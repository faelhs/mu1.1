; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\WhisperCash.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_7CWhisperCash@@6B@				; CWhisperCash::`vftable'
PUBLIC	??0CWhisperCash@@QAE@XZ				; CWhisperCash::CWhisperCash
PUBLIC	??_R4CWhisperCash@@6B@				; CWhisperCash::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCWhisperCash@@@8			; CWhisperCash `RTTI Type Descriptor'
PUBLIC	??_R3CWhisperCash@@8				; CWhisperCash::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWhisperCash@@8				; CWhisperCash::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CWhisperCash@@8			; CWhisperCash::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECWhisperCash@@UAEPAXI@Z:PROC		; CWhisperCash::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CWhisperCash@@8
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\whispercash.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CWhisperCash@@8 DD FLAT:??_R0?AVCWhisperCash@@@8 ; CWhisperCash::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWhisperCash@@8
rdata$r	ENDS
;	COMDAT ??_R2CWhisperCash@@8
rdata$r	SEGMENT
??_R2CWhisperCash@@8 DD FLAT:??_R1A@?0A@EA@CWhisperCash@@8 ; CWhisperCash::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CWhisperCash@@8
rdata$r	SEGMENT
??_R3CWhisperCash@@8 DD 00H				; CWhisperCash::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CWhisperCash@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWhisperCash@@@8
_DATA	SEGMENT
??_R0?AVCWhisperCash@@@8 DD FLAT:??_7type_info@@6B@	; CWhisperCash `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWhisperCash@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CWhisperCash@@6B@
rdata$r	SEGMENT
??_R4CWhisperCash@@6B@ DD 00H				; CWhisperCash::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCWhisperCash@@@8
	DD	FLAT:??_R3CWhisperCash@@8
rdata$r	ENDS
;	COMDAT ??_7CWhisperCash@@6B@
CONST	SEGMENT
??_7CWhisperCash@@6B@ DD FLAT:??_R4CWhisperCash@@6B@	; CWhisperCash::`vftable'
	DD	FLAT:??_ECWhisperCash@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0CWhisperCash@@QAE@XZ
_TEXT	SEGMENT
??0CWhisperCash@@QAE@XZ PROC				; CWhisperCash::CWhisperCash, COMDAT
; _this$ = ecx

; 16   : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CWhisperCash@@6B@

; 17   : 	return;
; 18   : }

  00008	c3		 ret	 0
??0CWhisperCash@@QAE@XZ ENDP				; CWhisperCash::CWhisperCash
_TEXT	ENDS
PUBLIC	??1CWhisperCash@@UAE@XZ				; CWhisperCash::~CWhisperCash
; Function compile flags: /Ogtp
;	COMDAT ??1CWhisperCash@@UAE@XZ
_TEXT	SEGMENT
??1CWhisperCash@@UAE@XZ PROC				; CWhisperCash::~CWhisperCash, COMDAT
; _this$ = ecx

; 22   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CWhisperCash@@6B@

; 23   : 	return;
; 24   : }

  00006	c3		 ret	 0
??1CWhisperCash@@UAE@XZ ENDP				; CWhisperCash::~CWhisperCash
_TEXT	ENDS
PUBLIC	?DelCash@CWhisperCash@@QAEXPAD@Z		; CWhisperCash::DelCash
; Function compile flags: /Ogtp
;	COMDAT ?DelCash@CWhisperCash@@QAEXPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?DelCash@CWhisperCash@@QAEXPAD@Z PROC			; CWhisperCash::DelCash, COMDAT
; _this$ = ecx

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 82   : 	int n = 0;
; 83   : 
; 84   : 	for (int n=0; n<2;n++)

  0000a	8d 71 08	 lea	 esi, DWORD PTR [ecx+8]
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  00010	33 ff		 xor	 edi, edi
$LL6@DelCash:

; 85   : 	{
; 86   : 		if ( this->WChash[n].Live == 1 )

  00012	83 7e fc 01	 cmp	 DWORD PTR [esi-4], 1
  00016	75 33		 jne	 SHORT $LN5@DelCash

; 87   : 		{
; 88   : 			if ( this->WChash[n].szId[0] == id[0] )

  00018	8a 06		 mov	 al, BYTE PTR [esi]
  0001a	3a 01		 cmp	 al, BYTE PTR [ecx]
  0001c	75 2d		 jne	 SHORT $LN5@DelCash

; 89   : 			{
; 90   : 				if ( strcmp(&this->WChash[n].szId[0], id) == 0)

  0001e	8b d1		 mov	 edx, ecx
  00020	8b c6		 mov	 eax, esi
$LL12@DelCash:
  00022	8a 18		 mov	 bl, BYTE PTR [eax]
  00024	3a 1a		 cmp	 bl, BYTE PTR [edx]
  00026	75 1a		 jne	 SHORT $LN13@DelCash
  00028	84 db		 test	 bl, bl
  0002a	74 12		 je	 SHORT $LN14@DelCash
  0002c	8a 58 01	 mov	 bl, BYTE PTR [eax+1]
  0002f	3a 5a 01	 cmp	 bl, BYTE PTR [edx+1]
  00032	75 0e		 jne	 SHORT $LN13@DelCash
  00034	83 c0 02	 add	 eax, 2
  00037	83 c2 02	 add	 edx, 2
  0003a	84 db		 test	 bl, bl
  0003c	75 e4		 jne	 SHORT $LL12@DelCash
$LN14@DelCash:
  0003e	33 c0		 xor	 eax, eax
  00040	eb 05		 jmp	 SHORT $LN15@DelCash
$LN13@DelCash:
  00042	1b c0		 sbb	 eax, eax
  00044	83 d8 ff	 sbb	 eax, -1
$LN15@DelCash:
  00047	85 c0		 test	 eax, eax
  00049	74 12		 je	 SHORT $LN10@DelCash
$LN5@DelCash:

; 82   : 	int n = 0;
; 83   : 
; 84   : 	for (int n=0; n<2;n++)

  0004b	47		 inc	 edi
  0004c	83 c6 18	 add	 esi, 24			; 00000018H
  0004f	83 ff 02	 cmp	 edi, 2
  00052	7c be		 jl	 SHORT $LL6@DelCash
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx

; 93   : 					return;
; 94   : 				}
; 95   : 			}
; 96   : 		}
; 97   : 	}
; 98   : }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
$LN10@DelCash:

; 91   : 				{
; 92   : 					this->WChash[n].Live = 0;

  0005d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00060	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	c7 44 ca 04 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*8+4], 0
  0006d	5b		 pop	 ebx

; 93   : 					return;
; 94   : 				}
; 95   : 			}
; 96   : 		}
; 97   : 	}
; 98   : }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
?DelCash@CWhisperCash@@QAEXPAD@Z ENDP			; CWhisperCash::DelCash
_TEXT	ENDS
PUBLIC	?SearchCash@CWhisperCash@@QAEHPAD@Z		; CWhisperCash::SearchCash
EXTRN	__imp__GetTickCount@0:PROC
; Function compile flags: /Ogtp
;	COMDAT ?SearchCash@CWhisperCash@@QAEHPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?SearchCash@CWhisperCash@@QAEHPAD@Z PROC		; CWhisperCash::SearchCash, COMDAT
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 102  : 	int n = 0;
; 103  : 
; 104  : 	for (int n=0; n<2;n++)

  0000a	8d 71 08	 lea	 esi, DWORD PTR [ecx+8]
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  00010	33 ff		 xor	 edi, edi
$LL6@SearchCash:

; 105  : 	{
; 106  : 		if ( this->WChash[n].Live == 1 )

  00012	83 7e fc 01	 cmp	 DWORD PTR [esi-4], 1
  00016	75 33		 jne	 SHORT $LN5@SearchCash

; 107  : 		{
; 108  : 			if ( this->WChash[n].szId[0] == id[0] )

  00018	8a 06		 mov	 al, BYTE PTR [esi]
  0001a	3a 01		 cmp	 al, BYTE PTR [ecx]
  0001c	75 2d		 jne	 SHORT $LN5@SearchCash

; 109  : 			{
; 110  : 				if ( strcmp(&this->WChash[n].szId[0], id) == 0)

  0001e	8b d1		 mov	 edx, ecx
  00020	8b c6		 mov	 eax, esi
$LL12@SearchCash:
  00022	8a 18		 mov	 bl, BYTE PTR [eax]
  00024	3a 1a		 cmp	 bl, BYTE PTR [edx]
  00026	75 1a		 jne	 SHORT $LN13@SearchCash
  00028	84 db		 test	 bl, bl
  0002a	74 12		 je	 SHORT $LN14@SearchCash
  0002c	8a 58 01	 mov	 bl, BYTE PTR [eax+1]
  0002f	3a 5a 01	 cmp	 bl, BYTE PTR [edx+1]
  00032	75 0e		 jne	 SHORT $LN13@SearchCash
  00034	83 c0 02	 add	 eax, 2
  00037	83 c2 02	 add	 edx, 2
  0003a	84 db		 test	 bl, bl
  0003c	75 e4		 jne	 SHORT $LL12@SearchCash
$LN14@SearchCash:
  0003e	33 c0		 xor	 eax, eax
  00040	eb 05		 jmp	 SHORT $LN15@SearchCash
$LN13@SearchCash:
  00042	1b c0		 sbb	 eax, eax
  00044	83 d8 ff	 sbb	 eax, -1
$LN15@SearchCash:
  00047	85 c0		 test	 eax, eax
  00049	74 15		 je	 SHORT $LN10@SearchCash
$LN5@SearchCash:

; 102  : 	int n = 0;
; 103  : 
; 104  : 	for (int n=0; n<2;n++)

  0004b	47		 inc	 edi
  0004c	83 c6 18	 add	 esi, 24			; 00000018H
  0004f	83 ff 02	 cmp	 edi, 2
  00052	7c be		 jl	 SHORT $LL6@SearchCash

; 114  : 				}
; 115  : 			}
; 116  : 		}
; 117  : 	}
; 118  : 	
; 119  : 	return -1;

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	83 c8 ff	 or	 eax, -1
  00059	5b		 pop	 ebx

; 120  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
$LN10@SearchCash:

; 111  : 				{
; 112  : 					this->WChash[n].m_Time = GetTickCount();

  00060	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00063	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00066	8d 34 ca	 lea	 esi, DWORD PTR [edx+ecx*8]
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0006f	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 113  : 					return this->WChash[n].m_Index ;

  00072	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx

; 120  : }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?SearchCash@CWhisperCash@@QAEHPAD@Z ENDP		; CWhisperCash::SearchCash
_TEXT	ENDS
PUBLIC	?TimeCheckCashDelete@CWhisperCash@@QAEXXZ	; CWhisperCash::TimeCheckCashDelete
; Function compile flags: /Ogtp
;	COMDAT ?TimeCheckCashDelete@CWhisperCash@@QAEXXZ
_TEXT	SEGMENT
?TimeCheckCashDelete@CWhisperCash@@QAEXXZ PROC		; CWhisperCash::TimeCheckCashDelete, COMDAT
; _this$ = ecx

; 123  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 124  : 	int n = 0;
; 125  : 	unsigned long CurTime = GetTickCount();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 126  : 
; 127  : 	for (int n=0;n<2;n++)
; 128  : 	{
; 129  : 		if ( this->WChash[n].Live == 1 )

  00009	b9 01 00 00 00	 mov	 ecx, 1
  0000e	33 d2		 xor	 edx, edx
  00010	39 4e 04	 cmp	 DWORD PTR [esi+4], ecx
  00013	75 12		 jne	 SHORT $LN4@TimeCheckC

; 130  : 		{
; 131  : 			if ( (CurTime-this->WChash[n].m_Time ) > 60000)

  00015	57		 push	 edi
  00016	8b f8		 mov	 edi, eax
  00018	2b 7e 18	 sub	 edi, DWORD PTR [esi+24]
  0001b	81 ff 60 ea 00
	00		 cmp	 edi, 60000		; 0000ea60H
  00021	5f		 pop	 edi
  00022	76 03		 jbe	 SHORT $LN4@TimeCheckC

; 132  : 			{
; 133  : 				this->WChash[n].Live=0;

  00024	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN4@TimeCheckC:

; 126  : 
; 127  : 	for (int n=0;n<2;n++)
; 128  : 	{
; 129  : 		if ( this->WChash[n].Live == 1 )

  00027	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  0002a	75 0d		 jne	 SHORT $LN14@TimeCheckC

; 130  : 		{
; 131  : 			if ( (CurTime-this->WChash[n].m_Time ) > 60000)

  0002c	2b 46 30	 sub	 eax, DWORD PTR [esi+48]
  0002f	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  00034	76 03		 jbe	 SHORT $LN14@TimeCheckC

; 132  : 			{
; 133  : 				this->WChash[n].Live=0;

  00036	89 56 1c	 mov	 DWORD PTR [esi+28], edx
$LN14@TimeCheckC:
  00039	5e		 pop	 esi

; 134  : 			}
; 135  : 		}
; 136  : 	}
; 137  : }

  0003a	c3		 ret	 0
?TimeCheckCashDelete@CWhisperCash@@QAEXXZ ENDP		; CWhisperCash::TimeCheckCashDelete
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCWhisperCash@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCWhisperCash@@UAEPAXI@Z PROC			; CWhisperCash::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CWhisperCash@@UAE@XZ	; CWhisperCash::~CWhisperCash
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCWhisperCash@@UAEPAXI@Z ENDP			; CWhisperCash::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?AddCash@CWhisperCash@@QAEHPAD@Z		; CWhisperCash::AddCash
EXTRN	?gObjGetIndex@@YAHPAD@Z:PROC			; gObjGetIndex
EXTRN	?gObjUserIdConnectCheck@@YAHPADH@Z:PROC		; gObjUserIdConnectCheck
; Function compile flags: /Ogtp
;	COMDAT ?AddCash@CWhisperCash@@QAEHPAD@Z
_TEXT	SEGMENT
_maxcount$ = -4						; size = 4
_result$ = 8						; size = 4
_id$ = 8						; size = 4
?AddCash@CWhisperCash@@QAEHPAD@Z PROC			; CWhisperCash::AddCash, COMDAT
; _this$ = ecx

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 29   : 	int count =0;
; 30   : 	int maxcount = 2;
; 31   : 	int result;
; 32   : 
; 33   : 	result=this->SearchCash(id);

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _id$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	53		 push	 ebx
  0000b	8b f9		 mov	 edi, ecx
  0000d	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _maxcount$[ebp], 2
  00014	e8 00 00 00 00	 call	 ?SearchCash@CWhisperCash@@QAEHPAD@Z ; CWhisperCash::SearchCash
  00019	8b f0		 mov	 esi, eax

; 34   : 
; 35   : 	if (result != -1)

  0001b	83 fe ff	 cmp	 esi, -1
  0001e	74 25		 je	 SHORT $LN8@AddCash

; 36   : 	{
; 37   : 		if (gObjUserIdConnectCheck(id,result) == 0)

  00020	56		 push	 esi
  00021	53		 push	 ebx
  00022	e8 00 00 00 00	 call	 ?gObjUserIdConnectCheck@@YAHPADH@Z ; gObjUserIdConnectCheck
  00027	83 c4 08	 add	 esp, 8
  0002a	85 c0		 test	 eax, eax
  0002c	75 0c		 jne	 SHORT $LN7@AddCash
$LN15@AddCash:
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 38   : 		{
; 39   : 			return -1;

  00030	83 c8 ff	 or	 eax, -1
  00033	5b		 pop	 ebx

; 78   : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
$LN7@AddCash:
  0003a	5f		 pop	 edi

; 40   : 		}
; 41   : 		return result;

  0003b	8b c6		 mov	 eax, esi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 78   : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN8@AddCash:

; 42   : 	}
; 43   : 
; 44   : 	result=gObjGetIndex(id);

  00045	53		 push	 ebx
  00046	e8 00 00 00 00	 call	 ?gObjGetIndex@@YAHPAD@Z	; gObjGetIndex
  0004b	8b c8		 mov	 ecx, eax
  0004d	83 c4 04	 add	 esp, 4
  00050	89 4d 08	 mov	 DWORD PTR _result$[ebp], ecx

; 45   : 
; 46   : 	if (result == -1)

  00053	83 f9 ff	 cmp	 ecx, -1

; 47   : 	{
; 48   : 		return -1;

  00056	74 d6		 je	 SHORT $LN15@AddCash

; 49   : 	}
; 50   : 
; 51   : 	count=this->WChashCount ;

  00058	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  0005b	eb 03 8d 49 00	 npad	 5
$LL5@AddCash:

; 52   : 
; 53   : 	while ( maxcount-- != 0)

  00060	ba 01 00 00 00	 mov	 edx, 1
  00065	29 55 fc	 sub	 DWORD PTR _maxcount$[ebp], edx

; 54   : 	{
; 55   : 		count++;

  00068	03 c2		 add	 eax, edx

; 56   : 
; 57   : 		if (count > 1)

  0006a	3b c2		 cmp	 eax, edx
  0006c	7e 02		 jle	 SHORT $LN14@AddCash

; 58   : 		{
; 59   : 			count=0;

  0006e	33 c0		 xor	 eax, eax
$LN14@AddCash:

; 60   : 		}
; 61   : 
; 62   : 		if ( this->WChash[count].Live == 0 )

  00070	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  00073	83 7c f7 04 00	 cmp	 DWORD PTR [edi+esi*8+4], 0
  00078	74 11		 je	 SHORT $LN12@AddCash

; 52   : 
; 53   : 	while ( maxcount-- != 0)

  0007a	83 7d fc 00	 cmp	 DWORD PTR _maxcount$[ebp], 0
  0007e	75 e0		 jne	 SHORT $LL5@AddCash

; 75   : 		}
; 76   : 	}
; 77   : 	return result;

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	8b c1		 mov	 eax, ecx
  00084	5b		 pop	 ebx

; 78   : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
$LN12@AddCash:

; 63   : 		{
; 64   : 			memcpy(&this->WChash[count].szId[0], id, 10 );

  0008b	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0008e	8d 34 c7	 lea	 esi, DWORD PTR [edi+eax*8]
  00091	8b 03		 mov	 eax, DWORD PTR [ebx]
  00093	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00096	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00099	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0009c	66 8b 43 08	 mov	 ax, WORD PTR [ebx+8]
  000a0	66 89 46 10	 mov	 WORD PTR [esi+16], ax

; 65   : 			this->WChash[count].Live = 1;

  000a4	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 66   : 			this->WChash[count].m_Index = result;

  000a7	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 67   : 			this->WChash[count].m_Time = GetTickCount();

  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000b0	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 68   : 			this->WChashCount++;

  000b3	b8 01 00 00 00	 mov	 eax, 1
  000b8	01 47 34	 add	 DWORD PTR [edi+52], eax

; 69   : 
; 70   : 			if ( this->WChashCount > 1)

  000bb	39 47 34	 cmp	 DWORD PTR [edi+52], eax
  000be	7e 07		 jle	 SHORT $LN1@AddCash

; 71   : 			{
; 72   : 				this->WChashCount = 0;

  000c0	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
$LN1@AddCash:

; 73   : 			}
; 74   : 			return result;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx

; 78   : }

  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 04 00	 ret	 4
?AddCash@CWhisperCash@@QAEHPAD@Z ENDP			; CWhisperCash::AddCash
_TEXT	ENDS
END
