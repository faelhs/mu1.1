; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\DarkSpirit.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
_g_sttCHAOSCASTLE_LEVEL DD 0aH
	DD	031H
	DD	0aH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_DATA	ENDS
PUBLIC	??_7CDarkSpirit@@6B@				; CDarkSpirit::`vftable'
PUBLIC	??1CDarkSpirit@@UAE@XZ				; CDarkSpirit::~CDarkSpirit
PUBLIC	??_R4CDarkSpirit@@6B@				; CDarkSpirit::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDarkSpirit@@@8				; CDarkSpirit `RTTI Type Descriptor'
PUBLIC	??_R3CDarkSpirit@@8				; CDarkSpirit::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDarkSpirit@@8				; CDarkSpirit::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDarkSpirit@@8			; CDarkSpirit::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CObjBaseAttack@@8			; CObjBaseAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCObjBaseAttack@@@8			; CObjBaseAttack `RTTI Type Descriptor'
PUBLIC	??_R3CObjBaseAttack@@8				; CObjBaseAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObjBaseAttack@@8				; CObjBaseAttack::`RTTI Base Class Array'
EXTRN	??1CObjBaseAttack@@UAE@XZ:PROC			; CObjBaseAttack::~CObjBaseAttack
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECDarkSpirit@@UAEPAXI@Z:PROC			; CDarkSpirit::`vector deleting destructor'
EXTRN	?MissCheck@CObjBaseAttack@@UAEHPAUOBJECTSTRUCT@@0HHHAAH@Z:PROC ; CObjBaseAttack::MissCheck
;	COMDAT ??_R2CObjBaseAttack@@8
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\darkspirit.cpp
rdata$r	SEGMENT
??_R2CObjBaseAttack@@8 DD FLAT:??_R1A@?0A@EA@CObjBaseAttack@@8 ; CObjBaseAttack::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObjBaseAttack@@8
rdata$r	SEGMENT
??_R3CObjBaseAttack@@8 DD 00H				; CObjBaseAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObjBaseAttack@@@8
_DATA	SEGMENT
??_R0?AVCObjBaseAttack@@@8 DD FLAT:??_7type_info@@6B@	; CObjBaseAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObjBaseAttack@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CObjBaseAttack@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObjBaseAttack@@8 DD FLAT:??_R0?AVCObjBaseAttack@@@8 ; CObjBaseAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CDarkSpirit@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDarkSpirit@@8 DD FLAT:??_R0?AVCDarkSpirit@@@8 ; CDarkSpirit::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDarkSpirit@@8
rdata$r	ENDS
;	COMDAT ??_R2CDarkSpirit@@8
rdata$r	SEGMENT
??_R2CDarkSpirit@@8 DD FLAT:??_R1A@?0A@EA@CDarkSpirit@@8 ; CDarkSpirit::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_R3CDarkSpirit@@8
rdata$r	SEGMENT
??_R3CDarkSpirit@@8 DD 00H				; CDarkSpirit::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CDarkSpirit@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDarkSpirit@@@8
_DATA	SEGMENT
??_R0?AVCDarkSpirit@@@8 DD FLAT:??_7type_info@@6B@	; CDarkSpirit `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDarkSpirit@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CDarkSpirit@@6B@
rdata$r	SEGMENT
??_R4CDarkSpirit@@6B@ DD 00H				; CDarkSpirit::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDarkSpirit@@@8
	DD	FLAT:??_R3CDarkSpirit@@8
rdata$r	ENDS
;	COMDAT ??_7CDarkSpirit@@6B@
CONST	SEGMENT
??_7CDarkSpirit@@6B@ DD FLAT:??_R4CDarkSpirit@@6B@	; CDarkSpirit::`vftable'
	DD	FLAT:??_ECDarkSpirit@@UAEPAXI@Z
	DD	FLAT:?MissCheck@CObjBaseAttack@@UAEHPAUOBJECTSTRUCT@@0HHHAAH@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1CDarkSpirit@@UAE@XZ
_TEXT	SEGMENT
??1CDarkSpirit@@UAE@XZ PROC				; CDarkSpirit::~CDarkSpirit, COMDAT
; _this$ = ecx

; 24   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CDarkSpirit@@6B@

; 25   : 	return;
; 26   : }

  00006	e9 00 00 00 00	 jmp	 ??1CObjBaseAttack@@UAE@XZ ; CObjBaseAttack::~CObjBaseAttack
??1CDarkSpirit@@UAE@XZ ENDP				; CDarkSpirit::~CDarkSpirit
_TEXT	ENDS
PUBLIC	?Init@CDarkSpirit@@QAEXXZ			; CDarkSpirit::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@CDarkSpirit@@QAEXXZ
_TEXT	SEGMENT
?Init@CDarkSpirit@@QAEXXZ PROC				; CDarkSpirit::Init, COMDAT
; _this$ = ecx

; 30   : 	this->m_AttackDamageMin = 0;

  00000	33 c0		 xor	 eax, eax

; 31   : 	this->m_AttackDamageMax = 0;
; 32   : 	this->m_AttackSpeed = 0;
; 33   : 	this->m_SuccessAttackRate = 0;
; 34   : 	this->m_dwLastAttackTime = 0;
; 35   : 	this->m_iMasterIndex = -1;

  00002	83 ca ff	 or	 edx, -1
  00005	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00008	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0000b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0000e	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00011	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00014	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 36   : 	this->m_iTargetIndex = -1;

  00017	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 37   : 	this->m_pPetItem = NULL;

  0001a	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 38   : }

  0001d	c3		 ret	 0
?Init@CDarkSpirit@@QAEXXZ ENDP				; CDarkSpirit::Init
_TEXT	ENDS
PUBLIC	?ModeNormal@CDarkSpirit@@QAEXXZ			; CDarkSpirit::ModeNormal
; Function compile flags: /Ogtp
;	COMDAT ?ModeNormal@CDarkSpirit@@QAEXXZ
_TEXT	SEGMENT
?ModeNormal@CDarkSpirit@@QAEXXZ PROC			; CDarkSpirit::ModeNormal, COMDAT
; _this$ = ecx

; 100  : 	LPOBJ lpObj = &gObj[this->m_iMasterIndex];
; 101  : }

  00000	c3		 ret	 0
?ModeNormal@CDarkSpirit@@QAEXXZ ENDP			; CDarkSpirit::ModeNormal
_TEXT	ENDS
PUBLIC	?SetTarget@CDarkSpirit@@QAEXH@Z			; CDarkSpirit::SetTarget
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:BYTE			; gObj
; Function compile flags: /Ogtp
;	COMDAT ?SetTarget@CDarkSpirit@@QAEXH@Z
_TEXT	SEGMENT
_aTargetIndex$ = 8					; size = 4
?SetTarget@CDarkSpirit@@QAEXH@Z PROC			; CDarkSpirit::SetTarget, COMDAT
; _this$ = ecx

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 420  : 	if ( this->m_iMasterIndex == -1 )

  00003	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00006	83 f8 ff	 cmp	 eax, -1
  00009	74 16		 je	 SHORT $LN3@SetTarget

; 421  : 	{
; 422  : 		return;
; 423  : 	}
; 424  : 
; 425  : 	LPOBJ lpObj = &gObj[this->m_iMasterIndex];

  0000b	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 426  : 
; 427  : 	if ( lpObj->Class != 4 )	// DL

  00011	66 83 b8 98 00
	00 00 04	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+152], 4
  00019	75 06		 jne	 SHORT $LN3@SetTarget

; 428  : 	{
; 429  : 		return;
; 430  : 	}
; 431  : 
; 432  : 	this->m_iTargetIndex = aTargetIndex;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0001e	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN3@SetTarget:

; 433  : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?SetTarget@CDarkSpirit@@QAEXH@Z ENDP			; CDarkSpirit::SetTarget
_TEXT	ENDS
PUBLIC	?GetAttackDamage@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@HHH@Z ; CDarkSpirit::GetAttackDamage
EXTRN	_rand:PROC
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GetAttackDamage@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_targetDefense$ = 12					; size = 4
_bIsOnDuel$ = 16					; size = 4
_damage$155729 = 20					; size = 4
_crititcaldamage$ = 20					; size = 4
?GetAttackDamage@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@HHH@Z PROC ; CDarkSpirit::GetAttackDamage, COMDAT
; _this$ = ecx

; 1108 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 1109 : 	int ad;
; 1110 : 	int sub = this->m_AttackDamageMax - this->m_AttackDamageMin;

  00007	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000a	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  0000d	2b f0		 sub	 esi, eax

; 1111 : 	int AttackDamage;
; 1112 : 
; 1113 : 	if ( crititcaldamage )

  0000f	83 7d 14 00	 cmp	 DWORD PTR _crititcaldamage$[ebp], 0
  00013	74 04		 je	 SHORT $LN7@GetAttackD

; 1114 : 	{
; 1115 : 		AttackDamage = this->m_AttackDamageMin + sub;

  00015	03 f0		 add	 esi, eax

; 1116 : 	}
; 1117 : 	else

  00017	eb 0e		 jmp	 SHORT $LN6@GetAttackD
$LN7@GetAttackD:

; 1118 : 	{
; 1119 : 		AttackDamage = this->m_AttackDamageMin + (rand()%(sub+1));

  00019	e8 00 00 00 00	 call	 _rand
  0001e	46		 inc	 esi
  0001f	99		 cdq
  00020	f7 fe		 idiv	 esi
  00022	8b f2		 mov	 esi, edx
  00024	03 77 04	 add	 esi, DWORD PTR [edi+4]
$LN6@GetAttackD:

; 1120 : 	}
; 1121 : 
; 1122 : 	if ( ( lpObj->pInventory[0].m_Type >= ITEMGET(2,8) && lpObj->pInventory[0].m_Type <= ITEMGET(2,12) ) ||
; 1123 : 		   lpObj->pInventory[0].m_Type == ITEMGET(2,13) ||
; 1124 : 		   lpObj->pInventory[0].m_Type == ITEMGET(2,14) ||
; 1125 : 		   lpObj->pInventory[0].m_Type == ITEMGET(2,15) )

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0002a	8b 81 8c 0c 00
	00		 mov	 eax, DWORD PTR [ecx+3212]
  00030	0f b7 40 06	 movzx	 eax, WORD PTR [eax+6]
  00034	ba 08 04 00 00	 mov	 edx, 1032		; 00000408H
  00039	66 3b c2	 cmp	 ax, dx
  0003c	7c 0a		 jl	 SHORT $LN3@GetAttackD
  0003e	ba 0c 04 00 00	 mov	 edx, 1036		; 0000040cH
  00043	66 3b c2	 cmp	 ax, dx
  00046	7e 1e		 jle	 SHORT $LN4@GetAttackD
$LN3@GetAttackD:
  00048	ba 0d 04 00 00	 mov	 edx, 1037		; 0000040dH
  0004d	66 3b c2	 cmp	 ax, dx
  00050	74 14		 je	 SHORT $LN4@GetAttackD
  00052	ba 0e 04 00 00	 mov	 edx, 1038		; 0000040eH
  00057	66 3b c2	 cmp	 ax, dx
  0005a	74 0a		 je	 SHORT $LN4@GetAttackD
  0005c	ba 0f 04 00 00	 mov	 edx, 1039		; 0000040fH
  00061	66 3b c2	 cmp	 ax, dx
  00064	75 3a		 jne	 SHORT $LN5@GetAttackD
$LN4@GetAttackD:

; 1126 : 	{
; 1127 : 		int damage = lpObj->pInventory[0].m_Magic / 2;

  00066	8b 81 8c 0c 00
	00		 mov	 eax, DWORD PTR [ecx+3212]
  0006c	0f b7 48 20	 movzx	 ecx, WORD PTR [eax+32]
  00070	d1 e9		 shr	 ecx, 1
  00072	89 4d 14	 mov	 DWORD PTR _damage$155729[ebp], ecx

; 1128 : 		damage -= damage * lpObj->pInventory[0].m_CurrentDurabilityState;
; 1129 : 		damage = AttackDamage * damage / 100;
; 1130 : 		AttackDamage += damage;

  00075	db 45 14	 fild	 DWORD PTR _damage$155729[ebp]
  00078	d9 80 8c 00 00
	00		 fld	 DWORD PTR [eax+140]
  0007e	da 4d 14	 fimul	 DWORD PTR _damage$155729[ebp]
  00081	de e9		 fsubp	 ST(1), ST(0)
  00083	e8 00 00 00 00	 call	 __ftol2_sse
  00088	8b c8		 mov	 ecx, eax
  0008a	0f af ce	 imul	 ecx, esi
  0008d	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00092	f7 e9		 imul	 ecx
  00094	c1 fa 05	 sar	 edx, 5
  00097	8b c2		 mov	 eax, edx
  00099	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0009c	03 c2		 add	 eax, edx
  0009e	03 f0		 add	 esi, eax
$LN5@GetAttackD:

; 1131 : 	}
; 1132 : 
; 1133 : 	if ( bIsOnDuel )

  000a0	83 7d 10 00	 cmp	 DWORD PTR _bIsOnDuel$[ebp], 0
  000a4	74 25		 je	 SHORT $LN2@GetAttackD

; 1134 : 	{
; 1135 : 		ad = AttackDamage * 60 / 100 - targetDefense;

  000a6	8b ce		 mov	 ecx, esi
  000a8	c1 e1 04	 shl	 ecx, 4
  000ab	2b ce		 sub	 ecx, esi
  000ad	03 c9		 add	 ecx, ecx
  000af	03 c9		 add	 ecx, ecx
  000b1	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000b6	f7 e9		 imul	 ecx
  000b8	c1 fa 05	 sar	 edx, 5
  000bb	8b c2		 mov	 eax, edx
  000bd	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000c0	03 c2		 add	 eax, edx
  000c2	2b 45 0c	 sub	 eax, DWORD PTR _targetDefense$[ebp]
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi

; 1140 : 	}
; 1141 : 
; 1142 : 	return ad;
; 1143 : }

  000c7	5d		 pop	 ebp
  000c8	c2 10 00	 ret	 16			; 00000010H
$LN2@GetAttackD:

; 1136 : 	}
; 1137 : 	else
; 1138 : 	{
; 1139 : 		ad = AttackDamage - targetDefense;

  000cb	2b 75 0c	 sub	 esi, DWORD PTR _targetDefense$[ebp]
  000ce	5f		 pop	 edi
  000cf	8b c6		 mov	 eax, esi
  000d1	5e		 pop	 esi

; 1140 : 	}
; 1141 : 
; 1142 : 	return ad;
; 1143 : }

  000d2	5d		 pop	 ebp
  000d3	c2 10 00	 ret	 16			; 00000010H
?GetAttackDamage@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@HHH@Z ENDP ; CDarkSpirit::GetAttackDamage
_TEXT	ENDS
PUBLIC	?MissCheck@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0HHAAH@Z ; CDarkSpirit::MissCheck
EXTRN	?GCDamageSend@@YAXHHHHH@Z:PROC			; GCDamageSend
; Function compile flags: /Ogtp
;	COMDAT ?MissCheck@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0HHAAH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_skill$ = 16						; size = 4
_skillSuccess$ = 20					; size = 4
_bAllMiss$ = 24						; size = 4
?MissCheck@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0HHAAH@Z PROC ; CDarkSpirit::MissCheck, COMDAT
; _this$ = ecx

; 1146 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1147 : 	int SuccessAttackRate = 0;
; 1148 : 	int TargetSuccessfulBlocking = lpTargetObj->m_SuccessfulBlocking;

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _lpTargetObj$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 1149 : 	int MsgDamage = 0;
; 1150 : 
; 1151 : 	if ( this->m_SuccessAttackRate < TargetSuccessfulBlocking )

  0000a	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000d	57		 push	 edi
  0000e	8b bb 18 03 00
	00		 mov	 edi, DWORD PTR [ebx+792]
  00014	3b c7		 cmp	 eax, edi
  00016	7d 0b		 jge	 SHORT $LN6@MissCheck

; 1152 : 	{
; 1153 : 		bAllMiss = TRUE;

  00018	8b 45 18	 mov	 eax, DWORD PTR _bAllMiss$[ebp]
  0001b	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 1154 : 	}
; 1155 : 
; 1156 : 	if ( bAllMiss != FALSE )

  00021	eb 08		 jmp	 SHORT $LN9@MissCheck
$LN6@MissCheck:
  00023	8b 4d 18	 mov	 ecx, DWORD PTR _bAllMiss$[ebp]
  00026	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00029	74 32		 je	 SHORT $LN5@MissCheck
$LN9@MissCheck:

; 1157 : 	{
; 1158 : 		if ( (rand()%100) >= 5 )

  0002b	e8 00 00 00 00	 call	 _rand
  00030	99		 cdq
  00031	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00036	f7 f9		 idiv	 ecx
  00038	83 fa 05	 cmp	 edx, 5
  0003b	7c 31		 jl	 SHORT $LN10@MissCheck
$LN11@MissCheck:

; 1159 : 		{
; 1160 : 			GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, 0, MsgDamage);

  0003d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0003f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	6a 00		 push	 0
  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	52		 push	 edx
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  00051	83 c4 14	 add	 esp, 20			; 00000014H
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 1161 : 			return FALSE;

  00056	33 c0		 xor	 eax, eax
  00058	5b		 pop	 ebx

; 1174 : }

  00059	5d		 pop	 ebp
  0005a	c2 14 00	 ret	 20			; 00000014H
$LN5@MissCheck:

; 1162 : 		}
; 1163 : 	}
; 1164 : 	else if ( this->m_SuccessAttackRate )

  0005d	85 c0		 test	 eax, eax
  0005f	74 0d		 je	 SHORT $LN10@MissCheck

; 1165 : 	{
; 1166 : 		if ( (rand()%this->m_SuccessAttackRate) < TargetSuccessfulBlocking)

  00061	e8 00 00 00 00	 call	 _rand
  00066	99		 cdq
  00067	f7 7e 10	 idiv	 DWORD PTR [esi+16]
  0006a	3b d7		 cmp	 edx, edi

; 1167 : 		{
; 1168 : 			GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, 0, MsgDamage);
; 1169 : 			return FALSE;

  0006c	7c cf		 jl	 SHORT $LN11@MissCheck
$LN10@MissCheck:
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi

; 1170 : 		}
; 1171 : 	}
; 1172 : 
; 1173 : 	return TRUE;

  00070	b8 01 00 00 00	 mov	 eax, 1
  00075	5b		 pop	 ebx

; 1174 : }

  00076	5d		 pop	 ebp
  00077	c2 14 00	 ret	 20			; 00000014H
?MissCheck@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0HHAAH@Z ENDP ; CDarkSpirit::MissCheck
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	__real@40c3880000000000
PUBLIC	__real@00000000
PUBLIC	?MissCheckPvP@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0HHAAH@Z ; CDarkSpirit::MissCheckPvP
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@40c3880000000000
CONST	SEGMENT
__real@40c3880000000000 DQ 040c3880000000000r	; 10000
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?MissCheckPvP@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0HHAAH@Z
_TEXT	SEGMENT
_iDefenseRate$ = -8					; size = 4
_iAttackRate$ = -4					; size = 4
tv334 = 8						; size = 4
tv320 = 8						; size = 4
tv314 = 8						; size = 4
tv308 = 8						; size = 4
tv303 = 8						; size = 4
tv299 = 8						; size = 4
tv298 = 8						; size = 4
tv295 = 8						; size = 4
tv294 = 8						; size = 4
tv288 = 8						; size = 4
tv286 = 8						; size = 4
tv282 = 8						; size = 4
tv255 = 8						; size = 4
tv192 = 8						; size = 4
_iAttackSuccessRate$ = 8				; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_skill$ = 16						; size = 4
_skillSuccess$ = 20					; size = 4
_bAllMiss$ = 24						; size = 4
?MissCheckPvP@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0HHAAH@Z PROC ; CDarkSpirit::MissCheckPvP, COMDAT
; _this$ = ecx

; 1177 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1178 : 	float iAttackRate = 0;

  00006	d9 ee		 fldz
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	d9 55 fc	 fst	 DWORD PTR _iAttackRate$[ebp]

; 1179 : 	float iDefenseRate = 0;
; 1180 : 	int iAttackSuccessRate = 0;
; 1181 : 
; 1182 : 	if ( lpObj->Class == CLASS_KNIGHT )

  0000d	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00010	d9 55 f8	 fst	 DWORD PTR _iDefenseRate$[ebp]
  00013	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  0001a	83 f8 01	 cmp	 eax, 1
  0001d	75 32		 jne	 SHORT $LN26@MissCheckP

; 1183 : 	{
; 1184 : 		iAttackRate = lpObj->Level * 3 + ( lpObj->Dexterity * 45) / 10;	// #formula

  0001f	0f b7 8e b6 00
	00 00		 movzx	 ecx, WORD PTR [esi+182]
  00026	6b c9 2d	 imul	 ecx, 45			; 0000002dH
  00029	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0002e	f7 e9		 imul	 ecx
  00030	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  00037	c1 fa 02	 sar	 edx, 2
  0003a	8b ca		 mov	 ecx, edx
  0003c	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0003f	03 ca		 add	 ecx, edx
  00041	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00044	03 ca		 add	 ecx, edx
  00046	89 4d 08	 mov	 DWORD PTR tv314[ebp], ecx
  00049	db 45 08	 fild	 DWORD PTR tv314[ebp]
  0004c	e9 ad 00 00 00	 jmp	 $LN71@MissCheckP
$LN26@MissCheckP:

; 1185 : 	}
; 1186 : 	else if ( lpObj->Class == CLASS_DARKLORD )

  00051	83 f8 04	 cmp	 eax, 4
  00054	75 1f		 jne	 SHORT $LN24@MissCheckP

; 1187 : 	{
; 1188 : 		iAttackRate = lpObj->Level * 3 + ( lpObj->Dexterity * 4 );	// #formula

  00056	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  0005d	0f b7 8e b6 00
	00 00		 movzx	 ecx, WORD PTR [esi+182]
  00064	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00067	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0006a	89 45 08	 mov	 DWORD PTR tv308[ebp], eax
  0006d	db 45 08	 fild	 DWORD PTR tv308[ebp]
  00070	e9 89 00 00 00	 jmp	 $LN71@MissCheckP
$LN24@MissCheckP:

; 1189 : 	}
; 1190 : 	else if ( lpObj->Class == CLASS_ELF )

  00075	83 f8 02	 cmp	 eax, 2
  00078	75 31		 jne	 SHORT $LN22@MissCheckP

; 1191 : 	{
; 1192 : 		iAttackRate = lpObj->Level * 3 + ( lpObj->Dexterity * 6 ) / 10;	// #formula

  0007a	0f b7 86 b6 00
	00 00		 movzx	 eax, WORD PTR [esi+182]
  00081	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00084	03 c9		 add	 ecx, ecx
  00086	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0008b	f7 e9		 imul	 ecx
  0008d	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  00094	c1 fa 02	 sar	 edx, 2
  00097	8b ca		 mov	 ecx, edx
  00099	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0009c	03 ca		 add	 ecx, edx
  0009e	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  000a1	03 ca		 add	 ecx, edx
  000a3	89 4d 08	 mov	 DWORD PTR tv303[ebp], ecx
  000a6	db 45 08	 fild	 DWORD PTR tv303[ebp]
  000a9	eb 53		 jmp	 SHORT $LN71@MissCheckP
$LN22@MissCheckP:

; 1193 : 	}
; 1194 : 	else if ( lpObj->Class == CLASS_MAGUMSA )

  000ab	83 f8 03	 cmp	 eax, 3
  000ae	75 2f		 jne	 SHORT $LN20@MissCheckP

; 1195 : 	{
; 1196 : 		iAttackRate = lpObj->Level * 3 + ( lpObj->Dexterity * 35 ) / 10;	// #formula

  000b0	0f b7 8e b6 00
	00 00		 movzx	 ecx, WORD PTR [esi+182]
  000b7	6b c9 23	 imul	 ecx, 35			; 00000023H
  000ba	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  000bf	f7 e9		 imul	 ecx
  000c1	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  000c8	c1 fa 02	 sar	 edx, 2
  000cb	8b ca		 mov	 ecx, edx
  000cd	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000d0	03 ca		 add	 ecx, edx
  000d2	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  000d5	03 ca		 add	 ecx, edx
  000d7	89 4d 08	 mov	 DWORD PTR tv299[ebp], ecx
  000da	db 45 08	 fild	 DWORD PTR tv299[ebp]
  000dd	eb 1f		 jmp	 SHORT $LN71@MissCheckP
$LN20@MissCheckP:

; 1197 : 	}
; 1198 : 	else if ( lpObj->Class == CLASS_WIZARD )

  000df	66 85 c0	 test	 ax, ax
  000e2	75 1d		 jne	 SHORT $LN18@MissCheckP

; 1199 : 	{
; 1200 : 		iAttackRate = lpObj->Level * 3 + ( lpObj->Dexterity * 4 );	// #formula

  000e4	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  000eb	0f b7 8e b6 00
	00 00		 movzx	 ecx, WORD PTR [esi+182]
  000f2	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  000f5	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000f8	89 45 08	 mov	 DWORD PTR tv298[ebp], eax
  000fb	db 45 08	 fild	 DWORD PTR tv298[ebp]
$LN71@MissCheckP:
  000fe	d9 5d fc	 fstp	 DWORD PTR _iAttackRate$[ebp]
$LN18@MissCheckP:

; 1201 : 	}
; 1202 : 
; 1203 : 	if ( lpTargetObj->Class == CLASS_KNIGHT )

  00101	8b 5d 0c	 mov	 ebx, DWORD PTR _lpTargetObj$[ebp]
  00104	0f b7 83 98 00
	00 00		 movzx	 eax, WORD PTR [ebx+152]
  0010b	83 f8 01	 cmp	 eax, 1
  0010e	75 1e		 jne	 SHORT $LN17@MissCheckP

; 1204 : 	{
; 1205 : 		iDefenseRate = lpTargetObj->Level * 2 + lpTargetObj->Dexterity / 2;	// #formula

  00110	0f b7 8b b6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+182]
  00117	0f bf 93 9c 00
	00 00		 movsx	 edx, WORD PTR [ebx+156]
  0011e	d1 e9		 shr	 ecx, 1
  00120	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00123	89 45 08	 mov	 DWORD PTR tv295[ebp], eax
  00126	db 45 08	 fild	 DWORD PTR tv295[ebp]
  00129	e9 8f 00 00 00	 jmp	 $LN72@MissCheckP
$LN17@MissCheckP:

; 1206 : 	}
; 1207 : 	else if ( lpTargetObj->Class == CLASS_DARKLORD )

  0012e	83 f8 04	 cmp	 eax, 4
  00131	75 1b		 jne	 SHORT $LN15@MissCheckP

; 1208 : 	{
; 1209 : 		iDefenseRate = lpTargetObj->Level * 2 + lpTargetObj->Dexterity / 2;	// #formula

  00133	0f b7 8b b6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+182]
  0013a	0f bf 93 9c 00
	00 00		 movsx	 edx, WORD PTR [ebx+156]
  00141	d1 e9		 shr	 ecx, 1
  00143	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00146	89 45 08	 mov	 DWORD PTR tv294[ebp], eax
  00149	db 45 08	 fild	 DWORD PTR tv294[ebp]
  0014c	eb 6f		 jmp	 SHORT $LN72@MissCheckP
$LN15@MissCheckP:

; 1210 : 	}
; 1211 : 	else if ( lpTargetObj->Class == CLASS_ELF )

  0014e	83 f8 02	 cmp	 eax, 2
  00151	75 2a		 jne	 SHORT $LN13@MissCheckP

; 1212 : 	{
; 1213 : 		iDefenseRate = lpTargetObj->Level * 2 + lpTargetObj->Dexterity / 10;	// #formula

  00153	0f b7 8b b6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+182]
  0015a	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0015f	f7 e9		 imul	 ecx
  00161	c1 fa 02	 sar	 edx, 2
  00164	8b ca		 mov	 ecx, edx
  00166	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00169	03 ca		 add	 ecx, edx
  0016b	0f bf 93 9c 00
	00 00		 movsx	 edx, WORD PTR [ebx+156]
  00172	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00175	89 45 08	 mov	 DWORD PTR tv288[ebp], eax
  00178	db 45 08	 fild	 DWORD PTR tv288[ebp]
  0017b	eb 40		 jmp	 SHORT $LN72@MissCheckP
$LN13@MissCheckP:

; 1214 : 	}
; 1215 : 	else if ( lpTargetObj->Class == CLASS_MAGUMSA )

  0017d	83 f8 03	 cmp	 eax, 3
  00180	75 1c		 jne	 SHORT $LN11@MissCheckP

; 1216 : 	{
; 1217 : 		iDefenseRate = lpTargetObj->Level * 2 + lpTargetObj->Dexterity / 4;	// #formula

  00182	0f b7 8b b6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+182]
  00189	0f bf 93 9c 00
	00 00		 movsx	 edx, WORD PTR [ebx+156]
  00190	c1 e9 02	 shr	 ecx, 2
  00193	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00196	89 45 08	 mov	 DWORD PTR tv286[ebp], eax
  00199	db 45 08	 fild	 DWORD PTR tv286[ebp]
  0019c	eb 1f		 jmp	 SHORT $LN72@MissCheckP
$LN11@MissCheckP:

; 1218 : 	}
; 1219 : 	else if ( lpTargetObj->Class == CLASS_WIZARD )

  0019e	66 85 c0	 test	 ax, ax
  001a1	75 1d		 jne	 SHORT $LN9@MissCheckP

; 1220 : 	{
; 1221 : 		iDefenseRate = lpTargetObj->Level * 2 + lpTargetObj->Dexterity / 4;	// #formula

  001a3	0f b7 8b b6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+182]
  001aa	0f bf 93 9c 00
	00 00		 movsx	 edx, WORD PTR [ebx+156]
  001b1	c1 e9 02	 shr	 ecx, 2
  001b4	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  001b7	89 45 08	 mov	 DWORD PTR tv282[ebp], eax
  001ba	db 45 08	 fild	 DWORD PTR tv282[ebp]
$LN72@MissCheckP:
  001bd	d9 5d f8	 fstp	 DWORD PTR _iDefenseRate$[ebp]
$LN9@MissCheckP:

; 1222 : 	}
; 1223 : 
; 1224 : 	if ( iAttackRate <= 0.0f || iDefenseRate <= 0.0f || lpObj->Level <= 0 || (DWORD)lpTargetObj <= 0 )	// #error lpTargetObj

  001c0	d9 45 fc	 fld	 DWORD PTR _iAttackRate$[ebp]
  001c3	d8 d1		 fcom	 ST(1)
  001c5	df e0		 fnstsw	 ax
  001c7	f6 c4 41	 test	 ah, 65			; 00000041H
  001ca	0f 8b fe 00 00
	00		 jnp	 $LN38@MissCheckP
  001d0	d9 45 f8	 fld	 DWORD PTR _iDefenseRate$[ebp]
  001d3	d8 d2		 fcom	 ST(2)
  001d5	df e0		 fnstsw	 ax
  001d7	dd da		 fstp	 ST(2)
  001d9	f6 c4 41	 test	 ah, 65			; 00000041H
  001dc	0f 8b fa 00 00
	00		 jnp	 $LN47@MissCheckP
  001e2	0f b7 86 9c 00
	00 00		 movzx	 eax, WORD PTR [esi+156]
  001e9	66 85 c0	 test	 ax, ax
  001ec	0f 8e ea 00 00
	00		 jle	 $LN47@MissCheckP
  001f2	85 db		 test	 ebx, ebx
  001f4	0f 84 e2 00 00
	00		 je	 $LN47@MissCheckP

; 1226 : 
; 1227 : 	float iExpressionA = ( iAttackRate * 10000.0f ) / ( iAttackRate + iDefenseRate );	// #formula
; 1228 : 	float iExpressionB = ( lpObj->Level * 10000 ) / ( lpObj->Level + lpTargetObj->Level );	// #formula
; 1229 : 
; 1230 : 	iExpressionA /= 10000.0f;
; 1231 : 	iExpressionB /= 10000.0f;
; 1232 : 
; 1233 : 	iAttackSuccessRate = 100.0f * iExpressionA * iExpressionB;

  001fa	d9 c0		 fld	 ST(0)
  001fc	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  00203	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@40c3880000000000
  00209	57		 push	 edi
  0020a	dc c9		 fmul	 ST(1), ST(0)
  0020c	0f bf bb 9c 00
	00 00		 movsx	 edi, WORD PTR [ebx+156]
  00213	d9 cb		 fxch	 ST(3)
  00215	de c2		 faddp	 ST(2), ST(0)
  00217	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0021a	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  00220	de f1		 fdivrp	 ST(1), ST(0)
  00222	99		 cdq
  00223	f7 f9		 idiv	 ecx
  00225	d9 5d 08	 fstp	 DWORD PTR tv255[ebp]
  00228	d9 45 08	 fld	 DWORD PTR tv255[ebp]
  0022b	d8 f1		 fdiv	 ST(0), ST(1)
  0022d	d9 5d 08	 fstp	 DWORD PTR tv320[ebp]
  00230	d9 45 08	 fld	 DWORD PTR tv320[ebp]
  00233	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4059000000000000
  00239	89 45 08	 mov	 DWORD PTR tv192[ebp], eax
  0023c	db 45 08	 fild	 DWORD PTR tv192[ebp]
  0023f	de f2		 fdivrp	 ST(2), ST(0)
  00241	d9 c9		 fxch	 ST(1)
  00243	d9 5d 08	 fstp	 DWORD PTR tv334[ebp]
  00246	d8 4d 08	 fmul	 DWORD PTR tv334[ebp]
  00249	e8 00 00 00 00	 call	 __ftol2_sse
  0024e	89 45 08	 mov	 DWORD PTR _iAttackSuccessRate$[ebp], eax

; 1234 : 
; 1235 : 	if ( (lpTargetObj->Level - lpObj->Level) >= 100 )

  00251	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  00258	2b f8		 sub	 edi, eax
  0025a	83 ff 64	 cmp	 edi, 100		; 00000064H
  0025d	5f		 pop	 edi
  0025e	7c 06		 jl	 SHORT $LN6@MissCheckP

; 1236 : 	{
; 1237 : 		iAttackSuccessRate -= 5;

  00260	83 6d 08 05	 sub	 DWORD PTR _iAttackSuccessRate$[ebp], 5
  00264	eb 2b		 jmp	 SHORT $LN2@MissCheckP
$LN6@MissCheckP:

; 1238 : 	}
; 1239 : 	else if ( (lpTargetObj->Level - lpObj->Level) >= 200 )

  00266	0f b7 86 9c 00
	00 00		 movzx	 eax, WORD PTR [esi+156]
  0026d	0f bf d0	 movsx	 edx, ax
  00270	0f bf 83 9c 00
	00 00		 movsx	 eax, WORD PTR [ebx+156]
  00277	2b c2		 sub	 eax, edx
  00279	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  0027e	7c 06		 jl	 SHORT $LN4@MissCheckP

; 1240 : 	{
; 1241 : 		iAttackSuccessRate -= 10;

  00280	83 6d 08 0a	 sub	 DWORD PTR _iAttackSuccessRate$[ebp], 10 ; 0000000aH
  00284	eb 0b		 jmp	 SHORT $LN2@MissCheckP
$LN4@MissCheckP:

; 1242 : 	}
; 1243 : 	else if ( (lpTargetObj->Level - lpObj->Level) >= 300 )

  00286	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  0028b	7c 04		 jl	 SHORT $LN2@MissCheckP

; 1244 : 	{
; 1245 : 		iAttackSuccessRate -= 15;

  0028d	83 6d 08 0f	 sub	 DWORD PTR _iAttackSuccessRate$[ebp], 15 ; 0000000fH
$LN2@MissCheckP:

; 1246 : 	}
; 1247 : 
; 1248 : 	DWORD dwRate = rand() % 100;

  00291	e8 00 00 00 00	 call	 _rand
  00296	99		 cdq
  00297	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0029c	f7 f9		 idiv	 ecx

; 1249 : 
; 1250 : 	if ( dwRate > iAttackSuccessRate )

  0029e	3b 55 08	 cmp	 edx, DWORD PTR _iAttackSuccessRate$[ebp]
  002a1	76 1e		 jbe	 SHORT $LN1@MissCheckP

; 1251 : 	{
; 1252 : 		GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, 0, 0);

  002a3	8b 13		 mov	 edx, DWORD PTR [ebx]
  002a5	8b 06		 mov	 eax, DWORD PTR [esi]
  002a7	6a 00		 push	 0
  002a9	6a 00		 push	 0
  002ab	6a 00		 push	 0
  002ad	52		 push	 edx
  002ae	50		 push	 eax
  002af	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  002b4	83 c4 14	 add	 esp, 20			; 00000014H
  002b7	5e		 pop	 esi
  002b8	33 c0		 xor	 eax, eax
  002ba	5b		 pop	 ebx

; 1257 : }

  002bb	8b e5		 mov	 esp, ebp
  002bd	5d		 pop	 ebp
  002be	c2 14 00	 ret	 20			; 00000014H
$LN1@MissCheckP:
  002c1	5e		 pop	 esi

; 1253 : 		return FALSE;
; 1254 : 	}
; 1255 : 
; 1256 : 	return TRUE;

  002c2	b8 01 00 00 00	 mov	 eax, 1
  002c7	5b		 pop	 ebx

; 1257 : }

  002c8	8b e5		 mov	 esp, ebp
  002ca	5d		 pop	 ebp
  002cb	c2 14 00	 ret	 20			; 00000014H
$LN38@MissCheckP:

; 1222 : 	}
; 1223 : 
; 1224 : 	if ( iAttackRate <= 0.0f || iDefenseRate <= 0.0f || lpObj->Level <= 0 || (DWORD)lpTargetObj <= 0 )	// #error lpTargetObj

  002ce	dd d9		 fstp	 ST(1)
  002d0	5e		 pop	 esi
  002d1	dd d8		 fstp	 ST(0)

; 1225 : 		return FALSE;

  002d3	33 c0		 xor	 eax, eax
  002d5	5b		 pop	 ebx

; 1257 : }

  002d6	8b e5		 mov	 esp, ebp
  002d8	5d		 pop	 ebp
  002d9	c2 14 00	 ret	 20			; 00000014H
$LN47@MissCheckP:

; 1222 : 	}
; 1223 : 
; 1224 : 	if ( iAttackRate <= 0.0f || iDefenseRate <= 0.0f || lpObj->Level <= 0 || (DWORD)lpTargetObj <= 0 )	// #error lpTargetObj

  002dc	dd d8		 fstp	 ST(0)
  002de	5e		 pop	 esi
  002df	dd d8		 fstp	 ST(0)

; 1225 : 		return FALSE;

  002e1	33 c0		 xor	 eax, eax
  002e3	5b		 pop	 ebx

; 1257 : }

  002e4	8b e5		 mov	 esp, ebp
  002e6	5d		 pop	 ebp
  002e7	c2 14 00	 ret	 20			; 00000014H
?MissCheckPvP@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0HHAAH@Z ENDP ; CDarkSpirit::MissCheckPvP
_TEXT	ENDS
PUBLIC	?set@PBMSG_HEAD@@QAEXPAEEE@Z			; PBMSG_HEAD::set
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD@@QAEXPAEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 1
?set@PBMSG_HEAD@@QAEXPAEEE@Z PROC			; PBMSG_HEAD::set, COMDAT
; _this$ = ecx

; 92   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 94   : 		lpBuf[1] = size;

  00006	8a 4d 10	 mov	 cl, BYTE PTR _size$[ebp]

; 95   : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  0000f	88 48 01	 mov	 BYTE PTR [eax+1], cl
  00012	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 96   : 	};	// line : 22

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?set@PBMSG_HEAD@@QAEXPAEEE@Z ENDP			; PBMSG_HEAD::set
_TEXT	ENDS
PUBLIC	??0CDarkSpirit@@QAE@XZ				; CDarkSpirit::CDarkSpirit
EXTRN	??0CObjBaseAttack@@QAE@XZ:PROC			; CObjBaseAttack::CObjBaseAttack
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\darkspirit.cpp
;	COMDAT ??0CDarkSpirit@@QAE@XZ
_TEXT	SEGMENT
??0CDarkSpirit@@QAE@XZ PROC				; CDarkSpirit::CDarkSpirit, COMDAT
; _this$ = ecx

; 19   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??0CObjBaseAttack@@QAE@XZ ; CObjBaseAttack::CObjBaseAttack

; 20   : 	this->Init();

  00008	8b ce		 mov	 ecx, esi
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDarkSpirit@@6B@
  00010	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  00017	e8 00 00 00 00	 call	 ?Init@CDarkSpirit@@QAEXXZ ; CDarkSpirit::Init

; 21   : }

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c3		 ret	 0
??0CDarkSpirit@@QAE@XZ ENDP				; CDarkSpirit::CDarkSpirit
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCDarkSpirit@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDarkSpirit@@UAEPAXI@Z PROC				; CDarkSpirit::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDarkSpirit@@UAE@XZ	; CDarkSpirit::~CDarkSpirit
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCDarkSpirit@@UAEPAXI@Z ENDP				; CDarkSpirit::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z		; CDarkSpirit::SendAttackMsg
EXTRN	?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z:PROC ; gObjAddAttackProcMsgSendDelay
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_criticaldamage$ = 16					; size = 4
_iActionType$ = 20					; size = 4
?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z PROC		; CDarkSpirit::SendAttackMsg, COMDAT
; _this$ = ecx

; 384  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	56		 push	 esi

; 385  : 	PMSG_PET_ITEM_ATTACK_COMMAND pMsg;
; 386  : 
; 387  : 	if ( criticaldamage != 2 )

  00015	8b 75 10	 mov	 esi, DWORD PTR _criticaldamage$[ebp]
  00018	57		 push	 edi
  00019	8b 7d 14	 mov	 edi, DWORD PTR _iActionType$[ebp]
  0001c	83 fe 02	 cmp	 esi, 2
  0001f	74 70		 je	 SHORT $LN4@SendAttack

; 388  : 	{
; 389  : 		pMsg.PetType = 0;
; 390  : 		pMsg.SkillType = (criticaldamage)? 0 : 1;

  00021	85 f6		 test	 esi, esi
  00023	0f 94 c0	 sete	 al
  00026	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 391  : 		pMsg.NumberH = SET_NUMBERH(aIndex);
; 392  : 		pMsg.NumberL = SET_NUMBERL(aIndex);
; 393  : 		pMsg.TargetNumberH = SET_NUMBERH(aTargetIndex);

  00029	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0002c	8b d0		 mov	 edx, eax

; 394  : 		pMsg.TargetNumberL = SET_NUMBERL(aTargetIndex);

  0002e	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+8], al

; 395  : 		pMsg.h.set((LPBYTE)&pMsg, 0xA8, sizeof(pMsg));
; 396  : 		
; 397  : 		DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00031	6a 09		 push	 9
  00033	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00036	8b cb		 mov	 ecx, ebx
  00038	50		 push	 eax
  00039	c1 e9 08	 shr	 ecx, 8
  0003c	c1 ea 08	 shr	 edx, 8
  0003f	53		 push	 ebx
  00040	88 4d f5	 mov	 BYTE PTR _pMsg$[ebp+5], cl
  00043	88 5d f6	 mov	 BYTE PTR _pMsg$[ebp+6], bl
  00046	88 55 f7	 mov	 BYTE PTR _pMsg$[ebp+7], dl
  00049	c7 45 f0 c1 09
	a8 00		 mov	 DWORD PTR _pMsg$[ebp], 11012545 ; 00a809c1H
  00050	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 398  : 		MsgSendV2(&gObj[aIndex], (UCHAR*)&pMsg, pMsg.h.size);

  00055	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00059	8b c3		 mov	 eax, ebx
  0005b	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00061	51		 push	 ecx
  00062	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00065	52		 push	 edx
  00066	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00071	83 c4 18	 add	 esp, 24			; 00000018H

; 399  : 
; 400  : 		if ( iActionType == 1 )

  00074	83 ff 01	 cmp	 edi, 1
  00077	75 1a		 jne	 SHORT $LN1@SendAttack

; 401  : 		{
; 402  : 			criticaldamage = 0;

  00079	33 f6		 xor	 esi, esi

; 403  : 			
; 404  : 			if ( (rand()%10) < 3 )

  0007b	e8 00 00 00 00	 call	 _rand
  00080	99		 cdq
  00081	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00086	f7 f9		 idiv	 ecx
  00088	83 fa 03	 cmp	 edx, 3
  0008b	7d 06		 jge	 SHORT $LN1@SendAttack

; 405  : 			{
; 406  : 				criticaldamage = TRUE;

  0008d	8b f7		 mov	 esi, edi

; 407  : 			}
; 408  : 		}
; 409  : 	}
; 410  : 	else

  0008f	eb 02		 jmp	 SHORT $LN1@SendAttack
$LN4@SendAttack:

; 411  : 	{
; 412  : 		criticaldamage = 0;

  00091	33 f6		 xor	 esi, esi
$LN1@SendAttack:

; 413  : 	}
; 414  : 
; 415  : 	gObjAddAttackProcMsgSendDelay(&gObj[aIndex], 51, aTargetIndex, 600, criticaldamage, iActionType);

  00093	8b 55 0c	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  00096	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  0009c	57		 push	 edi
  0009d	56		 push	 esi
  0009e	68 58 02 00 00	 push	 600			; 00000258H
  000a3	52		 push	 edx
  000a4	6a 33		 push	 51			; 00000033H
  000a6	81 c3 00 00 00
	00		 add	 ebx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ac	53		 push	 ebx
  000ad	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay

; 416  : }

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	83 c4 18	 add	 esp, 24			; 00000018H
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	33 cd		 xor	 ecx, ebp
  000bc	5b		 pop	 ebx
  000bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 10 00	 ret	 16			; 00000010H
?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z ENDP		; CDarkSpirit::SendAttackMsg
_TEXT	ENDS
PUBLIC	?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z	; CDarkSpirit::SetMode
; Function compile flags: /Ogtp
;	COMDAT ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z
_TEXT	SEGMENT
_pMsg$155529 = -8					; size = 7
_mode$ = 8						; size = 4
_iTargetindex$ = 12					; size = 4
?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z PROC	; CDarkSpirit::SetMode, COMDAT
; _this$ = ecx

; 470  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi

; 471  : 	if ( this->m_iMasterIndex == -1 )

  00007	8b 79 14	 mov	 edi, DWORD PTR [ecx+20]
  0000a	83 ff ff	 cmp	 edi, -1
  0000d	74 67		 je	 SHORT $LN5@SetMode

; 472  : 	{
; 473  : 		return;
; 474  : 	}
; 475  : 
; 476  : 	LPOBJ lpObj = &gObj[this->m_iMasterIndex];

  0000f	8b c7		 mov	 eax, edi
  00011	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 477  : 
; 478  : 	if ( lpObj->Class != CLASS_DARKLORD )	// DL

  00017	66 83 b8 98 00
	00 00 04	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+152], 4
  0001f	75 55		 jne	 SHORT $LN5@SetMode

; 479  : 	{
; 480  : 		return;
; 481  : 	}
; 482  : 
; 483  : 	if ( mode == PetItem_Mode_Attack_Target || this->m_ActionMode != mode)

  00021	8b 45 08	 mov	 eax, DWORD PTR _mode$[ebp]
  00024	56		 push	 esi
  00025	83 f8 03	 cmp	 eax, 3
  00028	74 07		 je	 SHORT $LN14@SetMode
  0002a	39 41 20	 cmp	 DWORD PTR [ecx+32], eax
  0002d	74 46		 je	 SHORT $LN15@SetMode

; 484  : 	{
; 485  : 		if ( mode == PetItem_Mode_Attack_Target )

  0002f	eb 19		 jmp	 SHORT $LN1@SetMode
$LN14@SetMode:

; 486  : 		{
; 487  : 			if ( OBJMAX_RANGE(iTargetindex) != FALSE )

  00031	8b 75 0c	 mov	 esi, DWORD PTR _iTargetindex$[ebp]
  00034	85 f6		 test	 esi, esi
  00036	78 3d		 js	 SHORT $LN15@SetMode
  00038	33 d2		 xor	 edx, edx
  0003a	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00040	0f 9e c2	 setle	 dl
  00043	85 d2		 test	 edx, edx
  00045	74 2e		 je	 SHORT $LN15@SetMode

; 488  : 			{
; 489  : 				this->m_iTargetIndex = iTargetindex;

  00047	89 71 18	 mov	 DWORD PTR [ecx+24], esi
$LN1@SetMode:

; 490  : 			}
; 491  : 			else
; 492  : 			{
; 493  : 				return;
; 494  : 			}
; 495  : 		}
; 496  : 
; 497  : 		this->m_ActionMode = mode;
; 498  : 		PMSG_SEND_PET_ITEM_COMMAND pMsg;
; 499  : 
; 500  : 		pMsg.h.set((LPBYTE)&pMsg, 0xA7, sizeof(pMsg));
; 501  : 		pMsg.PetType = 0;
; 502  : 		pMsg.Command = mode;
; 503  : 		pMsg.NumberH = SET_NUMBERH(this->m_iTargetIndex);

  0004a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0004d	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  00050	88 45 fc	 mov	 BYTE PTR _pMsg$155529[ebp+4], al

; 504  : 		pMsg.NumberL = SET_NUMBERL(this->m_iTargetIndex);

  00053	8a 41 18	 mov	 al, BYTE PTR [ecx+24]

; 505  : 
; 506  : 		DataSend(this->m_iMasterIndex, (UCHAR*)&pMsg, sizeof(pMsg));

  00056	6a 07		 push	 7
  00058	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$155529[ebp]
  0005b	51		 push	 ecx
  0005c	c1 ea 08	 shr	 edx, 8
  0005f	57		 push	 edi
  00060	c7 45 f8 c1 07
	a7 00		 mov	 DWORD PTR _pMsg$155529[ebp], 10946497 ; 00a707c1H
  00067	88 55 fd	 mov	 BYTE PTR _pMsg$155529[ebp+5], dl
  0006a	88 45 fe	 mov	 BYTE PTR _pMsg$155529[ebp+6], al
  0006d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@SetMode:
  00075	5e		 pop	 esi
$LN5@SetMode:
  00076	5f		 pop	 edi

; 507  : 
; 508  : 		char strMode[4][255] =
; 509  : 		{
; 510  : 			"[일반]",
; 511  : 			"[랜덤공격]",
; 512  : 			"[주인과같이공격]",
; 513  : 			"[사용자지정]"
; 514  : 		};
; 515  : /*
; 516  : 		char szNormal[256] = "[Raven Mode Normal]";
; 517  : 		char szRandom[256] = "[Raven Mode Random]";
; 518  : 		char szMaster[256] = "[Raven Mode With Master]";
; 519  : 		char szTarget[256] = "[Raven Mode Attack Target]";*/
; 520  : 	}
; 521  : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ENDP	; CDarkSpirit::SetMode
_TEXT	ENDS
PUBLIC	?Set@CDarkSpirit@@QAEXHPAVCItem@@@Z		; CDarkSpirit::Set
; Function compile flags: /Ogtp
;	COMDAT ?Set@CDarkSpirit@@QAEXHPAVCItem@@@Z
_TEXT	SEGMENT
_bChange$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_pPetItem$ = 12						; size = 4
?Set@CDarkSpirit@@QAEXHPAVCItem@@@Z PROC		; CDarkSpirit::Set, COMDAT
; _this$ = ecx

; 524  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 525  : 	LPOBJ lpObj = &gObj[aIndex];

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00008	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  0000e	81 c3 00 00 00
	00		 add	 ebx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 526  : 
; 527  : 	if ( lpObj->Class != 4 )	// DL

  00014	66 83 bb 98 00
	00 00 04	 cmp	 WORD PTR [ebx+152], 4
  0001c	0f 85 f2 00 00
	00		 jne	 $LN1@Set

; 528  : 	{
; 529  : 		return;
; 530  : 	}
; 531  : 
; 532  : 	BOOL bChange = FALSE;
; 533  : 
; 534  : 	if ( this->m_iMasterIndex == -1 )

  00022	83 79 14 ff	 cmp	 DWORD PTR [ecx+20], -1
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bChange$[ebp], 0
  0002d	75 07		 jne	 SHORT $LN4@Set

; 535  : 	{
; 536  : 		bChange = TRUE;

  0002f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bChange$[ebp], 1
$LN4@Set:

; 537  : 	}
; 538  : 
; 539  : 	this->Init();

  00036	e8 00 00 00 00	 call	 ?Init@CDarkSpirit@@QAEXXZ ; CDarkSpirit::Init

; 540  : 
; 541  : 	if ( pPetItem->m_Type != ITEMGET(13,5) ) // Talon of Dark Raven

  0003b	8b 55 0c	 mov	 edx, DWORD PTR _pPetItem$[ebp]
  0003e	b8 05 1a 00 00	 mov	 eax, 6661		; 00001a05H
  00043	66 39 42 06	 cmp	 WORD PTR [edx+6], ax
  00047	0f 85 c7 00 00
	00		 jne	 $LN1@Set

; 542  : 	{
; 543  : 		return;
; 544  : 	}
; 545  : 
; 546  : 	if ( pPetItem->m_Durability <= 0.0f )

  0004d	d9 ee		 fldz
  0004f	d8 5a 24	 fcomp	 DWORD PTR [edx+36]
  00052	df e0		 fnstsw	 ax
  00054	f6 c4 01	 test	 ah, 1
  00057	0f 84 b7 00 00
	00		 je	 $LN1@Set

; 547  : 	{
; 548  : 		return;
; 549  : 	}
; 550  : 
; 551  : 	int petitemlevel = pPetItem->m_PetItem_Level;

  0005d	56		 push	 esi
  0005e	8b b2 a0 00 00
	00		 mov	 esi, DWORD PTR [edx+160]

; 552  : 	int leadership = lpObj->Leadership + lpObj->AddLeadership;

  00064	0f b7 93 d8 00
	00 00		 movzx	 edx, WORD PTR [ebx+216]
  0006b	57		 push	 edi
  0006c	0f b7 bb da 00
	00 00		 movzx	 edi, WORD PTR [ebx+218]
  00073	03 fa		 add	 edi, edx

; 553  : 	this->m_AttackDamageMin = petitemlevel*15 + leadership/8 + 180;

  00075	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00078	8b d8		 mov	 ebx, eax
  0007a	c1 e3 04	 shl	 ebx, 4
  0007d	2b d8		 sub	 ebx, eax
  0007f	8b c7		 mov	 eax, edi
  00081	99		 cdq
  00082	83 e2 07	 and	 edx, 7
  00085	03 c2		 add	 eax, edx
  00087	c1 f8 03	 sar	 eax, 3
  0008a	03 d8		 add	 ebx, eax

; 554  : 	this->m_AttackDamageMax = petitemlevel*15 + leadership/4 + 200;

  0008c	8b c7		 mov	 eax, edi
  0008e	99		 cdq
  0008f	83 e2 03	 and	 edx, 3
  00092	03 c2		 add	 eax, edx
  00094	c1 f8 02	 sar	 eax, 2
  00097	8b d6		 mov	 edx, esi
  00099	c1 e2 04	 shl	 edx, 4
  0009c	2b d6		 sub	 edx, esi
  0009e	8d 84 10 c8 00
	00 00		 lea	 eax, DWORD PTR [eax+edx+200]
  000a5	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 555  : 	this->m_AttackSpeed = petitemlevel * 4 / 5 + leadership / 50 + 20;

  000a8	8d 14 b5 00 00
	00 00		 lea	 edx, DWORD PTR [esi*4]
  000af	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  000b4	f7 ea		 imul	 edx
  000b6	d1 fa		 sar	 edx, 1
  000b8	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  000bb	8b da		 mov	 ebx, edx
  000bd	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  000c0	03 da		 add	 ebx, edx
  000c2	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000c7	f7 ef		 imul	 edi
  000c9	c1 fa 04	 sar	 edx, 4
  000cc	8b c2		 mov	 eax, edx
  000ce	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000d1	03 da		 add	 ebx, edx
  000d3	8d 54 18 14	 lea	 edx, DWORD PTR [eax+ebx+20]
  000d7	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 556  : 	this->m_SuccessAttackRate= petitemlevel + petitemlevel / 15 + 1000;

  000da	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  000df	f7 ee		 imul	 esi
  000e1	03 d6		 add	 edx, esi
  000e3	c1 fa 03	 sar	 edx, 3
  000e6	8b c2		 mov	 eax, edx
  000e8	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000eb	03 c2		 add	 eax, edx

; 557  : 	this->m_iMasterIndex = aIndex;
; 558  : 	this->m_pPetItem = pPetItem;
; 559  : 
; 560  : 	if ( bChange != FALSE )

  000ed	83 7d fc 00	 cmp	 DWORD PTR _bChange$[ebp], 0
  000f1	8d 94 30 e8 03
	00 00		 lea	 edx, DWORD PTR [eax+esi+1000]
  000f8	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000fb	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  000fe	8b 55 0c	 mov	 edx, DWORD PTR _pPetItem$[ebp]
  00101	5f		 pop	 edi
  00102	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00105	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  00108	5e		 pop	 esi
  00109	74 09		 je	 SHORT $LN1@Set

; 561  : 	{
; 562  : 		this->SetMode(PetItem_Mode_Normal, -1);

  0010b	6a ff		 push	 -1
  0010d	6a 00		 push	 0
  0010f	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode
$LN1@Set:
  00114	5b		 pop	 ebx

; 563  : 	}
; 564  : }

  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c2 08 00	 ret	 8
?Set@CDarkSpirit@@QAEXHPAVCItem@@@Z ENDP		; CDarkSpirit::Set
_TEXT	ENDS
PUBLIC	?ChangeCommand@CDarkSpirit@@QAEXHH@Z		; CDarkSpirit::ChangeCommand
; Function compile flags: /Ogtp
;	COMDAT ?ChangeCommand@CDarkSpirit@@QAEXHH@Z
_TEXT	SEGMENT
_command$ = 8						; size = 4
_targetindex$ = 12					; size = 4
?ChangeCommand@CDarkSpirit@@QAEXHH@Z PROC		; CDarkSpirit::ChangeCommand, COMDAT
; _this$ = ecx

; 1260 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1261 : 	CDarkSpirit::ePetItem_Mode setmode = PetItem_Mode_Normal;
; 1262 : 
; 1263 : 	if ( command == PetItem_Mode_Normal )

  00003	8b 55 08	 mov	 edx, DWORD PTR _command$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 d2		 test	 edx, edx
  0000a	75 0e		 jne	 SHORT $LN7@ChangeComm

; 1278 : 	}
; 1279 : 
; 1280 : 	this->SetMode(setmode, targetindex);

  0000c	8b 55 0c	 mov	 edx, DWORD PTR _targetindex$[ebp]
  0000f	52		 push	 edx
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode

; 1281 : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
$LN7@ChangeComm:

; 1264 : 	{
; 1265 : 		setmode = PetItem_Mode_Normal;
; 1266 : 	}
; 1267 : 	else if ( command == PetItem_Mode_Attack_Random )

  0001a	83 fa 01	 cmp	 edx, 1
  0001d	75 10		 jne	 SHORT $LN5@ChangeComm

; 1268 : 	{
; 1269 : 		setmode = PetItem_Mode_Attack_Random;

  0001f	8b c2		 mov	 eax, edx

; 1278 : 	}
; 1279 : 
; 1280 : 	this->SetMode(setmode, targetindex);

  00021	8b 55 0c	 mov	 edx, DWORD PTR _targetindex$[ebp]
  00024	52		 push	 edx
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode

; 1281 : }

  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
$LN5@ChangeComm:

; 1270 : 	}
; 1271 : 	else if ( command == PetItem_Mode_Attack_WithMaster )

  0002f	83 fa 02	 cmp	 edx, 2
  00032	75 10		 jne	 SHORT $LN3@ChangeComm

; 1272 : 	{
; 1273 : 		setmode = PetItem_Mode_Attack_WithMaster;

  00034	8b c2		 mov	 eax, edx

; 1278 : 	}
; 1279 : 
; 1280 : 	this->SetMode(setmode, targetindex);

  00036	8b 55 0c	 mov	 edx, DWORD PTR _targetindex$[ebp]
  00039	52		 push	 edx
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode

; 1281 : }

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN3@ChangeComm:

; 1274 : 	}
; 1275 : 	else if ( command == PetItem_Mode_Attack_Target )

  00044	83 fa 03	 cmp	 edx, 3
  00047	75 02		 jne	 SHORT $LN1@ChangeComm

; 1276 : 	{
; 1277 : 		setmode = PetItem_Mode_Attack_Target;

  00049	8b c2		 mov	 eax, edx
$LN1@ChangeComm:

; 1278 : 	}
; 1279 : 
; 1280 : 	this->SetMode(setmode, targetindex);

  0004b	8b 55 0c	 mov	 edx, DWORD PTR _targetindex$[ebp]
  0004e	52		 push	 edx
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode

; 1281 : }

  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
?ChangeCommand@CDarkSpirit@@QAEXHH@Z ENDP		; CDarkSpirit::ChangeCommand
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z		; CDarkSpirit::SendLevelmsg
; Function compile flags: /Ogtp
;	COMDAT ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_nPos$ = 12						; size = 4
_PetType$ = 16						; size = 4
_InvenType$ = 20					; size = 4
?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z PROC		; CDarkSpirit::SendLevelmsg, COMDAT

; 1284 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]

; 1285 : 	PMSG_SEND_PET_ITEMINFO pMsg;
; 1286 : 
; 1287 : 	pMsg.h.set((LPBYTE)&pMsg, 0xA9, sizeof(pMsg));
; 1288 : 	pMsg.PetType = PetType;

  00013	8a 55 10	 mov	 dl, BYTE PTR _PetType$[ebp]
  00016	8b 45 0c	 mov	 eax, DWORD PTR _nPos$[ebp]
  00019	88 55 f3	 mov	 BYTE PTR _pMsg$[ebp+3], dl

; 1289 : 	pMsg.InvenType = 0xFE;
; 1290 : 	pMsg.nPos = nPos;

  0001c	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 1291 : 	pMsg.Level = gObj[aIndex].pInventory[nPos].m_PetItem_Level;

  0001f	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00025	8b d1		 mov	 edx, ecx
  00027	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  0002d	8b 92 8c 0c 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3212]
  00033	03 c2		 add	 eax, edx
  00035	66 c7 45 f0 c1
	0c		 mov	 WORD PTR _pMsg$[ebp], 3265 ; 00000cc1H
  0003b	c6 45 f2 a9	 mov	 BYTE PTR _pMsg$[ebp+2], 169 ; 000000a9H
  0003f	c6 45 f4 fe	 mov	 BYTE PTR _pMsg$[ebp+4], 254 ; 000000feH
  00043	0f b6 90 a0 00
	00 00		 movzx	 edx, BYTE PTR [eax+160]
  0004a	88 55 f6	 mov	 BYTE PTR _pMsg$[ebp+6], dl

; 1292 : 	pMsg.Exp = gObj[aIndex].pInventory[nPos].m_PetItem_Exp;

  0004d	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [eax+164]

; 1293 : 
; 1294 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00053	6a 0c		 push	 12			; 0000000cH
  00055	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00058	52		 push	 edx
  00059	51		 push	 ecx
  0005a	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  0005d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1295 : }

  00062	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00065	33 cd		 xor	 ecx, ebp
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ENDP		; CDarkSpirit::SendLevelmsg
_TEXT	ENDS
PUBLIC	?RangeAttack@CDarkSpirit@@QAEXHH@Z		; CDarkSpirit::RangeAttack
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z:PROC ; gObjTargetGuildWarCheck
; Function compile flags: /Ogtp
;	COMDAT ?RangeAttack@CDarkSpirit@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv330 = -8						; size = 4
_count$ = -4						; size = 4
_HitCount$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
?RangeAttack@CDarkSpirit@@QAEXHH@Z PROC			; CDarkSpirit::RangeAttack, COMDAT
; _this$ = ecx

; 284  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 285  : 	LPOBJ lpObj = &gObj[aIndex];

  00009	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000c	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H

; 286  : 	int StartDis = 1;
; 287  : 	int tObjNum;
; 288  : 	int count = 0;

  00012	33 c0		 xor	 eax, eax

; 289  : 	int loopcount = 0;
; 290  : 	int attackcheck;
; 291  : 	int EnableAttack;
; 292  : 	int HitCount = 0;
; 293  : 
; 294  : 	this->SendAttackMsg(lpObj->m_Index, aTargetIndex, 0, 0);

  00014	50		 push	 eax
  00015	50		 push	 eax
  00016	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  00019	89 45 08	 mov	 DWORD PTR _HitCount$[ebp], eax
  0001c	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0001f	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00025	8b 17		 mov	 edx, DWORD PTR [edi]
  00027	50		 push	 eax
  00028	52		 push	 edx
  00029	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002c	e8 00 00 00 00	 call	 ?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z ; CDarkSpirit::SendAttackMsg
  00031	8d 87 16 07 00
	00		 lea	 eax, DWORD PTR [edi+1814]
  00037	89 45 f8	 mov	 DWORD PTR tv330[ebp], eax
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL19@RangeAttac:

; 295  : 
; 296  : 	while ( true )
; 297  : 	{
; 298  : 		if ( lpObj->VpPlayer2[count].state != 0 )

  00040	80 78 fe 00	 cmp	 BYTE PTR [eax-2], 0
  00044	0f 84 b3 00 00
	00		 je	 $LN28@RangeAttac

; 299  : 		{
; 300  : 			tObjNum = lpObj->VpPlayer2[count].number;

  0004a	0f bf 18	 movsx	 ebx, WORD PTR [eax]

; 301  : 
; 302  : 			if ( tObjNum >= 0 && aTargetIndex != tObjNum )

  0004d	85 db		 test	 ebx, ebx
  0004f	0f 88 a8 00 00
	00		 js	 $LN28@RangeAttac
  00055	39 5d 0c	 cmp	 DWORD PTR _aTargetIndex$[ebp], ebx
  00058	0f 84 9f 00 00
	00		 je	 $LN28@RangeAttac

; 303  : 			{
; 304  : 				EnableAttack = FALSE;
; 305  : 				
; 306  : 				if ( lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  0005e	80 78 02 02	 cmp	 BYTE PTR [eax+2], 2
  00062	75 11		 jne	 SHORT $LN15@RangeAttac
  00064	8b f3		 mov	 esi, ebx
  00066	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0006c	83 be cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+716], 0

; 307  : 				{
; 308  : 					EnableAttack = TRUE;

  00073	7c 48		 jl	 SHORT $LN26@RangeAttac
$LN15@RangeAttac:

; 309  : 				}
; 310  : 				else if ( tObjNum == aTargetIndex )
; 311  : 				{
; 312  : 					EnableAttack = TRUE;
; 313  : 				}
; 314  : 				else
; 315  : 				{
; 316  : 					int lc10 = gObj[tObjNum].m_Index;

  00075	8b f3		 mov	 esi, ebx
  00077	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H

; 317  : 
; 318  : 					if ( gObj[tObjNum].Type == OBJ_MONSTER )

  0007d	66 83 be 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+96], 2
  00085	8b 86 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  0008b	75 16		 jne	 SHORT $LN10@RangeAttac

; 319  : 					{
; 320  : 						if ( gObj[tObjNum].m_RecallMon >= 0 )

  0008d	8b 8e cc 02 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+716]
  00093	85 c9		 test	 ecx, ecx
  00095	78 0c		 js	 SHORT $LN10@RangeAttac

; 321  : 						{
; 322  : 							lc10 = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00097	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0009d	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx]
$LN10@RangeAttac:

; 323  : 						}
; 324  : 					}
; 325  : 
; 326  : 					if ( gObjTargetGuildWarCheck(lpObj, &gObj[lc10]) == TRUE )

  000a3	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000a9	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ae	50		 push	 eax
  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000b5	83 c4 08	 add	 esp, 8
  000b8	83 f8 01	 cmp	 eax, 1
  000bb	75 40		 jne	 SHORT $LN28@RangeAttac
$LN26@RangeAttac:

; 327  : 					{
; 328  : 						EnableAttack = TRUE;
; 329  : 					}
; 330  : 				}
; 331  : 
; 332  : 				if ( EnableAttack != FALSE )
; 333  : 				{
; 334  : 					attackcheck = FALSE;
; 335  : 
; 336  : 					if ( loopcount == 0 )
; 337  : 					{
; 338  : 						attackcheck = TRUE;
; 339  : 					}
; 340  : 					else if ( (rand()%3) == 0 )
; 341  : 					{
; 342  : 						attackcheck = TRUE;
; 343  : 					}
; 344  : 
; 345  : 					if ( attackcheck != FALSE )
; 346  : 					{
; 347  : 						if ( gObjCalDistance(&gObj[aTargetIndex], &gObj[tObjNum]) < RAVEN_ATTACK_DISTANCE-3 )

  000bd	8b 4d 0c	 mov	 ecx, DWORD PTR _aTargetIndex$[ebp]
  000c0	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000c6	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000cc	50		 push	 eax
  000cd	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000d9	83 c4 08	 add	 esp, 8
  000dc	83 f8 04	 cmp	 eax, 4
  000df	7d 1c		 jge	 SHORT $LN28@RangeAttac

; 348  : 						{
; 349  : 							this->SendAttackMsg(lpObj->m_Index, tObjNum, 2, 0);

  000e1	8b 17		 mov	 edx, DWORD PTR [edi]
  000e3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	6a 00		 push	 0
  000e8	6a 02		 push	 2
  000ea	53		 push	 ebx
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 ?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z ; CDarkSpirit::SendAttackMsg

; 350  : 							HitCount++;

  000f1	8b 45 08	 mov	 eax, DWORD PTR _HitCount$[ebp]
  000f4	40		 inc	 eax
  000f5	89 45 08	 mov	 DWORD PTR _HitCount$[ebp], eax

; 351  : 
; 352  : 							if ( HitCount > 3 )

  000f8	83 f8 03	 cmp	 eax, 3
  000fb	7f 19		 jg	 SHORT $LN24@RangeAttac
$LN28@RangeAttac:

; 353  : 							{
; 354  : 								break;
; 355  : 							}
; 356  : 						}
; 357  : 					}
; 358  : 				}
; 359  : 			}				
; 360  : 		}
; 361  : 
; 362  : 		count++;

  000fd	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  00100	8b 45 f8	 mov	 eax, DWORD PTR tv330[ebp]
  00103	41		 inc	 ecx
  00104	83 c0 0c	 add	 eax, 12			; 0000000cH
  00107	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  0010a	89 45 f8	 mov	 DWORD PTR tv330[ebp], eax

; 363  : 
; 364  : 		if ( count > MAX_VIEWPORT-1 )

  0010d	83 f9 4a	 cmp	 ecx, 74			; 0000004aH
  00110	0f 8e 2a ff ff
	ff		 jle	 $LL19@RangeAttac
$LN24@RangeAttac:
  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx

; 365  : 		{
; 366  : 			break;
; 367  : 		}
; 368  : 	}
; 369  : }

  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c2 08 00	 ret	 8
?RangeAttack@CDarkSpirit@@QAEXHH@Z ENDP			; CDarkSpirit::RangeAttack
_TEXT	ENDS
PUBLIC	?ReSetTarget@CDarkSpirit@@QAEXH@Z		; CDarkSpirit::ReSetTarget
; Function compile flags: /Ogtp
;	COMDAT ?ReSetTarget@CDarkSpirit@@QAEXH@Z
_TEXT	SEGMENT
_aTargetIndex$ = 8					; size = 4
?ReSetTarget@CDarkSpirit@@QAEXH@Z PROC			; CDarkSpirit::ReSetTarget, COMDAT
; _this$ = ecx

; 436  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 437  : 	if ( this->m_iMasterIndex == -1 )

  00003	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00006	83 f8 ff	 cmp	 eax, -1
  00009	74 2e		 je	 SHORT $LN1@ReSetTarge

; 438  : 	{
; 439  : 		return;
; 440  : 	}
; 441  : 
; 442  : 	LPOBJ lpObj = &gObj[this->m_iMasterIndex];

  0000b	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 443  : 
; 444  : 	if ( lpObj->Class != 4 )	// DL

  00011	66 83 b8 98 00
	00 00 04	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+152], 4
  00019	75 1e		 jne	 SHORT $LN1@ReSetTarge

; 445  : 	{
; 446  : 		return;
; 447  : 	}
; 448  : 
; 449  : 	if ( aTargetIndex == this->m_iTargetIndex )

  0001b	8b 45 08	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0001e	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00021	75 16		 jne	 SHORT $LN1@ReSetTarge

; 450  : 	{
; 451  : 		this->m_iTargetIndex = -1;
; 452  : 
; 453  : 		if ( this->m_ActionMode == PetItem_Mode_Attack_Target )

  00023	83 79 20 03	 cmp	 DWORD PTR [ecx+32], 3
  00027	c7 41 18 ff ff
	ff ff		 mov	 DWORD PTR [ecx+24], -1
  0002e	75 09		 jne	 SHORT $LN1@ReSetTarge

; 454  : 		{
; 455  : 			this->SetMode(PetItem_Mode_Normal, -1);

  00030	6a ff		 push	 -1
  00032	6a 00		 push	 0
  00034	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode
$LN1@ReSetTarge:

; 456  : 		}
; 457  : 	}
; 458  : }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?ReSetTarget@CDarkSpirit@@QAEXH@Z ENDP			; CDarkSpirit::ReSetTarget
_TEXT	ENDS
PUBLIC	__real@4024000000000000
PUBLIC	??_C@_0EO@IMJLIFKK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$LE?Y?E?$KJ?$LN?$LK?G?G?$LI?$LE?$MA?G?$LJ?$NP?E?i?5Item?5i@ ; `string'
PUBLIC	??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5Le@ ; `string'
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff8000000000000
PUBLIC	?Attack@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HH@Z ; CDarkSpirit::Attack
EXTRN	?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHE@Z:PROC ; gObjLifeCheck
EXTRN	?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z:PROC ; GCMagicAttackNumberSend
EXTRN	?GCManaSend@@YAXHHEEH@Z:PROC			; GCManaSend
EXTRN	?gObjUniriaSprite@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjUniriaSprite
EXTRN	?gObjCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCheckSelfDefense
EXTRN	?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@E@Z:PROC ; GCMagicCancelSend
EXTRN	?gObjArmorRandomDurDown@@YAXPAUOBJECTSTRUCT@@0@Z:PROC ; gObjArmorRandomDurDown
EXTRN	?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z:PROC ; gObjGetRelationShip
EXTRN	?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z:PROC ; gObjAddMsgSendDelay
EXTRN	?gObjWeaponDurDownInCastle@@YAXPAUOBJECTSTRUCT@@0H@Z:PROC ; gObjWeaponDurDownInCastle
EXTRN	?gObjDarkHorse@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjDarkHorse
EXTRN	?GCReFillSend@@YAXHHEE@Z:PROC			; GCReFillSend
EXTRN	?IsDinorantReduceAttackDamaege@CItem@@QAEHXZ:PROC ; CItem::IsDinorantReduceAttackDamaege
EXTRN	?gObjDenorantSprite@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjDenorantSprite
EXTRN	?gObjWingSprite@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjWingSprite
EXTRN	?gObjAngelSprite@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjAngelSprite
EXTRN	?GCItemDurSend@@YAXHEEE@Z:PROC			; GCItemDurSend
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?DecPetItemExp@CItem@@QAEHH@Z:PROC		; CItem::DecPetItemExp
EXTRN	?GetTargetDefense@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0AAE@Z:PROC ; CObjBaseAttack::GetTargetDefense
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjDuelCheck
EXTRN	?PkCheck@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z:PROC ; CObjBaseAttack::PkCheck
EXTRN	?CheckAttackArea@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z:PROC ; CObjBaseAttack::CheckAttackArea
EXTRN	?gObjAttackQ@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjAttackQ
EXTRN	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjIsConnected
EXTRN	?gObjMonsterStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z:PROC ; gObjMonsterStateProc
EXTRN	?GetBattleSoccerGoalMove@@YAHH@Z:PROC		; GetBattleSoccerGoalMove
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT ??_C@_0EO@IMJLIFKK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$LE?Y?E?$KJ?$LN?$LK?G?G?$LI?$LE?$MA?G?$LJ?$NP?E?i?5Item?5i@
CONST	SEGMENT
??_C@_0EO@IMJLIFKK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$LE?Y?E?$KJ?$LN?$LK?G?G?$LI?$LE?$MA?G?$LJ?$NP?E?i?5Item?5i@ DB '['
	DB	'%s][%s] ', 0b4H, 0d9H, 0c5H, 0a9H, 0bdH, 0baH, 0c7H, 0c7H, 0b8H
	DB	0b4H, 0c0H, 0c7H, 0b9H, 0dfH, 0c5H, 0e9H, ' Item is Broken bec'
	DB	'ause durability is exhausted [%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5Le@
CONST	SEGMENT
??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5Le@ DB '['
	DB	'%s][%s][PetItemExpDown] [%s] Level:[%d]Exp:[%d]DecExp[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Attack@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HH@Z
_TEXT	SEGMENT
_MSBFlag$ = -16						; size = 4
_ManaChange$ = -12					; size = 4
_this$ = -8						; size = 4
_MsgDamage$ = -1					; size = 1
_skill$ = 8						; size = 4
_lpObj$ = 8						; size = 4
_AttackDamage$ = 12					; size = 4
_bIsOnDuel$ = 12					; size = 4
_lpTargetObj$ = 12					; size = 4
tv1168 = 16						; size = 4
tv1166 = 16						; size = 4
tv1070 = 16						; size = 4
tv1068 = 16						; size = 4
_bAllMiss$ = 16						; size = 4
_lpCallObj$ = 16					; size = 4
_lpMagic$ = 16						; size = 4
tv1198 = 20						; size = 4
tv1161 = 20						; size = 4
tv1160 = 20						; size = 4
tv1158 = 20						; size = 4
tv1149 = 20						; size = 4
tv1147 = 20						; size = 4
tv1139 = 20						; size = 4
tv1138 = 20						; size = 4
tv1136 = 20						; size = 4
tv1129 = 20						; size = 4
tv1127 = 20						; size = 4
tv1122 = 20						; size = 4
tv992 = 20						; size = 4
_selfdefense$ = 20					; size = 4
_replacemana$155654 = 20				; size = 4
_Wing$155627 = 20					; size = 4
_iPetExp$155619 = 20					; size = 4
_criticaldamage$ = 20					; size = 4
tv1171 = 22						; size = 2
tv1073 = 22						; size = 2
_iActionType$ = 24					; size = 4
?Attack@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HH@Z PROC ; CDarkSpirit::Attack, COMDAT
; _this$ = ecx

; 567  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	57		 push	 edi

; 568  : 	int skillSuccess = 0;
; 569  : 	LPOBJ lpCallObj;
; 570  : 	LPOBJ lpCallTargetObj;
; 571  : 	unsigned char MsgDamage = 0;
; 572  : 	int ManaChange = 0;
; 573  : 
; 574  : 	if ( (lpTargetObj->Authority&2) == 2 )

  00008	8b 7d 0c	 mov	 edi, DWORD PTR _lpTargetObj$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	33 c9		 xor	 ecx, ecx
  0000f	f6 87 a4 01 00
	00 02		 test	 BYTE PTR [edi+420], 2
  00016	89 5d f8	 mov	 DWORD PTR _this$[ebp], ebx
  00019	88 4d ff	 mov	 BYTE PTR _MsgDamage$[ebp], cl
  0001c	89 4d f4	 mov	 DWORD PTR _ManaChange$[ebp], ecx
  0001f	74 0a		 je	 SHORT $LN107@Attack

; 575  : 		return FALSE;

  00021	5f		 pop	 edi
  00022	33 c0		 xor	 eax, eax
  00024	5b		 pop	 ebx

; 1105 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 14 00	 ret	 20			; 00000014H
$LN107@Attack:
  0002b	56		 push	 esi

; 576  : 
; 577  : 	if ( lpObj->MapNumber != lpTargetObj->MapNumber )

  0002c	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0002f	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00035	3a 87 09 01 00
	00		 cmp	 al, BYTE PTR [edi+265]

; 578  : 		return FALSE;

  0003b	0f 85 6e 01 00
	00		 jne	 $LN173@Attack

; 579  : 
; 580  : 	int skill = 0;
; 581  : 	
; 582  : 	if ( lpMagic )

  00041	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00044	89 4d 08	 mov	 DWORD PTR _skill$[ebp], ecx
  00047	3b c1		 cmp	 eax, ecx
  00049	74 07		 je	 SHORT $LN105@Attack

; 583  : 		skill = lpMagic->m_Skill;

  0004b	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  0004f	89 55 08	 mov	 DWORD PTR _skill$[ebp], edx
$LN105@Attack:

; 584  : 
; 585  : 	skillSuccess = TRUE;
; 586  : 
; 587  : 	if ( lpObj->GuildNumber > 0 )

  00052	39 8e b0 02 00
	00		 cmp	 DWORD PTR [esi+688], ecx
  00058	7e 2d		 jle	 SHORT $LN137@Attack

; 588  : 	{
; 589  : 		if ( lpObj->lpGuild )

  0005a	8b 86 b4 02 00
	00		 mov	 eax, DWORD PTR [esi+692]
  00060	3b c1		 cmp	 eax, ecx
  00062	74 23		 je	 SHORT $LN137@Attack

; 590  : 		{
; 591  : 			if ( lpObj->lpGuild->WarState )

  00064	38 88 91 05 00
	00		 cmp	 BYTE PTR [eax+1425], cl
  0006a	74 1b		 je	 SHORT $LN137@Attack

; 592  : 			{
; 593  : 				if ( lpObj->lpGuild->WarType == 1 )

  0006c	80 b8 92 05 00
	00 01		 cmp	 BYTE PTR [eax+1426], 1
  00073	75 12		 jne	 SHORT $LN137@Attack

; 594  : 				{
; 595  : 					if ( !GetBattleSoccerGoalMove(0) )

  00075	6a 00		 push	 0
  00077	e8 00 00 00 00	 call	 ?GetBattleSoccerGoalMove@@YAHH@Z ; GetBattleSoccerGoalMove
  0007c	83 c4 04	 add	 esp, 4
  0007f	85 c0		 test	 eax, eax

; 596  : 					{
; 597  : 						return TRUE;

  00081	0f 84 79 0a 00
	00		 je	 $LN134@Attack
$LN137@Attack:

; 598  : 					}
; 599  : 				}
; 600  : 			}
; 601  : 		}
; 602  : 	}
; 603  : 
; 604  : 	if ( lpTargetObj->Type == OBJ_MONSTER )

  00087	66 83 7f 60 02	 cmp	 WORD PTR [edi+96], 2
  0008c	75 4e		 jne	 SHORT $LN98@Attack

; 605  : 	{
; 606  : 		if ( lpTargetObj->Class == 200 )

  0008e	b8 c8 00 00 00	 mov	 eax, 200		; 000000c8H
  00093	66 39 87 98 00
	00 00		 cmp	 WORD PTR [edi+152], ax
  0009a	75 40		 jne	 SHORT $LN98@Attack

; 607  : 		{
; 608  : 			if ( skill )

  0009c	83 7d 08 00	 cmp	 DWORD PTR _skill$[ebp], 0

; 609  : 			{
; 610  : 				gObjMonsterStateProc(lpTargetObj, 7, lpObj->m_Index, 0);

  000a0	6a 00		 push	 0
  000a2	74 1c		 je	 SHORT $LN97@Attack
  000a4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000a6	51		 push	 ecx
  000a7	6a 07		 push	 7

; 611  : 			}
; 612  : 			else
; 613  : 			{
; 614  : 				gObjMonsterStateProc(lpTargetObj, 6, lpObj->m_Index, 0);

  000a9	57		 push	 edi
  000aa	e8 00 00 00 00	 call	 ?gObjMonsterStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z ; gObjMonsterStateProc
  000af	83 c4 10	 add	 esp, 16			; 00000010H
  000b2	5e		 pop	 esi
  000b3	5f		 pop	 edi

; 1101 : 		}
; 1102 : 	}
; 1103 : 
; 1104 : 	return TRUE;

  000b4	b8 01 00 00 00	 mov	 eax, 1
  000b9	5b		 pop	 ebx

; 1105 : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 14 00	 ret	 20			; 00000014H
$LN97@Attack:

; 611  : 			}
; 612  : 			else
; 613  : 			{
; 614  : 				gObjMonsterStateProc(lpTargetObj, 6, lpObj->m_Index, 0);

  000c0	8b 16		 mov	 edx, DWORD PTR [esi]
  000c2	52		 push	 edx
  000c3	6a 06		 push	 6
  000c5	57		 push	 edi
  000c6	e8 00 00 00 00	 call	 ?gObjMonsterStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z ; gObjMonsterStateProc
  000cb	83 c4 10	 add	 esp, 16			; 00000010H
  000ce	5e		 pop	 esi
  000cf	5f		 pop	 edi

; 1101 : 		}
; 1102 : 	}
; 1103 : 
; 1104 : 	return TRUE;

  000d0	b8 01 00 00 00	 mov	 eax, 1
  000d5	5b		 pop	 ebx

; 1105 : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 14 00	 ret	 20			; 00000014H
$LN98@Attack:

; 615  : 			}
; 616  : 
; 617  : 			return TRUE;
; 618  : 		}
; 619  : 	}
; 620  : 
; 621  : 	if ( lpObj->Type == OBJ_USER )

  000dc	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  000e1	75 11		 jne	 SHORT $LN138@Attack

; 622  : 	{
; 623  : 		if ( !gObjIsConnected(lpObj))

  000e3	56		 push	 esi
  000e4	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000e9	83 c4 04	 add	 esp, 4
  000ec	85 c0		 test	 eax, eax

; 624  : 		{
; 625  : 			return FALSE;

  000ee	0f 84 bb 00 00
	00		 je	 $LN173@Attack
$LN138@Attack:

; 626  : 		}
; 627  : 	}
; 628  : 
; 629  : 	if ( lpTargetObj->Type == OBJ_USER )

  000f4	66 83 7f 60 01	 cmp	 WORD PTR [edi+96], 1
  000f9	75 11		 jne	 SHORT $LN139@Attack

; 630  : 	{
; 631  : 		if ( !gObjIsConnected(lpTargetObj))

  000fb	57		 push	 edi
  000fc	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00101	83 c4 04	 add	 esp, 4
  00104	85 c0		 test	 eax, eax

; 632  : 		{
; 633  : 			return FALSE;

  00106	0f 84 a3 00 00
	00		 je	 $LN173@Attack
$LN139@Attack:

; 634  : 		}
; 635  : 	}
; 636  : 
; 637  : 	if ( lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_MONSTER )	// PLAYER VS MONSTER

  0010c	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00111	75 19		 jne	 SHORT $LN89@Attack
  00113	66 83 7f 60 02	 cmp	 WORD PTR [edi+96], 2
  00118	75 12		 jne	 SHORT $LN89@Attack

; 638  : 	{
; 639  : 		if ( lpObj->m_RecallMon >= 0 )

  0011a	8b 86 cc 02 00
	00		 mov	 eax, DWORD PTR [esi+716]
  00120	85 c0		 test	 eax, eax
  00122	78 08		 js	 SHORT $LN89@Attack

; 640  : 		{
; 641  : 			if ( lpObj->m_RecallMon == lpTargetObj->m_Index )

  00124	3b 07		 cmp	 eax, DWORD PTR [edi]

; 642  : 			{
; 643  : 				return FALSE;

  00126	0f 84 83 00 00
	00		 je	 $LN173@Attack
$LN89@Attack:

; 644  : 			}
; 645  : 		}
; 646  : 	}
; 647  : 
; 648  : 	if ( !gObjAttackQ(lpTargetObj))

  0012c	57		 push	 edi
  0012d	e8 00 00 00 00	 call	 ?gObjAttackQ@@YAHPAUOBJECTSTRUCT@@@Z ; gObjAttackQ
  00132	83 c4 04	 add	 esp, 4
  00135	85 c0		 test	 eax, eax

; 649  : 		return FALSE;

  00137	74 76		 je	 SHORT $LN173@Attack

; 650  : 
; 651  : #if GS_CASTLE == 1
; 652  : 	if ( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 653  : 	{
; 654  : 		if ( lpObj->m_btCsJoinSide > 0 && lpObj->m_btCsJoinSide == lpTargetObj->m_btCsJoinSide )
; 655  : 		{
; 656  : 			return FALSE;
; 657  : 		}
; 658  : 	}
; 659  : #endif
; 660  : 
; 661  : 	lpObj->m_TotalAttackCount++;

  00139	ff 86 f8 01 00
	00		 inc	 DWORD PTR [esi+504]

; 662  : 
; 663  : 	if ( this->CheckAttackArea(lpObj, lpTargetObj) == FALSE )

  0013f	57		 push	 edi
  00140	56		 push	 esi
  00141	8b cb		 mov	 ecx, ebx
  00143	e8 00 00 00 00	 call	 ?CheckAttackArea@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z ; CObjBaseAttack::CheckAttackArea
  00148	85 c0		 test	 eax, eax

; 664  : 		return FALSE;

  0014a	74 63		 je	 SHORT $LN173@Attack

; 665  : 
; 666  : 	lpCallObj = lpObj;
; 667  : 	lpCallTargetObj = lpTargetObj;
; 668  : 
; 669  : 	if ( lpTargetObj->Type == OBJ_MONSTER )
; 670  : 	{
; 671  : 		if ( lpTargetObj->m_RecallMon >= 0 )
; 672  : 		{
; 673  : 			lpCallTargetObj = &gObj[lpTargetObj->m_RecallMon];
; 674  : 		}
; 675  : 	}
; 676  : 
; 677  : 	if ( this->PkCheck(lpCallObj, lpTargetObj) == FALSE )

  0014c	57		 push	 edi
  0014d	56		 push	 esi
  0014e	8b cb		 mov	 ecx, ebx
  00150	e8 00 00 00 00	 call	 ?PkCheck@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z ; CObjBaseAttack::PkCheck
  00155	85 c0		 test	 eax, eax

; 678  : 		return FALSE;

  00157	74 56		 je	 SHORT $LN173@Attack

; 679  : 
; 680  : 	int Strength = lpObj->Strength + lpObj->AddStrength;
; 681  : 	int Dexterity = lpObj->Dexterity + lpObj->AddDexterity;
; 682  : 	int Vitality = lpObj->Vitality + lpObj->AddVitality;
; 683  : 	int Energy = lpObj->Energy + lpObj->AddEnergy;
; 684  : 	BOOL bIsOnDuel = gObjDuelCheck(lpObj, lpTargetObj);

  00159	57		 push	 edi
  0015a	56		 push	 esi
  0015b	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjDuelCheck
  00160	83 c4 08	 add	 esp, 8
  00163	89 45 0c	 mov	 DWORD PTR _bIsOnDuel$[ebp], eax

; 685  : 
; 686  : 	if ( bIsOnDuel )

  00166	85 c0		 test	 eax, eax
  00168	74 19		 je	 SHORT $LN83@Attack

; 687  : 	{
; 688  : 		lpObj->m_iDuelTickCount = GetTickCount();

  0016a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  00170	ff d3		 call	 ebx
  00172	89 86 24 0d 00
	00		 mov	 DWORD PTR [esi+3364], eax

; 689  : 		lpTargetObj->m_iDuelTickCount = GetTickCount();

  00178	ff d3		 call	 ebx
  0017a	8b 5d f8	 mov	 ebx, DWORD PTR _this$[ebp]
  0017d	89 87 24 0d 00
	00		 mov	 DWORD PTR [edi+3364], eax
$LN83@Attack:

; 690  : 	}
; 691  : 
; 692  : 	int MSBFlag = 0;
; 693  : 	//MsgDamage = 0;
; 694  : 	
; 695  : 	if ( criticaldamage )

  00183	8b 4d 14	 mov	 ecx, DWORD PTR _criticaldamage$[ebp]
  00186	33 c0		 xor	 eax, eax

; 696  : 	{
; 697  : 		MsgDamage = 3;
; 698  : 	}
; 699  : 	else
; 700  : 	{
; 701  : 		MsgDamage = 0;
; 702  : 	}
; 703  : 
; 704  : 	BOOL bAllMiss = FALSE;
; 705  : 	int AttackDamage = 0;
; 706  : 
; 707  : 	if ( !this->MissCheck(lpObj, lpTargetObj, skill, skillSuccess, bAllMiss) )

  00188	8d 55 10	 lea	 edx, DWORD PTR _bAllMiss$[ebp]
  0018b	52		 push	 edx
  0018c	f7 d9		 neg	 ecx
  0018e	6a 01		 push	 1
  00190	89 45 f0	 mov	 DWORD PTR _MSBFlag$[ebp], eax
  00193	89 45 10	 mov	 DWORD PTR _bAllMiss$[ebp], eax
  00196	8b 45 08	 mov	 eax, DWORD PTR _skill$[ebp]
  00199	1a c9		 sbb	 cl, cl
  0019b	50		 push	 eax
  0019c	80 e1 03	 and	 cl, 3
  0019f	57		 push	 edi
  001a0	88 4d ff	 mov	 BYTE PTR _MsgDamage$[ebp], cl
  001a3	56		 push	 esi
  001a4	8b cb		 mov	 ecx, ebx
  001a6	e8 00 00 00 00	 call	 ?MissCheck@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0HHAAH@Z ; CDarkSpirit::MissCheck
  001ab	85 c0		 test	 eax, eax
  001ad	75 0b		 jne	 SHORT $LN80@Attack
$LN173@Attack:
  001af	5e		 pop	 esi
  001b0	5f		 pop	 edi

; 708  : 	{
; 709  : 		return FALSE;

  001b1	33 c0		 xor	 eax, eax
  001b3	5b		 pop	 ebx

; 1105 : }

  001b4	8b e5		 mov	 esp, ebp
  001b6	5d		 pop	 ebp
  001b7	c2 14 00	 ret	 20			; 00000014H
$LN80@Attack:

; 710  : 	}
; 711  : 
; 712  : 	int targetdefense = this->GetTargetDefense(lpObj, lpTargetObj, MsgDamage);

  001ba	8b 5d f8	 mov	 ebx, DWORD PTR _this$[ebp]
  001bd	8d 4d ff	 lea	 ecx, DWORD PTR _MsgDamage$[ebp]
  001c0	51		 push	 ecx
  001c1	57		 push	 edi
  001c2	56		 push	 esi
  001c3	8b cb		 mov	 ecx, ebx
  001c5	e8 00 00 00 00	 call	 ?GetTargetDefense@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0AAE@Z ; CObjBaseAttack::GetTargetDefense

; 713  : 	AttackDamage = this->GetAttackDamage(lpObj, targetdefense, bIsOnDuel, criticaldamage);

  001ca	8b 55 14	 mov	 edx, DWORD PTR _criticaldamage$[ebp]
  001cd	8b 4d 0c	 mov	 ecx, DWORD PTR _bIsOnDuel$[ebp]
  001d0	52		 push	 edx
  001d1	51		 push	 ecx
  001d2	50		 push	 eax
  001d3	56		 push	 esi
  001d4	8b cb		 mov	 ecx, ebx
  001d6	e8 00 00 00 00	 call	 ?GetAttackDamage@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@HHH@Z ; CDarkSpirit::GetAttackDamage

; 714  : 
; 715  : 	if ( criticaldamage == 0 && iActionType == 0 )

  001db	83 7d 14 00	 cmp	 DWORD PTR _criticaldamage$[ebp], 0
  001df	8b d8		 mov	 ebx, eax
  001e1	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx
  001e4	75 19		 jne	 SHORT $LN122@Attack
  001e6	83 7d 18 00	 cmp	 DWORD PTR _iActionType$[ebp], 0
  001ea	75 13		 jne	 SHORT $LN122@Attack

; 716  : 	{
; 717  : 		AttackDamage /= 1.5;

  001ec	db 45 0c	 fild	 DWORD PTR _AttackDamage$[ebp]
  001ef	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@3ff8000000000000
  001f5	e8 00 00 00 00	 call	 __ftol2_sse
  001fa	8b d8		 mov	 ebx, eax
  001fc	89 45 0c	 mov	 DWORD PTR _AttackDamage$[ebp], eax
$LN122@Attack:

; 718  : 	}
; 719  : 
; 720  : 	if ( bAllMiss )

  001ff	83 7d 10 00	 cmp	 DWORD PTR _bAllMiss$[ebp], 0
  00203	74 1f		 je	 SHORT $LN78@Attack

; 721  : 	{
; 722  : 		AttackDamage = ( AttackDamage * 30 ) / 100;

  00205	8b cb		 mov	 ecx, ebx
  00207	c1 e1 04	 shl	 ecx, 4
  0020a	2b cb		 sub	 ecx, ebx
  0020c	03 c9		 add	 ecx, ecx
  0020e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00213	f7 e9		 imul	 ecx
  00215	c1 fa 05	 sar	 edx, 5
  00218	8b c2		 mov	 eax, edx
  0021a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0021d	03 c2		 add	 eax, edx
  0021f	8b d8		 mov	 ebx, eax
  00221	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx
$LN78@Attack:

; 723  : 	}
; 724  : 
; 725  : 	if ( lpTargetObj->DamageMinus )

  00224	8a 87 14 01 00
	00		 mov	 al, BYTE PTR [edi+276]
  0022a	84 c0		 test	 al, al
  0022c	74 1c		 je	 SHORT $LN77@Attack

; 726  : 	{
; 727  : 		int beforeDamage = AttackDamage;
; 728  : 		AttackDamage -= ( ( AttackDamage * (int)lpTargetObj->DamageMinus) / 100 );

  0022e	0f b6 c8	 movzx	 ecx, al
  00231	0f af cb	 imul	 ecx, ebx
  00234	b8 e1 7a 14 ae	 mov	 eax, -1374389535	; ae147ae1H
  00239	f7 e9		 imul	 ecx
  0023b	c1 fa 05	 sar	 edx, 5
  0023e	8b ca		 mov	 ecx, edx
  00240	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00243	03 ca		 add	 ecx, edx
  00245	03 d9		 add	 ebx, ecx
  00247	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx
$LN77@Attack:

; 729  : 	}
; 730  : 
; 731  : 	int tlevel = lpObj->Level / 10;

  0024a	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR [esi+156]
  00251	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00256	f7 e9		 imul	 ecx
  00258	c1 fa 02	 sar	 edx, 2
  0025b	8b c2		 mov	 eax, edx
  0025d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00260	03 c2		 add	 eax, edx

; 732  : 
; 733  : 	if ( AttackDamage < tlevel )

  00262	3b d8		 cmp	 ebx, eax
  00264	7d 0f		 jge	 SHORT $LN123@Attack

; 734  : 	{
; 735  : 		if ( tlevel < 1 )

  00266	83 f8 01	 cmp	 eax, 1
  00269	7d 05		 jge	 SHORT $LN75@Attack

; 736  : 		{
; 737  : 			tlevel = 1;

  0026b	b8 01 00 00 00	 mov	 eax, 1
$LN75@Attack:

; 738  : 		}
; 739  : 
; 740  : 		AttackDamage = tlevel;

  00270	8b d8		 mov	 ebx, eax
  00272	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx
$LN123@Attack:

; 741  : 	}
; 742  : 
; 743  : 	if ( lpTargetObj->m_SkillNumber == 18 )

  00275	66 83 bf 3c 02
	00 00 12	 cmp	 WORD PTR [edi+572], 18	; 00000012H
  0027d	75 0a		 jne	 SHORT $LN73@Attack

; 744  : 	{
; 745  : 		if ( AttackDamage > 1 )

  0027f	83 fb 01	 cmp	 ebx, 1
  00282	7e 05		 jle	 SHORT $LN73@Attack

; 746  : 		{
; 747  : 			AttackDamage >>= 1;

  00284	d1 fb		 sar	 ebx, 1
  00286	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx
$LN73@Attack:

; 748  : 		}
; 749  : 	}
; 750  : 
; 751  : 	lpObj->pInventory[1].m_DurabilitySmall += AttackDamage * 2 / 100;

  00289	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0028f	8d 14 1b	 lea	 edx, DWORD PTR [ebx+ebx]
  00292	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00297	f7 ea		 imul	 edx
  00299	c1 fa 05	 sar	 edx, 5
  0029c	8b c2		 mov	 eax, edx
  0029e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002a1	03 c2		 add	 eax, edx
  002a3	66 01 81 d0 00
	00 00		 add	 WORD PTR [ecx+208], ax

; 752  : 
; 753  : 	if ( lpObj->pInventory[1].m_DurabilitySmall >= 800 )

  002aa	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  002b0	b9 20 03 00 00	 mov	 ecx, 800		; 00000320H
  002b5	66 39 88 d0 00
	00 00		 cmp	 WORD PTR [eax+208], cx
  002bc	0f 82 29 01 00
	00		 jb	 $LN72@Attack

; 754  : 	{
; 755  : 		lpObj->pInventory[1].m_DurabilitySmall = 0;

  002c2	33 d2		 xor	 edx, edx
  002c4	66 89 90 d0 00
	00 00		 mov	 WORD PTR [eax+208], dx

; 756  : 		lpObj->pInventory[1].m_Durability -= 1.0f;

  002cb	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  002d1	d9 80 cc 00 00
	00		 fld	 DWORD PTR [eax+204]
  002d7	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  002dd	d9 98 cc 00 00
	00		 fstp	 DWORD PTR [eax+204]

; 757  : 
; 758  : 		if ( lpObj->pInventory[1].m_Durability < 1.0f )

  002e3	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  002e9	d9 e8		 fld1
  002eb	d8 99 cc 00 00
	00		 fcomp	 DWORD PTR [ecx+204]
  002f1	df e0		 fnstsw	 ax
  002f3	f6 c4 41	 test	 ah, 65			; 00000041H
  002f6	0f 85 b5 00 00
	00		 jne	 $LN71@Attack

; 759  : 		{
; 760  : 			lpObj->pInventory[1].m_Durability = 0;

  002fc	d9 ee		 fldz

; 761  : 			int iPetExp = lpObj->pInventory[1].m_PetItem_Exp;
; 762  : 
; 763  : 			if ( lpObj->pInventory[1].DecPetItemExp(10) )

  002fe	6a 0a		 push	 10			; 0000000aH
  00300	d9 99 cc 00 00
	00		 fstp	 DWORD PTR [ecx+204]
  00306	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0030c	8b 88 4c 01 00
	00		 mov	 ecx, DWORD PTR [eax+332]
  00312	89 4d 14	 mov	 DWORD PTR _iPetExp$155619[ebp], ecx
  00315	8d 88 a8 00 00
	00		 lea	 ecx, DWORD PTR [eax+168]
  0031b	e8 00 00 00 00	 call	 ?DecPetItemExp@CItem@@QAEHH@Z ; CItem::DecPetItemExp
  00320	85 c0		 test	 eax, eax
  00322	74 69		 je	 SHORT $LN70@Attack

; 764  : 			{
; 765  : 				LogAdd(LOG_BLACK, "[%s][%s][PetItemExpDown] [%s] Level:[%d]Exp:[%d]DecExp[%d]",
; 766  : 					lpObj->AccountID, lpObj->Name, lpObj->pInventory[1].GetName(),
; 767  : 					lpObj->pInventory[1].m_PetItem_Level,
; 768  : 					lpObj->pInventory[1].m_PetItem_Exp, iPetExp - lpObj->pInventory[1].m_PetItem_Exp);

  00324	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0032a	8b 88 4c 01 00
	00		 mov	 ecx, DWORD PTR [eax+332]
  00330	8b 55 14	 mov	 edx, DWORD PTR _iPetExp$155619[ebp]
  00333	2b d1		 sub	 edx, ecx
  00335	52		 push	 edx
  00336	8b 90 48 01 00
	00		 mov	 edx, DWORD PTR [eax+328]
  0033c	51		 push	 ecx
  0033d	52		 push	 edx
  0033e	8d 88 a8 00 00
	00		 lea	 ecx, DWORD PTR [eax+168]
  00344	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00349	50		 push	 eax
  0034a	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  0034d	50		 push	 eax
  0034e	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  00351	51		 push	 ecx
  00352	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5Le@
  00357	6a 00		 push	 0
  00359	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 769  : 
; 770  : 				this->Set(lpObj->m_Index, &lpObj->pInventory[1]);

  0035e	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00364	8b 06		 mov	 eax, DWORD PTR [esi]
  00366	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00369	83 c4 20	 add	 esp, 32			; 00000020H
  0036c	81 c2 a8 00 00
	00		 add	 edx, 168		; 000000a8H
  00372	52		 push	 edx
  00373	50		 push	 eax
  00374	e8 00 00 00 00	 call	 ?Set@CDarkSpirit@@QAEXHPAVCItem@@@Z ; CDarkSpirit::Set

; 771  : 				this->SendLevelmsg(lpObj->m_Index, 1, 0, 0xFF);

  00379	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0037b	68 ff 00 00 00	 push	 255			; 000000ffH
  00380	6a 00		 push	 0
  00382	6a 01		 push	 1
  00384	51		 push	 ecx
  00385	e8 00 00 00 00	 call	 ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ; CDarkSpirit::SendLevelmsg
  0038a	83 c4 10	 add	 esp, 16			; 00000010H
$LN70@Attack:

; 772  : 			}
; 773  : 
; 774  : 			LogAdd(LOG_BLACK, "[%s][%s] 다크스피릿의발톱 Item is Broken because durability is exhausted [%d]",
; 775  : 				lpObj->AccountID, lpObj->Name, lpObj->pInventory[1].m_Number);

  0038d	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00393	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00399	50		 push	 eax
  0039a	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  0039d	51		 push	 ecx
  0039e	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  003a1	52		 push	 edx
  003a2	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@IMJLIFKK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$LE?Y?E?$KJ?$LN?$LK?G?G?$LI?$LE?$MA?G?$LJ?$NP?E?i?5Item?5i@
  003a7	6a 00		 push	 0
  003a9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  003ae	83 c4 14	 add	 esp, 20			; 00000014H
$LN71@Attack:

; 776  : 		}
; 777  : 
; 778  : 		GCItemDurSend(lpObj->m_Index, 1, lpObj->pInventory[1].m_Durability, 0);

  003b1	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  003b7	d9 7d 16	 fnstcw	 WORD PTR tv1171[ebp]
  003ba	d9 80 cc 00 00
	00		 fld	 DWORD PTR [eax+204]
  003c0	6a 00		 push	 0
  003c2	0f b7 45 16	 movzx	 eax, WORD PTR tv1171[ebp]
  003c6	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  003cb	89 45 10	 mov	 DWORD PTR tv1168[ebp], eax
  003ce	8b 06		 mov	 eax, DWORD PTR [esi]
  003d0	d9 6d 10	 fldcw	 WORD PTR tv1168[ebp]
  003d3	db 5d 10	 fistp	 DWORD PTR tv1166[ebp]
  003d6	8a 4d 10	 mov	 cl, BYTE PTR tv1166[ebp]
  003d9	0f b6 d1	 movzx	 edx, cl
  003dc	52		 push	 edx
  003dd	6a 01		 push	 1
  003df	d9 6d 16	 fldcw	 WORD PTR tv1171[ebp]
  003e2	50		 push	 eax
  003e3	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  003e8	83 c4 10	 add	 esp, 16			; 00000010H
$LN72@Attack:

; 779  : 	}
; 780  : 
; 781  : 	if ( gObjAngelSprite(lpTargetObj) == TRUE )

  003eb	57		 push	 edi
  003ec	e8 00 00 00 00	 call	 ?gObjAngelSprite@@YAHPAUOBJECTSTRUCT@@@Z ; gObjAngelSprite
  003f1	83 c4 04	 add	 esp, 4
  003f4	83 f8 01	 cmp	 eax, 1
  003f7	75 27		 jne	 SHORT $LN68@Attack

; 782  : 	{
; 783  : 		if ( AttackDamage > 1 )

  003f9	3b d8		 cmp	 ebx, eax
  003fb	7e 23		 jle	 SHORT $LN68@Attack

; 784  : 		{
; 785  : 			float  damage = (AttackDamage * 8) / 10.0f;

  003fd	8d 0c dd 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*8]

; 786  : 			AttackDamage = damage;

  00404	89 4d 14	 mov	 DWORD PTR tv1161[ebp], ecx
  00407	db 45 14	 fild	 DWORD PTR tv1161[ebp]
  0040a	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4024000000000000
  00410	d9 5d 14	 fstp	 DWORD PTR tv1158[ebp]
  00413	d9 45 14	 fld	 DWORD PTR tv1158[ebp]
  00416	e8 00 00 00 00	 call	 __ftol2_sse
  0041b	8b d8		 mov	 ebx, eax
  0041d	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx
$LN68@Attack:

; 787  : 		}
; 788  : 	}
; 789  : 
; 790  : 	if ( gObjWingSprite(lpTargetObj) == TRUE )

  00420	57		 push	 edi
  00421	e8 00 00 00 00	 call	 ?gObjWingSprite@@YAHPAUOBJECTSTRUCT@@@Z ; gObjWingSprite
  00426	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4059000000000000
  0042c	83 c4 04	 add	 esp, 4
  0042f	83 f8 01	 cmp	 eax, 1
  00432	0f 85 bd 00 00
	00		 jne	 $LN145@Attack

; 791  : 	{
; 792  : 		CItem * Wing = &lpTargetObj->pInventory[7];

  00438	8b 87 8c 0c 00
	00		 mov	 eax, DWORD PTR [edi+3212]
  0043e	05 98 04 00 00	 add	 eax, 1176		; 00000498H
  00443	89 45 14	 mov	 DWORD PTR _Wing$155627[ebp], eax

; 793  : 
; 794  : 		if ( AttackDamage > 1 )

  00446	83 fb 01	 cmp	 ebx, 1
  00449	0f 8e a6 00 00
	00		 jle	 $LN145@Attack

; 795  : 		{
; 796  : 			if ( Wing->m_Type > ITEMGET(12, 2) )

  0044f	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00453	ba 02 18 00 00	 mov	 edx, 6146		; 00001802H
  00458	66 3b ca	 cmp	 cx, dx
  0045b	7e 28		 jle	 SHORT $LN65@Attack

; 797  : 			{
; 798  : 				float damage = (float)(AttackDamage * (75 - (Wing->m_Level*2))) / 100.0f;
; 799  : 				AttackDamage = (int)(damage);

  0045d	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  00461	03 c0		 add	 eax, eax
  00463	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00468	2b c8		 sub	 ecx, eax
  0046a	0f af cb	 imul	 ecx, ebx
  0046d	89 4d 14	 mov	 DWORD PTR tv1149[ebp], ecx
  00470	da 7d 14	 fidivr	 DWORD PTR tv1149[ebp]
  00473	d9 5d 14	 fstp	 DWORD PTR tv1147[ebp]
  00476	d9 45 14	 fld	 DWORD PTR tv1147[ebp]
  00479	e8 00 00 00 00	 call	 __ftol2_sse
  0047e	8b d8		 mov	 ebx, eax
  00480	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx
  00483	eb 72		 jmp	 SHORT $LN62@Attack
$LN65@Attack:

; 800  : 			}
; 801  : 			else if(NEWWINGS(Wing->m_Type))

  00485	ba 64 18 00 00	 mov	 edx, 6244		; 00001864H
  0048a	66 3b ca	 cmp	 cx, dx
  0048d	7c 3e		 jl	 SHORT $LN63@Attack
  0048f	33 d2		 xor	 edx, edx
  00491	b8 7d 18 00 00	 mov	 eax, 6269		; 0000187dH
  00496	66 3b c8	 cmp	 cx, ax
  00499	0f 9e c2	 setle	 dl
  0049c	8b c2		 mov	 eax, edx
  0049e	85 c0		 test	 eax, eax

; 802  : 			{
; 803  : 				float damage = (float)(AttackDamage * (50 - (Wing->m_Level*2))) / 100.0f;
; 804  : 				AttackDamage = (int)(damage);

  004a0	8b 45 14	 mov	 eax, DWORD PTR _Wing$155627[ebp]
  004a3	74 28		 je	 SHORT $LN63@Attack
  004a5	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  004a9	ba 19 00 00 00	 mov	 edx, 25			; 00000019H
  004ae	2b d1		 sub	 edx, ecx
  004b0	0f af d3	 imul	 edx, ebx
  004b3	03 d2		 add	 edx, edx
  004b5	89 55 14	 mov	 DWORD PTR tv1138[ebp], edx
  004b8	da 7d 14	 fidivr	 DWORD PTR tv1138[ebp]
  004bb	d9 5d 14	 fstp	 DWORD PTR tv1136[ebp]
  004be	d9 45 14	 fld	 DWORD PTR tv1136[ebp]
  004c1	e8 00 00 00 00	 call	 __ftol2_sse
  004c6	8b d8		 mov	 ebx, eax
  004c8	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx

; 805  : 			}
; 806  : 			else

  004cb	eb 2a		 jmp	 SHORT $LN62@Attack
$LN63@Attack:

; 807  : 			{
; 808  : 				float damage = (float)(AttackDamage * (88 - (Wing->m_Level*2))) / 100.0f;
; 809  : 				AttackDamage = (int)(damage);

  004cd	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  004d1	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  004d6	2b c8		 sub	 ecx, eax
  004d8	0f af cb	 imul	 ecx, ebx
  004db	03 c9		 add	 ecx, ecx
  004dd	89 4d 14	 mov	 DWORD PTR tv1129[ebp], ecx
  004e0	da 7d 14	 fidivr	 DWORD PTR tv1129[ebp]
  004e3	d9 5d 14	 fstp	 DWORD PTR tv1127[ebp]
  004e6	d9 45 14	 fld	 DWORD PTR tv1127[ebp]
  004e9	e8 00 00 00 00	 call	 __ftol2_sse
  004ee	8b d8		 mov	 ebx, eax
  004f0	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx
  004f3	eb 02		 jmp	 SHORT $LN62@Attack
$LN145@Attack:

; 793  : 
; 794  : 		if ( AttackDamage > 1 )

  004f5	dd d8		 fstp	 ST(0)
$LN62@Attack:

; 810  : 			}
; 811  : 		}
; 812  : 	}
; 813  : 
; 814  : 	if ( gObjDenorantSprite(lpTargetObj ) )

  004f7	57		 push	 edi
  004f8	e8 00 00 00 00	 call	 ?gObjDenorantSprite@@YAHPAUOBJECTSTRUCT@@@Z ; gObjDenorantSprite
  004fd	83 c4 04	 add	 esp, 4
  00500	85 c0		 test	 eax, eax
  00502	74 7c		 je	 SHORT $LN61@Attack

; 815  : 	{
; 816  : 		CItem * Dinorant = &lpTargetObj->pInventory[8];

  00504	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3212]
  0050a	81 c1 40 05 00
	00		 add	 ecx, 1344		; 00000540H

; 817  : 		int dinorantdecdamage = 90 - Dinorant->IsDinorantReduceAttackDamaege();

  00510	e8 00 00 00 00	 call	 ?IsDinorantReduceAttackDamaege@CItem@@QAEHXZ ; CItem::IsDinorantReduceAttackDamaege

; 818  : 		lpObj->Life -= 1.0f;

  00515	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  0051b	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  00521	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00526	2b c8		 sub	 ecx, eax
  00528	d9 5d 14	 fstp	 DWORD PTR tv1122[ebp]
  0052b	d9 45 14	 fld	 DWORD PTR tv1122[ebp]
  0052e	d9 96 bc 00 00
	00		 fst	 DWORD PTR [esi+188]

; 819  : 
; 820  : 		if ( lpObj->Life < 0.0f )

  00534	d9 ee		 fldz
  00536	d8 d1		 fcom	 ST(1)
  00538	df e0		 fnstsw	 ax
  0053a	dd d9		 fstp	 ST(1)
  0053c	f6 c4 41	 test	 ah, 65			; 00000041H
  0053f	75 08		 jne	 SHORT $LN157@Attack

; 821  : 		{
; 822  : 			lpObj->Life = 0.0f;

  00541	d9 9e bc 00 00
	00		 fstp	 DWORD PTR [esi+188]

; 823  : 		}
; 824  : 		else

  00547	eb 19		 jmp	 SHORT $LN59@Attack
$LN157@Attack:

; 825  : 		{
; 826  : 			AttackDamage = AttackDamage * dinorantdecdamage / 100;

  00549	0f af cb	 imul	 ecx, ebx
  0054c	dd d8		 fstp	 ST(0)
  0054e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00553	f7 e9		 imul	 ecx
  00555	c1 fa 05	 sar	 edx, 5
  00558	8b da		 mov	 ebx, edx
  0055a	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0055d	03 da		 add	 ebx, edx
  0055f	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx
$LN59@Attack:

; 827  : 		}
; 828  : 
; 829  : 		GCReFillSend(lpObj->m_Index, lpObj->Life, 0xFF, 0);

  00562	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  00568	6a 00		 push	 0
  0056a	68 ff 00 00 00	 push	 255			; 000000ffH
  0056f	e8 00 00 00 00	 call	 __ftol2_sse
  00574	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00576	50		 push	 eax
  00577	51		 push	 ecx
  00578	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend
  0057d	83 c4 10	 add	 esp, 16			; 00000010H
$LN61@Attack:

; 830  : 	}
; 831  : 
; 832  : 	if ( gObjDarkHorse(lpTargetObj ) )

  00580	57		 push	 edi
  00581	e8 00 00 00 00	 call	 ?gObjDarkHorse@@YAHPAUOBJECTSTRUCT@@@Z ; gObjDarkHorse
  00586	83 c4 04	 add	 esp, 4
  00589	85 c0		 test	 eax, eax
  0058b	74 7f		 je	 SHORT $LN58@Attack

; 833  : 	{
; 834  : 		CItem * Darkhorse = &lpTargetObj->pInventory[8];
; 835  : 		int decdamage = 100 - ((Darkhorse->m_PetItem_Level + 30) / 2 );
; 836  : 
; 837  : 		lpTargetObj->Life -= 1.0f;

  0058d	d9 87 bc 00 00
	00		 fld	 DWORD PTR [edi+188]
  00593	8b 97 8c 0c 00
	00		 mov	 edx, DWORD PTR [edi+3212]
  00599	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  0059f	8b 82 e0 05 00
	00		 mov	 eax, DWORD PTR [edx+1504]
  005a5	83 c0 1e	 add	 eax, 30			; 0000001eH
  005a8	99		 cdq
  005a9	d9 5d 14	 fstp	 DWORD PTR tv1139[ebp]
  005ac	2b c2		 sub	 eax, edx
  005ae	d9 45 14	 fld	 DWORD PTR tv1139[ebp]
  005b1	d1 f8		 sar	 eax, 1
  005b3	d9 97 bc 00 00
	00		 fst	 DWORD PTR [edi+188]
  005b9	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H

; 838  : 
; 839  : 		if ( lpTargetObj->Life < 0.0f )

  005be	d9 ee		 fldz
  005c0	2b c8		 sub	 ecx, eax
  005c2	d8 d1		 fcom	 ST(1)
  005c4	df e0		 fnstsw	 ax
  005c6	dd d9		 fstp	 ST(1)
  005c8	f6 c4 41	 test	 ah, 65			; 00000041H
  005cb	75 08		 jne	 SHORT $LN160@Attack

; 840  : 		{
; 841  : 			lpTargetObj->Life = 0.0f;

  005cd	d9 9f bc 00 00
	00		 fstp	 DWORD PTR [edi+188]

; 842  : 		}
; 843  : 		else

  005d3	eb 19		 jmp	 SHORT $LN56@Attack
$LN160@Attack:

; 844  : 		{
; 845  : 			AttackDamage = AttackDamage * decdamage / 100;

  005d5	0f af cb	 imul	 ecx, ebx
  005d8	dd d8		 fstp	 ST(0)
  005da	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  005df	f7 e9		 imul	 ecx
  005e1	c1 fa 05	 sar	 edx, 5
  005e4	8b da		 mov	 ebx, edx
  005e6	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  005e9	03 da		 add	 ebx, edx
  005eb	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx
$LN56@Attack:

; 846  : 		}
; 847  : 
; 848  : 		GCReFillSend(lpTargetObj->m_Index, lpTargetObj->Life, 0xFF, 0);

  005ee	d9 87 bc 00 00
	00		 fld	 DWORD PTR [edi+188]
  005f4	6a 00		 push	 0
  005f6	68 ff 00 00 00	 push	 255			; 000000ffH
  005fb	e8 00 00 00 00	 call	 __ftol2_sse
  00600	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00602	50		 push	 eax
  00603	51		 push	 ecx
  00604	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend
  00609	83 c4 10	 add	 esp, 16			; 00000010H
$LN58@Attack:

; 849  : 	}
; 850  : 
; 851  : 	if ( lpTargetObj->Live )

  0060c	80 7f 62 00	 cmp	 BYTE PTR [edi+98], 0
  00610	0f 84 2d 02 00
	00		 je	 $LN129@Attack

; 852  : 	{
; 853  : 		if ( lpTargetObj->m_WizardSkillDefense && AttackDamage > 0)

  00616	8b 8f 04 0f 00
	00		 mov	 ecx, DWORD PTR [edi+3844]
  0061c	85 c9		 test	 ecx, ecx
  0061e	0f 84 8b 00 00
	00		 je	 $LN125@Attack
  00624	85 db		 test	 ebx, ebx
  00626	0f 8e 83 00 00
	00		 jle	 $LN125@Attack

; 854  : 		{
; 855  : 			int replacemana = (WORD)lpTargetObj->Mana * 2 / 100;

  0062c	d9 87 d0 00 00
	00		 fld	 DWORD PTR [edi+208]
  00632	d9 7d 16	 fnstcw	 WORD PTR tv1073[ebp]
  00635	0f b7 45 16	 movzx	 eax, WORD PTR tv1073[ebp]
  00639	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0063e	89 45 10	 mov	 DWORD PTR tv1070[ebp], eax
  00641	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00646	d9 6d 10	 fldcw	 WORD PTR tv1070[ebp]
  00649	db 5d 10	 fistp	 DWORD PTR tv1068[ebp]
  0064c	66 8b 55 10	 mov	 dx, WORD PTR tv1068[ebp]
  00650	0f b7 d2	 movzx	 edx, dx
  00653	03 d2		 add	 edx, edx
  00655	d9 6d 16	 fldcw	 WORD PTR tv1073[ebp]
  00658	f7 ea		 imul	 edx
  0065a	c1 fa 05	 sar	 edx, 5
  0065d	8b c2		 mov	 eax, edx
  0065f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00662	03 c2		 add	 eax, edx
  00664	89 45 14	 mov	 DWORD PTR _replacemana$155654[ebp], eax

; 856  : 
; 857  : 			if ( replacemana < lpTargetObj->Mana )

  00667	db 45 14	 fild	 DWORD PTR _replacemana$155654[ebp]
  0066a	d9 5d 14	 fstp	 DWORD PTR tv1160[ebp]
  0066d	d9 45 14	 fld	 DWORD PTR tv1160[ebp]
  00670	d9 87 d0 00 00
	00		 fld	 DWORD PTR [edi+208]
  00676	d8 d9		 fcomp	 ST(1)
  00678	df e0		 fnstsw	 ax
  0067a	f6 c4 41	 test	 ah, 65			; 00000041H
  0067d	75 2e		 jne	 SHORT $LN163@Attack

; 858  : 			{
; 859  : 				lpTargetObj->Mana -= replacemana;

  0067f	d8 af d0 00 00
	00		 fsubr	 DWORD PTR [edi+208]

; 860  : 				int decattackdamage = AttackDamage * lpTargetObj->m_WizardSkillDefense / 100;

  00685	0f af cb	 imul	 ecx, ebx
  00688	d9 9f d0 00 00
	00		 fstp	 DWORD PTR [edi+208]
  0068e	b8 e1 7a 14 ae	 mov	 eax, -1374389535	; ae147ae1H
  00693	f7 e9		 imul	 ecx
  00695	c1 fa 05	 sar	 edx, 5
  00698	8b ca		 mov	 ecx, edx
  0069a	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0069d	03 ca		 add	 ecx, edx

; 861  : 				AttackDamage -= decattackdamage;

  0069f	03 d9		 add	 ebx, ecx
  006a1	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx

; 862  : 				ManaChange = TRUE;

  006a4	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _ManaChange$[ebp], 1
  006ab	eb 02		 jmp	 SHORT $LN125@Attack
$LN163@Attack:
  006ad	dd d8		 fstp	 ST(0)
$LN125@Attack:

; 863  : 
; 864  : 			}
; 865  : 		}
; 866  : 
; 867  : 		if ( lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_USER )

  006af	0f b7 4e 60	 movzx	 ecx, WORD PTR [esi+96]
  006b3	83 f9 01	 cmp	 ecx, 1
  006b6	0f 85 5b 01 00
	00		 jne	 $LN128@Attack
  006bc	66 39 4f 60	 cmp	 WORD PTR [edi+96], cx
  006c0	75 3d		 jne	 SHORT $LN136@Attack

; 868  : 		{
; 869  : 			if ( CC_MAP_RANGE(lpObj->MapNumber ) && CC_MAP_RANGE(lpTargetObj->MapNumber) )

  006c2	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  006c9	3c 12		 cmp	 al, 18			; 00000012H
  006cb	72 32		 jb	 SHORT $LN136@Attack
  006cd	b2 17		 mov	 dl, 23			; 00000017H
  006cf	3a d0		 cmp	 dl, al
  006d1	1b c0		 sbb	 eax, eax
  006d3	40		 inc	 eax
  006d4	74 29		 je	 SHORT $LN136@Attack
  006d6	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR [edi+265]
  006dd	3c 12		 cmp	 al, 18			; 00000012H
  006df	72 1e		 jb	 SHORT $LN136@Attack
  006e1	3a d0		 cmp	 dl, al
  006e3	1b c0		 sbb	 eax, eax
  006e5	40		 inc	 eax
  006e6	74 17		 je	 SHORT $LN136@Attack

; 870  : 			{
; 871  : 				AttackDamage = AttackDamage * 50 / 100;

  006e8	6b db 32	 imul	 ebx, 50			; 00000032H
  006eb	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  006f0	f7 eb		 imul	 ebx
  006f2	c1 fa 05	 sar	 edx, 5
  006f5	8b da		 mov	 ebx, edx
  006f7	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  006fa	03 da		 add	 ebx, edx
  006fc	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx
$LN136@Attack:

; 872  : 			}
; 873  : 		}
; 874  : 
; 875  : #if GS_CASTLE == 1
; 876  : 		if ( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 877  : 		{
; 878  : 			if ( lpObj->Type == OBJ_USER && lpTargetObj->Type ==OBJ_USER )
; 879  : 			{
; 880  : 				if ( lpObj->MapNumber == MAP_INDEX_CASTLESIEGE && lpTargetObj->MapNumber == MAP_INDEX_CASTLESIEGE )
; 881  : 				{
; 882  : 					if ( lpObj->m_btCsJoinSide == lpTargetObj->m_btCsJoinSide )
; 883  : 					{
; 884  : 						AttackDamage = AttackDamage * 20 / 100;
; 885  : 					}
; 886  : 					
; 887  : 					AttackDamage = AttackDamage * 40 / 100;
; 888  : 				}
; 889  : 			}
; 890  : 		}
; 891  : #endif
; 892  : 
; 893  : 		if ( lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_MONSTER )

  006ff	83 f9 01	 cmp	 ecx, 1
  00702	0f 85 0f 01 00
	00		 jne	 $LN128@Attack
  00708	66 83 7f 60 02	 cmp	 WORD PTR [edi+96], 2
  0070d	0f 85 04 01 00
	00		 jne	 $LN128@Attack

; 894  : 		{
; 895  : 			if ( lpTargetObj->Class == 283 )

  00713	b9 1b 01 00 00	 mov	 ecx, 283		; 0000011bH
  00718	66 39 8f 98 00
	00 00		 cmp	 WORD PTR [edi+152], cx
  0071f	75 74		 jne	 SHORT $LN127@Attack

; 896  : 			{
; 897  : 				if ( lpObj->m_iPotionBlessTime > 0 || lpObj->m_iPotionSoulTime > 0 )

  00721	83 be f4 14 00
	00 00		 cmp	 DWORD PTR [esi+5364], 0
  00728	7f 4e		 jg	 SHORT $LN47@Attack
  0072a	83 be f8 14 00
	00 00		 cmp	 DWORD PTR [esi+5368], 0
  00731	7f 45		 jg	 SHORT $LN47@Attack

; 900  : 				}
; 901  : 				else 
; 902  : 				{
; 903  : 					if ( lpObj->m_iAccumulatedDamage > 100 )

  00733	8b 86 f0 14 00
	00		 mov	 eax, DWORD PTR [esi+5360]
  00739	83 f8 64	 cmp	 eax, 100		; 00000064H
  0073c	7e 18		 jle	 SHORT $LN45@Attack

; 904  : 					{
; 905  : 						gObjWeaponDurDownInCastle(lpObj, lpTargetObj, 1);

  0073e	6a 01		 push	 1
  00740	57		 push	 edi
  00741	56		 push	 esi
  00742	e8 00 00 00 00	 call	 ?gObjWeaponDurDownInCastle@@YAXPAUOBJECTSTRUCT@@0H@Z ; gObjWeaponDurDownInCastle
  00747	83 c4 0c	 add	 esp, 12			; 0000000cH

; 906  : 						lpObj->m_iAccumulatedDamage = 0;

  0074a	c7 86 f0 14 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5360], 0

; 907  : 					}
; 908  : 					else

  00754	eb 08		 jmp	 SHORT $LN44@Attack
$LN45@Attack:

; 909  : 					{
; 910  : 						lpObj->m_iAccumulatedDamage += AttackDamage;

  00756	03 c3		 add	 eax, ebx
  00758	89 86 f0 14 00
	00		 mov	 DWORD PTR [esi+5360], eax
$LN44@Attack:

; 911  : 					}
; 912  : 
; 913  : 					AttackDamage = AttackDamage * 20 / 100;

  0075e	8d 1c 9b	 lea	 ebx, DWORD PTR [ebx+ebx*4]
  00761	03 db		 add	 ebx, ebx
  00763	03 db		 add	 ebx, ebx
  00765	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0076a	f7 eb		 imul	 ebx
  0076c	c1 fa 05	 sar	 edx, 5
  0076f	8b da		 mov	 ebx, edx
  00771	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00774	03 da		 add	 ebx, edx
  00776	eb 1a		 jmp	 SHORT $LN171@Attack
$LN47@Attack:

; 898  : 				{
; 899  : 					AttackDamage += (AttackDamage * 20) / 100;

  00778	8d 0c 9b	 lea	 ecx, DWORD PTR [ebx+ebx*4]
  0077b	03 c9		 add	 ecx, ecx
  0077d	03 c9		 add	 ecx, ecx
  0077f	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00784	f7 e9		 imul	 ecx
  00786	c1 fa 05	 sar	 edx, 5
  00789	8b ca		 mov	 ecx, edx
  0078b	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0078e	03 ca		 add	 ecx, edx
  00790	03 d9		 add	 ebx, ecx
$LN171@Attack:
  00792	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx
$LN127@Attack:

; 914  : 				}
; 915  : 			}
; 916  : 
; 917  : 			if ( lpTargetObj->Class == 277 )

  00795	ba 15 01 00 00	 mov	 edx, 277		; 00000115H
  0079a	66 39 97 98 00
	00 00		 cmp	 WORD PTR [edi+152], dx
  007a1	75 74		 jne	 SHORT $LN128@Attack

; 918  : 			{
; 919  : 				if ( lpObj->m_iPotionBlessTime > 0 || lpObj->m_iPotionSoulTime > 0 )

  007a3	83 be f4 14 00
	00 00		 cmp	 DWORD PTR [esi+5364], 0
  007aa	7f 4e		 jg	 SHORT $LN41@Attack
  007ac	83 be f8 14 00
	00 00		 cmp	 DWORD PTR [esi+5368], 0
  007b3	7f 45		 jg	 SHORT $LN41@Attack

; 922  : 				}
; 923  : 				else 
; 924  : 				{
; 925  : 					if ( lpObj->m_iAccumulatedDamage > 100 )

  007b5	8b 86 f0 14 00
	00		 mov	 eax, DWORD PTR [esi+5360]
  007bb	83 f8 64	 cmp	 eax, 100		; 00000064H
  007be	7e 18		 jle	 SHORT $LN39@Attack

; 926  : 					{
; 927  : 						gObjWeaponDurDownInCastle(lpObj, lpTargetObj, 1);

  007c0	6a 01		 push	 1
  007c2	57		 push	 edi
  007c3	56		 push	 esi
  007c4	e8 00 00 00 00	 call	 ?gObjWeaponDurDownInCastle@@YAXPAUOBJECTSTRUCT@@0H@Z ; gObjWeaponDurDownInCastle
  007c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 928  : 						lpObj->m_iAccumulatedDamage = 0;

  007cc	c7 86 f0 14 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5360], 0

; 929  : 					}
; 930  : 					else

  007d6	eb 08		 jmp	 SHORT $LN38@Attack
$LN39@Attack:

; 931  : 					{
; 932  : 						lpObj->m_iAccumulatedDamage += AttackDamage;

  007d8	03 c3		 add	 eax, ebx
  007da	89 86 f0 14 00
	00		 mov	 DWORD PTR [esi+5360], eax
$LN38@Attack:

; 933  : 					}
; 934  : 
; 935  : 					AttackDamage = AttackDamage * 20 / 100;

  007e0	8d 1c 9b	 lea	 ebx, DWORD PTR [ebx+ebx*4]
  007e3	03 db		 add	 ebx, ebx
  007e5	03 db		 add	 ebx, ebx
  007e7	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  007ec	f7 eb		 imul	 ebx
  007ee	c1 fa 05	 sar	 edx, 5
  007f1	8b da		 mov	 ebx, edx
  007f3	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  007f6	03 da		 add	 ebx, edx
  007f8	eb 1a		 jmp	 SHORT $LN172@Attack
$LN41@Attack:

; 920  : 				{
; 921  : 					AttackDamage += (AttackDamage * 20) / 100;

  007fa	8d 0c 9b	 lea	 ecx, DWORD PTR [ebx+ebx*4]
  007fd	03 c9		 add	 ecx, ecx
  007ff	03 c9		 add	 ecx, ecx
  00801	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00806	f7 e9		 imul	 ecx
  00808	c1 fa 05	 sar	 edx, 5
  0080b	8b ca		 mov	 ecx, edx
  0080d	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00810	03 ca		 add	 ecx, edx
  00812	03 d9		 add	 ebx, ecx
$LN172@Attack:
  00814	89 5d 0c	 mov	 DWORD PTR _AttackDamage$[ebp], ebx
$LN128@Attack:

; 936  : 				}
; 937  : 			}
; 938  : 		}
; 939  : 
; 940  : 		lpTargetObj->Life -= AttackDamage;

  00817	d9 87 bc 00 00
	00		 fld	 DWORD PTR [edi+188]
  0081d	da 65 0c	 fisub	 DWORD PTR _AttackDamage$[ebp]
  00820	d9 5d 14	 fstp	 DWORD PTR tv1198[ebp]
  00823	d9 45 14	 fld	 DWORD PTR tv1198[ebp]
  00826	d9 97 bc 00 00
	00		 fst	 DWORD PTR [edi+188]

; 941  : 
; 942  : 		if ( lpTargetObj->Life < 0.0f )

  0082c	d9 ee		 fldz
  0082e	d8 d1		 fcom	 ST(1)
  00830	df e0		 fnstsw	 ax
  00832	dd d9		 fstp	 ST(1)
  00834	f6 c4 41	 test	 ah, 65			; 00000041H
  00837	75 08		 jne	 SHORT $LN166@Attack

; 943  : 		{
; 944  : 			lpTargetObj->Life = 0.0f;

  00839	d9 9f bc 00 00
	00		 fstp	 DWORD PTR [edi+188]
  0083f	eb 02		 jmp	 SHORT $LN129@Attack
$LN166@Attack:
  00841	dd d8		 fstp	 ST(0)
$LN129@Attack:

; 945  : 		}
; 946  : 	}
; 947  : 
; 948  : 	if ( lpTargetObj->Type == OBJ_MONSTER )

  00843	66 83 7f 60 02	 cmp	 WORD PTR [edi+96], 2
  00848	75 1c		 jne	 SHORT $LN36@Attack

; 949  : 	{
; 950  : 		gObjAddMsgSendDelay(lpTargetObj, 0, lpObj->m_Index, 100, 0);

  0084a	8b 16		 mov	 edx, DWORD PTR [esi]
  0084c	6a 00		 push	 0
  0084e	6a 64		 push	 100			; 00000064H
  00850	52		 push	 edx
  00851	6a 00		 push	 0
  00853	57		 push	 edi
  00854	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay

; 951  : 		lpTargetObj->LastAttackerID = lpObj->m_Index;

  00859	66 8b 06	 mov	 ax, WORD PTR [esi]
  0085c	83 c4 14	 add	 esp, 20			; 00000014H
  0085f	66 89 87 da 02
	00 00		 mov	 WORD PTR [edi+730], ax
$LN36@Attack:

; 952  : 	}
; 953  : 
; 954  : 	BOOL selfdefense = 0;
; 955  : 	lpCallObj = lpTargetObj;
; 956  : 	
; 957  : 	if ( lpTargetObj->Type == OBJ_MONSTER )

  00866	0f b7 4f 60	 movzx	 ecx, WORD PTR [edi+96]
  0086a	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _selfdefense$[ebp], 0
  00871	89 7d 10	 mov	 DWORD PTR _lpCallObj$[ebp], edi
  00874	83 f9 02	 cmp	 ecx, 2
  00877	75 18		 jne	 SHORT $LN34@Attack

; 958  : 	{
; 959  : 		if ( lpTargetObj->m_RecallMon >= 0 )

  00879	8b 87 cc 02 00
	00		 mov	 eax, DWORD PTR [edi+716]
  0087f	85 c0		 test	 eax, eax
  00881	78 0e		 js	 SHORT $LN34@Attack

; 960  : 		{
; 961  : 			lpCallObj = &gObj[lpTargetObj->m_RecallMon];

  00883	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00889	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0088e	89 45 10	 mov	 DWORD PTR _lpCallObj$[ebp], eax
$LN34@Attack:

; 962  : 		}
; 963  : 	}
; 964  : 
; 965  : 	if ( AttackDamage >= 1 )

  00891	83 fb 01	 cmp	 ebx, 1
  00894	0f 8c ed 00 00
	00		 jl	 $LN132@Attack

; 966  : 	{
; 967  : 		if ( lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_USER )

  0089a	0f b7 46 60	 movzx	 eax, WORD PTR [esi+96]
  0089e	83 f8 01	 cmp	 eax, 1
  008a1	75 62		 jne	 SHORT $LN32@Attack
  008a3	3b c8		 cmp	 ecx, eax
  008a5	75 5e		 jne	 SHORT $LN32@Attack

; 968  : 		{
; 969  : 			if ( gObjDuelCheck(lpObj, lpTargetObj) )

  008a7	57		 push	 edi
  008a8	56		 push	 esi
  008a9	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjDuelCheck
  008ae	83 c4 08	 add	 esp, 8
  008b1	85 c0		 test	 eax, eax

; 970  : 			{
; 971  : 				selfdefense = 0;

  008b3	75 31		 jne	 SHORT $LN28@Attack

; 972  : 			}
; 973  : 			else if ( CC_MAP_RANGE(lpObj->MapNumber) || CC_MAP_RANGE(lpTargetObj->MapNumber) )

  008b5	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  008bc	3c 12		 cmp	 al, 18			; 00000012H
  008be	72 09		 jb	 SHORT $LN130@Attack
  008c0	b1 17		 mov	 cl, 23			; 00000017H
  008c2	3a c8		 cmp	 cl, al
  008c4	1b c0		 sbb	 eax, eax
  008c6	40		 inc	 eax
  008c7	75 1d		 jne	 SHORT $LN28@Attack
$LN130@Attack:
  008c9	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR [edi+265]
  008d0	3c 12		 cmp	 al, 18			; 00000012H
  008d2	72 09		 jb	 SHORT $LN121@Attack
  008d4	b2 17		 mov	 dl, 23			; 00000017H
  008d6	3a d0		 cmp	 dl, al
  008d8	1b c0		 sbb	 eax, eax
  008da	40		 inc	 eax
  008db	75 09		 jne	 SHORT $LN28@Attack
$LN121@Attack:

; 976  : 			}
; 977  : 			else
; 978  : 			{
; 979  : 				selfdefense = 1;

  008dd	c7 45 14 01 00
	00 00		 mov	 DWORD PTR _selfdefense$[ebp], 1
  008e4	eb 07		 jmp	 SHORT $LN27@Attack
$LN28@Attack:

; 974  : 			{
; 975  : 				selfdefense = 0;

  008e6	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _selfdefense$[ebp], 0
$LN27@Attack:

; 980  : 			}
; 981  : 
; 982  : 			if ( gObjGetRelationShip(lpObj, lpTargetObj) == 2 )

  008ed	57		 push	 edi
  008ee	56		 push	 esi
  008ef	e8 00 00 00 00	 call	 ?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjGetRelationShip
  008f4	83 c4 08	 add	 esp, 8
  008f7	83 f8 02	 cmp	 eax, 2
  008fa	75 1f		 jne	 SHORT $LN131@Attack

; 983  : 			{
; 984  : 				selfdefense = FALSE;

  008fc	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _selfdefense$[ebp], 0

; 985  : 			}
; 986  : #if GS_CASTLE == 1
; 987  : 			if ( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 988  : 			{
; 989  : 				if ( lpObj->m_btCsJoinSide > 0 )
; 990  : 				{
; 991  : 					selfdefense = FALSE;
; 992  : 				}
; 993  : 			}
; 994  : #endif
; 995  : 		}

  00903	eb 16		 jmp	 SHORT $LN131@Attack
$LN32@Attack:

; 996  : 		else if ( lpTargetObj->Type == OBJ_MONSTER && lpObj->Type == OBJ_USER )

  00905	83 f9 02	 cmp	 ecx, 2
  00908	75 11		 jne	 SHORT $LN131@Attack
  0090a	83 f8 01	 cmp	 eax, 1
  0090d	75 0c		 jne	 SHORT $LN131@Attack

; 997  : 		{
; 998  : 			if ( lpTargetObj->m_RecallMon >= 0 )

  0090f	83 bf cc 02 00
	00 00		 cmp	 DWORD PTR [edi+716], 0
  00916	7c 03		 jl	 SHORT $LN131@Attack

; 999  : 			{
; 1000 : 				selfdefense = TRUE;

  00918	89 45 14	 mov	 DWORD PTR _selfdefense$[ebp], eax
$LN131@Attack:

; 1001 : 			}
; 1002 : 		}
; 1003 : 
; 1004 : 		if ( lpTargetObj->Type == OBJ_USER )

  0091b	66 83 7f 60 01	 cmp	 WORD PTR [edi+96], 1
  00920	75 0a		 jne	 SHORT $LN22@Attack

; 1005 : 		{
; 1006 : 			gObjArmorRandomDurDown(lpTargetObj, lpObj);

  00922	56		 push	 esi
  00923	57		 push	 edi
  00924	e8 00 00 00 00	 call	 ?gObjArmorRandomDurDown@@YAXPAUOBJECTSTRUCT@@0@Z ; gObjArmorRandomDurDown
  00929	83 c4 08	 add	 esp, 8
$LN22@Attack:

; 1007 : 		}
; 1008 : 
; 1009 : 		if ( lpTargetObj->m_SkillHarden )

  0092c	8b 87 98 02 00
	00		 mov	 eax, DWORD PTR [edi+664]
  00932	85 c0		 test	 eax, eax
  00934	74 2b		 je	 SHORT $LN20@Attack

; 1010 : 		{
; 1011 : 			lpTargetObj->m_SkillHarden--;

  00936	48		 dec	 eax
  00937	89 87 98 02 00
	00		 mov	 DWORD PTR [edi+664], eax

; 1012 : 
; 1013 : 			if ( lpTargetObj->m_SkillHarden <= 0 )

  0093d	85 c0		 test	 eax, eax
  0093f	7f 20		 jg	 SHORT $LN20@Attack

; 1014 : 			{
; 1015 : 				lpTargetObj->m_SkillHardenTime = 0;
; 1016 : 				lpTargetObj->m_SkillHarden = 0;
; 1017 : 				lpTargetObj->m_ViewSkillState &= -33;

  00941	83 a7 c4 01 00
	00 df		 and	 DWORD PTR [edi+452], -33 ; ffffffdfH
  00948	33 c0		 xor	 eax, eax

; 1018 : 				GCMagicCancelSend(lpTargetObj, 51);

  0094a	6a 33		 push	 51			; 00000033H
  0094c	57		 push	 edi
  0094d	89 87 9c 02 00
	00		 mov	 DWORD PTR [edi+668], eax
  00953	89 87 98 02 00
	00		 mov	 DWORD PTR [edi+664], eax
  00959	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  0095e	83 c4 08	 add	 esp, 8
$LN20@Attack:

; 1019 : 			}
; 1020 : 		}
; 1021 : 	}
; 1022 : 
; 1023 : 	if ( selfdefense == TRUE )

  00961	83 7d 14 01	 cmp	 DWORD PTR _selfdefense$[ebp], 1
  00965	75 20		 jne	 SHORT $LN132@Attack

; 1024 : 	{
; 1025 : 		if ( !gObjTargetGuildWarCheck(lpObj, lpCallObj) )

  00967	8b 45 10	 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  0096a	50		 push	 eax
  0096b	56		 push	 esi
  0096c	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00971	83 c4 08	 add	 esp, 8
  00974	85 c0		 test	 eax, eax
  00976	75 0f		 jne	 SHORT $LN132@Attack

; 1026 : 		{
; 1027 : 			gObjCheckSelfDefense(lpObj, lpCallObj->m_Index);

  00978	8b 4d 10	 mov	 ecx, DWORD PTR _lpCallObj$[ebp]
  0097b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0097d	52		 push	 edx
  0097e	56		 push	 esi
  0097f	e8 00 00 00 00	 call	 ?gObjCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjCheckSelfDefense
  00984	83 c4 08	 add	 esp, 8
$LN132@Attack:

; 1028 : 		}
; 1029 : 	}
; 1030 : 
; 1031 : 	if ( AttackDamage >= 5 )	// To make strong hit

  00987	83 fb 05	 cmp	 ebx, 5
  0098a	7c 52		 jl	 SHORT $LN133@Attack

; 1032 : 	{
; 1033 : 		if ( lpTargetObj->Type == OBJ_MONSTER )

  0098c	66 83 7f 60 02	 cmp	 WORD PTR [edi+96], 2
  00991	75 24		 jne	 SHORT $LN16@Attack

; 1034 : 		{
; 1035 : 			if ( (rand()%26) == 0 )

  00993	e8 00 00 00 00	 call	 _rand
  00998	99		 cdq
  00999	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  0099e	f7 f9		 idiv	 ecx
  009a0	85 d2		 test	 edx, edx
  009a2	75 3a		 jne	 SHORT $LN133@Attack

; 1036 : 			{
; 1037 : 				gObjAddMsgSendDelay(lpTargetObj,4, lpObj->m_Index, 100, 0);

  009a4	52		 push	 edx
  009a5	8b 16		 mov	 edx, DWORD PTR [esi]
  009a7	6a 64		 push	 100			; 00000064H
  009a9	52		 push	 edx
  009aa	6a 04		 push	 4
  009ac	57		 push	 edi
  009ad	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  009b2	83 c4 14	 add	 esp, 20			; 00000014H

; 1038 : 			}
; 1039 : 		}

  009b5	eb 27		 jmp	 SHORT $LN133@Attack
$LN16@Attack:

; 1040 : 		else if ( (rand()%4) == 0 )

  009b7	e8 00 00 00 00	 call	 _rand
  009bc	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  009c1	79 05		 jns	 SHORT $LN168@Attack
  009c3	48		 dec	 eax
  009c4	83 c8 fc	 or	 eax, -4			; fffffffcH
  009c7	40		 inc	 eax
$LN168@Attack:
  009c8	75 14		 jne	 SHORT $LN133@Attack

; 1041 : 		{
; 1042 : 			if ( !gObjUniriaSprite(lpTargetObj) )

  009ca	57		 push	 edi
  009cb	e8 00 00 00 00	 call	 ?gObjUniriaSprite@@YAHPAUOBJECTSTRUCT@@@Z ; gObjUniriaSprite
  009d0	83 c4 04	 add	 esp, 4
  009d3	85 c0		 test	 eax, eax
  009d5	75 07		 jne	 SHORT $LN133@Attack

; 1043 : 			{
; 1044 : 				MSBFlag = 1;

  009d7	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _MSBFlag$[ebp], 1
$LN133@Attack:

; 1045 : 			}
; 1046 : 		}
; 1047 : 	}
; 1048 : 
; 1049 : 	if ( ManaChange )

  009de	83 7d f4 00	 cmp	 DWORD PTR _ManaChange$[ebp], 0
  009e2	74 25		 je	 SHORT $LN11@Attack

; 1050 : 	{
; 1051 : 		GCManaSend(lpTargetObj->m_Index, lpTargetObj->Mana, 0xFF, 0, lpTargetObj->BP);

  009e4	8b 87 e8 00 00
	00		 mov	 eax, DWORD PTR [edi+232]
  009ea	d9 87 d0 00 00
	00		 fld	 DWORD PTR [edi+208]
  009f0	50		 push	 eax
  009f1	6a 00		 push	 0
  009f3	68 ff 00 00 00	 push	 255			; 000000ffH
  009f8	e8 00 00 00 00	 call	 __ftol2_sse
  009fd	8b 0f		 mov	 ecx, DWORD PTR [edi]
  009ff	50		 push	 eax
  00a00	51		 push	 ecx
  00a01	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  00a06	83 c4 14	 add	 esp, 20			; 00000014H
$LN11@Attack:

; 1052 : 	}
; 1053 : 
; 1054 : 	if ( lpObj->Type == OBJ_USER )

  00a09	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00a0e	75 19		 jne	 SHORT $LN9@Attack

; 1055 : 	{
; 1056 : 		if ( lpObj->m_Change == 9 )

  00a10	83 be d0 02 00
	00 09		 cmp	 DWORD PTR [esi+720], 9
  00a17	75 10		 jne	 SHORT $LN9@Attack

; 1057 : 		{
; 1058 : 			GCMagicAttackNumberSend(lpObj, 3, lpTargetObj->m_Index, 1);

  00a19	8b 17		 mov	 edx, DWORD PTR [edi]
  00a1b	6a 01		 push	 1
  00a1d	52		 push	 edx
  00a1e	6a 03		 push	 3
  00a20	56		 push	 esi
  00a21	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  00a26	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@Attack:

; 1059 : 		}
; 1060 : 	}
; 1061 : 
; 1062 : 	lpObj->m_Rest = 0;

  00a29	c6 86 c1 01 00
	00 00		 mov	 BYTE PTR [esi+449], 0

; 1063 : 
; 1064 : 	if ( AttackDamage > 0 )

  00a30	85 db		 test	 ebx, ebx
  00a32	7e 75		 jle	 SHORT $LN8@Attack

; 1065 : 	{
; 1066 : 		int atd_reflect = (int)((float)AttackDamage * lpTargetObj->DamageReflect / 100.0f);

  00a34	0f b6 87 15 01
	00 00		 movzx	 eax, BYTE PTR [edi+277]
  00a3b	89 45 14	 mov	 DWORD PTR tv992[ebp], eax
  00a3e	db 45 14	 fild	 DWORD PTR tv992[ebp]
  00a41	da 4d 0c	 fimul	 DWORD PTR _AttackDamage$[ebp]
  00a44	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  00a4a	e8 00 00 00 00	 call	 __ftol2_sse

; 1067 : 
; 1068 : 		if ( atd_reflect )

  00a4f	85 c0		 test	 eax, eax
  00a51	74 11		 je	 SHORT $LN7@Attack

; 1069 : 		{
; 1070 : 			gObjAddMsgSendDelay(lpTargetObj, 10, lpObj->m_Index, 10, atd_reflect);

  00a53	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00a55	50		 push	 eax
  00a56	6a 0a		 push	 10			; 0000000aH
  00a58	51		 push	 ecx
  00a59	6a 0a		 push	 10			; 0000000aH
  00a5b	57		 push	 edi
  00a5c	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00a61	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@Attack:

; 1071 : 		}
; 1072 : 
; 1073 : 		if ( (rand()%100) < lpObj->SetOpReflectionDamage )

  00a64	e8 00 00 00 00	 call	 _rand
  00a69	99		 cdq
  00a6a	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00a6f	f7 f9		 idiv	 ecx
  00a71	0f b6 86 7e 0f
	00 00		 movzx	 eax, BYTE PTR [esi+3966]
  00a78	3b d0		 cmp	 edx, eax
  00a7a	7d 11		 jge	 SHORT $LN6@Attack

; 1074 : 		{
; 1075 : 			gObjAddMsgSendDelay(lpTargetObj, 10, lpObj->m_Index, 10, AttackDamage);

  00a7c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00a7e	53		 push	 ebx
  00a7f	6a 0a		 push	 10			; 0000000aH
  00a81	51		 push	 ecx
  00a82	6a 0a		 push	 10			; 0000000aH
  00a84	57		 push	 edi
  00a85	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00a8a	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@Attack:

; 1076 : 		}
; 1077 : 
; 1078 : 		gObjLifeCheck(lpTargetObj, lpObj, AttackDamage, 0, MSBFlag, MsgDamage, skill);

  00a8d	8b 55 08	 mov	 edx, DWORD PTR _skill$[ebp]
  00a90	0f b6 45 ff	 movzx	 eax, BYTE PTR _MsgDamage$[ebp]
  00a94	8b 4d f0	 mov	 ecx, DWORD PTR _MSBFlag$[ebp]
  00a97	52		 push	 edx
  00a98	50		 push	 eax
  00a99	51		 push	 ecx
  00a9a	6a 00		 push	 0
  00a9c	53		 push	 ebx
  00a9d	56		 push	 esi
  00a9e	57		 push	 edi
  00a9f	e8 00 00 00 00	 call	 ?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHE@Z ; gObjLifeCheck
  00aa4	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1079 : 	}
; 1080 : 	else

  00aa7	eb 17		 jmp	 SHORT $LN5@Attack
$LN8@Attack:

; 1081 : 	{
; 1082 : 		GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, 0, MsgDamage);

  00aa9	0f b6 55 ff	 movzx	 edx, BYTE PTR _MsgDamage$[ebp]
  00aad	8b 07		 mov	 eax, DWORD PTR [edi]
  00aaf	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00ab1	52		 push	 edx
  00ab2	6a 00		 push	 0
  00ab4	6a 00		 push	 0
  00ab6	50		 push	 eax
  00ab7	51		 push	 ecx
  00ab8	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  00abd	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@Attack:

; 1083 : 	}
; 1084 : 
; 1085 : 	if ( lpObj->Life <= 0.0f && lpObj->Type == OBJ_USER )

  00ac0	d9 ee		 fldz
  00ac2	d8 9e bc 00 00
	00		 fcomp	 DWORD PTR [esi+188]
  00ac8	df e0		 fnstsw	 ax
  00aca	f6 c4 01	 test	 ah, 1
  00acd	75 31		 jne	 SHORT $LN134@Attack
  00acf	b8 01 00 00 00	 mov	 eax, 1
  00ad4	66 39 46 60	 cmp	 WORD PTR [esi+96], ax
  00ad8	75 26		 jne	 SHORT $LN134@Attack

; 1086 : 	{
; 1087 : 		if ( lpObj->m_CheckLifeTime <= 0 )

  00ada	83 be 10 0f 00
	00 00		 cmp	 DWORD PTR [esi+3856], 0
  00ae1	7f 1d		 jg	 SHORT $LN134@Attack

; 1088 : 		{
; 1089 : 			lpObj->lpAttackObj = lpTargetObj;

  00ae3	89 be 38 02 00
	00		 mov	 DWORD PTR [esi+568], edi

; 1090 : 
; 1091 : 			if ( lpTargetObj->Type == OBJ_USER )

  00ae9	66 39 47 60	 cmp	 WORD PTR [edi+96], ax

; 1092 : 			{
; 1093 : 				lpObj->m_bAttackerKilled = true;
; 1094 : 			}
; 1095 : 			else
; 1096 : 			{
; 1097 : 				lpObj->m_bAttackerKilled = false;
; 1098 : 			}
; 1099 : 
; 1100 : 			lpObj->m_CheckLifeTime = 3;

  00aed	c7 86 10 0f 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+3856], 3
  00af7	0f 94 c2	 sete	 dl
  00afa	88 96 44 02 00
	00		 mov	 BYTE PTR [esi+580], dl
$LN134@Attack:

; 1101 : 		}
; 1102 : 	}
; 1103 : 
; 1104 : 	return TRUE;

  00b00	5e		 pop	 esi
  00b01	5f		 pop	 edi
  00b02	b8 01 00 00 00	 mov	 eax, 1
  00b07	5b		 pop	 ebx

; 1105 : }

  00b08	8b e5		 mov	 esp, ebp
  00b0a	5d		 pop	 ebp
  00b0b	c2 14 00	 ret	 20			; 00000014H
?Attack@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HH@Z ENDP ; CDarkSpirit::Attack
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ModeAttackRandom@CDarkSpirit@@QAEXXZ		; CDarkSpirit::ModeAttackRandom
; Function compile flags: /Ogtp
;	COMDAT ?ModeAttackRandom@CDarkSpirit@@QAEXXZ
_TEXT	SEGMENT
_DuelIndex$ = -328					; size = 4
tv410 = -324						; size = 4
tv216 = -320						; size = 4
_this$GSCopy$ = -316					; size = 4
_criticaldamage$ = -312					; size = 4
_FindObjCount$ = -308					; size = 4
_FindObj$ = -304					; size = 300
__$ArrayPad$ = -4					; size = 4
?ModeAttackRandom@CDarkSpirit@@QAEXXZ PROC		; CDarkSpirit::ModeAttackRandom, COMDAT
; _this$ = ecx

; 104  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi

; 105  : 	LPOBJ lpObj = &gObj[this->m_iMasterIndex];

  00015	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]
  00018	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H

; 106  : 	int tObjNum;
; 107  : 	int count = 0;
; 108  : 	int FindObj[MAX_VIEWPORT];
; 109  : 	int FindObjCount = 0;

  0001e	89 8d c4 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00024	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 110  : 	int dis;
; 111  : 	int DuelIndex = lpObj->m_iDuelUser;

  0002a	8b 8e 1c 0d 00
	00		 mov	 ecx, DWORD PTR [esi+3356]
  00030	33 c0		 xor	 eax, eax
  00032	57		 push	 edi
  00033	89 85 cc fe ff
	ff		 mov	 DWORD PTR _FindObjCount$[ebp], eax
  00039	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _DuelIndex$[ebp], ecx

; 112  : 	BOOL EnableAttack;
; 113  : 	int criticaldamage = 0;

  0003f	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _criticaldamage$[ebp], eax

; 114  : 
; 115  : 	if ( (rand()%10) < 3 )

  00045	e8 00 00 00 00	 call	 _rand
  0004a	99		 cdq
  0004b	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00050	f7 f9		 idiv	 ecx
  00052	83 fa 03	 cmp	 edx, 3
  00055	7d 0a		 jge	 SHORT $LN31@ModeAttack

; 116  : 	{
; 117  : 		criticaldamage = 1;

  00057	c7 85 c8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _criticaldamage$[ebp], 1
$LN31@ModeAttack:

; 118  : 	}
; 119  : 
; 120  : 	while ( true )
; 121  : 	{
; 122  : 		if ( lpObj->VpPlayer2[count].state != 0 )

  00061	8d 86 18 07 00
	00		 lea	 eax, DWORD PTR [esi+1816]
  00067	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv410[ebp], eax
  0006d	c7 85 c0 fe ff
	ff 4b 00 00 00	 mov	 DWORD PTR tv216[ebp], 75 ; 0000004bH
  00077	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL21@ModeAttack:
  00080	80 78 fc 00	 cmp	 BYTE PTR [eax-4], 0
  00084	0f 84 c8 00 00
	00		 je	 $LN30@ModeAttack

; 123  : 		{
; 124  : 			if ( lpObj->VpPlayer2[count].type == OBJ_MONSTER )

  0008a	80 38 02	 cmp	 BYTE PTR [eax], 2
  0008d	0f 85 bf 00 00
	00		 jne	 $LN30@ModeAttack

; 125  : 			{
; 126  : 				tObjNum = lpObj->VpPlayer2[count].number;

  00093	0f bf 58 fe	 movsx	 ebx, WORD PTR [eax-2]

; 127  : 
; 128  : 				if ( tObjNum >= 0 )

  00097	85 db		 test	 ebx, ebx
  00099	0f 88 b3 00 00
	00		 js	 $LN30@ModeAttack

; 129  : 				{
; 130  : 					EnableAttack = FALSE;
; 131  : 
; 132  : 					if ( gObj[tObjNum].Life > 0.0f && (gObj[tObjNum].Class < 100 || gObj[tObjNum].Class  > 110 ) )

  0009f	d9 ee		 fldz
  000a1	8b fb		 mov	 edi, ebx
  000a3	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  000a9	d8 9f bc 00 00
	00		 fcomp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+188]
  000af	df e0		 fnstsw	 ax
  000b1	f6 c4 05	 test	 ah, 5
  000b4	0f 8a 98 00 00
	00		 jp	 $LN30@ModeAttack
  000ba	0f b7 87 98 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+152]
  000c1	83 f8 64	 cmp	 eax, 100		; 00000064H
  000c4	72 09		 jb	 SHORT $LN15@ModeAttack
  000c6	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  000c9	0f 86 83 00 00
	00		 jbe	 $LN30@ModeAttack
$LN15@ModeAttack:

; 133  : 					{
; 134  : 						if ( lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  000cf	8b 8f cc 02 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+716]
  000d5	85 c9		 test	 ecx, ecx

; 135  : 						{
; 136  : 							EnableAttack = TRUE;

  000d7	78 42		 js	 SHORT $LN28@ModeAttack

; 137  : 						}
; 138  : 						else if ( DuelIndex == tObjNum )

  000d9	39 9d b8 fe ff
	ff		 cmp	 DWORD PTR _DuelIndex$[ebp], ebx

; 139  : 						{
; 140  : 							EnableAttack = TRUE;
; 141  : 						}
; 142  : 						else

  000df	74 3a		 je	 SHORT $LN28@ModeAttack

; 143  : 						{
; 144  : 							int lc85 = gObj[tObjNum].m_Index;
; 145  : 
; 146  : 							if ( gObj[tObjNum].Type == OBJ_MONSTER )

  000e1	66 83 bf 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+96], 2
  000e9	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  000ef	75 10		 jne	 SHORT $LN9@ModeAttack

; 147  : 							{
; 148  : 								if ( gObj[tObjNum].m_RecallMon >= 0 )

  000f1	85 c9		 test	 ecx, ecx
  000f3	78 0c		 js	 SHORT $LN9@ModeAttack

; 149  : 								{
; 150  : 									lc85 = gObj[gObj[tObjNum].m_RecallMon].m_Index; 

  000f5	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000fb	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx]
$LN9@ModeAttack:

; 151  : 								}
; 152  : 							}
; 153  : 
; 154  : 							if ( gObjTargetGuildWarCheck(lpObj, &gObj[lc85]) == TRUE )

  00101	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00107	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010c	50		 push	 eax
  0010d	56		 push	 esi
  0010e	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00113	83 c4 08	 add	 esp, 8
  00116	83 f8 01	 cmp	 eax, 1
  00119	75 37		 jne	 SHORT $LN30@ModeAttack
$LN28@ModeAttack:

; 155  : 							{
; 156  : 								EnableAttack = TRUE;
; 157  : 							}
; 158  : 						}
; 159  : 
; 160  : 						if ( EnableAttack != FALSE )
; 161  : 						{
; 162  : 							if ( lpObj->MapNumber == gObj[tObjNum].MapNumber )

  0011b	8a 96 09 01 00
	00		 mov	 dl, BYTE PTR [esi+265]
  00121	3a 97 09 01 00
	00		 cmp	 dl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+265]
  00127	75 29		 jne	 SHORT $LN30@ModeAttack

; 163  : 							{
; 164  : 								dis = gObjCalDistance(lpObj, &gObj[tObjNum]);

  00129	8d 87 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  0012f	50		 push	 eax
  00130	56		 push	 esi
  00131	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00136	83 c4 08	 add	 esp, 8

; 165  : 
; 166  : 								if ( dis < RAVEN_ATTACK_DISTANCE-2 )

  00139	83 f8 05	 cmp	 eax, 5
  0013c	7d 14		 jge	 SHORT $LN30@ModeAttack

; 167  : 								{
; 168  : 									FindObj[FindObjCount] = tObjNum;

  0013e	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _FindObjCount$[ebp]
  00144	89 9c 85 d0 fe
	ff ff		 mov	 DWORD PTR _FindObj$[ebp+eax*4], ebx

; 169  : 									FindObjCount++;

  0014b	40		 inc	 eax
  0014c	89 85 cc fe ff
	ff		 mov	 DWORD PTR _FindObjCount$[ebp], eax
$LN30@ModeAttack:

; 170  : 								}
; 171  : 							}
; 172  : 						}
; 173  : 					}
; 174  : 				}
; 175  : 			}
; 176  : 		}
; 177  : 
; 178  : 		count++;

  00152	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR tv410[ebp]
  00158	83 c0 0c	 add	 eax, 12			; 0000000cH

; 179  : 
; 180  : 		if ( count > MAX_VIEWPORT-1 )

  0015b	ff 8d c0 fe ff
	ff		 dec	 DWORD PTR tv216[ebp]
  00161	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv410[ebp], eax
  00167	0f 85 13 ff ff
	ff		 jne	 $LL21@ModeAttack

; 181  : 		{
; 182  : 			break;
; 183  : 		}
; 184  : 	}
; 185  : 
; 186  : 	if ( FindObjCount != 0 )

  0016d	8b bd cc fe ff
	ff		 mov	 edi, DWORD PTR _FindObjCount$[ebp]
  00173	85 ff		 test	 edi, edi
  00175	74 4b		 je	 SHORT $LN1@ModeAttack

; 187  : 	{
; 188  : 		if ( criticaldamage != 0 )

  00177	8b 9d c8 fe ff
	ff		 mov	 ebx, DWORD PTR _criticaldamage$[ebp]

; 189  : 		{
; 190  : 			int target = FindObj[rand()%FindObjCount];

  0017d	e8 00 00 00 00	 call	 _rand
  00182	99		 cdq
  00183	f7 ff		 idiv	 edi
  00185	8b 94 95 d0 fe
	ff ff		 mov	 edx, DWORD PTR _FindObj$[ebp+edx*4]
  0018c	85 db		 test	 ebx, ebx
  0018e	74 23		 je	 SHORT $LN2@ModeAttack

; 191  : 			this->SendAttackMsg( lpObj->m_Index, target, criticaldamage, 0);

  00190	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00192	6a 00		 push	 0
  00194	53		 push	 ebx
  00195	52		 push	 edx
  00196	51		 push	 ecx
  00197	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0019d	e8 00 00 00 00	 call	 ?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z ; CDarkSpirit::SendAttackMsg
  001a2	5f		 pop	 edi
  001a3	5e		 pop	 esi
  001a4	5b		 pop	 ebx

; 197  : 		}
; 198  : 	}
; 199  : }

  001a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a8	33 cd		 xor	 ecx, ebp
  001aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
$LN2@ModeAttack:

; 192  : 		}
; 193  : 		else
; 194  : 		{
; 195  : 			int target = FindObj[rand()%FindObjCount];
; 196  : 			this->RangeAttack( lpObj->m_Index, target);

  001b3	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001b9	52		 push	 edx
  001ba	8b 16		 mov	 edx, DWORD PTR [esi]
  001bc	52		 push	 edx
  001bd	e8 00 00 00 00	 call	 ?RangeAttack@CDarkSpirit@@QAEXHH@Z ; CDarkSpirit::RangeAttack
$LN1@ModeAttack:

; 197  : 		}
; 198  : 	}
; 199  : }

  001c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c5	5f		 pop	 edi
  001c6	5e		 pop	 esi
  001c7	33 cd		 xor	 ecx, ebp
  001c9	5b		 pop	 ebx
  001ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c3		 ret	 0
?ModeAttackRandom@CDarkSpirit@@QAEXXZ ENDP		; CDarkSpirit::ModeAttackRandom
_TEXT	ENDS
PUBLIC	?ModeAttackWithMaster@CDarkSpirit@@QAEXXZ	; CDarkSpirit::ModeAttackWithMaster
; Function compile flags: /Ogtp
;	COMDAT ?ModeAttackWithMaster@CDarkSpirit@@QAEXXZ
_TEXT	SEGMENT
?ModeAttackWithMaster@CDarkSpirit@@QAEXXZ PROC		; CDarkSpirit::ModeAttackWithMaster, COMDAT
; _this$ = ecx

; 202  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 203  : 	LPOBJ lpObj = &gObj[this->m_iMasterIndex];

  00004	8b 77 14	 mov	 esi, DWORD PTR [edi+20]

; 204  : 	int count = 0;
; 205  : 	int dis;
; 206  : 
; 207  : 	if ( this->m_iTargetIndex == -1 )

  00007	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  0000a	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00010	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00016	83 fa ff	 cmp	 edx, -1
  00019	74 58		 je	 SHORT $LN1@ModeAttack@2

; 208  : 	{
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	if ( lpObj->MapNumber == gObj[this->m_iTargetIndex].MapNumber )

  0001b	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00021	8b ca		 mov	 ecx, edx
  00023	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00029	3a 81 09 01 00
	00		 cmp	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  0002f	75 42		 jne	 SHORT $LN1@ModeAttack@2

; 213  : 	{
; 214  : 		if ( gObj[this->m_iTargetIndex].Life > 0.0f )

  00031	d9 ee		 fldz
  00033	d8 99 bc 00 00
	00		 fcomp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+188]
  00039	df e0		 fnstsw	 ax
  0003b	f6 c4 05	 test	 ah, 5
  0003e	7a 2b		 jp	 SHORT $LN6@ModeAttack@2

; 215  : 		{
; 216  : 			dis = gObjCalDistance(lpObj, &gObj[this->m_iTargetIndex]);

  00040	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx]
  00046	51		 push	 ecx
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0004d	83 c4 08	 add	 esp, 8

; 217  : 
; 218  : 			if ( dis < RAVEN_ATTACK_DISTANCE )

  00050	83 f8 07	 cmp	 eax, 7
  00053	7d 1e		 jge	 SHORT $LN1@ModeAttack@2

; 219  : 			{
; 220  : 				int criticaldamage = 0;
; 221  : 
; 222  : 				if ( (rand()%10) < 3 )

  00055	e8 00 00 00 00	 call	 _rand

; 223  : 				{
; 224  : 					criticaldamage = FALSE;
; 225  : 				}
; 226  : 
; 227  : 				if ( criticaldamage != FALSE )
; 228  : 				{
; 229  : 					this->SendAttackMsg(lpObj->m_Index, this->m_iTargetIndex, criticaldamage, 0);
; 230  : 				}
; 231  : 				else
; 232  : 				{
; 233  : 					this->RangeAttack(lpObj->m_Index, this->m_iTargetIndex);

  0005a	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  0005d	8b 06		 mov	 eax, DWORD PTR [esi]
  0005f	52		 push	 edx
  00060	50		 push	 eax
  00061	8b cf		 mov	 ecx, edi
  00063	e8 00 00 00 00	 call	 ?RangeAttack@CDarkSpirit@@QAEXHH@Z ; CDarkSpirit::RangeAttack
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi

; 240  : 		}
; 241  : 	}
; 242  : }

  0006a	c3		 ret	 0
$LN6@ModeAttack@2:

; 234  : 				}
; 235  : 			}
; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			this->ReSetTarget(this->m_iTargetIndex);

  0006b	52		 push	 edx
  0006c	8b cf		 mov	 ecx, edi
  0006e	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget
$LN1@ModeAttack@2:

; 240  : 		}
; 241  : 	}
; 242  : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	c3		 ret	 0
?ModeAttackWithMaster@CDarkSpirit@@QAEXXZ ENDP		; CDarkSpirit::ModeAttackWithMaster
_TEXT	ENDS
PUBLIC	?ModeAttakTarget@CDarkSpirit@@QAEXXZ		; CDarkSpirit::ModeAttakTarget
; Function compile flags: /Ogtp
;	COMDAT ?ModeAttakTarget@CDarkSpirit@@QAEXXZ
_TEXT	SEGMENT
?ModeAttakTarget@CDarkSpirit@@QAEXXZ PROC		; CDarkSpirit::ModeAttakTarget, COMDAT
; _this$ = ecx

; 245  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 246  : 	LPOBJ lpObj = &gObj[this->m_iMasterIndex];

  00004	8b 77 14	 mov	 esi, DWORD PTR [edi+20]

; 247  : 	int count = 0;
; 248  : 	int dis;
; 249  : 
; 250  : 	if ( this->m_iTargetIndex == -1 )

  00007	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  0000a	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00010	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00016	83 fa ff	 cmp	 edx, -1
  00019	74 57		 je	 SHORT $LN1@ModeAttakT

; 251  : 	{
; 252  : 		return;
; 253  : 	}
; 254  : 
; 255  : 	if ( lpObj->MapNumber == gObj[this->m_iTargetIndex].MapNumber )

  0001b	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00021	8b ca		 mov	 ecx, edx
  00023	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00029	3a 81 09 01 00
	00		 cmp	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  0002f	75 41		 jne	 SHORT $LN1@ModeAttakT

; 256  : 	{
; 257  : 		if ( gObj[this->m_iTargetIndex].Life > 0.0f )

  00031	d9 ee		 fldz
  00033	d8 99 bc 00 00
	00		 fcomp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+188]
  00039	df e0		 fnstsw	 ax
  0003b	f6 c4 05	 test	 ah, 5
  0003e	7a 2a		 jp	 SHORT $LN5@ModeAttakT

; 258  : 		{
; 259  : 			dis = gObjCalDistance(lpObj, &gObj[this->m_iTargetIndex]);

  00040	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx]
  00046	51		 push	 ecx
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0004d	83 c4 08	 add	 esp, 8

; 260  : 
; 261  : 			if ( dis < RAVEN_ATTACK_DISTANCE )

  00050	83 f8 07	 cmp	 eax, 7
  00053	7d 1d		 jge	 SHORT $LN1@ModeAttakT

; 262  : 			{
; 263  : 				int criticaldamage = TRUE;
; 264  : 				int msg = 1;	// Attack with picada
; 265  : 
; 266  : 				if ( criticaldamage != FALSE )
; 267  : 				{
; 268  : 					this->SendAttackMsg(lpObj->m_Index, this->m_iTargetIndex, criticaldamage, msg);

  00055	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  00058	8b 06		 mov	 eax, DWORD PTR [esi]
  0005a	6a 01		 push	 1
  0005c	6a 01		 push	 1
  0005e	52		 push	 edx
  0005f	50		 push	 eax
  00060	8b cf		 mov	 ecx, edi
  00062	e8 00 00 00 00	 call	 ?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z ; CDarkSpirit::SendAttackMsg
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi

; 279  : 		}
; 280  : 	}
; 281  : }

  00069	c3		 ret	 0
$LN5@ModeAttakT:

; 269  : 				}
; 270  : 				else
; 271  : 				{
; 272  : 					this->RangeAttack(lpObj->m_Index, this->m_iTargetIndex);
; 273  : 				}
; 274  : 			}
; 275  : 		}
; 276  : 		else
; 277  : 		{
; 278  : 			this->ReSetTarget(this->m_iTargetIndex);

  0006a	52		 push	 edx
  0006b	8b cf		 mov	 ecx, edi
  0006d	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget
$LN1@ModeAttakT:

; 279  : 		}
; 280  : 	}
; 281  : }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	c3		 ret	 0
?ModeAttakTarget@CDarkSpirit@@QAEXXZ ENDP		; CDarkSpirit::ModeAttakTarget
_TEXT	ENDS
PUBLIC	?Run@CDarkSpirit@@QAEXXZ			; CDarkSpirit::Run
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
; Function compile flags: /Ogtp
;	COMDAT ?Run@CDarkSpirit@@QAEXXZ
_TEXT	SEGMENT
?Run@CDarkSpirit@@QAEXXZ PROC				; CDarkSpirit::Run, COMDAT
; _this$ = ecx

; 41   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 42   : 	if ( this->m_iMasterIndex == -1 )

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 ff	 cmp	 eax, -1
  00009	0f 84 aa 00 00
	00		 je	 $LN5@Run

; 43   : 	{
; 44   : 		return;
; 45   : 	}
; 46   : 
; 47   : 	LPOBJ lpObj = &gObj[this->m_iMasterIndex];

  0000f	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00015	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001a	8b c8		 mov	 ecx, eax

; 48   : 
; 49   : 	if ( lpObj->Class != 4 ) // dl

  0001c	66 83 b9 98 00
	00 00 04	 cmp	 WORD PTR [ecx+152], 4
  00024	0f 85 8f 00 00
	00		 jne	 $LN5@Run

; 50   : 	{
; 51   : 		return;
; 52   : 	}
; 53   : 
; 54   : 	if ( this->m_pPetItem == NULL )

  0002a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 84 00 00
	00		 je	 $LN5@Run

; 55   : 	{
; 56   : 		return;
; 57   : 	}
; 58   : 
; 59   : 	if ( this->m_pPetItem->m_Durability <= 0.0f )

  00035	d9 ee		 fldz
  00037	d8 58 24	 fcomp	 DWORD PTR [eax+36]
  0003a	df e0		 fnstsw	 ax
  0003c	f6 c4 01	 test	 ah, 1
  0003f	74 78		 je	 SHORT $LN5@Run

; 60   : 	{
; 61   : 		return;
; 62   : 	}
; 63   : 
; 64   : 	BYTE attr = MapC[lpObj->MapNumber].GetAttr(lpObj->X, lpObj->Y);
; 65   : 
; 66   : 	if ( (attr&1) != 0 )

  00041	0f bf 81 06 01
	00 00		 movsx	 eax, WORD PTR [ecx+262]
  00048	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  0004f	0f b6 89 09 01
	00 00		 movzx	 ecx, BYTE PTR [ecx+265]
  00056	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  0005c	50		 push	 eax
  0005d	52		 push	 edx
  0005e	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00064	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00069	a8 01		 test	 al, 1
  0006b	75 4c		 jne	 SHORT $LN5@Run

; 67   : 	{
; 68   : 		return;
; 69   : 	}
; 70   : 
; 71   : 	if ( this->m_dwLastAttackTime > GetTickCount() )

  0006d	57		 push	 edi
  0006e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  00074	ff d7		 call	 edi
  00076	39 46 1c	 cmp	 DWORD PTR [esi+28], eax
  00079	77 3d		 ja	 SHORT $LN15@Run

; 72   : 	{
; 73   : 		return;
; 74   : 	}
; 75   : 
; 76   : 	this->m_dwLastAttackTime = ( GetTickCount() + 1500 ) - ( this->m_AttackSpeed * 10 );

  0007b	ff d7		 call	 edi
  0007d	b9 96 00 00 00	 mov	 ecx, 150		; 00000096H
  00082	2b 4e 0c	 sub	 ecx, DWORD PTR [esi+12]
  00085	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  00088	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]

; 77   : 
; 78   : 	switch ( this->m_ActionMode )

  0008b	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0008e	89 56 1c	 mov	 DWORD PTR [esi+28], edx
  00091	83 f8 03	 cmp	 eax, 3
  00094	77 22		 ja	 SHORT $LN15@Run
  00096	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN18@Run[eax*4]
$LN3@Run:
  0009d	5f		 pop	 edi

; 79   : 	{
; 80   : 		case PetItem_Mode_Normal:
; 81   : 			this->ModeNormal();
; 82   : 			break;
; 83   : 
; 84   : 		case PetItem_Mode_Attack_Random:
; 85   : 			this->ModeAttackRandom();

  0009e	8b ce		 mov	 ecx, esi
  000a0	5e		 pop	 esi
  000a1	e9 00 00 00 00	 jmp	 ?ModeAttackRandom@CDarkSpirit@@QAEXXZ ; CDarkSpirit::ModeAttackRandom
$LN2@Run:
  000a6	5f		 pop	 edi

; 86   : 			break;
; 87   : 
; 88   : 		case PetItem_Mode_Attack_WithMaster:
; 89   : 			this->ModeAttackWithMaster();

  000a7	8b ce		 mov	 ecx, esi
  000a9	5e		 pop	 esi
  000aa	e9 00 00 00 00	 jmp	 ?ModeAttackWithMaster@CDarkSpirit@@QAEXXZ ; CDarkSpirit::ModeAttackWithMaster
$LN1@Run:
  000af	5f		 pop	 edi

; 90   : 			break;
; 91   : 
; 92   : 		case PetItem_Mode_Attack_Target:
; 93   : 			this->ModeAttakTarget();

  000b0	8b ce		 mov	 ecx, esi
  000b2	5e		 pop	 esi
  000b3	e9 00 00 00 00	 jmp	 ?ModeAttakTarget@CDarkSpirit@@QAEXXZ ; CDarkSpirit::ModeAttakTarget
$LN15@Run:
  000b8	5f		 pop	 edi
$LN5@Run:
  000b9	5e		 pop	 esi

; 94   : 			break;
; 95   : 	}
; 96   : }

  000ba	c3		 ret	 0
  000bb	90		 npad	 1
$LN18@Run:
  000bc	00 00 00 00	 DD	 $LN15@Run
  000c0	00 00 00 00	 DD	 $LN3@Run
  000c4	00 00 00 00	 DD	 $LN2@Run
  000c8	00 00 00 00	 DD	 $LN1@Run
?Run@CDarkSpirit@@QAEXXZ ENDP				; CDarkSpirit::Run
_TEXT	ENDS
EXTRN	_atexit:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??__EgDarkSpirit@@YAXXZ
text$yc	SEGMENT
??__EgDarkSpirit@@YAXXZ PROC				; `dynamic initializer for 'gDarkSpirit'', COMDAT

; 16   : CDarkSpirit gDarkSpirit[OBJMAX];

  00000	68 00 00 00 00	 push	 OFFSET ??1CDarkSpirit@@UAE@XZ ; CDarkSpirit::~CDarkSpirit
  00005	68 00 00 00 00	 push	 OFFSET ??0CDarkSpirit@@QAE@XZ ; CDarkSpirit::CDarkSpirit
  0000a	68 e8 1c 00 00	 push	 7400			; 00001ce8H
  0000f	6a 28		 push	 40			; 00000028H
  00011	68 00 00 00 00	 push	 OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  00016	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  0001b	68 00 00 00 00	 push	 OFFSET ??__FgDarkSpirit@@YAXXZ ; `dynamic atexit destructor for 'gDarkSpirit''
  00020	e8 00 00 00 00	 call	 _atexit
  00025	59		 pop	 ecx
  00026	c3		 ret	 0
??__EgDarkSpirit@@YAXXZ ENDP				; `dynamic initializer for 'gDarkSpirit''
text$yc	ENDS
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??__FgDarkSpirit@@YAXXZ
text$yd	SEGMENT
??__FgDarkSpirit@@YAXXZ PROC				; `dynamic atexit destructor for 'gDarkSpirit'', COMDAT
  00000	68 00 00 00 00	 push	 OFFSET ??1CDarkSpirit@@UAE@XZ ; CDarkSpirit::~CDarkSpirit
  00005	68 e8 1c 00 00	 push	 7400			; 00001ce8H
  0000a	6a 28		 push	 40			; 00000028H
  0000c	68 00 00 00 00	 push	 OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  00011	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00016	c3		 ret	 0
??__FgDarkSpirit@@YAXXZ ENDP				; `dynamic atexit destructor for 'gDarkSpirit''
text$yd	ENDS
PUBLIC	?gDarkSpirit@@3PAVCDarkSpirit@@A		; gDarkSpirit
_BSS	SEGMENT
?gDarkSpirit@@3PAVCDarkSpirit@@A DB 048440H DUP (?)	; gDarkSpirit
_BSS	ENDS
CRT$XCU	SEGMENT
_gDarkSpirit$initializer$ DD FLAT:??__EgDarkSpirit@@YAXXZ
CRT$XCU	ENDS
END
