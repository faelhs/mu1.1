; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\ObjUseSkill.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
_g_sttCHAOSCASTLE_LEVEL DD 0aH
	DD	031H
	DD	0aH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_DATA	ENDS
PUBLIC	?GetInfinityArrowSkillTime@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetInfinityArrowSkillTime
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\skilladditioninfo.h
;	COMDAT ?GetInfinityArrowSkillTime@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetInfinityArrowSkillTime@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetInfinityArrowSkillTime, COMDAT
; _this$ = ecx

; 23   : 	int GetInfinityArrowSkillTime(){return this->m_iInfinityArrowSkillTime;}

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetInfinityArrowSkillTime@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetInfinityArrowSkillTime
_TEXT	ENDS
PUBLIC	?GetInfinityArrowMPConsumptionPlus0@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus0
; Function compile flags: /Ogtp
;	COMDAT ?GetInfinityArrowMPConsumptionPlus0@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetInfinityArrowMPConsumptionPlus0@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus0, COMDAT
; _this$ = ecx

; 27   : 	int GetInfinityArrowMPConsumptionPlus0(){return this->m_iInfinityArrowMPConsumptionPlus0;}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?GetInfinityArrowMPConsumptionPlus0@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus0
_TEXT	ENDS
PUBLIC	?GetInfinityArrowMPConsumptionPlus1@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus1
; Function compile flags: /Ogtp
;	COMDAT ?GetInfinityArrowMPConsumptionPlus1@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetInfinityArrowMPConsumptionPlus1@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus1, COMDAT
; _this$ = ecx

; 29   : 	int GetInfinityArrowMPConsumptionPlus1(){return this->m_iInfinityArrowMPConsumptionPlus1;}

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	c3		 ret	 0
?GetInfinityArrowMPConsumptionPlus1@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus1
_TEXT	ENDS
PUBLIC	?GetInfinityArrowMPConsumptionPlus2@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus2
; Function compile flags: /Ogtp
;	COMDAT ?GetInfinityArrowMPConsumptionPlus2@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetInfinityArrowMPConsumptionPlus2@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus2, COMDAT
; _this$ = ecx

; 31   : 	int GetInfinityArrowMPConsumptionPlus2(){return this->m_iInfinityArrowMPConsumptionPlus2;}

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	c3		 ret	 0
?GetInfinityArrowMPConsumptionPlus2@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus2
_TEXT	ENDS
PUBLIC	?GetFireScreamSkill@CSkillAdditionInfo@@QAEHXZ	; CSkillAdditionInfo::GetFireScreamSkill
; Function compile flags: /Ogtp
;	COMDAT ?GetFireScreamSkill@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetFireScreamSkill@CSkillAdditionInfo@@QAEHXZ PROC	; CSkillAdditionInfo::GetFireScreamSkill, COMDAT
; _this$ = ecx

; 33   : 	BOOL GetFireScreamSkill(){return this->m_bFireScreamSkill;}

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetFireScreamSkill@CSkillAdditionInfo@@QAEHXZ ENDP	; CSkillAdditionInfo::GetFireScreamSkill
_TEXT	ENDS
PUBLIC	?GetFireScreamExplosionAttackDistance@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetFireScreamExplosionAttackDistance
; Function compile flags: /Ogtp
;	COMDAT ?GetFireScreamExplosionAttackDistance@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetFireScreamExplosionAttackDistance@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetFireScreamExplosionAttackDistance, COMDAT
; _this$ = ecx

; 35   : 	int GetFireScreamExplosionAttackDistance(){return this->m_iFireScreamExplosionAttackDistance;}

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	c3		 ret	 0
?GetFireScreamExplosionAttackDistance@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetFireScreamExplosionAttackDistance
_TEXT	ENDS
PUBLIC	?GetFireScreamExplosionRate@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetFireScreamExplosionRate
; Function compile flags: /Ogtp
;	COMDAT ?GetFireScreamExplosionRate@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetFireScreamExplosionRate@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetFireScreamExplosionRate, COMDAT
; _this$ = ecx

; 37   : 	int GetFireScreamExplosionRate(){return this->m_iFireScreamExplosionRate;}

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	c3		 ret	 0
?GetFireScreamExplosionRate@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetFireScreamExplosionRate
_TEXT	ENDS
PUBLIC	??_7CObjUseSkill@@6B@				; CObjUseSkill::`vftable'
PUBLIC	??0CObjUseSkill@@QAE@XZ				; CObjUseSkill::CObjUseSkill
PUBLIC	??_R4CObjUseSkill@@6B@				; CObjUseSkill::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCObjUseSkill@@@8			; CObjUseSkill `RTTI Type Descriptor'
PUBLIC	??_R3CObjUseSkill@@8				; CObjUseSkill::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObjUseSkill@@8				; CObjUseSkill::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CObjUseSkill@@8			; CObjUseSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??0MULua@@QAE@_N@Z:PROC				; MULua::MULua
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECObjUseSkill@@UAEPAXI@Z:PROC		; CObjUseSkill::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CObjUseSkill@@8
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\objuseskill.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CObjUseSkill@@8 DD FLAT:??_R0?AVCObjUseSkill@@@8 ; CObjUseSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObjUseSkill@@8
rdata$r	ENDS
;	COMDAT ??_R2CObjUseSkill@@8
rdata$r	SEGMENT
??_R2CObjUseSkill@@8 DD FLAT:??_R1A@?0A@EA@CObjUseSkill@@8 ; CObjUseSkill::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObjUseSkill@@8
rdata$r	SEGMENT
??_R3CObjUseSkill@@8 DD 00H				; CObjUseSkill::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObjUseSkill@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObjUseSkill@@@8
_DATA	SEGMENT
??_R0?AVCObjUseSkill@@@8 DD FLAT:??_7type_info@@6B@	; CObjUseSkill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObjUseSkill@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CObjUseSkill@@6B@
rdata$r	SEGMENT
??_R4CObjUseSkill@@6B@ DD 00H				; CObjUseSkill::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCObjUseSkill@@@8
	DD	FLAT:??_R3CObjUseSkill@@8
rdata$r	ENDS
;	COMDAT ??_7CObjUseSkill@@6B@
CONST	SEGMENT
??_7CObjUseSkill@@6B@ DD FLAT:??_R4CObjUseSkill@@6B@	; CObjUseSkill::`vftable'
	DD	FLAT:??_ECObjUseSkill@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0CObjUseSkill@@QAE@XZ
_TEXT	SEGMENT
??0CObjUseSkill@@QAE@XZ PROC				; CObjUseSkill::CObjUseSkill, COMDAT
; _this$ = ecx

; 19   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	6a 00		 push	 0
  00005	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CObjUseSkill@@6B@
  0000e	e8 00 00 00 00	 call	 ??0MULua@@QAE@_N@Z	; MULua::MULua

; 20   : 	return ;
; 21   : }

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??0CObjUseSkill@@QAE@XZ ENDP				; CObjUseSkill::CObjUseSkill
_TEXT	ENDS
PUBLIC	??1CObjUseSkill@@UAE@XZ				; CObjUseSkill::~CObjUseSkill
EXTRN	??1MULua@@QAE@XZ:PROC				; MULua::~MULua
; Function compile flags: /Ogtp
;	COMDAT ??1CObjUseSkill@@UAE@XZ
_TEXT	SEGMENT
??1CObjUseSkill@@UAE@XZ PROC				; CObjUseSkill::~CObjUseSkill, COMDAT
; _this$ = ecx

; 24   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CObjUseSkill@@6B@

; 25   : 	return;
; 26   : }

  00006	83 c1 04	 add	 ecx, 4
  00009	e9 00 00 00 00	 jmp	 ??1MULua@@QAE@XZ	; MULua::~MULua
??1CObjUseSkill@@UAE@XZ ENDP				; CObjUseSkill::~CObjUseSkill
_TEXT	ENDS
PUBLIC	??_C@_0BI@KIBEEOFP@?$FLSKILL?5FILE?$FN?5Carregado?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BM@IFPOHFJJ@?4?2Customs?2Scripts?2Skill?4lua?$AA@ ; `string'
PUBLIC	?Load@CObjUseSkill@@QAEXXZ			; CObjUseSkill::Load
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
EXTRN	?DoFile@MULua@@QAE_NPBD@Z:PROC			; MULua::DoFile
;	COMDAT ??_C@_0BI@KIBEEOFP@?$FLSKILL?5FILE?$FN?5Carregado?$CB?$AA@
CONST	SEGMENT
??_C@_0BI@KIBEEOFP@?$FLSKILL?5FILE?$FN?5Carregado?$CB?$AA@ DB '[SKILL FIL'
	DB	'E] Carregado!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IFPOHFJJ@?4?2Customs?2Scripts?2Skill?4lua?$AA@
CONST	SEGMENT
??_C@_0BM@IFPOHFJJ@?4?2Customs?2Scripts?2Skill?4lua?$AA@ DB '.\Customs\Sc'
	DB	'ripts\Skill.lua', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Load@CObjUseSkill@@QAEXXZ
_TEXT	SEGMENT
?Load@CObjUseSkill@@QAEXXZ PROC				; CObjUseSkill::Load, COMDAT
; _this$ = ecx

; 30   : 	this->m_Lua.DoFile(".\\Customs\\Scripts\\Skill.lua");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IFPOHFJJ@?4?2Customs?2Scripts?2Skill?4lua?$AA@
  00005	83 c1 04	 add	 ecx, 4
  00008	e8 00 00 00 00	 call	 ?DoFile@MULua@@QAE_NPBD@Z ; MULua::DoFile

; 31   : 	// ---
; 32   : 	LogAdd(LOG_GOLD, "[SKILL FILE] Carregado!");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@KIBEEOFP@?$FLSKILL?5FILE?$FN?5Carregado?$CB?$AA@
  00012	6a 05		 push	 5
  00014	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00019	83 c4 08	 add	 esp, 8

; 33   : }

  0001c	c3		 ret	 0
?Load@CObjUseSkill@@QAEXXZ ENDP				; CObjUseSkill::Load
_TEXT	ENDS
PUBLIC	?EnableSkill@CObjUseSkill@@QAEHE@Z		; CObjUseSkill::EnableSkill
; Function compile flags: /Ogtp
;	COMDAT ?EnableSkill@CObjUseSkill@@QAEHE@Z
_TEXT	SEGMENT
_Skill$ = 8						; size = 1
?EnableSkill@CObjUseSkill@@QAEHE@Z PROC			; CObjUseSkill::EnableSkill, COMDAT
; _this$ = ecx

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 162  : 	if(Skill != AT_SKILL_STORM
; 163  : 		&& Skill != AT_SKILL_EVIL
; 164  : 		&& Skill != AT_SKILL_FLAME
; 165  : 		&& Skill != AT_SKILL_HELL
; 166  : 		&& Skill != AT_SKILL_BLAST
; 167  : 		&& Skill != AT_SKILL_INFERNO
; 168  : 		&& Skill != AT_SKILL_CROSSBOW
; 169  : 		&& Skill != AT_SKILL_DEVILFIRE
; 170  : 		&& Skill != AT_SKILL_FLASH
; 171  : 		&& Skill != AT_SKILL_WHEEL
; 172  : 		&& Skill != AT_SKILL_SWORD6
; 173  : 		&& Skill != AT_SKILL_KNIGHTSPEAR
; 174  : 		&& Skill != AT_SKILL_KNIGHTADDLIFE
; 175  : 		&& Skill != AT_SKILL_STRIKE
; 176  : 		&& Skill != AT_SKILL_KNIGHTDINORANT
; 177  : 		&& Skill != AT_SKILL_ELFHARDEN
; 178  : 		&& Skill != AT_SKILL_PENETRATION
; 179  : 		&& Skill != AT_SKILL_DEFENSEDOWN
; 180  : 		&& Skill != AT_SKILL_MAGICDEFENSE
; 181  : 		&& Skill != AT_SKILL_BLOWOFFURY
; 182  : 		&& Skill != AT_SKILL_EXPPOISON
; 183  : 		&& Skill != AT_SKILL_EXPICE
; 184  : 		&& Skill != AT_SKILL_EXPHELL
; 185  : 		&& Skill != AT_SKILL_ELECTRICSPARK
; 186  : 		&& Skill != AT_SKILL_DARKHORSE_ATTACK
; 187  : 		&& Skill != AT_SKILL_BRAND_OF_SKILL
; 188  : 		&& Skill != AT_SKILL_STUN
; 189  : 		&& Skill != AT_SKILL_REMOVAL_STUN
; 190  : 		&& Skill != AT_SKILL_ADD_MANA
; 191  : 		&& Skill != AT_SKILL_INVISIBLE 
; 192  : 		&& Skill != AT_SKILL_REMOVAL_INVISIBLE
; 193  : 		&& Skill != AT_SKILL_REMOVAL_MAGIC
; 194  : 		&& Skill != AT_SKILL_FENRIR_ATTACK
; 195  : 		&& Skill != AT_SKILL_INFINITY_ARROW
; 196  : 		&& Skill != AT_SKILL_FIRESCREAM)

  00003	8a 45 08	 mov	 al, BYTE PTR _Skill$[ebp]
  00006	3c 08		 cmp	 al, 8
  00008	0f 84 9a 00 00
	00		 je	 $LN1@EnableSkil
  0000e	3c 09		 cmp	 al, 9
  00010	0f 84 92 00 00
	00		 je	 $LN1@EnableSkil
  00016	3c 05		 cmp	 al, 5
  00018	0f 84 8a 00 00
	00		 je	 $LN1@EnableSkil
  0001e	3c 0a		 cmp	 al, 10			; 0000000aH
  00020	0f 84 82 00 00
	00		 je	 $LN1@EnableSkil
  00026	3c 0d		 cmp	 al, 13			; 0000000dH
  00028	74 7e		 je	 SHORT $LN1@EnableSkil
  0002a	3c 0e		 cmp	 al, 14			; 0000000eH
  0002c	74 7a		 je	 SHORT $LN1@EnableSkil
  0002e	3c 18		 cmp	 al, 24			; 00000018H
  00030	74 76		 je	 SHORT $LN1@EnableSkil
  00032	3c 32		 cmp	 al, 50			; 00000032H
  00034	74 72		 je	 SHORT $LN1@EnableSkil
  00036	3c 0c		 cmp	 al, 12			; 0000000cH
  00038	74 6e		 je	 SHORT $LN1@EnableSkil
  0003a	3c 29		 cmp	 al, 41			; 00000029H
  0003c	74 6a		 je	 SHORT $LN1@EnableSkil
  0003e	3c 38		 cmp	 al, 56			; 00000038H
  00040	74 66		 je	 SHORT $LN1@EnableSkil
  00042	3c 2f		 cmp	 al, 47			; 0000002fH
  00044	74 62		 je	 SHORT $LN1@EnableSkil
  00046	3c 30		 cmp	 al, 48			; 00000030H
  00048	74 5e		 je	 SHORT $LN1@EnableSkil
  0004a	3c 2b		 cmp	 al, 43			; 0000002bH
  0004c	74 5a		 je	 SHORT $LN1@EnableSkil
  0004e	3c 31		 cmp	 al, 49			; 00000031H
  00050	74 56		 je	 SHORT $LN1@EnableSkil
  00052	3c 33		 cmp	 al, 51			; 00000033H
  00054	74 52		 je	 SHORT $LN1@EnableSkil
  00056	3c 34		 cmp	 al, 52			; 00000034H
  00058	74 4e		 je	 SHORT $LN1@EnableSkil
  0005a	3c 37		 cmp	 al, 55			; 00000037H
  0005c	74 4a		 je	 SHORT $LN1@EnableSkil
  0005e	3c 10		 cmp	 al, 16			; 00000010H
  00060	74 46		 je	 SHORT $LN1@EnableSkil
  00062	3c 2a		 cmp	 al, 42			; 0000002aH
  00064	74 42		 je	 SHORT $LN1@EnableSkil
  00066	3c 26		 cmp	 al, 38			; 00000026H
  00068	74 3e		 je	 SHORT $LN1@EnableSkil
  0006a	3c 27		 cmp	 al, 39			; 00000027H
  0006c	74 3a		 je	 SHORT $LN1@EnableSkil
  0006e	3c 28		 cmp	 al, 40			; 00000028H
  00070	74 36		 je	 SHORT $LN1@EnableSkil
  00072	3c 41		 cmp	 al, 65			; 00000041H
  00074	74 32		 je	 SHORT $LN1@EnableSkil
  00076	3c 3e		 cmp	 al, 62			; 0000003eH
  00078	74 2e		 je	 SHORT $LN1@EnableSkil
  0007a	3c 4b		 cmp	 al, 75			; 0000004bH
  0007c	74 2a		 je	 SHORT $LN1@EnableSkil
  0007e	3c 43		 cmp	 al, 67			; 00000043H
  00080	74 26		 je	 SHORT $LN1@EnableSkil
  00082	3c 44		 cmp	 al, 68			; 00000044H
  00084	74 22		 je	 SHORT $LN1@EnableSkil
  00086	3c 45		 cmp	 al, 69			; 00000045H
  00088	74 1e		 je	 SHORT $LN1@EnableSkil
  0008a	3c 46		 cmp	 al, 70			; 00000046H
  0008c	74 1a		 je	 SHORT $LN1@EnableSkil
  0008e	3c 47		 cmp	 al, 71			; 00000047H
  00090	74 16		 je	 SHORT $LN1@EnableSkil
  00092	3c 48		 cmp	 al, 72			; 00000048H
  00094	74 12		 je	 SHORT $LN1@EnableSkil
  00096	3c 4c		 cmp	 al, 76			; 0000004cH
  00098	74 0e		 je	 SHORT $LN1@EnableSkil
  0009a	3c 4d		 cmp	 al, 77			; 0000004dH
  0009c	74 0a		 je	 SHORT $LN1@EnableSkil
  0009e	3c 4e		 cmp	 al, 78			; 0000004eH
  000a0	74 06		 je	 SHORT $LN1@EnableSkil

; 197  : 	{
; 198  : 		return false;

  000a2	33 c0		 xor	 eax, eax

; 201  : }

  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
$LN1@EnableSkil:

; 199  : 	}
; 200  : 	return true;

  000a8	b8 01 00 00 00	 mov	 eax, 1

; 201  : }

  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
?EnableSkill@CObjUseSkill@@QAEHE@Z ENDP			; CObjUseSkill::EnableSkill
_TEXT	ENDS
PUBLIC	?GetAddUseMana@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; CObjUseSkill::GetAddUseMana
EXTRN	?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A:BYTE ; g_SkillAdditionInfo
; Function compile flags: /Ogtp
;	COMDAT ?GetAddUseMana@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?GetAddUseMana@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z PROC ; CObjUseSkill::GetAddUseMana, COMDAT
; _this$ = ecx

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 233  : 	int iRetValue = 0;
; 234  : 
; 235  : 	if(lpObj->Class == CLASS_ELF && lpObj->Type == OBJ_USER && lpObj->ChangeUP == 1 && lpObj->m_iMuseElfInfinityArrowSkillTime > 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	66 83 b9 98 00
	00 00 02	 cmp	 WORD PTR [ecx+152], 2
  00010	0f 85 18 01 00
	00		 jne	 $LN24@GetAddUseM
  00016	66 83 79 60 01	 cmp	 WORD PTR [ecx+96], 1
  0001b	0f 85 0d 01 00
	00		 jne	 $LN24@GetAddUseM
  00021	80 b9 9b 00 00
	00 01		 cmp	 BYTE PTR [ecx+155], 1
  00028	0f 85 00 01 00
	00		 jne	 $LN24@GetAddUseM
  0002e	39 81 30 15 00
	00		 cmp	 DWORD PTR [ecx+5424], eax
  00034	0f 8e f4 00 00
	00		 jle	 $LN24@GetAddUseM

; 236  : 	{
; 237  : 		if(lpMagic->m_Skill == AT_SKILL_CROSSBOW
; 238  : 			|| lpMagic->m_Skill == AT_SKILL_BOW
; 239  : 			|| lpMagic->m_Skill == AT_SKILL_ELFHARDEN
; 240  : 			|| lpMagic->m_Skill == AT_SKILL_PENETRATION
; 241  : 			|| lpMagic->m_Skill == AT_SKILL_5CROSSBOW)

  0003a	8b 55 0c	 mov	 edx, DWORD PTR _lpMagic$[ebp]
  0003d	8a 52 05	 mov	 dl, BYTE PTR [edx+5]
  00040	80 fa 18	 cmp	 dl, 24			; 00000018H
  00043	74 18		 je	 SHORT $LN15@GetAddUseM
  00045	80 fa 19	 cmp	 dl, 25			; 00000019H
  00048	74 13		 je	 SHORT $LN15@GetAddUseM
  0004a	80 fa 33	 cmp	 dl, 51			; 00000033H
  0004d	74 0e		 je	 SHORT $LN15@GetAddUseM
  0004f	80 fa 34	 cmp	 dl, 52			; 00000034H
  00052	74 09		 je	 SHORT $LN15@GetAddUseM
  00054	80 fa 36	 cmp	 dl, 54			; 00000036H
  00057	0f 85 d1 00 00
	00		 jne	 $LN24@GetAddUseM
$LN15@GetAddUseM:

; 242  : 		{
; 243  : 			int iArrowLevel = 0;
; 244  : 
; 245  : 			CItem * Right = &lpObj->pInventory[0];

  0005d	8b 89 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ecx+3212]
  00063	56		 push	 esi

; 246  : 			CItem * Left = &lpObj->pInventory[1];
; 247  : 
; 248  : 			if(Right->m_Type >= ITEMGET(4,8) && Right->m_Type <= ITEMGET(4,14)
; 249  : 				|| Right->m_Type == ITEMGET(4,16)
; 250  : 				|| Right->m_Type == ITEMGET(4,18)
; 251  : 				|| Right->m_Type == ITEMGET(4,19))

  00064	0f b7 71 06	 movzx	 esi, WORD PTR [ecx+6]
  00068	ba 08 08 00 00	 mov	 edx, 2056		; 00000808H
  0006d	57		 push	 edi
  0006e	66 3b f2	 cmp	 si, dx
  00071	7c 0a		 jl	 SHORT $LN12@GetAddUseM
  00073	ba 0e 08 00 00	 mov	 edx, 2062		; 0000080eH
  00078	66 3b f2	 cmp	 si, dx
  0007b	7e 71		 jle	 SHORT $LN13@GetAddUseM
$LN12@GetAddUseM:
  0007d	ba 10 08 00 00	 mov	 edx, 2064		; 00000810H
  00082	66 3b f2	 cmp	 si, dx
  00085	74 67		 je	 SHORT $LN13@GetAddUseM
  00087	ba 12 08 00 00	 mov	 edx, 2066		; 00000812H
  0008c	66 3b f2	 cmp	 si, dx
  0008f	74 5d		 je	 SHORT $LN13@GetAddUseM
  00091	ba 13 08 00 00	 mov	 edx, 2067		; 00000813H
  00096	66 3b f2	 cmp	 si, dx
  00099	74 53		 je	 SHORT $LN13@GetAddUseM

; 256  : 				}
; 257  : 			}
; 258  : 			else if(Left->m_Type >= ITEMGET(4,0) && Left->m_Type <= ITEMGET(4,6)
; 259  : 				|| Left->m_Type == ITEMGET(4,17)
; 260  : 				|| Left->m_Type == ITEMGET(4,20)
; 261  : 				|| Left->m_Type == ITEMGET(4,21)
; 262  : 				|| Left->m_Type == ITEMGET(4,22))

  0009b	0f b7 91 ae 00
	00 00		 movzx	 edx, WORD PTR [ecx+174]
  000a2	bf 00 08 00 00	 mov	 edi, 2048		; 00000800H
  000a7	66 3b d7	 cmp	 dx, di
  000aa	7c 0a		 jl	 SHORT $LN7@GetAddUseM
  000ac	bf 06 08 00 00	 mov	 edi, 2054		; 00000806H
  000b1	66 3b d7	 cmp	 dx, di
  000b4	7e 28		 jle	 SHORT $LN8@GetAddUseM
$LN7@GetAddUseM:
  000b6	bf 11 08 00 00	 mov	 edi, 2065		; 00000811H
  000bb	66 3b d7	 cmp	 dx, di
  000be	74 1e		 je	 SHORT $LN8@GetAddUseM
  000c0	bf 14 08 00 00	 mov	 edi, 2068		; 00000814H
  000c5	66 3b d7	 cmp	 dx, di
  000c8	74 14		 je	 SHORT $LN8@GetAddUseM
  000ca	bf 15 08 00 00	 mov	 edi, 2069		; 00000815H
  000cf	66 3b d7	 cmp	 dx, di
  000d2	74 0a		 je	 SHORT $LN8@GetAddUseM
  000d4	bf 16 08 00 00	 mov	 edi, 2070		; 00000816H
  000d9	66 3b d7	 cmp	 dx, di
  000dc	75 29		 jne	 SHORT $LN26@GetAddUseM
$LN8@GetAddUseM:

; 263  : 			{
; 264  : 				if(Right->m_Type == ITEMGET(4,15))

  000de	ba 0f 08 00 00	 mov	 edx, 2063		; 0000080fH
  000e3	66 3b f2	 cmp	 si, dx
  000e6	75 1f		 jne	 SHORT $LN26@GetAddUseM

; 265  : 				{
; 266  : 					iArrowLevel = Right->m_Level;

  000e8	0f bf 49 08	 movsx	 ecx, WORD PTR [ecx+8]
  000ec	eb 15		 jmp	 SHORT $LN11@GetAddUseM
$LN13@GetAddUseM:

; 252  : 			{
; 253  : 				if(Left->m_Type == ITEMGET(4,7))

  000ee	ba 07 08 00 00	 mov	 edx, 2055		; 00000807H
  000f3	66 39 91 ae 00
	00 00		 cmp	 WORD PTR [ecx+174], dx
  000fa	75 0b		 jne	 SHORT $LN26@GetAddUseM

; 254  : 				{
; 255  : 					iArrowLevel = Left->m_Level;

  000fc	0f bf 89 b0 00
	00 00		 movsx	 ecx, WORD PTR [ecx+176]
$LN11@GetAddUseM:

; 267  : 				}
; 268  : 			}
; 269  : 
; 270  : 			if(iArrowLevel == 0)

  00103	85 c9		 test	 ecx, ecx
  00105	75 0b		 jne	 SHORT $LN5@GetAddUseM
$LN26@GetAddUseM:

; 271  : 			{
; 272  : 				iRetValue = g_SkillAdditionInfo.GetInfinityArrowMPConsumptionPlus0();

  00107	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+12
  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi

; 281  : 			}
; 282  : 		}
; 283  : 	}
; 284  : 	return iRetValue;
; 285  : }

  0010e	5d		 pop	 ebp
  0010f	c2 08 00	 ret	 8
$LN5@GetAddUseM:

; 273  : 			}
; 274  : 			else if(iArrowLevel == 1)

  00112	83 f9 01	 cmp	 ecx, 1
  00115	75 0b		 jne	 SHORT $LN3@GetAddUseM

; 275  : 			{
; 276  : 				iRetValue = g_SkillAdditionInfo.GetInfinityArrowMPConsumptionPlus1();

  00117	a1 10 00 00 00	 mov	 eax, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+16
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi

; 281  : 			}
; 282  : 		}
; 283  : 	}
; 284  : 	return iRetValue;
; 285  : }

  0011e	5d		 pop	 ebp
  0011f	c2 08 00	 ret	 8
$LN3@GetAddUseM:

; 277  : 			}
; 278  : 			else if(iArrowLevel == 2)

  00122	83 f9 02	 cmp	 ecx, 2
  00125	75 05		 jne	 SHORT $LN27@GetAddUseM

; 279  : 			{
; 280  : 				iRetValue = g_SkillAdditionInfo.GetInfinityArrowMPConsumptionPlus2();

  00127	a1 14 00 00 00	 mov	 eax, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+20
$LN27@GetAddUseM:
  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
$LN24@GetAddUseM:

; 281  : 			}
; 282  : 		}
; 283  : 	}
; 284  : 	return iRetValue;
; 285  : }

  0012e	5d		 pop	 ebp
  0012f	c2 08 00	 ret	 8
?GetAddUseMana@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ENDP ; CObjUseSkill::GetAddUseMana
_TEXT	ENDS
PUBLIC	?GetUseBP@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z	; CObjUseSkill::GetUseBP
EXTRN	?SkillGetBP@CMagicDamage@@QAEHH@Z:PROC		; CMagicDamage::SkillGetBP
EXTRN	?MagicDamageC@@3VCMagicDamage@@A:BYTE		; MagicDamageC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:BYTE			; gObj
; Function compile flags: /Ogtp
;	COMDAT ?GetUseBP@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?GetUseBP@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::GetUseBP, COMDAT
; _this$ = ecx

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 289  : 	LPOBJ lpObj = &gObj[aIndex];

  00005	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00008	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0000e	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 290  : 
; 291  : 	int bp = lpObj->BP;
; 292  : 
; 293  : 	if(lpObj->Type != OBJ_USER)

  00014	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00019	8b 9e e8 00 00
	00		 mov	 ebx, DWORD PTR [esi+232]
  0001f	74 08		 je	 SHORT $LN3@GetUseBP
$LN6@GetUseBP:
  00021	5e		 pop	 esi

; 294  : 	{
; 295  : 		return 0;

  00022	33 c0		 xor	 eax, eax
  00024	5b		 pop	 ebx

; 315  : }

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN3@GetUseBP:

; 296  : 	}
; 297  : 
; 298  : 	if(lpMagic == 0)

  00029	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0002c	85 c0		 test	 eax, eax

; 299  : 	{
; 300  : 		return 0;

  0002e	74 f1		 je	 SHORT $LN6@GetUseBP

; 301  : 	}
; 302  : 
; 303  : 	int usingbp = MagicDamageC.SkillGetBP(lpMagic->m_Skill);

  00030	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  00034	57		 push	 edi
  00035	50		 push	 eax
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0003b	e8 00 00 00 00	 call	 ?SkillGetBP@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetBP

; 304  : 
; 305  : 	usingbp -= usingbp * lpObj->SetOpDecreaseAG / 100;
; 306  : 
; 307  : 	bp -= usingbp;

  00040	0f b6 8e 80 0f
	00 00		 movzx	 ecx, BYTE PTR [esi+3968]
  00047	8b f8		 mov	 edi, eax
  00049	0f af cf	 imul	 ecx, edi
  0004c	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00051	f7 e9		 imul	 ecx
  00053	c1 fa 05	 sar	 edx, 5
  00056	8b ca		 mov	 ecx, edx
  00058	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0005b	03 ca		 add	 ecx, edx
  0005d	2b cf		 sub	 ecx, edi
  0005f	03 d9		 add	 ebx, ecx
  00061	5f		 pop	 edi

; 308  : 
; 309  : 	if(bp < 0)

  00062	79 09		 jns	 SHORT $LN1@GetUseBP

; 310  : 	{
; 311  : 		return -1;

  00064	5e		 pop	 esi
  00065	83 c8 ff	 or	 eax, -1
  00068	5b		 pop	 ebx

; 315  : }

  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
$LN1@GetUseBP:
  0006d	5e		 pop	 esi

; 312  : 	}
; 313  : 
; 314  : 	return bp;

  0006e	8b c3		 mov	 eax, ebx
  00070	5b		 pop	 ebx

; 315  : }

  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8
?GetUseBP@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::GetUseBP
_TEXT	ENDS
PUBLIC	?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHH@Z	; CObjUseSkill::MaGumSkillDefenseDown
EXTRN	?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z:PROC ; GCMagicAttackNumberSend
EXTRN	?retCalcSkillResistance@@YAHPAUOBJECTSTRUCT@@H@Z:PROC ; retCalcSkillResistance
; Function compile flags: /Ogtp
;	COMDAT ?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_skill_level$ = 16					; size = 4
?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHH@Z PROC	; CObjUseSkill::MaGumSkillDefenseDown, COMDAT
; _this$ = ecx

; 603  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 604  : 	int skillSuccess = 1;
; 605  : 	LPOBJ lpObj = &gObj[aIndex];
; 606  : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  00004	8b 75 0c	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]
  00007	57		 push	 edi
  00008	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0000e	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00011	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00017	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001d	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 607  : 
; 608  : 	if(lpObj->Type == OBJ_USER && lpObj->Class != CLASS_MAGUMSA)

  00023	66 83 7f 60 01	 cmp	 WORD PTR [edi+96], 1
  00028	75 0a		 jne	 SHORT $LN2@MaGumSkill
  0002a	66 83 bf 98 00
	00 00 03	 cmp	 WORD PTR [edi+152], 3
  00032	75 37		 jne	 SHORT $LN1@MaGumSkill
$LN2@MaGumSkill:

; 609  : 	{
; 610  : 		return;
; 611  : 	}
; 612  : 	
; 613  : 	if(retCalcSkillResistance(lpTargetObj,1))

  00034	6a 01		 push	 1
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ?retCalcSkillResistance@@YAHPAUOBJECTSTRUCT@@H@Z ; retCalcSkillResistance
  0003c	83 c4 08	 add	 esp, 8
  0003f	85 c0		 test	 eax, eax
  00041	74 28		 je	 SHORT $LN1@MaGumSkill

; 614  : 	{
; 615  : 		lpTargetObj->m_SkillMagumReduceDefense = 10;
; 616  : 		lpTargetObj->m_SkillMagumReduceDefenseTime = 10;
; 617  : 		lpTargetObj->m_ViewSkillState |= 64;

  00043	83 8e c4 01 00
	00 40		 or	 DWORD PTR [esi+452], 64	; 00000040H
  0004a	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0004f	89 86 a0 02 00
	00		 mov	 DWORD PTR [esi+672], eax
  00055	89 86 a4 02 00
	00		 mov	 DWORD PTR [esi+676], eax

; 618  : 
; 619  : 		GCMagicAttackNumberSend(lpObj,AT_SKILL_DEFENSEDOWN,lpTargetObj->m_Index,skillSuccess);

  0005b	8b 06		 mov	 eax, DWORD PTR [esi]
  0005d	6a 01		 push	 1
  0005f	50		 push	 eax
  00060	6a 37		 push	 55			; 00000037H
  00062	57		 push	 edi
  00063	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  00068	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@MaGumSkill:
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi

; 620  : 	}
; 621  : }

  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHH@Z ENDP	; CObjUseSkill::MaGumSkillDefenseDown
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	??_C@_0BD@KFLCOHGE@KnightSkillAddLife?$AA@	; `string'
PUBLIC	??_C@_06CMHBFOJJ@iii?$DOdi?$AA@			; `string'
PUBLIC	__real@0000000000000000
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?KnightSkillAddLife@CObjUseSkill@@QAEXHH@Z	; CObjUseSkill::KnightSkillAddLife
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?GCReFillSend@@YAXHHEE@Z:PROC			; GCReFillSend
EXTRN	?Generic_Call@MULua@@QAA_NPBD0ZZ:PROC		; MULua::Generic_Call
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT ??_C@_0BD@KFLCOHGE@KnightSkillAddLife?$AA@
CONST	SEGMENT
??_C@_0BD@KFLCOHGE@KnightSkillAddLife?$AA@ DB 'KnightSkillAddLife', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CMHBFOJJ@iii?$DOdi?$AA@
CONST	SEGMENT
??_C@_06CMHBFOJJ@iii?$DOdi?$AA@ DB 'iii>di', 00H	; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?KnightSkillAddLife@CObjUseSkill@@QAEXHH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -56					; size = 4
_iaddLifepower$ = -52					; size = 8
tv535 = -44						; size = 4
_iLifeTime$ = -40					; size = 4
_viewpercent$ = -36					; size = 4
_n$157441 = -32						; size = 4
_viewplayer$ = -32					; size = 4
tv524 = -28						; size = 4
tv505 = -28						; size = 4
tv492 = -28						; size = 4
tv479 = -28						; size = 4
_partynum$ = -28					; size = 4
_ApplyPartyIndex$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_skill_level$ = 12					; size = 4
?KnightSkillAddLife@CObjUseSkill@@QAEXHH@Z PROC		; CObjUseSkill::KnightSkillAddLife, COMDAT
; _this$ = ecx

; 624  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 625  : 	int skillSuccess = true;
; 626  : 	LPOBJ lpObj = &gObj[aIndex];

  00014	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0001a	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 627  : 
; 628  : 	if(lpObj->Type != OBJ_USER && lpObj->m_RecallMon == -1)

  00020	66 83 7f 60 01	 cmp	 WORD PTR [edi+96], 1
  00025	89 4d c8	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00028	74 0d		 je	 SHORT $LN30@KnightSkil
  0002a	83 bf cc 02 00
	00 ff		 cmp	 DWORD PTR [edi+716], -1
  00031	0f 84 8a 02 00
	00		 je	 $LN2@KnightSkil
$LN30@KnightSkil:

; 629  : 	{
; 630  : 		return;
; 631  : 	}
; 632  : 
; 633  : 	if(lpObj->Class != CLASS_KNIGHT && lpObj->Class != CLASS_MAGUMSA)

  00037	0f b7 87 98 00
	00 00		 movzx	 eax, WORD PTR [edi+152]
  0003e	83 f8 01	 cmp	 eax, 1
  00041	74 09		 je	 SHORT $LN31@KnightSkil
  00043	83 f8 03	 cmp	 eax, 3
  00046	0f 85 75 02 00
	00		 jne	 $LN2@KnightSkil
$LN31@KnightSkil:

; 634  : 	{
; 635  : 		return;
; 636  : 	}
; 637  : 
; 638  : 	int number;
; 639  : 	int partynum = 0;
; 640  : 	int totallevel = 0;
; 641  : 	int partycount;
; 642  : 	int dis;
; 643  : 
; 644  : 	int ApplyPartyIndex[MAX_USER_IN_PARTY];
; 645  : 
; 646  : 	int viewplayer = 0;
; 647  : 	int viewpercent = 0;
; 648  : 
; 649  : 	LPOBJ lpPartyObj;
; 650  : 
; 651  : 	memset(ApplyPartyIndex,-1,sizeof(ApplyPartyIndex));
; 652  : 
; 653  : 	partynum = lpObj->PartyNumber;

  0004c	8b 8f a8 02 00
	00		 mov	 ecx, DWORD PTR [edi+680]
  00052	83 c8 ff	 or	 eax, -1
  00055	53		 push	 ebx
  00056	33 db		 xor	 ebx, ebx
  00058	56		 push	 esi
  00059	89 5d e0	 mov	 DWORD PTR _viewplayer$[ebp], ebx
  0005c	89 5d dc	 mov	 DWORD PTR _viewpercent$[ebp], ebx
  0005f	89 45 e8	 mov	 DWORD PTR _ApplyPartyIndex$[ebp], eax
  00062	89 45 ec	 mov	 DWORD PTR _ApplyPartyIndex$[ebp+4], eax
  00065	89 45 f0	 mov	 DWORD PTR _ApplyPartyIndex$[ebp+8], eax
  00068	89 45 f4	 mov	 DWORD PTR _ApplyPartyIndex$[ebp+12], eax
  0006b	89 45 f8	 mov	 DWORD PTR _ApplyPartyIndex$[ebp+16], eax
  0006e	89 4d e4	 mov	 DWORD PTR _partynum$[ebp], ecx

; 654  : 
; 655  : 	if(partynum != -1)

  00071	3b c8		 cmp	 ecx, eax
  00073	0f 84 88 00 00
	00		 je	 $LN34@KnightSkil

; 656  : 	{
; 657  : 		partycount = gParty.m_PartyS[partynum].Count;
; 658  : 
; 659  : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00079	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0007c	c1 e1 04	 shl	 ecx, 4
  0007f	81 c1 0c 00 00
	00		 add	 ecx, OFFSET ?gParty@@3VPartyClass@@A+12
  00085	89 4d d4	 mov	 DWORD PTR tv535[ebp], ecx
$LL35@KnightSkil:

; 660  : 		{
; 661  : 			number = gParty.m_PartyS[partynum].Number[n];

  00088	8b 01		 mov	 eax, DWORD PTR [ecx]

; 662  : 
; 663  : 			if(number >= 0)

  0008a	85 c0		 test	 eax, eax
  0008c	78 35		 js	 SHORT $LN19@KnightSkil

; 664  : 			{
; 665  : 				lpPartyObj = &gObj[number];

  0008e	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00094	8d b0 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]

; 666  : 
; 667  : 				if(lpObj->MapNumber == lpPartyObj->MapNumber)

  0009a	8a 87 09 01 00
	00		 mov	 al, BYTE PTR [edi+265]
  000a0	3a 86 09 01 00
	00		 cmp	 al, BYTE PTR [esi+265]
  000a6	75 1b		 jne	 SHORT $LN19@KnightSkil

; 668  : 				{
; 669  : 					dis = gObjCalDistance(lpObj,&gObj[number]);

  000a8	56		 push	 esi
  000a9	57		 push	 edi
  000aa	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000af	83 c4 08	 add	 esp, 8

; 670  : 
; 671  : 					if(dis < 10)

  000b2	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000b5	7d 09		 jge	 SHORT $LN32@KnightSkil

; 672  : 					{
; 673  : 						ApplyPartyIndex[n] = lpPartyObj->m_Index;

  000b7	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 674  : 						viewplayer++;

  000b9	ff 45 e0	 inc	 DWORD PTR _viewplayer$[ebp]
  000bc	89 4c 9d e8	 mov	 DWORD PTR _ApplyPartyIndex$[ebp+ebx*4], ecx
$LN32@KnightSkil:
  000c0	8b 4d d4	 mov	 ecx, DWORD PTR tv535[ebp]
$LN19@KnightSkil:

; 656  : 	{
; 657  : 		partycount = gParty.m_PartyS[partynum].Count;
; 658  : 
; 659  : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  000c3	43		 inc	 ebx
  000c4	83 c1 04	 add	 ecx, 4
  000c7	89 4d d4	 mov	 DWORD PTR tv535[ebp], ecx
  000ca	83 fb 05	 cmp	 ebx, 5
  000cd	7c b9		 jl	 SHORT $LL35@KnightSkil

; 675  : 					}
; 676  : 				}
; 677  : 			}
; 678  : 		}
; 679  : 	}
; 680  : 
; 681  : 	if(viewplayer > 1)

  000cf	8b 45 e0	 mov	 eax, DWORD PTR _viewplayer$[ebp]
  000d2	83 f8 01	 cmp	 eax, 1
  000d5	7e 2a		 jle	 SHORT $LN34@KnightSkil

; 682  : 	{
; 683  : 		if(viewplayer == 2)

  000d7	83 f8 02	 cmp	 eax, 2
  000da	75 09		 jne	 SHORT $LN13@KnightSkil

; 684  : 		{
; 685  : 			viewpercent = 1;

  000dc	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 1
  000e3	eb 1c		 jmp	 SHORT $LN34@KnightSkil
$LN13@KnightSkil:

; 686  : 		}
; 687  : 		else if(viewplayer == 3)

  000e5	83 f8 03	 cmp	 eax, 3
  000e8	75 09		 jne	 SHORT $LN11@KnightSkil

; 688  : 		{
; 689  : 			viewpercent = 2;

  000ea	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 2
  000f1	eb 0e		 jmp	 SHORT $LN34@KnightSkil
$LN11@KnightSkil:

; 690  : 		}
; 691  : 		else if(viewplayer == 4)

  000f3	33 d2		 xor	 edx, edx
  000f5	83 f8 04	 cmp	 eax, 4
  000f8	0f 95 c2	 setne	 dl
  000fb	83 c2 03	 add	 edx, 3
  000fe	89 55 dc	 mov	 DWORD PTR _viewpercent$[ebp], edx
$LN34@KnightSkil:

; 692  : 		{
; 693  : 			viewpercent = 3;
; 694  : 		}
; 695  : 		else
; 696  : 		{
; 697  : 			viewpercent = 4;
; 698  : 		}
; 699  : 	}
; 700  : 
; 701  : 	double iaddLifepower = 0.0;
; 702  : 	int iLifeTime = 0;
; 703  : 	int iaddlife = 0;
; 704  : 
; 705  : 	this->m_Lua.Generic_Call("KnightSkillAddLife", "iii>di", (lpObj->Vitality + lpObj->AddVitality), (lpObj->Energy + lpObj->AddEnergy), viewpercent, &iaddLifepower, &iLifeTime);

  00101	8b 55 dc	 mov	 edx, DWORD PTR _viewpercent$[ebp]
  00104	d9 ee		 fldz
  00106	8d 45 d8	 lea	 eax, DWORD PTR _iLifeTime$[ebp]
  00109	dd 5d cc	 fstp	 QWORD PTR _iaddLifepower$[ebp]
  0010c	50		 push	 eax
  0010d	0f bf 87 e6 00
	00 00		 movsx	 eax, WORD PTR [edi+230]
  00114	8d 4d cc	 lea	 ecx, DWORD PTR _iaddLifepower$[ebp]
  00117	51		 push	 ecx
  00118	0f b7 8f ba 00
	00 00		 movzx	 ecx, WORD PTR [edi+186]
  0011f	52		 push	 edx
  00120	0f bf 97 e4 00
	00 00		 movsx	 edx, WORD PTR [edi+228]
  00127	03 c1		 add	 eax, ecx
  00129	8b 4d c8	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0012c	50		 push	 eax
  0012d	0f b7 87 b8 00
	00 00		 movzx	 eax, WORD PTR [edi+184]
  00134	03 d0		 add	 edx, eax
  00136	52		 push	 edx
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_06CMHBFOJJ@iii?$DOdi?$AA@
  0013c	83 c1 04	 add	 ecx, 4
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KFLCOHGE@KnightSkillAddLife?$AA@
  00144	51		 push	 ecx
  00145	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _iLifeTime$[ebp], 0
  0014c	e8 00 00 00 00	 call	 ?Generic_Call@MULua@@QAA_NPBD0ZZ ; MULua::Generic_Call
  00151	83 c4 20	 add	 esp, 32			; 00000020H

; 706  : 
; 707  : 	if(lpObj->Type == OBJ_USER && partynum == -1)

  00154	66 83 7f 60 01	 cmp	 WORD PTR [edi+96], 1
  00159	0f 85 ae 00 00
	00		 jne	 $LN7@KnightSkil
  0015f	83 7d e4 ff	 cmp	 DWORD PTR _partynum$[ebp], -1
  00163	0f 85 a4 00 00
	00		 jne	 $LN7@KnightSkil

; 708  : 	{
; 709  : 		iaddlife = int(lpObj->MaxLife) * iaddLifepower / 100;

  00169	d9 87 c0 00 00
	00		 fld	 DWORD PTR [edi+192]
  0016f	e8 00 00 00 00	 call	 __ftol2_sse
  00174	89 45 e4	 mov	 DWORD PTR tv524[ebp], eax
  00177	db 45 e4	 fild	 DWORD PTR tv524[ebp]
  0017a	dc 4d cc	 fmul	 QWORD PTR _iaddLifepower$[ebp]
  0017d	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  00183	e8 00 00 00 00	 call	 __ftol2_sse
  00188	8b f0		 mov	 esi, eax

; 710  : 
; 711  : 		if(iaddlife > 3000000)

  0018a	81 fe c0 c6 2d
	00		 cmp	 esi, 3000000		; 002dc6c0H
  00190	7e 05		 jle	 SHORT $LN6@KnightSkil

; 712  : 		{
; 713  : 			iaddlife = 3000000;

  00192	be c0 c6 2d 00	 mov	 esi, 3000000		; 002dc6c0H
$LN6@KnightSkil:

; 714  : 		}
; 715  : 		
; 716  : 		lpObj->AddLife -= lpObj->m_SkillAddLife;
; 717  : 		lpObj->AddLife += iaddlife;

  00197	8b d6		 mov	 edx, esi
  00199	2b 97 90 02 00
	00		 sub	 edx, DWORD PTR [edi+656]

; 718  : 
; 719  : 		GCReFillSend(lpObj->m_Index,lpObj->MaxLife + lpObj->AddLife,0xFE,0);

  0019f	6a 00		 push	 0
  001a1	01 97 0c 01 00
	00		 add	 DWORD PTR [edi+268], edx
  001a7	8b 87 0c 01 00
	00		 mov	 eax, DWORD PTR [edi+268]
  001ad	89 45 e4	 mov	 DWORD PTR tv479[ebp], eax
  001b0	db 45 e4	 fild	 DWORD PTR tv479[ebp]
  001b3	68 fe 00 00 00	 push	 254			; 000000feH
  001b8	d8 87 c0 00 00
	00		 fadd	 DWORD PTR [edi+192]
  001be	e8 00 00 00 00	 call	 __ftol2_sse
  001c3	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001c5	50		 push	 eax
  001c6	51		 push	 ecx
  001c7	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend

; 720  : 
; 721  : 		lpObj->m_SkillAddLife = iaddlife;
; 722  : 		lpObj->m_SkillAddLifeTime = iLifeTime;
; 723  : 
; 724  : 		lpObj->m_ViewSkillState |= 16;
; 725  : 		GCMagicAttackNumberSend(lpObj,AT_SKILL_KNIGHTADDLIFE,lpObj->m_Index,skillSuccess);

  001cc	8b 07		 mov	 eax, DWORD PTR [edi]
  001ce	8b 55 d8	 mov	 edx, DWORD PTR _iLifeTime$[ebp]
  001d1	83 8f c4 01 00
	00 10		 or	 DWORD PTR [edi+452], 16	; 00000010H
  001d8	6a 01		 push	 1
  001da	50		 push	 eax
  001db	6a 30		 push	 48			; 00000030H
  001dd	57		 push	 edi
  001de	89 b7 90 02 00
	00		 mov	 DWORD PTR [edi+656], esi
  001e4	89 97 94 02 00
	00		 mov	 DWORD PTR [edi+660], edx
  001ea	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 726  : 
; 727  : 		gObjCalCharacter(lpObj->m_Index);

  001ef	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001f1	51		 push	 ecx
  001f2	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  001f7	83 c4 24	 add	 esp, 36			; 00000024H
  001fa	5e		 pop	 esi
  001fb	5b		 pop	 ebx
  001fc	5f		 pop	 edi

; 749  : 			}
; 750  : 		}
; 751  : 	}
; 752  : }

  001fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00200	33 cd		 xor	 ecx, ebp
  00202	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c2 08 00	 ret	 8
$LN7@KnightSkil:

; 728  : 	}
; 729  : 	else
; 730  : 	{
; 731  : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  0020d	33 c0		 xor	 eax, eax
  0020f	89 45 e0	 mov	 DWORD PTR _n$157441[ebp], eax
$LL4@KnightSkil:

; 732  : 		{
; 733  : 			if(ApplyPartyIndex[n]!= -1)

  00212	8b 74 85 e8	 mov	 esi, DWORD PTR _ApplyPartyIndex$[ebp+eax*4]
  00216	83 fe ff	 cmp	 esi, -1
  00219	0f 84 93 00 00
	00		 je	 $LN3@KnightSkil

; 734  : 			{
; 735  : 				lpPartyObj = &gObj[ApplyPartyIndex[n]];

  0021f	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00225	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 736  : 
; 737  : 				iaddlife = int(lpPartyObj->MaxLife) * iaddLifepower / 100;

  0022b	d9 86 c0 00 00
	00		 fld	 DWORD PTR [esi+192]
  00231	e8 00 00 00 00	 call	 __ftol2_sse
  00236	89 45 e4	 mov	 DWORD PTR tv505[ebp], eax
  00239	db 45 e4	 fild	 DWORD PTR tv505[ebp]
  0023c	dc 4d cc	 fmul	 QWORD PTR _iaddLifepower$[ebp]
  0023f	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  00245	e8 00 00 00 00	 call	 __ftol2_sse
  0024a	8b d8		 mov	 ebx, eax

; 738  : 				lpPartyObj->AddLife -= lpPartyObj->m_SkillAddLife;
; 739  : 				lpPartyObj->AddLife += iaddlife;

  0024c	8b d3		 mov	 edx, ebx
  0024e	2b 96 90 02 00
	00		 sub	 edx, DWORD PTR [esi+656]

; 740  : 
; 741  : 				GCReFillSend(lpPartyObj->m_Index,lpPartyObj->MaxLife + lpPartyObj->AddLife,0xFE,0);

  00254	6a 00		 push	 0
  00256	01 96 0c 01 00
	00		 add	 DWORD PTR [esi+268], edx
  0025c	8b 86 0c 01 00
	00		 mov	 eax, DWORD PTR [esi+268]
  00262	89 45 e4	 mov	 DWORD PTR tv492[ebp], eax
  00265	db 45 e4	 fild	 DWORD PTR tv492[ebp]
  00268	68 fe 00 00 00	 push	 254			; 000000feH
  0026d	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  00273	e8 00 00 00 00	 call	 __ftol2_sse
  00278	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0027a	50		 push	 eax
  0027b	51		 push	 ecx
  0027c	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend

; 742  : 
; 743  : 				lpPartyObj->m_SkillAddLife = iaddlife;
; 744  : 				lpPartyObj->m_SkillAddLifeTime = iLifeTime;
; 745  : 
; 746  : 				lpPartyObj->m_ViewSkillState |= 16;
; 747  : 				GCMagicAttackNumberSend(lpObj,AT_SKILL_KNIGHTADDLIFE,lpPartyObj->m_Index,skillSuccess);

  00281	8b 06		 mov	 eax, DWORD PTR [esi]
  00283	8b 55 d8	 mov	 edx, DWORD PTR _iLifeTime$[ebp]
  00286	83 8e c4 01 00
	00 10		 or	 DWORD PTR [esi+452], 16	; 00000010H
  0028d	6a 01		 push	 1
  0028f	50		 push	 eax
  00290	6a 30		 push	 48			; 00000030H
  00292	57		 push	 edi
  00293	89 9e 90 02 00
	00		 mov	 DWORD PTR [esi+656], ebx
  00299	89 96 94 02 00
	00		 mov	 DWORD PTR [esi+660], edx
  0029f	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 748  : 				gObjCalCharacter(lpObj->m_Index);

  002a4	8b 0f		 mov	 ecx, DWORD PTR [edi]
  002a6	51		 push	 ecx
  002a7	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  002ac	8b 45 e0	 mov	 eax, DWORD PTR _n$157441[ebp]
  002af	83 c4 24	 add	 esp, 36			; 00000024H
$LN3@KnightSkil:

; 728  : 	}
; 729  : 	else
; 730  : 	{
; 731  : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  002b2	40		 inc	 eax
  002b3	89 45 e0	 mov	 DWORD PTR _n$157441[ebp], eax
  002b6	83 f8 05	 cmp	 eax, 5
  002b9	0f 8c 53 ff ff
	ff		 jl	 $LL4@KnightSkil
  002bf	5e		 pop	 esi
  002c0	5b		 pop	 ebx
$LN2@KnightSkil:

; 749  : 			}
; 750  : 		}
; 751  : 	}
; 752  : }

  002c1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c4	33 cd		 xor	 ecx, ebp
  002c6	5f		 pop	 edi
  002c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cc	8b e5		 mov	 esp, ebp
  002ce	5d		 pop	 ebp
  002cf	c2 08 00	 ret	 8
?KnightSkillAddLife@CObjUseSkill@@QAEXHH@Z ENDP		; CObjUseSkill::KnightSkillAddLife
_TEXT	ENDS
PUBLIC	??_C@_0BD@MCBGGOFB@WizardMagicDefense?$AA@	; `string'
PUBLIC	??_C@_07BLJLOFBO@iiii?$DOdi?$AA@		; `string'
PUBLIC	?WizardMagicDefense@CObjUseSkill@@QAEXHHH@Z	; CObjUseSkill::WizardMagicDefense
;	COMDAT ??_C@_0BD@MCBGGOFB@WizardMagicDefense?$AA@
CONST	SEGMENT
??_C@_0BD@MCBGGOFB@WizardMagicDefense?$AA@ DB 'WizardMagicDefense', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BLJLOFBO@iiii?$DOdi?$AA@
CONST	SEGMENT
??_C@_07BLJLOFBO@iiii?$DOdi?$AA@ DB 'iiii>di', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?WizardMagicDefense@CObjUseSkill@@QAEXHHH@Z
_TEXT	SEGMENT
_skillInc$ = -8						; size = 8
_skillTime$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_skill_level$ = 16					; size = 4
?WizardMagicDefense@CObjUseSkill@@QAEXHHH@Z PROC	; CObjUseSkill::WizardMagicDefense, COMDAT
; _this$ = ecx

; 755  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 756  : 	int skillSuccess = true;
; 757  : 	// ---
; 758  : 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 759  : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  0000b	8b 7d 0c	 mov	 edi, DWORD PTR _aTargetIndex$[ebp]
  0000e	8b f0		 mov	 esi, eax
  00010	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00016	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0001c	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00022	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 760  : 	// ---
; 761  : 	if(lpObj->Type != OBJ_USER && lpObj->m_RecallMon== -1)

  00028	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0002d	74 0d		 je	 SHORT $LN3@WizardMagi
  0002f	83 be cc 02 00
	00 ff		 cmp	 DWORD PTR [esi+716], -1
  00036	0f 84 a8 00 00
	00		 je	 $LN4@WizardMagi
$LN3@WizardMagi:

; 762  : 	{
; 763  : 		return;
; 764  : 	}
; 765  : 	// ---
; 766  : 	if(lpObj->Class != CLASS_WIZARD && lpObj->Class != CLASS_MAGUMSA)

  0003c	0f b7 96 98 00
	00 00		 movzx	 edx, WORD PTR [esi+152]
  00043	66 85 d2	 test	 dx, dx
  00046	74 09		 je	 SHORT $LN2@WizardMagi
  00048	83 fa 03	 cmp	 edx, 3
  0004b	0f 85 93 00 00
	00		 jne	 $LN4@WizardMagi
$LN2@WizardMagi:

; 767  : 	{
; 768  : 		return;
; 769  : 	}
; 770  : 	// ---
; 771  : 	if(lpObj->PartyNumber != lpTargetObj->PartyNumber)

  00051	8b 96 a8 02 00
	00		 mov	 edx, DWORD PTR [esi+680]
  00057	3b 97 a8 02 00
	00		 cmp	 edx, DWORD PTR [edi+680]
  0005d	0f 85 81 00 00
	00		 jne	 $LN4@WizardMagi

; 772  : 	{
; 773  : 		return;
; 774  : 	}
; 775  : 	// ---
; 776  : 	double skillInc = 0.0;

  00063	53		 push	 ebx
  00064	d9 ee		 fldz

; 777  : 	int skillTime = 0;
; 778  : 	// ---
; 779  : 	this->m_Lua.Generic_Call("WizardMagicDefense", "iiii>di", aIndex, aTargetIndex, (lpObj->Dexterity + lpObj->AddDexterity), (lpObj->Energy + lpObj->AddEnergy), &skillInc, &skillTime);

  00066	0f b7 9e ba 00
	00 00		 movzx	 ebx, WORD PTR [esi+186]
  0006d	dd 5d f8	 fstp	 QWORD PTR _skillInc$[ebp]
  00070	8d 55 08	 lea	 edx, DWORD PTR _skillTime$[ebp]
  00073	52		 push	 edx
  00074	8d 55 f8	 lea	 edx, DWORD PTR _skillInc$[ebp]
  00077	52		 push	 edx
  00078	0f bf 96 e6 00
	00 00		 movsx	 edx, WORD PTR [esi+230]
  0007f	03 d3		 add	 edx, ebx
  00081	0f b7 9e b6 00
	00 00		 movzx	 ebx, WORD PTR [esi+182]
  00088	52		 push	 edx
  00089	0f bf 96 e2 00
	00 00		 movsx	 edx, WORD PTR [esi+226]
  00090	03 d3		 add	 edx, ebx
  00092	52		 push	 edx
  00093	8b 55 0c	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  00096	52		 push	 edx
  00097	50		 push	 eax
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_07BLJLOFBO@iiii?$DOdi?$AA@
  0009d	83 c1 04	 add	 ecx, 4
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@MCBGGOFB@WizardMagicDefense?$AA@
  000a5	51		 push	 ecx
  000a6	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _skillTime$[ebp], 0
  000ad	e8 00 00 00 00	 call	 ?Generic_Call@MULua@@QAA_NPBD0ZZ ; MULua::Generic_Call

; 780  : 	// ---
; 781  : 	lpTargetObj->m_WizardSkillDefense		= skillInc;

  000b2	dd 45 f8	 fld	 QWORD PTR _skillInc$[ebp]
  000b5	e8 00 00 00 00	 call	 __ftol2_sse

; 782  : 	lpTargetObj->m_WizardSkillDefenseTime	= skillTime;
; 783  : 	// ---
; 784  : 	lpTargetObj->m_ViewSkillState			|= 256;
; 785  : 	// ---
; 786  : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_MAGICDEFENSE,lpTargetObj->m_Index,skillSuccess);

  000ba	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000bc	81 8f c4 01 00
	00 00 01 00 00	 or	 DWORD PTR [edi+452], 256 ; 00000100H
  000c6	6a 01		 push	 1
  000c8	51		 push	 ecx
  000c9	89 87 04 0f 00
	00		 mov	 DWORD PTR [edi+3844], eax
  000cf	8b 45 08	 mov	 eax, DWORD PTR _skillTime$[ebp]
  000d2	6a 10		 push	 16			; 00000010H
  000d4	56		 push	 esi
  000d5	89 87 08 0f 00
	00		 mov	 DWORD PTR [edi+3848], eax
  000db	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  000e0	83 c4 34	 add	 esp, 52			; 00000034H
  000e3	5b		 pop	 ebx
$LN4@WizardMagi:
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi

; 787  : }

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 0c 00	 ret	 12			; 0000000cH
?WizardMagicDefense@CObjUseSkill@@QAEXHHH@Z ENDP	; CObjUseSkill::WizardMagicDefense
_TEXT	ENDS
PUBLIC	__real@4024000000000000
PUBLIC	??_C@_0BA@ONMAGIGA@ElfSkillDefense?$AA@		; `string'
PUBLIC	??_C@_07KODFJLFD@iiii?$DOdd?$AA@		; `string'
PUBLIC	?SkillDefense@CObjUseSkill@@QAEXHHH@Z		; CObjUseSkill::SkillDefense
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT ??_C@_0BA@ONMAGIGA@ElfSkillDefense?$AA@
CONST	SEGMENT
??_C@_0BA@ONMAGIGA@ElfSkillDefense?$AA@ DB 'ElfSkillDefense', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KODFJLFD@iiii?$DOdd?$AA@
CONST	SEGMENT
??_C@_07KODFJLFD@iiii?$DOdd?$AA@ DB 'iiii>dd', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SkillDefense@CObjUseSkill@@QAEXHHH@Z
_TEXT	SEGMENT
_skill_time$ = -16					; size = 8
_skill_defense$ = -8					; size = 8
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_skill_level$ = 16					; size = 4
?SkillDefense@CObjUseSkill@@QAEXHHH@Z PROC		; CObjUseSkill::SkillDefense, COMDAT
; _this$ = ecx

; 790  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 791  : 	int skillSuccess = true;
; 792  : 	// ---
; 793  : 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	56		 push	 esi

; 794  : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  0000a	8b 75 0c	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]
  0000d	57		 push	 edi
  0000e	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00014	8b f8		 mov	 edi, eax
  00016	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0001c	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00022	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 795  : 	// ---
; 796  : 	if(lpTargetObj->Type != OBJ_USER && lpTargetObj->m_RecallMon == -1)

  00028	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0002d	74 0d		 je	 SHORT $LN4@SkillDefen
  0002f	83 be cc 02 00
	00 ff		 cmp	 DWORD PTR [esi+716], -1
  00036	0f 84 c0 00 00
	00		 je	 $LN5@SkillDefen
$LN4@SkillDefen:

; 797  : 	{
; 798  : 		return;
; 799  : 	}
; 800  : 	// ---
; 801  : 	if(lpObj->Class != CLASS_ELF)

  0003c	66 83 bf 98 00
	00 00 02	 cmp	 WORD PTR [edi+152], 2
  00044	0f 85 b2 00 00
	00		 jne	 $LN5@SkillDefen

; 802  : 	{
; 803  : 		return;
; 804  : 	}
; 805  : 	// ---
; 806  : 	if(CC_MAP_RANGE(lpObj->MapNumber) && lpObj->m_Index != lpTargetObj->m_Index)

  0004a	0f b6 97 09 01
	00 00		 movzx	 edx, BYTE PTR [edi+265]
  00051	53		 push	 ebx
  00052	80 fa 12	 cmp	 dl, 18			; 00000012H
  00055	72 13		 jb	 SHORT $LN2@SkillDefen
  00057	b3 17		 mov	 bl, 23			; 00000017H
  00059	3a da		 cmp	 bl, dl
  0005b	1b d2		 sbb	 edx, edx
  0005d	42		 inc	 edx
  0005e	74 0a		 je	 SHORT $LN2@SkillDefen
  00060	8b 17		 mov	 edx, DWORD PTR [edi]
  00062	3b 16		 cmp	 edx, DWORD PTR [esi]
  00064	0f 85 91 00 00
	00		 jne	 $LN10@SkillDefen
$LN2@SkillDefen:

; 807  : 	{
; 808  : 		return;
; 809  : 	}
; 810  : 	// ---
; 811  : 	double skill_defense = 0.0;
; 812  : 	double skill_time = 0.0;
; 813  : 	// ---
; 814  : 	this->m_Lua.Generic_Call("ElfSkillDefense", "iiii>dd", lpTargetObj->Class, aIndex, aTargetIndex, (lpObj->Energy + lpObj->AddEnergy), &skill_defense, &skill_time);

  0006a	0f b7 9f ba 00
	00 00		 movzx	 ebx, WORD PTR [edi+186]
  00071	d9 ee		 fldz
  00073	8d 55 f0	 lea	 edx, DWORD PTR _skill_time$[ebp]
  00076	dd 55 f8	 fst	 QWORD PTR _skill_defense$[ebp]
  00079	52		 push	 edx
  0007a	dd 5d f0	 fstp	 QWORD PTR _skill_time$[ebp]
  0007d	8d 55 f8	 lea	 edx, DWORD PTR _skill_defense$[ebp]
  00080	52		 push	 edx
  00081	0f bf 97 e6 00
	00 00		 movsx	 edx, WORD PTR [edi+230]
  00088	03 d3		 add	 edx, ebx
  0008a	52		 push	 edx
  0008b	8b 55 0c	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  0008e	52		 push	 edx
  0008f	50		 push	 eax
  00090	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00097	50		 push	 eax
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_07KODFJLFD@iiii?$DOdd?$AA@
  0009d	83 c1 04	 add	 ecx, 4
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ONMAGIGA@ElfSkillDefense?$AA@
  000a5	51		 push	 ecx
  000a6	e8 00 00 00 00	 call	 ?Generic_Call@MULua@@QAA_NPBD0ZZ ; MULua::Generic_Call
  000ab	83 c4 24	 add	 esp, 36			; 00000024H

; 815  : 	// ---
; 816  : 	if(lpTargetObj->Class == CLASS_KNIGHT)

  000ae	66 83 be 98 00
	00 00 01	 cmp	 WORD PTR [esi+152], 1
  000b6	75 10		 jne	 SHORT $LN9@SkillDefen

; 817  : 	{
; 818  : 		skill_defense += skill_defense/10.0f;

  000b8	dd 45 f8	 fld	 QWORD PTR _skill_defense$[ebp]
  000bb	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  000c1	d8 f9		 fdivr	 ST(0), ST(1)
  000c3	de c1		 faddp	 ST(1), ST(0)
  000c5	dd 5d f8	 fstp	 QWORD PTR _skill_defense$[ebp]
$LN9@SkillDefen:

; 819  : 	}
; 820  : 	// ---
; 821  : 	lpTargetObj->m_SkillDefense			= skill_defense;

  000c8	dd 45 f8	 fld	 QWORD PTR _skill_defense$[ebp]
  000cb	e8 00 00 00 00	 call	 __ftol2_sse

; 822  : 	lpTargetObj->m_SkillDefenseTime		= skill_time;

  000d0	dd 45 f0	 fld	 QWORD PTR _skill_time$[ebp]
  000d3	89 86 78 02 00
	00		 mov	 DWORD PTR [esi+632], eax
  000d9	e8 00 00 00 00	 call	 __ftol2_sse

; 823  : 	// ---
; 824  : 	lpTargetObj->m_ViewSkillState		|= 8;
; 825  : 	// ---
; 826  : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_DEFENSE,lpTargetObj->m_Index,skillSuccess);

  000de	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000e0	83 8e c4 01 00
	00 08		 or	 DWORD PTR [esi+452], 8
  000e7	6a 01		 push	 1
  000e9	51		 push	 ecx
  000ea	6a 1b		 push	 27			; 0000001bH
  000ec	57		 push	 edi
  000ed	88 86 7c 02 00
	00		 mov	 BYTE PTR [esi+636], al
  000f3	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  000f8	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@SkillDefen:
  000fb	5b		 pop	 ebx
$LN5@SkillDefen:
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi

; 827  : }

  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c2 0c 00	 ret	 12			; 0000000cH
?SkillDefense@CObjUseSkill@@QAEXHHH@Z ENDP		; CObjUseSkill::SkillDefense
_TEXT	ENDS
PUBLIC	??_C@_0P@MAAAHDHB@ElfSkillAttack?$AA@		; `string'
PUBLIC	?SkillAttack@CObjUseSkill@@QAEXHHH@Z		; CObjUseSkill::SkillAttack
;	COMDAT ??_C@_0P@MAAAHDHB@ElfSkillAttack?$AA@
CONST	SEGMENT
??_C@_0P@MAAAHDHB@ElfSkillAttack?$AA@ DB 'ElfSkillAttack', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SkillAttack@CObjUseSkill@@QAEXHHH@Z
_TEXT	SEGMENT
_skill_time$ = -16					; size = 8
_skill_attack$ = -8					; size = 8
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_skill_level$ = 16					; size = 4
?SkillAttack@CObjUseSkill@@QAEXHHH@Z PROC		; CObjUseSkill::SkillAttack, COMDAT
; _this$ = ecx

; 830  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 831  : 	int skillSuccess = true;
; 832  : 	// ---
; 833  : 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	56		 push	 esi

; 834  : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  0000a	8b 75 0c	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]
  0000d	57		 push	 edi
  0000e	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00014	8b f8		 mov	 edi, eax
  00016	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0001c	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00022	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 835  : 	// ---
; 836  : 	if(lpTargetObj->Type != OBJ_USER && lpTargetObj->m_RecallMon == -1)

  00028	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0002d	74 0d		 je	 SHORT $LN4@SkillAttac
  0002f	83 be cc 02 00
	00 ff		 cmp	 DWORD PTR [esi+716], -1
  00036	0f 84 c0 00 00
	00		 je	 $LN5@SkillAttac
$LN4@SkillAttac:

; 837  : 	{
; 838  : 		return;
; 839  : 	}
; 840  : 	// ---
; 841  : 	if(lpObj->Class != CLASS_ELF)

  0003c	66 83 bf 98 00
	00 00 02	 cmp	 WORD PTR [edi+152], 2
  00044	0f 85 b2 00 00
	00		 jne	 $LN5@SkillAttac

; 842  : 	{
; 843  : 		return;
; 844  : 	}
; 845  : 	// ---
; 846  : 	if(CC_MAP_RANGE(lpObj->MapNumber) && lpObj->m_Index != lpTargetObj->m_Index)

  0004a	0f b6 97 09 01
	00 00		 movzx	 edx, BYTE PTR [edi+265]
  00051	53		 push	 ebx
  00052	80 fa 12	 cmp	 dl, 18			; 00000012H
  00055	72 13		 jb	 SHORT $LN2@SkillAttac
  00057	b3 17		 mov	 bl, 23			; 00000017H
  00059	3a da		 cmp	 bl, dl
  0005b	1b d2		 sbb	 edx, edx
  0005d	42		 inc	 edx
  0005e	74 0a		 je	 SHORT $LN2@SkillAttac
  00060	8b 17		 mov	 edx, DWORD PTR [edi]
  00062	3b 16		 cmp	 edx, DWORD PTR [esi]
  00064	0f 85 91 00 00
	00		 jne	 $LN10@SkillAttac
$LN2@SkillAttac:

; 847  : 	{
; 848  : 		return;
; 849  : 	}
; 850  : 	// ---
; 851  : 	double skill_attack = 0.0;
; 852  : 	double skill_time = 0.0;
; 853  : 	// ---
; 854  : 	this->m_Lua.Generic_Call("ElfSkillAttack", "iiii>dd", lpTargetObj->Class, aIndex, aTargetIndex, (lpObj->Energy + lpObj->AddEnergy), &skill_attack, &skill_time);

  0006a	0f b7 9f ba 00
	00 00		 movzx	 ebx, WORD PTR [edi+186]
  00071	d9 ee		 fldz
  00073	8d 55 f0	 lea	 edx, DWORD PTR _skill_time$[ebp]
  00076	dd 55 f8	 fst	 QWORD PTR _skill_attack$[ebp]
  00079	52		 push	 edx
  0007a	dd 5d f0	 fstp	 QWORD PTR _skill_time$[ebp]
  0007d	8d 55 f8	 lea	 edx, DWORD PTR _skill_attack$[ebp]
  00080	52		 push	 edx
  00081	0f bf 97 e6 00
	00 00		 movsx	 edx, WORD PTR [edi+230]
  00088	03 d3		 add	 edx, ebx
  0008a	52		 push	 edx
  0008b	8b 55 0c	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  0008e	52		 push	 edx
  0008f	50		 push	 eax
  00090	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00097	50		 push	 eax
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_07KODFJLFD@iiii?$DOdd?$AA@
  0009d	83 c1 04	 add	 ecx, 4
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MAAAHDHB@ElfSkillAttack?$AA@
  000a5	51		 push	 ecx
  000a6	e8 00 00 00 00	 call	 ?Generic_Call@MULua@@QAA_NPBD0ZZ ; MULua::Generic_Call
  000ab	83 c4 24	 add	 esp, 36			; 00000024H

; 855  : 	// ---
; 856  : 	if(lpTargetObj->Class == CLASS_KNIGHT)

  000ae	66 83 be 98 00
	00 00 01	 cmp	 WORD PTR [esi+152], 1
  000b6	75 10		 jne	 SHORT $LN9@SkillAttac

; 857  : 	{
; 858  : 		skill_attack += skill_attack / 10.0f;

  000b8	dd 45 f8	 fld	 QWORD PTR _skill_attack$[ebp]
  000bb	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  000c1	d8 f9		 fdivr	 ST(0), ST(1)
  000c3	de c1		 faddp	 ST(1), ST(0)
  000c5	dd 5d f8	 fstp	 QWORD PTR _skill_attack$[ebp]
$LN9@SkillAttac:

; 859  : 	}
; 860  : 	// ---
; 861  : 	lpTargetObj->m_SkillAttack		= skill_attack;

  000c8	dd 45 f8	 fld	 QWORD PTR _skill_attack$[ebp]
  000cb	e8 00 00 00 00	 call	 __ftol2_sse

; 862  : 	lpTargetObj->m_SkillAttackTime	= skill_time;

  000d0	dd 45 f0	 fld	 QWORD PTR _skill_time$[ebp]
  000d3	89 86 80 02 00
	00		 mov	 DWORD PTR [esi+640], eax
  000d9	e8 00 00 00 00	 call	 __ftol2_sse

; 863  : 	// ---
; 864  : 	lpTargetObj->m_ViewSkillState	|= 4;
; 865  : 	// ---
; 866  : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_ATTACK,lpTargetObj->m_Index,skillSuccess);

  000de	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000e0	83 8e c4 01 00
	00 04		 or	 DWORD PTR [esi+452], 4
  000e7	6a 01		 push	 1
  000e9	51		 push	 ecx
  000ea	6a 1c		 push	 28			; 0000001cH
  000ec	57		 push	 edi
  000ed	88 86 84 02 00
	00		 mov	 BYTE PTR [esi+644], al
  000f3	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  000f8	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@SkillAttac:
  000fb	5b		 pop	 ebx
$LN5@SkillAttac:
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi

; 867  : }

  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c2 0c 00	 ret	 12			; 0000000cH
?SkillAttack@CObjUseSkill@@QAEXHHH@Z ENDP		; CObjUseSkill::SkillAttack
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	?SkillChangeUse@CObjUseSkill@@QAEHH@Z		; CObjUseSkill::SkillChangeUse
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolCreate
EXTRN	?gServerInfo@@3VCServerInfo@@A:BYTE		; gServerInfo
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SkillChangeUse@CObjUseSkill@@QAEHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
?SkillChangeUse@CObjUseSkill@@QAEHH@Z PROC		; CObjUseSkill::SkillChangeUse, COMDAT
; _this$ = ecx

; 870  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 871  : 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000a	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00010	57		 push	 edi
  00011	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 872  : 
; 873  : 	int skill_level = -1;

  00017	83 cf ff	 or	 edi, -1

; 874  : 
; 875  : 	if(lpObj->Type != OBJ_USER)

  0001a	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0001f	74 0a		 je	 SHORT $LN27@SkillChang
$LN35@SkillChang:
  00021	5f		 pop	 edi

; 876  : 	{
; 877  : 		return false;

  00022	33 c0		 xor	 eax, eax
  00024	5e		 pop	 esi

; 985  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN27@SkillChang:

; 878  : 	}
; 879  : 
; 880  : 	if(lpObj->pInventory[10].IsItem()==1 && lpObj->pInventory[10].m_Type == ITEMGET(13,10))

  0002b	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00031	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
  00037	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0003c	83 f8 01	 cmp	 eax, 1
  0003f	75 2f		 jne	 SHORT $LN24@SkillChang
  00041	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00047	b8 0a 1a 00 00	 mov	 eax, 6666		; 00001a0aH
  0004c	66 39 81 96 06
	00 00		 cmp	 WORD PTR [ecx+1686], ax
  00053	75 1b		 jne	 SHORT $LN24@SkillChang

; 881  : 	{
; 882  : 		if(lpObj->pInventory[10].m_Durability < 1.0f)

  00055	d9 e8		 fld1
  00057	d8 99 b4 06 00
	00		 fcomp	 DWORD PTR [ecx+1716]
  0005d	df e0		 fnstsw	 ax
  0005f	f6 c4 41	 test	 ah, 65			; 00000041H
  00062	75 05		 jne	 SHORT $LN25@SkillChang

; 883  : 		{
; 884  : 			skill_level = -1;

  00064	83 cf ff	 or	 edi, -1

; 885  : 		}
; 886  : 		else

  00067	eb 07		 jmp	 SHORT $LN24@SkillChang
$LN25@SkillChang:

; 887  : 		{
; 888  : 			skill_level = lpObj->pInventory[10].m_Level;

  00069	0f bf b9 98 06
	00 00		 movsx	 edi, WORD PTR [ecx+1688]
$LN24@SkillChang:

; 889  : 		}
; 890  : 	}
; 891  : 
; 892  : 	if(lpObj->pInventory[11].IsItem()==1 && skill_level == -1 && lpObj->pInventory[11].m_Type == ITEMGET(13,10))

  00070	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00076	81 c1 38 07 00
	00		 add	 ecx, 1848		; 00000738H
  0007c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00081	83 f8 01	 cmp	 eax, 1
  00084	75 33		 jne	 SHORT $LN21@SkillChang
  00086	83 ff ff	 cmp	 edi, -1
  00089	75 2e		 jne	 SHORT $LN21@SkillChang
  0008b	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00091	ba 0a 1a 00 00	 mov	 edx, 6666		; 00001a0aH
  00096	66 39 91 3e 07
	00 00		 cmp	 WORD PTR [ecx+1854], dx
  0009d	75 23		 jne	 SHORT $LN20@SkillChang

; 893  : 	{
; 894  : 		if(lpObj->pInventory[11].m_Durability < 1.0f)

  0009f	d9 e8		 fld1
  000a1	d8 99 5c 07 00
	00		 fcomp	 DWORD PTR [ecx+1884]
  000a7	df e0		 fnstsw	 ax
  000a9	f6 c4 41	 test	 ah, 65			; 00000041H
  000ac	75 04		 jne	 SHORT $LN22@SkillChang

; 895  : 		{
; 896  : 			skill_level = -1;

  000ae	0b ff		 or	 edi, edi

; 897  : 		}
; 898  : 		else

  000b0	eb 10		 jmp	 SHORT $LN20@SkillChang
$LN22@SkillChang:

; 899  : 		{
; 900  : 			skill_level = lpObj->pInventory[11].m_Level;

  000b2	0f bf b9 40 07
	00 00		 movsx	 edi, WORD PTR [ecx+1856]
$LN21@SkillChang:

; 901  : 		}
; 902  : 	}
; 903  : 
; 904  : 	if(skill_level > 7)

  000b9	83 ff 07	 cmp	 edi, 7

; 905  : 	{
; 906  : 		return false;

  000bc	0f 8f 5f ff ff
	ff		 jg	 $LN35@SkillChang
$LN20@SkillChang:

; 907  : 	}
; 908  : 
; 909  : 	if(lpObj->pInventory[10].IsItem()==1 && lpObj->pInventory[10].m_Type == ITEMGET(13,39))

  000c2	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  000c8	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
  000ce	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000d3	83 f8 01	 cmp	 eax, 1
  000d6	75 2d		 jne	 SHORT $LN33@SkillChang
  000d8	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  000de	b9 27 1a 00 00	 mov	 ecx, 6695		; 00001a27H
  000e3	66 39 88 96 06
	00 00		 cmp	 WORD PTR [eax+1686], cx
  000ea	75 19		 jne	 SHORT $LN33@SkillChang

; 910  : 	{
; 911  : 		if(lpObj->pInventory[10].m_Durability < 1.0f)

  000ec	d9 e8		 fld1
  000ee	d8 98 b4 06 00
	00		 fcomp	 DWORD PTR [eax+1716]
  000f4	df e0		 fnstsw	 ax
  000f6	f6 c4 41	 test	 ah, 65			; 00000041H
  000f9	75 05		 jne	 SHORT $LN18@SkillChang

; 912  : 		{
; 913  : 			skill_level = -1;

  000fb	83 cf ff	 or	 edi, -1

; 914  : 		}
; 915  : 		else

  000fe	eb 05		 jmp	 SHORT $LN33@SkillChang
$LN18@SkillChang:

; 916  : 		{
; 917  : 			skill_level = 372;

  00100	bf 74 01 00 00	 mov	 edi, 372		; 00000174H
$LN33@SkillChang:

; 918  : 		}
; 919  : 	}
; 920  : 
; 921  : 	if(lpObj->pInventory[11].IsItem()==1 && skill_level == -1 && lpObj->pInventory[11].m_Type == ITEMGET(13,39))

  00105	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0010b	81 c1 38 07 00
	00		 add	 ecx, 1848		; 00000738H
  00111	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00116	83 f8 01	 cmp	 eax, 1
  00119	75 2f		 jne	 SHORT $LN14@SkillChang
  0011b	83 ff ff	 cmp	 edi, -1
  0011e	75 2a		 jne	 SHORT $LN14@SkillChang
  00120	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00126	ba 27 1a 00 00	 mov	 edx, 6695		; 00001a27H
  0012b	66 39 90 3e 07
	00 00		 cmp	 WORD PTR [eax+1854], dx
  00132	75 5c		 jne	 SHORT $LN30@SkillChang

; 922  : 	{
; 923  : 		if(lpObj->pInventory[11].m_Durability < 1.0f)

  00134	d9 e8		 fld1
  00136	d8 98 5c 07 00
	00		 fcomp	 DWORD PTR [eax+1884]
  0013c	df e0		 fnstsw	 ax
  0013e	f6 c4 41	 test	 ah, 65			; 00000041H

; 924  : 		{
; 925  : 			skill_level = -1;
; 926  : 		}
; 927  : 		else

  00141	74 4d		 je	 SHORT $LN30@SkillChang
$LN5@SkillChang:

; 943  : 	case 372:	change = skill_level;					break;

  00143	bf 74 01 00 00	 mov	 edi, 372		; 00000174H
  00148	eb 49		 jmp	 SHORT $LN12@SkillChang
$LN14@SkillChang:

; 928  : 		{
; 929  : 			skill_level = 372;
; 930  : 		}
; 931  : 	}
; 932  : 
; 933  : 	int change = -1;
; 934  : 
; 935  : 	switch(skill_level)

  0014a	81 ff 74 01 00
	00		 cmp	 edi, 372		; 00000174H
  00150	7f 3e		 jg	 SHORT $LN30@SkillChang
  00152	74 ef		 je	 SHORT $LN5@SkillChang
  00154	83 ff 05	 cmp	 edi, 5
  00157	77 37		 ja	 SHORT $LN30@SkillChang
  00159	ff 24 bd 00 00
	00 00		 jmp	 DWORD PTR $LN36@SkillChang[edi*4]
$LN11@SkillChang:

; 936  : 	{
; 937  : 	case 0:		change = gServerInfo.m_Data.iRings[0];		break;

  00160	8b 3d dc 00 00
	00		 mov	 edi, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+220
  00166	eb 2b		 jmp	 SHORT $LN12@SkillChang
$LN10@SkillChang:

; 938  : 	case 1:		change = gServerInfo.m_Data.iRings[1];		break;

  00168	8b 3d e0 00 00
	00		 mov	 edi, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+224
  0016e	eb 23		 jmp	 SHORT $LN12@SkillChang
$LN9@SkillChang:

; 939  : 	case 2:		change = gServerInfo.m_Data.iRings[2];		break;

  00170	8b 3d e4 00 00
	00		 mov	 edi, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+228
  00176	eb 1b		 jmp	 SHORT $LN12@SkillChang
$LN8@SkillChang:

; 940  : 	case 3:		change = gServerInfo.m_Data.iRings[3];		break;

  00178	8b 3d e8 00 00
	00		 mov	 edi, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+232
  0017e	eb 13		 jmp	 SHORT $LN12@SkillChang
$LN7@SkillChang:

; 941  : 	case 4:		change = gServerInfo.m_Data.iRings[4];		break;

  00180	8b 3d ec 00 00
	00		 mov	 edi, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+236
  00186	eb 0b		 jmp	 SHORT $LN12@SkillChang
$LN6@SkillChang:

; 942  : 	case 5:		change = gServerInfo.m_Data.iRings[5];		break;

  00188	8b 3d f0 00 00
	00		 mov	 edi, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+240
  0018e	eb 03		 jmp	 SHORT $LN12@SkillChang
$LN30@SkillChang:

; 944  : 	default:	change = -1;							break;

  00190	83 cf ff	 or	 edi, -1
$LN12@SkillChang:

; 945  : 	}
; 946  : 
; 947  : 	if(lpObj->m_Change >= 0 && lpObj->m_Change == change)

  00193	8b 86 d0 02 00
	00		 mov	 eax, DWORD PTR [esi+720]
  00199	53		 push	 ebx
  0019a	33 db		 xor	 ebx, ebx
  0019c	3b c3		 cmp	 eax, ebx
  0019e	7c 0f		 jl	 SHORT $LN3@SkillChang
  001a0	3b c7		 cmp	 eax, edi
  001a2	75 0b		 jne	 SHORT $LN3@SkillChang

; 948  : 	{
; 949  : 		return false;

  001a4	5b		 pop	 ebx
  001a5	5f		 pop	 edi
  001a6	33 c0		 xor	 eax, eax
  001a8	5e		 pop	 esi

; 985  : }

  001a9	8b e5		 mov	 esp, ebp
  001ab	5d		 pop	 ebp
  001ac	c2 04 00	 ret	 4
$LN3@SkillChang:

; 950  : 	}
; 951  : 
; 952  : 	if(lpObj->m_Change == 41 && change != 41)

  001af	83 f8 29	 cmp	 eax, 41			; 00000029H
  001b2	75 4a		 jne	 SHORT $LN2@SkillChang
  001b4	3b f8		 cmp	 edi, eax
  001b6	74 46		 je	 SHORT $LN2@SkillChang

; 953  : 	{
; 954  : 		lpObj->AddLife = 0;
; 955  : 
; 956  : 		GCReFillSend(lpObj->m_Index,lpObj->Life,0xFF,0);

  001b8	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  001be	53		 push	 ebx
  001bf	68 ff 00 00 00	 push	 255			; 000000ffH
  001c4	89 9e 0c 01 00
	00		 mov	 DWORD PTR [esi+268], ebx
  001ca	e8 00 00 00 00	 call	 __ftol2_sse
  001cf	50		 push	 eax
  001d0	8b 06		 mov	 eax, DWORD PTR [esi]
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend

; 957  : 		GCReFillSend(lpObj->m_Index,lpObj->MaxLife + lpObj->AddLife,0xFE,0);

  001d8	d9 86 c0 00 00
	00		 fld	 DWORD PTR [esi+192]
  001de	da 86 0c 01 00
	00		 fiadd	 DWORD PTR [esi+268]
  001e4	83 c4 10	 add	 esp, 16			; 00000010H
  001e7	53		 push	 ebx
  001e8	68 fe 00 00 00	 push	 254			; 000000feH
  001ed	e8 00 00 00 00	 call	 __ftol2_sse
  001f2	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001f4	50		 push	 eax
  001f5	51		 push	 ecx
  001f6	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend
  001fb	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@SkillChang:

; 958  : 	}
; 959  : 
; 960  : 	if(lpObj->m_Change == 372 && change != 372)

  001fe	81 be d0 02 00
	00 74 01 00 00	 cmp	 DWORD PTR [esi+720], 372 ; 00000174H
  00208	75 59		 jne	 SHORT $LN1@SkillChang
  0020a	81 ff 74 01 00
	00		 cmp	 edi, 372		; 00000174H
  00210	74 51		 je	 SHORT $LN1@SkillChang

; 961  : 	{
; 962  : 		lpObj->AddLife = 0;
; 963  : 		gObjCalCharacter(lpObj->m_Index);

  00212	8b 16		 mov	 edx, DWORD PTR [esi]
  00214	52		 push	 edx
  00215	89 9e 0c 01 00
	00		 mov	 DWORD PTR [esi+268], ebx
  0021b	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 964  : 
; 965  : 		GCReFillSend(lpObj->m_Index,lpObj->Life,0xFF,0);

  00220	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  00226	83 c4 04	 add	 esp, 4
  00229	53		 push	 ebx
  0022a	68 ff 00 00 00	 push	 255			; 000000ffH
  0022f	e8 00 00 00 00	 call	 __ftol2_sse
  00234	50		 push	 eax
  00235	8b 06		 mov	 eax, DWORD PTR [esi]
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend

; 966  : 		GCReFillSend(lpObj->m_Index,lpObj->MaxLife + lpObj->AddLife,0xFE,0);

  0023d	d9 86 c0 00 00
	00		 fld	 DWORD PTR [esi+192]
  00243	da 86 0c 01 00
	00		 fiadd	 DWORD PTR [esi+268]
  00249	83 c4 10	 add	 esp, 16			; 00000010H
  0024c	53		 push	 ebx
  0024d	68 fe 00 00 00	 push	 254			; 000000feH
  00252	e8 00 00 00 00	 call	 __ftol2_sse
  00257	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00259	50		 push	 eax
  0025a	51		 push	 ecx
  0025b	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend
  00260	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@SkillChang:

; 967  : 	}
; 968  : 
; 969  : 	lpObj->m_Change = change;
; 970  : 	gObjViewportListProtocolCreate(lpObj);

  00263	56		 push	 esi
  00264	89 be d0 02 00
	00		 mov	 DWORD PTR [esi+720], edi
  0026a	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate

; 971  : 
; 972  : #if GS_CASTLE == 1
; 973  : 	g_CastleSiege.NotifySelfCsJoinSide(lpObj->m_Index);
; 974  : #endif
; 975  : 
; 976  : 	PMSG_KILLCOUNT pMsg = {0};
; 977  : 
; 978  : 	PHeadSubSetB((LPBYTE)&pMsg,0xB8,0x01,sizeof(pMsg));

  0026f	6a 05		 push	 5
  00271	6a 01		 push	 1
  00273	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00276	68 b8 00 00 00	 push	 184			; 000000b8H
  0027b	52		 push	 edx
  0027c	88 5d f8	 mov	 BYTE PTR _pMsg$[ebp], bl
  0027f	89 5d f9	 mov	 DWORD PTR _pMsg$[ebp+1], ebx
  00282	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 979  : 
; 980  : 	pMsg.btKillCount = lpObj->m_btKillCount;
; 981  : 
; 982  : 	DataSend(aIndex,(PBYTE)&pMsg,sizeof(pMsg));

  00287	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0028a	8a 86 d8 14 00
	00		 mov	 al, BYTE PTR [esi+5336]
  00290	6a 05		 push	 5
  00292	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00295	51		 push	 ecx
  00296	52		 push	 edx
  00297	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al
  0029a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0029f	83 c4 20	 add	 esp, 32			; 00000020H
  002a2	5b		 pop	 ebx
  002a3	5f		 pop	 edi

; 983  : 
; 984  : 	return true;

  002a4	b8 01 00 00 00	 mov	 eax, 1
  002a9	5e		 pop	 esi

; 985  : }

  002aa	8b e5		 mov	 esp, ebp
  002ac	5d		 pop	 ebp
  002ad	c2 04 00	 ret	 4
$LN36@SkillChang:
  002b0	00 00 00 00	 DD	 $LN11@SkillChang
  002b4	00 00 00 00	 DD	 $LN10@SkillChang
  002b8	00 00 00 00	 DD	 $LN9@SkillChang
  002bc	00 00 00 00	 DD	 $LN8@SkillChang
  002c0	00 00 00 00	 DD	 $LN7@SkillChang
  002c4	00 00 00 00	 DD	 $LN6@SkillChang
?SkillChangeUse@CObjUseSkill@@QAEHH@Z ENDP		; CObjUseSkill::SkillChangeUse
_TEXT	ENDS
PUBLIC	??_C@_0BA@BBGFEFPO@ElfSkillHealing?$AA@		; `string'
PUBLIC	??_C@_06BLIAMCOE@iiii?$DOi?$AA@			; `string'
PUBLIC	?SkillHealing@CObjUseSkill@@QAEXHHH@Z		; CObjUseSkill::SkillHealing
EXTRN	?GCRecallMonLife@@YAXHHH@Z:PROC			; GCRecallMonLife
;	COMDAT ??_C@_0BA@BBGFEFPO@ElfSkillHealing?$AA@
CONST	SEGMENT
??_C@_0BA@BBGFEFPO@ElfSkillHealing?$AA@ DB 'ElfSkillHealing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BLIAMCOE@iiii?$DOi?$AA@
CONST	SEGMENT
??_C@_06BLIAMCOE@iiii?$DOi?$AA@ DB 'iiii>i', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SkillHealing@CObjUseSkill@@QAEXHHH@Z
_TEXT	SEGMENT
_addlife$ = 8						; size = 4
_aIndex$ = 8						; size = 4
tv272 = 12						; size = 4
_aTargetIndex$ = 12					; size = 4
_skill_level$ = 16					; size = 4
?SkillHealing@CObjUseSkill@@QAEXHHH@Z PROC		; CObjUseSkill::SkillHealing, COMDAT
; _this$ = ecx

; 988  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 989  : 	int skillSuccess = true;
; 990  : 	// ---
; 991  : 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00006	56		 push	 esi

; 992  : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  00007	8b 75 0c	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]
  0000a	57		 push	 edi
  0000b	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00011	8b fa		 mov	 edi, edx
  00013	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00019	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001f	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 993  : 	// ---
; 994  : 	if(lpTargetObj->Type != OBJ_USER && lpTargetObj->m_RecallMon == -1)

  00025	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0002a	74 0d		 je	 SHORT $LN7@SkillHeali
  0002c	83 be cc 02 00
	00 ff		 cmp	 DWORD PTR [esi+716], -1
  00033	0f 84 f7 00 00
	00		 je	 $LN1@SkillHeali
$LN7@SkillHeali:

; 995  : 	{
; 996  : 		return;
; 997  : 	}
; 998  : 	// ---
; 999  : 	if(lpObj->Class != CLASS_ELF)

  00039	66 83 bf 98 00
	00 00 02	 cmp	 WORD PTR [edi+152], 2
  00041	0f 85 e9 00 00
	00		 jne	 $LN1@SkillHeali

; 1000 : 	{
; 1001 : 		return;
; 1002 : 	}
; 1003 : 	// ---
; 1004 : 	if(CC_MAP_RANGE(lpObj->MapNumber) && lpObj->m_Index != lpTargetObj->m_Index)

  00047	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR [edi+265]
  0004e	53		 push	 ebx
  0004f	3c 12		 cmp	 al, 18			; 00000012H
  00051	72 13		 jb	 SHORT $LN12@SkillHeali
  00053	b3 17		 mov	 bl, 23			; 00000017H
  00055	3a d8		 cmp	 bl, al
  00057	1b c0		 sbb	 eax, eax
  00059	40		 inc	 eax
  0005a	74 0a		 je	 SHORT $LN12@SkillHeali
  0005c	8b 07		 mov	 eax, DWORD PTR [edi]
  0005e	3b 06		 cmp	 eax, DWORD PTR [esi]
  00060	0f 85 c9 00 00
	00		 jne	 $LN14@SkillHeali
$LN12@SkillHeali:

; 1005 : 	{
; 1006 : 		return;
; 1007 : 	}
; 1008 : 	// ---
; 1009 : 	int addlife = 0;
; 1010 : 	// ---
; 1011 : 	this->m_Lua.Generic_Call("ElfSkillHealing", "iiii>i", lpTargetObj->Class, lpObj->Energy + lpObj->AddEnergy, aIndex, aTargetIndex, &addlife);

  00066	8d 45 08	 lea	 eax, DWORD PTR _addlife$[ebp]
  00069	50		 push	 eax
  0006a	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0006d	50		 push	 eax
  0006e	0f b7 87 ba 00
	00 00		 movzx	 eax, WORD PTR [edi+186]
  00075	52		 push	 edx
  00076	0f bf 97 e6 00
	00 00		 movsx	 edx, WORD PTR [edi+230]
  0007d	03 d0		 add	 edx, eax
  0007f	52		 push	 edx
  00080	0f b7 96 98 00
	00 00		 movzx	 edx, WORD PTR [esi+152]
  00087	52		 push	 edx
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_06BLIAMCOE@iiii?$DOi?$AA@
  0008d	83 c1 04	 add	 ecx, 4
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BBGFEFPO@ElfSkillHealing?$AA@
  00095	51		 push	 ecx
  00096	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _addlife$[ebp], 0
  0009d	e8 00 00 00 00	 call	 ?Generic_Call@MULua@@QAA_NPBD0ZZ ; MULua::Generic_Call

; 1012 : 	// ---
; 1013 : 	lpTargetObj->Life += addlife;

  000a2	8d 8e bc 00 00
	00		 lea	 ecx, DWORD PTR [esi+188]
  000a8	db 45 08	 fild	 DWORD PTR _addlife$[ebp]

; 1014 : 	// ---
; 1015 : 	if((lpTargetObj->MaxLife + lpTargetObj->AddLife) < lpTargetObj->Life)

  000ab	8d 9e c0 00 00
	00		 lea	 ebx, DWORD PTR [esi+192]
  000b1	83 c4 20	 add	 esp, 32			; 00000020H
  000b4	d8 01		 fadd	 DWORD PTR [ecx]
  000b6	d9 5d 0c	 fstp	 DWORD PTR tv272[ebp]
  000b9	d9 45 0c	 fld	 DWORD PTR tv272[ebp]
  000bc	d9 11		 fst	 DWORD PTR [ecx]
  000be	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  000c4	d8 03		 fadd	 DWORD PTR [ebx]
  000c6	d8 d1		 fcom	 ST(1)
  000c8	df e0		 fnstsw	 ax
  000ca	dd d9		 fstp	 ST(1)
  000cc	f6 c4 05	 test	 ah, 5
  000cf	7a 04		 jp	 SHORT $LN16@SkillHeali

; 1016 : 	{
; 1017 : 		lpTargetObj->Life = lpTargetObj->MaxLife + lpTargetObj->AddLife;

  000d1	d9 19		 fstp	 DWORD PTR [ecx]
  000d3	eb 02		 jmp	 SHORT $LN4@SkillHeali
$LN16@SkillHeali:
  000d5	dd d8		 fstp	 ST(0)
$LN4@SkillHeali:

; 1018 : 	}
; 1019 : 	// ---
; 1020 : 	if(lpTargetObj->Type == OBJ_USER)

  000d7	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  000dc	75 2e		 jne	 SHORT $LN3@SkillHeali

; 1021 : 	{
; 1022 : 		GCReFillSend(lpTargetObj->m_Index,lpTargetObj->Life,0xFF,0);

  000de	d9 01		 fld	 DWORD PTR [ecx]
  000e0	6a 00		 push	 0
  000e2	68 ff 00 00 00	 push	 255			; 000000ffH
  000e7	e8 00 00 00 00	 call	 __ftol2_sse
  000ec	50		 push	 eax
  000ed	8b 06		 mov	 eax, DWORD PTR [esi]
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend

; 1023 : 		GCMagicAttackNumberSend(lpObj,AT_SKILL_HEALING,lpTargetObj->m_Index,skillSuccess);

  000f5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f7	6a 01		 push	 1
  000f9	51		 push	 ecx
  000fa	6a 1a		 push	 26			; 0000001aH
  000fc	57		 push	 edi
  000fd	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  00102	83 c4 20	 add	 esp, 32			; 00000020H
  00105	5b		 pop	 ebx
  00106	5f		 pop	 edi
  00107	5e		 pop	 esi

; 1028 : 	}
; 1029 : }

  00108	5d		 pop	 ebp
  00109	c2 0c 00	 ret	 12			; 0000000cH
$LN3@SkillHeali:

; 1024 : 	}
; 1025 : 	else if(lpTargetObj->m_RecallMon >= 0)

  0010c	8b b6 cc 02 00
	00		 mov	 esi, DWORD PTR [esi+716]
  00112	85 f6		 test	 esi, esi
  00114	78 19		 js	 SHORT $LN14@SkillHeali

; 1026 : 	{
; 1027 : 		GCRecallMonLife(lpTargetObj->m_RecallMon,lpTargetObj->MaxLife,lpTargetObj->Life);

  00116	d9 01		 fld	 DWORD PTR [ecx]
  00118	e8 00 00 00 00	 call	 __ftol2_sse
  0011d	d9 03		 fld	 DWORD PTR [ebx]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 __ftol2_sse
  00125	50		 push	 eax
  00126	56		 push	 esi
  00127	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife
  0012c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@SkillHeali:
  0012f	5b		 pop	 ebx
$LN1@SkillHeali:
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi

; 1028 : 	}
; 1029 : }

  00132	5d		 pop	 ebp
  00133	c2 0c 00	 ret	 12			; 0000000cH
?SkillHealing@CObjUseSkill@@QAEXHHH@Z ENDP		; CObjUseSkill::SkillHealing
_TEXT	ENDS
PUBLIC	?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z	; CObjUseSkill::SkillMonsterCall
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjAddCallMon@@YAFXZ:PROC			; gObjAddCallMon
EXTRN	?gObjMonsterCallKill@@YAXH@Z:PROC		; gObjMonsterCallKill
; Function compile flags: /Ogtp
;	COMDAT ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_MonsterType$ = 12					; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z PROC		; CObjUseSkill::SkillMonsterCall, COMDAT
; _this$ = ecx

; 1032 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1033 : 	if(gObj[aIndex].MapNumber == MAP_INDEX_ICARUS)

  00005	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00008	8b de		 mov	 ebx, esi
  0000a	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  00010	8a 83 09 01 00
	00		 mov	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+265]
  00016	3c 0a		 cmp	 al, 10			; 0000000aH

; 1034 : 	{
; 1035 : 		return false;

  00018	74 29		 je	 SHORT $LN11@SkillMonst

; 1036 : 	}
; 1037 : 
; 1038 : 	if(CC_MAP_RANGE(gObj[aIndex].MapNumber))

  0001a	3c 12		 cmp	 al, 18			; 00000012H
  0001c	72 09		 jb	 SHORT $LN9@SkillMonst
  0001e	b1 17		 mov	 cl, 23			; 00000017H
  00020	3a c8		 cmp	 cl, al
  00022	1b c0		 sbb	 eax, eax
  00024	40		 inc	 eax

; 1039 : 	{
; 1040 : 		return false;

  00025	75 1c		 jne	 SHORT $LN11@SkillMonst
$LN9@SkillMonst:

; 1041 : 	}
; 1042 : 
; 1043 : 	if(gObj[aIndex].m_RecallMon >= 0)

  00027	83 bb cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+716], 0
  0002e	7c 1b		 jl	 SHORT $LN2@SkillMonst

; 1044 : 	{
; 1045 : 		GCRecallMonLife(aIndex,60,0);

  00030	6a 00		 push	 0
  00032	6a 3c		 push	 60			; 0000003cH
  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife

; 1046 : 		gObjMonsterCallKill(aIndex);

  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  00040	83 c4 10	 add	 esp, 16			; 00000010H
$LN11@SkillMonst:

; 1047 : 		return false;

  00043	5e		 pop	 esi
  00044	33 c0		 xor	 eax, eax
  00046	5b		 pop	 ebx

; 1076 : }

  00047	5d		 pop	 ebp
  00048	c2 10 00	 ret	 16			; 00000010H
$LN2@SkillMonst:
  0004b	57		 push	 edi

; 1048 : 	}
; 1049 : 
; 1050 : 	int result = gObjAddCallMon();

  0004c	e8 00 00 00 00	 call	 ?gObjAddCallMon@@YAFXZ	; gObjAddCallMon
  00051	0f bf f8	 movsx	 edi, ax

; 1051 : 
; 1052 : 	if(result >= 0)

  00054	85 ff		 test	 edi, edi
  00056	0f 88 c9 00 00
	00		 js	 $LN1@SkillMonst

; 1053 : 	{
; 1054 : 		gObj[result].X = x;

  0005c	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]

; 1055 : 		gObj[result].Y = y;

  0005f	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  00062	8b f7		 mov	 esi, edi
  00064	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0006a	66 89 86 04 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260], ax

; 1056 : 		gObj[result].MTX = x;

  00071	66 89 86 24 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+292], ax

; 1057 : 		gObj[result].MTY = y;
; 1058 : 		gObj[result].Dir = 2;
; 1059 : 		gObj[result].MapNumber = gObj[aIndex].MapNumber;
; 1060 : 		gObjSetMonster(result,MonsterType);

  00078	8b 45 0c	 mov	 eax, DWORD PTR _MonsterType$[ebp]
  0007b	66 89 8e 06 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262], cx
  00082	66 89 8e 26 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+294], cx
  00089	c6 86 08 01 00
	00 02		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+264], 2
  00090	8a 93 09 01 00
	00		 mov	 dl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+265]
  00096	50		 push	 eax
  00097	57		 push	 edi
  00098	88 96 09 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265], dl
  0009e	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1061 : 		gObj[result].m_RecallMon = aIndex;

  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]

; 1062 : 		gObj[result].m_Attribute = 100;
; 1063 : 		gObj[result].TargetNumber = (WORD)-1;
; 1064 : 		gObj[result].m_ActState.Emotion = 0;
; 1065 : 		gObj[result].m_ActState.Attack = 0;

  000a6	81 a6 b4 01 00
	00 0d ff ff ff	 and	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+436], -243 ; ffffff0dH
  000b0	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  000b5	83 c8 ff	 or	 eax, -1
  000b8	89 8e cc 02 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+716], ecx
  000be	66 89 96 26 03
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+806], dx
  000c5	66 89 86 d4 02
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+724], ax

; 1066 : 		gObj[result].m_ActState.EmotionCount = 0;

  000cc	c6 86 b5 01 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+437], 0

; 1067 : 		gObj[result].PathCount = 0;

  000d3	c7 86 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+296], 0

; 1068 : 
; 1069 : 		gObj[aIndex].m_RecallMon = result;

  000dd	89 bb cc 02 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+716], edi

; 1070 : 		gObj[result].m_MoveRange = 15;
; 1071 : 
; 1072 : 		GCRecallMonLife(gObj[result].m_RecallMon,gObj[result].MaxLife,gObj[result].Life);

  000e3	d9 86 bc 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+188]
  000e9	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  000ee	83 c4 08	 add	 esp, 8
  000f1	66 89 8e 1e 03
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+798], cx
  000f8	e8 00 00 00 00	 call	 __ftol2_sse
  000fd	d9 86 c0 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 __ftol2_sse
  00109	8b 96 cc 02 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+716]
  0010f	50		 push	 eax
  00110	52		 push	 edx
  00111	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi

; 1073 : 		return true;

  0011b	b8 01 00 00 00	 mov	 eax, 1
  00120	5b		 pop	 ebx

; 1076 : }

  00121	5d		 pop	 ebp
  00122	c2 10 00	 ret	 16			; 00000010H
$LN1@SkillMonst:
  00125	5f		 pop	 edi
  00126	5e		 pop	 esi

; 1074 : 	}
; 1075 : 	return false;

  00127	33 c0		 xor	 eax, eax
  00129	5b		 pop	 ebx

; 1076 : }

  0012a	5d		 pop	 ebp
  0012b	c2 10 00	 ret	 16			; 00000010H
?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ENDP		; CObjUseSkill::SkillMonsterCall
_TEXT	ENDS
PUBLIC	?SkillBlowOfFury@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEHH@Z ; CObjUseSkill::SkillBlowOfFury
EXTRN	?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z:PROC ; gObjAddAttackProcMsgSendDelay
EXTRN	?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z:PROC ; gObjTargetGuildWarCheck
; Function compile flags: /Ogtp
;	COMDAT ?SkillBlowOfFury@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEHH@Z
_TEXT	SEGMENT
_DuelIndex$ = -12					; size = 4
tv373 = -8						; size = 4
tv336 = -4						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_dir$ = 24						; size = 1
_TargetPos$ = 28					; size = 1
_aTargetIndex$ = 32					; size = 4
_isCombo$ = 36						; size = 4
?SkillBlowOfFury@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEHH@Z PROC ; CObjUseSkill::SkillBlowOfFury, COMDAT
; _this$ = ecx

; 1079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1080 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 5d 24	 mov	 ebx, DWORD PTR _isCombo$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000e	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00014	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1081 : 	int tObjNum;
; 1082 : 	int count = 0;
; 1083 : 	int DuelIndex = lpObj->m_iDuelUser;

  0001a	8b 86 1c 0d 00
	00		 mov	 eax, DWORD PTR [esi+3356]
  00020	89 45 f4	 mov	 DWORD PTR _DuelIndex$[ebp], eax
  00023	8d 86 16 07 00
	00		 lea	 eax, DWORD PTR [esi+1814]
  00029	57		 push	 edi
  0002a	89 45 fc	 mov	 DWORD PTR tv336[ebp], eax
  0002d	c7 45 f8 4b 00
	00 00		 mov	 DWORD PTR tv373[ebp], 75 ; 0000004bH
$LL20@SkillBlowO:

; 1084 : 	int HitCount = 0;
; 1085 : 	int bAttack = 0;
; 1086 : 	int EnableAttack;
; 1087 : 
; 1088 : 	while ( true )
; 1089 : 	{
; 1090 : 		if(lpObj->VpPlayer2[count].state != 0)

  00034	80 78 fe 00	 cmp	 BYTE PTR [eax-2], 0
  00038	0f 84 c1 00 00
	00		 je	 $LN28@SkillBlowO

; 1091 : 		{
; 1092 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0003e	0f bf 38	 movsx	 edi, WORD PTR [eax]

; 1093 : 
; 1094 : 			if(tObjNum >= 0)

  00041	85 ff		 test	 edi, edi
  00043	0f 88 b6 00 00
	00		 js	 $LN28@SkillBlowO

; 1095 : 			{
; 1096 : 				EnableAttack = 0;
; 1097 : 
; 1098 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00049	80 78 02 02	 cmp	 BYTE PTR [eax+2], 2
  0004d	75 11		 jne	 SHORT $LN16@SkillBlowO
  0004f	8b cf		 mov	 ecx, edi
  00051	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00057	83 b9 cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+716], 0

; 1099 : 				{
; 1100 : 					EnableAttack = 1;

  0005e	7c 53		 jl	 SHORT $LN13@SkillBlowO
$LN16@SkillBlowO:

; 1101 : 				}
; 1102 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  00060	3b 7d 20	 cmp	 edi, DWORD PTR _aTargetIndex$[ebp]
  00063	74 4e		 je	 SHORT $LN13@SkillBlowO
  00065	39 7d f4	 cmp	 DWORD PTR _DuelIndex$[ebp], edi
  00068	74 49		 je	 SHORT $LN13@SkillBlowO

; 1103 : 				{
; 1104 : 					EnableAttack = 1;
; 1105 : 				}
; 1106 : #if GS_CASTLE == 1
; 1107 : 				else if (lpObj->VpPlayer2[count].type != OBJ_NPC &&
; 1108 : 						gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE &&
; 1109 : 						g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 1110 : 				{
; 1111 : 					EnableAttack = 1;
; 1112 : 				}
; 1113 : #endif
; 1114 : 				else
; 1115 : 				{
; 1116 : 
; 1117 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  0006a	8b c7		 mov	 eax, edi
  0006c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 1118 : 
; 1119 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  00072	66 83 b8 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 2
  0007a	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  00080	75 16		 jne	 SHORT $LN11@SkillBlowO
  00082	8b 80 cc 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716]
  00088	85 c0		 test	 eax, eax
  0008a	78 0c		 js	 SHORT $LN11@SkillBlowO

; 1120 : 					{
; 1121 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  0008c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00092	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
$LN11@SkillBlowO:

; 1122 : 					}
; 1123 : 
; 1124 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00098	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0009e	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a4	51		 push	 ecx
  000a5	56		 push	 esi
  000a6	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000ab	83 c4 08	 add	 esp, 8
  000ae	83 f8 01	 cmp	 eax, 1
  000b1	75 4c		 jne	 SHORT $LN28@SkillBlowO
$LN13@SkillBlowO:

; 1125 : 					{
; 1126 : 						EnableAttack = 1;
; 1127 : 					}
; 1128 : 				}
; 1129 : 
; 1130 : 				if(EnableAttack != 0)
; 1131 : 				{
; 1132 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 4)

  000b3	8b d7		 mov	 edx, edi
  000b5	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  000bb	81 c2 00 00 00
	00		 add	 edx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c1	52		 push	 edx
  000c2	56		 push	 esi
  000c3	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000c8	83 c4 08	 add	 esp, 8
  000cb	83 f8 04	 cmp	 eax, 4
  000ce	7d 2f		 jge	 SHORT $LN28@SkillBlowO

; 1133 : 					{
; 1134 : 						bAttack = 0;
; 1135 : 
; 1136 : 						if(HitCount > 15)
; 1137 : 						{
; 1138 : 							bAttack = 0;
; 1139 : 						}
; 1140 : 
; 1141 : 						if(HitCount >= 10)
; 1142 : 						{
; 1143 : 							if(rand()%2)
; 1144 : 							{
; 1145 : 								bAttack = 1;
; 1146 : 							}
; 1147 : 						}
; 1148 : 						else
; 1149 : 						{
; 1150 : 							bAttack = 1;
; 1151 : 						}
; 1152 : 
; 1153 : 						if(bAttack != 0)
; 1154 : 						{
; 1155 : 							gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,500,lpMagic->m_Skill,isCombo);

  000d0	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000d3	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  000d7	53		 push	 ebx
  000d8	51		 push	 ecx
  000d9	68 f4 01 00 00	 push	 500			; 000001f4H
  000de	57		 push	 edi
  000df	6a 32		 push	 50			; 00000032H
  000e1	56		 push	 esi
  000e2	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  000e7	83 c4 18	 add	 esp, 24			; 00000018H

; 1156 : 
; 1157 : 							if(isCombo != 0)

  000ea	85 db		 test	 ebx, ebx
  000ec	74 11		 je	 SHORT $LN28@SkillBlowO

; 1158 : 							{
; 1159 : 								GCMagicAttackNumberSend(lpObj,AT_SKILL_COMBO,aIndex,1);

  000ee	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000f1	6a 01		 push	 1
  000f3	52		 push	 edx
  000f4	6a 3b		 push	 59			; 0000003bH
  000f6	56		 push	 esi
  000f7	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  000fc	83 c4 10	 add	 esp, 16			; 00000010H
$LN28@SkillBlowO:

; 1160 : 							}
; 1161 : 						}
; 1162 : 					}
; 1163 : 				}
; 1164 : 			}
; 1165 : 		}
; 1166 : 
; 1167 : 		count++;

  000ff	8b 45 fc	 mov	 eax, DWORD PTR tv336[ebp]
  00102	83 c0 0c	 add	 eax, 12			; 0000000cH

; 1168 : 		if(count > MAX_VIEWPORT -1)

  00105	ff 4d f8	 dec	 DWORD PTR tv373[ebp]
  00108	89 45 fc	 mov	 DWORD PTR tv336[ebp], eax
  0010b	0f 85 23 ff ff
	ff		 jne	 $LL20@SkillBlowO
  00111	5f		 pop	 edi
  00112	5e		 pop	 esi
  00113	5b		 pop	 ebx

; 1169 : 		{
; 1170 : 			break;
; 1171 : 		}
; 1172 : 	}
; 1173 : }

  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c2 20 00	 ret	 32			; 00000020H
?SkillBlowOfFury@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEHH@Z ENDP ; CObjUseSkill::SkillBlowOfFury
_TEXT	ENDS
PUBLIC	?SkillWheel@CObjUseSkill@@QAEXHPAVCMagicInf@@HH@Z ; CObjUseSkill::SkillWheel
EXTRN	?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z:PROC ; gObjAttack
; Function compile flags: /Ogtp
;	COMDAT ?SkillWheel@CObjUseSkill@@QAEXHPAVCMagicInf@@HH@Z
_TEXT	SEGMENT
_DuelIndex$ = -4					; size = 4
tv374 = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_aTargetIndex$ = 16					; size = 4
_isCombo$ = 20						; size = 4
?SkillWheel@CObjUseSkill@@QAEXHPAVCMagicInf@@HH@Z PROC	; CObjUseSkill::SkillWheel, COMDAT
; _this$ = ecx

; 1176 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 1177 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000a	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00010	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1178 : 	int tObjNum;
; 1179 : 	int count = 0;
; 1180 : 	int HitCount = 0;
; 1181 : 	int bAttack;
; 1182 : 	int DuelIndex = lpObj->m_iDuelUser;

  00016	8b 87 1c 0d 00
	00		 mov	 eax, DWORD PTR [edi+3356]
  0001c	89 45 fc	 mov	 DWORD PTR _DuelIndex$[ebp], eax
  0001f	8d 9f 16 07 00
	00		 lea	 ebx, DWORD PTR [edi+1814]
  00025	c7 45 08 4b 00
	00 00		 mov	 DWORD PTR tv374[ebp], 75 ; 0000004bH
  0002c	8d 64 24 00	 npad	 4
$LL20@SkillWheel:

; 1183 : 	int EnableAttack;
; 1184 : 
; 1185 : 	while ( true )
; 1186 : 	{
; 1187 : 		if(lpObj->VpPlayer2[count].state != 0)

  00030	80 7b fe 00	 cmp	 BYTE PTR [ebx-2], 0
  00034	0f 84 be 00 00
	00		 je	 $LN28@SkillWheel

; 1188 : 		{
; 1189 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0003a	0f bf 33	 movsx	 esi, WORD PTR [ebx]

; 1190 : 
; 1191 : 			if(tObjNum >= 0)

  0003d	85 f6		 test	 esi, esi
  0003f	0f 88 b3 00 00
	00		 js	 $LN28@SkillWheel

; 1192 : 			{
; 1193 : 				EnableAttack = 0;
; 1194 : 
; 1195 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00045	80 7b 02 02	 cmp	 BYTE PTR [ebx+2], 2
  00049	75 11		 jne	 SHORT $LN16@SkillWheel
  0004b	8b ce		 mov	 ecx, esi
  0004d	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00053	83 b9 cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+716], 0

; 1196 : 				{
; 1197 : 					EnableAttack = 1;

  0005a	7c 53		 jl	 SHORT $LN13@SkillWheel
$LN16@SkillWheel:

; 1198 : 				}
; 1199 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  0005c	3b 75 10	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  0005f	74 4e		 je	 SHORT $LN13@SkillWheel
  00061	39 75 fc	 cmp	 DWORD PTR _DuelIndex$[ebp], esi
  00064	74 49		 je	 SHORT $LN13@SkillWheel

; 1200 : 				{
; 1201 : 					EnableAttack = 1;
; 1202 : 				}
; 1203 : #if GS_CASTLE == 1
; 1204 : 				else if (lpObj->VpPlayer2[count].type != OBJ_NPC &&
; 1205 : 						gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE &&
; 1206 : 						g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 1207 : 				{
; 1208 : 					EnableAttack = 1;
; 1209 : 				}
; 1210 : #endif
; 1211 : 				else
; 1212 : 				{
; 1213 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  00066	8b c6		 mov	 eax, esi
  00068	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 1214 : 
; 1215 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  0006e	66 83 b8 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 2
  00076	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  0007c	75 16		 jne	 SHORT $LN11@SkillWheel
  0007e	8b 80 cc 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716]
  00084	85 c0		 test	 eax, eax
  00086	78 0c		 js	 SHORT $LN11@SkillWheel

; 1216 : 					{
; 1217 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00088	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0008e	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
$LN11@SkillWheel:

; 1218 : 					}
; 1219 : 
; 1220 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00094	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0009a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a0	51		 push	 ecx
  000a1	57		 push	 edi
  000a2	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000a7	83 c4 08	 add	 esp, 8
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	75 49		 jne	 SHORT $LN28@SkillWheel
$LN13@SkillWheel:

; 1221 : 					{
; 1222 : 						EnableAttack = 1;
; 1223 : 					}
; 1224 : 				}
; 1225 : 
; 1226 : 				if(EnableAttack != 0)
; 1227 : 				{
; 1228 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 3)

  000af	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000b5	8d b6 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000bb	56		 push	 esi
  000bc	57		 push	 edi
  000bd	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 03	 cmp	 eax, 3
  000c8	7d 2e		 jge	 SHORT $LN28@SkillWheel

; 1229 : 					{
; 1230 : 						bAttack = 0;
; 1231 : 
; 1232 : 						if(HitCount > 15)
; 1233 : 						{
; 1234 : 							bAttack = 0;
; 1235 : 						}
; 1236 : 
; 1237 : 						if(HitCount >= 10)
; 1238 : 						{
; 1239 : 							if(rand()%2)
; 1240 : 							{
; 1241 : 								bAttack = 1;
; 1242 : 							}
; 1243 : 						}
; 1244 : 						else
; 1245 : 						{
; 1246 : 							bAttack = 1;
; 1247 : 						}
; 1248 : 
; 1249 : 						if(bAttack != 0)
; 1250 : 						{
; 1251 : 
; 1252 : 							gObjAttack(lpObj,&gObj[tObjNum],lpMagic,0,1,0,isCombo);

  000ca	8b 55 14	 mov	 edx, DWORD PTR _isCombo$[ebp]
  000cd	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000d0	52		 push	 edx
  000d1	6a 00		 push	 0
  000d3	6a 01		 push	 1
  000d5	6a 00		 push	 0
  000d7	50		 push	 eax
  000d8	56		 push	 esi
  000d9	57		 push	 edi
  000da	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  000df	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1253 : 
; 1254 : 							if(isCombo != 0)

  000e2	83 7d 14 00	 cmp	 DWORD PTR _isCombo$[ebp], 0
  000e6	74 10		 je	 SHORT $LN28@SkillWheel

; 1255 : 							{
; 1256 : 								GCMagicAttackNumberSend(lpObj,AT_SKILL_COMBO,gObj[tObjNum].m_Index,1);

  000e8	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000ea	6a 01		 push	 1
  000ec	51		 push	 ecx
  000ed	6a 3b		 push	 59			; 0000003bH
  000ef	57		 push	 edi
  000f0	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  000f5	83 c4 10	 add	 esp, 16			; 00000010H
$LN28@SkillWheel:

; 1257 : 							}
; 1258 : 						}
; 1259 : 					}
; 1260 : 				}
; 1261 : 			}
; 1262 : 		}
; 1263 : 
; 1264 : 		count++;

  000f8	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1265 : 		if(count > MAX_VIEWPORT -1)

  000fb	ff 4d 08	 dec	 DWORD PTR tv374[ebp]
  000fe	0f 85 2c ff ff
	ff		 jne	 $LL20@SkillWheel
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx

; 1266 : 		{
; 1267 : 			break;
; 1268 : 		}
; 1269 : 	}
; 1270 : }

  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c2 10 00	 ret	 16			; 00000010H
?SkillWheel@CObjUseSkill@@QAEXHPAVCMagicInf@@HH@Z ENDP	; CObjUseSkill::SkillWheel
_TEXT	ENDS
PUBLIC	?SkillPowerSlash@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillPowerSlash
EXTRN	_rand:PROC
EXTRN	?SkillTestFrustrum@@YAHHHH@Z:PROC		; SkillTestFrustrum
EXTRN	?SkillFrustrum@@YAXEH@Z:PROC			; SkillFrustrum
; Function compile flags: /Ogtp
;	COMDAT ?SkillPowerSlash@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z
_TEXT	SEGMENT
_DuelIndex$ = -8					; size = 4
tv311 = -4						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_dir$ = 24						; size = 1
_targetangle$ = 28					; size = 1
_HitCount$ = 28						; size = 4
_aTargetIndex$ = 32					; size = 4
?SkillPowerSlash@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z PROC ; CObjUseSkill::SkillPowerSlash, COMDAT
; _this$ = ecx

; 1273 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1274 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f8		 mov	 edi, eax
  0000e	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H

; 1275 : 	int StartDis = 1;
; 1276 : 	int tObjNum;
; 1277 : 	::SkillFrustrum(targetangle,aIndex);

  00014	50		 push	 eax
  00015	8b 45 1c	 mov	 eax, DWORD PTR _targetangle$[ebp]
  00018	50		 push	 eax
  00019	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001f	e8 00 00 00 00	 call	 ?SkillFrustrum@@YAXEH@Z	; SkillFrustrum

; 1278 : 	int count = 0;
; 1279 : 	int HitCount = 0;
; 1280 : 	int bAttack;
; 1281 : 	int DuelIndex = lpObj->m_iDuelUser;

  00024	8b 8f 1c 0d 00
	00		 mov	 ecx, DWORD PTR [edi+3356]
  0002a	83 c4 08	 add	 esp, 8
  0002d	c7 45 1c 00 00
	00 00		 mov	 DWORD PTR _HitCount$[ebp], 0
  00034	89 4d f8	 mov	 DWORD PTR _DuelIndex$[ebp], ecx
  00037	8d 9f 16 07 00
	00		 lea	 ebx, DWORD PTR [edi+1814]
  0003d	c7 45 fc 4b 00
	00 00		 mov	 DWORD PTR tv311[ebp], 75 ; 0000004bH
$LL19@SkillPower:

; 1282 : 	int EnableAttack;
; 1283 : 
; 1284 : 	while ( true )
; 1285 : 	{
; 1286 : 		if(lpObj->VpPlayer2[count].state != 0)

  00044	80 7b fe 00	 cmp	 BYTE PTR [ebx-2], 0
  00048	0f 84 d3 00 00
	00		 je	 $LN27@SkillPower

; 1287 : 		{
; 1288 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0004e	0f bf 33	 movsx	 esi, WORD PTR [ebx]

; 1289 : 
; 1290 : 			if(tObjNum >= 0)

  00051	85 f6		 test	 esi, esi
  00053	0f 88 c8 00 00
	00		 js	 $LN27@SkillPower

; 1291 : 			{
; 1292 : 				EnableAttack = 0;
; 1293 : 
; 1294 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00059	80 7b 02 02	 cmp	 BYTE PTR [ebx+2], 2
  0005d	75 11		 jne	 SHORT $LN15@SkillPower
  0005f	8b d6		 mov	 edx, esi
  00061	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00067	83 ba cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+716], 0

; 1295 : 				{
; 1296 : 					EnableAttack = 1;

  0006e	7c 53		 jl	 SHORT $LN12@SkillPower
$LN15@SkillPower:

; 1297 : 				}
; 1298 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  00070	3b 75 20	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  00073	74 4e		 je	 SHORT $LN12@SkillPower
  00075	39 75 f8	 cmp	 DWORD PTR _DuelIndex$[ebp], esi
  00078	74 49		 je	 SHORT $LN12@SkillPower

; 1299 : 				{
; 1300 : 					EnableAttack = 1;
; 1301 : 				}
; 1302 : #if GS_CASTLE == 1
; 1303 : 				else if (lpObj->VpPlayer2[count].type != OBJ_NPC &&
; 1304 : 						gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE &&
; 1305 : 						g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 1306 : 				{
; 1307 : 					EnableAttack = 1;
; 1308 : 				}
; 1309 : #endif
; 1310 : 				else
; 1311 : 				{
; 1312 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  0007a	8b c6		 mov	 eax, esi
  0007c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 1313 : 
; 1314 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  00082	66 83 b8 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 2
  0008a	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  00090	75 16		 jne	 SHORT $LN10@SkillPower
  00092	8b 80 cc 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716]
  00098	85 c0		 test	 eax, eax
  0009a	78 0c		 js	 SHORT $LN10@SkillPower

; 1315 : 					{
; 1316 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  0009c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000a2	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
$LN10@SkillPower:

; 1317 : 					}
; 1318 : 
; 1319 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  000a8	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000ae	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b4	51		 push	 ecx
  000b5	57		 push	 edi
  000b6	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000bb	83 c4 08	 add	 esp, 8
  000be	83 f8 01	 cmp	 eax, 1
  000c1	75 5e		 jne	 SHORT $LN27@SkillPower
$LN12@SkillPower:

; 1320 : 					{
; 1321 : 						EnableAttack = 1;
; 1322 : 					}
; 1323 : 				}
; 1324 : 
; 1325 : 				if(EnableAttack != 0)
; 1326 : 				{
; 1327 : 					if(SkillTestFrustrum(gObj[tObjNum].X,gObj[tObjNum].Y,aIndex))

  000c3	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000c6	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000cc	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  000d3	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  000da	50		 push	 eax
  000db	51		 push	 ecx
  000dc	52		 push	 edx
  000dd	e8 00 00 00 00	 call	 ?SkillTestFrustrum@@YAHHHH@Z ; SkillTestFrustrum
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e5	85 c0		 test	 eax, eax
  000e7	74 38		 je	 SHORT $LN27@SkillPower

; 1328 : 					{
; 1329 : 						bAttack = 0;
; 1330 : 
; 1331 : 						if(HitCount > 10)
; 1332 : 						{
; 1333 : 							bAttack = 0;
; 1334 : 						}
; 1335 : 						
; 1336 : 						if(HitCount >= 5)

  000e9	83 7d 1c 05	 cmp	 DWORD PTR _HitCount$[ebp], 5
  000ed	7c 13		 jl	 SHORT $LN5@SkillPower

; 1337 : 						{
; 1338 : 							if(rand()%2)

  000ef	e8 00 00 00 00	 call	 _rand
  000f4	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000f9	79 05		 jns	 SHORT $LN31@SkillPower
  000fb	48		 dec	 eax
  000fc	83 c8 fe	 or	 eax, -2			; fffffffeH
  000ff	40		 inc	 eax
$LN31@SkillPower:
  00100	74 1c		 je	 SHORT $LN2@SkillPower
$LN5@SkillPower:

; 1339 : 							{
; 1340 : 								bAttack = 1;
; 1341 : 							}
; 1342 : 						}
; 1343 : 						else
; 1344 : 						{
; 1345 : 							bAttack = 1;
; 1346 : 						}
; 1347 : 
; 1348 : 						if(bAttack != 0)
; 1349 : 						{
; 1350 : 							gObjAttack(lpObj,&gObj[tObjNum],lpMagic,1,1,0,0);

  00102	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00105	6a 00		 push	 0
  00107	6a 00		 push	 0
  00109	6a 01		 push	 1
  0010b	6a 01		 push	 1
  0010d	50		 push	 eax
  0010e	8d 8e 00 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00114	51		 push	 ecx
  00115	57		 push	 edi
  00116	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  0011b	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN2@SkillPower:

; 1351 : 						}
; 1352 : 
; 1353 : 						HitCount++;

  0011e	ff 45 1c	 inc	 DWORD PTR _HitCount$[ebp]
$LN27@SkillPower:

; 1354 : 					}
; 1355 : 				}
; 1356 : 			}
; 1357 : 		}
; 1358 : 
; 1359 : 		count++;

  00121	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1360 : 		if(count > MAX_VIEWPORT -1)

  00124	ff 4d fc	 dec	 DWORD PTR tv311[ebp]
  00127	0f 85 17 ff ff
	ff		 jne	 $LL19@SkillPower
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi
  0012f	5b		 pop	 ebx

; 1361 : 		{
; 1362 : 			break;
; 1363 : 		}
; 1364 : 	}
; 1365 : }

  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c2 1c 00	 ret	 28			; 0000001cH
?SkillPowerSlash@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ENDP ; CObjUseSkill::SkillPowerSlash
_TEXT	ENDS
PUBLIC	??_C@_0CD@DJPGBFFK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Nova?5skill?5already?5cast@ ; `string'
PUBLIC	?SkillHellFire2Start@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillHellFire2Start
EXTRN	__imp__GetTickCount@0:PROC
;	COMDAT ??_C@_0CD@DJPGBFFK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Nova?5skill?5already?5cast@
CONST	SEGMENT
??_C@_0CD@DJPGBFFK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Nova?5skill?5already?5cast@ DB '['
	DB	'%s][%s] Nova skill already casted', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SkillHellFire2Start@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?SkillHellFire2Start@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillHellFire2Start, COMDAT
; _this$ = ecx

; 1645 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1646 : 	LPOBJ lpObj = &gObj[aIndex];

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00008	8b f7		 mov	 esi, edi
  0000a	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00010	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1647 : 
; 1648 : 	if(lpObj->SkillHellFire2State != 0)

  00016	80 be 50 0f 00
	00 00		 cmp	 BYTE PTR [esi+3920], 0
  0001d	74 1f		 je	 SHORT $LN1@SkillHellF

; 1649 : 	{
; 1650 : 		LogAdd(LOG_BLACK, "[%s][%s] Nova skill already casted",lpObj->AccountID,lpObj->Name);

  0001f	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00022	50		 push	 eax
  00023	83 c6 64	 add	 esi, 100		; 00000064H
  00026	56		 push	 esi
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DJPGBFFK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Nova?5skill?5already?5cast@
  0002c	6a 00		 push	 0
  0002e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	5f		 pop	 edi

; 1651 : 		return false;

  00037	33 c0		 xor	 eax, eax
  00039	5e		 pop	 esi

; 1660 : }

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN1@SkillHellF:

; 1652 : 	}
; 1653 : 
; 1654 : 	lpObj->SkillHellFire2Time = GetTickCount();

  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 1655 : 	lpObj->SkillHellFire2State = 1;
; 1656 : 	lpObj->SkillHellFire2Count = 0;
; 1657 : 
; 1658 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_EXPHELL_START,aIndex,1);

  00044	6a 01		 push	 1
  00046	57		 push	 edi
  00047	6a 3a		 push	 58			; 0000003aH
  00049	56		 push	 esi
  0004a	89 86 54 0f 00
	00		 mov	 DWORD PTR [esi+3924], eax
  00050	66 c7 86 50 0f
	00 00 01 00	 mov	 WORD PTR [esi+3920], 1
  00059	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	5f		 pop	 edi

; 1659 : 	return true;

  00062	b8 01 00 00 00	 mov	 eax, 1
  00067	5e		 pop	 esi

; 1660 : }

  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
?SkillHellFire2Start@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillHellFire2Start
_TEXT	ENDS
PUBLIC	__real@bf800000
PUBLIC	__real@00000000
PUBLIC	__$ArrayPad$
PUBLIC	?SkillFrustrum@CObjUseSkill@@QAEXHMMM@Z		; CObjUseSkill::SkillFrustrum
EXTRN	?VectorRotate@@YAXQBM0QAM@Z:PROC		; VectorRotate
EXTRN	?AngleMatrix@@YAXPBMPAY03M@Z:PROC		; AngleMatrix
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SkillFrustrum@CObjUseSkill@@QAEXHMMM@Z
_TEXT	SEGMENT
_lpObj$ = -164						; size = 4
_vFrustrum$ = -160					; size = 48
_Matrix$ = -112						; size = 48
_p$ = -64						; size = 48
_Angle$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_fangle$ = 12						; size = 4
_tx$ = 16						; size = 4
_ty$ = 20						; size = 4
?SkillFrustrum@CObjUseSkill@@QAEXHMMM@Z PROC		; CObjUseSkill::SkillFrustrum, COMDAT
; _this$ = ecx

; 1756 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1757 : 	LPOBJ lpObj = &gObj[aIndex];
; 1758 : 
; 1759 : 	float p[MAX_ARRAY_FRUSTRUM][3];
; 1760 : 
; 1761 : 	p[0][0] = -tx;

  00013	d9 45 10	 fld	 DWORD PTR _tx$[ebp]
  00016	53		 push	 ebx
  00017	d9 c0		 fld	 ST(0)
  00019	56		 push	 esi
  0001a	d9 e0		 fchs
  0001c	57		 push	 edi
  0001d	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00020	d9 5d c0	 fstp	 DWORD PTR _p$[ebp]

; 1762 : 	p[0][1] = ty;

  00023	d9 45 14	 fld	 DWORD PTR _ty$[ebp]
  00026	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0002c	d9 55 c4	 fst	 DWORD PTR _p$[ebp+4]

; 1763 : 	p[0][2] = 0;

  0002f	d9 ee		 fldz
  00031	d9 55 c8	 fst	 DWORD PTR _p$[ebp+8]

; 1764 : 	p[1][0] = tx;
; 1765 : 	p[1][1] = ty;
; 1766 : 	p[1][2] = 0;

  00034	d9 55 d4	 fst	 DWORD PTR _p$[ebp+20]
  00037	d9 ca		 fxch	 ST(2)
  00039	d9 5d cc	 fstp	 DWORD PTR _p$[ebp+12]

; 1767 : 	p[2][0] = 1.0f;
; 1768 : 	p[2][1] = 0;
; 1769 : 	p[2][2] = 0;
; 1770 : 	p[3][0] = -1.0f;
; 1771 : 	p[3][1] = 0;
; 1772 : 	p[3][2] = 0;
; 1773 : 
; 1774 : 	float Angle[3];
; 1775 : 
; 1776 : 	Angle[0] = 0;
; 1777 : 	Angle[1] = 0;
; 1778 : 	Angle[2] = fangle;
; 1779 : 
; 1780 : 	float Matrix[3][MAX_ARRAY_FRUSTRUM];
; 1781 : 	float vFrustrum[MAX_ARRAY_FRUSTRUM][3];
; 1782 : 
; 1783 : 	AngleMatrix(Angle,Matrix);

  0003c	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  0003f	d9 5d d0	 fstp	 DWORD PTR _p$[ebp+16]
  00042	50		 push	 eax
  00043	d9 e8		 fld1
  00045	8d 4d f0	 lea	 ecx, DWORD PTR _Angle$[ebp]
  00048	d9 5d d8	 fstp	 DWORD PTR _p$[ebp+24]
  0004b	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00051	51		 push	 ecx
  00052	89 bd 5c ff ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], edi
  00058	d9 55 dc	 fst	 DWORD PTR _p$[ebp+28]
  0005b	d9 55 e0	 fst	 DWORD PTR _p$[ebp+32]
  0005e	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@bf800000
  00064	d9 5d e4	 fstp	 DWORD PTR _p$[ebp+36]
  00067	d9 55 e8	 fst	 DWORD PTR _p$[ebp+40]
  0006a	d9 55 ec	 fst	 DWORD PTR _p$[ebp+44]
  0006d	d9 55 f0	 fst	 DWORD PTR _Angle$[ebp]
  00070	d9 5d f4	 fstp	 DWORD PTR _Angle$[ebp+4]
  00073	d9 45 0c	 fld	 DWORD PTR _fangle$[ebp]
  00076	d9 5d f8	 fstp	 DWORD PTR _Angle$[ebp+8]
  00079	e8 00 00 00 00	 call	 ?AngleMatrix@@YAXPBMPAY03M@Z ; AngleMatrix
  0007e	83 c4 08	 add	 esp, 8

; 1788 : 
; 1789 : 		lpObj->fSkillFrustrumX[i] = (int)vFrustrum[i][0] + lpObj->X;

  00081	81 c7 40 0f 00
	00		 add	 edi, 3904		; 00000f40H
  00087	33 f6		 xor	 esi, esi
  00089	8d a4 24 00 00
	00 00		 npad	 7
$LL3@SkillFrust:

; 1784 : 
; 1785 : 	for(int i = 0; i < MAX_ARRAY_FRUSTRUM; i++)
; 1786 : 	{
; 1787 : 		VectorRotate((const float *)&p[i],(const float *)&Matrix[0],(float *)&vFrustrum[i]);

  00090	8d 9c 35 60 ff
	ff ff		 lea	 ebx, DWORD PTR _vFrustrum$[ebp+esi]
  00097	53		 push	 ebx
  00098	8d 55 90	 lea	 edx, DWORD PTR _Matrix$[ebp]
  0009b	52		 push	 edx
  0009c	8d 44 35 c0	 lea	 eax, DWORD PTR _p$[ebp+esi]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ?VectorRotate@@YAXQBM0QAM@Z ; VectorRotate

; 1788 : 
; 1789 : 		lpObj->fSkillFrustrumX[i] = (int)vFrustrum[i][0] + lpObj->X;

  000a6	d9 03		 fld	 DWORD PTR [ebx]
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	e8 00 00 00 00	 call	 __ftol2_sse

; 1790 : 		lpObj->fSkillFrustrumY[i] = (int)vFrustrum[i][1] + lpObj->Y;

  000b0	d9 84 35 64 ff
	ff ff		 fld	 DWORD PTR _vFrustrum$[ebp+esi+4]
  000b7	8b 9d 5c ff ff
	ff		 mov	 ebx, DWORD PTR _lpObj$[ebp]
  000bd	0f bf 8b 04 01
	00 00		 movsx	 ecx, WORD PTR [ebx+260]
  000c4	03 c1		 add	 eax, ecx
  000c6	89 47 f0	 mov	 DWORD PTR [edi-16], eax
  000c9	e8 00 00 00 00	 call	 __ftol2_sse
  000ce	0f bf 93 06 01
	00 00		 movsx	 edx, WORD PTR [ebx+262]
  000d5	03 c2		 add	 eax, edx
  000d7	89 07		 mov	 DWORD PTR [edi], eax
  000d9	83 c6 0c	 add	 esi, 12			; 0000000cH
  000dc	83 c7 04	 add	 edi, 4
  000df	83 fe 30	 cmp	 esi, 48			; 00000030H
  000e2	7c ac		 jl	 SHORT $LL3@SkillFrust

; 1791 : 	}
; 1792 : }

  000e4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	33 cd		 xor	 ecx, ebp
  000eb	5b		 pop	 ebx
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c2 10 00	 ret	 16			; 00000010H
?SkillFrustrum@CObjUseSkill@@QAEXHMMM@Z ENDP		; CObjUseSkill::SkillFrustrum
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SkillFrustrum2@CObjUseSkill@@QAEXHMMM@Z	; CObjUseSkill::SkillFrustrum2
; Function compile flags: /Ogtp
;	COMDAT ?SkillFrustrum2@CObjUseSkill@@QAEXHMMM@Z
_TEXT	SEGMENT
_lpObj$ = -164						; size = 4
_vFrustrum$ = -160					; size = 48
_Matrix$ = -112						; size = 48
_p$ = -64						; size = 48
_Angle$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_fangle$ = 12						; size = 4
_tx$ = 16						; size = 4
_ty$ = 20						; size = 4
?SkillFrustrum2@CObjUseSkill@@QAEXHMMM@Z PROC		; CObjUseSkill::SkillFrustrum2, COMDAT
; _this$ = ecx

; 1795 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1796 : 	LPOBJ lpObj = &gObj[aIndex];
; 1797 : 
; 1798 : 
; 1799 : 	float p[MAX_ARRAY_FRUSTRUM][3];
; 1800 : 
; 1801 : 	p[0][0] = 0;

  00013	d9 ee		 fldz
  00015	53		 push	 ebx
  00016	d9 55 c0	 fst	 DWORD PTR _p$[ebp]
  00019	56		 push	 esi

; 1802 : 	p[0][1] = ty;

  0001a	d9 45 14	 fld	 DWORD PTR _ty$[ebp]
  0001d	57		 push	 edi
  0001e	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00021	d9 55 c4	 fst	 DWORD PTR _p$[ebp+4]

; 1803 : 	p[0][2] = 0;
; 1804 : 	p[1][0] = 0;
; 1805 : 	p[1][1] = ty;

  00024	d9 5d d0	 fstp	 DWORD PTR _p$[ebp+16]
  00027	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0002d	d9 55 c8	 fst	 DWORD PTR _p$[ebp+8]
  00030	d9 55 cc	 fst	 DWORD PTR _p$[ebp+12]

; 1806 : 	p[1][2] = 0;

  00033	d9 55 d4	 fst	 DWORD PTR _p$[ebp+20]

; 1807 : 	p[2][0] = tx;

  00036	d9 45 10	 fld	 DWORD PTR _tx$[ebp]
  00039	d9 55 d8	 fst	 DWORD PTR _p$[ebp+24]

; 1808 : 	p[2][1] = 1.0f;

  0003c	d9 e8		 fld1

; 1809 : 	p[2][2] = 0;
; 1810 : 	p[3][0] = -tx;
; 1811 : 	p[3][1] = 1.0f;
; 1812 : 	p[3][2] = 0;
; 1813 : 
; 1814 : 	float Angle[3];
; 1815 : 
; 1816 : 	Angle[0] = 0;
; 1817 : 	Angle[1] = 0;
; 1818 : 	Angle[2] = fangle;
; 1819 : 
; 1820 : 	float Matrix[3][MAX_ARRAY_FRUSTRUM];
; 1821 : 	float vFrustrum[MAX_ARRAY_FRUSTRUM][3];
; 1822 : 
; 1823 : 	AngleMatrix(Angle,Matrix);

  0003e	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  00041	d9 55 dc	 fst	 DWORD PTR _p$[ebp+28]
  00044	50		 push	 eax
  00045	d9 ca		 fxch	 ST(2)
  00047	8d 4d f0	 lea	 ecx, DWORD PTR _Angle$[ebp]
  0004a	d9 55 e0	 fst	 DWORD PTR _p$[ebp+32]
  0004d	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00053	d9 c9		 fxch	 ST(1)
  00055	51		 push	 ecx
  00056	d9 e0		 fchs
  00058	89 bd 5c ff ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], edi
  0005e	d9 5d e4	 fstp	 DWORD PTR _p$[ebp+36]
  00061	d9 c9		 fxch	 ST(1)
  00063	d9 5d e8	 fstp	 DWORD PTR _p$[ebp+40]
  00066	d9 55 ec	 fst	 DWORD PTR _p$[ebp+44]
  00069	d9 55 f0	 fst	 DWORD PTR _Angle$[ebp]
  0006c	d9 5d f4	 fstp	 DWORD PTR _Angle$[ebp+4]
  0006f	d9 45 0c	 fld	 DWORD PTR _fangle$[ebp]
  00072	d9 5d f8	 fstp	 DWORD PTR _Angle$[ebp+8]
  00075	e8 00 00 00 00	 call	 ?AngleMatrix@@YAXPBMPAY03M@Z ; AngleMatrix
  0007a	83 c4 08	 add	 esp, 8

; 1828 : 
; 1829 : 		lpObj->fSkillFrustrumX[i] = (int)vFrustrum[i][0] + lpObj->X;

  0007d	81 c7 40 0f 00
	00		 add	 edi, 3904		; 00000f40H
  00083	33 f6		 xor	 esi, esi
$LL3@SkillFrust@2:

; 1824 : 
; 1825 : 	for(int i = 0; i < MAX_ARRAY_FRUSTRUM; i++)
; 1826 : 	{
; 1827 : 		VectorRotate((const float *)&p[i],(const float *)&Matrix[0],(float *)&vFrustrum[i]);

  00085	8d 9c 35 60 ff
	ff ff		 lea	 ebx, DWORD PTR _vFrustrum$[ebp+esi]
  0008c	53		 push	 ebx
  0008d	8d 55 90	 lea	 edx, DWORD PTR _Matrix$[ebp]
  00090	52		 push	 edx
  00091	8d 44 35 c0	 lea	 eax, DWORD PTR _p$[ebp+esi]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?VectorRotate@@YAXQBM0QAM@Z ; VectorRotate

; 1828 : 
; 1829 : 		lpObj->fSkillFrustrumX[i] = (int)vFrustrum[i][0] + lpObj->X;

  0009b	d9 03		 fld	 DWORD PTR [ebx]
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a0	e8 00 00 00 00	 call	 __ftol2_sse

; 1830 : 		lpObj->fSkillFrustrumY[i] = (int)vFrustrum[i][1] + lpObj->Y;

  000a5	d9 84 35 64 ff
	ff ff		 fld	 DWORD PTR _vFrustrum$[ebp+esi+4]
  000ac	8b 9d 5c ff ff
	ff		 mov	 ebx, DWORD PTR _lpObj$[ebp]
  000b2	0f bf 8b 04 01
	00 00		 movsx	 ecx, WORD PTR [ebx+260]
  000b9	03 c1		 add	 eax, ecx
  000bb	89 47 f0	 mov	 DWORD PTR [edi-16], eax
  000be	e8 00 00 00 00	 call	 __ftol2_sse
  000c3	0f bf 93 06 01
	00 00		 movsx	 edx, WORD PTR [ebx+262]
  000ca	03 c2		 add	 eax, edx
  000cc	89 07		 mov	 DWORD PTR [edi], eax
  000ce	83 c6 0c	 add	 esi, 12			; 0000000cH
  000d1	83 c7 04	 add	 edi, 4
  000d4	83 fe 30	 cmp	 esi, 48			; 00000030H
  000d7	7c ac		 jl	 SHORT $LL3@SkillFrust@2

; 1831 : 	}
; 1832 : }

  000d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi
  000de	33 cd		 xor	 ecx, ebp
  000e0	5b		 pop	 ebx
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 10 00	 ret	 16			; 00000010H
?SkillFrustrum2@CObjUseSkill@@QAEXHMMM@Z ENDP		; CObjUseSkill::SkillFrustrum2
_TEXT	ENDS
PUBLIC	__real@4056800000000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@4066800000000000
PUBLIC	?GetAngle@CObjUseSkill@@QAEHHHHH@Z		; CObjUseSkill::GetAngle
EXTRN	__CIatan2:PROC
;	COMDAT __real@4056800000000000
CONST	SEGMENT
__real@4056800000000000 DQ 04056800000000000r	; 90
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GetAngle@CObjUseSkill@@QAEHHHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
tv138 = 12						; size = 4
tv136 = 12						; size = 4
_y$ = 12						; size = 4
_tx$ = 16						; size = 4
_ty$ = 20						; size = 4
?GetAngle@CObjUseSkill@@QAEHHHHH@Z PROC			; CObjUseSkill::GetAngle, COMDAT
; _this$ = ecx

; 1835 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1836 : 	double diffX = x - tx;
; 1837 : 	double diffY = y - ty;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00006	2b 45 14	 sub	 eax, DWORD PTR _ty$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0000c	2b 4d 10	 sub	 ecx, DWORD PTR _tx$[ebp]

; 1838 : 
; 1839 : 	double rad = atan2(diffY,diffX);
; 1840 : 
; 1841 : 	int angle = rad * 180 / Q_PI + 90;

  0000f	89 45 0c	 mov	 DWORD PTR tv138[ebp], eax
  00012	db 45 0c	 fild	 DWORD PTR tv138[ebp]
  00015	89 4d 0c	 mov	 DWORD PTR tv136[ebp], ecx
  00018	db 45 0c	 fild	 DWORD PTR tv136[ebp]
  0001b	e8 00 00 00 00	 call	 __CIatan2
  00020	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4066800000000000
  00026	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@400921fb54442d18
  0002c	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4056800000000000
  00032	e8 00 00 00 00	 call	 __ftol2_sse

; 1842 : 
; 1843 : 	if(angle < 0)

  00037	85 c0		 test	 eax, eax
  00039	79 05		 jns	 SHORT $LN1@GetAngle

; 1844 : 	{
; 1845 : 		angle += 360;

  0003b	05 68 01 00 00	 add	 eax, 360		; 00000168H
$LN1@GetAngle:

; 1846 : 	}
; 1847 : 	return angle;
; 1848 : }

  00040	5d		 pop	 ebp
  00041	c2 10 00	 ret	 16			; 00000010H
?GetAngle@CObjUseSkill@@QAEHHHHH@Z ENDP			; CObjUseSkill::GetAngle
_TEXT	ENDS
PUBLIC	?SkillSpear@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillSpear
EXTRN	?HitCheck@CSkillHitBox@@QAEHHHHHH@Z:PROC	; CSkillHitBox::HitCheck
EXTRN	?SkillSpearHitBox@@3VCSkillHitBox@@A:BYTE	; SkillSpearHitBox
; Function compile flags: /Ogtp
;	COMDAT ?SkillSpear@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_iangle$ = -8						; size = 4
_DuelIndex$ = -4					; size = 4
tv74 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillSpear@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::SkillSpear, COMDAT
; _this$ = ecx

; 1923 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1924 : 	LPOBJ lpObj = &gObj[aIndex];
; 1925 : 	int StartDis = 1;
; 1926 : 	int tObjNum;
; 1927 : 
; 1928 : 	int iangle = this->GetAngle(lpObj->X,lpObj->Y,gObj[aTargetIndex].X,gObj[aTargetIndex].Y);

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000e	57		 push	 edi
  0000f	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00015	8b fb		 mov	 edi, ebx
  00017	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0001d	0f bf 87 06 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  00024	0f bf 97 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  0002b	50		 push	 eax
  0002c	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00032	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  00039	52		 push	 edx
  0003a	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  00041	50		 push	 eax
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?GetAngle@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::GetAngle

; 1929 : 	int count = 0;
; 1930 : 	int loopcount = 0;
; 1931 : 	int attackcheck;
; 1932 : 
; 1933 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00048	6a 01		 push	 1
  0004a	53		 push	 ebx
  0004b	8b 5d 10	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  0004e	89 45 f8	 mov	 DWORD PTR _iangle$[ebp], eax
  00051	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  00055	50		 push	 eax
  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  0005c	83 c4 10	 add	 esp, 16			; 00000010H

; 1934 : 
; 1935 : 	if(lpObj->SkillLongSpearChange == 0)

  0005f	80 be bb 10 00
	00 00		 cmp	 BYTE PTR [esi+4283], 0
  00066	75 27		 jne	 SHORT $LN19@SkillSpear

; 1936 : 	{
; 1937 : 		gObjAttack(lpObj,&gObj[aTargetIndex],lpMagic,0,1,0,0);

  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	6a 01		 push	 1
  0006e	6a 00		 push	 0
  00070	53		 push	 ebx
  00071	8d 8f 00 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  00077	51		 push	 ecx
  00078	56		 push	 esi
  00079	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  0007e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi

; 2003 : 		{
; 2004 : 			break;
; 2005 : 		}
; 2006 : 	}
; 2007 : 	return true;

  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	5b		 pop	 ebx

; 2008 : }

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 0c 00	 ret	 12			; 0000000cH
$LN19@SkillSpear:

; 1938 : 		return true;
; 1939 : 	}
; 1940 : 
; 1941 : 	int DuelIndex = lpObj->m_iDuelUser;

  0008f	8b 96 1c 0d 00
	00		 mov	 edx, DWORD PTR [esi+3356]
  00095	89 55 fc	 mov	 DWORD PTR _DuelIndex$[ebp], edx
  00098	8d 9e 16 07 00
	00		 lea	 ebx, DWORD PTR [esi+1814]
  0009e	c7 45 08 4b 00
	00 00		 mov	 DWORD PTR tv74[ebp], 75	; 0000004bH
$LL18@SkillSpear:

; 1942 : 	int EnableAttack;
; 1943 : 
; 1944 : 	while ( true )
; 1945 : 	{
; 1946 : 		if(lpObj->VpPlayer2[count].state != 0)

  000a5	80 7b fe 00	 cmp	 BYTE PTR [ebx-2], 0
  000a9	0f 84 c9 00 00
	00		 je	 $LN27@SkillSpear

; 1947 : 		{
; 1948 : 			tObjNum = lpObj->VpPlayer2[count].number;

  000af	0f bf 3b	 movsx	 edi, WORD PTR [ebx]

; 1949 : 
; 1950 : 			if(tObjNum >= 0)

  000b2	85 ff		 test	 edi, edi
  000b4	0f 88 be 00 00
	00		 js	 $LN27@SkillSpear

; 1951 : 			{
; 1952 : 				EnableAttack = 0;
; 1953 : 
; 1954 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  000ba	80 7b 02 02	 cmp	 BYTE PTR [ebx+2], 2
  000be	75 11		 jne	 SHORT $LN14@SkillSpear
  000c0	8b c7		 mov	 eax, edi
  000c2	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000c8	83 b8 cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716], 0

; 1955 : 				{
; 1956 : 					EnableAttack = 1;

  000cf	7c 53		 jl	 SHORT $LN11@SkillSpear
$LN14@SkillSpear:

; 1957 : 				}
; 1958 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  000d1	3b 7d 0c	 cmp	 edi, DWORD PTR _aTargetIndex$[ebp]
  000d4	74 4e		 je	 SHORT $LN11@SkillSpear
  000d6	39 7d fc	 cmp	 DWORD PTR _DuelIndex$[ebp], edi
  000d9	74 49		 je	 SHORT $LN11@SkillSpear

; 1959 : 				{
; 1960 : 					EnableAttack = 1;
; 1961 : 				}
; 1962 : 				else
; 1963 : 				{
; 1964 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000db	8b c7		 mov	 eax, edi
  000dd	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 1965 : 
; 1966 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000e3	66 83 b8 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 2
  000eb	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  000f1	75 16		 jne	 SHORT $LN9@SkillSpear
  000f3	8b 80 cc 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716]
  000f9	85 c0		 test	 eax, eax
  000fb	78 0c		 js	 SHORT $LN9@SkillSpear

; 1967 : 					{
; 1968 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  000fd	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00103	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
$LN9@SkillSpear:

; 1969 : 					}
; 1970 : 
; 1971 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00109	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0010f	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00115	51		 push	 ecx
  00116	56		 push	 esi
  00117	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0011c	83 c4 08	 add	 esp, 8
  0011f	83 f8 01	 cmp	 eax, 1
  00122	75 54		 jne	 SHORT $LN27@SkillSpear
$LN11@SkillSpear:

; 1972 : 					{
; 1973 : 						EnableAttack = 1;
; 1974 : 					}
; 1975 : 				}
; 1976 : 
; 1977 : 				if(EnableAttack != 0)
; 1978 : 				{
; 1979 : 					attackcheck = 0;
; 1980 : 
; 1981 : 					if(loopcount == 0)
; 1982 : 					{
; 1983 : 						attackcheck = 1;
; 1984 : 					}
; 1985 : 					else if(rand()%3==0)
; 1986 : 					{
; 1987 : 						attackcheck = 1;
; 1988 : 					}
; 1989 : 
; 1990 : 					if(attackcheck != 0)
; 1991 : 					{
; 1992 : 						if(SkillSpearHitBox.HitCheck(iangle,lpObj->X,lpObj->Y,gObj[tObjNum].X,gObj[tObjNum].Y))

  00124	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  0012b	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00131	0f bf 8f 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  00138	0f bf 97 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  0013f	51		 push	 ecx
  00140	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  00147	52		 push	 edx
  00148	8b 55 f8	 mov	 edx, DWORD PTR _iangle$[ebp]
  0014b	50		 push	 eax
  0014c	51		 push	 ecx
  0014d	52		 push	 edx
  0014e	b9 00 00 00 00	 mov	 ecx, OFFSET ?SkillSpearHitBox@@3VCSkillHitBox@@A ; SkillSpearHitBox
  00153	e8 00 00 00 00	 call	 ?HitCheck@CSkillHitBox@@QAEHHHHHH@Z ; CSkillHitBox::HitCheck
  00158	85 c0		 test	 eax, eax
  0015a	74 1c		 je	 SHORT $LN27@SkillSpear

; 1993 : 						{
; 1994 : 							gObjAttack(lpObj,&gObj[tObjNum],lpMagic,0,1,0,0);

  0015c	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0015f	6a 00		 push	 0
  00161	6a 00		 push	 0
  00163	6a 01		 push	 1
  00165	6a 00		 push	 0
  00167	50		 push	 eax
  00168	8d 8f 00 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  0016e	51		 push	 ecx
  0016f	56		 push	 esi
  00170	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  00175	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN27@SkillSpear:

; 1995 : 						}
; 1996 : 					}
; 1997 : 				}
; 1998 : 			}
; 1999 : 		}
; 2000 : 
; 2001 : 		count++;

  00178	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 2002 : 		if(count > MAX_VIEWPORT -1)

  0017b	ff 4d 08	 dec	 DWORD PTR tv74[ebp]
  0017e	0f 85 21 ff ff
	ff		 jne	 $LL18@SkillSpear

; 2003 : 		{
; 2004 : 			break;
; 2005 : 		}
; 2006 : 	}
; 2007 : 	return true;

  00184	5f		 pop	 edi
  00185	5e		 pop	 esi
  00186	b8 01 00 00 00	 mov	 eax, 1
  0018b	5b		 pop	 ebx

; 2008 : }

  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c2 0c 00	 ret	 12			; 0000000cH
?SkillSpear@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::SkillSpear
_TEXT	ENDS
PUBLIC	?SkillFireBurst@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillFireBurst
; Function compile flags: /Ogtp
;	COMDAT ?SkillFireBurst@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv230 = -8						; size = 4
_DuelIndex$ = -4					; size = 4
tv371 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
tv220 = 16						; size = 4
_lpMagic$ = 16						; size = 4
?SkillFireBurst@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillFireBurst, COMDAT
; _this$ = ecx

; 2011 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 2012 : 	LPOBJ lpObj = &gObj[aIndex];
; 2013 : 	int StartDis = 1;
; 2014 : 	int tObjNum;
; 2015 : 	int count = 0;
; 2016 : 	int loopcount = 0;
; 2017 : 
; 2018 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00007	8b 5d 10	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  0000a	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00012	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00018	57		 push	 edi
  00019	8b 7d 0c	 mov	 edi, DWORD PTR _aTargetIndex$[ebp]
  0001c	6a 01		 push	 1
  0001e	57		 push	 edi
  0001f	50		 push	 eax
  00020	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 2019 : 	gObjAttack(lpObj,&gObj[aTargetIndex],lpMagic,0,1,0,0);

  0002c	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 01		 push	 1
  00038	6a 00		 push	 0
  0003a	8d 87 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  00040	53		 push	 ebx
  00041	50		 push	 eax
  00042	56		 push	 esi
  00043	89 45 f8	 mov	 DWORD PTR tv230[ebp], eax
  00046	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack

; 2020 : 
; 2021 : 	int attackcheck;
; 2022 : 	int DuelIndex = lpObj->m_iDuelUser;

  0004b	8b 8e 1c 0d 00
	00		 mov	 ecx, DWORD PTR [esi+3356]
  00051	8d 86 16 07 00
	00		 lea	 eax, DWORD PTR [esi+1814]
  00057	83 c4 2c	 add	 esp, 44			; 0000002cH
  0005a	89 4d fc	 mov	 DWORD PTR _DuelIndex$[ebp], ecx
  0005d	89 45 08	 mov	 DWORD PTR tv371[ebp], eax
  00060	c7 45 10 4b 00
	00 00		 mov	 DWORD PTR tv220[ebp], 75 ; 0000004bH
  00067	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL18@SkillFireB:

; 2023 : 	int EnableAttack;
; 2024 : 	int delaytime;
; 2025 : 
; 2026 : 	while ( true )
; 2027 : 	{
; 2028 : 		if(lpObj->VpPlayer2[count].state != 0)

  00070	80 78 fe 00	 cmp	 BYTE PTR [eax-2], 0
  00074	0f 84 c6 00 00
	00		 je	 $LN27@SkillFireB

; 2029 : 		{
; 2030 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0007a	0f bf 38	 movsx	 edi, WORD PTR [eax]

; 2031 : 
; 2032 : 			if(tObjNum >= 0 && aTargetIndex != tObjNum)

  0007d	85 ff		 test	 edi, edi
  0007f	0f 88 bb 00 00
	00		 js	 $LN27@SkillFireB
  00085	39 7d 0c	 cmp	 DWORD PTR _aTargetIndex$[ebp], edi
  00088	0f 84 b2 00 00
	00		 je	 $LN27@SkillFireB

; 2033 : 			{
; 2034 : 				EnableAttack = 0;
; 2035 : 
; 2036 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  0008e	80 78 02 02	 cmp	 BYTE PTR [eax+2], 2
  00092	75 11		 jne	 SHORT $LN26@SkillFireB
  00094	8b d7		 mov	 edx, edi
  00096	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  0009c	83 ba cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+716], 0

; 2037 : 				{
; 2038 : 					EnableAttack = 1;

  000a3	7c 4e		 jl	 SHORT $LN11@SkillFireB
$LN26@SkillFireB:

; 2039 : 				}
; 2040 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  000a5	39 7d fc	 cmp	 DWORD PTR _DuelIndex$[ebp], edi
  000a8	74 49		 je	 SHORT $LN11@SkillFireB

; 2041 : 				{
; 2042 : 					EnableAttack = 1;
; 2043 : 				}
; 2044 : 				else
; 2045 : 				{
; 2046 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000aa	8b c7		 mov	 eax, edi
  000ac	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 2047 : 
; 2048 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000b2	66 83 b8 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 2
  000ba	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  000c0	75 16		 jne	 SHORT $LN9@SkillFireB
  000c2	8b 80 cc 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716]
  000c8	85 c0		 test	 eax, eax
  000ca	78 0c		 js	 SHORT $LN9@SkillFireB

; 2049 : 					{
; 2050 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  000cc	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000d2	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
$LN9@SkillFireB:

; 2051 : 					}
; 2052 : 
; 2053 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  000d8	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000de	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e4	51		 push	 ecx
  000e5	56		 push	 esi
  000e6	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000eb	83 c4 08	 add	 esp, 8
  000ee	83 f8 01	 cmp	 eax, 1
  000f1	75 4d		 jne	 SHORT $LN27@SkillFireB
$LN11@SkillFireB:

; 2054 : 					{
; 2055 : 						EnableAttack = 1;
; 2056 : 					}
; 2057 : 				}
; 2058 : 
; 2059 : 				if(EnableAttack != 0)
; 2060 : 				{
; 2061 : 					attackcheck = 0;
; 2062 : 
; 2063 : 					if(loopcount == 0)
; 2064 : 					{
; 2065 : 						attackcheck = 1;
; 2066 : 					}
; 2067 : 					else if(rand()%3==0)
; 2068 : 					{
; 2069 : 						attackcheck = 1;
; 2070 : 					}
; 2071 : 
; 2072 : 					if(attackcheck != 0)
; 2073 : 					{
; 2074 : 						if(gObjCalDistance(&gObj[aTargetIndex],&gObj[tObjNum]) < 3)

  000f3	8b 4d f8	 mov	 ecx, DWORD PTR tv230[ebp]
  000f6	8b c7		 mov	 eax, edi
  000f8	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000fe	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00103	50		 push	 eax
  00104	51		 push	 ecx
  00105	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0010a	83 c4 08	 add	 esp, 8
  0010d	83 f8 03	 cmp	 eax, 3
  00110	7d 2e		 jge	 SHORT $LN27@SkillFireB

; 2075 : 						{
; 2076 : 							delaytime = (rand()*17)%300 + 500;

  00112	e8 00 00 00 00	 call	 _rand
  00117	8b c8		 mov	 ecx, eax
  00119	c1 e0 04	 shl	 eax, 4
  0011c	03 c1		 add	 eax, ecx
  0011e	99		 cdq
  0011f	b9 2c 01 00 00	 mov	 ecx, 300		; 0000012cH
  00124	f7 f9		 idiv	 ecx

; 2077 : 
; 2078 : 							gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,delaytime,lpMagic->m_Skill,0);

  00126	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  0012a	6a 00		 push	 0
  0012c	50		 push	 eax
  0012d	81 c2 f4 01 00
	00		 add	 edx, 500		; 000001f4H
  00133	52		 push	 edx
  00134	57		 push	 edi
  00135	6a 32		 push	 50			; 00000032H
  00137	56		 push	 esi
  00138	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  0013d	83 c4 18	 add	 esp, 24			; 00000018H
$LN27@SkillFireB:

; 2079 : 						}
; 2080 : 					}
; 2081 : 				}
; 2082 : 			}
; 2083 : 		}
; 2084 : 
; 2085 : 		count++;

  00140	8b 45 08	 mov	 eax, DWORD PTR tv371[ebp]
  00143	83 c0 0c	 add	 eax, 12			; 0000000cH

; 2086 : 		if(count > MAX_VIEWPORT -1)

  00146	ff 4d 10	 dec	 DWORD PTR tv220[ebp]
  00149	89 45 08	 mov	 DWORD PTR tv371[ebp], eax
  0014c	0f 85 1e ff ff
	ff		 jne	 $LL18@SkillFireB

; 2087 : 		{
; 2088 : 			break;
; 2089 : 		}
; 2090 : 	}
; 2091 : 	return true;

  00152	5f		 pop	 edi
  00153	5e		 pop	 esi
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	5b		 pop	 ebx

; 2092 : }

  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 0c 00	 ret	 12			; 0000000cH
?SkillFireBurst@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillFireBurst
_TEXT	ENDS
PUBLIC	?SkillDarkHorseAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDarkHorseAttack
; Function compile flags: /Ogtp
;	COMDAT ?SkillDarkHorseAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_DuelIndex$ = -8					; size = 4
tv312 = -4						; size = 4
tv374 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillDarkHorseAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillDarkHorseAttack, COMDAT
; _this$ = ecx

; 2095 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2096 : 	LPOBJ lpObj = &gObj[aIndex];

  00009	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000c	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00012	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2097 : 	int tObjNum;
; 2098 : 	int count = 0;
; 2099 : 	int HitCount = 0;
; 2100 : 	int bAttack;
; 2101 : 	int DuelIndex = lpObj->m_iDuelUser;
; 2102 : 	int EnableAttack;
; 2103 : 
; 2104 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_DARKHORSE_ATTACK,lpObj->m_Index,1);

  00018	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0001a	8b 87 1c 0d 00
	00		 mov	 eax, DWORD PTR [edi+3356]
  00020	6a 01		 push	 1
  00022	51		 push	 ecx
  00023	6a 3e		 push	 62			; 0000003eH
  00025	57		 push	 edi
  00026	89 45 f8	 mov	 DWORD PTR _DuelIndex$[ebp], eax
  00029	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  0002e	8d 8f 16 07 00
	00		 lea	 ecx, DWORD PTR [edi+1814]
  00034	83 c4 10	 add	 esp, 16			; 00000010H
  00037	89 4d 08	 mov	 DWORD PTR tv374[ebp], ecx
  0003a	c7 45 fc 4b 00
	00 00		 mov	 DWORD PTR tv312[ebp], 75 ; 0000004bH
$LL21@SkillDarkH:

; 2105 : 
; 2106 : 	while ( true )
; 2107 : 	{
; 2108 : 		if(lpObj->VpPlayer2[count].state != 0)

  00041	80 79 fe 00	 cmp	 BYTE PTR [ecx-2], 0
  00045	0f 84 b1 00 00
	00		 je	 $LN29@SkillDarkH

; 2109 : 		{
; 2110 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0004b	0f bf 19	 movsx	 ebx, WORD PTR [ecx]

; 2111 : 
; 2112 : 			if(tObjNum >= 0)

  0004e	85 db		 test	 ebx, ebx
  00050	0f 88 a6 00 00
	00		 js	 $LN29@SkillDarkH

; 2113 : 			{
; 2114 : 				EnableAttack = 0;
; 2115 : 				if(gObj[tObjNum].Class < 100 || gObj[tObjNum].Class > 110)

  00056	8b f3		 mov	 esi, ebx
  00058	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0005e	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152]
  00065	83 f8 64	 cmp	 eax, 100		; 00000064H
  00068	72 09		 jb	 SHORT $LN16@SkillDarkH
  0006a	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  0006d	0f 86 89 00 00
	00		 jbe	 $LN29@SkillDarkH
$LN16@SkillDarkH:

; 2116 : 				{
; 2117 : 	
; 2118 : 					if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00073	80 79 02 02	 cmp	 BYTE PTR [ecx+2], 2
  00077	75 09		 jne	 SHORT $LN15@SkillDarkH
  00079	83 be cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+716], 0

; 2119 : 					{
; 2120 : 						EnableAttack = 1;

  00080	7c 4a		 jl	 SHORT $LN12@SkillDarkH
$LN15@SkillDarkH:

; 2121 : 					}
; 2122 : 					else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  00082	3b 5d 0c	 cmp	 ebx, DWORD PTR _aTargetIndex$[ebp]
  00085	74 45		 je	 SHORT $LN12@SkillDarkH
  00087	39 5d f8	 cmp	 DWORD PTR _DuelIndex$[ebp], ebx
  0008a	74 40		 je	 SHORT $LN12@SkillDarkH

; 2123 : 					{
; 2124 : 						EnableAttack = 1;
; 2125 : 					}
; 2126 : #if GS_CASTLE == 1
; 2127 : 					else if (lpObj->VpPlayer2[count].type != OBJ_NPC &&
; 2128 : 							gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE &&
; 2129 : 							g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 2130 : 					{
; 2131 : 						EnableAttack = 1;
; 2132 : 					}
; 2133 : #endif
; 2134 : 					else
; 2135 : 					{
; 2136 : 						int CallMonIndex = gObj[tObjNum].m_Index;
; 2137 : 	
; 2138 : 						if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  0008c	66 83 be 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+96], 2
  00094	8b 86 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  0009a	75 16		 jne	 SHORT $LN10@SkillDarkH
  0009c	8b 8e cc 02 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+716]
  000a2	85 c9		 test	 ecx, ecx
  000a4	78 0c		 js	 SHORT $LN10@SkillDarkH

; 2139 : 						{
; 2140 : 							CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  000a6	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000ac	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx]
$LN10@SkillDarkH:

; 2141 : 						}
; 2142 : 	
; 2143 : 						if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  000b2	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000b8	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bd	50		 push	 eax
  000be	57		 push	 edi
  000bf	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000c4	83 c4 08	 add	 esp, 8
  000c7	83 f8 01	 cmp	 eax, 1
  000ca	75 30		 jne	 SHORT $LN29@SkillDarkH
$LN12@SkillDarkH:

; 2144 : 						{
; 2145 : 							EnableAttack = 1;
; 2146 : 						}
; 2147 : 					}
; 2148 : 				}
; 2149 : 				if(EnableAttack != 0)
; 2150 : 				{
; 2151 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 5)

  000cc	8d 96 00 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000d2	52		 push	 edx
  000d3	57		 push	 edi
  000d4	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000d9	83 c4 08	 add	 esp, 8
  000dc	83 f8 05	 cmp	 eax, 5
  000df	7d 1b		 jge	 SHORT $LN29@SkillDarkH

; 2152 : 					{
; 2153 : 						bAttack = 0;
; 2154 : 
; 2155 : 						if(HitCount > 15)
; 2156 : 						{
; 2157 : 							bAttack = 0;
; 2158 : 						}
; 2159 : 
; 2160 : 						if(HitCount >= 10)
; 2161 : 						{
; 2162 : 							if(rand()%2)
; 2163 : 							{
; 2164 : 								bAttack = 1;
; 2165 : 							}
; 2166 : 						}
; 2167 : 						else
; 2168 : 						{
; 2169 : 							bAttack = 1;
; 2170 : 						}
; 2171 : 
; 2172 : 						if(bAttack != 0)
; 2173 : 						{
; 2174 : 							gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,500,lpMagic->m_Skill,0);

  000e1	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000e4	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  000e8	6a 00		 push	 0
  000ea	51		 push	 ecx
  000eb	68 f4 01 00 00	 push	 500			; 000001f4H
  000f0	53		 push	 ebx
  000f1	6a 32		 push	 50			; 00000032H
  000f3	57		 push	 edi
  000f4	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  000f9	83 c4 18	 add	 esp, 24			; 00000018H
$LN29@SkillDarkH:

; 2175 : 						}
; 2176 : 					}
; 2177 : 				}
; 2178 : 			}
; 2179 : 		}
; 2180 : 	
; 2181 : 		count++;

  000fc	8b 4d 08	 mov	 ecx, DWORD PTR tv374[ebp]
  000ff	83 c1 0c	 add	 ecx, 12			; 0000000cH

; 2182 : 		if(count > MAX_VIEWPORT -1)

  00102	b8 01 00 00 00	 mov	 eax, 1
  00107	29 45 fc	 sub	 DWORD PTR tv312[ebp], eax
  0010a	89 4d 08	 mov	 DWORD PTR tv374[ebp], ecx
  0010d	0f 85 2e ff ff
	ff		 jne	 $LL21@SkillDarkH
  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx

; 2183 : 		{
; 2184 : 			break;
; 2185 : 		}
; 2186 : 	}
; 2187 : return true;
; 2188 : }

  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c2 0c 00	 ret	 12			; 0000000cH
?SkillDarkHorseAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillDarkHorseAttack
_TEXT	ENDS
PUBLIC	?RecallPartyCheck@CObjUseSkill@@QAEHHH@Z	; CObjUseSkill::RecallPartyCheck
; Function compile flags: /Ogtp
;	COMDAT ?RecallPartyCheck@CObjUseSkill@@QAEHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_skill_level$ = 12					; size = 4
?RecallPartyCheck@CObjUseSkill@@QAEHHH@Z PROC		; CObjUseSkill::RecallPartyCheck, COMDAT
; _this$ = ecx

; 2194 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2195 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0000d	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2196 : 	int number;
; 2197 : 	int partynum = 0;
; 2198 : 
; 2199 : 	partynum = lpObj->PartyNumber;

  00013	8b 86 a8 02 00
	00		 mov	 eax, DWORD PTR [esi+680]
  00019	57		 push	 edi

; 2200 : 
; 2201 : 	int partycount;
; 2202 : 	LPOBJ lpPartyObj;
; 2203 : 	int recallcount = 0;
; 2204 : 
; 2205 : 	if(partynum != -1)

  0001a	83 f8 ff	 cmp	 eax, -1
  0001d	74 49		 je	 SHORT $LN5@RecallPart

; 2206 : 	{
; 2207 : 		partycount = gParty.m_PartyS[partynum].Count;
; 2208 : 
; 2209 : 		for(int n = 0; n < MAX_USER_IN_PARTY;n++)

  0001f	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00022	c1 e1 04	 shl	 ecx, 4
  00025	33 ff		 xor	 edi, edi
  00027	81 c1 0c 00 00
	00		 add	 ecx, OFFSET ?gParty@@3VPartyClass@@A+12
  0002d	8d 49 00	 npad	 3
$LL7@RecallPart:

; 2210 : 		{
; 2211 : 			number = gParty.m_PartyS[partynum].Number[n];

  00030	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2212 : 
; 2213 : 			if(number >= 0)

  00032	85 c0		 test	 eax, eax
  00034	78 29		 js	 SHORT $LN6@RecallPart

; 2214 : 			{
; 2215 : 				lpPartyObj = &gObj[number];

  00036	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0003c	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2216 : 
; 2217 : 				if(lpPartyObj->m_Index != lpObj->m_Index)

  00041	8b 10		 mov	 edx, DWORD PTR [eax]
  00043	3b 16		 cmp	 edx, DWORD PTR [esi]
  00045	74 18		 je	 SHORT $LN6@RecallPart

; 2218 : 				{
; 2219 : 					if(lpPartyObj->MapNumber == lpObj->MapNumber)

  00047	8a 90 09 01 00
	00		 mov	 dl, BYTE PTR [eax+265]
  0004d	3a 96 09 01 00
	00		 cmp	 dl, BYTE PTR [esi+265]
  00053	75 0a		 jne	 SHORT $LN6@RecallPart

; 2220 : 					{
; 2221 : 						if(lpPartyObj->SkillRecallParty_Time != 0)

  00055	66 83 b8 b0 10
	00 00 00	 cmp	 WORD PTR [eax+4272], 0
  0005d	75 14		 jne	 SHORT $LN12@RecallPart
$LN6@RecallPart:

; 2206 : 	{
; 2207 : 		partycount = gParty.m_PartyS[partynum].Count;
; 2208 : 
; 2209 : 		for(int n = 0; n < MAX_USER_IN_PARTY;n++)

  0005f	47		 inc	 edi
  00060	83 c1 04	 add	 ecx, 4
  00063	83 ff 05	 cmp	 edi, 5
  00066	7c c8		 jl	 SHORT $LL7@RecallPart
$LN5@RecallPart:
  00068	5f		 pop	 edi

; 2224 : 						}
; 2225 : 					}
; 2226 : 				}
; 2227 : 			}
; 2228 : 		}
; 2229 : 	}
; 2230 : 	return true;

  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	5e		 pop	 esi

; 2231 : }

  0006f	5d		 pop	 ebp
  00070	c2 08 00	 ret	 8
$LN12@RecallPart:
  00073	5f		 pop	 edi

; 2222 : 						{
; 2223 : 							return false;

  00074	33 c0		 xor	 eax, eax
  00076	5e		 pop	 esi

; 2231 : }

  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
?RecallPartyCheck@CObjUseSkill@@QAEHHH@Z ENDP		; CObjUseSkill::RecallPartyCheck
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SkillRecallParty@CObjUseSkill@@QAEXHH@Z	; CObjUseSkill::SkillRecallParty
EXTRN	?gObjCheckTeleportArea@@YAHHEE@Z:PROC		; gObjCheckTeleportArea
EXTRN	?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMoveCommand::CheckEquipmentToMove
EXTRN	?GetMoveLevel@CMoveCommand@@QAEHHHHH@Z:PROC	; CMoveCommand::GetMoveLevel
EXTRN	?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMoveCommand::CheckInterfaceToMove
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	__imp__wsprintfA:PROC
EXTRN	?CheckMainToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMoveCommand::CheckMainToMove
EXTRN	?gMoveCommand@@3VCMoveCommand@@A:BYTE		; gMoveCommand
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
; Function compile flags: /Ogtp
;	COMDAT ?SkillRecallParty@CObjUseSkill@@QAEXHH@Z
_TEXT	SEGMENT
tv153 = -280						; size = 4
tv462 = -276						; size = 4
_addy$158092 = -272					; size = 4
_bCheckEquipmentToMove$158088 = -272			; size = 4
_recallcount$ = -268					; size = 4
_count$158093 = -264					; size = 4
_bCheckMainToMove$158087 = -264				; size = 4
_msg$158104 = -260					; size = 255
_msg$158102 = -260					; size = 255
_msg$158100 = -260					; size = 255
_msg$158071 = -260					; size = 255
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_skill_level$ = 12					; size = 4
?SkillRecallParty@CObjUseSkill@@QAEXHH@Z PROC		; CObjUseSkill::SkillRecallParty, COMDAT
; _this$ = ecx

; 2237 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 2238 : 	int skillSuccess = true;
; 2239 : 	LPOBJ lpObj = &gObj[aIndex];

  00018	8b f7		 mov	 esi, edi
  0001a	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00020	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2240 : 
; 2241 : 	if(lpObj->Type != OBJ_USER && lpObj->m_RecallMon == -1)

  00026	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0002b	74 0d		 je	 SHORT $LN26@SkillRecal
  0002d	83 be cc 02 00
	00 ff		 cmp	 DWORD PTR [esi+716], -1
  00034	0f 84 fc 02 00
	00		 je	 $LN1@SkillRecal
$LN26@SkillRecal:

; 2242 : 	{
; 2243 : 		return;
; 2244 : 	}
; 2245 : 
; 2246 : 	if(this->RecallPartyCheck(aIndex,skill_level) == 0)

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _skill_level$[ebp]
  0003d	50		 push	 eax
  0003e	57		 push	 edi
  0003f	e8 00 00 00 00	 call	 ?RecallPartyCheck@CObjUseSkill@@QAEHHH@Z ; CObjUseSkill::RecallPartyCheck
  00044	85 c0		 test	 eax, eax
  00046	75 2b		 jne	 SHORT $LN16@SkillRecal

; 2247 : 	{
; 2248 : 		MsgOutput(aIndex,lMsg.Get(1238));

  00048	68 d6 04 00 00	 push	 1238			; 000004d6H
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00052	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00057	50		 push	 eax
  00058	57		 push	 edi
  00059	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0005e	83 c4 08	 add	 esp, 8
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi

; 2365 : 	}
; 2366 : }

  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 08 00	 ret	 8
$LN16@SkillRecal:

; 2249 : 		return;
; 2250 : 	}
; 2251 : 
; 2252 : 	if(gMoveCommand.CheckMainToMove(lpObj) == 0)

  00073	56		 push	 esi
  00074	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00079	e8 00 00 00 00	 call	 ?CheckMainToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckMainToMove
  0007e	85 c0		 test	 eax, eax
  00080	75 43		 jne	 SHORT $LN15@SkillRecal

; 2253 : 	{
; 2254 : 		char msg[255];
; 2255 : 		wsprintf(msg,lMsg.Get(1249));

  00082	68 e1 04 00 00	 push	 1249			; 000004e1H
$LN31@SkillRecal:
  00087	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0008c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00091	50		 push	 eax
  00092	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _msg$158071[ebp]
  00098	51		 push	 ecx
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 2256 : 		GCServerMsgStringSend(msg,lpObj->m_Index,1);

  0009f	8b 16		 mov	 edx, DWORD PTR [esi]
  000a1	6a 01		 push	 1
  000a3	52		 push	 edx
  000a4	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$158071[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000b0	83 c4 14	 add	 esp, 20			; 00000014H
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi

; 2365 : 	}
; 2366 : }

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b8	33 cd		 xor	 ecx, ebp
  000ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 08 00	 ret	 8
$LN15@SkillRecal:

; 2257 : 		return;
; 2258 : 	}
; 2259 : 
; 2260 : 	if(gMoveCommand.CheckInterfaceToMove(lpObj) == 0)

  000c5	56		 push	 esi
  000c6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  000cb	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
  000d0	85 c0		 test	 eax, eax
  000d2	75 07		 jne	 SHORT $LN14@SkillRecal

; 2261 : 	{
; 2262 : 		char msg[255];
; 2263 : 		wsprintf(msg,lMsg.Get(1239));

  000d4	68 d7 04 00 00	 push	 1239			; 000004d7H

; 2264 : 		GCServerMsgStringSend(msg,lpObj->m_Index,1);
; 2265 : 		return;

  000d9	eb ac		 jmp	 SHORT $LN31@SkillRecal
$LN14@SkillRecal:

; 2266 : 	}
; 2267 : 
; 2268 : 	int number;
; 2269 : 	int partynum;
; 2270 : 	int partycount;
; 2271 : 	LPOBJ lpPartyObj;
; 2272 : 	int recallcount;
; 2273 : 
; 2274 : 	partynum = 0;
; 2275 : 	partynum = lpObj->PartyNumber;
; 2276 : 
; 2277 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_RECALL_PARTY,lpObj->m_Index,skillSuccess);

  000db	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000dd	8b be a8 02 00
	00		 mov	 edi, DWORD PTR [esi+680]
  000e3	6a 01		 push	 1
  000e5	51		 push	 ecx
  000e6	6a 3f		 push	 63			; 0000003fH
  000e8	56		 push	 esi
  000e9	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  000ee	83 c4 10	 add	 esp, 16			; 00000010H

; 2278 : 
; 2279 : 	recallcount = 0;

  000f1	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _recallcount$[ebp], 0

; 2280 : 
; 2281 : 	if(partynum != -1)

  000fb	83 ff ff	 cmp	 edi, -1
  000fe	0f 84 32 02 00
	00		 je	 $LN1@SkillRecal

; 2282 : 	{
; 2283 : 		partycount = gParty.m_PartyS[partynum].Count;
; 2284 : 
; 2285 : 		for(int n = 0; n < MAX_USER_IN_PARTY;n ++)

  00104	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00107	c1 e0 04	 shl	 eax, 4
  0010a	05 0c 00 00 00	 add	 eax, OFFSET ?gParty@@3VPartyClass@@A+12
  0010f	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv462[ebp], eax
  00115	c7 85 e8 fe ff
	ff 05 00 00 00	 mov	 DWORD PTR tv153[ebp], 5
  0011f	53		 push	 ebx
$LL29@SkillRecal:

; 2286 : 		{
; 2287 : 			number = gParty.m_PartyS[partynum].Number[n];

  00120	8b 38		 mov	 edi, DWORD PTR [eax]

; 2288 : 
; 2289 : 			if(number >= 0)

  00122	85 ff		 test	 edi, edi
  00124	0f 88 ba 01 00
	00		 js	 $LN11@SkillRecal

; 2290 : 			{
; 2291 : 				lpPartyObj = &gObj[number];

  0012a	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00130	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2292 : 
; 2293 : 				if(lpPartyObj->m_Index != lpObj->m_Index)

  00136	8b 17		 mov	 edx, DWORD PTR [edi]
  00138	3b 16		 cmp	 edx, DWORD PTR [esi]
  0013a	0f 84 a4 01 00
	00		 je	 $LN11@SkillRecal

; 2294 : 				{
; 2295 : #if GS_CASTLE == 1
; 2296 : 					if ( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 2297 : 					{
; 2298 : 						if ( lpPartyObj->m_btCsJoinSide != lpObj->m_btCsJoinSide )
; 2299 : 						{
; 2300 : 							continue;
; 2301 : 						}
; 2302 : 					}
; 2303 : #endif
; 2304 : 					int movelevel = gMoveCommand.GetMoveLevel(lpObj->MapNumber,lpObj->X,lpObj->Y,lpPartyObj->Class);

  00140	0f b7 87 98 00
	00 00		 movzx	 eax, WORD PTR [edi+152]
  00147	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR [esi+262]
  0014e	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  00155	50		 push	 eax
  00156	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  0015d	51		 push	 ecx
  0015e	52		 push	 edx
  0015f	50		 push	 eax
  00160	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00165	e8 00 00 00 00	 call	 ?GetMoveLevel@CMoveCommand@@QAEHHHHH@Z ; CMoveCommand::GetMoveLevel

; 2305 : 					int bCheckMainToMove = gMoveCommand.CheckMainToMove(lpPartyObj);

  0016a	57		 push	 edi
  0016b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00170	8b d8		 mov	 ebx, eax
  00172	e8 00 00 00 00	 call	 ?CheckMainToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckMainToMove

; 2306 : 					int bCheckEquipmentToMove = gMoveCommand.CheckEquipmentToMove(lpPartyObj,lpObj->MapNumber);

  00177	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  0017e	51		 push	 ecx
  0017f	57		 push	 edi
  00180	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00185	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _bCheckMainToMove$158087[ebp], eax
  0018b	e8 00 00 00 00	 call	 ?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMoveCommand::CheckEquipmentToMove

; 2307 : 					int bCheckInterfaceToMove = gMoveCommand.CheckInterfaceToMove(lpPartyObj);

  00190	57		 push	 edi
  00191	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00196	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _bCheckEquipmentToMove$158088[ebp], eax
  0019c	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove

; 2308 : 
; 2309 : 					if(lpPartyObj->Level >= movelevel
; 2310 : 						&& movelevel != -1
; 2311 : 						&& bCheckMainToMove != false
; 2312 : 						&& bCheckEquipmentToMove != false
; 2313 : 						&& bCheckInterfaceToMove != false)

  001a1	0f bf 97 9c 00
	00 00		 movsx	 edx, WORD PTR [edi+156]
  001a8	3b d3		 cmp	 edx, ebx
  001aa	0f 8c fd 00 00
	00		 jl	 $LN7@SkillRecal
  001b0	83 fb ff	 cmp	 ebx, -1
  001b3	0f 84 f4 00 00
	00		 je	 $LN7@SkillRecal
  001b9	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR _bCheckMainToMove$158087[ebp], 0
  001c0	0f 84 e7 00 00
	00		 je	 $LN7@SkillRecal
  001c6	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _bCheckEquipmentToMove$158088[ebp], 0
  001cd	0f 84 da 00 00
	00		 je	 $LN7@SkillRecal
  001d3	85 c0		 test	 eax, eax
  001d5	0f 84 d2 00 00
	00		 je	 $LN7@SkillRecal

; 2314 : 					{
; 2315 : 						int addx;
; 2316 : 						int addy;
; 2317 : 						int count = 50;

  001db	c7 85 f8 fe ff
	ff 32 00 00 00	 mov	 DWORD PTR _count$158093[ebp], 50 ; 00000032H
$LL6@SkillRecal:

; 2318 : 						int Find = 0;
; 2319 : 
; 2320 : 						while(count--)

  001e5	ff 8d f8 fe ff
	ff		 dec	 DWORD PTR _count$158093[ebp]

; 2321 : 						{
; 2322 : 							addx = lpObj->X + rand()%9 - 4;

  001eb	e8 00 00 00 00	 call	 _rand
  001f0	99		 cdq
  001f1	b9 09 00 00 00	 mov	 ecx, 9
  001f6	f7 f9		 idiv	 ecx
  001f8	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR [esi+260]
  001ff	8d 5c 02 fc	 lea	 ebx, DWORD PTR [edx+eax-4]

; 2323 : 							addy = lpObj->Y + rand()%9 - 4;

  00203	e8 00 00 00 00	 call	 _rand
  00208	99		 cdq
  00209	b9 09 00 00 00	 mov	 ecx, 9
  0020e	f7 f9		 idiv	 ecx
  00210	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]

; 2324 : 
; 2325 : 							if(gObjCheckTeleportArea(lpObj->m_Index,addx,addy))

  00217	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00219	8d 44 02 fc	 lea	 eax, DWORD PTR [edx+eax-4]
  0021d	50		 push	 eax
  0021e	53		 push	 ebx
  0021f	51		 push	 ecx
  00220	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _addy$158092[ebp], eax
  00226	e8 00 00 00 00	 call	 ?gObjCheckTeleportArea@@YAHHEE@Z ; gObjCheckTeleportArea
  0022b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022e	85 c0		 test	 eax, eax
  00230	75 18		 jne	 SHORT $LN28@SkillRecal

; 2318 : 						int Find = 0;
; 2319 : 
; 2320 : 						while(count--)

  00232	39 85 f8 fe ff
	ff		 cmp	 DWORD PTR _count$158093[ebp], eax
  00238	75 ab		 jne	 SHORT $LL6@SkillRecal

; 2326 : 							{
; 2327 : 								Find = 1;
; 2328 : 								break;
; 2329 : 							}
; 2330 : 						}
; 2331 : 
; 2332 : 						if(Find == 0)
; 2333 : 						{
; 2334 : 							addx = lpObj->X;

  0023a	0f bf 9e 04 01
	00 00		 movsx	 ebx, WORD PTR [esi+260]

; 2335 : 							addy = lpObj->Y;

  00241	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  00248	eb 06		 jmp	 SHORT $LN3@SkillRecal
$LN28@SkillRecal:
  0024a	8a 85 f0 fe ff
	ff		 mov	 al, BYTE PTR _addy$158092[ebp]
$LN3@SkillRecal:

; 2336 : 						}
; 2337 : 
; 2338 : 						lpPartyObj->SkillRecallParty_Time = 7;

  00250	ba 07 00 00 00	 mov	 edx, 7
  00255	66 89 97 b0 10
	00 00		 mov	 WORD PTR [edi+4272], dx

; 2339 : 						lpPartyObj->SkillRecallParty_MapNumber = lpObj->MapNumber;

  0025c	8a 8e 09 01 00
	00		 mov	 cl, BYTE PTR [esi+265]
  00262	88 8f b2 10 00
	00		 mov	 BYTE PTR [edi+4274], cl

; 2340 : 						lpPartyObj->SkillRecallParty_X = addx;
; 2341 : 						lpPartyObj->SkillRecallParty_Y = addy;
; 2342 : 
; 2343 : 						char msg[255];
; 2344 : 
; 2345 : 						wsprintf(msg,lMsg.Get(1251));

  00268	68 e3 04 00 00	 push	 1251			; 000004e3H
  0026d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00272	88 9f b3 10 00
	00		 mov	 BYTE PTR [edi+4275], bl
  00278	88 87 b4 10 00
	00		 mov	 BYTE PTR [edi+4276], al
  0027e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00283	50		 push	 eax
  00284	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _msg$158100[ebp]
  0028a	52		 push	 edx
  0028b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 2346 : 						GCServerMsgStringSend(msg,lpPartyObj->m_Index,1);

  00291	8b 07		 mov	 eax, DWORD PTR [edi]
  00293	6a 01		 push	 1
  00295	50		 push	 eax
  00296	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _msg$158100[ebp]
  0029c	51		 push	 ecx
  0029d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  002a2	83 c4 14	 add	 esp, 20			; 00000014H

; 2347 : 						recallcount++;

  002a5	ff 85 f4 fe ff
	ff		 inc	 DWORD PTR _recallcount$[ebp]

; 2348 : 					}
; 2349 : 					else

  002ab	eb 31		 jmp	 SHORT $LN30@SkillRecal
$LN7@SkillRecal:

; 2350 : 					{
; 2351 : 						char msg[255];
; 2352 : 						wsprintf(msg,lMsg.Get(1252));

  002ad	68 e4 04 00 00	 push	 1252			; 000004e4H
  002b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002b7	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  002bc	50		 push	 eax
  002bd	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _msg$158102[ebp]
  002c3	52		 push	 edx
  002c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 2353 : 						GCServerMsgStringSend(msg,lpPartyObj->m_Index,1);

  002ca	8b 07		 mov	 eax, DWORD PTR [edi]
  002cc	6a 01		 push	 1
  002ce	50		 push	 eax
  002cf	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _msg$158102[ebp]
  002d5	51		 push	 ecx
  002d6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  002db	83 c4 14	 add	 esp, 20			; 00000014H
$LN30@SkillRecal:
  002de	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv462[ebp]
$LN11@SkillRecal:

; 2282 : 	{
; 2283 : 		partycount = gParty.m_PartyS[partynum].Count;
; 2284 : 
; 2285 : 		for(int n = 0; n < MAX_USER_IN_PARTY;n ++)

  002e4	83 c0 04	 add	 eax, 4
  002e7	ff 8d e8 fe ff
	ff		 dec	 DWORD PTR tv153[ebp]
  002ed	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv462[ebp], eax
  002f3	0f 85 27 fe ff
	ff		 jne	 $LL29@SkillRecal

; 2354 : 					}
; 2355 : 				}
; 2356 : 			}
; 2357 : 		}
; 2358 : 	}
; 2359 : 
; 2360 : 	if(recallcount != 0)

  002f9	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _recallcount$[ebp]
  002ff	5b		 pop	 ebx
  00300	85 c0		 test	 eax, eax
  00302	74 32		 je	 SHORT $LN1@SkillRecal

; 2361 : 	{
; 2362 : 		char msg[255];
; 2363 : 		wsprintf(msg,lMsg.Get(1244),recallcount);

  00304	50		 push	 eax
  00305	68 dc 04 00 00	 push	 1244			; 000004dcH
  0030a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0030f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00314	50		 push	 eax
  00315	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _msg$158104[ebp]
  0031b	52		 push	 edx
  0031c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 2364 : 		GCServerMsgStringSend(msg,lpObj->m_Index,1);

  00322	8b 06		 mov	 eax, DWORD PTR [esi]
  00324	6a 01		 push	 1
  00326	50		 push	 eax
  00327	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _msg$158104[ebp]
  0032d	51		 push	 ecx
  0032e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00333	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@SkillRecal:

; 2365 : 	}
; 2366 : }

  00336	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00339	5f		 pop	 edi
  0033a	33 cd		 xor	 ecx, ebp
  0033c	5e		 pop	 esi
  0033d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00342	8b e5		 mov	 esp, ebp
  00344	5d		 pop	 ebp
  00345	c2 08 00	 ret	 8
?SkillRecallParty@CObjUseSkill@@QAEXHH@Z ENDP		; CObjUseSkill::SkillRecallParty
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?SkillAddCriticalDamage@CObjUseSkill@@QAEXHH@Z	; CObjUseSkill::SkillAddCriticalDamage
; Function compile flags: /Ogtp
;	COMDAT ?SkillAddCriticalDamage@CObjUseSkill@@QAEXHH@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -36					; size = 4
tv368 = -32						; size = 4
_SkillTime$ = -32					; size = 4
_partynum$ = -32					; size = 4
_n$158133 = -28						; size = 4
_n$158122 = -28						; size = 4
_ApplyPartyIndex$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_skill_level$ = 12					; size = 4
?SkillAddCriticalDamage@CObjUseSkill@@QAEXHH@Z PROC	; CObjUseSkill::SkillAddCriticalDamage, COMDAT
; _this$ = ecx

; 2372 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 2441 : 	}
; 2442 : 	else
; 2443 : 	{
; 2444 : 		for(int n = 0;n < MAX_USER_IN_PARTY;n++)

  00014	89 7d dc	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], edi
  00017	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0001d	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00023	66 83 7f 60 01	 cmp	 WORD PTR [edi+96], 1
  00028	74 0d		 je	 SHORT $LN22@SkillAddCr

; 2373 : 	int skillSuccess = true;
; 2374 : 	LPOBJ lpObj = &gObj[aIndex];
; 2375 : 	int number;
; 2376 : 
; 2377 : /*#if (FOREIGN_GAMESERVER==1)
; 2378 : 	if (szAuthKey[14] != AUTHKEY14 )
; 2379 : 	{
; 2380 : 		DestroyGIocp();
; 2381 : 	}
; 2382 : #endif*/
; 2383 : 
; 2384 : 	if(lpObj->Type != OBJ_USER && lpObj->m_RecallMon == -1)

  0002a	83 bf cc 02 00
	00 ff		 cmp	 DWORD PTR [edi+716], -1
  00031	0f 84 c1 01 00
	00		 je	 $LN2@SkillAddCr
$LN22@SkillAddCr:

; 2385 : 	{
; 2386 : 		return;
; 2387 : 	}
; 2388 : 
; 2389 : 	if(lpObj->Class != CLASS_DARKLORD)

  00037	66 83 bf 98 00
	00 00 04	 cmp	 WORD PTR [edi+152], 4
  0003f	0f 85 b3 01 00
	00		 jne	 $LN2@SkillAddCr

; 2390 : 	{
; 2391 : 		return;
; 2392 : 	}
; 2393 : 
; 2394 : 
; 2395 : 	int partynum = 0;
; 2396 : 	int totallevel = 0;
; 2397 : 	int partycount;
; 2398 : 	int dis;
; 2399 : 
; 2400 : 	int ApplyPartyIndex[MAX_USER_IN_PARTY];
; 2401 : 	LPOBJ lpPartyObj;
; 2402 : 	memset(ApplyPartyIndex,-1,sizeof(ApplyPartyIndex));

  00045	83 c8 ff	 or	 eax, -1
  00048	53		 push	 ebx
  00049	56		 push	 esi

; 2403 : 
; 2404 : 	partynum = lpObj->PartyNumber;

  0004a	8b b7 a8 02 00
	00		 mov	 esi, DWORD PTR [edi+680]
  00050	89 45 e8	 mov	 DWORD PTR _ApplyPartyIndex$[ebp], eax
  00053	89 45 ec	 mov	 DWORD PTR _ApplyPartyIndex$[ebp+4], eax
  00056	89 45 f0	 mov	 DWORD PTR _ApplyPartyIndex$[ebp+8], eax
  00059	89 45 f4	 mov	 DWORD PTR _ApplyPartyIndex$[ebp+12], eax
  0005c	89 45 f8	 mov	 DWORD PTR _ApplyPartyIndex$[ebp+16], eax
  0005f	89 75 e0	 mov	 DWORD PTR _partynum$[ebp], esi

; 2405 : 
; 2406 : 	if(partynum != -1)

  00062	3b f0		 cmp	 esi, eax
  00064	74 64		 je	 SHORT $LN10@SkillAddCr

; 2407 : 	{
; 2408 : 		partycount = gParty.m_PartyS[partynum].Count;
; 2409 : 
; 2410 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00066	8d 1c 76	 lea	 ebx, DWORD PTR [esi+esi*2]
  00069	c1 e3 04	 shl	 ebx, 4
  0006c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _n$158122[ebp], 0
  00073	81 c3 0c 00 00
	00		 add	 ebx, OFFSET ?gParty@@3VPartyClass@@A+12
  00079	8d a4 24 00 00
	00 00		 npad	 7
$LL25@SkillAddCr:

; 2411 : 		{
; 2412 : 			number = gParty.m_PartyS[partynum].Number[n];

  00080	8b 03		 mov	 eax, DWORD PTR [ebx]

; 2413 : 
; 2414 : 			if(number >= 0)

  00082	85 c0		 test	 eax, eax
  00084	78 32		 js	 SHORT $LN11@SkillAddCr

; 2415 : 			{
; 2416 : 				lpPartyObj = &gObj[number];

  00086	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0008c	8d b0 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]

; 2417 : 
; 2418 : 				if(lpObj->MapNumber == lpPartyObj->MapNumber)

  00092	8a 87 09 01 00
	00		 mov	 al, BYTE PTR [edi+265]
  00098	3a 86 09 01 00
	00		 cmp	 al, BYTE PTR [esi+265]
  0009e	75 18		 jne	 SHORT $LN11@SkillAddCr

; 2419 : 				{
; 2420 : 					dis = gObjCalDistance(lpObj,&gObj[number]);

  000a0	56		 push	 esi
  000a1	57		 push	 edi
  000a2	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000a7	83 c4 08	 add	 esp, 8

; 2421 : 					if(dis < 10)

  000aa	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000ad	7d 09		 jge	 SHORT $LN11@SkillAddCr

; 2422 : 					{
; 2423 : 						ApplyPartyIndex[n] = lpPartyObj->m_Index;

  000af	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b1	8b 55 e4	 mov	 edx, DWORD PTR _n$158122[ebp]
  000b4	89 4c 95 e8	 mov	 DWORD PTR _ApplyPartyIndex$[ebp+edx*4], ecx
$LN11@SkillAddCr:

; 2407 : 	{
; 2408 : 		partycount = gParty.m_PartyS[partynum].Count;
; 2409 : 
; 2410 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  000b8	8b 45 e4	 mov	 eax, DWORD PTR _n$158122[ebp]
  000bb	40		 inc	 eax
  000bc	83 c3 04	 add	 ebx, 4
  000bf	89 45 e4	 mov	 DWORD PTR _n$158122[ebp], eax
  000c2	83 f8 05	 cmp	 eax, 5
  000c5	7c b9		 jl	 SHORT $LL25@SkillAddCr
  000c7	8b 75 e0	 mov	 esi, DWORD PTR _partynum$[ebp]
$LN10@SkillAddCr:

; 2424 : 					}
; 2425 : 				}
; 2426 : 			}
; 2427 : 		}
; 2428 : 	}
; 2429 : 
; 2430 : 	int addcriticaldamagevalue = (lpObj->Leadership + lpObj->AddLeadership)/25 + (lpObj->Energy + lpObj->AddEnergy)/30;

  000ca	0f bf 87 e6 00
	00 00		 movsx	 eax, WORD PTR [edi+230]
  000d1	0f b7 8f ba 00
	00 00		 movzx	 ecx, WORD PTR [edi+186]
  000d8	0f b7 97 da 00
	00 00		 movzx	 edx, WORD PTR [edi+218]
  000df	03 c8		 add	 ecx, eax
  000e1	0f b7 87 d8 00
	00 00		 movzx	 eax, WORD PTR [edi+216]
  000e8	03 d0		 add	 edx, eax
  000ea	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000ef	f7 ea		 imul	 edx
  000f1	c1 fa 03	 sar	 edx, 3
  000f4	8b c2		 mov	 eax, edx
  000f6	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000f9	03 c2		 add	 eax, edx
  000fb	89 45 e0	 mov	 DWORD PTR tv368[ebp], eax
  000fe	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00103	f7 e9		 imul	 ecx
  00105	8b 45 e0	 mov	 eax, DWORD PTR tv368[ebp]
  00108	03 d1		 add	 edx, ecx
  0010a	c1 fa 04	 sar	 edx, 4
  0010d	8b da		 mov	 ebx, edx
  0010f	03 c2		 add	 eax, edx
  00111	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00114	03 d8		 add	 ebx, eax

; 2431 : 	int SkillTime = (lpObj->Energy + lpObj->AddEnergy)/10 + 60;

  00116	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0011b	f7 e9		 imul	 ecx
  0011d	c1 fa 02	 sar	 edx, 2
  00120	8b ca		 mov	 ecx, edx
  00122	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00125	8d 54 0a 3c	 lea	 edx, DWORD PTR [edx+ecx+60]
  00129	89 55 e0	 mov	 DWORD PTR _SkillTime$[ebp], edx

; 2432 : 
; 2433 : 	if(partynum == -1)

  0012c	83 fe ff	 cmp	 esi, -1
  0012f	75 55		 jne	 SHORT $LN6@SkillAddCr

; 2434 : 	{
; 2435 : 		lpObj->SkillAddCriticalDamageTime = SkillTime;
; 2436 : 		lpObj->SkillAddCriticalDamage = addcriticaldamagevalue;
; 2437 : 		lpObj->m_ViewSkillState |= 2048;

  00131	81 8f c4 01 00
	00 00 08 00 00	 or	 DWORD PTR [edi+452], 2048 ; 00000800H

; 2438 : 
; 2439 : 		MsgOutput(aIndex,lMsg.Get(1240),SkillTime);

  0013b	52		 push	 edx
  0013c	68 d8 04 00 00	 push	 1240			; 000004d8H
  00141	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00146	66 89 97 b6 10
	00 00		 mov	 WORD PTR [edi+4278], dx
  0014d	66 89 9f b8 10
	00 00		 mov	 WORD PTR [edi+4280], bx
  00154	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00159	8b 55 dc	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0015c	50		 push	 eax
  0015d	52		 push	 edx
  0015e	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 2440 : 		GCMagicAttackNumberSend(lpObj,AT_SKILL_ADD_CRITICALDAMAGE,lpObj->m_Index,skillSuccess);

  00163	8b 07		 mov	 eax, DWORD PTR [edi]
  00165	6a 01		 push	 1
  00167	50		 push	 eax
  00168	6a 40		 push	 64			; 00000040H
  0016a	57		 push	 edi
  0016b	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  00170	83 c4 1c	 add	 esp, 28			; 0000001cH
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx
  00175	5f		 pop	 edi

; 2456 : 			}
; 2457 : 		}
; 2458 : 	}
; 2459 : }

  00176	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00179	33 cd		 xor	 ecx, ebp
  0017b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c2 08 00	 ret	 8
$LN6@SkillAddCr:

; 2441 : 	}
; 2442 : 	else
; 2443 : 	{
; 2444 : 		for(int n = 0;n < MAX_USER_IN_PARTY;n++)

  00186	33 c0		 xor	 eax, eax
  00188	89 45 e4	 mov	 DWORD PTR _n$158133[ebp], eax
  0018b	eb 03 8d 49 00	 npad	 5
$LL4@SkillAddCr:

; 2445 : 		{
; 2446 : 			if(ApplyPartyIndex[n] != -1)

  00190	8b 74 85 e8	 mov	 esi, DWORD PTR _ApplyPartyIndex$[ebp+eax*4]
  00194	83 fe ff	 cmp	 esi, -1
  00197	74 54		 je	 SHORT $LN3@SkillAddCr

; 2447 : 			{
; 2448 : 				lpPartyObj = &gObj[ApplyPartyIndex[n]];
; 2449 : 
; 2450 : 				lpPartyObj->SkillAddCriticalDamageTime = SkillTime;

  00199	8b 45 e0	 mov	 eax, DWORD PTR _SkillTime$[ebp]
  0019c	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  001a2	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2451 : 				lpPartyObj->SkillAddCriticalDamage = addcriticaldamagevalue;
; 2452 : 				lpPartyObj->m_ViewSkillState |= 2048;

  001a8	81 8e c4 01 00
	00 00 08 00 00	 or	 DWORD PTR [esi+452], 2048 ; 00000800H

; 2453 : 
; 2454 : 				MsgOutput(aIndex,lMsg.Get(1240),SkillTime);

  001b2	50		 push	 eax
  001b3	68 d8 04 00 00	 push	 1240			; 000004d8H
  001b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001bd	66 89 86 b6 10
	00 00		 mov	 WORD PTR [esi+4278], ax
  001c4	66 89 9e b8 10
	00 00		 mov	 WORD PTR [esi+4280], bx
  001cb	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001d0	8b 4d dc	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  001d3	50		 push	 eax
  001d4	51		 push	 ecx
  001d5	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 2455 : 				GCMagicAttackNumberSend(lpObj,AT_SKILL_ADD_CRITICALDAMAGE,lpPartyObj->m_Index,skillSuccess);

  001da	8b 16		 mov	 edx, DWORD PTR [esi]
  001dc	6a 01		 push	 1
  001de	52		 push	 edx
  001df	6a 40		 push	 64			; 00000040H
  001e1	57		 push	 edi
  001e2	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  001e7	8b 45 e4	 mov	 eax, DWORD PTR _n$158133[ebp]
  001ea	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN3@SkillAddCr:

; 2441 : 	}
; 2442 : 	else
; 2443 : 	{
; 2444 : 		for(int n = 0;n < MAX_USER_IN_PARTY;n++)

  001ed	40		 inc	 eax
  001ee	89 45 e4	 mov	 DWORD PTR _n$158133[ebp], eax
  001f1	83 f8 05	 cmp	 eax, 5
  001f4	7c 9a		 jl	 SHORT $LL4@SkillAddCr
  001f6	5e		 pop	 esi
  001f7	5b		 pop	 ebx
$LN2@SkillAddCr:

; 2456 : 			}
; 2457 : 		}
; 2458 : 	}
; 2459 : }

  001f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fb	33 cd		 xor	 ecx, ebp
  001fd	5f		 pop	 edi
  001fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00203	8b e5		 mov	 esp, ebp
  00205	5d		 pop	 ebp
  00206	c2 08 00	 ret	 8
?SkillAddCriticalDamage@CObjUseSkill@@QAEXHH@Z ENDP	; CObjUseSkill::SkillAddCriticalDamage
_TEXT	ENDS
PUBLIC	__real@4014000000000000
PUBLIC	__real@4034000000000000
PUBLIC	??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CFs@ ; `string'
PUBLIC	??_C@_0BA@DNENMBIK@ObjUseSkill?4cpp?$AA@	; `string'
PUBLIC	?DecPartyMemberHPandMP@@YAHPAUOBJECTSTRUCT@@@Z	; DecPartyMemberHPandMP
EXTRN	?GCManaSend@@YAXHHEEH@Z:PROC			; GCManaSend
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@4034000000000000
CONST	SEGMENT
__real@4034000000000000 DQ 04034000000000000r	; 20
CONST	ENDS
;	COMDAT ??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CFs@
CONST	SEGMENT
??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CFs@ DB 'error : De'
	DB	'cPartyMemberHPandMP %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DNENMBIK@ObjUseSkill?4cpp?$AA@
CONST	SEGMENT
??_C@_0BA@DNENMBIK@ObjUseSkill?4cpp?$AA@ DB 'ObjUseSkill.cpp', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DecPartyMemberHPandMP@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv313 = -8						; size = 4
tv304 = -8						; size = 4
tv261 = -8						; size = 4
tv182 = -4						; size = 4
_retcount$ = 8						; size = 4
_lpObj$ = 8						; size = 4
?DecPartyMemberHPandMP@@YAHPAUOBJECTSTRUCT@@@Z PROC	; DecPartyMemberHPandMP, COMDAT

; 2550 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 2551 : 	LPOBJ lpPartyObj;
; 2552 : 	int partynum = lpObj->PartyNumber;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  0000a	8b 83 a8 02 00
	00		 mov	 eax, DWORD PTR [ebx+680]

; 2553 : 
; 2554 : 	if(OBJMAX_RANGE(partynum)==false)

  00010	85 c0		 test	 eax, eax
  00012	78 0e		 js	 SHORT $LN14@DecPartyMe
  00014	33 c9		 xor	 ecx, ecx
  00016	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  0001b	0f 9e c1	 setle	 cl
  0001e	85 c9		 test	 ecx, ecx
  00020	75 20		 jne	 SHORT $LN7@DecPartyMe
$LN14@DecPartyMe:

; 2555 : 	{
; 2556 : 		LogAdd(LOG_BLACK, "error : DecPartyMemberHPandMP %s %d",__FILE__,__LINE__);

  00022	68 fc 09 00 00	 push	 2556			; 000009fcH
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DNENMBIK@ObjUseSkill?4cpp?$AA@
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CFs@
  00031	6a 00		 push	 0
  00033	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00038	83 c4 10	 add	 esp, 16			; 00000010H

; 2557 : 		return false;

  0003b	33 c0		 xor	 eax, eax
  0003d	5b		 pop	 ebx

; 2593 : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN7@DecPartyMe:
  00042	56		 push	 esi
  00043	57		 push	 edi

; 2558 : 	}
; 2559 : 
; 2560 : 	int partycount = gParty.m_PartyS[partynum].Count;
; 2561 : 	int retcount = 0;

  00044	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  00047	c1 e7 04	 shl	 edi, 4
  0004a	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _retcount$[ebp], 0
  00051	81 c7 0c 00 00
	00		 add	 edi, OFFSET ?gParty@@3VPartyClass@@A+12
  00057	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR tv182[ebp], 5
  0005e	8b ff		 npad	 2
$LL17@DecPartyMe:

; 2564 : 	{
; 2565 : 		int number = gParty.m_PartyS[partynum].Number[n];

  00060	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2566 : 
; 2567 : 		if(number >= 0)

  00062	85 c9		 test	 ecx, ecx
  00064	0f 88 d5 00 00
	00		 js	 $LN5@DecPartyMe

; 2568 : 		{
; 2569 : 			lpPartyObj = &gObj[number];
; 2570 : 
; 2571 : 			if(lpObj->MapNumber == lpPartyObj->MapNumber && lpObj->m_Index != number)

  0006a	8a 93 09 01 00
	00		 mov	 dl, BYTE PTR [ebx+265]
  00070	8b c1		 mov	 eax, ecx
  00072	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00078	3a 90 09 01 00
	00		 cmp	 dl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  0007e	0f 85 bb 00 00
	00		 jne	 $LN5@DecPartyMe
  00084	39 0b		 cmp	 DWORD PTR [ebx], ecx
  00086	0f 84 b3 00 00
	00		 je	 $LN5@DecPartyMe

; 2572 : 			{
; 2573 : 				int dis = gObjCalDistance(lpObj,&gObj[number]);

  0008c	8d b0 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  00092	56		 push	 esi
  00093	53		 push	 ebx
  00094	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00099	83 c4 08	 add	 esp, 8

; 2574 : 				if(dis < 10)

  0009c	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0009f	0f 8d 9a 00 00
	00		 jge	 $LN5@DecPartyMe

; 2575 : 				{
; 2576 : 					lpPartyObj = &gObj[number];
; 2577 : 
; 2578 : 					int declife = lpPartyObj->Life * 20.0f / 100.0f;

  000a5	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  000ab	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4034000000000000
  000b1	d8 c9		 fmul	 ST(0), ST(1)
  000b3	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4059000000000000
  000b9	dc f9		 fdiv	 ST(1), ST(0)

; 2579 : 					int decmana = lpPartyObj->Mana * 5.0f / 100.0f;
; 2580 : 
; 2581 : 					lpPartyObj->Life = lpPartyObj->Life - declife;

  000bb	d9 c9		 fxch	 ST(1)
  000bd	e8 00 00 00 00	 call	 __ftol2_sse
  000c2	89 45 f8	 mov	 DWORD PTR tv313[ebp], eax
  000c5	db 45 f8	 fild	 DWORD PTR tv313[ebp]
  000c8	de ea		 fsubp	 ST(2), ST(0)
  000ca	d9 c9		 fxch	 ST(1)
  000cc	d9 5d f8	 fstp	 DWORD PTR tv261[ebp]
  000cf	d9 45 f8	 fld	 DWORD PTR tv261[ebp]
  000d2	d9 96 bc 00 00
	00		 fst	 DWORD PTR [esi+188]
  000d8	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  000de	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4014000000000000
  000e4	d8 c9		 fmul	 ST(0), ST(1)
  000e6	de f3		 fdivrp	 ST(3), ST(0)

; 2582 : 					lpPartyObj->Mana = lpPartyObj->Mana - decmana;

  000e8	d9 ca		 fxch	 ST(2)
  000ea	e8 00 00 00 00	 call	 __ftol2_sse
  000ef	89 45 f8	 mov	 DWORD PTR tv304[ebp], eax
  000f2	db 45 f8	 fild	 DWORD PTR tv304[ebp]

; 2583 : 
; 2584 : 					GCReFillSend(lpPartyObj->m_Index,lpPartyObj->Life,0xFF,0);

  000f5	6a 00		 push	 0
  000f7	68 ff 00 00 00	 push	 255			; 000000ffH
  000fc	de ea		 fsubp	 ST(2), ST(0)
  000fe	d9 c9		 fxch	 ST(1)
  00100	d9 9e d0 00 00
	00		 fstp	 DWORD PTR [esi+208]
  00106	e8 00 00 00 00	 call	 __ftol2_sse
  0010b	50		 push	 eax
  0010c	8b 06		 mov	 eax, DWORD PTR [esi]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend

; 2585 : 					GCManaSend(lpPartyObj->m_Index,lpPartyObj->Mana,0xFF,0,lpPartyObj->BP);

  00114	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  0011a	8b 8e e8 00 00
	00		 mov	 ecx, DWORD PTR [esi+232]
  00120	83 c4 10	 add	 esp, 16			; 00000010H
  00123	51		 push	 ecx
  00124	6a 00		 push	 0
  00126	68 ff 00 00 00	 push	 255			; 000000ffH
  0012b	e8 00 00 00 00	 call	 __ftol2_sse
  00130	8b 16		 mov	 edx, DWORD PTR [esi]
  00132	50		 push	 eax
  00133	52		 push	 edx
  00134	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  00139	83 c4 14	 add	 esp, 20			; 00000014H

; 2586 : 					retcount++;

  0013c	ff 45 08	 inc	 DWORD PTR _retcount$[ebp]
$LN5@DecPartyMe:

; 2562 : 
; 2563 : 	for(int n = 0; n < MAX_USER_IN_PARTY;n++)

  0013f	83 c7 04	 add	 edi, 4
  00142	ff 4d fc	 dec	 DWORD PTR tv182[ebp]
  00145	0f 85 15 ff ff
	ff		 jne	 $LL17@DecPartyMe

; 2587 : 				}
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : 
; 2592 : 	return retcount;

  0014b	8b 45 08	 mov	 eax, DWORD PTR _retcount$[ebp]
  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	5b		 pop	 ebx

; 2593 : }

  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c3		 ret	 0
?DecPartyMemberHPandMP@@YAHPAUOBJECTSTRUCT@@@Z ENDP	; DecPartyMemberHPandMP
_TEXT	ENDS
PUBLIC	?SkillSummon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillSummon
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gObjGetRandomFreeLocation@@YAHHAAE0HHH@Z:PROC	; gObjGetRandomFreeLocation
; Function compile flags: /Ogtp
;	COMDAT ?SkillSummon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_result$158230 = -12					; size = 4
_bSummonSuccess$ = -7					; size = 1
_cSummonX$ = -2						; size = 1
_cSY$158226 = -1					; size = 1
_aIndex$ = 8						; size = 4
_cSX$158225 = 11					; size = 1
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillSummon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::SkillSummon, COMDAT
; _this$ = ecx

; 2599 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2600 : 	if(OBJMAX_RANGE(aIndex)==false)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	85 c0		 test	 eax, eax
  0000b	78 0e		 js	 SHORT $LN22@SkillSummo
  0000d	33 c9		 xor	 ecx, ecx
  0000f	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00014	0f 9e c1	 setle	 cl
  00017	85 c9		 test	 ecx, ecx
  00019	75 08		 jne	 SHORT $LN15@SkillSummo
$LN22@SkillSummo:

; 2601 : 	{
; 2602 : 		return false;

  0001b	33 c0		 xor	 eax, eax

; 2682 : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
$LN15@SkillSummo:

; 2603 : 	}
; 2604 : 
; 2605 : 	int iSummonCount = 1;
; 2606 : 	int iSummonMonterType = 0;
; 2607 : 	BYTE bDoSummon = 1;
; 2608 : 	BYTE bSummonSuccess = 0;
; 2609 : 	BYTE cSummonX = 0;
; 2610 : 	BYTE cSummonY = 0;
; 2611 : 
; 2612 : 	LPOBJ lpObj = &gObj[aIndex];

  00023	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00029	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002e	53		 push	 ebx
  0002f	8b d8		 mov	 ebx, eax

; 2613 : 
; 2614 : 	switch(lpObj->Class)

  00031	0f b7 83 98 00
	00 00		 movzx	 eax, WORD PTR [ebx+152]
  00038	57		 push	 edi
  00039	05 5f ff ff ff	 add	 eax, -161		; ffffff5fH
  0003e	33 ff		 xor	 edi, edi
  00040	c6 45 f9 00	 mov	 BYTE PTR _bSummonSuccess$[ebp], 0
  00044	c6 45 fe 00	 mov	 BYTE PTR _cSummonX$[ebp], 0
  00048	83 f8 72	 cmp	 eax, 114		; 00000072H
  0004b	0f 87 d7 00 00
	00		 ja	 $LN6@SkillSummo
  00051	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN23@SkillSummo[eax]
  00058	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@SkillSummo[eax*4]
$LN12@SkillSummo:

; 2615 : 	{
; 2616 : 	case 161:
; 2617 : 		iSummonMonterType = rand()%2+ 147;

  0005f	e8 00 00 00 00	 call	 _rand
  00064	8b f8		 mov	 edi, eax
  00066	81 e7 01 00 00
	80		 and	 edi, -2147483647	; 80000001H
  0006c	79 05		 jns	 SHORT $LN27@SkillSummo
  0006e	4f		 dec	 edi
  0006f	83 cf fe	 or	 edi, -2			; fffffffeH
  00072	47		 inc	 edi
$LN27@SkillSummo:
  00073	81 c7 93 00 00
	00		 add	 edi, 147		; 00000093H

; 2618 : 		bDoSummon = (rand()%15) ? false : true;
; 2619 : 		break;

  00079	e9 8a 00 00 00	 jmp	 $LN34@SkillSummo
$LN11@SkillSummo:

; 2620 : 	case 181:
; 2621 : 		iSummonMonterType = rand()%2+ 177;

  0007e	e8 00 00 00 00	 call	 _rand
  00083	8b f8		 mov	 edi, eax
  00085	81 e7 01 00 00
	80		 and	 edi, -2147483647	; 80000001H
  0008b	79 05		 jns	 SHORT $LN28@SkillSummo
  0008d	4f		 dec	 edi
  0008e	83 cf fe	 or	 edi, -2			; fffffffeH
  00091	47		 inc	 edi
$LN28@SkillSummo:
  00092	81 c7 b1 00 00
	00		 add	 edi, 177		; 000000b1H

; 2622 : 		bDoSummon = (rand()%15) ? false : true;
; 2623 : 		break;

  00098	eb 6e		 jmp	 SHORT $LN34@SkillSummo
$LN10@SkillSummo:

; 2624 : 	case 189:
; 2625 : 		iSummonMonterType = rand()%2+ 185;

  0009a	e8 00 00 00 00	 call	 _rand
  0009f	8b f8		 mov	 edi, eax
  000a1	81 e7 01 00 00
	80		 and	 edi, -2147483647	; 80000001H
  000a7	79 05		 jns	 SHORT $LN29@SkillSummo
  000a9	4f		 dec	 edi
  000aa	83 cf fe	 or	 edi, -2			; fffffffeH
  000ad	47		 inc	 edi
$LN29@SkillSummo:
  000ae	81 c7 b9 00 00
	00		 add	 edi, 185		; 000000b9H

; 2626 : 		bDoSummon = (rand()%15) ? false : true;
; 2627 : 		break;

  000b4	eb 52		 jmp	 SHORT $LN34@SkillSummo
$LN9@SkillSummo:

; 2628 : 	case 197:
; 2629 : 		iSummonMonterType = rand()%2+ 193;

  000b6	e8 00 00 00 00	 call	 _rand
  000bb	8b f8		 mov	 edi, eax
  000bd	81 e7 01 00 00
	80		 and	 edi, -2147483647	; 80000001H
  000c3	79 05		 jns	 SHORT $LN30@SkillSummo
  000c5	4f		 dec	 edi
  000c6	83 cf fe	 or	 edi, -2			; fffffffeH
  000c9	47		 inc	 edi
$LN30@SkillSummo:
  000ca	81 c7 c1 00 00
	00		 add	 edi, 193		; 000000c1H

; 2630 : 		bDoSummon = (rand()%15) ? false : true;
; 2631 : 		break;

  000d0	eb 36		 jmp	 SHORT $LN34@SkillSummo
$LN8@SkillSummo:

; 2632 : 	case 267:
; 2633 : 		iSummonMonterType = rand()%2+ 263;

  000d2	e8 00 00 00 00	 call	 _rand
  000d7	8b f8		 mov	 edi, eax
  000d9	81 e7 01 00 00
	80		 and	 edi, -2147483647	; 80000001H
  000df	79 05		 jns	 SHORT $LN31@SkillSummo
  000e1	4f		 dec	 edi
  000e2	83 cf fe	 or	 edi, -2			; fffffffeH
  000e5	47		 inc	 edi
$LN31@SkillSummo:
  000e6	81 c7 07 01 00
	00		 add	 edi, 263		; 00000107H

; 2634 : 		bDoSummon = (rand()%15) ? false : true;
; 2635 : 		break;

  000ec	eb 1a		 jmp	 SHORT $LN34@SkillSummo
$LN7@SkillSummo:

; 2636 : 	case 275:
; 2637 : 		iSummonMonterType = rand()%2+ 271;

  000ee	e8 00 00 00 00	 call	 _rand
  000f3	8b f8		 mov	 edi, eax
  000f5	81 e7 01 00 00
	80		 and	 edi, -2147483647	; 80000001H
  000fb	79 05		 jns	 SHORT $LN32@SkillSummo
  000fd	4f		 dec	 edi
  000fe	83 cf fe	 or	 edi, -2			; fffffffeH
  00101	47		 inc	 edi
$LN32@SkillSummo:
  00102	81 c7 0f 01 00
	00		 add	 edi, 271		; 0000010fH
$LN34@SkillSummo:

; 2638 : 		bDoSummon = (rand()%15) ? false : true;

  00108	e8 00 00 00 00	 call	 _rand
  0010d	99		 cdq
  0010e	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00113	f7 f9		 idiv	 ecx
  00115	85 d2		 test	 edx, edx
  00117	0f 94 c0	 sete	 al

; 2639 : 		break;
; 2640 : 	}
; 2641 : 
; 2642 : 	if(bDoSummon == false)

  0011a	84 c0		 test	 al, al
  0011c	75 0a		 jne	 SHORT $LN6@SkillSummo

; 2643 : 	{
; 2644 : 		return false;

  0011e	5f		 pop	 edi
  0011f	33 c0		 xor	 eax, eax
  00121	5b		 pop	 ebx

; 2682 : }

  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c2 0c 00	 ret	 12			; 0000000cH
$LN6@SkillSummo:

; 2645 : 	}
; 2646 : 
; 2647 : 	for(int iSC = 0; iSC < iSummonCount; iSC++)
; 2648 : 	{
; 2649 : 		BYTE cSX = lpObj->X;

  00128	8a 93 04 01 00
	00		 mov	 dl, BYTE PTR [ebx+260]

; 2650 : 		BYTE cSY = lpObj->Y;

  0012e	8a 83 06 01 00
	00		 mov	 al, BYTE PTR [ebx+262]
  00134	56		 push	 esi

; 2651 : 
; 2652 : 		if(gObjGetRandomFreeLocation(lpObj->MapNumber,(BYTE &)cSX,(BYTE &)cSY,2,2,30)==1)

  00135	6a 1e		 push	 30			; 0000001eH
  00137	6a 02		 push	 2
  00139	6a 02		 push	 2
  0013b	8d 4d ff	 lea	 ecx, DWORD PTR _cSY$158226[ebp]
  0013e	88 55 0b	 mov	 BYTE PTR _cSX$158225[ebp], dl
  00141	88 45 ff	 mov	 BYTE PTR _cSY$158226[ebp], al
  00144	0f b6 83 09 01
	00 00		 movzx	 eax, BYTE PTR [ebx+265]
  0014b	51		 push	 ecx
  0014c	8d 55 0b	 lea	 edx, DWORD PTR _cSX$158225[ebp]
  0014f	52		 push	 edx
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 ?gObjGetRandomFreeLocation@@YAHHAAE0HHH@Z ; gObjGetRandomFreeLocation
  00156	83 c4 18	 add	 esp, 24			; 00000018H
  00159	83 f8 01	 cmp	 eax, 1
  0015c	0f 85 d1 00 00
	00		 jne	 $LN24@SkillSummo

; 2653 : 		{
; 2654 : 			int result = gObjAddMonster(lpObj->MapNumber);

  00162	0f b6 8b 09 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+265]
  00169	51		 push	 ecx
  0016a	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0016f	0f bf f0	 movsx	 esi, ax
  00172	83 c4 04	 add	 esp, 4
  00175	89 75 f4	 mov	 DWORD PTR _result$158230[ebp], esi

; 2655 : 
; 2656 : 			if(result >= 0)

  00178	85 f6		 test	 esi, esi
  0017a	0f 88 b3 00 00
	00		 js	 $LN24@SkillSummo

; 2657 : 			{
; 2658 : 				gObj[result].m_PosNum = (WORD)-1;
; 2659 : 				gObj[result].X = cSX;

  00180	0f b6 45 0b	 movzx	 eax, BYTE PTR _cSX$158225[ebp]
  00184	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H

; 2660 : 				gObj[result].Y = cSY;

  0018a	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cSY$158226[ebp]
  0018e	83 ca ff	 or	 edx, -1
  00191	66 89 96 10 02
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+528], dx
  00198	66 89 86 04 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260], ax
  0019f	66 89 8e 06 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262], cx

; 2661 : 				gObj[result].MapNumber = lpObj->MapNumber;

  001a6	8a 93 09 01 00
	00		 mov	 dl, BYTE PTR [ebx+265]

; 2662 : 				gObj[result].TX = gObj[result].X;

  001ac	66 89 86 20 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+288], ax

; 2663 : 				gObj[result].TY = gObj[result].Y;

  001b3	66 89 8e 22 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+290], cx

; 2664 : 				gObj[result].m_OldX = gObj[result].X;

  001ba	66 89 86 1c 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+284], ax

; 2665 : 				gObj[result].m_OldY = gObj[result].Y;

  001c1	66 89 8e 1e 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+286], cx
  001c8	88 96 09 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265], dl

; 2666 : 				gObj[result].Dir = 1;
; 2667 : 				gObj[result].StartX = gObj[result].X;
; 2668 : 				gObj[result].StartY = gObj[result].Y;
; 2669 : 				gObjSetMonster(result,iSummonMonterType);

  001ce	8b 55 f4	 mov	 edx, DWORD PTR _result$158230[ebp]
  001d1	0f b6 c0	 movzx	 eax, al
  001d4	0f b6 c9	 movzx	 ecx, cl
  001d7	57		 push	 edi
  001d8	52		 push	 edx
  001d9	c6 86 08 01 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+264], 1
  001e0	88 86 1a 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+282], al
  001e6	88 8e 1b 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+283], cl
  001ec	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 2670 : 				gObj[result].m_Attribute = 60;

  001f1	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  001f6	83 c4 08	 add	 esp, 8
  001f9	66 89 86 26 03
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+806], ax

; 2671 : 				gObj[result].MaxRegenTime = 0;

  00200	c7 86 0c 02 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+524], 0

; 2672 : 				gObj[result].Dir = rand()%8;

  0020a	e8 00 00 00 00	 call	 _rand
  0020f	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00214	79 05		 jns	 SHORT $LN33@SkillSummo
  00216	48		 dec	 eax
  00217	83 c8 f8	 or	 eax, -8			; fffffff8H
  0021a	40		 inc	 eax
$LN33@SkillSummo:

; 2673 : 				bSummonSuccess = 1;
; 2674 : 				cSummonX = gObj[result].StartX;
; 2675 : 				cSummonY = gObj[result].StartY;

  0021b	8a 8e 1b 01 00
	00		 mov	 cl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+283]
  00221	88 86 08 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+264], al
  00227	8a 86 1a 01 00
	00		 mov	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+282]
  0022d	c6 45 f9 01	 mov	 BYTE PTR _bSummonSuccess$[ebp], 1
  00231	eb 05		 jmp	 SHORT $LN4@SkillSummo
$LN24@SkillSummo:
  00233	8a 45 fe	 mov	 al, BYTE PTR _cSummonX$[ebp]
  00236	8a c8		 mov	 cl, al
$LN4@SkillSummo:

; 2676 : 			}
; 2677 : 		}
; 2678 : 	}
; 2679 : 
; 2680 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_SUMMON,(((cSummonX & 0xFF)&0xFF) | ((cSummonY & 0xFF)&0xFF) << 8) & 0xFFFF,bSummonSuccess);

  00238	8b 55 f9	 mov	 edx, DWORD PTR _bSummonSuccess$[ebp]
  0023b	52		 push	 edx
  0023c	0f b6 c9	 movzx	 ecx, cl
  0023f	0f b6 d0	 movzx	 edx, al
  00242	c1 e1 08	 shl	 ecx, 8
  00245	0b ca		 or	 ecx, edx
  00247	51		 push	 ecx
  00248	68 c8 00 00 00	 push	 200			; 000000c8H
  0024d	53		 push	 ebx
  0024e	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 2681 : 	return bSummonSuccess;

  00253	0f b6 45 f9	 movzx	 eax, BYTE PTR _bSummonSuccess$[ebp]
  00257	83 c4 10	 add	 esp, 16			; 00000010H
  0025a	5e		 pop	 esi
  0025b	5f		 pop	 edi
  0025c	5b		 pop	 ebx

; 2682 : }

  0025d	8b e5		 mov	 esp, ebp
  0025f	5d		 pop	 ebp
  00260	c2 0c 00	 ret	 12			; 0000000cH
  00263	90		 npad	 1
$LN35@SkillSummo:
  00264	00 00 00 00	 DD	 $LN12@SkillSummo
  00268	00 00 00 00	 DD	 $LN11@SkillSummo
  0026c	00 00 00 00	 DD	 $LN10@SkillSummo
  00270	00 00 00 00	 DD	 $LN9@SkillSummo
  00274	00 00 00 00	 DD	 $LN8@SkillSummo
  00278	00 00 00 00	 DD	 $LN7@SkillSummo
  0027c	00 00 00 00	 DD	 $LN6@SkillSummo
$LN23@SkillSummo:
  00280	00		 DB	 0
  00281	06		 DB	 6
  00282	06		 DB	 6
  00283	06		 DB	 6
  00284	06		 DB	 6
  00285	06		 DB	 6
  00286	06		 DB	 6
  00287	06		 DB	 6
  00288	06		 DB	 6
  00289	06		 DB	 6
  0028a	06		 DB	 6
  0028b	06		 DB	 6
  0028c	06		 DB	 6
  0028d	06		 DB	 6
  0028e	06		 DB	 6
  0028f	06		 DB	 6
  00290	06		 DB	 6
  00291	06		 DB	 6
  00292	06		 DB	 6
  00293	06		 DB	 6
  00294	01		 DB	 1
  00295	06		 DB	 6
  00296	06		 DB	 6
  00297	06		 DB	 6
  00298	06		 DB	 6
  00299	06		 DB	 6
  0029a	06		 DB	 6
  0029b	06		 DB	 6
  0029c	02		 DB	 2
  0029d	06		 DB	 6
  0029e	06		 DB	 6
  0029f	06		 DB	 6
  002a0	06		 DB	 6
  002a1	06		 DB	 6
  002a2	06		 DB	 6
  002a3	06		 DB	 6
  002a4	03		 DB	 3
  002a5	06		 DB	 6
  002a6	06		 DB	 6
  002a7	06		 DB	 6
  002a8	06		 DB	 6
  002a9	06		 DB	 6
  002aa	06		 DB	 6
  002ab	06		 DB	 6
  002ac	06		 DB	 6
  002ad	06		 DB	 6
  002ae	06		 DB	 6
  002af	06		 DB	 6
  002b0	06		 DB	 6
  002b1	06		 DB	 6
  002b2	06		 DB	 6
  002b3	06		 DB	 6
  002b4	06		 DB	 6
  002b5	06		 DB	 6
  002b6	06		 DB	 6
  002b7	06		 DB	 6
  002b8	06		 DB	 6
  002b9	06		 DB	 6
  002ba	06		 DB	 6
  002bb	06		 DB	 6
  002bc	06		 DB	 6
  002bd	06		 DB	 6
  002be	06		 DB	 6
  002bf	06		 DB	 6
  002c0	06		 DB	 6
  002c1	06		 DB	 6
  002c2	06		 DB	 6
  002c3	06		 DB	 6
  002c4	06		 DB	 6
  002c5	06		 DB	 6
  002c6	06		 DB	 6
  002c7	06		 DB	 6
  002c8	06		 DB	 6
  002c9	06		 DB	 6
  002ca	06		 DB	 6
  002cb	06		 DB	 6
  002cc	06		 DB	 6
  002cd	06		 DB	 6
  002ce	06		 DB	 6
  002cf	06		 DB	 6
  002d0	06		 DB	 6
  002d1	06		 DB	 6
  002d2	06		 DB	 6
  002d3	06		 DB	 6
  002d4	06		 DB	 6
  002d5	06		 DB	 6
  002d6	06		 DB	 6
  002d7	06		 DB	 6
  002d8	06		 DB	 6
  002d9	06		 DB	 6
  002da	06		 DB	 6
  002db	06		 DB	 6
  002dc	06		 DB	 6
  002dd	06		 DB	 6
  002de	06		 DB	 6
  002df	06		 DB	 6
  002e0	06		 DB	 6
  002e1	06		 DB	 6
  002e2	06		 DB	 6
  002e3	06		 DB	 6
  002e4	06		 DB	 6
  002e5	06		 DB	 6
  002e6	06		 DB	 6
  002e7	06		 DB	 6
  002e8	06		 DB	 6
  002e9	06		 DB	 6
  002ea	04		 DB	 4
  002eb	06		 DB	 6
  002ec	06		 DB	 6
  002ed	06		 DB	 6
  002ee	06		 DB	 6
  002ef	06		 DB	 6
  002f0	06		 DB	 6
  002f1	06		 DB	 6
  002f2	05		 DB	 5
?SkillSummon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::SkillSummon
_TEXT	ENDS
PUBLIC	?SkillImmuneToMagic@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillImmuneToMagic
EXTRN	?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z:PROC	; GCStateInfoSend
; Function compile flags: /Ogtp
;	COMDAT ?SkillImmuneToMagic@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?SkillImmuneToMagic@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillImmuneToMagic, COMDAT
; _this$ = ecx

; 2688 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2689 : 	if(OBJMAX_RANGE(aIndex) == false)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 68		 js	 SHORT $LN1@SkillImmun
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax

; 2690 : 	{
; 2691 : 		return false;

  00018	74 59		 je	 SHORT $LN1@SkillImmun

; 2692 : 	}
; 2693 : 
; 2694 : 	LPOBJ lpObj = &gObj[aIndex];

  0001a	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00020	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2695 : 
; 2696 : 	if(lpObj->m_ImmuneToMagicCount <= 0 && lpObj->m_ImmuneToHarmCount <= 0)

  00026	80 be 29 02 00
	00 00		 cmp	 BYTE PTR [esi+553], 0
  0002d	7f 44		 jg	 SHORT $LN1@SkillImmun
  0002f	80 be 2a 02 00
	00 00		 cmp	 BYTE PTR [esi+554], 0
  00036	7f 3b		 jg	 SHORT $LN1@SkillImmun

; 2697 : 	{
; 2698 : 		lpObj->m_ImmuneToMagicCount = 10;
; 2699 : 		lpObj->m_ViewSkillState |= 128;

  00038	81 8e c4 01 00
	00 80 00 00 00	 or	 DWORD PTR [esi+452], 128 ; 00000080H

; 2700 : 		GCStateInfoSend(lpObj,1,128);

  00042	68 80 00 00 00	 push	 128			; 00000080H
  00047	6a 01		 push	 1
  00049	56		 push	 esi
  0004a	c6 86 29 02 00
	00 0a		 mov	 BYTE PTR [esi+553], 10	; 0000000aH
  00051	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend

; 2701 : 		GCMagicAttackNumberSend(lpObj,AT_SKILL_IMMUNE_TO_MAGIC,lpObj->m_Index,1);

  00056	8b 06		 mov	 eax, DWORD PTR [esi]
  00058	6a 01		 push	 1
  0005a	50		 push	 eax
  0005b	68 c9 00 00 00	 push	 201			; 000000c9H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  00066	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2702 : 		return true;

  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	5e		 pop	 esi

; 2705 : }

  0006f	5d		 pop	 ebp
  00070	c2 08 00	 ret	 8
$LN1@SkillImmun:

; 2703 : 	}
; 2704 : 	return false;

  00073	33 c0		 xor	 eax, eax
  00075	5e		 pop	 esi

; 2705 : }

  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
?SkillImmuneToMagic@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillImmuneToMagic
_TEXT	ENDS
PUBLIC	?SkillImmuneToHarm@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillImmuneToHarm
; Function compile flags: /Ogtp
;	COMDAT ?SkillImmuneToHarm@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?SkillImmuneToHarm@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillImmuneToHarm, COMDAT
; _this$ = ecx

; 2711 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2712 : 	if(OBJMAX_RANGE(aIndex) == false)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 62		 js	 SHORT $LN1@SkillImmun@2
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax

; 2713 : 	{
; 2714 : 		return false;

  00018	74 53		 je	 SHORT $LN1@SkillImmun@2

; 2715 : 	}
; 2716 : 
; 2717 : 	LPOBJ lpObj = &gObj[aIndex];

  0001a	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00020	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2718 : 
; 2719 : 	if(lpObj->m_ImmuneToMagicCount <= 0 && lpObj->m_ImmuneToHarmCount <= 0)

  00026	80 be 29 02 00
	00 00		 cmp	 BYTE PTR [esi+553], 0
  0002d	7f 3e		 jg	 SHORT $LN1@SkillImmun@2
  0002f	80 be 2a 02 00
	00 00		 cmp	 BYTE PTR [esi+554], 0
  00036	7f 35		 jg	 SHORT $LN1@SkillImmun@2

; 2720 : 	{
; 2721 : 		lpObj->m_ImmuneToHarmCount = 10;
; 2722 : 		lpObj->m_ViewSkillState |= 8;

  00038	83 8e c4 01 00
	00 08		 or	 DWORD PTR [esi+452], 8

; 2723 : 		GCStateInfoSend(lpObj,1,8);

  0003f	6a 08		 push	 8
  00041	6a 01		 push	 1
  00043	56		 push	 esi
  00044	c6 86 2a 02 00
	00 0a		 mov	 BYTE PTR [esi+554], 10	; 0000000aH
  0004b	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend

; 2724 : 		GCMagicAttackNumberSend(lpObj,AT_SKILL_IMMUNE_TO_HARM,lpObj->m_Index,1);

  00050	8b 06		 mov	 eax, DWORD PTR [esi]
  00052	6a 01		 push	 1
  00054	50		 push	 eax
  00055	68 ca 00 00 00	 push	 202			; 000000caH
  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  00060	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2725 : 		return true;

  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	5e		 pop	 esi

; 2728 : }

  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
$LN1@SkillImmun@2:

; 2726 : 	}
; 2727 : 	return false;

  0006d	33 c0		 xor	 eax, eax
  0006f	5e		 pop	 esi

; 2728 : }

  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
?SkillImmuneToHarm@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillImmuneToHarm
_TEXT	ENDS
PUBLIC	?RemoveSpecificSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z ; CObjUseSkill::RemoveSpecificSkillState
; Function compile flags: /Ogtp
;	COMDAT ?RemoveSpecificSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_iSkillNumber$ = 12					; size = 4
?RemoveSpecificSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z PROC ; CObjUseSkill::RemoveSpecificSkillState, COMDAT
; _this$ = ecx

; 2732 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2733 : 	if(lpObj->Type != OBJ_USER)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	66 83 78 60 01	 cmp	 WORD PTR [eax+96], 1
  0000b	74 06		 je	 SHORT $LN4@RemoveSpec

; 2734 : 	{
; 2735 : 		return false;

  0000d	33 c0		 xor	 eax, eax

; 2756 : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
$LN4@RemoveSpec:
  00013	56		 push	 esi

; 2736 : 	}
; 2737 : 
; 2738 : 	int iViewSkillState = 0;
; 2739 : 
; 2740 : 	if(iSkillNumber == AT_SKILL_ATTACK)

  00014	8b 75 0c	 mov	 esi, DWORD PTR _iSkillNumber$[ebp]
  00017	33 d2		 xor	 edx, edx
  00019	33 c9		 xor	 ecx, ecx
  0001b	83 fe 1c	 cmp	 esi, 28			; 0000001cH
  0001e	75 11		 jne	 SHORT $LN3@RemoveSpec

; 2741 : 	{
; 2742 : 		lpObj->m_SkillAttackTime = 0;

  00020	88 90 84 02 00
	00		 mov	 BYTE PTR [eax+644], dl

; 2743 : 		lpObj->m_SkillAttack = 0;

  00026	89 90 80 02 00
	00		 mov	 DWORD PTR [eax+640], edx

; 2744 : 		iViewSkillState = 4;

  0002c	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
  0002f	eb 16		 jmp	 SHORT $LN1@RemoveSpec
$LN3@RemoveSpec:

; 2745 : 	}
; 2746 : 	else if(iSkillNumber == AT_SKILL_DEFENSE)

  00031	83 fe 1b	 cmp	 esi, 27			; 0000001bH
  00034	75 11		 jne	 SHORT $LN1@RemoveSpec

; 2747 : 	{
; 2748 : 		lpObj->m_SkillDefenseTime = 0;

  00036	88 90 7c 02 00
	00		 mov	 BYTE PTR [eax+636], dl

; 2749 : 		lpObj->m_SkillDefense = 0;

  0003c	89 90 78 02 00
	00		 mov	 DWORD PTR [eax+632], edx

; 2750 : 		iViewSkillState = 8;

  00042	b9 08 00 00 00	 mov	 ecx, 8
$LN1@RemoveSpec:

; 2751 : 	}
; 2752 : 
; 2753 : 	lpObj->m_ViewSkillState &= ~iViewSkillState;
; 2754 : 	GCStateInfoSend(lpObj,0,iViewSkillState);

  00047	51		 push	 ecx
  00048	8b f1		 mov	 esi, ecx
  0004a	52		 push	 edx
  0004b	f7 d6		 not	 esi
  0004d	21 b0 c4 01 00
	00		 and	 DWORD PTR [eax+452], esi
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2755 : 	return true;

  0005c	b8 01 00 00 00	 mov	 eax, 1
  00061	5e		 pop	 esi

; 2756 : }

  00062	5d		 pop	 ebp
  00063	c2 08 00	 ret	 8
?RemoveSpecificSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z ENDP ; CObjUseSkill::RemoveSpecificSkillState
_TEXT	ENDS
PUBLIC	?RemoveAllCharacterInvalidMagicAndSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@@Z ; CObjUseSkill::RemoveAllCharacterInvalidMagicAndSkillState
; Function compile flags: /Ogtp
;	COMDAT ?RemoveAllCharacterInvalidMagicAndSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?RemoveAllCharacterInvalidMagicAndSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CObjUseSkill::RemoveAllCharacterInvalidMagicAndSkillState, COMDAT
; _this$ = ecx

; 2760 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2761 : 	if(lpObj->Type != OBJ_USER)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	66 83 78 60 01	 cmp	 WORD PTR [eax+96], 1
  0000b	74 06		 je	 SHORT $LN1@RemoveAllC

; 2762 : 	{
; 2763 : 		return false;

  0000d	33 c0		 xor	 eax, eax

; 2828 : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
$LN1@RemoveAllC:

; 2764 : 	}
; 2765 : 
; 2766 : 	lpObj->m_SkillAttackTime = 0;

  00013	33 c9		 xor	 ecx, ecx

; 2767 : 	lpObj->m_SkillAttack = 0;
; 2768 : 	lpObj->m_ViewSkillState &= ~4;
; 2769 : 
; 2770 : 	lpObj->m_SkillAttackTime2 = 0;
; 2771 : 	lpObj->m_SkillAttack2 = 0;
; 2772 : 	lpObj->m_SkillDefenseTime = 0;
; 2773 : 	lpObj->m_SkillDefense = 0;
; 2774 : 	lpObj->m_ViewSkillState &= ~8;
; 2775 : 
; 2776 : 	lpObj->m_WizardSkillDefenseTime = 0;
; 2777 : 	lpObj->m_WizardSkillDefense = 0;
; 2778 : 	lpObj->m_ViewSkillState &= ~256;
; 2779 : 
; 2780 : 	lpObj->m_SkillAddLifeTime = 0;
; 2781 : 	lpObj->m_SkillAddLife = 0;
; 2782 : 	lpObj->m_ViewSkillState &= ~16;
; 2783 : 
; 2784 : 	lpObj->m_SkillHardenTime = 0;
; 2785 : 	lpObj->m_SkillHarden = 0;
; 2786 : 	lpObj->m_ViewSkillState &= ~32;
; 2787 : 
; 2788 : 	lpObj->m_SkillMagumReduceDefenseTime = 0;
; 2789 : 	lpObj->m_SkillMagumReduceDefense = 0;
; 2790 : 	lpObj->m_ViewSkillState &= ~64;
; 2791 : 
; 2792 : 	lpObj->SkillRecallParty_Time = 0;

  00015	33 d2		 xor	 edx, edx

; 2793 : 	lpObj->SkillAddCriticalDamageTime = 0;
; 2794 : 	lpObj->SkillAddCriticalDamage = 0;
; 2795 : 	lpObj->m_ViewSkillState &= ~2048;
; 2796 : 
; 2797 : 	lpObj->m_iSkillStunTime = 0;
; 2798 : 	lpObj->m_ViewSkillState &= ~4096;
; 2799 : 
; 2800 : 	lpObj->m_iSkillBrandOfSkillTime = 0;
; 2801 : 	lpObj->m_ViewSkillState &= ~512;
; 2802 : 
; 2803 : 	lpObj->m_iSkillInvisibleTime = 0;
; 2804 : 	lpObj->m_ViewSkillState &= ~16384;
; 2805 : 
; 2806 : 	lpObj->m_iSkillManaSwellTime = 0;
; 2807 : 	lpObj->m_iSkillManaSwell = 0;
; 2808 : 	lpObj->m_ViewSkillState &= ~8192;
; 2809 : 
; 2810 : 	lpObj->m_PoisonBeattackCount = 0;
; 2811 : 	lpObj->m_PoisonType = 0;
; 2812 : 	lpObj->m_ViewSkillState &= ~1;
; 2813 : 
; 2814 : 	lpObj->m_ColdBeattackCount = 0;
; 2815 : 	lpObj->m_IceType = 0;
; 2816 : 	lpObj->m_ViewSkillState &= ~2;
; 2817 : 
; 2818 : 	lpObj->m_ImmuneToMagicCount = 0;
; 2819 : 	lpObj->m_ImmuneToHarmCount = 0;
; 2820 : 
; 2821 : 	lpObj->m_ViewSkillState &= ~128;
; 2822 : 	lpObj->m_ViewSkillState &= ~8;
; 2823 : 
; 2824 : 	lpObj->m_iMuseElfInfinityArrowSkillTime = 0;
; 2825 : 	lpObj->m_ViewSkillState &= ~67108864;

  00017	81 a0 c4 01 00
	00 00 84 ff fb	 and	 DWORD PTR [eax+452], -67140608 ; fbff8400H
  00021	88 88 84 02 00
	00		 mov	 BYTE PTR [eax+644], cl
  00027	89 88 80 02 00
	00		 mov	 DWORD PTR [eax+640], ecx
  0002d	88 88 8c 02 00
	00		 mov	 BYTE PTR [eax+652], cl
  00033	89 88 88 02 00
	00		 mov	 DWORD PTR [eax+648], ecx
  00039	88 88 7c 02 00
	00		 mov	 BYTE PTR [eax+636], cl
  0003f	89 88 78 02 00
	00		 mov	 DWORD PTR [eax+632], ecx
  00045	89 88 08 0f 00
	00		 mov	 DWORD PTR [eax+3848], ecx
  0004b	89 88 04 0f 00
	00		 mov	 DWORD PTR [eax+3844], ecx
  00051	89 88 94 02 00
	00		 mov	 DWORD PTR [eax+660], ecx
  00057	89 88 90 02 00
	00		 mov	 DWORD PTR [eax+656], ecx
  0005d	89 88 9c 02 00
	00		 mov	 DWORD PTR [eax+668], ecx
  00063	89 88 98 02 00
	00		 mov	 DWORD PTR [eax+664], ecx
  00069	89 88 a4 02 00
	00		 mov	 DWORD PTR [eax+676], ecx
  0006f	89 88 a0 02 00
	00		 mov	 DWORD PTR [eax+672], ecx
  00075	66 89 90 b0 10
	00 00		 mov	 WORD PTR [eax+4272], dx
  0007c	66 89 90 b6 10
	00 00		 mov	 WORD PTR [eax+4278], dx
  00083	66 89 90 b8 10
	00 00		 mov	 WORD PTR [eax+4280], dx
  0008a	89 88 dc 14 00
	00		 mov	 DWORD PTR [eax+5340], ecx
  00090	89 88 e0 14 00
	00		 mov	 DWORD PTR [eax+5344], ecx
  00096	89 88 e4 14 00
	00		 mov	 DWORD PTR [eax+5348], ecx
  0009c	89 88 e8 14 00
	00		 mov	 DWORD PTR [eax+5352], ecx
  000a2	89 88 ec 14 00
	00		 mov	 DWORD PTR [eax+5356], ecx
  000a8	89 88 25 02 00
	00		 mov	 DWORD PTR [eax+549], ecx
  000ae	66 89 88 29 02
	00 00		 mov	 WORD PTR [eax+553], cx
  000b5	89 88 30 15 00
	00		 mov	 DWORD PTR [eax+5424], ecx

; 2826 : 
; 2827 : 	return true;

  000bb	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 2828 : }

  000be	5d		 pop	 ebp
  000bf	c2 04 00	 ret	 4
?RemoveAllCharacterInvalidMagicAndSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CObjUseSkill::RemoveAllCharacterInvalidMagicAndSkillState
_TEXT	ENDS
PUBLIC	?SkillKnightRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillKnightRush
; Function compile flags: /Ogtp
;	COMDAT ?SkillKnightRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillKnightRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillKnightRush, COMDAT
; _this$ = ecx

; 2834 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2835 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN7@SkillKnigh
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN2@SkillKnigh
$LN7@SkillKnigh:

; 2836 : 	{
; 2837 : 		return false;

  00018	33 c0		 xor	 eax, eax

; 2850 : }

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
$LN2@SkillKnigh:

; 2838 : 	}
; 2839 : 
; 2840 : 	LPOBJ lpObj = &gObj[aIndex];

  0001e	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00024	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00029	57		 push	 edi
  0002a	8b f8		 mov	 edi, eax

; 2841 : 
; 2842 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)

  0002c	8a 87 09 01 00
	00		 mov	 al, BYTE PTR [edi+265]
  00032	3c 1e		 cmp	 al, 30			; 0000001eH
  00034	74 0b		 je	 SHORT $LN1@SkillKnigh
  00036	3c 1f		 cmp	 al, 31			; 0000001fH
  00038	74 07		 je	 SHORT $LN1@SkillKnigh

; 2843 : 	{
; 2844 : 		return false;

  0003a	33 c0		 xor	 eax, eax
  0003c	5f		 pop	 edi

; 2850 : }

  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
$LN1@SkillKnigh:
  00041	53		 push	 ebx

; 2845 : 	}
; 2846 : 
; 2847 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00042	8b 5d 10	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  00045	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  00049	56		 push	 esi
  0004a	8b 75 0c	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]
  0004d	6a 01		 push	 1
  0004f	56		 push	 esi
  00050	50		 push	 eax
  00051	57		 push	 edi
  00052	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 2848 : 	gObjAttack(lpObj,&gObj[aTargetIndex],lpMagic,0,1,0,0);

  00057	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	6a 01		 push	 1
  00063	6a 00		 push	 0
  00065	53		 push	 ebx
  00066	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006c	56		 push	 esi
  0006d	57		 push	 edi
  0006e	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  00073	83 c4 2c	 add	 esp, 44			; 0000002cH
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx

; 2849 : 	return true;

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	5f		 pop	 edi

; 2850 : }

  0007e	5d		 pop	 ebp
  0007f	c2 0c 00	 ret	 12			; 0000000cH
?SkillKnightRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillKnightRush
_TEXT	ENDS
PUBLIC	?SkillWizardJavalin@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillWizardJavalin
; Function compile flags: /Ogtp
;	COMDAT ?SkillWizardJavalin@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillWizardJavalin@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillWizardJavalin, COMDAT
; _this$ = ecx

; 2856 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2857 : 	if(OBJMAX_RANGE(aIndex) == false)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 0f		 js	 SHORT $LN7@SkillWizar
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 07		 jne	 SHORT $LN2@SkillWizar
$LN7@SkillWizar:

; 2858 : 	{
; 2859 : 		return false;

  0001a	33 c0		 xor	 eax, eax
  0001c	5e		 pop	 esi

; 2876 : }

  0001d	5d		 pop	 ebp
  0001e	c2 0c 00	 ret	 12			; 0000000cH
$LN2@SkillWizar:

; 2860 : 	}
; 2861 : 
; 2862 : 	LPOBJ lpObj = &gObj[aIndex];

  00021	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00027	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2863 : 
; 2864 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)

  0002d	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00033	3c 1e		 cmp	 al, 30			; 0000001eH
  00035	74 04		 je	 SHORT $LN1@SkillWizar
  00037	3c 1f		 cmp	 al, 31			; 0000001fH

; 2865 : 	{
; 2866 : 		return false;

  00039	75 df		 jne	 SHORT $LN7@SkillWizar
$LN1@SkillWizar:
  0003b	53		 push	 ebx

; 2867 : 	}
; 2868 : 
; 2869 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  0003c	8b 5d 0c	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]
  0003f	57		 push	 edi
  00040	8b 7d 10	 mov	 edi, DWORD PTR _lpMagic$[ebp]
  00043	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00047	6a 01		 push	 1
  00049	53		 push	 ebx
  0004a	50		 push	 eax
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 2870 : 
; 2871 : 	int iDelay = 500;
; 2872 : 
; 2873 : 	gObjAddAttackProcMsgSendDelay(lpObj,50,aTargetIndex,iDelay,lpMagic->m_Skill,0);

  00051	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  00055	6a 00		 push	 0
  00057	51		 push	 ecx
  00058	68 f4 01 00 00	 push	 500			; 000001f4H
  0005d	53		 push	 ebx
  0005e	6a 32		 push	 50			; 00000032H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay

; 2874 : 	gObjAddAttackProcMsgSendDelay(lpObj,50,aTargetIndex,iDelay+200,lpMagic->m_Skill,0);

  00066	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  0006a	6a 00		 push	 0
  0006c	52		 push	 edx
  0006d	68 bc 02 00 00	 push	 700			; 000002bcH
  00072	53		 push	 ebx
  00073	6a 32		 push	 50			; 00000032H
  00075	56		 push	 esi
  00076	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  0007b	83 c4 40	 add	 esp, 64			; 00000040H
  0007e	5f		 pop	 edi
  0007f	5b		 pop	 ebx

; 2875 : 	return true;

  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	5e		 pop	 esi

; 2876 : }

  00086	5d		 pop	 ebp
  00087	c2 0c 00	 ret	 12			; 0000000cH
?SkillWizardJavalin@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillWizardJavalin
_TEXT	ENDS
PUBLIC	?SkillElfRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillElfRush
; Function compile flags: /Ogtp
;	COMDAT ?SkillElfRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillElfRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::SkillElfRush, COMDAT
; _this$ = ecx

; 2882 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2883 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN7@SkillElfRu
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN2@SkillElfRu
$LN7@SkillElfRu:

; 2884 : 	{
; 2885 : 		return false;

  00018	33 c0		 xor	 eax, eax

; 2898 : }

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
$LN2@SkillElfRu:

; 2886 : 	}
; 2887 : 
; 2888 : 	LPOBJ lpObj = &gObj[aIndex];

  0001e	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00024	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00029	56		 push	 esi
  0002a	8b f0		 mov	 esi, eax

; 2889 : 
; 2890 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)

  0002c	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00032	3c 1e		 cmp	 al, 30			; 0000001eH
  00034	74 0b		 je	 SHORT $LN1@SkillElfRu
  00036	3c 1f		 cmp	 al, 31			; 0000001fH
  00038	74 07		 je	 SHORT $LN1@SkillElfRu

; 2891 : 	{
; 2892 : 		return false;

  0003a	33 c0		 xor	 eax, eax
  0003c	5e		 pop	 esi

; 2898 : }

  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
$LN1@SkillElfRu:
  00041	53		 push	 ebx

; 2893 : 	}
; 2894 : 
; 2895 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00042	8b 5d 0c	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]
  00045	57		 push	 edi
  00046	8b 7d 10	 mov	 edi, DWORD PTR _lpMagic$[ebp]
  00049	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  0004d	6a 01		 push	 1
  0004f	53		 push	 ebx
  00050	50		 push	 eax
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 2896 : 	gObjAddAttackProcMsgSendDelay(lpObj,50,aTargetIndex,800,lpMagic->m_Skill,0);

  00057	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  0005b	6a 00		 push	 0
  0005d	51		 push	 ecx
  0005e	68 20 03 00 00	 push	 800			; 00000320H
  00063	53		 push	 ebx
  00064	6a 32		 push	 50			; 00000032H
  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  0006c	83 c4 28	 add	 esp, 40			; 00000028H
  0006f	5f		 pop	 edi
  00070	5b		 pop	 ebx

; 2897 : 	return true;

  00071	b8 01 00 00 00	 mov	 eax, 1
  00076	5e		 pop	 esi

; 2898 : }

  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
?SkillElfRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::SkillElfRush
_TEXT	ENDS
PUBLIC	?SkillMagumOneFlash@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillMagumOneFlash
; Function compile flags: /Ogtp
;	COMDAT ?SkillMagumOneFlash@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillMagumOneFlash@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillMagumOneFlash, COMDAT
; _this$ = ecx

; 2904 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2905 : 	if(OBJMAX_RANGE(aIndex) == false)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 0f		 js	 SHORT $LN7@SkillMagum
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 07		 jne	 SHORT $LN2@SkillMagum
$LN7@SkillMagum:

; 2906 : 	{
; 2907 : 		return false;

  0001a	33 c0		 xor	 eax, eax
  0001c	5e		 pop	 esi

; 2921 : }

  0001d	5d		 pop	 ebp
  0001e	c2 0c 00	 ret	 12			; 0000000cH
$LN2@SkillMagum:

; 2908 : 	}
; 2909 : 
; 2910 : 	LPOBJ lpObj = &gObj[aIndex];

  00021	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00027	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2911 : 
; 2912 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)

  0002d	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00033	3c 1e		 cmp	 al, 30			; 0000001eH
  00035	74 04		 je	 SHORT $LN1@SkillMagum
  00037	3c 1f		 cmp	 al, 31			; 0000001fH

; 2913 : 	{
; 2914 : 		return false;

  00039	75 df		 jne	 SHORT $LN7@SkillMagum
$LN1@SkillMagum:
  0003b	53		 push	 ebx

; 2915 : 	}
; 2916 : 
; 2917 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  0003c	8b 5d 0c	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]
  0003f	57		 push	 edi
  00040	8b 7d 10	 mov	 edi, DWORD PTR _lpMagic$[ebp]
  00043	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00047	6a 01		 push	 1
  00049	53		 push	 ebx
  0004a	50		 push	 eax
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 2918 : 	gObjAttack(lpObj,&gObj[aTargetIndex],lpMagic,0,1,0,0);

  00051	6a 00		 push	 0
  00053	8b cb		 mov	 ecx, ebx
  00055	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0005b	6a 00		 push	 0
  0005d	6a 01		 push	 1
  0005f	6a 00		 push	 0
  00061	57		 push	 edi
  00062	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00068	51		 push	 ecx
  00069	56		 push	 esi
  0006a	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack

; 2919 : 	gObjAddAttackProcMsgSendDelay(lpObj,50,aTargetIndex,100,lpMagic->m_Skill,0);

  0006f	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  00073	6a 00		 push	 0
  00075	52		 push	 edx
  00076	6a 64		 push	 100			; 00000064H
  00078	53		 push	 ebx
  00079	6a 32		 push	 50			; 00000032H
  0007b	56		 push	 esi
  0007c	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  00081	83 c4 44	 add	 esp, 68			; 00000044H
  00084	5f		 pop	 edi
  00085	5b		 pop	 ebx

; 2920 : 	return true;

  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	5e		 pop	 esi

; 2921 : }

  0008c	5d		 pop	 ebp
  0008d	c2 0c 00	 ret	 12			; 0000000cH
?SkillMagumOneFlash@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillMagumOneFlash
_TEXT	ENDS
PUBLIC	?SkillMagumDeathCannon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillMagumDeathCannon
; Function compile flags: /Ogtp
;	COMDAT ?SkillMagumDeathCannon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillMagumDeathCannon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillMagumDeathCannon, COMDAT
; _this$ = ecx

; 2927 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2928 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN7@SkillMagum@2
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN2@SkillMagum@2
$LN7@SkillMagum@2:

; 2929 : 	{
; 2930 : 		return false;

  00018	33 c0		 xor	 eax, eax

; 2943 : }

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
$LN2@SkillMagum@2:

; 2931 : 	}
; 2932 : 
; 2933 : 	LPOBJ lpObj = &gObj[aIndex];

  0001e	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00024	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00029	57		 push	 edi
  0002a	8b f8		 mov	 edi, eax

; 2934 : 
; 2935 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)

  0002c	8a 87 09 01 00
	00		 mov	 al, BYTE PTR [edi+265]
  00032	3c 1e		 cmp	 al, 30			; 0000001eH
  00034	74 0b		 je	 SHORT $LN1@SkillMagum@2
  00036	3c 1f		 cmp	 al, 31			; 0000001fH
  00038	74 07		 je	 SHORT $LN1@SkillMagum@2

; 2936 : 	{
; 2937 : 		return false;

  0003a	33 c0		 xor	 eax, eax
  0003c	5f		 pop	 edi

; 2943 : }

  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
$LN1@SkillMagum@2:
  00041	53		 push	 ebx

; 2938 : 	}
; 2939 : 
; 2940 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00042	8b 5d 10	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  00045	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  00049	56		 push	 esi
  0004a	8b 75 0c	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]
  0004d	6a 01		 push	 1
  0004f	56		 push	 esi
  00050	50		 push	 eax
  00051	57		 push	 edi
  00052	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 2941 : 	gObjAttack(lpObj,&gObj[aTargetIndex],lpMagic,0,1,0,0);

  00057	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	6a 01		 push	 1
  00063	6a 00		 push	 0
  00065	53		 push	 ebx
  00066	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006c	56		 push	 esi
  0006d	57		 push	 edi
  0006e	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  00073	83 c4 2c	 add	 esp, 44			; 0000002cH
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx

; 2942 : 	return true;

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	5f		 pop	 edi

; 2943 : }

  0007e	5d		 pop	 ebp
  0007f	c2 0c 00	 ret	 12			; 0000000cH
?SkillMagumDeathCannon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillMagumDeathCannon
_TEXT	ENDS
PUBLIC	?SkillDarklordSpaceSplit@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDarklordSpaceSplit
; Function compile flags: /Ogtp
;	COMDAT ?SkillDarklordSpaceSplit@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillDarklordSpaceSplit@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillDarklordSpaceSplit, COMDAT
; _this$ = ecx

; 2949 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2950 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN7@SkillDarkl
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN2@SkillDarkl
$LN7@SkillDarkl:

; 2951 : 	{
; 2952 : 		return false;

  00018	33 c0		 xor	 eax, eax

; 2965 : }

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
$LN2@SkillDarkl:

; 2953 : 	}
; 2954 : 
; 2955 : 	LPOBJ lpObj = &gObj[aIndex];

  0001e	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00024	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00029	56		 push	 esi
  0002a	8b f0		 mov	 esi, eax

; 2956 : 
; 2957 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)

  0002c	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00032	3c 1e		 cmp	 al, 30			; 0000001eH
  00034	74 0b		 je	 SHORT $LN1@SkillDarkl
  00036	3c 1f		 cmp	 al, 31			; 0000001fH
  00038	74 07		 je	 SHORT $LN1@SkillDarkl

; 2958 : 	{
; 2959 : 		return false;

  0003a	33 c0		 xor	 eax, eax
  0003c	5e		 pop	 esi

; 2965 : }

  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
$LN1@SkillDarkl:
  00041	53		 push	 ebx

; 2960 : 	}
; 2961 : 
; 2962 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00042	8b 5d 0c	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]
  00045	57		 push	 edi
  00046	8b 7d 10	 mov	 edi, DWORD PTR _lpMagic$[ebp]
  00049	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  0004d	6a 01		 push	 1
  0004f	53		 push	 ebx
  00050	50		 push	 eax
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 2963 : 	gObjAddAttackProcMsgSendDelay(lpObj,50,aTargetIndex,500,lpMagic->m_Skill,0);

  00057	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  0005b	6a 00		 push	 0
  0005d	51		 push	 ecx
  0005e	68 f4 01 00 00	 push	 500			; 000001f4H
  00063	53		 push	 ebx
  00064	6a 32		 push	 50			; 00000032H
  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  0006c	83 c4 28	 add	 esp, 40			; 00000028H
  0006f	5f		 pop	 edi
  00070	5b		 pop	 ebx

; 2964 : 	return true;

  00071	b8 01 00 00 00	 mov	 eax, 1
  00076	5e		 pop	 esi

; 2965 : }

  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
?SkillDarklordSpaceSplit@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillDarklordSpaceSplit
_TEXT	ENDS
PUBLIC	?SkillBrandOfSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillBrandOfSkill
; Function compile flags: /Ogtp
;	COMDAT ?SkillBrandOfSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv230 = -8						; size = 4
tv360 = -4						; size = 4
tv322 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillBrandOfSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillBrandOfSkill, COMDAT
; _this$ = ecx

; 2971 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi

; 2972 : 	if(OBJMAX_RANGE(aIndex) == false)

  00007	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000a	85 ff		 test	 edi, edi
  0000c	78 0f		 js	 SHORT $LN19@SkillBrand
  0000e	33 c0		 xor	 eax, eax
  00010	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 09		 jne	 SHORT $LN9@SkillBrand
$LN19@SkillBrand:

; 2973 : 	{
; 2974 : 		return false;

  0001d	33 c0		 xor	 eax, eax
  0001f	5f		 pop	 edi

; 3022 : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
$LN9@SkillBrand:

; 2975 : 	}
; 2976 : 
; 2977 : 	LPOBJ lpObj = &gObj[aIndex];

  00026	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0002c	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2978 : 	int tObjNum;
; 2979 : 
; 2980 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)

  00032	8a 87 09 01 00
	00		 mov	 al, BYTE PTR [edi+265]
  00038	3c 1e		 cmp	 al, 30			; 0000001eH
  0003a	74 04		 je	 SHORT $LN8@SkillBrand
  0003c	3c 1f		 cmp	 al, 31			; 0000001fH

; 2981 : 	{
; 2982 : 		return false;

  0003e	75 dd		 jne	 SHORT $LN19@SkillBrand
$LN8@SkillBrand:

; 2983 : 	}
; 2984 : 
; 2985 : 	int count = 0;
; 2986 : 
; 2987 : 	lpObj->m_iSkillBrandOfSkillTime = 10;
; 2988 : 	lpObj->m_ViewSkillState |= 512;

  00040	81 8f c4 01 00
	00 00 02 00 00	 or	 DWORD PTR [edi+452], 512 ; 00000200H

; 2989 : 	GCStateInfoSend(lpObj,1,512);

  0004a	68 00 02 00 00	 push	 512			; 00000200H
  0004f	6a 01		 push	 1
  00051	57		 push	 edi
  00052	c7 87 e0 14 00
	00 0a 00 00 00	 mov	 DWORD PTR [edi+5344], 10 ; 0000000aH
  0005c	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend

; 2990 : 
; 2991 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_BRAND_OF_SKILL,lpObj->m_Index,1);

  00061	8b 07		 mov	 eax, DWORD PTR [edi]
  00063	6a 01		 push	 1
  00065	50		 push	 eax
  00066	6a 4b		 push	 75			; 0000004bH
  00068	57		 push	 edi
  00069	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  0006e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00071	8d 87 16 07 00
	00		 lea	 eax, DWORD PTR [edi+1814]
  00077	53		 push	 ebx
  00078	89 45 08	 mov	 DWORD PTR tv322[ebp], eax
  0007b	c7 45 fc 4b 00
	00 00		 mov	 DWORD PTR tv360[ebp], 75 ; 0000004bH
  00082	56		 push	 esi
$LL7@SkillBrand:

; 2992 : 
; 2993 : 	while( true )
; 2994 : 	{
; 2995 : 		if(lpObj->VpPlayer2[count].state != 0)

  00083	80 78 fe 00	 cmp	 BYTE PTR [eax-2], 0
  00087	74 71		 je	 SHORT $LN2@SkillBrand

; 2996 : 		{
; 2997 : 			tObjNum = lpObj->VpPlayer2[count].number;

  00089	0f bf 18	 movsx	 ebx, WORD PTR [eax]

; 2998 : 
; 2999 : 			if(OBJMAX_RANGE(tObjNum))

  0008c	85 db		 test	 ebx, ebx
  0008e	78 6a		 js	 SHORT $LN2@SkillBrand
  00090	33 c9		 xor	 ecx, ecx
  00092	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  00098	0f 9e c1	 setle	 cl
  0009b	85 c9		 test	 ecx, ecx
  0009d	74 5b		 je	 SHORT $LN2@SkillBrand

; 3000 : 			{
; 3001 : 				if(lpObj->VpPlayer2[count].type == OBJ_USER)

  0009f	80 78 02 01	 cmp	 BYTE PTR [eax+2], 1
  000a3	75 55		 jne	 SHORT $LN2@SkillBrand

; 3002 : 				{
; 3003 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 5)

  000a5	8b f3		 mov	 esi, ebx
  000a7	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000ad	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000b3	50		 push	 eax
  000b4	57		 push	 edi
  000b5	89 45 f8	 mov	 DWORD PTR tv230[ebp], eax
  000b8	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000bd	83 c4 08	 add	 esp, 8
  000c0	83 f8 05	 cmp	 eax, 5
  000c3	7d 32		 jge	 SHORT $LN20@SkillBrand

; 3004 : 					{
; 3005 : 						gObj[tObjNum].m_iSkillBrandOfSkillTime = 10;
; 3006 : 						gObj[tObjNum].m_ViewSkillState |= 512;
; 3007 : 						GCStateInfoSend(&gObj[tObjNum],1,512);

  000c5	8b 4d f8	 mov	 ecx, DWORD PTR tv230[ebp]
  000c8	81 8e c4 01 00
	00 00 02 00 00	 or	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+452], 512 ; 00000200H
  000d2	68 00 02 00 00	 push	 512			; 00000200H
  000d7	6a 01		 push	 1
  000d9	51		 push	 ecx
  000da	c7 86 e0 14 00
	00 0a 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+5344], 10 ; 0000000aH
  000e4	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend

; 3008 : 						GCMagicAttackNumberSend(lpObj,AT_SKILL_BRAND_OF_SKILL,tObjNum,1);

  000e9	6a 01		 push	 1
  000eb	53		 push	 ebx
  000ec	6a 4b		 push	 75			; 0000004bH
  000ee	57		 push	 edi
  000ef	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  000f4	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN20@SkillBrand:
  000f7	8b 45 08	 mov	 eax, DWORD PTR tv322[ebp]
$LN2@SkillBrand:

; 3009 : 					}
; 3010 : 				}
; 3011 : 			}
; 3012 : 		}
; 3013 : 
; 3014 : 		count++;

  000fa	83 c0 0c	 add	 eax, 12			; 0000000cH

; 3015 : 
; 3016 : 		if(count > MAX_VIEWPORT - 1)

  000fd	ff 4d fc	 dec	 DWORD PTR tv360[ebp]
  00100	89 45 08	 mov	 DWORD PTR tv322[ebp], eax
  00103	0f 85 7a ff ff
	ff		 jne	 $LL7@SkillBrand

; 3017 : 		{
; 3018 : 			break;
; 3019 : 		}
; 3020 : 	}
; 3021 : 	return true;

  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	b8 01 00 00 00	 mov	 eax, 1
  00110	5f		 pop	 edi

; 3022 : }

  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c2 0c 00	 ret	 12			; 0000000cH
?SkillBrandOfSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillBrandOfSkill
_TEXT	ENDS
PUBLIC	?SkillStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@EEEE@Z ; CObjUseSkill::SkillStun
EXTRN	?gObjSetPosition@@YAXHHH@Z:PROC			; gObjSetPosition
EXTRN	?SkillElectricSparkHitBox@@3VCSkillHitBox@@A:BYTE ; SkillElectricSparkHitBox
EXTRN	?gObjSetKillCount@@YAXHH@Z:PROC			; gObjSetKillCount
; Function compile flags: /Ogtp
;	COMDAT ?SkillStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@EEEE@Z
_TEXT	SEGMENT
_iangle$ = -4						; size = 4
_this$ = -4						; size = 4
tv171 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
_btX$ = 20						; size = 1
_btY$ = 24						; size = 1
_btDir$ = 28						; size = 1
tv436 = 32						; size = 4
_btTargetPos$ = 32					; size = 1
?SkillStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@EEEE@Z PROC ; CObjUseSkill::SkillStun, COMDAT
; _this$ = ecx

; 3028 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 3029 : 	if(OBJMAX_RANGE(aIndex) == false)

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000b	85 db		 test	 ebx, ebx
  0000d	78 0f		 js	 SHORT $LN21@SkillStun
  0000f	33 c0		 xor	 eax, eax
  00011	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	75 09		 jne	 SHORT $LN11@SkillStun
$LN21@SkillStun:

; 3030 : 	{
; 3031 : 		return false;

  0001e	33 c0		 xor	 eax, eax
  00020	5b		 pop	 ebx

; 3084 : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 1c 00	 ret	 28			; 0000001cH
$LN11@SkillStun:

; 3032 : 	}
; 3033 : 
; 3034 : 	LPOBJ lpObj = &gObj[aIndex];
; 3035 : 
; 3036 : 	int TargePosx = lpObj->X - (8 - (btTargetPos & 15));
; 3037 : 	int TargePosy = lpObj->Y - (8 - ((btTargetPos & 240) >> 4));

  00027	0f b6 45 20	 movzx	 eax, BYTE PTR _btTargetPos$[ebp]
  0002b	56		 push	 esi
  0002c	57		 push	 edi
  0002d	8b fb		 mov	 edi, ebx
  0002f	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00035	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003b	0f bf 97 06 01
	00 00		 movsx	 edx, WORD PTR [edi+262]
  00042	0f bf b7 04 01
	00 00		 movsx	 esi, WORD PTR [edi+260]
  00049	8b c8		 mov	 ecx, eax
  0004b	c1 e9 04	 shr	 ecx, 4

; 3038 : 
; 3039 : 	int iangle = this->GetAngle(lpObj->X,lpObj->Y,TargePosx,TargePosy);

  0004e	8d 4c 11 f8	 lea	 ecx, DWORD PTR [ecx+edx-8]
  00052	51		 push	 ecx
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	83 e0 0f	 and	 eax, 15			; 0000000fH
  00059	8d 44 30 f8	 lea	 eax, DWORD PTR [eax+esi-8]
  0005d	50		 push	 eax
  0005e	52		 push	 edx
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 ?GetAngle@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::GetAngle
  00065	89 45 fc	 mov	 DWORD PTR _iangle$[ebp], eax

; 3040 : 
; 3041 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)

  00068	8a 87 09 01 00
	00		 mov	 al, BYTE PTR [edi+265]
  0006e	3c 1e		 cmp	 al, 30			; 0000001eH
  00070	74 0f		 je	 SHORT $LN10@SkillStun
  00072	3c 1f		 cmp	 al, 31			; 0000001fH
  00074	74 0b		 je	 SHORT $LN10@SkillStun

; 3042 : 	{
; 3043 : 		return false;

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	33 c0		 xor	 eax, eax
  0007a	5b		 pop	 ebx

; 3084 : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 1c 00	 ret	 28			; 0000001cH
$LN10@SkillStun:

; 3044 : 	}
; 3045 : 
; 3046 : 	int tObjNum;
; 3047 : 	int count = 0;
; 3048 : 
; 3049 : 	gObjSetKillCount(aIndex,0);

  00081	6a 00		 push	 0
  00083	53		 push	 ebx
  00084	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount
  00089	8d 87 18 07 00
	00		 lea	 eax, DWORD PTR [edi+1816]
  0008f	83 c4 08	 add	 esp, 8
  00092	89 45 20	 mov	 DWORD PTR tv436[ebp], eax
  00095	c7 45 08 4b 00
	00 00		 mov	 DWORD PTR tv171[ebp], 75 ; 0000004bH
  0009c	8d 64 24 00	 npad	 4
$LL9@SkillStun:

; 3050 : 
; 3051 : 	while( true )
; 3052 : 	{
; 3053 : 		if(lpObj->VpPlayer2[count].state != 0)

  000a0	80 78 fc 00	 cmp	 BYTE PTR [eax-4], 0
  000a4	0f 84 cc 00 00
	00		 je	 $LN2@SkillStun

; 3054 : 		{
; 3055 : 			if(lpObj->VpPlayer2[count].type == OBJ_USER || lpObj->VpPlayer2[count].type == OBJ_MONSTER)

  000aa	8a 08		 mov	 cl, BYTE PTR [eax]
  000ac	80 f9 01	 cmp	 cl, 1
  000af	74 09		 je	 SHORT $LN5@SkillStun
  000b1	80 f9 02	 cmp	 cl, 2
  000b4	0f 85 bc 00 00
	00		 jne	 $LN2@SkillStun
$LN5@SkillStun:

; 3056 : 			{
; 3057 : 				tObjNum = lpObj->VpPlayer2[count].number;

  000ba	0f bf 58 fe	 movsx	 ebx, WORD PTR [eax-2]

; 3058 : 
; 3059 : 				if(OBJMAX_RANGE(tObjNum))

  000be	85 db		 test	 ebx, ebx
  000c0	0f 88 b0 00 00
	00		 js	 $LN2@SkillStun
  000c6	33 c9		 xor	 ecx, ecx
  000c8	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  000ce	0f 9e c1	 setle	 cl
  000d1	85 c9		 test	 ecx, ecx
  000d3	0f 84 9d 00 00
	00		 je	 $LN2@SkillStun

; 3060 : 				{
; 3061 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) <= 4)

  000d9	8b f3		 mov	 esi, ebx
  000db	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000e1	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000e7	50		 push	 eax
  000e8	57		 push	 edi
  000e9	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000ee	83 c4 08	 add	 esp, 8
  000f1	83 f8 04	 cmp	 eax, 4
  000f4	7f 7d		 jg	 SHORT $LN22@SkillStun

; 3062 : 					{
; 3063 : 						if(SkillElectricSparkHitBox.HitCheck(iangle,lpObj->X,lpObj->Y,gObj[tObjNum].X,gObj[tObjNum].Y))

  000f6	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  000fd	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  00104	0f bf 87 06 01
	00 00		 movsx	 eax, WORD PTR [edi+262]
  0010b	51		 push	 ecx
  0010c	0f bf 8f 04 01
	00 00		 movsx	 ecx, WORD PTR [edi+260]
  00113	52		 push	 edx
  00114	8b 55 fc	 mov	 edx, DWORD PTR _iangle$[ebp]
  00117	50		 push	 eax
  00118	51		 push	 ecx
  00119	52		 push	 edx
  0011a	b9 00 00 00 00	 mov	 ecx, OFFSET ?SkillElectricSparkHitBox@@3VCSkillHitBox@@A ; SkillElectricSparkHitBox
  0011f	e8 00 00 00 00	 call	 ?HitCheck@CSkillHitBox@@QAEHHHHHH@Z ; CSkillHitBox::HitCheck
  00124	85 c0		 test	 eax, eax
  00126	74 4b		 je	 SHORT $LN22@SkillStun

; 3064 : 						{
; 3065 : 							gObj[tObjNum].m_iSkillStunTime = 10;
; 3066 : 							gObj[tObjNum].m_ViewSkillState |= 4096;

  00128	81 8e c4 01 00
	00 00 10 00 00	 or	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+452], 4096 ; 00001000H

; 3067 : 							GCStateInfoSend(&gObj[tObjNum],1,4096);

  00132	68 00 10 00 00	 push	 4096			; 00001000H
  00137	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  0013d	6a 01		 push	 1
  0013f	50		 push	 eax
  00140	c7 86 dc 14 00
	00 0a 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+5340], 10 ; 0000000aH
  0014a	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend

; 3068 : 							GCMagicAttackNumberSend(lpObj,AT_SKILL_STUN,tObjNum,1);

  0014f	6a 01		 push	 1
  00151	53		 push	 ebx
  00152	6a 43		 push	 67			; 00000043H
  00154	57		 push	 edi
  00155	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 3069 : 							gObjSetPosition(tObjNum,gObj[tObjNum].X,gObj[tObjNum].Y);

  0015a	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  00161	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  00168	50		 push	 eax
  00169	51		 push	 ecx
  0016a	53		 push	 ebx
  0016b	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  00170	83 c4 28	 add	 esp, 40			; 00000028H
$LN22@SkillStun:
  00173	8b 45 20	 mov	 eax, DWORD PTR tv436[ebp]
$LN2@SkillStun:

; 3070 : 						}
; 3071 : 					}
; 3072 : 				}
; 3073 : 			}
; 3074 : 		}
; 3075 : 
; 3076 : 		count++;

  00176	83 c0 0c	 add	 eax, 12			; 0000000cH

; 3077 : 
; 3078 : 		if(count > MAX_VIEWPORT - 1)

  00179	ff 4d 08	 dec	 DWORD PTR tv171[ebp]
  0017c	89 45 20	 mov	 DWORD PTR tv436[ebp], eax
  0017f	0f 85 1b ff ff
	ff		 jne	 $LL9@SkillStun

; 3079 : 		{
; 3080 : 			break;
; 3081 : 		}
; 3082 : 	}
; 3083 : 	return true;

  00185	5f		 pop	 edi
  00186	5e		 pop	 esi
  00187	b8 01 00 00 00	 mov	 eax, 1
  0018c	5b		 pop	 ebx

; 3084 : }

  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c2 1c 00	 ret	 28			; 0000001cH
?SkillStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@EEEE@Z ENDP ; CObjUseSkill::SkillStun
_TEXT	ENDS
PUBLIC	?SkillRemoveStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRemoveStun
; Function compile flags: /Ogtp
;	COMDAT ?SkillRemoveStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv224 = -8						; size = 4
tv359 = -4						; size = 4
tv314 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillRemoveStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillRemoveStun, COMDAT
; _this$ = ecx

; 3090 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3091 : 
; 3092 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 0e		 js	 SHORT $LN19@SkillRemov
  0000d	33 c9		 xor	 ecx, ecx
  0000f	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00014	0f 9e c1	 setle	 cl
  00017	85 c9		 test	 ecx, ecx
  00019	75 08		 jne	 SHORT $LN9@SkillRemov
$LN19@SkillRemov:

; 3093 : 	{
; 3094 : 		return false;

  0001b	33 c0		 xor	 eax, eax

; 3139 : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
$LN9@SkillRemov:
  00023	57		 push	 edi

; 3095 : 	}
; 3096 : 
; 3097 : 	LPOBJ lpObj = &gObj[aIndex];

  00024	8b f8		 mov	 edi, eax
  00026	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0002c	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3098 : 
; 3099 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)

  00032	8a 8f 09 01 00
	00		 mov	 cl, BYTE PTR [edi+265]
  00038	80 f9 1e	 cmp	 cl, 30			; 0000001eH
  0003b	74 0e		 je	 SHORT $LN8@SkillRemov
  0003d	80 f9 1f	 cmp	 cl, 31			; 0000001fH
  00040	74 09		 je	 SHORT $LN8@SkillRemov

; 3100 : 	{
; 3101 : 		return false;

  00042	33 c0		 xor	 eax, eax
  00044	5f		 pop	 edi

; 3139 : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 0c 00	 ret	 12			; 0000000cH
$LN8@SkillRemov:

; 3102 : 	}
; 3103 : 
; 3104 : 	int tObjNum;
; 3105 : 	int count = 0;
; 3106 : 
; 3107 : 	gObjSetKillCount(aIndex,0);

  0004b	6a 00		 push	 0
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount

; 3108 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_REMOVAL_STUN,lpObj->m_Index,1);

  00053	8b 07		 mov	 eax, DWORD PTR [edi]
  00055	6a 01		 push	 1
  00057	50		 push	 eax
  00058	6a 44		 push	 68			; 00000044H
  0005a	57		 push	 edi
  0005b	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  00060	83 c4 18	 add	 esp, 24			; 00000018H
  00063	8d 87 16 07 00
	00		 lea	 eax, DWORD PTR [edi+1814]
  00069	53		 push	 ebx
  0006a	89 45 08	 mov	 DWORD PTR tv314[ebp], eax
  0006d	c7 45 fc 4b 00
	00 00		 mov	 DWORD PTR tv359[ebp], 75 ; 0000004bH
  00074	56		 push	 esi
$LL7@SkillRemov:

; 3109 : 
; 3110 : 	while( true )
; 3111 : 	{
; 3112 : 		if(lpObj->VpPlayer2[count].state != 0)

  00075	80 78 fe 00	 cmp	 BYTE PTR [eax-2], 0
  00079	74 71		 je	 SHORT $LN2@SkillRemov

; 3113 : 		{
; 3114 : 
; 3115 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0007b	0f bf 18	 movsx	 ebx, WORD PTR [eax]

; 3116 : 			if(OBJMAX_RANGE(tObjNum))

  0007e	85 db		 test	 ebx, ebx
  00080	78 6a		 js	 SHORT $LN2@SkillRemov
  00082	33 c9		 xor	 ecx, ecx
  00084	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  0008a	0f 9e c1	 setle	 cl
  0008d	85 c9		 test	 ecx, ecx
  0008f	74 5b		 je	 SHORT $LN2@SkillRemov

; 3117 : 			{
; 3118 : 				if(lpObj->VpPlayer2[count].type == OBJ_USER)

  00091	80 78 02 01	 cmp	 BYTE PTR [eax+2], 1
  00095	75 55		 jne	 SHORT $LN2@SkillRemov

; 3119 : 				{
; 3120 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 6)

  00097	8b f3		 mov	 esi, ebx
  00099	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0009f	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000a5	50		 push	 eax
  000a6	57		 push	 edi
  000a7	89 45 f8	 mov	 DWORD PTR tv224[ebp], eax
  000aa	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000af	83 c4 08	 add	 esp, 8
  000b2	83 f8 06	 cmp	 eax, 6
  000b5	7d 32		 jge	 SHORT $LN20@SkillRemov

; 3121 : 					{
; 3122 : 						gObj[tObjNum].m_iSkillStunTime = 0;
; 3123 : 						gObj[tObjNum].m_ViewSkillState &= ~4096;
; 3124 : 						GCStateInfoSend(&gObj[tObjNum],0,4096);

  000b7	8b 4d f8	 mov	 ecx, DWORD PTR tv224[ebp]
  000ba	81 a6 c4 01 00
	00 ff ef ff ff	 and	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+452], -4097 ; ffffefffH
  000c4	68 00 10 00 00	 push	 4096			; 00001000H
  000c9	6a 00		 push	 0
  000cb	51		 push	 ecx
  000cc	c7 86 dc 14 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+5340], 0
  000d6	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend

; 3125 : 						GCMagicAttackNumberSend(lpObj,AT_SKILL_REMOVAL_STUN,tObjNum,1);

  000db	6a 01		 push	 1
  000dd	53		 push	 ebx
  000de	6a 44		 push	 68			; 00000044H
  000e0	57		 push	 edi
  000e1	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  000e6	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN20@SkillRemov:
  000e9	8b 45 08	 mov	 eax, DWORD PTR tv314[ebp]
$LN2@SkillRemov:

; 3126 : 					}
; 3127 : 				}
; 3128 : 			}
; 3129 : 		}
; 3130 : 
; 3131 : 		count++;

  000ec	83 c0 0c	 add	 eax, 12			; 0000000cH

; 3132 : 
; 3133 : 		if(count > MAX_VIEWPORT - 1)

  000ef	ff 4d fc	 dec	 DWORD PTR tv359[ebp]
  000f2	89 45 08	 mov	 DWORD PTR tv314[ebp], eax
  000f5	0f 85 7a ff ff
	ff		 jne	 $LL7@SkillRemov

; 3134 : 		{
; 3135 : 			break;
; 3136 : 		}
; 3137 : 	}
; 3138 : return true;

  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
  000fd	b8 01 00 00 00	 mov	 eax, 1
  00102	5f		 pop	 edi

; 3139 : }

  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c2 0c 00	 ret	 12			; 0000000cH
?SkillRemoveStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillRemoveStun
_TEXT	ENDS
PUBLIC	?SkillAddMana@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillAddMana
; Function compile flags: /Ogtp
;	COMDAT ?SkillAddMana@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv456 = -24						; size = 4
tv502 = -20						; size = 4
_tObjNum$ = -20						; size = 4
tv474 = -16						; size = 4
_count$ = -12						; size = 4
tv650 = -8						; size = 4
tv652 = -4						; size = 4
tv654 = 8						; size = 4
tv431 = 8						; size = 4
tv400 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillAddMana@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::SkillAddMana, COMDAT
; _this$ = ecx

; 3145 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3146 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	83 ec 18	 sub	 esp, 24			; 00000018H
  00009	85 c0		 test	 eax, eax
  0000b	78 0e		 js	 SHORT $LN23@SkillAddMa
  0000d	33 c9		 xor	 ecx, ecx
  0000f	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00014	0f 9e c1	 setle	 cl
  00017	85 c9		 test	 ecx, ecx
  00019	75 08		 jne	 SHORT $LN12@SkillAddMa
$LN23@SkillAddMa:

; 3147 : 	{
; 3148 : 		return false;

  0001b	33 c0		 xor	 eax, eax

; 3229 : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
$LN12@SkillAddMa:
  00023	57		 push	 edi

; 3149 : 	}
; 3150 : 
; 3151 : 	LPOBJ lpObj = &gObj[aIndex];

  00024	8b f8		 mov	 edi, eax
  00026	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0002c	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3152 : 
; 3153 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)

  00032	8a 8f 09 01 00
	00		 mov	 cl, BYTE PTR [edi+265]
  00038	80 f9 1e	 cmp	 cl, 30			; 0000001eH
  0003b	74 0e		 je	 SHORT $LN11@SkillAddMa
  0003d	80 f9 1f	 cmp	 cl, 31			; 0000001fH
  00040	74 09		 je	 SHORT $LN11@SkillAddMa

; 3154 : 	{
; 3155 : 		return false;

  00042	33 c0		 xor	 eax, eax
  00044	5f		 pop	 edi

; 3229 : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 0c 00	 ret	 12			; 0000000cH
$LN11@SkillAddMa:
  0004b	53		 push	 ebx
  0004c	56		 push	 esi

; 3156 : 	}
; 3157 : 
; 3158 : 	int tObjNum;
; 3159 : 	int count = 0;
; 3160 : 	gObjSetKillCount(aIndex,0);

  0004d	6a 00		 push	 0
  0004f	50		 push	 eax
  00050	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00057	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount

; 3161 : 
; 3162 : 	lpObj->AddMana -= lpObj->m_iSkillManaSwell;

  0005c	8b b7 10 01 00
	00		 mov	 esi, DWORD PTR [edi+272]
  00062	2b b7 ec 14 00
	00		 sub	 esi, DWORD PTR [edi+5356]
  00068	83 c4 08	 add	 esp, 8
  0006b	89 75 08	 mov	 DWORD PTR tv400[ebp], esi

; 3163 : 
; 3164 : 	int iSwelledMana = short(lpObj->MaxMana + lpObj->AddMana) * 50 / 100;

  0006e	db 45 08	 fild	 DWORD PTR tv400[ebp]
  00071	d8 87 d4 00 00
	00		 fadd	 DWORD PTR [edi+212]
  00077	e8 00 00 00 00	 call	 __ftol2_sse
  0007c	0f bf c8	 movsx	 ecx, ax
  0007f	6b c9 32	 imul	 ecx, 50			; 00000032H
  00082	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00087	f7 e9		 imul	 ecx
  00089	c1 fa 05	 sar	 edx, 5
  0008c	8b c2		 mov	 eax, edx
  0008e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00091	03 c2		 add	 eax, edx

; 3165 : 	lpObj->AddMana += iSwelledMana;

  00093	03 f0		 add	 esi, eax

; 3166 : 	lpObj->m_iSkillManaSwellTime = 60;
; 3167 : 	lpObj->m_iSkillManaSwell = iSwelledMana;

  00095	89 87 ec 14 00
	00		 mov	 DWORD PTR [edi+5356], eax

; 3168 : 
; 3169 : 	GCManaSend(lpObj->m_Index,lpObj->MaxMana + lpObj->AddMana,0xFE,0,lpObj->MaxBP + lpObj->AddBP);

  0009b	8b 87 f0 00 00
	00		 mov	 eax, DWORD PTR [edi+240]
  000a1	03 87 ec 00 00
	00		 add	 eax, DWORD PTR [edi+236]
  000a7	89 b7 10 01 00
	00		 mov	 DWORD PTR [edi+272], esi
  000ad	50		 push	 eax
  000ae	db 87 10 01 00
	00		 fild	 DWORD PTR [edi+272]
  000b4	6a 00		 push	 0
  000b6	68 fe 00 00 00	 push	 254			; 000000feH
  000bb	c7 87 e8 14 00
	00 3c 00 00 00	 mov	 DWORD PTR [edi+5352], 60 ; 0000003cH
  000c5	d8 87 d4 00 00
	00		 fadd	 DWORD PTR [edi+212]
  000cb	e8 00 00 00 00	 call	 __ftol2_sse
  000d0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend

; 3170 : 
; 3171 : 	if( (lpObj->MaxMana + lpObj->AddMana) < lpObj->Mana)

  000d9	db 87 10 01 00
	00		 fild	 DWORD PTR [edi+272]
  000df	83 c4 14	 add	 esp, 20			; 00000014H
  000e2	d8 87 d4 00 00
	00		 fadd	 DWORD PTR [edi+212]
  000e8	d9 87 d0 00 00
	00		 fld	 DWORD PTR [edi+208]
  000ee	d8 d9		 fcomp	 ST(1)
  000f0	df e0		 fnstsw	 ax
  000f2	f6 c4 41	 test	 ah, 65			; 00000041H
  000f5	75 2d		 jne	 SHORT $LN27@SkillAddMa

; 3172 : 	{
; 3173 : 		lpObj->Mana = lpObj->MaxMana + lpObj->AddMana;
; 3174 : 		GCManaSend(lpObj->m_Index,lpObj->Mana,0xFF,0,lpObj->BP);

  000f7	8b 97 e8 00 00
	00		 mov	 edx, DWORD PTR [edi+232]
  000fd	d9 5d 08	 fstp	 DWORD PTR tv431[ebp]
  00100	d9 45 08	 fld	 DWORD PTR tv431[ebp]
  00103	52		 push	 edx
  00104	6a 00		 push	 0
  00106	d9 97 d0 00 00
	00		 fst	 DWORD PTR [edi+208]
  0010c	68 ff 00 00 00	 push	 255			; 000000ffH
  00111	e8 00 00 00 00	 call	 __ftol2_sse
  00116	50		 push	 eax
  00117	8b 07		 mov	 eax, DWORD PTR [edi]
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  0011f	83 c4 14	 add	 esp, 20			; 00000014H
  00122	eb 02		 jmp	 SHORT $LN10@SkillAddMa
$LN27@SkillAddMa:
  00124	dd d8		 fstp	 ST(0)
$LN10@SkillAddMa:

; 3175 : 	}
; 3176 : 
; 3177 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_ADD_MANA,lpObj->m_Index,1);

  00126	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00128	6a 01		 push	 1
  0012a	51		 push	 ecx
  0012b	6a 45		 push	 69			; 00000045H
  0012d	57		 push	 edi
  0012e	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  00133	8d 97 18 07 00
	00		 lea	 edx, DWORD PTR [edi+1816]
  00139	8d 87 16 07 00
	00		 lea	 eax, DWORD PTR [edi+1814]
  0013f	8d 8f 14 07 00
	00		 lea	 ecx, DWORD PTR [edi+1812]
  00145	83 c4 10	 add	 esp, 16			; 00000010H
  00148	89 55 f8	 mov	 DWORD PTR tv650[ebp], edx
  0014b	89 45 fc	 mov	 DWORD PTR tv652[ebp], eax
  0014e	89 4d 08	 mov	 DWORD PTR tv654[ebp], ecx
$LL9@SkillAddMa:

; 3178 : 
; 3179 : 	while( true )
; 3180 : 	{
; 3181 : 		if(lpObj->VpPlayer2[count].state != 0)

  00151	8b 55 08	 mov	 edx, DWORD PTR tv654[ebp]
  00154	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00157	0f 84 76 01 00
	00		 je	 $LN4@SkillAddMa

; 3182 : 		{
; 3183 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0015d	8b 45 fc	 mov	 eax, DWORD PTR tv652[ebp]
  00160	0f bf 30	 movsx	 esi, WORD PTR [eax]
  00163	89 75 ec	 mov	 DWORD PTR _tObjNum$[ebp], esi

; 3184 : 
; 3185 : 			if(OBJMAX_RANGE(tObjNum) && lpObj->VpPlayer2[count].type == OBJ_USER)

  00166	85 f6		 test	 esi, esi
  00168	0f 88 65 01 00
	00		 js	 $LN4@SkillAddMa
  0016e	33 c0		 xor	 eax, eax
  00170	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00176	0f 9e c0	 setle	 al
  00179	85 c0		 test	 eax, eax
  0017b	0f 84 52 01 00
	00		 je	 $LN4@SkillAddMa
  00181	8b 4d f8	 mov	 ecx, DWORD PTR tv650[ebp]
  00184	80 39 01	 cmp	 BYTE PTR [ecx], 1
  00187	0f 85 46 01 00
	00		 jne	 $LN4@SkillAddMa

; 3186 : 			{
; 3187 : 				if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 5)

  0018d	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00193	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00199	50		 push	 eax
  0019a	57		 push	 edi
  0019b	89 45 e8	 mov	 DWORD PTR tv456[ebp], eax
  0019e	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  001a3	83 c4 08	 add	 esp, 8
  001a6	83 f8 05	 cmp	 eax, 5
  001a9	0f 8d 24 01 00
	00		 jge	 $LN4@SkillAddMa

; 3188 : 				{
; 3189 : 					if(lpObj->GuildNumber > 0 && gObj[tObjNum].GuildNumber > 0)

  001af	8b 8f b0 02 00
	00		 mov	 ecx, DWORD PTR [edi+688]
  001b5	85 c9		 test	 ecx, ecx
  001b7	0f 8e 16 01 00
	00		 jle	 $LN4@SkillAddMa
  001bd	8b 86 b0 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+688]
  001c3	85 c0		 test	 eax, eax
  001c5	0f 8e 08 01 00
	00		 jle	 $LN4@SkillAddMa

; 3190 : 					{
; 3191 : 						if(lpObj->GuildNumber != gObj[tObjNum].GuildNumber)

  001cb	3b c8		 cmp	 ecx, eax
  001cd	74 16		 je	 SHORT $LN3@SkillAddMa

; 3192 : 						{
; 3193 : 							count++;

  001cf	ff 45 f4	 inc	 DWORD PTR _count$[ebp]
  001d2	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  001d7	01 45 08	 add	 DWORD PTR tv654[ebp], eax
  001da	01 45 fc	 add	 DWORD PTR tv652[ebp], eax
  001dd	01 45 f8	 add	 DWORD PTR tv650[ebp], eax

; 3194 : 							continue;

  001e0	e9 6c ff ff ff	 jmp	 $LL9@SkillAddMa
$LN3@SkillAddMa:

; 3195 : 						}
; 3196 : 
; 3197 : 						gObj[tObjNum].AddMana -= gObj[tObjNum].m_iSkillManaSwell;

  001e5	8b 9e 10 01 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+272]
  001eb	2b 9e ec 14 00
	00		 sub	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+5356]
  001f1	89 5d f0	 mov	 DWORD PTR tv474[ebp], ebx

; 3198 : 						iSwelledMana = short(gObj[tObjNum].MaxMana + gObj[tObjNum].AddMana) * 50 / 100;

  001f4	db 45 f0	 fild	 DWORD PTR tv474[ebp]
  001f7	d8 86 d4 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  001fd	e8 00 00 00 00	 call	 __ftol2_sse
  00202	0f bf c8	 movsx	 ecx, ax
  00205	6b c9 32	 imul	 ecx, 50			; 00000032H
  00208	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0020d	f7 e9		 imul	 ecx
  0020f	c1 fa 05	 sar	 edx, 5
  00212	8b c2		 mov	 eax, edx
  00214	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00217	03 c2		 add	 eax, edx

; 3199 : 						gObj[tObjNum].AddMana += iSwelledMana;
; 3200 : 
; 3201 : 						gObj[tObjNum].m_iSkillManaSwellTime = 60;
; 3202 : 						gObj[tObjNum].m_iSkillManaSwell = iSwelledMana;
; 3203 : 
; 3204 : 
; 3205 : 						GCManaSend(tObjNum,gObj[tObjNum].MaxMana + gObj[tObjNum].AddMana,0xFE,0,gObj[tObjNum].MaxBP + gObj[tObjNum].AddBP);

  00219	8b 96 f0 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+240]
  0021f	03 96 ec 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+236]
  00225	03 d8		 add	 ebx, eax
  00227	89 9e 10 01 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+272], ebx
  0022d	52		 push	 edx
  0022e	db 86 10 01 00
	00		 fild	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+272]
  00234	6a 00		 push	 0
  00236	68 fe 00 00 00	 push	 254			; 000000feH
  0023b	c7 86 e8 14 00
	00 3c 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+5352], 60 ; 0000003cH
  00245	d8 86 d4 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  0024b	89 86 ec 14 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+5356], eax
  00251	e8 00 00 00 00	 call	 __ftol2_sse
  00256	8b 5d ec	 mov	 ebx, DWORD PTR _tObjNum$[ebp]
  00259	50		 push	 eax
  0025a	53		 push	 ebx
  0025b	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend

; 3206 : 
; 3207 : 						if(gObj[tObjNum].Mana > gObj[tObjNum].MaxMana + gObj[tObjNum].AddMana)

  00260	db 86 10 01 00
	00		 fild	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+272]
  00266	83 c4 14	 add	 esp, 20			; 00000014H
  00269	d8 86 d4 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  0026f	d9 86 d0 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+208]
  00275	d8 d9		 fcomp	 ST(1)
  00277	df e0		 fnstsw	 ax
  00279	f6 c4 41	 test	 ah, 65			; 00000041H
  0027c	75 2b		 jne	 SHORT $LN30@SkillAddMa

; 3208 : 						{
; 3209 : 							gObj[tObjNum].Mana = gObj[tObjNum].MaxMana + gObj[tObjNum].AddMana;
; 3210 : 							GCManaSend(tObjNum,gObj[tObjNum].Mana,0xFF,0,gObj[tObjNum].BP);

  0027e	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+232]
  00284	d9 5d ec	 fstp	 DWORD PTR tv502[ebp]
  00287	d9 45 ec	 fld	 DWORD PTR tv502[ebp]
  0028a	50		 push	 eax
  0028b	6a 00		 push	 0
  0028d	d9 96 d0 00 00
	00		 fst	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+208]
  00293	68 ff 00 00 00	 push	 255			; 000000ffH
  00298	e8 00 00 00 00	 call	 __ftol2_sse
  0029d	50		 push	 eax
  0029e	53		 push	 ebx
  0029f	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  002a4	83 c4 14	 add	 esp, 20			; 00000014H
  002a7	eb 02		 jmp	 SHORT $LN2@SkillAddMa
$LN30@SkillAddMa:
  002a9	dd d8		 fstp	 ST(0)
$LN2@SkillAddMa:

; 3211 : 						}
; 3212 : 
; 3213 : 						gObj[tObjNum].m_ViewSkillState |= 8192;
; 3214 : 						GCStateInfoSend(&gObj[tObjNum],1,8192);

  002ab	8b 4d e8	 mov	 ecx, DWORD PTR tv456[ebp]
  002ae	81 8e c4 01 00
	00 00 20 00 00	 or	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+452], 8192 ; 00002000H
  002b8	68 00 20 00 00	 push	 8192			; 00002000H
  002bd	6a 01		 push	 1
  002bf	51		 push	 ecx
  002c0	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend

; 3215 : 						GCMagicAttackNumberSend(lpObj,AT_SKILL_ADD_MANA,tObjNum,1);

  002c5	6a 01		 push	 1
  002c7	53		 push	 ebx
  002c8	6a 45		 push	 69			; 00000045H
  002ca	57		 push	 edi
  002cb	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  002d0	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN4@SkillAddMa:

; 3216 : 					}
; 3217 : 				}
; 3218 : 			}
; 3219 : 		}
; 3220 : 
; 3221 : 		count++;

  002d3	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  002d6	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  002db	01 4d 08	 add	 DWORD PTR tv654[ebp], ecx
  002de	01 4d fc	 add	 DWORD PTR tv652[ebp], ecx
  002e1	01 4d f8	 add	 DWORD PTR tv650[ebp], ecx
  002e4	40		 inc	 eax
  002e5	89 45 f4	 mov	 DWORD PTR _count$[ebp], eax

; 3222 : 
; 3223 : 		if(count > MAX_VIEWPORT - 1)

  002e8	83 f8 4a	 cmp	 eax, 74			; 0000004aH
  002eb	0f 8e 60 fe ff
	ff		 jle	 $LL9@SkillAddMa

; 3224 : 		{
; 3225 : 			break;
; 3226 : 		}
; 3227 : 	}
; 3228 : 	return true;

  002f1	5e		 pop	 esi
  002f2	5b		 pop	 ebx
  002f3	8d 41 f5	 lea	 eax, DWORD PTR [ecx-11]
  002f6	5f		 pop	 edi

; 3229 : }

  002f7	8b e5		 mov	 esp, ebp
  002f9	5d		 pop	 ebp
  002fa	c2 0c 00	 ret	 12			; 0000000cH
?SkillAddMana@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::SkillAddMana
_TEXT	ENDS
PUBLIC	??_C@_0FJ@KFEKMJMJ@?$FLANTI?9HACK?$FN?$FLCloaking?5Skill?$FN?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	?SkillCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillCloaking
;	COMDAT ??_C@_0FJ@KFEKMJMJ@?$FLANTI?9HACK?$FN?$FLCloaking?5Skill?$FN?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0FJ@KFEKMJMJ@?$FLANTI?9HACK?$FN?$FLCloaking?5Skill?$FN?5?$FL?$CFs?$FN@ DB '['
	DB	'ANTI-HACK][Cloaking Skill] [%s][%s] Invalid Targeting  Target'
	DB	'Type [%d] TargetClass [%d]', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SkillCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillCloaking, COMDAT
; _this$ = ecx

; 3235 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3236 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN11@SkillCloak
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN4@SkillCloak
$LN11@SkillCloak:

; 3237 : 	{
; 3238 : 		return false;

  00018	33 c0		 xor	 eax, eax

; 3270 : }

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
$LN4@SkillCloak:
  0001e	53		 push	 ebx

; 3239 : 	}
; 3240 : 
; 3241 : 	if(OBJMAX_RANGE(aTargetIndex) == false)

  0001f	8b 5d 0c	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]
  00022	85 db		 test	 ebx, ebx
  00024	78 0f		 js	 SHORT $LN12@SkillCloak
  00026	33 c9		 xor	 ecx, ecx
  00028	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  0002e	0f 9e c1	 setle	 cl
  00031	85 c9		 test	 ecx, ecx
  00033	75 07		 jne	 SHORT $LN3@SkillCloak
$LN12@SkillCloak:

; 3242 : 	{
; 3243 : 		return false;

  00035	33 c0		 xor	 eax, eax
  00037	5b		 pop	 ebx

; 3270 : }

  00038	5d		 pop	 ebp
  00039	c2 0c 00	 ret	 12			; 0000000cH
$LN3@SkillCloak:
  0003c	56		 push	 esi
  0003d	57		 push	 edi

; 3244 : 	}
; 3245 : 
; 3246 : 	LPOBJ lpObj = &gObj[aIndex];

  0003e	8b f8		 mov	 edi, eax
  00040	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H

; 3247 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  00046	8b f3		 mov	 esi, ebx
  00048	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0004e	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3248 : 
; 3249 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)

  00054	8a 8f 09 01 00
	00		 mov	 cl, BYTE PTR [edi+265]
  0005a	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00060	80 f9 1e	 cmp	 cl, 30			; 0000001eH
  00063	74 05		 je	 SHORT $LN2@SkillCloak
  00065	80 f9 1f	 cmp	 cl, 31			; 0000001fH

; 3250 : 	{
; 3251 : 		return false;

  00068	75 29		 jne	 SHORT $LN16@SkillCloak
$LN2@SkillCloak:

; 3252 : 	}
; 3253 : 
; 3254 : 	if(lpTargetObj->Type != OBJ_USER)

  0006a	0f b7 4e 60	 movzx	 ecx, WORD PTR [esi+96]
  0006e	83 f9 01	 cmp	 ecx, 1
  00071	74 29		 je	 SHORT $LN1@SkillCloak

; 3255 : 	{
; 3256 : 		LogAdd(LOG_BLACK, "[ANTI-HACK][Cloaking Skill] [%s][%s] Invalid Targeting  TargetType [%d] TargetClass [%d]",
; 3257 : 			lpObj->AccountID,lpObj->Name,lpTargetObj->Type,lpTargetObj->Class);

  00073	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  0007a	50		 push	 eax
  0007b	51		 push	 ecx
  0007c	8d 57 6f	 lea	 edx, DWORD PTR [edi+111]
  0007f	52		 push	 edx
  00080	83 c7 64	 add	 edi, 100		; 00000064H
  00083	57		 push	 edi
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@KFEKMJMJ@?$FLANTI?9HACK?$FN?$FLCloaking?5Skill?$FN?5?$FL?$CFs?$FN@
  00089	6a 00		 push	 0
  0008b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00090	83 c4 18	 add	 esp, 24			; 00000018H
$LN16@SkillCloak:

; 3258 : 		return false;

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	33 c0		 xor	 eax, eax
  00097	5b		 pop	 ebx

; 3270 : }

  00098	5d		 pop	 ebp
  00099	c2 0c 00	 ret	 12			; 0000000cH
$LN1@SkillCloak:

; 3259 : 	}
; 3260 : 
; 3261 : 	gObjSetKillCount(aIndex,0);

  0009c	6a 00		 push	 0
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount

; 3262 : 
; 3263 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_INVISIBLE,lpObj->m_Index,1);

  000a4	8b 07		 mov	 eax, DWORD PTR [edi]
  000a6	6a 01		 push	 1
  000a8	50		 push	 eax
  000a9	6a 46		 push	 70			; 00000046H
  000ab	57		 push	 edi
  000ac	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 3264 : 	lpTargetObj->m_iSkillInvisibleTime = 60;
; 3265 : 	lpTargetObj->m_ViewSkillState |= 16384;

  000b1	81 8e c4 01 00
	00 00 40 00 00	 or	 DWORD PTR [esi+452], 16384 ; 00004000H

; 3266 : 
; 3267 : 	GCStateInfoSend(lpTargetObj,1,16384);

  000bb	68 00 40 00 00	 push	 16384			; 00004000H
  000c0	6a 01		 push	 1
  000c2	56		 push	 esi
  000c3	c7 86 e4 14 00
	00 3c 00 00 00	 mov	 DWORD PTR [esi+5348], 60 ; 0000003cH
  000cd	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend

; 3268 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_INVISIBLE,aTargetIndex,1);

  000d2	6a 01		 push	 1
  000d4	53		 push	 ebx
  000d5	6a 46		 push	 70			; 00000046H
  000d7	57		 push	 edi
  000d8	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  000dd	83 c4 34	 add	 esp, 52			; 00000034H
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi

; 3269 : 	return true;

  000e2	b8 01 00 00 00	 mov	 eax, 1
  000e7	5b		 pop	 ebx

; 3270 : }

  000e8	5d		 pop	 ebp
  000e9	c2 0c 00	 ret	 12			; 0000000cH
?SkillCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillCloaking
_TEXT	ENDS
PUBLIC	?RemoveCloakingEffect@CObjUseSkill@@QAEHH@Z	; CObjUseSkill::RemoveCloakingEffect
; Function compile flags: /Ogtp
;	COMDAT ?RemoveCloakingEffect@CObjUseSkill@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?RemoveCloakingEffect@CObjUseSkill@@QAEHH@Z PROC	; CObjUseSkill::RemoveCloakingEffect, COMDAT
; _this$ = ecx

; 3274 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3275 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN6@RemoveCloa
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN1@RemoveCloa
$LN6@RemoveCloa:

; 3276 : 	{
; 3277 : 		return false;

  00018	33 c0		 xor	 eax, eax

; 3284 : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
$LN1@RemoveCloa:

; 3278 : 	}
; 3279 : 
; 3280 : 	gObj[aIndex].m_iSkillInvisibleTime = 0;

  0001e	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 3281 : 	gObj[aIndex].m_ViewSkillState &= ~16384;

  00024	81 a0 c4 01 00
	00 ff bf ff ff	 and	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+452], -16385 ; ffffbfffH

; 3282 : 	GCStateInfoSend(&gObj[aIndex],0,16384);

  0002e	68 00 40 00 00	 push	 16384			; 00004000H
  00033	c7 80 e4 14 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+5348], 0
  0003d	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  00043	6a 00		 push	 0
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3283 : 	return true;

  0004e	b8 01 00 00 00	 mov	 eax, 1

; 3284 : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?RemoveCloakingEffect@CObjUseSkill@@QAEHH@Z ENDP	; CObjUseSkill::RemoveCloakingEffect
_TEXT	ENDS
PUBLIC	?SkillRemoveCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRemoveCloaking
; Function compile flags: /Ogtp
;	COMDAT ?SkillRemoveCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv224 = -8						; size = 4
tv359 = -4						; size = 4
tv314 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillRemoveCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillRemoveCloaking, COMDAT
; _this$ = ecx

; 3290 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3291 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 0e		 js	 SHORT $LN18@SkillRemov@2
  0000d	33 c9		 xor	 ecx, ecx
  0000f	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00014	0f 9e c1	 setle	 cl
  00017	85 c9		 test	 ecx, ecx
  00019	75 08		 jne	 SHORT $LN8@SkillRemov@2
$LN18@SkillRemov@2:

; 3292 : 	{
; 3293 : 		return false;

  0001b	33 c0		 xor	 eax, eax

; 3335 : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
$LN8@SkillRemov@2:
  00023	57		 push	 edi

; 3294 : 	}
; 3295 : 
; 3296 : 	LPOBJ lpObj = &gObj[aIndex];

  00024	8b f8		 mov	 edi, eax
  00026	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0002c	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3297 : 
; 3298 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)

  00032	8a 8f 09 01 00
	00		 mov	 cl, BYTE PTR [edi+265]
  00038	80 f9 1e	 cmp	 cl, 30			; 0000001eH
  0003b	74 0e		 je	 SHORT $LN7@SkillRemov@2
  0003d	80 f9 1f	 cmp	 cl, 31			; 0000001fH
  00040	74 09		 je	 SHORT $LN7@SkillRemov@2

; 3299 : 	{
; 3300 : 		return false;

  00042	33 c0		 xor	 eax, eax
  00044	5f		 pop	 edi

; 3335 : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 0c 00	 ret	 12			; 0000000cH
$LN7@SkillRemov@2:

; 3301 : 	}
; 3302 : 
; 3303 : 	int tObjNum;
; 3304 : 	int count = 0;
; 3305 : 
; 3306 : 	gObjSetKillCount(aIndex,0);

  0004b	6a 00		 push	 0
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount

; 3307 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_REMOVAL_INVISIBLE,lpObj->m_Index,1);

  00053	8b 07		 mov	 eax, DWORD PTR [edi]
  00055	6a 01		 push	 1
  00057	50		 push	 eax
  00058	6a 47		 push	 71			; 00000047H
  0005a	57		 push	 edi
  0005b	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  00060	83 c4 18	 add	 esp, 24			; 00000018H
  00063	8d 87 16 07 00
	00		 lea	 eax, DWORD PTR [edi+1814]
  00069	53		 push	 ebx
  0006a	89 45 08	 mov	 DWORD PTR tv314[ebp], eax
  0006d	c7 45 fc 4b 00
	00 00		 mov	 DWORD PTR tv359[ebp], 75 ; 0000004bH
  00074	56		 push	 esi
$LL6@SkillRemov@2:

; 3308 : 
; 3309 : 	while ( true )
; 3310 : 	{
; 3311 : 		if(lpObj->VpPlayer2[count].state != 0)

  00075	80 78 fe 00	 cmp	 BYTE PTR [eax-2], 0
  00079	74 71		 je	 SHORT $LN2@SkillRemov@2

; 3312 : 		{
; 3313 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0007b	0f bf 18	 movsx	 ebx, WORD PTR [eax]

; 3314 : 
; 3315 : 			if(OBJMAX_RANGE(tObjNum) && lpObj->VpPlayer2[count].type == OBJ_USER)

  0007e	85 db		 test	 ebx, ebx
  00080	78 6a		 js	 SHORT $LN2@SkillRemov@2
  00082	33 c9		 xor	 ecx, ecx
  00084	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  0008a	0f 9e c1	 setle	 cl
  0008d	85 c9		 test	 ecx, ecx
  0008f	74 5b		 je	 SHORT $LN2@SkillRemov@2
  00091	80 78 02 01	 cmp	 BYTE PTR [eax+2], 1
  00095	75 55		 jne	 SHORT $LN2@SkillRemov@2

; 3316 : 			{
; 3317 : 				if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 5)

  00097	8b f3		 mov	 esi, ebx
  00099	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0009f	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000a5	50		 push	 eax
  000a6	57		 push	 edi
  000a7	89 45 f8	 mov	 DWORD PTR tv224[ebp], eax
  000aa	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000af	83 c4 08	 add	 esp, 8
  000b2	83 f8 05	 cmp	 eax, 5
  000b5	7d 32		 jge	 SHORT $LN19@SkillRemov@2

; 3318 : 				{
; 3319 : 					gObj[tObjNum].m_iSkillInvisibleTime = 0;
; 3320 : 					gObj[tObjNum].m_ViewSkillState &= ~16384;
; 3321 : 					GCStateInfoSend(&gObj[tObjNum],0,16384);

  000b7	8b 4d f8	 mov	 ecx, DWORD PTR tv224[ebp]
  000ba	81 a6 c4 01 00
	00 ff bf ff ff	 and	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+452], -16385 ; ffffbfffH
  000c4	68 00 40 00 00	 push	 16384			; 00004000H
  000c9	6a 00		 push	 0
  000cb	51		 push	 ecx
  000cc	c7 86 e4 14 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+5348], 0
  000d6	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend

; 3322 : 					GCMagicAttackNumberSend(lpObj,AT_SKILL_REMOVAL_INVISIBLE,tObjNum,1);

  000db	6a 01		 push	 1
  000dd	53		 push	 ebx
  000de	6a 47		 push	 71			; 00000047H
  000e0	57		 push	 edi
  000e1	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  000e6	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN19@SkillRemov@2:
  000e9	8b 45 08	 mov	 eax, DWORD PTR tv314[ebp]
$LN2@SkillRemov@2:

; 3323 : 				}
; 3324 : 			}
; 3325 : 		}
; 3326 : 
; 3327 : 		count++;

  000ec	83 c0 0c	 add	 eax, 12			; 0000000cH

; 3328 : 
; 3329 : 		if(count > MAX_VIEWPORT - 1)

  000ef	ff 4d fc	 dec	 DWORD PTR tv359[ebp]
  000f2	89 45 08	 mov	 DWORD PTR tv314[ebp], eax
  000f5	0f 85 7a ff ff
	ff		 jne	 $LL6@SkillRemov@2

; 3330 : 		{
; 3331 : 			break;
; 3332 : 		}
; 3333 : 	}
; 3334 : 	return true;

  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
  000fd	b8 01 00 00 00	 mov	 eax, 1
  00102	5f		 pop	 edi

; 3335 : }

  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c2 0c 00	 ret	 12			; 0000000cH
?SkillRemoveCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillRemoveCloaking
_TEXT	ENDS
PUBLIC	?SkillRemoveMagic@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRemoveMagic
; Function compile flags: /Ogtp
;	COMDAT ?SkillRemoveMagic@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv361 = -4						; size = 4
tv306 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillRemoveMagic@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillRemoveMagic, COMDAT
; _this$ = ecx

; 3341 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3342 : 	if(OBJMAX_RANGE(aIndex) == false)

  00006	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00009	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	85 c0		 test	 eax, eax
  0000e	78 0e		 js	 SHORT $LN18@SkillRemov@3
  00010	33 c9		 xor	 ecx, ecx
  00012	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00017	0f 9e c1	 setle	 cl
  0001a	85 c9		 test	 ecx, ecx
  0001c	75 08		 jne	 SHORT $LN8@SkillRemov@3
$LN18@SkillRemov@3:

; 3343 : 	{
; 3344 : 		return false;

  0001e	33 c0		 xor	 eax, eax

; 3385 : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
$LN8@SkillRemov@3:
  00026	57		 push	 edi

; 3345 : 	}
; 3346 : 
; 3347 : 	LPOBJ lpObj = &gObj[aIndex];

  00027	8b f8		 mov	 edi, eax
  00029	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0002f	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3348 : 
; 3349 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)

  00035	8a 8f 09 01 00
	00		 mov	 cl, BYTE PTR [edi+265]
  0003b	80 f9 1e	 cmp	 cl, 30			; 0000001eH
  0003e	74 0e		 je	 SHORT $LN7@SkillRemov@3
  00040	80 f9 1f	 cmp	 cl, 31			; 0000001fH
  00043	74 09		 je	 SHORT $LN7@SkillRemov@3

; 3350 : 	{
; 3351 : 		return false;

  00045	33 c0		 xor	 eax, eax
  00047	5f		 pop	 edi

; 3385 : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 0c 00	 ret	 12			; 0000000cH
$LN7@SkillRemov@3:

; 3352 : 	}
; 3353 : 
; 3354 : 	int tObjNum;
; 3355 : 	int count = 0;
; 3356 : 
; 3357 : 	gObjSetKillCount(aIndex,0);

  0004e	6a 00		 push	 0
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount

; 3358 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_REMOVAL_MAGIC,lpObj->m_Index,1);

  00056	8b 07		 mov	 eax, DWORD PTR [edi]
  00058	6a 01		 push	 1
  0005a	50		 push	 eax
  0005b	6a 48		 push	 72			; 00000048H
  0005d	57		 push	 edi
  0005e	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  00063	83 c4 18	 add	 esp, 24			; 00000018H
  00066	8d 87 16 07 00
	00		 lea	 eax, DWORD PTR [edi+1814]
  0006c	53		 push	 ebx
  0006d	89 45 08	 mov	 DWORD PTR tv306[ebp], eax
  00070	c7 45 fc 4b 00
	00 00		 mov	 DWORD PTR tv361[ebp], 75 ; 0000004bH
  00077	56		 push	 esi
$LL6@SkillRemov@3:

; 3359 : 
; 3360 : 	while ( true )
; 3361 : 	{
; 3362 : 		if(lpObj->VpPlayer2[count].state != 0)

  00078	80 78 fe 00	 cmp	 BYTE PTR [eax-2], 0
  0007c	74 60		 je	 SHORT $LN2@SkillRemov@3

; 3363 : 		{
; 3364 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0007e	0f bf 18	 movsx	 ebx, WORD PTR [eax]

; 3365 : 
; 3366 : 			if(OBJMAX_RANGE(tObjNum) && lpObj->VpPlayer2[count].type == OBJ_USER)

  00081	85 db		 test	 ebx, ebx
  00083	78 59		 js	 SHORT $LN2@SkillRemov@3
  00085	33 c9		 xor	 ecx, ecx
  00087	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  0008d	0f 9e c1	 setle	 cl
  00090	85 c9		 test	 ecx, ecx
  00092	74 4a		 je	 SHORT $LN2@SkillRemov@3
  00094	80 78 02 01	 cmp	 BYTE PTR [eax+2], 1
  00098	75 44		 jne	 SHORT $LN2@SkillRemov@3

; 3367 : 			{
; 3368 : 				if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 5)

  0009a	8b cb		 mov	 ecx, ebx
  0009c	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000a2	8d b1 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx]
  000a8	56		 push	 esi
  000a9	57		 push	 edi
  000aa	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000af	83 c4 08	 add	 esp, 8
  000b2	83 f8 05	 cmp	 eax, 5
  000b5	7d 24		 jge	 SHORT $LN19@SkillRemov@3

; 3369 : 				{
; 3370 : 					this->RemoveAllCharacterInvalidMagicAndSkillState(&gObj[tObjNum]);

  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	56		 push	 esi
  000bb	e8 00 00 00 00	 call	 ?RemoveAllCharacterInvalidMagicAndSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@@Z ; CObjUseSkill::RemoveAllCharacterInvalidMagicAndSkillState

; 3371 : 					GCStateInfoSend(&gObj[tObjNum],0,1048576);

  000c0	68 00 00 10 00	 push	 1048576			; 00100000H
  000c5	6a 00		 push	 0
  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend

; 3372 : 					GCMagicAttackNumberSend(lpObj,AT_SKILL_REMOVAL_MAGIC,tObjNum,1);

  000cd	6a 01		 push	 1
  000cf	53		 push	 ebx
  000d0	6a 48		 push	 72			; 00000048H
  000d2	57		 push	 edi
  000d3	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  000d8	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN19@SkillRemov@3:
  000db	8b 45 08	 mov	 eax, DWORD PTR tv306[ebp]
$LN2@SkillRemov@3:

; 3373 : 				}
; 3374 : 			}
; 3375 : 		}
; 3376 : 
; 3377 : 		count++;

  000de	83 c0 0c	 add	 eax, 12			; 0000000cH

; 3378 : 
; 3379 : 		if(count > MAX_VIEWPORT - 1)

  000e1	ff 4d fc	 dec	 DWORD PTR tv361[ebp]
  000e4	89 45 08	 mov	 DWORD PTR tv306[ebp], eax
  000e7	75 8f		 jne	 SHORT $LL6@SkillRemov@3

; 3380 : 		{
; 3381 : 			break;
; 3382 : 		}
; 3383 : 	}
; 3384 : 	return true;

  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx
  000eb	b8 01 00 00 00	 mov	 eax, 1
  000f0	5f		 pop	 edi

; 3385 : }

  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c2 0c 00	 ret	 12			; 0000000cH
?SkillRemoveMagic@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillRemoveMagic
_TEXT	ENDS
PUBLIC	?SkillFenrirAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillFenrirAttack
; Function compile flags: /Ogtp
;	COMDAT ?SkillFenrirAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_DuelIndex$ = -12					; size = 4
tv310 = -8						; size = 4
tv374 = -4						; size = 4
_HitCount$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillFenrirAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillFenrirAttack, COMDAT
; _this$ = ecx

; 3389 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	57		 push	 edi

; 3390 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000a	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00010	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3391 : 	int tObjNum;
; 3392 : 	int count = 0;
; 3393 : 	int HitCount = 0;
; 3394 : 	int bAttack;
; 3395 : 	int DuelIndex = lpObj->m_iDuelUser;

  00016	8b 87 1c 0d 00
	00		 mov	 eax, DWORD PTR [edi+3356]

; 3396 : 	int EnableAttack;
; 3397 : 
; 3398 : 	if(lpObj->Level < 300)

  0001c	b9 2c 01 00 00	 mov	 ecx, 300		; 0000012cH
  00021	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _HitCount$[ebp], 0
  00028	89 45 f4	 mov	 DWORD PTR _DuelIndex$[ebp], eax
  0002b	66 39 8f 9c 00
	00 00		 cmp	 WORD PTR [edi+156], cx
  00032	7d 09		 jge	 SHORT $LN29@SkillFenri

; 3399 : 	{
; 3400 : 		return false;

  00034	33 c0		 xor	 eax, eax
  00036	5f		 pop	 edi

; 3486 : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 0c 00	 ret	 12			; 0000000cH
$LN29@SkillFenri:

; 3401 : 	}
; 3402 : 
; 3403 : 	while( true )
; 3404 : 	{
; 3405 : 		if(lpObj->VpPlayer2[count].state != 0)

  0003d	8d 8f 16 07 00
	00		 lea	 ecx, DWORD PTR [edi+1814]
  00043	53		 push	 ebx
  00044	89 4d fc	 mov	 DWORD PTR tv374[ebp], ecx
  00047	c7 45 f8 4b 00
	00 00		 mov	 DWORD PTR tv310[ebp], 75 ; 0000004bH
  0004e	56		 push	 esi
  0004f	90		 npad	 1
$LL20@SkillFenri:
  00050	80 79 fe 00	 cmp	 BYTE PTR [ecx-2], 0
  00054	0f 84 c6 00 00
	00		 je	 $LN30@SkillFenri

; 3406 : 		{
; 3407 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0005a	0f bf 19	 movsx	 ebx, WORD PTR [ecx]

; 3408 : 
; 3409 : 			if(tObjNum >= 0)

  0005d	85 db		 test	 ebx, ebx
  0005f	0f 88 bb 00 00
	00		 js	 $LN30@SkillFenri

; 3410 : 			{
; 3411 : 				EnableAttack = 0;
; 3412 : 
; 3413 : 				if(gObj[tObjNum].Class < 100 || gObj[tObjNum].Class > 110)

  00065	8b f3		 mov	 esi, ebx
  00067	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0006d	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152]
  00074	83 f8 64	 cmp	 eax, 100		; 00000064H
  00077	72 09		 jb	 SHORT $LN15@SkillFenri
  00079	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  0007c	0f 86 9e 00 00
	00		 jbe	 $LN30@SkillFenri
$LN15@SkillFenri:

; 3414 : 				{
; 3415 : 					if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00082	80 79 02 02	 cmp	 BYTE PTR [ecx+2], 2
  00086	75 09		 jne	 SHORT $LN14@SkillFenri
  00088	83 be cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+716], 0

; 3416 : 					{
; 3417 : 						EnableAttack = 1;

  0008f	7c 4a		 jl	 SHORT $LN11@SkillFenri
$LN14@SkillFenri:

; 3418 : 					}
; 3419 : 					else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  00091	3b 5d 0c	 cmp	 ebx, DWORD PTR _aTargetIndex$[ebp]
  00094	74 45		 je	 SHORT $LN11@SkillFenri
  00096	39 5d f4	 cmp	 DWORD PTR _DuelIndex$[ebp], ebx
  00099	74 40		 je	 SHORT $LN11@SkillFenri

; 3420 : 					{
; 3421 : 						EnableAttack = 1;
; 3422 : 					}
; 3423 : #if GS_CASTLE == 1
; 3424 : 					else if (lpObj->VpPlayer2[count].type != OBJ_NPC &&
; 3425 : 							gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE &&
; 3426 : 							g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 3427 : 					{
; 3428 : 						EnableAttack = 1;
; 3429 : 					}
; 3430 : #endif
; 3431 : 					else
; 3432 : 					{
; 3433 : 						int CallMonIndex = gObj[tObjNum].m_Index;
; 3434 : 
; 3435 : 
; 3436 : 						if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  0009b	66 83 be 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+96], 2
  000a3	8b 86 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000a9	75 16		 jne	 SHORT $LN9@SkillFenri
  000ab	8b 8e cc 02 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+716]
  000b1	85 c9		 test	 ecx, ecx
  000b3	78 0c		 js	 SHORT $LN9@SkillFenri

; 3437 : 						{
; 3438 : 							CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  000b5	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000bb	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx]
$LN9@SkillFenri:

; 3439 : 						}
; 3440 : 
; 3441 : 						if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex]) == 1)

  000c1	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000c7	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cc	50		 push	 eax
  000cd	57		 push	 edi
  000ce	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000d3	83 c4 08	 add	 esp, 8
  000d6	83 f8 01	 cmp	 eax, 1
  000d9	75 45		 jne	 SHORT $LN30@SkillFenri
$LN11@SkillFenri:

; 3442 : 						{
; 3443 : 							EnableAttack = 1;
; 3444 : 						}
; 3445 : 					}
; 3446 : 				}
; 3447 : 
; 3448 : 				if(EnableAttack != 0)
; 3449 : 				{
; 3450 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 6)

  000db	8d 96 00 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000e1	52		 push	 edx
  000e2	57		 push	 edi
  000e3	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000e8	83 c4 08	 add	 esp, 8
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	7d 30		 jge	 SHORT $LN30@SkillFenri

; 3451 : 					{
; 3452 : 						bAttack = 0;
; 3453 : 
; 3454 : 						if(HitCount >= 5)

  000f0	33 c0		 xor	 eax, eax
  000f2	83 7d 08 05	 cmp	 DWORD PTR _HitCount$[ebp], 5
  000f6	0f 9c c0	 setl	 al

; 3455 : 						{
; 3456 : 							bAttack = 0;
; 3457 : 						}
; 3458 : 						else
; 3459 : 						{
; 3460 : 							bAttack = 1;
; 3461 : 						}
; 3462 : 
; 3463 : 						if(tObjNum == aTargetIndex)

  000f9	3b 5d 0c	 cmp	 ebx, DWORD PTR _aTargetIndex$[ebp]

; 3464 : 						{
; 3465 : 							bAttack = 1;
; 3466 : 						}
; 3467 : 
; 3468 : 						if(bAttack != 0)

  000fc	74 04		 je	 SHORT $LN28@SkillFenri
  000fe	85 c0		 test	 eax, eax
  00100	74 1e		 je	 SHORT $LN30@SkillFenri
$LN28@SkillFenri:

; 3469 : 						{
; 3470 : 							gObjAddAttackProcMsgSendDelay(lpObj,53,tObjNum,300,lpMagic->m_Skill,0);

  00102	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00105	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00109	6a 00		 push	 0
  0010b	51		 push	 ecx
  0010c	68 2c 01 00 00	 push	 300			; 0000012cH
  00111	53		 push	 ebx
  00112	6a 35		 push	 53			; 00000035H
  00114	57		 push	 edi
  00115	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  0011a	83 c4 18	 add	 esp, 24			; 00000018H

; 3471 : 							HitCount++;

  0011d	ff 45 08	 inc	 DWORD PTR _HitCount$[ebp]
$LN30@SkillFenri:

; 3472 : 						}
; 3473 : 					}
; 3474 : 				}
; 3475 : 			}
; 3476 : 		}
; 3477 : 
; 3478 : 		count++;

  00120	8b 4d fc	 mov	 ecx, DWORD PTR tv374[ebp]
  00123	83 c1 0c	 add	 ecx, 12			; 0000000cH

; 3479 : 
; 3480 : 		if(count > MAX_VIEWPORT - 1)

  00126	ff 4d f8	 dec	 DWORD PTR tv310[ebp]
  00129	89 4d fc	 mov	 DWORD PTR tv374[ebp], ecx
  0012c	0f 85 1e ff ff
	ff		 jne	 $LL20@SkillFenri

; 3481 : 		{
; 3482 : 			break;
; 3483 : 		}
; 3484 : 	}
; 3485 : 	return true;

  00132	5e		 pop	 esi
  00133	5b		 pop	 ebx
  00134	b8 01 00 00 00	 mov	 eax, 1
  00139	5f		 pop	 edi

; 3486 : }

  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c2 0c 00	 ret	 12			; 0000000cH
?SkillFenrirAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillFenrirAttack
_TEXT	ENDS
PUBLIC	??_C@_0FA@NONLFBKD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5Infinity?5Arrow?5Skil@ ; `string'
PUBLIC	?SkillInfinityArrow@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillInfinityArrow
;	COMDAT ??_C@_0FA@NONLFBKD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5Infinity?5Arrow?5Skil@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\skilladditioninfo.h
CONST	SEGMENT
??_C@_0FA@NONLFBKD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5Infinity?5Arrow?5Skil@ DB '['
	DB	'%s][%s] Use Infinity Arrow Skill (Time:%d)(Character Level : '
	DB	'%d)(ChangeUp: %d)', 00H			; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\objuseskill.cpp
CONST	ENDS
;	COMDAT ?SkillInfinityArrow@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillInfinityArrow@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillInfinityArrow, COMDAT
; _this$ = ecx

; 3489 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3490 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0000d	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3491 : 
; 3492 : 	if(lpObj->Type != OBJ_USER)

  00013	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1

; 3493 : 	{
; 3494 : 		return false;

  00018	0f 85 8f 00 00
	00		 jne	 $LN3@SkillInfin

; 3495 : 	}
; 3496 : 
; 3497 : 	if(lpObj->Class != CLASS_ELF || lpObj->ChangeUP == 0)

  0001e	66 83 be 98 00
	00 00 02	 cmp	 WORD PTR [esi+152], 2
  00026	0f 85 81 00 00
	00		 jne	 $LN3@SkillInfin
  0002c	80 be 9b 00 00
	00 00		 cmp	 BYTE PTR [esi+155], 0
  00033	74 78		 je	 SHORT $LN3@SkillInfin

; 3500 : 	}
; 3501 : 
; 3502 : 	if(lpObj->m_Index != aTargetIndex)

  00035	8b 06		 mov	 eax, DWORD PTR [esi]
  00037	3b 45 0c	 cmp	 eax, DWORD PTR _aTargetIndex$[ebp]

; 3503 : 	{
; 3504 : 		return false;

  0003a	75 71		 jne	 SHORT $LN3@SkillInfin

; 3505 : 	}
; 3506 : 
; 3507 : 	if(lpObj->m_iMuseElfInfinityArrowSkillTime > 0)

  0003c	83 be 30 15 00
	00 00		 cmp	 DWORD PTR [esi+5424], 0

; 3508 : 	{
; 3509 : 		return false;

  00043	7f 68		 jg	 SHORT $LN3@SkillInfin

; 3510 : 	}
; 3511 : 
; 3512 : 	lpObj->m_iMuseElfInfinityArrowSkillTime = g_SkillAdditionInfo.GetInfinityArrowSkillTime();

  00045	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+4

; 3513 : 	lpObj->m_ViewSkillState |= 0x4000000;

  0004b	81 8e c4 01 00
	00 00 00 00 04	 or	 DWORD PTR [esi+452], 67108864 ; 04000000H

; 3514 : 	GCStateInfoSend(lpObj,1,0x4000000);

  00055	68 00 00 00 04	 push	 67108864		; 04000000H
  0005a	6a 01		 push	 1
  0005c	56		 push	 esi
  0005d	89 8e 30 15 00
	00		 mov	 DWORD PTR [esi+5424], ecx
  00063	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend

; 3515 : 	GCMagicAttackNumberSend(lpObj,0x4D,lpObj->m_Index,1);

  00068	8b 16		 mov	 edx, DWORD PTR [esi]
  0006a	6a 01		 push	 1
  0006c	52		 push	 edx
  0006d	6a 4d		 push	 77			; 0000004dH
  0006f	56		 push	 esi
  00070	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 3516 : 	LogAdd(LOG_BLACK, "[%s][%s] Use Infinity Arrow Skill (Time:%d)(Character Level : %d)(ChangeUp: %d)",
; 3517 : 		lpObj->AccountID,lpObj->Name,lpObj->m_iMuseElfInfinityArrowSkillTime,lpObj->Level,lpObj->ChangeUP);

  00075	0f b6 86 9b 00
	00 00		 movzx	 eax, BYTE PTR [esi+155]
  0007c	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR [esi+156]
  00083	8b 96 30 15 00
	00		 mov	 edx, DWORD PTR [esi+5424]
  00089	50		 push	 eax
  0008a	51		 push	 ecx
  0008b	52		 push	 edx
  0008c	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  0008f	50		 push	 eax
  00090	83 c6 64	 add	 esi, 100		; 00000064H
  00093	56		 push	 esi
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@NONLFBKD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5Infinity?5Arrow?5Skil@
  00099	6a 00		 push	 0
  0009b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000a0	83 c4 38	 add	 esp, 56			; 00000038H

; 3518 : 	return true;

  000a3	b8 01 00 00 00	 mov	 eax, 1
  000a8	5e		 pop	 esi

; 3519 : }

  000a9	5d		 pop	 ebp
  000aa	c2 0c 00	 ret	 12			; 0000000cH
$LN3@SkillInfin:

; 3498 : 	{
; 3499 : 		return false;

  000ad	33 c0		 xor	 eax, eax
  000af	5e		 pop	 esi

; 3519 : }

  000b0	5d		 pop	 ebp
  000b1	c2 0c 00	 ret	 12			; 0000000cH
?SkillInfinityArrow@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillInfinityArrow
_TEXT	ENDS
PUBLIC	?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillFireScream
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
; Function compile flags: /Ogtp
;	COMDAT ?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillFireScream, COMDAT
; _this$ = ecx

; 3522 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3523 : 	if(g_SkillAdditionInfo.GetFireScreamSkill() == false)

  00003	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+24, 0
  0000a	75 06		 jne	 SHORT $LN4@SkillFireS

; 3524 : 	{
; 3525 : 		return false;

  0000c	33 c0		 xor	 eax, eax

; 3548 : }

  0000e	5d		 pop	 ebp
  0000f	c2 0c 00	 ret	 12			; 0000000cH
$LN4@SkillFireS:
  00012	56		 push	 esi

; 3526 : 	}
; 3527 : 
; 3528 : 	LPOBJ lpObj = &gObj[aIndex];

  00013	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00016	57		 push	 edi
  00017	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H

; 3529 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  0001d	8b 7d 0c	 mov	 edi, DWORD PTR _aTargetIndex$[ebp]
  00020	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00026	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3530 : 
; 3531 : 	if(gObjIsConnected(lpObj->m_Index) == false && gObjIsConnected(lpTargetObj->m_Index) == false)

  0002c	8b 06		 mov	 eax, DWORD PTR [esi]
  0002e	50		 push	 eax
  0002f	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003a	83 c4 04	 add	 esp, 4
  0003d	85 c0		 test	 eax, eax
  0003f	75 0f		 jne	 SHORT $LN3@SkillFireS
  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00049	83 c4 04	 add	 esp, 4
  0004c	85 c0		 test	 eax, eax

; 3532 : 	{
; 3533 : 		return false;

  0004e	74 11		 je	 SHORT $LN11@SkillFireS
$LN3@SkillFireS:

; 3534 : 	}
; 3535 : 
; 3536 : 	if(lpObj->Type != OBJ_USER)

  00050	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1

; 3537 : 	{
; 3538 : 		return false;

  00055	75 0a		 jne	 SHORT $LN11@SkillFireS

; 3539 : 	}
; 3540 : 
; 3541 : 	if(lpObj->Class != CLASS_DARKLORD)

  00057	66 83 be 98 00
	00 00 04	 cmp	 WORD PTR [esi+152], 4
  0005f	74 08		 je	 SHORT $LN1@SkillFireS
$LN11@SkillFireS:
  00061	5f		 pop	 edi

; 3542 : 	{
; 3543 : 		return false;

  00062	33 c0		 xor	 eax, eax
  00064	5e		 pop	 esi

; 3548 : }

  00065	5d		 pop	 ebp
  00066	c2 0c 00	 ret	 12			; 0000000cH
$LN1@SkillFireS:

; 3544 : 	}
; 3545 : 
; 3546 : 	gObjAttack(lpObj,lpTargetObj,lpMagic,0,0,0,0);

  00069	8b 55 10	 mov	 edx, DWORD PTR _lpMagic$[ebp]
  0006c	6a 00		 push	 0
  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	52		 push	 edx
  00075	57		 push	 edi
  00076	56		 push	 esi
  00077	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  0007c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0007f	5f		 pop	 edi

; 3547 : 	return true;

  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	5e		 pop	 esi

; 3548 : }

  00086	5d		 pop	 ebp
  00087	c2 0c 00	 ret	 12			; 0000000cH
?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillFireScream
_TEXT	ENDS
PUBLIC	?FireScreamExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z ; CObjUseSkill::FireScreamExplosionAttack
EXTRN	?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z:PROC ; gObjAddMsgSendDelay
; Function compile flags: /Ogtp
;	COMDAT ?FireScreamExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
tv320 = 8						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
tv171 = 16						; size = 4
_iAttackDamage$ = 16					; size = 4
?FireScreamExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z PROC ; CObjUseSkill::FireScreamExplosionAttack, COMDAT
; _this$ = ecx

; 3553 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 3554 : 
; 3555 : 	if(gObjIsConnected(lpObj->m_Index) == false && gObjIsConnected(lpTargetObj->m_Index) == false)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00007	8b 03		 mov	 eax, DWORD PTR [ebx]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000f	83 c4 04	 add	 esp, 4
  00012	85 c0		 test	 eax, eax
  00014	75 17		 jne	 SHORT $LN16@FireScream
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	75 05		 jne	 SHORT $LN16@FireScream
  00028	5b		 pop	 ebx

; 3630 : }

  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
$LN16@FireScream:
  0002d	56		 push	 esi

; 3556 : 	{
; 3557 : 		return false;
; 3558 : 	}
; 3559 : 
; 3560 : 	if(rand()%10000 > g_SkillAdditionInfo.GetFireScreamExplosionRate())

  0002e	8b 35 20 00 00
	00		 mov	 esi, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+32
  00034	e8 00 00 00 00	 call	 _rand
  00039	99		 cdq
  0003a	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0003f	f7 f9		 idiv	 ecx
  00041	3b d6		 cmp	 edx, esi
  00043	7e 08		 jle	 SHORT $LN15@FireScream

; 3561 : 	{
; 3562 : 		return false;

  00045	5e		 pop	 esi
  00046	33 c0		 xor	 eax, eax
  00048	5b		 pop	 ebx

; 3630 : }

  00049	5d		 pop	 ebp
  0004a	c2 0c 00	 ret	 12			; 0000000cH
$LN15@FireScream:

; 3563 : 	}
; 3564 : 
; 3565 : 	int iExplosionDamage = iAttackDamage / 10;

  0004d	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00052	f7 6d 10	 imul	 DWORD PTR _iAttackDamage$[ebp]
  00055	c1 fa 02	 sar	 edx, 2
  00058	57		 push	 edi
  00059	8b fa		 mov	 edi, edx
  0005b	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0005e	03 fa		 add	 edi, edx

; 3566 : 	int iTarObjNum;
; 3567 : 
; 3568 : 	if(iExplosionDamage < 1)

  00060	83 ff 01	 cmp	 edi, 1

; 3569 : 	{
; 3570 : 		return true;

  00063	0f 8c b6 00 00
	00		 jl	 $LN33@FireScream

; 3571 : 	}
; 3572 : 
; 3573 : 	int iCount = 0;

  00069	8d 83 16 07 00
	00		 lea	 eax, DWORD PTR [ebx+1814]
  0006f	89 45 08	 mov	 DWORD PTR tv320[ebp], eax
  00072	c7 45 10 4b 00
	00 00		 mov	 DWORD PTR tv171[ebp], 75 ; 0000004bH
  00079	8d a4 24 00 00
	00 00		 npad	 7
$LL13@FireScream:

; 3574 : 	int bEnableAttack;
; 3575 : 
; 3576 : 	while( true )
; 3577 : 	{
; 3578 : 		if(lpObj->VpPlayer2[iCount].state != 0)

  00080	80 78 fe 00	 cmp	 BYTE PTR [eax-2], 0
  00084	0f 84 83 00 00
	00		 je	 $LN29@FireScream

; 3579 : 		{
; 3580 : 			iTarObjNum = lpObj->VpPlayer2[iCount].number;

  0008a	0f bf 30	 movsx	 esi, WORD PTR [eax]

; 3581 : 
; 3582 : 			if(iTarObjNum >= 0)

  0008d	85 f6		 test	 esi, esi
  0008f	78 7c		 js	 SHORT $LN29@FireScream

; 3583 : 			{
; 3584 : 				bEnableAttack = 0;
; 3585 : 
; 3586 : 				if(gObj[iTarObjNum].Type == OBJ_MONSTER && gObj[iTarObjNum].m_RecallMon < 0)

  00091	8b c6		 mov	 eax, esi
  00093	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00099	0f b7 88 60 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96]
  000a0	83 f9 02	 cmp	 ecx, 2
  000a3	75 09		 jne	 SHORT $LN9@FireScream
  000a5	83 b8 cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716], 0

; 3587 : 				{
; 3588 : 					bEnableAttack = 1;

  000ac	7c 2b		 jl	 SHORT $LN27@FireScream
$LN9@FireScream:

; 3589 : 				}
; 3590 : 				else if(lpTargetObj->Type == OBJ_USER && lpObj->Type == OBJ_USER && gObj[iTarObjNum].Type != OBJ_NPC)

  000ae	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000b1	66 83 7a 60 01	 cmp	 WORD PTR [edx+96], 1
  000b6	75 0c		 jne	 SHORT $LN7@FireScream
  000b8	66 83 7b 60 01	 cmp	 WORD PTR [ebx+96], 1
  000bd	75 05		 jne	 SHORT $LN7@FireScream
  000bf	83 f9 03	 cmp	 ecx, 3

; 3591 : 				{
; 3592 : 					bEnableAttack = 1;

  000c2	75 18		 jne	 SHORT $LN28@FireScream
$LN7@FireScream:

; 3593 : 				}
; 3594 : 				else if(lpTargetObj->m_cChaosCastleIndex == gObj[iTarObjNum].m_cChaosCastleIndex && lpTargetObj->m_cChaosCastleIndex != -1)

  000c4	8a 8a 09 0d 00
	00		 mov	 cl, BYTE PTR [edx+3337]
  000ca	3a 88 09 0d 00
	00		 cmp	 cl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3337]
  000d0	75 3b		 jne	 SHORT $LN29@FireScream
  000d2	80 f9 ff	 cmp	 cl, -1
  000d5	74 36		 je	 SHORT $LN29@FireScream
  000d7	eb 03		 jmp	 SHORT $LN28@FireScream
$LN27@FireScream:
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
$LN28@FireScream:

; 3595 : 				{
; 3596 : 					bEnableAttack = 1;
; 3597 : 				}
; 3598 : #if GS_CASTLE == 1
; 3599 : 				else if (gObj[iTarObjNum].Type != OBJ_NPC &&
; 3600 : 					 	 gObj[iTarObjNum].MapNumber == MAP_INDEX_CASTLESIEGE &&
; 3601 : 						 g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 3602 : 				{
; 3603 : 					bEnableAttack = 1;
; 3604 : 				}
; 3605 : #endif
; 3606 : 
; 3607 : 				if(bEnableAttack != 0)
; 3608 : 				{
; 3609 : 					if(lpObj->m_Index != gObj[iTarObjNum].m_Index)

  000dc	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000de	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  000e4	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  000ea	74 21		 je	 SHORT $LN29@FireScream

; 3610 : 					{
; 3611 : 						int iSkillDistance = gObjCalDistance(lpTargetObj,&gObj[iTarObjNum]);

  000ec	50		 push	 eax
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000f3	83 c4 08	 add	 esp, 8

; 3612 : 
; 3613 : 						if(iSkillDistance <= g_SkillAdditionInfo.GetFireScreamExplosionAttackDistance())

  000f6	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+28
  000fc	7f 0f		 jg	 SHORT $LN29@FireScream

; 3614 : 						{
; 3615 : 							gObjAddMsgSendDelay(lpObj,54,iTarObjNum,100,iExplosionDamage);

  000fe	57		 push	 edi
  000ff	6a 64		 push	 100			; 00000064H
  00101	56		 push	 esi
  00102	6a 36		 push	 54			; 00000036H
  00104	53		 push	 ebx
  00105	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  0010a	83 c4 14	 add	 esp, 20			; 00000014H
$LN29@FireScream:

; 3616 : 						}
; 3617 : 					}
; 3618 : 				}
; 3619 : 			}
; 3620 : 		}
; 3621 : 
; 3622 : 		iCount++;

  0010d	8b 45 08	 mov	 eax, DWORD PTR tv320[ebp]
  00110	83 c0 0c	 add	 eax, 12			; 0000000cH

; 3623 : 
; 3624 : 		if(iCount > MAX_VIEWPORT -1)

  00113	ff 4d 10	 dec	 DWORD PTR tv171[ebp]
  00116	89 45 08	 mov	 DWORD PTR tv320[ebp], eax
  00119	0f 85 61 ff ff
	ff		 jne	 $LL13@FireScream
$LN33@FireScream:
  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi

; 3625 : 		{
; 3626 : 			break;
; 3627 : 		}
; 3628 : 	}
; 3629 : 	return true;

  00121	b8 01 00 00 00	 mov	 eax, 1
  00126	5b		 pop	 ebx

; 3630 : }

  00127	5d		 pop	 ebp
  00128	c2 0c 00	 ret	 12			; 0000000cH
?FireScreamExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z ENDP ; CObjUseSkill::FireScreamExplosionAttack
_TEXT	ENDS
PUBLIC	?SpecificSkillAdditionTreat@CObjUseSkill@@QAEXPAUOBJECTSTRUCT@@0PAVCMagicInf@@H@Z ; CObjUseSkill::SpecificSkillAdditionTreat
; Function compile flags: /Ogtp
;	COMDAT ?SpecificSkillAdditionTreat@CObjUseSkill@@QAEXPAUOBJECTSTRUCT@@0PAVCMagicInf@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
_iAttackDamage$ = 20					; size = 4
?SpecificSkillAdditionTreat@CObjUseSkill@@QAEXPAUOBJECTSTRUCT@@0PAVCMagicInf@@H@Z PROC ; CObjUseSkill::SpecificSkillAdditionTreat, COMDAT
; _this$ = ecx

; 3636 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3637 : 	BYTE bySkillNum = lpMagic->m_Skill;
; 3638 : 
; 3639 : 	if(bySkillNum == AT_SKILL_FIRESCREAM)

  00003	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00006	80 78 05 4e	 cmp	 BYTE PTR [eax+5], 78	; 0000004eH
  0000a	75 16		 jne	 SHORT $LN1@SpecificSk

; 3640 : 	{
; 3641 : 		gObjUseSkill.FireScreamExplosionAttack(lpObj,lpTargetObj,iAttackDamage);

  0000c	8b 4d 14	 mov	 ecx, DWORD PTR _iAttackDamage$[ebp]
  0000f	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00012	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00015	51		 push	 ecx
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0001d	e8 00 00 00 00	 call	 ?FireScreamExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z ; CObjUseSkill::FireScreamExplosionAttack
$LN1@SpecificSk:

; 3642 : 	}
; 3643 : }

  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
?SpecificSkillAdditionTreat@CObjUseSkill@@QAEXPAUOBJECTSTRUCT@@0PAVCMagicInf@@H@Z ENDP ; CObjUseSkill::SpecificSkillAdditionTreat
_TEXT	ENDS
PUBLIC	_sqrtf
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Ogtp
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 542  :         {return (sqrtf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCObjUseSkill@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCObjUseSkill@@UAEPAXI@Z PROC			; CObjUseSkill::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CObjUseSkill@@UAE@XZ	; CObjUseSkill::~CObjUseSkill
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCObjUseSkill@@UAEPAXI@Z ENDP			; CObjUseSkill::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetTargetLinePath@CObjUseSkill@@QAEHHHHHPAH0H@Z ; CObjUseSkill::GetTargetLinePath
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\objuseskill.cpp
;	COMDAT ?GetTargetLinePath@CObjUseSkill@@QAEHHHHHPAH0H@Z
_TEXT	SEGMENT
tv539 = -16						; size = 4
tv533 = -16						; size = 4
_incx$ = -12						; size = 4
_incy$ = -8						; size = 4
_error$ = -4						; size = 4
_delta_x$ = 8						; size = 4
_sx$ = 8						; size = 4
_delta_y$ = 12						; size = 4
_sy$ = 12						; size = 4
$T159412 = 16						; size = 4
_x$ = 16						; size = 4
_count$ = 16						; size = 4
_tx$ = 16						; size = 4
_ty$ = 20						; size = 4
tv384 = 24						; size = 4
_PathX$ = 24						; size = 4
_PathY$ = 28						; size = 4
_half$ = 32						; size = 4
_distance$ = 32						; size = 4
?GetTargetLinePath@CObjUseSkill@@QAEHHHHHPAH0H@Z PROC	; CObjUseSkill::GetTargetLinePath, COMDAT
; _this$ = ecx

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 37   : 	int x,y;
; 38   : 	int delta_x,delta_y;
; 39   : 	int half;
; 40   : 
; 41   : 	int error = 0;
; 42   : 
; 43   : 	int incx = 1,incy = 1;

  00007	b8 01 00 00 00	 mov	 eax, 1
  0000c	56		 push	 esi

; 44   : 	int dis;
; 45   : 	int count;
; 46   : 
; 47   : 	if(sx > tx)

  0000d	8b 75 08	 mov	 esi, DWORD PTR _sx$[ebp]
  00010	89 45 f4	 mov	 DWORD PTR _incx$[ebp], eax
  00013	89 45 f8	 mov	 DWORD PTR _incy$[ebp], eax
  00016	8b 45 10	 mov	 eax, DWORD PTR _tx$[ebp]
  00019	57		 push	 edi
  0001a	83 cf ff	 or	 edi, -1
  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _error$[ebp], 0
  00024	3b f0		 cmp	 esi, eax
  00026	7e 0c		 jle	 SHORT $LN26@GetTargetL

; 48   : 	{
; 49   : 		incx = -1;
; 50   : 		delta_x = sx - tx;

  00028	8b ce		 mov	 ecx, esi
  0002a	2b c8		 sub	 ecx, eax
  0002c	89 7d f4	 mov	 DWORD PTR _incx$[ebp], edi
  0002f	89 4d 08	 mov	 DWORD PTR _delta_x$[ebp], ecx

; 51   : 	}
; 52   : 	else

  00032	eb 07		 jmp	 SHORT $LN25@GetTargetL
$LN26@GetTargetL:

; 53   : 	{
; 54   : 		delta_x = tx - sx;

  00034	2b c6		 sub	 eax, esi
  00036	89 45 08	 mov	 DWORD PTR _delta_x$[ebp], eax
  00039	8b c8		 mov	 ecx, eax
$LN25@GetTargetL:

; 55   : 	}
; 56   : 
; 57   : 	if(sy > ty)

  0003b	8b 5d 0c	 mov	 ebx, DWORD PTR _sy$[ebp]
  0003e	8b 55 14	 mov	 edx, DWORD PTR _ty$[ebp]
  00041	3b da		 cmp	 ebx, edx
  00043	7e 09		 jle	 SHORT $LN24@GetTargetL

; 58   : 	{
; 59   : 		incy = -1;
; 60   : 		delta_y = sy - ty;

  00045	8b c3		 mov	 eax, ebx
  00047	89 7d f8	 mov	 DWORD PTR _incy$[ebp], edi
  0004a	2b c2		 sub	 eax, edx

; 61   : 	}
; 62   : 	else

  0004c	eb 04		 jmp	 SHORT $LN47@GetTargetL
$LN24@GetTargetL:

; 63   : 	{
; 64   : 		delta_y = ty - sy;

  0004e	8b c2		 mov	 eax, edx
  00050	2b c3		 sub	 eax, ebx
$LN47@GetTargetL:
  00052	89 45 0c	 mov	 DWORD PTR _delta_y$[ebp], eax

; 65   : 	}
; 66   : 
; 67   : 	dis = sqrt((float)(delta_x * delta_x + delta_y * delta_y));

  00055	0f af c0	 imul	 eax, eax
  00058	0f af c9	 imul	 ecx, ecx
  0005b	03 c1		 add	 eax, ecx

; 68   : 	dis = distance - dis;

  0005d	89 45 f0	 mov	 DWORD PTR tv539[ebp], eax
  00060	db 45 f0	 fild	 DWORD PTR tv539[ebp]
  00063	e8 00 00 00 00	 call	 __CIsqrt
  00068	d9 5d f0	 fstp	 DWORD PTR tv533[ebp]
  0006b	d9 45 f0	 fld	 DWORD PTR tv533[ebp]
  0006e	e8 00 00 00 00	 call	 __ftol2_sse
  00073	8b 7d 20	 mov	 edi, DWORD PTR _distance$[ebp]

; 69   : 
; 70   : 	count = 0;
; 71   : 	PathX[count] = sx;
; 72   : 	PathY[count] = sy;

  00076	8b 4d 1c	 mov	 ecx, DWORD PTR _PathY$[ebp]
  00079	2b f8		 sub	 edi, eax
  0007b	8b 45 18	 mov	 eax, DWORD PTR _PathX$[ebp]
  0007e	89 30		 mov	 DWORD PTR [eax], esi

; 73   : 	count++;
; 74   : 
; 75   : 	if(delta_x > delta_y)

  00080	8b 45 0c	 mov	 eax, DWORD PTR _delta_y$[ebp]
  00083	89 19		 mov	 DWORD PTR [ecx], ebx
  00085	39 45 08	 cmp	 DWORD PTR _delta_x$[ebp], eax
  00088	0f 8e c4 00 00
	00		 jle	 $LN22@GetTargetL

; 76   : 	{
; 77   : 		y = sy;
; 78   : 		half = delta_x / 2;

  0008e	8b 45 08	 mov	 eax, DWORD PTR _delta_x$[ebp]
  00091	99		 cdq
  00092	2b c2		 sub	 eax, edx
  00094	d1 f8		 sar	 eax, 1

; 79   : 
; 80   : 		if(incx > 0)

  00096	83 7d f4 00	 cmp	 DWORD PTR _incx$[ebp], 0
  0009a	89 45 20	 mov	 DWORD PTR _half$[ebp], eax
  0009d	7e 4f		 jle	 SHORT $LN21@GetTargetL

; 81   : 		{
; 82   : 			for(x = (sx+1); x <= (tx + dis); x++)

  0009f	03 7d 10	 add	 edi, DWORD PTR _tx$[ebp]
  000a2	46		 inc	 esi
  000a3	89 7d 10	 mov	 DWORD PTR $T159412[ebp], edi
  000a6	3b f7		 cmp	 esi, edi
  000a8	0f 8f 58 01 00
	00		 jg	 $LN44@GetTargetL
  000ae	8b 45 10	 mov	 eax, DWORD PTR $T159412[ebp]
  000b1	8b 7d 18	 mov	 edi, DWORD PTR _PathX$[ebp]
  000b4	2b c6		 sub	 eax, esi
  000b6	2b f9		 sub	 edi, ecx
  000b8	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  000bb	83 c0 02	 add	 eax, 2
  000be	8b ff		 npad	 2
$LL20@GetTargetL:

; 83   : 			{
; 84   : 				error += delta_y;

  000c0	8b 4d 0c	 mov	 ecx, DWORD PTR _delta_y$[ebp]
  000c3	01 4d fc	 add	 DWORD PTR _error$[ebp], ecx

; 85   : 
; 86   : 				if(error > half)

  000c6	8b 4d 20	 mov	 ecx, DWORD PTR _half$[ebp]
  000c9	39 4d fc	 cmp	 DWORD PTR _error$[ebp], ecx
  000cc	7e 09		 jle	 SHORT $LN17@GetTargetL

; 87   : 				{
; 88   : 					y += incy;
; 89   : 					error -= delta_x;

  000ce	8b 4d 08	 mov	 ecx, DWORD PTR _delta_x$[ebp]
  000d1	03 5d f8	 add	 ebx, DWORD PTR _incy$[ebp]
  000d4	29 4d fc	 sub	 DWORD PTR _error$[ebp], ecx
$LN17@GetTargetL:

; 90   : 				}
; 91   : 
; 92   : 				PathX[count] = x;

  000d7	89 34 17	 mov	 DWORD PTR [edi+edx], esi

; 93   : 				PathY[count] = y;

  000da	89 1a		 mov	 DWORD PTR [edx], ebx

; 94   : 
; 95   : 				count++;

  000dc	46		 inc	 esi
  000dd	83 c2 04	 add	 edx, 4
  000e0	3b 75 10	 cmp	 esi, DWORD PTR $T159412[ebp]
  000e3	7e db		 jle	 SHORT $LL20@GetTargetL
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx

; 158  : }

  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 1c 00	 ret	 28			; 0000001cH
$LN21@GetTargetL:

; 96   : 			}
; 97   : 		}
; 98   : 		else
; 99   : 		{
; 100  : 			for(x = (sx-1); x >= (tx - dis);x--)

  000ee	8b 45 10	 mov	 eax, DWORD PTR _tx$[ebp]
  000f1	2b c7		 sub	 eax, edi
  000f3	8d 56 ff	 lea	 edx, DWORD PTR [esi-1]
  000f6	8b f8		 mov	 edi, eax
  000f8	3b d7		 cmp	 edx, edi
  000fa	0f 8c 06 01 00
	00		 jl	 $LN44@GetTargetL
  00100	8b 45 18	 mov	 eax, DWORD PTR _PathX$[ebp]
  00103	2b c1		 sub	 eax, ecx
  00105	89 45 18	 mov	 DWORD PTR tv384[ebp], eax
  00108	8b c2		 mov	 eax, edx
  0010a	2b c7		 sub	 eax, edi
  0010c	83 c0 02	 add	 eax, 2
  0010f	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00112	8b 4d 20	 mov	 ecx, DWORD PTR _half$[ebp]
  00115	89 45 10	 mov	 DWORD PTR _count$[ebp], eax
  00118	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL15@GetTargetL:

; 101  : 			{
; 102  : 				error += delta_y;

  00120	8b 45 fc	 mov	 eax, DWORD PTR _error$[ebp]
  00123	03 45 0c	 add	 eax, DWORD PTR _delta_y$[ebp]
  00126	89 45 fc	 mov	 DWORD PTR _error$[ebp], eax

; 103  : 
; 104  : 				if(error > half)

  00129	3b c1		 cmp	 eax, ecx
  0012b	7e 09		 jle	 SHORT $LN12@GetTargetL

; 105  : 				{
; 106  : 					y += incy;

  0012d	03 5d f8	 add	 ebx, DWORD PTR _incy$[ebp]

; 107  : 					error -= delta_x;

  00130	2b 45 08	 sub	 eax, DWORD PTR _delta_x$[ebp]
  00133	89 45 fc	 mov	 DWORD PTR _error$[ebp], eax
$LN12@GetTargetL:

; 108  : 				}
; 109  : 
; 110  : 				PathX[count] = x;

  00136	8b 45 18	 mov	 eax, DWORD PTR tv384[ebp]
  00139	89 14 06	 mov	 DWORD PTR [esi+eax], edx

; 111  : 				PathY[count] = y;

  0013c	89 1e		 mov	 DWORD PTR [esi], ebx
  0013e	4a		 dec	 edx

; 112  : 
; 113  : 				count++;

  0013f	83 c6 04	 add	 esi, 4
  00142	3b d7		 cmp	 edx, edi
  00144	7d da		 jge	 SHORT $LL15@GetTargetL

; 154  : 			}
; 155  : 		}
; 156  : 	}
; 157  : 	return count;

  00146	8b 45 10	 mov	 eax, DWORD PTR _count$[ebp]
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx

; 158  : }

  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c2 1c 00	 ret	 28			; 0000001cH
$LN22@GetTargetL:

; 114  : 			}
; 115  : 		}
; 116  : 	}
; 117  : 	else
; 118  : 	{
; 119  : 		x = sx;
; 120  : 		half = delta_y / 2;

  00152	99		 cdq
  00153	2b c2		 sub	 eax, edx
  00155	d1 f8		 sar	 eax, 1

; 121  : 
; 122  : 		if(incy > 0)

  00157	83 7d f8 00	 cmp	 DWORD PTR _incy$[ebp], 0
  0015b	89 75 10	 mov	 DWORD PTR _x$[ebp], esi
  0015e	89 45 20	 mov	 DWORD PTR _half$[ebp], eax
  00161	7e 53		 jle	 SHORT $LN10@GetTargetL

; 123  : 		{
; 124  : 			for(y = (sy+1); y <= (ty + dis);y++)

  00163	03 7d 14	 add	 edi, DWORD PTR _ty$[ebp]
  00166	8d 73 01	 lea	 esi, DWORD PTR [ebx+1]
  00169	3b f7		 cmp	 esi, edi
  0016b	0f 8f 95 00 00
	00		 jg	 $LN44@GetTargetL
  00171	8b 5d 18	 mov	 ebx, DWORD PTR _PathX$[ebp]
  00174	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  00177	2b d9		 sub	 ebx, ecx
  00179	8b cf		 mov	 ecx, edi
  0017b	2b ce		 sub	 ecx, esi
  0017d	8d 49 00	 npad	 3
$LL9@GetTargetL:

; 125  : 			{
; 126  : 				error += delta_x;

  00180	8b 45 08	 mov	 eax, DWORD PTR _delta_x$[ebp]
  00183	01 45 fc	 add	 DWORD PTR _error$[ebp], eax

; 127  : 
; 128  : 				if(error > half)

  00186	8b 45 20	 mov	 eax, DWORD PTR _half$[ebp]
  00189	39 45 fc	 cmp	 DWORD PTR _error$[ebp], eax
  0018c	7e 0c		 jle	 SHORT $LN45@GetTargetL

; 129  : 				{
; 130  : 					x += incx;

  0018e	8b 45 f4	 mov	 eax, DWORD PTR _incx$[ebp]
  00191	01 45 10	 add	 DWORD PTR _x$[ebp], eax

; 131  : 					error -= delta_y;

  00194	8b 45 0c	 mov	 eax, DWORD PTR _delta_y$[ebp]
  00197	29 45 fc	 sub	 DWORD PTR _error$[ebp], eax
$LN45@GetTargetL:

; 132  : 				}
; 133  : 
; 134  : 				PathX[count] = x;

  0019a	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  0019d	89 04 1a	 mov	 DWORD PTR [edx+ebx], eax

; 135  : 				PathY[count] = y;

  001a0	89 32		 mov	 DWORD PTR [edx], esi

; 136  : 				count++;

  001a2	46		 inc	 esi
  001a3	83 c2 04	 add	 edx, 4
  001a6	3b f7		 cmp	 esi, edi
  001a8	7e d6		 jle	 SHORT $LL9@GetTargetL

; 154  : 			}
; 155  : 		}
; 156  : 	}
; 157  : 	return count;

  001aa	5f		 pop	 edi
  001ab	5e		 pop	 esi
  001ac	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  001af	5b		 pop	 ebx

; 158  : }

  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	c2 1c 00	 ret	 28			; 0000001cH
$LN10@GetTargetL:

; 137  : 			}
; 138  : 		}
; 139  : 		else
; 140  : 		{
; 141  : 			for(y = (sy-1);y >= (ty - dis);y--)

  001b6	8b 75 14	 mov	 esi, DWORD PTR _ty$[ebp]
  001b9	2b f7		 sub	 esi, edi
  001bb	8d 53 ff	 lea	 edx, DWORD PTR [ebx-1]
  001be	8b fe		 mov	 edi, esi
  001c0	3b d7		 cmp	 edx, edi
  001c2	7c 42		 jl	 SHORT $LN44@GetTargetL
  001c4	8b 5d 18	 mov	 ebx, DWORD PTR _PathX$[ebp]
  001c7	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  001ca	2b d9		 sub	 ebx, ecx
  001cc	8b ca		 mov	 ecx, edx
  001ce	2b cf		 sub	 ecx, edi
$LL4@GetTargetL:

; 142  : 			{
; 143  : 				error += delta_x;

  001d0	8b 45 08	 mov	 eax, DWORD PTR _delta_x$[ebp]
  001d3	01 45 fc	 add	 DWORD PTR _error$[ebp], eax

; 144  : 
; 145  : 				if(error > half)

  001d6	8b 45 20	 mov	 eax, DWORD PTR _half$[ebp]
  001d9	39 45 fc	 cmp	 DWORD PTR _error$[ebp], eax
  001dc	7e 0c		 jle	 SHORT $LN46@GetTargetL

; 146  : 				{
; 147  : 					x += incx;

  001de	8b 45 f4	 mov	 eax, DWORD PTR _incx$[ebp]
  001e1	01 45 10	 add	 DWORD PTR _x$[ebp], eax

; 148  : 					error -= delta_y;

  001e4	8b 45 0c	 mov	 eax, DWORD PTR _delta_y$[ebp]
  001e7	29 45 fc	 sub	 DWORD PTR _error$[ebp], eax
$LN46@GetTargetL:

; 149  : 				}
; 150  : 
; 151  : 				PathX[count] = x;

  001ea	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  001ed	89 04 1e	 mov	 DWORD PTR [esi+ebx], eax

; 152  : 				PathY[count] = y;

  001f0	89 16		 mov	 DWORD PTR [esi], edx
  001f2	4a		 dec	 edx

; 153  : 				count++;

  001f3	83 c6 04	 add	 esi, 4
  001f6	3b d7		 cmp	 edx, edi
  001f8	7d d6		 jge	 SHORT $LL4@GetTargetL

; 154  : 			}
; 155  : 		}
; 156  : 	}
; 157  : 	return count;

  001fa	5f		 pop	 edi
  001fb	5e		 pop	 esi
  001fc	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  001ff	5b		 pop	 ebx

; 158  : }

  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c2 1c 00	 ret	 28			; 0000001cH
$LN44@GetTargetL:
  00206	5f		 pop	 edi
  00207	5e		 pop	 esi

; 154  : 			}
; 155  : 		}
; 156  : 	}
; 157  : 	return count;

  00208	b8 01 00 00 00	 mov	 eax, 1
  0020d	5b		 pop	 ebx

; 158  : }

  0020e	8b e5		 mov	 esp, ebp
  00210	5d		 pop	 ebp
  00211	c2 1c 00	 ret	 28			; 0000001cH
?GetTargetLinePath@CObjUseSkill@@QAEHHHHHPAH0H@Z ENDP	; CObjUseSkill::GetTargetLinePath
_TEXT	ENDS
PUBLIC	?GetUseMana@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z	; CObjUseSkill::GetUseMana
EXTRN	?SkillGetMana@CMagicDamage@@QAEHH@Z:PROC	; CMagicDamage::SkillGetMana
; Function compile flags: /Ogtp
;	COMDAT ?GetUseMana@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv160 = -8						; size = 8
tv179 = 8						; size = 4
tv175 = 8						; size = 4
_mana$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?GetUseMana@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::GetUseMana, COMDAT
; _this$ = ecx

; 204  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 205  : 	LPOBJ lpObj =&gObj[aIndex];

  00008	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000b	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00011	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 206  : 	float mana = lpObj->Mana;
; 207  : 
; 208  : 	if ( lpObj->Type != OBJ_USER )

  00017	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0001c	8b d9		 mov	 ebx, ecx
  0001e	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  00024	d9 5d 08	 fstp	 DWORD PTR _mana$[ebp]
  00027	74 0a		 je	 SHORT $LN3@GetUseMana

; 209  : 	{
; 210  : 		return 0;

  00029	5e		 pop	 esi
  0002a	33 c0		 xor	 eax, eax
  0002c	5b		 pop	 ebx

; 227  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
$LN3@GetUseMana:
  00033	57		 push	 edi

; 211  : 	}
; 212  : 
; 213  : 	if ( lpMagic == NULL )

  00034	8b 7d 0c	 mov	 edi, DWORD PTR _lpMagic$[ebp]
  00037	85 ff		 test	 edi, edi
  00039	75 0b		 jne	 SHORT $LN2@GetUseMana

; 214  : 	{
; 215  : 		return 0;

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	33 c0		 xor	 eax, eax
  0003f	5b		 pop	 ebx

; 227  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
$LN2@GetUseMana:

; 216  : 	}
; 217  : 
; 218  : 	mana -= MagicDamageC.SkillGetMana(lpMagic->m_Skill);

  00046	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  0004a	d9 45 08	 fld	 DWORD PTR _mana$[ebp]
  0004d	50		 push	 eax
  0004e	dd 5d f8	 fstp	 QWORD PTR tv160[ebp]
  00051	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00056	e8 00 00 00 00	 call	 ?SkillGetMana@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetMana
  0005b	89 45 08	 mov	 DWORD PTR tv179[ebp], eax

; 219  : 
; 220  : 	mana -= this->GetAddUseMana(lpObj,lpMagic);

  0005e	57		 push	 edi
  0005f	db 45 08	 fild	 DWORD PTR tv179[ebp]
  00062	56		 push	 esi
  00063	8b cb		 mov	 ecx, ebx
  00065	dc 6d f8	 fsubr	 QWORD PTR tv160[ebp]
  00068	d9 5d 08	 fstp	 DWORD PTR _mana$[ebp]
  0006b	d9 45 08	 fld	 DWORD PTR _mana$[ebp]
  0006e	e8 00 00 00 00	 call	 ?GetAddUseMana@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; CObjUseSkill::GetAddUseMana
  00073	89 45 08	 mov	 DWORD PTR tv175[ebp], eax
  00076	da 65 08	 fisub	 DWORD PTR tv175[ebp]
  00079	d9 5d 08	 fstp	 DWORD PTR _mana$[ebp]

; 221  : 
; 222  : 	if(mana < 0.0f)

  0007c	d9 ee		 fldz
  0007e	d9 45 08	 fld	 DWORD PTR _mana$[ebp]
  00081	d8 d1		 fcom	 ST(1)
  00083	df e0		 fnstsw	 ax
  00085	dd d9		 fstp	 ST(1)
  00087	f6 c4 05	 test	 ah, 5
  0008a	7a 0e		 jp	 SHORT $LN1@GetUseMana
  0008c	5f		 pop	 edi
  0008d	dd d8		 fstp	 ST(0)
  0008f	5e		 pop	 esi

; 223  : 	{
; 224  : 		return -1;

  00090	83 c8 ff	 or	 eax, -1
  00093	5b		 pop	 ebx

; 227  : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 08 00	 ret	 8
$LN1@GetUseMana:

; 225  : 	}
; 226  : 	return mana;

  0009a	e8 00 00 00 00	 call	 __ftol2_sse
  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx

; 227  : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 08 00	 ret	 8
?GetUseMana@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::GetUseMana
_TEXT	ENDS
PUBLIC	?SkillHellFire2@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillHellFire2
; Function compile flags: /Ogtp
;	COMDAT ?SkillHellFire2@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_DuelIndex$ = -4					; size = 4
tv216 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillHellFire2@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillHellFire2, COMDAT
; _this$ = ecx

; 1559 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1560 : 	if(aTargetIndex == 58)

  00004	83 7d 0c 3a	 cmp	 DWORD PTR _aTargetIndex$[ebp], 58 ; 0000003aH
  00008	75 13		 jne	 SHORT $LN16@SkillHellF@2

; 1561 : 	{
; 1562 : 		return this->SkillHellFire2Start(aIndex,lpMagic);

  0000a	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0000d	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00010	50		 push	 eax
  00011	52		 push	 edx
  00012	e8 00 00 00 00	 call	 ?SkillHellFire2Start@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillHellFire2Start

; 1642 : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 0c 00	 ret	 12			; 0000000cH
$LN16@SkillHellF@2:
  0001d	56		 push	 esi

; 1563 : 	}
; 1564 : 
; 1565 : 	LPOBJ lpObj = &gObj[aIndex];

  0001e	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00021	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00027	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1566 : 	int tObjNum;
; 1567 : 
; 1568 : 	if(lpObj->SkillHellFire2State == 0)

  0002d	80 be 50 0f 00
	00 00		 cmp	 BYTE PTR [esi+3920], 0
  00034	75 20		 jne	 SHORT $LN15@SkillHellF@2

; 1569 : 	{
; 1570 : 		LogAdd(LOG_BLACK, "[%s][%s] Nova skill already casted",lpObj->AccountID, lpObj->Name);

  00036	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00039	50		 push	 eax
  0003a	83 c6 64	 add	 esi, 100		; 00000064H
  0003d	56		 push	 esi
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DJPGBFFK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Nova?5skill?5already?5cast@
  00043	6a 00		 push	 0
  00045	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0004a	83 c4 10	 add	 esp, 16			; 00000010H

; 1571 : 		return false;

  0004d	33 c0		 xor	 eax, eax
  0004f	5e		 pop	 esi

; 1642 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 0c 00	 ret	 12			; 0000000cH
$LN15@SkillHellF@2:

; 1572 : 	}
; 1573 : 
; 1574 : 	lpObj->SkillHellFire2State = 0;
; 1575 : 	int count = 0;
; 1576 : 	lpObj->SkillHellFire2Time = 0;
; 1577 : 
; 1578 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];
; 1579 : 	int DuelIndex = lpObj->m_iDuelUser;

  00056	8b 8e 1c 0d 00
	00		 mov	 ecx, DWORD PTR [esi+3356]
  0005c	53		 push	 ebx
  0005d	57		 push	 edi
  0005e	c6 86 50 0f 00
	00 00		 mov	 BYTE PTR [esi+3920], 0
  00065	c7 86 54 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3924], 0
  0006f	89 4d fc	 mov	 DWORD PTR _DuelIndex$[ebp], ecx
  00072	8d 9e 16 07 00
	00		 lea	 ebx, DWORD PTR [esi+1814]
  00078	c7 45 08 4b 00
	00 00		 mov	 DWORD PTR tv216[ebp], 75 ; 0000004bH
  0007f	90		 npad	 1
$LL14@SkillHellF@2:

; 1580 : 	int EnableAttack;
; 1581 : 
; 1582 : 	while ( true )
; 1583 : 	{
; 1584 : 		if(lpObj->VpPlayer2[count].state != 0)

  00080	80 7b fe 00	 cmp	 BYTE PTR [ebx-2], 0
  00084	0f 84 ac 00 00
	00		 je	 $LN23@SkillHellF@2

; 1585 : 		{
; 1586 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0008a	0f bf 3b	 movsx	 edi, WORD PTR [ebx]

; 1587 : 
; 1588 : 			if(tObjNum >= 0)

  0008d	85 ff		 test	 edi, edi
  0008f	0f 88 a1 00 00
	00		 js	 $LN23@SkillHellF@2

; 1589 : 			{
; 1590 : 				EnableAttack = 0;
; 1591 : 
; 1592 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00095	80 7b 02 02	 cmp	 BYTE PTR [ebx+2], 2
  00099	75 11		 jne	 SHORT $LN10@SkillHellF@2
  0009b	8b d7		 mov	 edx, edi
  0009d	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  000a3	83 ba cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+716], 0

; 1593 : 				{
; 1594 : 					EnableAttack = 1;

  000aa	7c 53		 jl	 SHORT $LN7@SkillHellF@2
$LN10@SkillHellF@2:

; 1595 : 				}
; 1596 : 				else if(aTargetIndex == tObjNum || DuelIndex == tObjNum)

  000ac	39 7d 0c	 cmp	 DWORD PTR _aTargetIndex$[ebp], edi
  000af	74 4e		 je	 SHORT $LN7@SkillHellF@2
  000b1	39 7d fc	 cmp	 DWORD PTR _DuelIndex$[ebp], edi
  000b4	74 49		 je	 SHORT $LN7@SkillHellF@2

; 1597 : 				{
; 1598 : 					EnableAttack = 1;
; 1599 : 				}
; 1600 : #if GS_CASTLE == 1
; 1601 : 				else if (lpObj->VpPlayer2[count].type != OBJ_NPC &&
; 1602 : 						gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE &&
; 1603 : 						g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 1604 : 				{
; 1605 : 					EnableAttack = 1;
; 1606 : 				}
; 1607 : #endif
; 1608 : 				else
; 1609 : 				{
; 1610 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000b6	8b c7		 mov	 eax, edi
  000b8	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 1611 : 
; 1612 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000be	66 83 b8 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 2
  000c6	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  000cc	75 16		 jne	 SHORT $LN5@SkillHellF@2
  000ce	8b 80 cc 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716]
  000d4	85 c0		 test	 eax, eax
  000d6	78 0c		 js	 SHORT $LN5@SkillHellF@2

; 1613 : 					{
; 1614 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  000d8	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000de	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
$LN5@SkillHellF@2:

; 1615 : 					}
; 1616 : 
; 1617 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  000e4	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000ea	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f0	51		 push	 ecx
  000f1	56		 push	 esi
  000f2	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000f7	83 c4 08	 add	 esp, 8
  000fa	83 f8 01	 cmp	 eax, 1
  000fd	75 37		 jne	 SHORT $LN23@SkillHellF@2
$LN7@SkillHellF@2:

; 1618 : 					{
; 1619 : 						EnableAttack = 1;
; 1620 : 					}
; 1621 : 				}
; 1622 : 
; 1623 : 				if(EnableAttack != 0)
; 1624 : 				{
; 1625 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) <= 6)

  000ff	8b c7		 mov	 eax, edi
  00101	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00107	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010c	50		 push	 eax
  0010d	56		 push	 esi
  0010e	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00113	83 c4 08	 add	 esp, 8
  00116	83 f8 06	 cmp	 eax, 6
  00119	7f 1b		 jg	 SHORT $LN23@SkillHellF@2

; 1626 : 					{
; 1627 : 						gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,600,lpMagic->m_Skill,0);

  0011b	8b 4d 10	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  0011e	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  00122	6a 00		 push	 0
  00124	52		 push	 edx
  00125	68 58 02 00 00	 push	 600			; 00000258H
  0012a	57		 push	 edi
  0012b	6a 32		 push	 50			; 00000032H
  0012d	56		 push	 esi
  0012e	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  00133	83 c4 18	 add	 esp, 24			; 00000018H
$LN23@SkillHellF@2:

; 1628 : 					}
; 1629 : 				}
; 1630 : 			}
; 1631 : 		}
; 1632 : 
; 1633 : 		count++;

  00136	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1634 : 		if(count > MAX_VIEWPORT -1)

  00139	ff 4d 08	 dec	 DWORD PTR tv216[ebp]
  0013c	0f 85 3e ff ff
	ff		 jne	 $LL14@SkillHellF@2

; 1635 : 		{
; 1636 : 			break;
; 1637 : 		}
; 1638 : 	}
; 1639 : 
; 1640 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_EXPHELL,lpObj->m_Index,1);

  00142	8b 06		 mov	 eax, DWORD PTR [esi]
  00144	6a 01		 push	 1
  00146	50		 push	 eax
  00147	6a 28		 push	 40			; 00000028H
  00149	56		 push	 esi
  0014a	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  0014f	83 c4 10	 add	 esp, 16			; 00000010H
  00152	5f		 pop	 edi
  00153	5b		 pop	 ebx

; 1641 : 	return true;

  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	5e		 pop	 esi

; 1642 : }

  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 0c 00	 ret	 12			; 0000000cH
?SkillHellFire2@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillHellFire2
_TEXT	ENDS
PUBLIC	__real@3fc00000
PUBLIC	__real@40400000
PUBLIC	?SkillKnightBlow@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::SkillKnightBlow
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SkillKnightBlow@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z
_TEXT	SEGMENT
_DuelIndex$ = -8					; size = 4
tv345 = -4						; size = 4
_loopcount$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
_isCombo$ = 20						; size = 4
?SkillKnightBlow@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z PROC ; CObjUseSkill::SkillKnightBlow, COMDAT
; _this$ = ecx

; 1663 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1664 : 	LPOBJ lpObj = &gObj[aIndex];
; 1665 : 	int StartDis = 1;
; 1666 : 	int tObjNum;
; 1667 : 
; 1668 : 	float fangle = this->GetAngle(lpObj->X,lpObj->Y,gObj[aTargetIndex].X,gObj[aTargetIndex].Y);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]

; 1669 : 
; 1670 : 	this->SkillFrustrum(aIndex,fangle,1.5f,3.0f);

  00009	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40400000
  0000f	53		 push	 ebx
  00010	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00019	0f bf 90 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  00020	56		 push	 esi
  00021	8b f3		 mov	 esi, ebx
  00023	57		 push	 edi
  00024	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0002a	83 ec 08	 sub	 esp, 8
  0002d	8b f9		 mov	 edi, ecx
  0002f	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  00036	d9 5c 24 04	 fstp	 DWORD PTR [esp+4]
  0003a	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3fc00000
  00040	d9 1c 24	 fstp	 DWORD PTR [esp]
  00043	51		 push	 ecx
  00044	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004a	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  00051	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  00058	52		 push	 edx
  00059	50		 push	 eax
  0005a	51		 push	 ecx
  0005b	8b cf		 mov	 ecx, edi
  0005d	e8 00 00 00 00	 call	 ?GetAngle@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::GetAngle
  00062	89 45 fc	 mov	 DWORD PTR tv345[ebp], eax
  00065	51		 push	 ecx
  00066	db 45 fc	 fild	 DWORD PTR tv345[ebp]
  00069	8b cf		 mov	 ecx, edi
  0006b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0006e	53		 push	 ebx
  0006f	e8 00 00 00 00	 call	 ?SkillFrustrum@CObjUseSkill@@QAEXHMMM@Z ; CObjUseSkill::SkillFrustrum

; 1671 : 
; 1672 : 	int count = 0;
; 1673 : 	int loopcount = 0;
; 1674 : 	int attackcheck;
; 1675 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00074	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00077	8b 55 0c	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  0007a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0007e	6a 01		 push	 1
  00080	52		 push	 edx
  00081	51		 push	 ecx
  00082	33 db		 xor	 ebx, ebx
  00084	56		 push	 esi
  00085	89 5d fc	 mov	 DWORD PTR _loopcount$[ebp], ebx
  00088	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend

; 1676 : 
; 1677 : 	int DuelIndex = lpObj->m_iDuelUser;

  0008d	8b 96 1c 0d 00
	00		 mov	 edx, DWORD PTR [esi+3356]
  00093	83 c4 10	 add	 esp, 16			; 00000010H
  00096	89 55 f8	 mov	 DWORD PTR _DuelIndex$[ebp], edx
  00099	8d a4 24 00 00
	00 00		 npad	 7
$LL20@SkillKnigh@2:

; 1678 : 	int EnableAttack;
; 1679 : 
; 1680 : 	while ( true )
; 1681 : 	{
; 1682 : 		if(lpObj->VpPlayer2[count].state != 0)

  000a0	8d 84 5b c5 01
	00 00		 lea	 eax, DWORD PTR [ebx+ebx*2+453]
  000a7	80 3c 86 00	 cmp	 BYTE PTR [esi+eax*4], 0
  000ab	0f 84 f4 00 00
	00		 je	 $LN29@SkillKnigh@2

; 1683 : 		{
; 1684 : 			tObjNum = lpObj->VpPlayer2[count].number;

  000b1	8d 0c 5b	 lea	 ecx, DWORD PTR [ebx+ebx*2]
  000b4	0f bf bc 8e 16
	07 00 00	 movsx	 edi, WORD PTR [esi+ecx*4+1814]
  000bc	8d 04 8e	 lea	 eax, DWORD PTR [esi+ecx*4]

; 1685 : 
; 1686 : 			if(tObjNum >= 0)

  000bf	85 ff		 test	 edi, edi
  000c1	0f 88 de 00 00
	00		 js	 $LN29@SkillKnigh@2

; 1687 : 			{
; 1688 : 				EnableAttack = 0;
; 1689 : 
; 1690 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  000c7	80 b8 18 07 00
	00 02		 cmp	 BYTE PTR [eax+1816], 2
  000ce	75 11		 jne	 SHORT $LN28@SkillKnigh@2
  000d0	8b d7		 mov	 edx, edi
  000d2	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  000d8	83 ba cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+716], 0

; 1691 : 				{
; 1692 : 					EnableAttack = 1;

  000df	7c 53		 jl	 SHORT $LN13@SkillKnigh@2
$LN28@SkillKnigh@2:

; 1693 : 				}
; 1694 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  000e1	3b 7d 0c	 cmp	 edi, DWORD PTR _aTargetIndex$[ebp]
  000e4	74 4e		 je	 SHORT $LN13@SkillKnigh@2
  000e6	39 7d f8	 cmp	 DWORD PTR _DuelIndex$[ebp], edi
  000e9	74 49		 je	 SHORT $LN13@SkillKnigh@2

; 1695 : 				{
; 1696 : 					EnableAttack = 1;
; 1697 : 				}
; 1698 : 				else
; 1699 : 				{
; 1700 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000eb	8b c7		 mov	 eax, edi
  000ed	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 1701 : 
; 1702 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000f3	66 83 b8 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 2
  000fb	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  00101	75 16		 jne	 SHORT $LN11@SkillKnigh@2
  00103	8b 80 cc 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716]
  00109	85 c0		 test	 eax, eax
  0010b	78 0c		 js	 SHORT $LN11@SkillKnigh@2

; 1703 : 					{
; 1704 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  0010d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00113	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
$LN11@SkillKnigh@2:

; 1705 : 					}
; 1706 : 
; 1707 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00119	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0011f	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00125	51		 push	 ecx
  00126	56		 push	 esi
  00127	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0012c	83 c4 08	 add	 esp, 8
  0012f	83 f8 01	 cmp	 eax, 1
  00132	75 71		 jne	 SHORT $LN29@SkillKnigh@2
$LN13@SkillKnigh@2:

; 1708 : 					{
; 1709 : 						EnableAttack = 1;
; 1710 : 					}
; 1711 : 				}
; 1712 : 
; 1713 : 				if(EnableAttack != 0)
; 1714 : 				{
; 1715 : 					attackcheck = 0;
; 1716 : 
; 1717 : 					if(loopcount == 0)

  00134	83 7d fc 00	 cmp	 DWORD PTR _loopcount$[ebp], 0

; 1718 : 					{
; 1719 : 						attackcheck = 1;

  00138	74 11		 je	 SHORT $LN27@SkillKnigh@2

; 1720 : 					}
; 1721 : 					else if(rand()%3==0)

  0013a	e8 00 00 00 00	 call	 _rand
  0013f	99		 cdq
  00140	b9 03 00 00 00	 mov	 ecx, 3
  00145	f7 f9		 idiv	 ecx
  00147	85 d2		 test	 edx, edx
  00149	75 5a		 jne	 SHORT $LN29@SkillKnigh@2
$LN27@SkillKnigh@2:

; 1722 : 					{
; 1723 : 						attackcheck = 1;
; 1724 : 					}
; 1725 : 
; 1726 : 					if(attackcheck != 0)
; 1727 : 					{
; 1728 : 						if(::SkillTestFrustrum(gObj[tObjNum].X,gObj[tObjNum].Y,aIndex))

  0014b	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0014e	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00154	0f bf 87 06 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  0015b	0f bf 8f 04 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  00162	52		 push	 edx
  00163	50		 push	 eax
  00164	51		 push	 ecx
  00165	e8 00 00 00 00	 call	 ?SkillTestFrustrum@@YAHHHH@Z ; SkillTestFrustrum
  0016a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016d	85 c0		 test	 eax, eax
  0016f	74 34		 je	 SHORT $LN29@SkillKnigh@2

; 1729 : 						{
; 1730 : 							gObjAttack(lpObj,&gObj[tObjNum],lpMagic,0,1,0,isCombo);

  00171	8b 55 14	 mov	 edx, DWORD PTR _isCombo$[ebp]
  00174	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00177	52		 push	 edx
  00178	6a 00		 push	 0
  0017a	6a 01		 push	 1
  0017c	6a 00		 push	 0
  0017e	50		 push	 eax
  0017f	8d bf 00 00 00
	00		 lea	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  00185	57		 push	 edi
  00186	56		 push	 esi
  00187	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  0018c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1731 : 							if(isCombo != 0)

  0018f	83 7d 14 00	 cmp	 DWORD PTR _isCombo$[ebp], 0
  00193	74 10		 je	 SHORT $LN29@SkillKnigh@2

; 1732 : 							{
; 1733 : 								GCMagicAttackNumberSend(lpObj,AT_SKILL_COMBO,gObj[tObjNum].m_Index,1);

  00195	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00197	6a 01		 push	 1
  00199	51		 push	 ecx
  0019a	6a 3b		 push	 59			; 0000003bH
  0019c	56		 push	 esi
  0019d	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  001a2	83 c4 10	 add	 esp, 16			; 00000010H
$LN29@SkillKnigh@2:

; 1734 : 							}
; 1735 : 						}
; 1736 : 					}
; 1737 : 				}
; 1738 : 			}
; 1739 : 		}
; 1740 : 
; 1741 : 		count++;

  001a5	43		 inc	 ebx

; 1742 : 		if(count > MAX_VIEWPORT -1)

  001a6	83 fb 4a	 cmp	 ebx, 74			; 0000004aH
  001a9	0f 8e f1 fe ff
	ff		 jle	 $LL20@SkillKnigh@2

; 1743 : 		{
; 1744 : 			loopcount++;

  001af	8b 45 fc	 mov	 eax, DWORD PTR _loopcount$[ebp]
  001b2	40		 inc	 eax

; 1745 : 			count = 0;

  001b3	33 db		 xor	 ebx, ebx
  001b5	89 45 fc	 mov	 DWORD PTR _loopcount$[ebp], eax

; 1746 : 			if(loopcount >= 3)

  001b8	83 f8 03	 cmp	 eax, 3

; 1747 : 			{
; 1748 : 				break;
; 1749 : 			}
; 1750 : 		}
; 1751 : 	}

  001bb	0f 8c df fe ff
	ff		 jl	 $LL20@SkillKnigh@2

; 1752 : 	return true;

  001c1	5f		 pop	 edi
  001c2	5e		 pop	 esi
  001c3	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  001c6	5b		 pop	 ebx

; 1753 : }

  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c2 10 00	 ret	 16			; 00000010H
?SkillKnightBlow@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ENDP ; CObjUseSkill::SkillKnightBlow
_TEXT	ENDS
PUBLIC	?CalDistance@CObjUseSkill@@QAEHHHHH@Z		; CObjUseSkill::CalDistance
; Function compile flags: /Ogtp
;	COMDAT ?CalDistance@CObjUseSkill@@QAEHHHHH@Z
_TEXT	SEGMENT
tv167 = 8						; size = 4
tv164 = 8						; size = 4
tv135 = 8						; size = 4
tv133 = 8						; size = 4
_ty$ = 8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_tx$ = 16						; size = 4
_x1$ = 16						; size = 4
_y1$ = 20						; size = 4
?CalDistance@CObjUseSkill@@QAEHHHHH@Z PROC		; CObjUseSkill::CalDistance, COMDAT
; _this$ = ecx

; 1851 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1852 : 	if(x == x1 && y == y1)

  00003	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00006	8b 55 10	 mov	 edx, DWORD PTR _x1$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0000c	56		 push	 esi
  0000d	8b 75 14	 mov	 esi, DWORD PTR _y1$[ebp]
  00010	3b c2		 cmp	 eax, edx
  00012	75 0b		 jne	 SHORT $LN1@CalDistanc
  00014	3b ce		 cmp	 ecx, esi
  00016	75 07		 jne	 SHORT $LN1@CalDistanc

; 1853 : 	{
; 1854 : 		return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	5e		 pop	 esi

; 1861 : }

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
$LN1@CalDistanc:

; 1855 : 	}
; 1856 : 
; 1857 : 	float tx = x - x1;

  0001f	2b c2		 sub	 eax, edx
  00021	89 45 08	 mov	 DWORD PTR tv167[ebp], eax
  00024	db 45 08	 fild	 DWORD PTR tv167[ebp]

; 1858 : 	float ty = y - y1;

  00027	2b ce		 sub	 ecx, esi
  00029	89 4d 08	 mov	 DWORD PTR tv164[ebp], ecx
  0002c	d9 5d 10	 fstp	 DWORD PTR _tx$[ebp]
  0002f	db 45 08	 fild	 DWORD PTR tv164[ebp]
  00032	d9 5d 08	 fstp	 DWORD PTR _ty$[ebp]

; 1859 : 
; 1860 : 	return sqrt(tx*tx + ty*ty);

  00035	d9 45 08	 fld	 DWORD PTR _ty$[ebp]
  00038	d9 45 10	 fld	 DWORD PTR _tx$[ebp]
  0003b	dc c8		 fmul	 ST(0), ST(0)
  0003d	d9 c1		 fld	 ST(1)
  0003f	de ca		 fmulp	 ST(2), ST(0)
  00041	de c1		 faddp	 ST(1), ST(0)
  00043	d9 5d 08	 fstp	 DWORD PTR tv135[ebp]
  00046	d9 45 08	 fld	 DWORD PTR tv135[ebp]
  00049	e8 00 00 00 00	 call	 __CIsqrt
  0004e	d9 5d 08	 fstp	 DWORD PTR tv133[ebp]
  00051	d9 45 08	 fld	 DWORD PTR tv133[ebp]
  00054	e8 00 00 00 00	 call	 __ftol2_sse
  00059	5e		 pop	 esi

; 1861 : }

  0005a	5d		 pop	 ebp
  0005b	c2 10 00	 ret	 16			; 00000010H
?CalDistance@CObjUseSkill@@QAEHHHHH@Z ENDP		; CObjUseSkill::CalDistance
_TEXT	ENDS
PUBLIC	?SkillAreaCheck@CObjUseSkill@@QAEHHHHHHHH@Z	; CObjUseSkill::SkillAreaCheck
; Function compile flags: /Ogtp
;	COMDAT ?SkillAreaCheck@CObjUseSkill@@QAEHHHHHHHH@Z
_TEXT	SEGMENT
_maxangel$ = 8						; size = 4
_angel$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_tx$ = 20						; size = 4
_ty$ = 24						; size = 4
_dis$ = 28						; size = 4
_arc$ = 32						; size = 4
?SkillAreaCheck@CObjUseSkill@@QAEHHHHHHHH@Z PROC	; CObjUseSkill::SkillAreaCheck, COMDAT
; _this$ = ecx

; 1864 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1865 : 	int minangel = angel - arc;

  00003	8b 45 08	 mov	 eax, DWORD PTR _angel$[ebp]

; 1866 : 	int maxangel = angel + arc;
; 1867 : 
; 1868 : 	if(this->CalDistance(x,y,tx,ty) > dis)

  00006	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 18	 mov	 ebx, DWORD PTR _ty$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	8b 4d 20	 mov	 ecx, DWORD PTR _arc$[ebp]
  00014	8b f0		 mov	 esi, eax
  00016	03 c1		 add	 eax, ecx
  00018	53		 push	 ebx
  00019	89 45 08	 mov	 DWORD PTR _maxangel$[ebp], eax
  0001c	8b 45 14	 mov	 eax, DWORD PTR _tx$[ebp]
  0001f	2b f1		 sub	 esi, ecx
  00021	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00024	50		 push	 eax
  00025	51		 push	 ecx
  00026	52		 push	 edx
  00027	8b cf		 mov	 ecx, edi
  00029	e8 00 00 00 00	 call	 ?CalDistance@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::CalDistance
  0002e	3b 45 1c	 cmp	 eax, DWORD PTR _dis$[ebp]

; 1869 : 	{
; 1870 : 		return false;

  00031	7f 5c		 jg	 SHORT $LN21@SkillAreaC

; 1871 : 	}
; 1872 : 
; 1873 : 	int targetangle = this->GetAngle(x,y,tx,ty);

  00033	8b 45 14	 mov	 eax, DWORD PTR _tx$[ebp]
  00036	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00039	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  0003c	53		 push	 ebx
  0003d	50		 push	 eax
  0003e	51		 push	 ecx
  0003f	52		 push	 edx
  00040	8b cf		 mov	 ecx, edi
  00042	e8 00 00 00 00	 call	 ?GetAngle@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::GetAngle

; 1874 : 
; 1875 : 	if(minangel < 0)

  00047	85 f6		 test	 esi, esi
  00049	79 1b		 jns	 SHORT $LN17@SkillAreaC

; 1876 : 	{
; 1877 : 		if(targetangle > maxangel)

  0004b	3b 45 08	 cmp	 eax, DWORD PTR _maxangel$[ebp]
  0004e	7e 55		 jle	 SHORT $LN1@SkillAreaC

; 1878 : 		{
; 1879 : 			if(targetangle > minangel + 360)

  00050	81 c6 68 01 00
	00		 add	 esi, 360		; 00000168H
  00056	33 c9		 xor	 ecx, ecx
  00058	3b c6		 cmp	 eax, esi
  0005a	0f 9f c1	 setg	 cl
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b c1		 mov	 eax, ecx

; 1920 : }

  00062	5d		 pop	 ebp
  00063	c2 1c 00	 ret	 28			; 0000001cH
$LN17@SkillAreaC:

; 1880 : 			{
; 1881 : 				return true;
; 1882 : 			}
; 1883 : 			else
; 1884 : 			{
; 1885 : 				return false;
; 1886 : 			}
; 1887 : 		}
; 1888 : 		else if(maxangel < targetangle)
; 1889 : 		{
; 1890 : 			return false;
; 1891 : 		}
; 1892 : 	}
; 1893 : 	else if(maxangel > 360)

  00066	8b 4d 08	 mov	 ecx, DWORD PTR _maxangel$[ebp]
  00069	81 f9 68 01 00
	00		 cmp	 ecx, 360		; 00000168H
  0006f	7e 27		 jle	 SHORT $LN10@SkillAreaC

; 1894 : 	{
; 1895 : 		if(targetangle < minangel)

  00071	3b c6		 cmp	 eax, esi
  00073	7d 16		 jge	 SHORT $LN9@SkillAreaC

; 1896 : 		{
; 1897 : 			if(targetangle < maxangel - 360)

  00075	33 d2		 xor	 edx, edx
  00077	81 c1 98 fe ff
	ff		 add	 ecx, -360		; fffffe98H
  0007d	3b c1		 cmp	 eax, ecx
  0007f	0f 9c c2	 setl	 dl
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b c2		 mov	 eax, edx

; 1920 : }

  00087	5d		 pop	 ebp
  00088	c2 1c 00	 ret	 28			; 0000001cH
$LN9@SkillAreaC:

; 1898 : 			{
; 1899 : 				return true;
; 1900 : 			}
; 1901 : 			else
; 1902 : 			{
; 1903 : 				return false;
; 1904 : 			}
; 1905 : 		}
; 1906 : 		else if(maxangel < targetangle)

  0008b	3b c8		 cmp	 ecx, eax
  0008d	7d 16		 jge	 SHORT $LN1@SkillAreaC
$LN21@SkillAreaC:
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi

; 1907 : 		{
; 1908 : 			return false;

  00091	33 c0		 xor	 eax, eax
  00093	5b		 pop	 ebx

; 1920 : }

  00094	5d		 pop	 ebp
  00095	c2 1c 00	 ret	 28			; 0000001cH
$LN10@SkillAreaC:

; 1909 : 		}
; 1910 : 	}
; 1911 : 	else if(minangel > targetangle)

  00098	3b f0		 cmp	 esi, eax
  0009a	7e ef		 jle	 SHORT $LN9@SkillAreaC

; 1907 : 		{
; 1908 : 			return false;

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	33 c0		 xor	 eax, eax
  000a0	5b		 pop	 ebx

; 1920 : }

  000a1	5d		 pop	 ebp
  000a2	c2 1c 00	 ret	 28			; 0000001cH
$LN1@SkillAreaC:
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi

; 1912 : 	{
; 1913 : 		return false;
; 1914 : 	}
; 1915 : 	else if(maxangel < targetangle)
; 1916 : 	{
; 1917 : 		return false;
; 1918 : 	}
; 1919 : 	return true;

  000a7	b8 01 00 00 00	 mov	 eax, 1
  000ac	5b		 pop	 ebx

; 1920 : }

  000ad	5d		 pop	 ebp
  000ae	c2 1c 00	 ret	 28			; 0000001cH
?SkillAreaCheck@CObjUseSkill@@QAEHHHHHHHH@Z ENDP	; CObjUseSkill::SkillAreaCheck
_TEXT	ENDS
PUBLIC	?SkillElectricSpark@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillElectricSpark
; Function compile flags: /Ogtp
;	COMDAT ?SkillElectricSpark@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z
_TEXT	SEGMENT
_iangle$ = -12						; size = 4
_DuelIndex$ = -8					; size = 4
_Hit$ = -4						; size = 4
_this$ = -4						; size = 4
tv64 = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_dir$ = 24						; size = 1
tv423 = 28						; size = 4
_TargetPos$ = 28					; size = 1
_aTargetIndex$ = 32					; size = 4
?SkillElectricSpark@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z PROC ; CObjUseSkill::SkillElectricSpark, COMDAT
; _this$ = ecx

; 2465 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 2466 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H

; 2467 : 
; 2468 : 	int TargePosx = lpObj->X - (8 - (TargetPos & 15));
; 2469 : 	int TargePosy = lpObj->Y - (8 - ((TargetPos & 240) >> 4));
; 2470 : 
; 2471 : 	int tObjNum;
; 2472 : 	int count = 0;
; 2473 : 	int DuelIndex = lpObj->m_iDuelUser;

  00010	8b 83 1c 0d 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3356]
  00016	0f bf 93 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+262]
  0001d	56		 push	 esi
  0001e	8d b3 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx]
  00024	89 45 f8	 mov	 DWORD PTR _DuelIndex$[ebp], eax
  00027	0f b6 45 1c	 movzx	 eax, BYTE PTR _TargetPos$[ebp]
  0002b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0002e	57		 push	 edi
  0002f	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]
  00036	8b c8		 mov	 ecx, eax
  00038	c1 e9 04	 shr	 ecx, 4

; 2474 : 	int iangle = this->GetAngle(lpObj->X,lpObj->Y,TargePosx,TargePosy);

  0003b	8d 4c 11 f8	 lea	 ecx, DWORD PTR [ecx+edx-8]
  0003f	51		 push	 ecx
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 e0 0f	 and	 eax, 15			; 0000000fH
  00046	8d 44 38 f8	 lea	 eax, DWORD PTR [eax+edi-8]
  0004a	50		 push	 eax
  0004b	52		 push	 edx
  0004c	57		 push	 edi
  0004d	e8 00 00 00 00	 call	 ?GetAngle@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::GetAngle
  00052	89 45 f4	 mov	 DWORD PTR _iangle$[ebp], eax
  00055	8d 86 16 07 00
	00		 lea	 eax, DWORD PTR [esi+1814]

; 2475 : 	int delaytime;
; 2476 : 	int Hit = 0;

  0005b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Hit$[ebp], 0
  00062	89 45 1c	 mov	 DWORD PTR tv423[ebp], eax
  00065	c7 45 08 4b 00
	00 00		 mov	 DWORD PTR tv64[ebp], 75	; 0000004bH
  0006c	8d 64 24 00	 npad	 4
$LL15@SkillElect:

; 2477 : 	int EnableAttack;
; 2478 : 
; 2479 : 	while ( true )
; 2480 : 	{
; 2481 : 		if(lpObj->VpPlayer2[count].state != 0)

  00070	80 78 fe 00	 cmp	 BYTE PTR [eax-2], 0
  00074	0f 84 d1 00 00
	00		 je	 $LN22@SkillElect

; 2482 : 		{
; 2483 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0007a	0f bf 38	 movsx	 edi, WORD PTR [eax]

; 2484 : 
; 2485 : 			if(tObjNum >= 0)

  0007d	85 ff		 test	 edi, edi
  0007f	0f 88 c6 00 00
	00		 js	 $LN22@SkillElect

; 2486 : 			{
; 2487 : 				EnableAttack = 0;
; 2488 : 
; 2489 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00085	80 78 02 02	 cmp	 BYTE PTR [eax+2], 2
  00089	75 11		 jne	 SHORT $LN11@SkillElect
  0008b	8b cf		 mov	 ecx, edi
  0008d	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00093	83 b9 cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+716], 0

; 2490 : 				{
; 2491 : 					EnableAttack = 1;

  0009a	7c 53		 jl	 SHORT $LN8@SkillElect
$LN11@SkillElect:

; 2492 : 				}
; 2493 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  0009c	3b 7d 20	 cmp	 edi, DWORD PTR _aTargetIndex$[ebp]
  0009f	74 4e		 je	 SHORT $LN8@SkillElect
  000a1	39 7d f8	 cmp	 DWORD PTR _DuelIndex$[ebp], edi
  000a4	74 49		 je	 SHORT $LN8@SkillElect

; 2494 : 				{
; 2495 : 					EnableAttack = 1;
; 2496 : 				}
; 2497 : #if GS_CASTLE == 1
; 2498 : 					else if (lpObj->VpPlayer2[count].type != OBJ_NPC &&
; 2499 : 							gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE &&
; 2500 : 							g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 2501 : 					{
; 2502 : 						EnableAttack = 1;
; 2503 : 					}
; 2504 : #endif
; 2505 : 				else
; 2506 : 				{
; 2507 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000a6	8b c7		 mov	 eax, edi
  000a8	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 2508 : 
; 2509 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000ae	66 83 b8 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 2
  000b6	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  000bc	75 16		 jne	 SHORT $LN6@SkillElect
  000be	8b 80 cc 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716]
  000c4	85 c0		 test	 eax, eax
  000c6	78 0c		 js	 SHORT $LN6@SkillElect

; 2510 : 					{
; 2511 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  000c8	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000ce	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
$LN6@SkillElect:

; 2512 : 					}
; 2513 : 
; 2514 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  000d4	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000da	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e0	51		 push	 ecx
  000e1	56		 push	 esi
  000e2	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000e7	83 c4 08	 add	 esp, 8
  000ea	83 f8 01	 cmp	 eax, 1
  000ed	75 5c		 jne	 SHORT $LN22@SkillElect
$LN8@SkillElect:

; 2515 : 					{
; 2516 : 						EnableAttack = 1;
; 2517 : 					}
; 2518 : 				}
; 2519 : 
; 2520 : 				if(EnableAttack != 0)
; 2521 : 				{
; 2522 : 					if(SkillElectricSparkHitBox.HitCheck(iangle,gObj[aIndex].X,gObj[aIndex].Y,gObj[tObjNum].X,gObj[tObjNum].Y))

  000ef	0f bf 8b 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+262]
  000f6	8b c7		 mov	 eax, edi
  000f8	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000fe	0f bf 90 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  00105	0f bf 80 04 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  0010c	52		 push	 edx
  0010d	0f bf 93 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+260]
  00114	50		 push	 eax
  00115	8b 45 f4	 mov	 eax, DWORD PTR _iangle$[ebp]
  00118	51		 push	 ecx
  00119	52		 push	 edx
  0011a	50		 push	 eax
  0011b	b9 00 00 00 00	 mov	 ecx, OFFSET ?SkillElectricSparkHitBox@@3VCSkillHitBox@@A ; SkillElectricSparkHitBox
  00120	e8 00 00 00 00	 call	 ?HitCheck@CSkillHitBox@@QAEHHHHHH@Z ; CSkillHitBox::HitCheck
  00125	85 c0		 test	 eax, eax
  00127	74 22		 je	 SHORT $LN22@SkillElect

; 2523 : 					{
; 2524 : 						delaytime = 500;
; 2525 : 						Hit = 1;
; 2526 : 
; 2527 : 						gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,delaytime,lpMagic->m_Skill,0);

  00129	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  0012c	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  00130	6a 00		 push	 0
  00132	52		 push	 edx
  00133	68 f4 01 00 00	 push	 500			; 000001f4H
  00138	57		 push	 edi
  00139	6a 32		 push	 50			; 00000032H
  0013b	56		 push	 esi
  0013c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _Hit$[ebp], 1
  00143	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  00148	83 c4 18	 add	 esp, 24			; 00000018H
$LN22@SkillElect:

; 2528 : 					}
; 2529 : 				}
; 2530 : 			}
; 2531 : 		}
; 2532 : 
; 2533 : 		count++;

  0014b	8b 45 1c	 mov	 eax, DWORD PTR tv423[ebp]
  0014e	83 c0 0c	 add	 eax, 12			; 0000000cH

; 2534 : 		if(count > MAX_VIEWPORT -1)

  00151	ff 4d 08	 dec	 DWORD PTR tv64[ebp]
  00154	89 45 1c	 mov	 DWORD PTR tv423[ebp], eax
  00157	0f 85 13 ff ff
	ff		 jne	 $LL15@SkillElect

; 2535 : 		{
; 2536 : 			break;
; 2537 : 		}
; 2538 : 	}
; 2539 : 
; 2540 : 	if(Hit != 0)

  0015d	83 7d fc 00	 cmp	 DWORD PTR _Hit$[ebp], 0
  00161	74 09		 je	 SHORT $LN1@SkillElect

; 2541 : 	{
; 2542 : 		DecPartyMemberHPandMP(lpObj);

  00163	56		 push	 esi
  00164	e8 00 00 00 00	 call	 ?DecPartyMemberHPandMP@@YAHPAUOBJECTSTRUCT@@@Z ; DecPartyMemberHPandMP
  00169	83 c4 04	 add	 esp, 4
$LN1@SkillElect:
  0016c	5f		 pop	 edi
  0016d	5e		 pop	 esi
  0016e	5b		 pop	 ebx

; 2543 : 	}
; 2544 : }

  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c2 1c 00	 ret	 28			; 0000001cH
?SkillElectricSpark@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ENDP ; CObjUseSkill::SkillElectricSpark
_TEXT	ENDS
PUBLIC	?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::RunningSkill
EXTRN	?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z:PROC	; GCActionSend
; Function compile flags: /Ogtp
;	COMDAT ?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z
_TEXT	SEGMENT
_lpTargetObj$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
_MagicNumber$ = 19					; size = 1
_bCombo$ = 20						; size = 4
?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z PROC ; CObjUseSkill::RunningSkill, COMDAT
; _this$ = ecx

; 502  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 503  : 	LPOBJ lpObj = &gObj[aIndex];
; 504  : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  00004	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00007	53		 push	 ebx

; 505  : 	BYTE MagicNumber = lpMagic->m_Skill;

  00008	8b 5d 10	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  0000b	56		 push	 esi
  0000c	8b d0		 mov	 edx, eax
  0000e	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00014	57		 push	 edi
  00015	8b f9		 mov	 edi, ecx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0001a	8b f1		 mov	 esi, ecx
  0001c	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00022	81 c2 00 00 00
	00		 add	 edx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	89 55 fc	 mov	 DWORD PTR _lpTargetObj$[ebp], edx
  0002b	8a 53 05	 mov	 dl, BYTE PTR [ebx+5]
  0002e	88 55 13	 mov	 BYTE PTR _MagicNumber$[ebp], dl
  00031	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 506  : 
; 507  : 	lpObj->m_SkillNumber = MagicNumber;
; 508  : 
; 509  : 	if(lpObj->m_iSkillInvisibleTime > 0)

  00037	83 be e4 14 00
	00 00		 cmp	 DWORD PTR [esi+5348], 0
  0003e	0f b6 d2	 movzx	 edx, dl
  00041	66 89 96 3c 02
	00 00		 mov	 WORD PTR [esi+572], dx
  00048	7e 10		 jle	 SHORT $LN49@RunningSki

; 510  : 	{
; 511  : 		this->RemoveCloakingEffect(lpObj->m_Index);

  0004a	8b 06		 mov	 eax, DWORD PTR [esi]
  0004c	50		 push	 eax
  0004d	8b cf		 mov	 ecx, edi
  0004f	e8 00 00 00 00	 call	 ?RemoveCloakingEffect@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::RemoveCloakingEffect
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00057	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
$LN49@RunningSki:

; 512  : 	}
; 513  : 
; 514  : 	switch(MagicNumber)

  0005a	0f b6 55 13	 movzx	 edx, BYTE PTR _MagicNumber$[ebp]
  0005e	4a		 dec	 edx
  0005f	81 fa c9 00 00
	00		 cmp	 edx, 201		; 000000c9H
  00065	0f 87 91 04 00
	00		 ja	 $LN1@RunningSki
  0006b	0f b6 92 00 00
	00 00		 movzx	 edx, BYTE PTR $LN48@RunningSki[edx]
  00072	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN51@RunningSki[edx*4]
$LN42@RunningSki:

; 515  : 	{
; 516  : 	case AT_SKILL_BLOCKING:
; 517  : 		if(lpObj->pInventory[1].IsItem() == 1)

  00079	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0007f	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00085	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0008a	83 f8 01	 cmp	 eax, 1
  0008d	0f 85 7f 04 00
	00		 jne	 $LN43@RunningSki

; 518  : 		{
; 519  : 			if(lpObj->pInventory[1].m_Type >= ITEMGET(6,4) && lpObj->pInventory[1].m_Type < ITEMGET(7,0))

  00093	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00099	0f b7 88 ae 00
	00 00		 movzx	 ecx, WORD PTR [eax+174]
  000a0	ba 04 0c 00 00	 mov	 edx, 3076		; 00000c04H
  000a5	66 3b ca	 cmp	 cx, dx
  000a8	0f 8c 64 04 00
	00		 jl	 $LN43@RunningSki
  000ae	ba 00 0e 00 00	 mov	 edx, 3584		; 00000e00H
  000b3	66 3b ca	 cmp	 cx, dx
  000b6	0f 8d 56 04 00
	00		 jge	 $LN43@RunningSki

; 520  : 			{
; 521  : 				if(lpObj->pInventory[1].m_Option1 != 0)

  000bc	80 b8 20 01 00
	00 00		 cmp	 BYTE PTR [eax+288], 0
  000c3	0f 84 49 04 00
	00		 je	 $LN43@RunningSki

; 522  : 				{
; 523  : 					lpObj->m_SkillTime = GetTickCount() + 4000;

  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 524  : 					GCActionSend(lpObj,18,lpObj->m_Index,aTargetIndex);

  000cf	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000d1	05 a0 0f 00 00	 add	 eax, 4000		; 00000fa0H
  000d6	89 86 40 02 00
	00		 mov	 DWORD PTR [esi+576], eax
  000dc	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  000df	50		 push	 eax
  000e0	51		 push	 ecx
  000e1	6a 12		 push	 18			; 00000012H
  000e3	56		 push	 esi
  000e4	e8 00 00 00 00	 call	 ?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z ; GCActionSend
  000e9	83 c4 10	 add	 esp, 16			; 00000010H
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  000ee	b8 01 00 00 00	 mov	 eax, 1
  000f3	5b		 pop	 ebx

; 600  : }

  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c2 10 00	 ret	 16			; 00000010H
$LN38@RunningSki:

; 525  : 				}
; 526  : 			}
; 527  : 		}
; 528  : 		break;
; 529  : 	case AT_SKILL_POISON:
; 530  : 	case AT_SKILL_METEO:
; 531  : 	case AT_SKILL_THUNDER:
; 532  : 	case AT_SKILL_FIREBALL:
; 533  : 	case AT_SKILL_FLAME:
; 534  : 	case AT_SKILL_SLOW:
; 535  : 	case AT_SKILL_ENERGYBALL:
; 536  : 	case AT_SKILL_SWORD1:
; 537  : 	case AT_SKILL_SWORD2:
; 538  : 	case AT_SKILL_SWORD3:
; 539  : 	case AT_SKILL_SWORD4:
; 540  : 	case AT_SKILL_SWORD5:
; 541  : 	case AT_SKILL_CROSSBOW:
; 542  : 	case AT_SKILL_BOW:
; 543  : 	case AT_SKILL_WHEEL:
; 544  : 	case AT_SKILL_BLOWOFFURY:
; 545  : 	case AT_SKILL_KNIGHTSPEAR:
; 546  : 	case AT_SKILL_PENETRATION:
; 547  : 	case AT_SKILL_SWORD6:
; 548  : 		gObjAttack(lpObj,lpTargetObj,lpMagic,1,0,0,0);

  000fa	8b 55 fc	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000fd	6a 00		 push	 0
  000ff	6a 00		 push	 0
  00101	6a 00		 push	 0
  00103	6a 01		 push	 1
  00105	53		 push	 ebx
  00106	52		 push	 edx

; 549  : 		break;

  00107	e9 fd 03 00 00	 jmp	 $LN50@RunningSki
$LN37@RunningSki:

; 550  : 	case AT_SKILL_HEALING:	this->SkillHealing(aIndex,aTargetIndex,lpMagic->m_Level);break;

  0010c	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  00110	52		 push	 edx
  00111	50		 push	 eax
  00112	51		 push	 ecx
  00113	8b cf		 mov	 ecx, edi
  00115	e8 00 00 00 00	 call	 ?SkillHealing@CObjUseSkill@@QAEXHHH@Z ; CObjUseSkill::SkillHealing
  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  0011c	b8 01 00 00 00	 mov	 eax, 1
  00121	5b		 pop	 ebx

; 600  : }

  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c2 10 00	 ret	 16			; 00000010H
$LN36@RunningSki:

; 551  : 	case AT_SKILL_MAGICDEFENSE:	this->WizardMagicDefense(aIndex,aTargetIndex,lpMagic->m_Level);break;

  00128	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  0012c	52		 push	 edx
  0012d	50		 push	 eax
  0012e	51		 push	 ecx
  0012f	8b cf		 mov	 ecx, edi
  00131	e8 00 00 00 00	 call	 ?WizardMagicDefense@CObjUseSkill@@QAEXHHH@Z ; CObjUseSkill::WizardMagicDefense
  00136	5f		 pop	 edi
  00137	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  00138	b8 01 00 00 00	 mov	 eax, 1
  0013d	5b		 pop	 ebx

; 600  : }

  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c2 10 00	 ret	 16			; 00000010H
$LN35@RunningSki:

; 552  : 	case AT_SKILL_KNIGHTADDLIFE:	this->KnightSkillAddLife(aIndex,lpMagic->m_Level);break;

  00144	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00148	50		 push	 eax
  00149	51		 push	 ecx
  0014a	8b cf		 mov	 ecx, edi
  0014c	e8 00 00 00 00	 call	 ?KnightSkillAddLife@CObjUseSkill@@QAEXHH@Z ; CObjUseSkill::KnightSkillAddLife
  00151	5f		 pop	 edi
  00152	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  00153	b8 01 00 00 00	 mov	 eax, 1
  00158	5b		 pop	 ebx

; 600  : }

  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c2 10 00	 ret	 16			; 00000010H
$LN34@RunningSki:

; 553  : 	case AT_SKILL_DEFENSE:	this->SkillDefense(aIndex,aTargetIndex,lpMagic->m_Level);break;

  0015f	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  00163	52		 push	 edx
  00164	50		 push	 eax
  00165	51		 push	 ecx
  00166	8b cf		 mov	 ecx, edi
  00168	e8 00 00 00 00	 call	 ?SkillDefense@CObjUseSkill@@QAEXHHH@Z ; CObjUseSkill::SkillDefense
  0016d	5f		 pop	 edi
  0016e	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  0016f	b8 01 00 00 00	 mov	 eax, 1
  00174	5b		 pop	 ebx

; 600  : }

  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c2 10 00	 ret	 16			; 00000010H
$LN33@RunningSki:

; 554  : 	case AT_SKILL_ATTACK:	this->SkillAttack(aIndex,aTargetIndex,lpMagic->m_Level);break;

  0017b	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  0017f	52		 push	 edx
  00180	50		 push	 eax
  00181	51		 push	 ecx
  00182	8b cf		 mov	 ecx, edi
  00184	e8 00 00 00 00	 call	 ?SkillAttack@CObjUseSkill@@QAEXHHH@Z ; CObjUseSkill::SkillAttack
  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  0018b	b8 01 00 00 00	 mov	 eax, 1
  00190	5b		 pop	 ebx

; 600  : }

  00191	8b e5		 mov	 esp, ebp
  00193	5d		 pop	 ebp
  00194	c2 10 00	 ret	 16			; 00000010H
$LN32@RunningSki:

; 555  : 
; 556  : 	case AT_SKILL_CALLMON1:	return this->SkillMonsterCall(lpObj->m_Index,26,lpObj->X-1,lpObj->Y+1);

  00197	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  0019e	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  001a5	8b 16		 mov	 edx, DWORD PTR [esi]
  001a7	40		 inc	 eax
  001a8	50		 push	 eax
  001a9	49		 dec	 ecx
  001aa	51		 push	 ecx
  001ab	6a 1a		 push	 26			; 0000001aH
  001ad	52		 push	 edx
  001ae	8b cf		 mov	 ecx, edi
  001b0	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  001b5	5f		 pop	 edi
  001b6	5e		 pop	 esi
  001b7	5b		 pop	 ebx

; 600  : }

  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c2 10 00	 ret	 16			; 00000010H
$LN31@RunningSki:

; 557  : 	case AT_SKILL_CALLMON2:	return this->SkillMonsterCall(lpObj->m_Index,32,lpObj->X-1,lpObj->Y+1);

  001be	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  001c5	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  001cc	8b 16		 mov	 edx, DWORD PTR [esi]
  001ce	40		 inc	 eax
  001cf	50		 push	 eax
  001d0	49		 dec	 ecx
  001d1	51		 push	 ecx
  001d2	6a 20		 push	 32			; 00000020H
  001d4	52		 push	 edx
  001d5	8b cf		 mov	 ecx, edi
  001d7	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  001dc	5f		 pop	 edi
  001dd	5e		 pop	 esi
  001de	5b		 pop	 ebx

; 600  : }

  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c2 10 00	 ret	 16			; 00000010H
$LN30@RunningSki:

; 558  : 	case AT_SKILL_CALLMON3:	return this->SkillMonsterCall(lpObj->m_Index,21,lpObj->X-1,lpObj->Y+1);

  001e5	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  001ec	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  001f3	8b 16		 mov	 edx, DWORD PTR [esi]
  001f5	40		 inc	 eax
  001f6	50		 push	 eax
  001f7	49		 dec	 ecx
  001f8	51		 push	 ecx
  001f9	6a 15		 push	 21			; 00000015H
  001fb	52		 push	 edx
  001fc	8b cf		 mov	 ecx, edi
  001fe	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  00203	5f		 pop	 edi
  00204	5e		 pop	 esi
  00205	5b		 pop	 ebx

; 600  : }

  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c2 10 00	 ret	 16			; 00000010H
$LN29@RunningSki:

; 559  : 	case AT_SKILL_CALLMON4:	return this->SkillMonsterCall(lpObj->m_Index,20,lpObj->X-1,lpObj->Y+1);

  0020c	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  00213	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  0021a	8b 16		 mov	 edx, DWORD PTR [esi]
  0021c	40		 inc	 eax
  0021d	50		 push	 eax
  0021e	49		 dec	 ecx
  0021f	51		 push	 ecx
  00220	6a 14		 push	 20			; 00000014H
  00222	52		 push	 edx
  00223	8b cf		 mov	 ecx, edi
  00225	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  0022a	5f		 pop	 edi
  0022b	5e		 pop	 esi
  0022c	5b		 pop	 ebx

; 600  : }

  0022d	8b e5		 mov	 esp, ebp
  0022f	5d		 pop	 ebp
  00230	c2 10 00	 ret	 16			; 00000010H
$LN28@RunningSki:

; 560  : 	case AT_SKILL_CALLMON5:	return this->SkillMonsterCall(lpObj->m_Index,10,lpObj->X-1,lpObj->Y+1);

  00233	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  0023a	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  00241	8b 16		 mov	 edx, DWORD PTR [esi]
  00243	40		 inc	 eax
  00244	50		 push	 eax
  00245	49		 dec	 ecx
  00246	51		 push	 ecx
  00247	6a 0a		 push	 10			; 0000000aH
  00249	52		 push	 edx
  0024a	8b cf		 mov	 ecx, edi
  0024c	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  00251	5f		 pop	 edi
  00252	5e		 pop	 esi
  00253	5b		 pop	 ebx

; 600  : }

  00254	8b e5		 mov	 esp, ebp
  00256	5d		 pop	 ebp
  00257	c2 10 00	 ret	 16			; 00000010H
$LN27@RunningSki:

; 561  : 	case AT_SKILL_CALLMON6:	return this->SkillMonsterCall(lpObj->m_Index,150,lpObj->X-1,lpObj->Y+1);

  0025a	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  00261	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  00268	8b 16		 mov	 edx, DWORD PTR [esi]
  0026a	40		 inc	 eax
  0026b	50		 push	 eax
  0026c	49		 dec	 ecx
  0026d	51		 push	 ecx
  0026e	68 96 00 00 00	 push	 150			; 00000096H
  00273	52		 push	 edx
  00274	8b cf		 mov	 ecx, edi
  00276	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  0027b	5f		 pop	 edi
  0027c	5e		 pop	 esi
  0027d	5b		 pop	 ebx

; 600  : }

  0027e	8b e5		 mov	 esp, ebp
  00280	5d		 pop	 ebp
  00281	c2 10 00	 ret	 16			; 00000010H
$LN26@RunningSki:

; 562  : 	case AT_SKILL_CALLMON7:	return this->SkillMonsterCall(lpObj->m_Index,151,lpObj->X-1,lpObj->Y+1);

  00284	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  0028b	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  00292	8b 16		 mov	 edx, DWORD PTR [esi]
  00294	40		 inc	 eax
  00295	50		 push	 eax
  00296	49		 dec	 ecx
  00297	51		 push	 ecx
  00298	68 97 00 00 00	 push	 151			; 00000097H
  0029d	52		 push	 edx
  0029e	8b cf		 mov	 ecx, edi
  002a0	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  002a5	5f		 pop	 edi
  002a6	5e		 pop	 esi
  002a7	5b		 pop	 ebx

; 600  : }

  002a8	8b e5		 mov	 esp, ebp
  002aa	5d		 pop	 ebp
  002ab	c2 10 00	 ret	 16			; 00000010H
$LN25@RunningSki:

; 563  : 
; 564  : 	case AT_SKILL_EXPHELL:	return this->SkillHellFire2(lpObj->m_Index,aTargetIndex,lpMagic);

  002ae	53		 push	 ebx
  002af	50		 push	 eax
  002b0	8b 06		 mov	 eax, DWORD PTR [esi]
  002b2	50		 push	 eax
  002b3	8b cf		 mov	 ecx, edi
  002b5	e8 00 00 00 00	 call	 ?SkillHellFire2@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillHellFire2
  002ba	5f		 pop	 edi
  002bb	5e		 pop	 esi
  002bc	5b		 pop	 ebx

; 600  : }

  002bd	8b e5		 mov	 esp, ebp
  002bf	5d		 pop	 ebp
  002c0	c2 10 00	 ret	 16			; 00000010H
$LN24@RunningSki:

; 565  : 	case AT_SKILL_STRIKE:	return this->SkillKnightBlow(lpObj->m_Index,aTargetIndex,lpMagic,bCombo);

  002c3	8b 4d 14	 mov	 ecx, DWORD PTR _bCombo$[ebp]
  002c6	8b 16		 mov	 edx, DWORD PTR [esi]
  002c8	51		 push	 ecx
  002c9	53		 push	 ebx
  002ca	50		 push	 eax
  002cb	52		 push	 edx
  002cc	8b cf		 mov	 ecx, edi
  002ce	e8 00 00 00 00	 call	 ?SkillKnightBlow@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::SkillKnightBlow
  002d3	5f		 pop	 edi
  002d4	5e		 pop	 esi
  002d5	5b		 pop	 ebx

; 600  : }

  002d6	8b e5		 mov	 esp, ebp
  002d8	5d		 pop	 ebp
  002d9	c2 10 00	 ret	 16			; 00000010H
$LN23@RunningSki:

; 566  : 
; 567  : 	case AT_SKILL_SPEAR:	return this->SkillSpear(lpObj->m_Index,aTargetIndex,lpMagic);

  002dc	53		 push	 ebx
  002dd	50		 push	 eax
  002de	8b 06		 mov	 eax, DWORD PTR [esi]
  002e0	50		 push	 eax
  002e1	8b cf		 mov	 ecx, edi
  002e3	e8 00 00 00 00	 call	 ?SkillSpear@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillSpear
  002e8	5f		 pop	 edi
  002e9	5e		 pop	 esi
  002ea	5b		 pop	 ebx

; 600  : }

  002eb	8b e5		 mov	 esp, ebp
  002ed	5d		 pop	 ebp
  002ee	c2 10 00	 ret	 16			; 00000010H
$LN22@RunningSki:

; 568  : 	case AT_SKILL_FIREBURST:	return this->SkillFireBurst(lpObj->m_Index,aTargetIndex,lpMagic);

  002f1	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002f3	53		 push	 ebx
  002f4	50		 push	 eax
  002f5	51		 push	 ecx
  002f6	8b cf		 mov	 ecx, edi
  002f8	e8 00 00 00 00	 call	 ?SkillFireBurst@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillFireBurst
  002fd	5f		 pop	 edi
  002fe	5e		 pop	 esi
  002ff	5b		 pop	 ebx

; 600  : }

  00300	8b e5		 mov	 esp, ebp
  00302	5d		 pop	 ebp
  00303	c2 10 00	 ret	 16			; 00000010H
$LN21@RunningSki:

; 569  : 	case AT_SKILL_DARKHORSE_ATTACK:	return this->SkillDarkHorseAttack(lpObj->m_Index,aTargetIndex,lpMagic);

  00306	8b 16		 mov	 edx, DWORD PTR [esi]
  00308	53		 push	 ebx
  00309	50		 push	 eax
  0030a	52		 push	 edx
  0030b	8b cf		 mov	 ecx, edi
  0030d	e8 00 00 00 00	 call	 ?SkillDarkHorseAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDarkHorseAttack
  00312	5f		 pop	 edi
  00313	5e		 pop	 esi
  00314	5b		 pop	 ebx

; 600  : }

  00315	8b e5		 mov	 esp, ebp
  00317	5d		 pop	 ebp
  00318	c2 10 00	 ret	 16			; 00000010H
$LN20@RunningSki:

; 570  : 	case AT_SKILL_RECALL_PARTY:	this->SkillRecallParty(aIndex,lpMagic->m_Level);break;

  0031b	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  0031f	50		 push	 eax
  00320	51		 push	 ecx
  00321	8b cf		 mov	 ecx, edi
  00323	e8 00 00 00 00	 call	 ?SkillRecallParty@CObjUseSkill@@QAEXHH@Z ; CObjUseSkill::SkillRecallParty
  00328	5f		 pop	 edi
  00329	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  0032a	b8 01 00 00 00	 mov	 eax, 1
  0032f	5b		 pop	 ebx

; 600  : }

  00330	8b e5		 mov	 esp, ebp
  00332	5d		 pop	 ebp
  00333	c2 10 00	 ret	 16			; 00000010H
$LN19@RunningSki:

; 571  : 	case AT_SKILL_ADD_CRITICALDAMAGE:	this->SkillAddCriticalDamage(aIndex,lpMagic->m_Level);break;

  00336	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  0033a	52		 push	 edx
  0033b	51		 push	 ecx
  0033c	8b cf		 mov	 ecx, edi
  0033e	e8 00 00 00 00	 call	 ?SkillAddCriticalDamage@CObjUseSkill@@QAEXHH@Z ; CObjUseSkill::SkillAddCriticalDamage
  00343	5f		 pop	 edi
  00344	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  00345	b8 01 00 00 00	 mov	 eax, 1
  0034a	5b		 pop	 ebx

; 600  : }

  0034b	8b e5		 mov	 esp, ebp
  0034d	5d		 pop	 ebp
  0034e	c2 10 00	 ret	 16			; 00000010H
$LN18@RunningSki:

; 572  : 
; 573  : 	case AT_SKILL_DEFENSEDOWN:	this->MaGumSkillDefenseDown(lpObj->m_Index,aTargetIndex,1);break;

  00351	6a 01		 push	 1
  00353	50		 push	 eax
  00354	8b 06		 mov	 eax, DWORD PTR [esi]
  00356	50		 push	 eax
  00357	8b cf		 mov	 ecx, edi
  00359	e8 00 00 00 00	 call	 ?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHH@Z ; CObjUseSkill::MaGumSkillDefenseDown
  0035e	5f		 pop	 edi
  0035f	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  00360	b8 01 00 00 00	 mov	 eax, 1
  00365	5b		 pop	 ebx

; 600  : }

  00366	8b e5		 mov	 esp, ebp
  00368	5d		 pop	 ebp
  00369	c2 10 00	 ret	 16			; 00000010H
$LN17@RunningSki:

; 574  : 
; 575  : 	case AT_SKILL_SUMMON:	this->SkillSummon(lpObj->m_Index,aTargetIndex,lpMagic);break;

  0036c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0036e	53		 push	 ebx
  0036f	50		 push	 eax
  00370	51		 push	 ecx
  00371	8b cf		 mov	 ecx, edi
  00373	e8 00 00 00 00	 call	 ?SkillSummon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillSummon
  00378	5f		 pop	 edi
  00379	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  0037a	b8 01 00 00 00	 mov	 eax, 1
  0037f	5b		 pop	 ebx

; 600  : }

  00380	8b e5		 mov	 esp, ebp
  00382	5d		 pop	 ebp
  00383	c2 10 00	 ret	 16			; 00000010H
$LN16@RunningSki:

; 576  : 	case AT_SKILL_IMMUNE_TO_MAGIC:	this->SkillImmuneToMagic(lpObj->m_Index,lpMagic);break;

  00386	8b 16		 mov	 edx, DWORD PTR [esi]
  00388	53		 push	 ebx
  00389	52		 push	 edx
  0038a	8b cf		 mov	 ecx, edi
  0038c	e8 00 00 00 00	 call	 ?SkillImmuneToMagic@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillImmuneToMagic
  00391	5f		 pop	 edi
  00392	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  00393	b8 01 00 00 00	 mov	 eax, 1
  00398	5b		 pop	 ebx

; 600  : }

  00399	8b e5		 mov	 esp, ebp
  0039b	5d		 pop	 ebp
  0039c	c2 10 00	 ret	 16			; 00000010H
$LN15@RunningSki:

; 577  : 	case AT_SKILL_IMMUNE_TO_HARM:	this->SkillImmuneToHarm(lpObj->m_Index,lpMagic);break;

  0039f	8b 06		 mov	 eax, DWORD PTR [esi]
  003a1	53		 push	 ebx
  003a2	50		 push	 eax
  003a3	8b cf		 mov	 ecx, edi
  003a5	e8 00 00 00 00	 call	 ?SkillImmuneToHarm@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillImmuneToHarm
  003aa	5f		 pop	 edi
  003ab	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  003ac	b8 01 00 00 00	 mov	 eax, 1
  003b1	5b		 pop	 ebx

; 600  : }

  003b2	8b e5		 mov	 esp, ebp
  003b4	5d		 pop	 ebp
  003b5	c2 10 00	 ret	 16			; 00000010H
$LN14@RunningSki:

; 578  : 
; 579  : 	case AT_SKILL_RUSH:	this->SkillKnightRush(lpObj->m_Index,aTargetIndex,lpMagic);break;

  003b8	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003ba	53		 push	 ebx
  003bb	50		 push	 eax
  003bc	51		 push	 ecx
  003bd	8b cf		 mov	 ecx, edi
  003bf	e8 00 00 00 00	 call	 ?SkillKnightRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillKnightRush
  003c4	5f		 pop	 edi
  003c5	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  003c6	b8 01 00 00 00	 mov	 eax, 1
  003cb	5b		 pop	 ebx

; 600  : }

  003cc	8b e5		 mov	 esp, ebp
  003ce	5d		 pop	 ebp
  003cf	c2 10 00	 ret	 16			; 00000010H
$LN13@RunningSki:

; 580  : 	case AT_SKILL_JAVALIN:	this->SkillWizardJavalin(lpObj->m_Index,aTargetIndex,lpMagic);break;

  003d2	8b 16		 mov	 edx, DWORD PTR [esi]
  003d4	53		 push	 ebx
  003d5	50		 push	 eax
  003d6	52		 push	 edx
  003d7	8b cf		 mov	 ecx, edi
  003d9	e8 00 00 00 00	 call	 ?SkillWizardJavalin@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillWizardJavalin
  003de	5f		 pop	 edi
  003df	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  003e0	b8 01 00 00 00	 mov	 eax, 1
  003e5	5b		 pop	 ebx

; 600  : }

  003e6	8b e5		 mov	 esp, ebp
  003e8	5d		 pop	 ebp
  003e9	c2 10 00	 ret	 16			; 00000010H
$LN12@RunningSki:

; 581  : 	case AT_SKILL_DEEPIMPACT:	this->SkillElfRush(lpObj->m_Index,aTargetIndex,lpMagic);break;

  003ec	53		 push	 ebx
  003ed	50		 push	 eax
  003ee	8b 06		 mov	 eax, DWORD PTR [esi]
  003f0	50		 push	 eax
  003f1	8b cf		 mov	 ecx, edi
  003f3	e8 00 00 00 00	 call	 ?SkillElfRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillElfRush
  003f8	5f		 pop	 edi
  003f9	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  003fa	b8 01 00 00 00	 mov	 eax, 1
  003ff	5b		 pop	 ebx

; 600  : }

  00400	8b e5		 mov	 esp, ebp
  00402	5d		 pop	 ebp
  00403	c2 10 00	 ret	 16			; 00000010H
$LN11@RunningSki:

; 582  : 	case AT_SKILL_ONE_FLASH:	this->SkillMagumOneFlash(lpObj->m_Index,aTargetIndex,lpMagic);break;

  00406	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00408	53		 push	 ebx
  00409	50		 push	 eax
  0040a	51		 push	 ecx
  0040b	8b cf		 mov	 ecx, edi
  0040d	e8 00 00 00 00	 call	 ?SkillMagumOneFlash@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillMagumOneFlash
  00412	5f		 pop	 edi
  00413	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  00414	b8 01 00 00 00	 mov	 eax, 1
  00419	5b		 pop	 ebx

; 600  : }

  0041a	8b e5		 mov	 esp, ebp
  0041c	5d		 pop	 ebp
  0041d	c2 10 00	 ret	 16			; 00000010H
$LN10@RunningSki:

; 583  : 	case AT_SKILL_DEATH_CANNON:	this->SkillMagumDeathCannon(lpObj->m_Index,aTargetIndex,lpMagic);break;

  00420	8b 16		 mov	 edx, DWORD PTR [esi]
  00422	53		 push	 ebx
  00423	50		 push	 eax
  00424	52		 push	 edx
  00425	8b cf		 mov	 ecx, edi
  00427	e8 00 00 00 00	 call	 ?SkillMagumDeathCannon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillMagumDeathCannon
  0042c	5f		 pop	 edi
  0042d	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  0042e	b8 01 00 00 00	 mov	 eax, 1
  00433	5b		 pop	 ebx

; 600  : }

  00434	8b e5		 mov	 esp, ebp
  00436	5d		 pop	 ebp
  00437	c2 10 00	 ret	 16			; 00000010H
$LN9@RunningSki:

; 584  : 	case AT_SKILL_SPACE_SPLIT:	this->SkillDarklordSpaceSplit(lpObj->m_Index,aTargetIndex,lpMagic);break;

  0043a	53		 push	 ebx
  0043b	50		 push	 eax
  0043c	8b 06		 mov	 eax, DWORD PTR [esi]
  0043e	50		 push	 eax
  0043f	8b cf		 mov	 ecx, edi
  00441	e8 00 00 00 00	 call	 ?SkillDarklordSpaceSplit@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDarklordSpaceSplit
  00446	5f		 pop	 edi
  00447	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  00448	b8 01 00 00 00	 mov	 eax, 1
  0044d	5b		 pop	 ebx

; 600  : }

  0044e	8b e5		 mov	 esp, ebp
  00450	5d		 pop	 ebp
  00451	c2 10 00	 ret	 16			; 00000010H
$LN8@RunningSki:

; 585  : 
; 586  : 	case AT_SKILL_BRAND_OF_SKILL:	this->SkillBrandOfSkill(aIndex,aTargetIndex,lpMagic);break;

  00454	53		 push	 ebx
  00455	50		 push	 eax
  00456	51		 push	 ecx
  00457	8b cf		 mov	 ecx, edi
  00459	e8 00 00 00 00	 call	 ?SkillBrandOfSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillBrandOfSkill
  0045e	5f		 pop	 edi
  0045f	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  00460	b8 01 00 00 00	 mov	 eax, 1
  00465	5b		 pop	 ebx

; 600  : }

  00466	8b e5		 mov	 esp, ebp
  00468	5d		 pop	 ebp
  00469	c2 10 00	 ret	 16			; 00000010H
$LN7@RunningSki:

; 587  : 
; 588  : 	case AT_SKILL_REMOVAL_STUN:	this->SkillRemoveStun(aIndex,aTargetIndex,lpMagic);break;

  0046c	53		 push	 ebx
  0046d	50		 push	 eax
  0046e	51		 push	 ecx
  0046f	8b cf		 mov	 ecx, edi
  00471	e8 00 00 00 00	 call	 ?SkillRemoveStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRemoveStun
  00476	5f		 pop	 edi
  00477	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  00478	b8 01 00 00 00	 mov	 eax, 1
  0047d	5b		 pop	 ebx

; 600  : }

  0047e	8b e5		 mov	 esp, ebp
  00480	5d		 pop	 ebp
  00481	c2 10 00	 ret	 16			; 00000010H
$LN6@RunningSki:

; 589  : 	case AT_SKILL_ADD_MANA:	this->SkillAddMana(aIndex,aTargetIndex,lpMagic);break;

  00484	53		 push	 ebx
  00485	50		 push	 eax
  00486	51		 push	 ecx
  00487	8b cf		 mov	 ecx, edi
  00489	e8 00 00 00 00	 call	 ?SkillAddMana@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillAddMana
  0048e	5f		 pop	 edi
  0048f	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  00490	b8 01 00 00 00	 mov	 eax, 1
  00495	5b		 pop	 ebx

; 600  : }

  00496	8b e5		 mov	 esp, ebp
  00498	5d		 pop	 ebp
  00499	c2 10 00	 ret	 16			; 00000010H
$LN5@RunningSki:

; 590  : 	case AT_SKILL_INVISIBLE:	this->SkillCloaking(aIndex,aTargetIndex,lpMagic);break;

  0049c	53		 push	 ebx
  0049d	50		 push	 eax
  0049e	51		 push	 ecx
  0049f	8b cf		 mov	 ecx, edi
  004a1	e8 00 00 00 00	 call	 ?SkillCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillCloaking
  004a6	5f		 pop	 edi
  004a7	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  004a8	b8 01 00 00 00	 mov	 eax, 1
  004ad	5b		 pop	 ebx

; 600  : }

  004ae	8b e5		 mov	 esp, ebp
  004b0	5d		 pop	 ebp
  004b1	c2 10 00	 ret	 16			; 00000010H
$LN4@RunningSki:

; 591  : 	case AT_SKILL_REMOVAL_INVISIBLE:	this->SkillRemoveCloaking(aIndex,aTargetIndex,lpMagic);break;

  004b4	53		 push	 ebx
  004b5	50		 push	 eax
  004b6	51		 push	 ecx
  004b7	8b cf		 mov	 ecx, edi
  004b9	e8 00 00 00 00	 call	 ?SkillRemoveCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRemoveCloaking
  004be	5f		 pop	 edi
  004bf	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  004c0	b8 01 00 00 00	 mov	 eax, 1
  004c5	5b		 pop	 ebx

; 600  : }

  004c6	8b e5		 mov	 esp, ebp
  004c8	5d		 pop	 ebp
  004c9	c2 10 00	 ret	 16			; 00000010H
$LN3@RunningSki:

; 592  : 	case AT_SKILL_REMOVAL_MAGIC:	this->SkillRemoveMagic(aIndex,aTargetIndex,lpMagic);break;

  004cc	53		 push	 ebx
  004cd	50		 push	 eax
  004ce	51		 push	 ecx
  004cf	8b cf		 mov	 ecx, edi
  004d1	e8 00 00 00 00	 call	 ?SkillRemoveMagic@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRemoveMagic
  004d6	5f		 pop	 edi
  004d7	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  004d8	b8 01 00 00 00	 mov	 eax, 1
  004dd	5b		 pop	 ebx

; 600  : }

  004de	8b e5		 mov	 esp, ebp
  004e0	5d		 pop	 ebp
  004e1	c2 10 00	 ret	 16			; 00000010H
$LN2@RunningSki:

; 593  : 
; 594  : 	case AT_SKILL_INFINITY_ARROW:	this->SkillInfinityArrow(aIndex,aTargetIndex,lpMagic);break;

  004e4	53		 push	 ebx
  004e5	50		 push	 eax
  004e6	51		 push	 ecx
  004e7	8b cf		 mov	 ecx, edi
  004e9	e8 00 00 00 00	 call	 ?SkillInfinityArrow@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillInfinityArrow
  004ee	5f		 pop	 edi
  004ef	5e		 pop	 esi

; 597  : 	}
; 598  : 
; 599  : 	return true;

  004f0	b8 01 00 00 00	 mov	 eax, 1
  004f5	5b		 pop	 ebx

; 600  : }

  004f6	8b e5		 mov	 esp, ebp
  004f8	5d		 pop	 ebp
  004f9	c2 10 00	 ret	 16			; 00000010H
$LN1@RunningSki:

; 595  : 
; 596  : 	default:	gObjAttack(lpObj,lpTargetObj,lpMagic,1,0,0,0);break;

  004fc	8b 4d fc	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  004ff	6a 00		 push	 0
  00501	6a 00		 push	 0
  00503	6a 00		 push	 0
  00505	6a 01		 push	 1
  00507	53		 push	 ebx
  00508	51		 push	 ecx
$LN50@RunningSki:
  00509	56		 push	 esi
  0050a	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  0050f	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN43@RunningSki:

; 597  : 	}
; 598  : 
; 599  : 	return true;

  00512	5f		 pop	 edi
  00513	5e		 pop	 esi
  00514	b8 01 00 00 00	 mov	 eax, 1
  00519	5b		 pop	 ebx

; 600  : }

  0051a	8b e5		 mov	 esp, ebp
  0051c	5d		 pop	 ebp
  0051d	c2 10 00	 ret	 16			; 00000010H
$LN51@RunningSki:
  00520	00 00 00 00	 DD	 $LN38@RunningSki
  00524	00 00 00 00	 DD	 $LN36@RunningSki
  00528	00 00 00 00	 DD	 $LN42@RunningSki
  0052c	00 00 00 00	 DD	 $LN37@RunningSki
  00530	00 00 00 00	 DD	 $LN34@RunningSki
  00534	00 00 00 00	 DD	 $LN33@RunningSki
  00538	00 00 00 00	 DD	 $LN32@RunningSki
  0053c	00 00 00 00	 DD	 $LN31@RunningSki
  00540	00 00 00 00	 DD	 $LN30@RunningSki
  00544	00 00 00 00	 DD	 $LN29@RunningSki
  00548	00 00 00 00	 DD	 $LN28@RunningSki
  0054c	00 00 00 00	 DD	 $LN27@RunningSki
  00550	00 00 00 00	 DD	 $LN26@RunningSki
  00554	00 00 00 00	 DD	 $LN25@RunningSki
  00558	00 00 00 00	 DD	 $LN24@RunningSki
  0055c	00 00 00 00	 DD	 $LN14@RunningSki
  00560	00 00 00 00	 DD	 $LN13@RunningSki
  00564	00 00 00 00	 DD	 $LN12@RunningSki
  00568	00 00 00 00	 DD	 $LN35@RunningSki
  0056c	00 00 00 00	 DD	 $LN18@RunningSki
  00570	00 00 00 00	 DD	 $LN11@RunningSki
  00574	00 00 00 00	 DD	 $LN23@RunningSki
  00578	00 00 00 00	 DD	 $LN22@RunningSki
  0057c	00 00 00 00	 DD	 $LN21@RunningSki
  00580	00 00 00 00	 DD	 $LN20@RunningSki
  00584	00 00 00 00	 DD	 $LN19@RunningSki
  00588	00 00 00 00	 DD	 $LN7@RunningSki
  0058c	00 00 00 00	 DD	 $LN6@RunningSki
  00590	00 00 00 00	 DD	 $LN5@RunningSki
  00594	00 00 00 00	 DD	 $LN4@RunningSki
  00598	00 00 00 00	 DD	 $LN3@RunningSki
  0059c	00 00 00 00	 DD	 $LN10@RunningSki
  005a0	00 00 00 00	 DD	 $LN9@RunningSki
  005a4	00 00 00 00	 DD	 $LN8@RunningSki
  005a8	00 00 00 00	 DD	 $LN2@RunningSki
  005ac	00 00 00 00	 DD	 $LN17@RunningSki
  005b0	00 00 00 00	 DD	 $LN16@RunningSki
  005b4	00 00 00 00	 DD	 $LN15@RunningSki
  005b8	00 00 00 00	 DD	 $LN1@RunningSki
$LN48@RunningSki:
  005bc	00		 DB	 0
  005bd	00		 DB	 0
  005be	00		 DB	 0
  005bf	00		 DB	 0
  005c0	00		 DB	 0
  005c1	26		 DB	 38			; 00000026H
  005c2	00		 DB	 0
  005c3	26		 DB	 38			; 00000026H
  005c4	26		 DB	 38			; 00000026H
  005c5	26		 DB	 38			; 00000026H
  005c6	26		 DB	 38			; 00000026H
  005c7	26		 DB	 38			; 00000026H
  005c8	26		 DB	 38			; 00000026H
  005c9	26		 DB	 38			; 00000026H
  005ca	26		 DB	 38			; 00000026H
  005cb	01		 DB	 1
  005cc	00		 DB	 0
  005cd	02		 DB	 2
  005ce	00		 DB	 0
  005cf	00		 DB	 0
  005d0	00		 DB	 0
  005d1	00		 DB	 0
  005d2	00		 DB	 0
  005d3	00		 DB	 0
  005d4	00		 DB	 0
  005d5	03		 DB	 3
  005d6	04		 DB	 4
  005d7	05		 DB	 5
  005d8	26		 DB	 38			; 00000026H
  005d9	06		 DB	 6
  005da	07		 DB	 7
  005db	08		 DB	 8
  005dc	09		 DB	 9
  005dd	0a		 DB	 10			; 0000000aH
  005de	0b		 DB	 11			; 0000000bH
  005df	0c		 DB	 12			; 0000000cH
  005e0	26		 DB	 38			; 00000026H
  005e1	26		 DB	 38			; 00000026H
  005e2	26		 DB	 38			; 00000026H
  005e3	0d		 DB	 13			; 0000000dH
  005e4	00		 DB	 0
  005e5	00		 DB	 0
  005e6	0e		 DB	 14			; 0000000eH
  005e7	0f		 DB	 15			; 0000000fH
  005e8	10		 DB	 16			; 00000010H
  005e9	11		 DB	 17			; 00000011H
  005ea	00		 DB	 0
  005eb	12		 DB	 18			; 00000012H
  005ec	26		 DB	 38			; 00000026H
  005ed	26		 DB	 38			; 00000026H
  005ee	26		 DB	 38			; 00000026H
  005ef	00		 DB	 0
  005f0	26		 DB	 38			; 00000026H
  005f1	26		 DB	 38			; 00000026H
  005f2	13		 DB	 19			; 00000013H
  005f3	00		 DB	 0
  005f4	14		 DB	 20			; 00000014H
  005f5	26		 DB	 38			; 00000026H
  005f6	26		 DB	 38			; 00000026H
  005f7	15		 DB	 21			; 00000015H
  005f8	16		 DB	 22			; 00000016H
  005f9	17		 DB	 23			; 00000017H
  005fa	18		 DB	 24			; 00000018H
  005fb	19		 DB	 25			; 00000019H
  005fc	26		 DB	 38			; 00000026H
  005fd	26		 DB	 38			; 00000026H
  005fe	26		 DB	 38			; 00000026H
  005ff	1a		 DB	 26			; 0000001aH
  00600	1b		 DB	 27			; 0000001bH
  00601	1c		 DB	 28			; 0000001cH
  00602	1d		 DB	 29			; 0000001dH
  00603	1e		 DB	 30			; 0000001eH
  00604	1f		 DB	 31			; 0000001fH
  00605	20		 DB	 32			; 00000020H
  00606	21		 DB	 33			; 00000021H
  00607	26		 DB	 38			; 00000026H
  00608	22		 DB	 34			; 00000022H
  00609	26		 DB	 38			; 00000026H
  0060a	26		 DB	 38			; 00000026H
  0060b	26		 DB	 38			; 00000026H
  0060c	26		 DB	 38			; 00000026H
  0060d	26		 DB	 38			; 00000026H
  0060e	26		 DB	 38			; 00000026H
  0060f	26		 DB	 38			; 00000026H
  00610	26		 DB	 38			; 00000026H
  00611	26		 DB	 38			; 00000026H
  00612	26		 DB	 38			; 00000026H
  00613	26		 DB	 38			; 00000026H
  00614	26		 DB	 38			; 00000026H
  00615	26		 DB	 38			; 00000026H
  00616	26		 DB	 38			; 00000026H
  00617	26		 DB	 38			; 00000026H
  00618	26		 DB	 38			; 00000026H
  00619	26		 DB	 38			; 00000026H
  0061a	26		 DB	 38			; 00000026H
  0061b	26		 DB	 38			; 00000026H
  0061c	26		 DB	 38			; 00000026H
  0061d	26		 DB	 38			; 00000026H
  0061e	26		 DB	 38			; 00000026H
  0061f	26		 DB	 38			; 00000026H
  00620	26		 DB	 38			; 00000026H
  00621	26		 DB	 38			; 00000026H
  00622	26		 DB	 38			; 00000026H
  00623	26		 DB	 38			; 00000026H
  00624	26		 DB	 38			; 00000026H
  00625	26		 DB	 38			; 00000026H
  00626	26		 DB	 38			; 00000026H
  00627	26		 DB	 38			; 00000026H
  00628	26		 DB	 38			; 00000026H
  00629	26		 DB	 38			; 00000026H
  0062a	26		 DB	 38			; 00000026H
  0062b	26		 DB	 38			; 00000026H
  0062c	26		 DB	 38			; 00000026H
  0062d	26		 DB	 38			; 00000026H
  0062e	26		 DB	 38			; 00000026H
  0062f	26		 DB	 38			; 00000026H
  00630	26		 DB	 38			; 00000026H
  00631	26		 DB	 38			; 00000026H
  00632	26		 DB	 38			; 00000026H
  00633	26		 DB	 38			; 00000026H
  00634	26		 DB	 38			; 00000026H
  00635	26		 DB	 38			; 00000026H
  00636	26		 DB	 38			; 00000026H
  00637	26		 DB	 38			; 00000026H
  00638	26		 DB	 38			; 00000026H
  00639	26		 DB	 38			; 00000026H
  0063a	26		 DB	 38			; 00000026H
  0063b	26		 DB	 38			; 00000026H
  0063c	26		 DB	 38			; 00000026H
  0063d	26		 DB	 38			; 00000026H
  0063e	26		 DB	 38			; 00000026H
  0063f	26		 DB	 38			; 00000026H
  00640	26		 DB	 38			; 00000026H
  00641	26		 DB	 38			; 00000026H
  00642	26		 DB	 38			; 00000026H
  00643	26		 DB	 38			; 00000026H
  00644	26		 DB	 38			; 00000026H
  00645	26		 DB	 38			; 00000026H
  00646	26		 DB	 38			; 00000026H
  00647	26		 DB	 38			; 00000026H
  00648	26		 DB	 38			; 00000026H
  00649	26		 DB	 38			; 00000026H
  0064a	26		 DB	 38			; 00000026H
  0064b	26		 DB	 38			; 00000026H
  0064c	26		 DB	 38			; 00000026H
  0064d	26		 DB	 38			; 00000026H
  0064e	26		 DB	 38			; 00000026H
  0064f	26		 DB	 38			; 00000026H
  00650	26		 DB	 38			; 00000026H
  00651	26		 DB	 38			; 00000026H
  00652	26		 DB	 38			; 00000026H
  00653	26		 DB	 38			; 00000026H
  00654	26		 DB	 38			; 00000026H
  00655	26		 DB	 38			; 00000026H
  00656	26		 DB	 38			; 00000026H
  00657	26		 DB	 38			; 00000026H
  00658	26		 DB	 38			; 00000026H
  00659	26		 DB	 38			; 00000026H
  0065a	26		 DB	 38			; 00000026H
  0065b	26		 DB	 38			; 00000026H
  0065c	26		 DB	 38			; 00000026H
  0065d	26		 DB	 38			; 00000026H
  0065e	26		 DB	 38			; 00000026H
  0065f	26		 DB	 38			; 00000026H
  00660	26		 DB	 38			; 00000026H
  00661	26		 DB	 38			; 00000026H
  00662	26		 DB	 38			; 00000026H
  00663	26		 DB	 38			; 00000026H
  00664	26		 DB	 38			; 00000026H
  00665	26		 DB	 38			; 00000026H
  00666	26		 DB	 38			; 00000026H
  00667	26		 DB	 38			; 00000026H
  00668	26		 DB	 38			; 00000026H
  00669	26		 DB	 38			; 00000026H
  0066a	26		 DB	 38			; 00000026H
  0066b	26		 DB	 38			; 00000026H
  0066c	26		 DB	 38			; 00000026H
  0066d	26		 DB	 38			; 00000026H
  0066e	26		 DB	 38			; 00000026H
  0066f	26		 DB	 38			; 00000026H
  00670	26		 DB	 38			; 00000026H
  00671	26		 DB	 38			; 00000026H
  00672	26		 DB	 38			; 00000026H
  00673	26		 DB	 38			; 00000026H
  00674	26		 DB	 38			; 00000026H
  00675	26		 DB	 38			; 00000026H
  00676	26		 DB	 38			; 00000026H
  00677	26		 DB	 38			; 00000026H
  00678	26		 DB	 38			; 00000026H
  00679	26		 DB	 38			; 00000026H
  0067a	26		 DB	 38			; 00000026H
  0067b	26		 DB	 38			; 00000026H
  0067c	26		 DB	 38			; 00000026H
  0067d	26		 DB	 38			; 00000026H
  0067e	26		 DB	 38			; 00000026H
  0067f	26		 DB	 38			; 00000026H
  00680	26		 DB	 38			; 00000026H
  00681	26		 DB	 38			; 00000026H
  00682	26		 DB	 38			; 00000026H
  00683	23		 DB	 35			; 00000023H
  00684	24		 DB	 36			; 00000024H
  00685	25		 DB	 37			; 00000025H
?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ENDP ; CObjUseSkill::RunningSkill
_TEXT	ENDS
PUBLIC	?SkillDeathPoison@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillDeathPoison
; Function compile flags: /Ogtp
;	COMDAT ?SkillDeathPoison@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_DuelIndex$ = -4					; size = 4
tv213 = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_dir$ = 24						; size = 1
_TargetPos$ = 28					; size = 1
_aTargetIndex$ = 32					; size = 4
?SkillDeathPoison@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z PROC ; CObjUseSkill::SkillDeathPoison, COMDAT
; _this$ = ecx

; 1368 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1369 : 	LPOBJ lpObj = &gObj[aIndex];

  00009	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000c	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00012	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1370 : 	int tObjNum;
; 1371 : 	int count = 0;
; 1372 : 	int FirstHit = 0;
; 1373 : 	int HitCount = 0;
; 1374 : 	int bAttack;
; 1375 : 	int DuelIndex = lpObj->m_iDuelUser;

  00018	8b 87 1c 0d 00
	00		 mov	 eax, DWORD PTR [edi+3356]
  0001e	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00021	89 45 fc	 mov	 DWORD PTR _DuelIndex$[ebp], eax
  00024	8d 9f 16 07 00
	00		 lea	 ebx, DWORD PTR [edi+1814]
  0002a	c7 45 08 4b 00
	00 00		 mov	 DWORD PTR tv213[ebp], 75 ; 0000004bH
$LL19@SkillDeath:

; 1376 : 	int EnableAttack;
; 1377 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];
; 1378 : 
; 1379 : 
; 1380 : 	while ( true )
; 1381 : 	{
; 1382 : 		if(lpObj->VpPlayer2[count].state != 0)

  00031	80 7b fe 00	 cmp	 BYTE PTR [ebx-2], 0
  00035	0f 84 c8 00 00
	00		 je	 $LN27@SkillDeath

; 1383 : 		{
; 1384 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0003b	0f bf 33	 movsx	 esi, WORD PTR [ebx]

; 1385 : 
; 1386 : 			if(tObjNum >= 0)

  0003e	85 f6		 test	 esi, esi
  00040	0f 88 bd 00 00
	00		 js	 $LN27@SkillDeath

; 1387 : 			{
; 1388 : 				EnableAttack = 0;
; 1389 : 
; 1390 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00046	80 7b 02 02	 cmp	 BYTE PTR [ebx+2], 2
  0004a	75 11		 jne	 SHORT $LN15@SkillDeath
  0004c	8b ce		 mov	 ecx, esi
  0004e	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00054	83 b9 cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+716], 0

; 1391 : 				{
; 1392 : 					EnableAttack = 1;

  0005b	7c 53		 jl	 SHORT $LN12@SkillDeath
$LN15@SkillDeath:

; 1393 : 				}
; 1394 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  0005d	3b 75 20	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  00060	74 4e		 je	 SHORT $LN12@SkillDeath
  00062	39 75 fc	 cmp	 DWORD PTR _DuelIndex$[ebp], esi
  00065	74 49		 je	 SHORT $LN12@SkillDeath

; 1395 : 				{
; 1396 : 					EnableAttack = 1;
; 1397 : 				}
; 1398 : #if GS_CASTLE == 1
; 1399 : 				else if (lpObj->VpPlayer2[count].type != OBJ_NPC &&
; 1400 : 						gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE &&
; 1401 : 						g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 1402 : 				{
; 1403 : 					EnableAttack = 1;
; 1404 : 				}
; 1405 : #endif
; 1406 : 				else
; 1407 : 				{
; 1408 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  00067	8b c6		 mov	 eax, esi
  00069	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 1409 : 
; 1410 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  0006f	66 83 b8 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 2
  00077	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  0007d	75 16		 jne	 SHORT $LN10@SkillDeath
  0007f	8b 80 cc 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716]
  00085	85 c0		 test	 eax, eax
  00087	78 0c		 js	 SHORT $LN10@SkillDeath

; 1411 : 					{
; 1412 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00089	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0008f	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
$LN10@SkillDeath:

; 1413 : 					}
; 1414 : 
; 1415 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00095	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0009b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a1	51		 push	 ecx
  000a2	57		 push	 edi
  000a3	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000a8	83 c4 08	 add	 esp, 8
  000ab	83 f8 01	 cmp	 eax, 1
  000ae	75 53		 jne	 SHORT $LN27@SkillDeath
$LN12@SkillDeath:

; 1416 : 					{
; 1417 : 						EnableAttack = 1;
; 1418 : 					}
; 1419 : 				}
; 1420 : 
; 1421 : 				if(EnableAttack != 0)
; 1422 : 				{
; 1423 : 					if(this->CalDistance(x,y,gObj[tObjNum].X,gObj[tObjNum].Y) < 4)

  000b0	0f b6 4d 14	 movzx	 ecx, BYTE PTR _y$[ebp]
  000b4	8b c6		 mov	 eax, esi
  000b6	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000bc	0f bf 90 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  000c3	0f bf 80 04 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  000ca	52		 push	 edx
  000cb	0f b6 55 10	 movzx	 edx, BYTE PTR _x$[ebp]
  000cf	50		 push	 eax
  000d0	51		 push	 ecx
  000d1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ?CalDistance@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::CalDistance
  000da	83 f8 04	 cmp	 eax, 4
  000dd	7d 24		 jge	 SHORT $LN27@SkillDeath

; 1424 : 					{
; 1425 : 						bAttack = 0;
; 1426 : 
; 1427 : 						if(HitCount > 10)
; 1428 : 						{
; 1429 : 							bAttack = 0;
; 1430 : 						}
; 1431 : 						
; 1432 : 						if(HitCount >= 5)
; 1433 : 						{
; 1434 : 							if(rand()%2)
; 1435 : 							{
; 1436 : 								bAttack = 1;
; 1437 : 							}
; 1438 : 						}
; 1439 : 						else
; 1440 : 						{
; 1441 : 							bAttack = 1;
; 1442 : 						}
; 1443 : 
; 1444 : 						if(bAttack != 0)
; 1445 : 						{
; 1446 : 							int delay = rand()%500;

  000df	e8 00 00 00 00	 call	 _rand
  000e4	99		 cdq
  000e5	b9 f4 01 00 00	 mov	 ecx, 500		; 000001f4H
  000ea	f7 f9		 idiv	 ecx

; 1447 : 							gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,delay,lpMagic->m_Skill,0);

  000ec	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000ef	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  000f3	6a 00		 push	 0
  000f5	51		 push	 ecx
  000f6	52		 push	 edx
  000f7	56		 push	 esi
  000f8	6a 32		 push	 50			; 00000032H
  000fa	57		 push	 edi
  000fb	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  00100	83 c4 18	 add	 esp, 24			; 00000018H
$LN27@SkillDeath:

; 1448 : 						}
; 1449 : 					}
; 1450 : 				}
; 1451 : 			}
; 1452 : 		}
; 1453 : 
; 1454 : 		count++;

  00103	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1455 : 		if(count > MAX_VIEWPORT -1)

  00106	ff 4d 08	 dec	 DWORD PTR tv213[ebp]
  00109	0f 85 22 ff ff
	ff		 jne	 $LL19@SkillDeath

; 1456 : 		{
; 1457 : 			break;
; 1458 : 		}
; 1459 : 	}
; 1460 : 	return true;

  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	b8 01 00 00 00	 mov	 eax, 1
  00116	5b		 pop	 ebx

; 1461 : }

  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 1c 00	 ret	 28			; 0000001cH
?SkillDeathPoison@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z ENDP ; CObjUseSkill::SkillDeathPoison
_TEXT	ENDS
PUBLIC	?SkillSuddenIce@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillSuddenIce
; Function compile flags: /Ogtp
;	COMDAT ?SkillSuddenIce@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_DuelIndex$ = -4					; size = 4
tv215 = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_dir$ = 24						; size = 1
_TargetPos$ = 28					; size = 1
_aTargetIndex$ = 32					; size = 4
?SkillSuddenIce@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z PROC ; CObjUseSkill::SkillSuddenIce, COMDAT
; _this$ = ecx

; 1464 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1465 : 	LPOBJ lpObj = &gObj[aIndex];

  00009	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000c	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00012	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1466 : 	int tObjNum;
; 1467 : 	int count = 0;
; 1468 : 	int FirstHit = 0;
; 1469 : 	int HitCount = 0;
; 1470 : 	int bAttack;
; 1471 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];
; 1472 : 	int DuelIndex = lpObj->m_iDuelUser;

  00018	8b 87 1c 0d 00
	00		 mov	 eax, DWORD PTR [edi+3356]
  0001e	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00021	89 45 fc	 mov	 DWORD PTR _DuelIndex$[ebp], eax
  00024	8d 9f 16 07 00
	00		 lea	 ebx, DWORD PTR [edi+1814]
  0002a	c7 45 08 4b 00
	00 00		 mov	 DWORD PTR tv215[ebp], 75 ; 0000004bH
$LL19@SkillSudde:

; 1473 : 	int EnableAttack;
; 1474 : 
; 1475 : 	while ( true )
; 1476 : 	{
; 1477 : 		if(lpObj->VpPlayer2[count].state != 0)

  00031	80 7b fe 00	 cmp	 BYTE PTR [ebx-2], 0
  00035	0f 84 c3 00 00
	00		 je	 $LN27@SkillSudde

; 1478 : 		{
; 1479 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0003b	0f bf 33	 movsx	 esi, WORD PTR [ebx]

; 1480 : 
; 1481 : 			if(tObjNum >= 0)

  0003e	85 f6		 test	 esi, esi
  00040	0f 88 b8 00 00
	00		 js	 $LN27@SkillSudde

; 1482 : 			{
; 1483 : 				EnableAttack = 0;
; 1484 : 
; 1485 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00046	80 7b 02 02	 cmp	 BYTE PTR [ebx+2], 2
  0004a	75 11		 jne	 SHORT $LN15@SkillSudde
  0004c	8b ce		 mov	 ecx, esi
  0004e	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00054	83 b9 cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+716], 0

; 1486 : 				{
; 1487 : 					EnableAttack = 1;

  0005b	7c 53		 jl	 SHORT $LN12@SkillSudde
$LN15@SkillSudde:

; 1488 : 				}
; 1489 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  0005d	3b 75 20	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  00060	74 4e		 je	 SHORT $LN12@SkillSudde
  00062	39 75 fc	 cmp	 DWORD PTR _DuelIndex$[ebp], esi
  00065	74 49		 je	 SHORT $LN12@SkillSudde

; 1490 : 				{
; 1491 : 					EnableAttack = 1;
; 1492 : 				}
; 1493 : #if GS_CASTLE == 1
; 1494 : 				else if (lpObj->VpPlayer2[count].type != OBJ_NPC &&
; 1495 : 						gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE &&
; 1496 : 						g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 1497 : 				{
; 1498 : 					EnableAttack = 1;
; 1499 : 				}
; 1500 : #endif
; 1501 : 				else
; 1502 : 				{
; 1503 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  00067	8b c6		 mov	 eax, esi
  00069	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 1504 : 
; 1505 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  0006f	66 83 b8 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 2
  00077	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  0007d	75 16		 jne	 SHORT $LN10@SkillSudde
  0007f	8b 80 cc 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716]
  00085	85 c0		 test	 eax, eax
  00087	78 0c		 js	 SHORT $LN10@SkillSudde

; 1506 : 					{
; 1507 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00089	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0008f	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
$LN10@SkillSudde:

; 1508 : 					}
; 1509 : 
; 1510 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00095	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0009b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a1	51		 push	 ecx
  000a2	57		 push	 edi
  000a3	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000a8	83 c4 08	 add	 esp, 8
  000ab	83 f8 01	 cmp	 eax, 1
  000ae	75 4e		 jne	 SHORT $LN27@SkillSudde
$LN12@SkillSudde:

; 1511 : 					{
; 1512 : 						EnableAttack = 1;
; 1513 : 					}
; 1514 : 				}
; 1515 : 
; 1516 : 				if(EnableAttack != 0)
; 1517 : 				{
; 1518 : 					if(this->CalDistance(x,y,gObj[tObjNum].X,gObj[tObjNum].Y) < 4)

  000b0	0f b6 4d 14	 movzx	 ecx, BYTE PTR _y$[ebp]
  000b4	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000ba	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  000c1	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  000c8	52		 push	 edx
  000c9	0f b6 55 10	 movzx	 edx, BYTE PTR _x$[ebp]
  000cd	50		 push	 eax
  000ce	51		 push	 ecx
  000cf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 ?CalDistance@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::CalDistance
  000d8	83 f8 04	 cmp	 eax, 4
  000db	7d 21		 jge	 SHORT $LN27@SkillSudde

; 1519 : 					{
; 1520 : 						bAttack = 0;
; 1521 : 
; 1522 : 						if(HitCount > 10)
; 1523 : 						{
; 1524 : 							bAttack = 0;
; 1525 : 						}
; 1526 : 						
; 1527 : 						if(HitCount >= 5)
; 1528 : 						{
; 1529 : 							if(rand()%2)
; 1530 : 							{
; 1531 : 								bAttack = 1;
; 1532 : 							}
; 1533 : 						}
; 1534 : 						else
; 1535 : 						{
; 1536 : 							bAttack = 1;
; 1537 : 						}
; 1538 : 
; 1539 : 						if(bAttack != 0)
; 1540 : 						{
; 1541 : 							int delay = rand()%500;

  000dd	e8 00 00 00 00	 call	 _rand

; 1542 : 							gObjAttack(lpObj,&gObj[tObjNum],lpMagic,1,1,0,0);

  000e2	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000e5	6a 00		 push	 0
  000e7	6a 00		 push	 0
  000e9	6a 01		 push	 1
  000eb	6a 01		 push	 1
  000ed	50		 push	 eax
  000ee	8d 8e 00 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000f4	51		 push	 ecx
  000f5	57		 push	 edi
  000f6	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  000fb	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN27@SkillSudde:

; 1543 : 						}
; 1544 : 					}
; 1545 : 				}
; 1546 : 			}
; 1547 : 		}
; 1548 : 
; 1549 : 		count++;

  000fe	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1550 : 		if(count > MAX_VIEWPORT -1)

  00101	ff 4d 08	 dec	 DWORD PTR tv215[ebp]
  00104	0f 85 27 ff ff
	ff		 jne	 $LL19@SkillSudde

; 1551 : 		{
; 1552 : 			break;
; 1553 : 		}
; 1554 : 	}
; 1555 : 	return true;

  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	b8 01 00 00 00	 mov	 eax, 1
  00111	5b		 pop	 ebx

; 1556 : }

  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 1c 00	 ret	 28			; 0000001cH
?SkillSuddenIce@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z ENDP ; CObjUseSkill::SkillSuddenIce
_TEXT	ENDS
PUBLIC	??_C@_0BJ@CPAKELEB@?$FL?$CF?$FN?5?$LN?$LK?E?$LD?5?$LF?t?$LH?$LJ?$MA?L?$LN?C?$LA?$KD?5?$LP?$MA?$LJ?v?$AA@ ; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?PHeadSetBE@@YAXPAEEH@Z:PROC			; PHeadSetBE
EXTRN	?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z:PROC ; gObjMagicBPUse
EXTRN	?Check@CSkillDelay@@QAEHE@Z:PROC		; CSkillDelay::Check
EXTRN	?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@E@Z:PROC ; gObjGetMagicSearch
EXTRN	?CheckCombo@CComboAttack@@QAEHHH@Z:PROC		; CComboAttack::CheckCombo
EXTRN	?gComboAttack@@3VCComboAttack@@A:DWORD		; gComboAttack
;	COMDAT ??_C@_0BJ@CPAKELEB@?$FL?$CF?$FN?5?$LN?$LK?E?$LD?5?$LF?t?$LH?$LJ?$MA?L?$LN?C?$LA?$KD?5?$LP?$MA?$LJ?v?$AA@
CONST	SEGMENT
??_C@_0BJ@CPAKELEB@?$FL?$CF?$FN?5?$LN?$LK?E?$LD?5?$LF?t?$LH?$LJ?$MA?L?$LN?C?$LA?$KD?5?$LP?$MA?$LJ?v?$AA@ DB '['
	DB	'%] ', 0bdH, 0baH, 0c5H, 0b3H, ' ', 0b5H, 0f4H, 0b7H, 0b9H, 0c0H
	DB	0ccH, 0bdH, 0c3H, 0b0H, 0a3H, ' ', 0bfH, 0c0H, 0b9H, 0f6H, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z
_TEXT	SEGMENT
_bCombo$ = -32						; size = 4
tv378 = -28						; size = 4
_usemana$ = -28						; size = 4
tv352 = -24						; size = 4
_usebp$157276 = -24					; size = 4
_this$GSCopy$ = -20					; size = 4
_pMsg$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_dir$ = 24						; size = 1
_TargetPos$ = 28					; size = 1
_aTargetIndex$ = 32					; size = 4
?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z PROC	; CObjUseSkill::UseSkill, COMDAT
; _this$ = ecx

; 318  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _lpMagic$[ebp]

; 319  : 	LPOBJ lpObj = &gObj[aIndex];
; 320  : 
; 321  : 	int bCombo = 0;
; 322  : 
; 323  : 	if(gComboAttack.CheckCombo(aIndex,lpMagic->m_Skill))

  00018	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  0001c	57		 push	 edi
  0001d	8b fb		 mov	 edi, ebx
  0001f	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00025	50		 push	 eax
  00026	89 4d ec	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00029	89 7d e8	 mov	 DWORD PTR tv352[ebp], edi
  0002c	53		 push	 ebx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gComboAttack@@3VCComboAttack@@A ; gComboAttack
  00032	8d bf 00 00 00
	00		 lea	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  00038	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _bCombo$[ebp], 0
  0003f	e8 00 00 00 00	 call	 ?CheckCombo@CComboAttack@@QAEHHH@Z ; CComboAttack::CheckCombo
  00044	85 c0		 test	 eax, eax
  00046	74 07		 je	 SHORT $LN29@UseSkill

; 324  : 	{
; 325  : 		bCombo = 1;

  00048	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _bCombo$[ebp], 1
$LN29@UseSkill:

; 326  : 	}
; 327  : 
; 328  : 	if(lpObj->SkillHellFire2State && lpMagic->m_Skill != AT_SKILL_EXPHELL)

  0004f	80 bf 50 0f 00
	00 00		 cmp	 BYTE PTR [edi+3920], 0
  00056	74 3e		 je	 SHORT $LN28@UseSkill
  00058	80 7e 05 28	 cmp	 BYTE PTR [esi+5], 40	; 00000028H
  0005c	74 38		 je	 SHORT $LN28@UseSkill

; 329  : 	{
; 330  : 		CMagicInf * lpMagic = gObjGetMagicSearch(lpObj,AT_SKILL_EXPHELL);

  0005e	6a 28		 push	 40			; 00000028H
  00060	57		 push	 edi
  00061	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
  00066	83 c4 08	 add	 esp, 8

; 331  : 
; 332  : 		if(lpMagic != 0)

  00069	85 c0		 test	 eax, eax
  0006b	0f 84 01 03 00
	00		 je	 $LN1@UseSkill

; 333  : 		{
; 334  : 			gObjUseSkill.RunningSkill(lpObj->m_Index,0,lpMagic,0);

  00071	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00073	6a 00		 push	 0
  00075	50		 push	 eax
  00076	6a 00		 push	 0
  00078	51		 push	 ecx
  00079	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0007e	e8 00 00 00 00	 call	 ?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::RunningSkill
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx

; 435  : 		}
; 436  : 	}
; 437  : }

  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	33 cd		 xor	 ecx, ebp
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 1c 00	 ret	 28			; 0000001cH
$LN28@UseSkill:

; 335  : 		}
; 336  : 
; 337  : 		return;
; 338  : 	}
; 339  : 
; 340  : 	int usemana = this->GetUseMana(aIndex,lpMagic);

  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00099	56		 push	 esi
  0009a	53		 push	 ebx
  0009b	e8 00 00 00 00	 call	 ?GetUseMana@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::GetUseMana
  000a0	89 45 e4	 mov	 DWORD PTR _usemana$[ebp], eax

; 341  : 
; 342  : 	PMSG_DURATION_MAGIC_SEND pMsg;
; 343  : 
; 344  : 	if(usemana >= 0)

  000a3	85 c0		 test	 eax, eax
  000a5	0f 88 c7 02 00
	00		 js	 $LN1@UseSkill

; 345  : 	{
; 346  : 		if(!gObj[aIndex].SkillDelay.Check(lpMagic->m_Skill))

  000ab	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  000af	8b 4d e8	 mov	 ecx, DWORD PTR tv352[ebp]
  000b2	52		 push	 edx
  000b3	8d 89 bc 10 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4284]
  000b9	e8 00 00 00 00	 call	 ?Check@CSkillDelay@@QAEHE@Z ; CSkillDelay::Check
  000be	85 c0		 test	 eax, eax
  000c0	75 2c		 jne	 SHORT $LN25@UseSkill

; 347  : 		{
; 348  : 			LogAdd(LOG_BLACK, "[%]   ",gObj[aIndex].Name);

  000c2	8b 45 e8	 mov	 eax, DWORD PTR tv352[ebp]
  000c5	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  000cb	51		 push	 ecx
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CPAKELEB@?$FL?$CF?$FN?5?$LN?$LK?E?$LD?5?$LF?t?$LH?$LJ?$MA?L?$LN?C?$LA?$KD?5?$LP?$MA?$LJ?v?$AA@
  000d1	6a 00		 push	 0
  000d3	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx

; 435  : 		}
; 436  : 	}
; 437  : }

  000de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e1	33 cd		 xor	 ecx, ebp
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 1c 00	 ret	 28			; 0000001cH
$LN25@UseSkill:

; 349  : 			return;
; 350  : 		}
; 351  : 
; 352  : 		int usebp = gObjMagicBPUse(&gObj[aIndex],lpMagic);

  000ee	56		 push	 esi
  000ef	57		 push	 edi
  000f0	e8 00 00 00 00	 call	 ?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicBPUse
  000f5	83 c4 08	 add	 esp, 8
  000f8	89 45 e8	 mov	 DWORD PTR _usebp$157276[ebp], eax

; 353  : 
; 354  : 		if(usebp >= 0)

  000fb	85 c0		 test	 eax, eax
  000fd	0f 88 e9 00 00
	00		 js	 $LN35@UseSkill

; 355  : 		{
; 356  : 			lpObj->UseMagicNumber = lpMagic->m_Skill;

  00103	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  00107	88 97 3d 03 00
	00		 mov	 BYTE PTR [edi+829], dl

; 357  : 			lpObj->UseMagicTime = GetTickCount();

  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00113	89 87 40 03 00
	00		 mov	 DWORD PTR [edi+832], eax

; 358  : 			lpObj->UseMagicCount = 0;
; 359  : 
; 360  : 			lpObj->Mana = usemana;
; 361  : 			lpObj->BP = usebp;

  00119	8b 45 e8	 mov	 eax, DWORD PTR _usebp$157276[ebp]
  0011c	db 45 e4	 fild	 DWORD PTR _usemana$[ebp]

; 362  : 
; 363  : 			GCManaSend(lpObj->m_Index,lpObj->Mana,0xFF,0,lpObj->BP);

  0011f	50		 push	 eax
  00120	6a 00		 push	 0
  00122	d9 5d e4	 fstp	 DWORD PTR tv378[ebp]
  00125	68 ff 00 00 00	 push	 255			; 000000ffH
  0012a	d9 45 e4	 fld	 DWORD PTR tv378[ebp]
  0012d	c6 87 44 03 00
	00 00		 mov	 BYTE PTR [edi+836], 0
  00134	d9 97 d0 00 00
	00		 fst	 DWORD PTR [edi+208]
  0013a	89 87 e8 00 00
	00		 mov	 DWORD PTR [edi+232], eax
  00140	e8 00 00 00 00	 call	 __ftol2_sse
  00145	50		 push	 eax
  00146	8b 07		 mov	 eax, DWORD PTR [edi]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend

; 364  : 
; 365  : 			PHeadSetBE((PBYTE)&pMsg,0x1E,sizeof(pMsg));

  0014e	6a 09		 push	 9
  00150	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00153	6a 1e		 push	 30			; 0000001eH
  00155	51		 push	 ecx
  00156	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 366  : 
; 367  : 			pMsg.MagicNumber = lpMagic->m_Skill;

  0015b	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]

; 368  : 			pMsg.X = x;
; 369  : 			pMsg.Y = y;

  0015f	8a 4d 14	 mov	 cl, BYTE PTR _y$[ebp]
  00162	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  00165	88 4d f7	 mov	 BYTE PTR _pMsg$[ebp+7], cl

; 370  : 			pMsg.Dir = dir;
; 371  : 			pMsg.NumberH = SET_NUMBERH(aIndex);

  00168	8b cb		 mov	 ecx, ebx
  0016a	88 55 f3	 mov	 BYTE PTR _pMsg$[ebp+3], dl
  0016d	8a 55 18	 mov	 dl, BYTE PTR _dir$[ebp]
  00170	c1 e9 08	 shr	 ecx, 8
  00173	83 c4 20	 add	 esp, 32			; 00000020H

; 372  : 			pMsg.NumberL = SET_NUMBERL(aIndex);
; 373  : 
; 374  : 			if(lpObj->Type == OBJ_USER)

  00176	66 83 7f 60 01	 cmp	 WORD PTR [edi+96], 1
  0017b	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+6], al
  0017e	88 55 f8	 mov	 BYTE PTR _pMsg$[ebp+8], dl
  00181	88 4d f4	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00184	88 5d f5	 mov	 BYTE PTR _pMsg$[ebp+5], bl
  00187	75 17		 jne	 SHORT $LN23@UseSkill

; 375  : 			{
; 376  : 				DataSend(lpObj->m_Index,(PBYTE)&pMsg,pMsg.h.size);

  00189	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0018d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0018f	52		 push	 edx
  00190	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00193	50		 push	 eax
  00194	51		 push	 ecx
  00195	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0019a	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN23@UseSkill:

; 377  : 			}
; 378  : 
; 379  : 			if(CC_MAP_RANGE(lpObj->MapNumber))

  001a0	0f b6 8f 09 01
	00 00		 movzx	 ecx, BYTE PTR [edi+265]
  001a7	80 f9 12	 cmp	 cl, 18			; 00000012H
  001aa	72 2e		 jb	 SHORT $LN22@UseSkill
  001ac	b2 17		 mov	 dl, 23			; 00000017H
  001ae	3a d1		 cmp	 dl, cl
  001b0	1b c9		 sbb	 ecx, ecx
  001b2	41		 inc	 ecx
  001b3	74 25		 je	 SHORT $LN22@UseSkill

; 380  : 			{
; 381  : 				switch(lpMagic->m_Skill)

  001b5	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  001b9	83 c1 f0	 add	 ecx, -16		; fffffff0H
  001bc	83 f9 20	 cmp	 ecx, 32			; 00000020H
  001bf	77 0e		 ja	 SHORT $LN18@UseSkill
  001c1	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN34@UseSkill[ecx]
  001c8	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN38@UseSkill[ecx*4]
$LN18@UseSkill:

; 382  : 				{
; 383  : 				case AT_SKILL_MAGICDEFENSE:
; 384  : 				case AT_SKILL_HEALING:
; 385  : 				case AT_SKILL_DEFENSE:
; 386  : 				case AT_SKILL_ATTACK:
; 387  : 				case AT_SKILL_KNIGHTADDLIFE:
; 388  : 					break;
; 389  : 				default: 
; 390  : 					MsgSendV2(lpObj,(PBYTE)&pMsg,pMsg.h.size);

  001cf	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  001d3	52		 push	 edx
  001d4	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001d7	50		 push	 eax

; 391  : 				}
; 392  : 			}
; 393  : 			else

  001d8	eb 09		 jmp	 SHORT $LN37@UseSkill
$LN22@UseSkill:

; 394  : 			{
; 395  : 				MsgSendV2(lpObj,(PBYTE)&pMsg,pMsg.h.size);

  001da	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  001de	51		 push	 ecx
  001df	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  001e2	52		 push	 edx
$LN37@UseSkill:
  001e3	57		 push	 edi
  001e4	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  001e9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN35@UseSkill:

; 391  : 				}
; 392  : 			}
; 393  : 			else

  001ec	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
$LN36@UseSkill:

; 396  : 			}
; 397  : 		}
; 398  : 
; 399  : 		if(lpMagic->m_Skill == AT_SKILL_SWORD6)

  001ef	80 7e 05 38	 cmp	 BYTE PTR [esi+5], 56	; 00000038H
  001f3	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  001f6	75 1e		 jne	 SHORT $LN16@UseSkill

; 400  : 		{
; 401  : 			this->SkillPowerSlash(aIndex,lpMagic,x,y,dir,TargetPos,aTargetIndex);

  001f8	8b 55 20	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  001fb	52		 push	 edx
  001fc	8b 55 1c	 mov	 edx, DWORD PTR _TargetPos$[ebp]
  001ff	52		 push	 edx
  00200	8b 55 18	 mov	 edx, DWORD PTR _dir$[ebp]
  00203	52		 push	 edx
  00204	51		 push	 ecx
  00205	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00208	50		 push	 eax
  00209	56		 push	 esi
  0020a	53		 push	 ebx
  0020b	e8 00 00 00 00	 call	 ?SkillPowerSlash@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillPowerSlash
  00210	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  00213	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
$LN16@UseSkill:

; 402  : 		}
; 403  : 
; 404  : 		if(lpMagic->m_Skill == AT_SKILL_EXPPOISON)

  00216	8a 56 05	 mov	 dl, BYTE PTR [esi+5]
  00219	80 fa 26	 cmp	 dl, 38			; 00000026H
  0021c	75 2b		 jne	 SHORT $LN15@UseSkill

; 405  : 		{
; 406  : 			this->SkillDeathPoison(aIndex,lpMagic,x,y,dir,TargetPos,aTargetIndex);

  0021e	8b 55 20	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  00221	52		 push	 edx
  00222	8b 55 1c	 mov	 edx, DWORD PTR _TargetPos$[ebp]
  00225	52		 push	 edx
  00226	8b 55 18	 mov	 edx, DWORD PTR _dir$[ebp]
  00229	52		 push	 edx
  0022a	51		 push	 ecx
  0022b	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0022e	50		 push	 eax
  0022f	56		 push	 esi
  00230	53		 push	 ebx
  00231	e8 00 00 00 00	 call	 ?SkillDeathPoison@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillDeathPoison
  00236	5f		 pop	 edi
  00237	5e		 pop	 esi
  00238	5b		 pop	 ebx

; 435  : 		}
; 436  : 	}
; 437  : }

  00239	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0023c	33 cd		 xor	 ecx, ebp
  0023e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00243	8b e5		 mov	 esp, ebp
  00245	5d		 pop	 ebp
  00246	c2 1c 00	 ret	 28			; 0000001cH
$LN15@UseSkill:

; 407  : 		}
; 408  : 		else if(lpMagic->m_Skill == AT_SKILL_EXPICE)

  00249	80 fa 27	 cmp	 dl, 39			; 00000027H
  0024c	75 2b		 jne	 SHORT $LN13@UseSkill

; 409  : 		{
; 410  : 			this->SkillSuddenIce(aIndex,lpMagic,x,y,dir,TargetPos,aTargetIndex);

  0024e	8b 55 20	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  00251	52		 push	 edx
  00252	8b 55 1c	 mov	 edx, DWORD PTR _TargetPos$[ebp]
  00255	52		 push	 edx
  00256	8b 55 18	 mov	 edx, DWORD PTR _dir$[ebp]
  00259	52		 push	 edx
  0025a	51		 push	 ecx
  0025b	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0025e	50		 push	 eax
  0025f	56		 push	 esi
  00260	53		 push	 ebx
  00261	e8 00 00 00 00	 call	 ?SkillSuddenIce@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillSuddenIce
  00266	5f		 pop	 edi
  00267	5e		 pop	 esi
  00268	5b		 pop	 ebx

; 435  : 		}
; 436  : 	}
; 437  : }

  00269	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026c	33 cd		 xor	 ecx, ebp
  0026e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00273	8b e5		 mov	 esp, ebp
  00275	5d		 pop	 ebp
  00276	c2 1c 00	 ret	 28			; 0000001cH
$LN13@UseSkill:

; 411  : 		}
; 412  : 		else if(lpMagic->m_Skill == AT_SKILL_BLOWOFFURY)

  00279	80 fa 2a	 cmp	 dl, 42			; 0000002aH
  0027c	75 2f		 jne	 SHORT $LN11@UseSkill

; 413  : 		{
; 414  : 			this->SkillBlowOfFury(aIndex,lpMagic,x,y,dir,TargetPos,aTargetIndex,bCombo);

  0027e	8b 55 e0	 mov	 edx, DWORD PTR _bCombo$[ebp]
  00281	52		 push	 edx
  00282	8b 55 20	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  00285	52		 push	 edx
  00286	8b 55 1c	 mov	 edx, DWORD PTR _TargetPos$[ebp]
  00289	52		 push	 edx
  0028a	8b 55 18	 mov	 edx, DWORD PTR _dir$[ebp]
  0028d	52		 push	 edx
  0028e	51		 push	 ecx
  0028f	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00292	50		 push	 eax
  00293	56		 push	 esi
  00294	53		 push	 ebx
  00295	e8 00 00 00 00	 call	 ?SkillBlowOfFury@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEHH@Z ; CObjUseSkill::SkillBlowOfFury
  0029a	5f		 pop	 edi
  0029b	5e		 pop	 esi
  0029c	5b		 pop	 ebx

; 435  : 		}
; 436  : 	}
; 437  : }

  0029d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a0	33 cd		 xor	 ecx, ebp
  002a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a7	8b e5		 mov	 esp, ebp
  002a9	5d		 pop	 ebp
  002aa	c2 1c 00	 ret	 28			; 0000001cH
$LN11@UseSkill:

; 415  : 		}
; 416  : 		else if(lpMagic->m_Skill == AT_SKILL_WHEEL)

  002ad	80 fa 29	 cmp	 dl, 41			; 00000029H
  002b0	75 25		 jne	 SHORT $LN9@UseSkill

; 417  : 		{
; 418  : 			this->SkillWheel(aIndex,lpMagic,aTargetIndex,bCombo);

  002b2	8b 45 e0	 mov	 eax, DWORD PTR _bCombo$[ebp]
  002b5	8b 4d 20	 mov	 ecx, DWORD PTR _aTargetIndex$[ebp]
  002b8	50		 push	 eax
  002b9	51		 push	 ecx
  002ba	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  002bd	56		 push	 esi
  002be	53		 push	 ebx
  002bf	e8 00 00 00 00	 call	 ?SkillWheel@CObjUseSkill@@QAEXHPAVCMagicInf@@HH@Z ; CObjUseSkill::SkillWheel
  002c4	5f		 pop	 edi
  002c5	5e		 pop	 esi
  002c6	5b		 pop	 ebx

; 435  : 		}
; 436  : 	}
; 437  : }

  002c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ca	33 cd		 xor	 ecx, ebp
  002cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d1	8b e5		 mov	 esp, ebp
  002d3	5d		 pop	 ebp
  002d4	c2 1c 00	 ret	 28			; 0000001cH
$LN9@UseSkill:

; 419  : 		}
; 420  : 		else if(lpMagic->m_Skill == AT_SKILL_ELECTRICSPARK)

  002d7	80 fa 41	 cmp	 dl, 65			; 00000041H
  002da	75 2b		 jne	 SHORT $LN7@UseSkill

; 421  : 		{
; 422  : 			this->SkillElectricSpark(aIndex,lpMagic,x,y,dir,TargetPos,aTargetIndex);

  002dc	8b 55 20	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  002df	52		 push	 edx
  002e0	8b 55 1c	 mov	 edx, DWORD PTR _TargetPos$[ebp]
  002e3	52		 push	 edx
  002e4	8b 55 18	 mov	 edx, DWORD PTR _dir$[ebp]
  002e7	52		 push	 edx
  002e8	51		 push	 ecx
  002e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  002ec	50		 push	 eax
  002ed	56		 push	 esi
  002ee	53		 push	 ebx
  002ef	e8 00 00 00 00	 call	 ?SkillElectricSpark@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillElectricSpark
  002f4	5f		 pop	 edi
  002f5	5e		 pop	 esi
  002f6	5b		 pop	 ebx

; 435  : 		}
; 436  : 	}
; 437  : }

  002f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002fa	33 cd		 xor	 ecx, ebp
  002fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00301	8b e5		 mov	 esp, ebp
  00303	5d		 pop	 ebp
  00304	c2 1c 00	 ret	 28			; 0000001cH
$LN7@UseSkill:

; 423  : 		}
; 424  : 		else if(lpMagic->m_Skill == AT_SKILL_DARKHORSE_ATTACK)

  00307	80 fa 3e	 cmp	 dl, 62			; 0000003eH
  0030a	75 23		 jne	 SHORT $LN5@UseSkill

; 425  : 		{
; 426  : 			this->SkillDarkHorseAttack(lpObj->m_Index,aTargetIndex,lpMagic);

  0030c	8b 45 20	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0030f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00311	56		 push	 esi
  00312	50		 push	 eax
  00313	51		 push	 ecx
  00314	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00317	e8 00 00 00 00	 call	 ?SkillDarkHorseAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDarkHorseAttack
  0031c	5f		 pop	 edi
  0031d	5e		 pop	 esi
  0031e	5b		 pop	 ebx

; 435  : 		}
; 436  : 	}
; 437  : }

  0031f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00322	33 cd		 xor	 ecx, ebp
  00324	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00329	8b e5		 mov	 esp, ebp
  0032b	5d		 pop	 ebp
  0032c	c2 1c 00	 ret	 28			; 0000001cH
$LN5@UseSkill:

; 427  : 		}
; 428  : 		else if(lpMagic->m_Skill == AT_SKILL_STUN)

  0032f	80 fa 43	 cmp	 dl, 67			; 00000043H
  00332	75 2b		 jne	 SHORT $LN3@UseSkill

; 429  : 		{
; 430  : 			this->SkillStun(aIndex,aTargetIndex,lpMagic,x,y,dir,TargetPos);

  00334	8b 55 1c	 mov	 edx, DWORD PTR _TargetPos$[ebp]
  00337	52		 push	 edx
  00338	8b 55 18	 mov	 edx, DWORD PTR _dir$[ebp]
  0033b	52		 push	 edx
  0033c	51		 push	 ecx
  0033d	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00340	50		 push	 eax
  00341	8b 45 20	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00344	56		 push	 esi
  00345	50		 push	 eax
  00346	53		 push	 ebx
  00347	e8 00 00 00 00	 call	 ?SkillStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@EEEE@Z ; CObjUseSkill::SkillStun
  0034c	5f		 pop	 edi
  0034d	5e		 pop	 esi
  0034e	5b		 pop	 ebx

; 435  : 		}
; 436  : 	}
; 437  : }

  0034f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00352	33 cd		 xor	 ecx, ebp
  00354	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00359	8b e5		 mov	 esp, ebp
  0035b	5d		 pop	 ebp
  0035c	c2 1c 00	 ret	 28			; 0000001cH
$LN3@UseSkill:

; 431  : 		}
; 432  : 		else if(lpMagic->m_Skill == AT_SKILL_FENRIR_ATTACK)

  0035f	80 fa 4c	 cmp	 dl, 76			; 0000004cH
  00362	75 0e		 jne	 SHORT $LN1@UseSkill

; 433  : 		{
; 434  : 			this->SkillFenrirAttack(aIndex,aTargetIndex,lpMagic);

  00364	8b 4d 20	 mov	 ecx, DWORD PTR _aTargetIndex$[ebp]
  00367	56		 push	 esi
  00368	51		 push	 ecx
  00369	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0036c	53		 push	 ebx
  0036d	e8 00 00 00 00	 call	 ?SkillFenrirAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillFenrirAttack
$LN1@UseSkill:

; 435  : 		}
; 436  : 	}
; 437  : }

  00372	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00375	5f		 pop	 edi
  00376	5e		 pop	 esi
  00377	33 cd		 xor	 ecx, ebp
  00379	5b		 pop	 ebx
  0037a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0037f	8b e5		 mov	 esp, ebp
  00381	5d		 pop	 ebp
  00382	c2 1c 00	 ret	 28			; 0000001cH
  00385	8d 49 00	 npad	 3
$LN38@UseSkill:
  00388	00 00 00 00	 DD	 $LN36@UseSkill
  0038c	00 00 00 00	 DD	 $LN18@UseSkill
$LN34@UseSkill:
  00390	00		 DB	 0
  00391	01		 DB	 1
  00392	01		 DB	 1
  00393	01		 DB	 1
  00394	01		 DB	 1
  00395	01		 DB	 1
  00396	01		 DB	 1
  00397	01		 DB	 1
  00398	01		 DB	 1
  00399	01		 DB	 1
  0039a	00		 DB	 0
  0039b	00		 DB	 0
  0039c	00		 DB	 0
  0039d	01		 DB	 1
  0039e	01		 DB	 1
  0039f	01		 DB	 1
  003a0	01		 DB	 1
  003a1	01		 DB	 1
  003a2	01		 DB	 1
  003a3	01		 DB	 1
  003a4	01		 DB	 1
  003a5	01		 DB	 1
  003a6	01		 DB	 1
  003a7	01		 DB	 1
  003a8	01		 DB	 1
  003a9	01		 DB	 1
  003aa	01		 DB	 1
  003ab	01		 DB	 1
  003ac	01		 DB	 1
  003ad	01		 DB	 1
  003ae	01		 DB	 1
  003af	01		 DB	 1
  003b0	00		 DB	 0
?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ENDP	; CObjUseSkill::UseSkill
_TEXT	ENDS
PUBLIC	?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z	; CObjUseSkill::UseSkill
; Function compile flags: /Ogtp
;	COMDAT ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv192 = -8						; size = 4
_usebp$157329 = -8					; size = 4
_this$ = -4						; size = 4
_bCombo$ = 8						; size = 4
_aIndex$ = 8						; size = 4
tv221 = 12						; size = 4
_aTargetIndex$ = 12					; size = 4
_usemana$ = 16						; size = 4
_lpMagic$ = 16						; size = 4
?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::UseSkill, COMDAT
; _this$ = ecx

; 440  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 441  : 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	8b f3		 mov	 esi, ebx
  0000d	57		 push	 edi
  0000e	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H

; 442  : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];
; 443  : 
; 444  : 	int bCombo = 0;
; 445  : 
; 446  : 	if(gComboAttack.CheckCombo(aIndex,lpMagic->m_Skill))

  00014	8b 7d 10	 mov	 edi, DWORD PTR _lpMagic$[ebp]
  00017	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  0001b	50		 push	 eax
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	89 75 f8	 mov	 DWORD PTR tv192[ebp], esi
  00022	53		 push	 ebx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?gComboAttack@@3VCComboAttack@@A ; gComboAttack
  00028	8d b6 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  0002e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _bCombo$[ebp], 0
  00035	e8 00 00 00 00	 call	 ?CheckCombo@CComboAttack@@QAEHHH@Z ; CComboAttack::CheckCombo
  0003a	85 c0		 test	 eax, eax
  0003c	74 07		 je	 SHORT $LN11@UseSkill@2

; 447  : 	{
; 448  : 		bCombo = 1;

  0003e	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _bCombo$[ebp], 1
$LN11@UseSkill@2:

; 449  : 	}
; 450  : 
; 451  : 	if(lpObj->SkillHellFire2State && lpMagic->m_Skill != AT_SKILL_EXPHELL)

  00045	80 be 50 0f 00
	00 00		 cmp	 BYTE PTR [esi+3920], 0
  0004c	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  00051	74 32		 je	 SHORT $LN7@UseSkill@2
  00053	38 47 05	 cmp	 BYTE PTR [edi+5], al
  00056	74 32		 je	 SHORT $LN13@UseSkill@2

; 452  : 	{
; 453  : 		CMagicInf * lpMagic = gObjGetMagicSearch(lpObj,AT_SKILL_EXPHELL);

  00058	50		 push	 eax
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
  0005f	83 c4 08	 add	 esp, 8

; 454  : 
; 455  : 		if(lpMagic != 0)

  00062	85 c0		 test	 eax, eax
  00064	0f 84 1d 01 00
	00		 je	 $LN1@UseSkill@2

; 456  : 		{
; 457  : 			gObjUseSkill.RunningSkill(lpObj->m_Index,0,lpMagic,0);

  0006a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006c	6a 00		 push	 0
  0006e	50		 push	 eax
  0006f	6a 00		 push	 0
  00071	51		 push	 ecx
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00077	e8 00 00 00 00	 call	 ?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::RunningSkill
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx

; 496  : 			}
; 497  : 		}
; 498  : 	}
; 499  : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 0c 00	 ret	 12			; 0000000cH
$LN7@UseSkill@2:

; 458  : 		}
; 459  : 
; 460  : 		return;
; 461  : 	}
; 462  : 
; 463  : 	if(lpMagic->m_Skill == AT_SKILL_EXPHELL && aTargetIndex != 58)

  00085	38 47 05	 cmp	 BYTE PTR [edi+5], al
  00088	75 3c		 jne	 SHORT $LN5@UseSkill@2
$LN13@UseSkill@2:
  0008a	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0008d	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00090	74 34		 je	 SHORT $LN5@UseSkill@2

; 464  : 	{
; 465  : 		this->RunningSkill(aIndex,aTargetIndex,lpMagic,bCombo);

  00092	8b 55 08	 mov	 edx, DWORD PTR _bCombo$[ebp]
  00095	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	52		 push	 edx
  00099	57		 push	 edi
  0009a	50		 push	 eax
  0009b	53		 push	 ebx
  0009c	e8 00 00 00 00	 call	 ?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::RunningSkill

; 466  : 		lpObj->UseMagicNumber = lpMagic->m_Skill;

  000a1	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  000a4	88 86 3d 03 00
	00		 mov	 BYTE PTR [esi+829], al

; 467  : 		lpObj->UseMagicTime = GetTickCount();

  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000b0	5f		 pop	 edi
  000b1	89 86 40 03 00
	00		 mov	 DWORD PTR [esi+832], eax

; 468  : 		lpObj->UseMagicCount = 0;

  000b7	c6 86 44 03 00
	00 00		 mov	 BYTE PTR [esi+836], 0
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx

; 496  : 			}
; 497  : 		}
; 498  : 	}
; 499  : }

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 0c 00	 ret	 12			; 0000000cH
$LN5@UseSkill@2:

; 469  : 		return;
; 470  : 	}
; 471  : 
; 472  : 	int usemana = this->GetUseMana(aIndex,lpMagic);

  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	57		 push	 edi
  000ca	53		 push	 ebx
  000cb	e8 00 00 00 00	 call	 ?GetUseMana@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::GetUseMana
  000d0	89 45 10	 mov	 DWORD PTR _usemana$[ebp], eax

; 473  : 
; 474  : 	if(usemana >= 0)

  000d3	85 c0		 test	 eax, eax
  000d5	0f 88 ac 00 00
	00		 js	 $LN1@UseSkill@2

; 475  : 	{
; 476  : 		if(!gObj[aIndex].SkillDelay.Check(lpMagic->m_Skill))

  000db	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  000df	51		 push	 ecx
  000e0	8b 4d f8	 mov	 ecx, DWORD PTR tv192[ebp]
  000e3	8d 89 bc 10 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4284]
  000e9	e8 00 00 00 00	 call	 ?Check@CSkillDelay@@QAEHE@Z ; CSkillDelay::Check
  000ee	85 c0		 test	 eax, eax
  000f0	75 22		 jne	 SHORT $LN3@UseSkill@2

; 477  : 		{
; 478  : 			LogAdd(LOG_BLACK, "[%]   ",gObj[aIndex].Name);

  000f2	8b 55 f8	 mov	 edx, DWORD PTR tv192[ebp]
  000f5	8d 82 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+111]
  000fb	50		 push	 eax
  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CPAKELEB@?$FL?$CF?$FN?5?$LN?$LK?E?$LD?5?$LF?t?$LH?$LJ?$MA?L?$LN?C?$LA?$KD?5?$LP?$MA?$LJ?v?$AA@
  00101	6a 00		 push	 0
  00103	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx

; 496  : 			}
; 497  : 		}
; 498  : 	}
; 499  : }

  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c2 0c 00	 ret	 12			; 0000000cH
$LN3@UseSkill@2:

; 479  : 			return;
; 480  : 		}
; 481  : 
; 482  : 		int usebp = this->GetUseBP(aIndex,lpMagic);

  00114	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	57		 push	 edi
  00118	53		 push	 ebx
  00119	e8 00 00 00 00	 call	 ?GetUseBP@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::GetUseBP
  0011e	89 45 f8	 mov	 DWORD PTR _usebp$157329[ebp], eax

; 483  : 
; 484  : 		if(usebp >= 0)

  00121	85 c0		 test	 eax, eax
  00123	78 62		 js	 SHORT $LN1@UseSkill@2

; 485  : 		{
; 486  : 			if(this->RunningSkill(aIndex,aTargetIndex,lpMagic,bCombo)==1)

  00125	8b 4d 08	 mov	 ecx, DWORD PTR _bCombo$[ebp]
  00128	8b 55 0c	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  0012b	51		 push	 ecx
  0012c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	57		 push	 edi
  00130	52		 push	 edx
  00131	53		 push	 ebx
  00132	e8 00 00 00 00	 call	 ?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::RunningSkill
  00137	83 f8 01	 cmp	 eax, 1
  0013a	75 4b		 jne	 SHORT $LN1@UseSkill@2

; 487  : 			{
; 488  : 				lpObj->UseMagicNumber = lpMagic->m_Skill;

  0013c	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  0013f	88 86 3d 03 00
	00		 mov	 BYTE PTR [esi+829], al

; 489  : 				lpObj->UseMagicTime = GetTickCount();

  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 490  : 				lpObj->UseMagicCount = 0;
; 491  : 
; 492  : 				lpObj->Mana = usemana;

  0014b	db 45 10	 fild	 DWORD PTR _usemana$[ebp]
  0014e	89 86 40 03 00
	00		 mov	 DWORD PTR [esi+832], eax

; 493  : 				lpObj->BP = usebp;

  00154	8b 45 f8	 mov	 eax, DWORD PTR _usebp$157329[ebp]

; 494  : 
; 495  : 				GCManaSend(aIndex,lpObj->Mana,0xFF,0,lpObj->BP);

  00157	50		 push	 eax
  00158	d9 5d 0c	 fstp	 DWORD PTR tv221[ebp]
  0015b	d9 45 0c	 fld	 DWORD PTR tv221[ebp]
  0015e	6a 00		 push	 0
  00160	68 ff 00 00 00	 push	 255			; 000000ffH
  00165	d9 96 d0 00 00
	00		 fst	 DWORD PTR [esi+208]
  0016b	c6 86 44 03 00
	00 00		 mov	 BYTE PTR [esi+836], 0
  00172	89 86 e8 00 00
	00		 mov	 DWORD PTR [esi+232], eax
  00178	e8 00 00 00 00	 call	 __ftol2_sse
  0017d	50		 push	 eax
  0017e	53		 push	 ebx
  0017f	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  00184	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@UseSkill@2:
  00187	5f		 pop	 edi
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx

; 496  : 			}
; 497  : 		}
; 498  : 	}
; 499  : }

  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c2 0c 00	 ret	 12			; 0000000cH
?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::UseSkill
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__EgObjUseSkill@@YAXXZ
text$yc	SEGMENT
??__EgObjUseSkill@@YAXXZ PROC				; `dynamic initializer for 'gObjUseSkill'', COMDAT

; 15   : CObjUseSkill gObjUseSkill;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00005	e8 00 00 00 00	 call	 ??0CObjUseSkill@@QAE@XZ	; CObjUseSkill::CObjUseSkill
  0000a	68 00 00 00 00	 push	 OFFSET ??__FgObjUseSkill@@YAXXZ ; `dynamic atexit destructor for 'gObjUseSkill''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__EgObjUseSkill@@YAXXZ ENDP				; `dynamic initializer for 'gObjUseSkill''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__FgObjUseSkill@@YAXXZ
text$yd	SEGMENT
??__FgObjUseSkill@@YAXXZ PROC				; `dynamic atexit destructor for 'gObjUseSkill'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00005	e9 00 00 00 00	 jmp	 ??1CObjUseSkill@@UAE@XZ	; CObjUseSkill::~CObjUseSkill
??__FgObjUseSkill@@YAXXZ ENDP				; `dynamic atexit destructor for 'gObjUseSkill''
text$yd	ENDS
PUBLIC	?gObjUseSkill@@3VCObjUseSkill@@A		; gObjUseSkill
_BSS	SEGMENT
?gObjUseSkill@@3VCObjUseSkill@@A DB 024H DUP (?)	; gObjUseSkill
_BSS	ENDS
CRT$XCU	SEGMENT
_gObjUseSkill$initializer$ DD FLAT:??__EgObjUseSkill@@YAXXZ
CRT$XCU	ENDS
END
