; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\ChaosBox.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
_DATA	ENDS
PUBLIC	?ChaosBoxCheck@@YAHPAUOBJECTSTRUCT@@@Z		; ChaosBoxCheck
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaosbox.cpp
;	COMDAT ?ChaosBoxCheck@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?ChaosBoxCheck@@YAHPAUOBJECTSTRUCT@@@Z PROC		; ChaosBoxCheck, COMDAT

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15   : 	if ( lpObj->pChaosBox == NULL )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	39 81 dc 0c 00
	00		 cmp	 DWORD PTR [ecx+3292], eax
  0000e	0f 95 c0	 setne	 al

; 16   : 	{
; 17   : 		return false;
; 18   : 	}
; 19   : 
; 20   : 	return true;
; 21   : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?ChaosBoxCheck@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; ChaosBoxCheck
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?ChaosBoxItemDown@@YAHPAUOBJECTSTRUCT@@@Z	; ChaosBoxItemDown
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?Convert@CItem@@QAEXHEEEEEEE@Z:PROC		; CItem::Convert
EXTRN	?ItemGetDurability@@YAHHHHH@Z:PROC		; ItemGetDurability
EXTRN	?IsExtItem@CItem@@QAEHXZ:PROC			; CItem::IsExtItem
EXTRN	?IsSetItem@CItem@@QAEHXZ:PROC			; CItem::IsSetItem
EXTRN	_rand:PROC
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
;	COMDAT ?ChaosBoxItemDown@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv534 = 8						; size = 4
_dur$155589 = 8						; size = 4
_lpObj$ = 8						; size = 4
?ChaosBoxItemDown@@YAHPAUOBJECTSTRUCT@@@Z PROC		; ChaosBoxItemDown, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 68   : 	if ( lpObj->pChaosBox == NULL )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00007	83 bf dc 0c 00
	00 00		 cmp	 DWORD PTR [edi+3292], 0
  0000e	75 05		 jne	 SHORT $LN12@ChaosBoxIt

; 69   : 	{
; 70   : 		return FALSE;

  00010	33 c0		 xor	 eax, eax
  00012	5f		 pop	 edi

; 119  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
$LN12@ChaosBoxIt:
  00015	53		 push	 ebx
  00016	56		 push	 esi

; 71   : 	}
; 72   : 
; 73   : 	for (int n=0;n<CHAOS_BOX_SIZE;n++)

  00017	33 f6		 xor	 esi, esi
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL11@ChaosBoxIt:

; 74   : 	{
; 75   : 		if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,15) || lpObj->pChaosBox[n].m_Type == ITEMGET(14,13) || lpObj->pChaosBox[n].m_Type == ITEMGET(14,14))

  00020	8b 87 dc 0c 00
	00		 mov	 eax, DWORD PTR [edi+3292]
  00026	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00029	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  0002d	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  00032	66 3b c2	 cmp	 ax, dx
  00035	0f 84 15 01 00
	00		 je	 $LN7@ChaosBoxIt
  0003b	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  00040	66 3b c2	 cmp	 ax, dx
  00043	0f 84 07 01 00
	00		 je	 $LN7@ChaosBoxIt
  00049	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  0004e	66 3b c2	 cmp	 ax, dx
  00051	0f 84 f9 00 00
	00		 je	 $LN7@ChaosBoxIt

; 78   : 		}
; 79   : 		else
; 80   : 		{
; 81   : 			int op = lpObj->pChaosBox[n].m_Option1;

  00057	0f b6 59 78	 movzx	 ebx, BYTE PTR [ecx+120]

; 82   : 
; 83   : 			if ( op > 0 )

  0005b	85 db		 test	 ebx, ebx
  0005d	7e 14		 jle	 SHORT $LN17@ChaosBoxIt

; 84   : 			{
; 85   : 				if ( (rand() % 2) == 0 )

  0005f	e8 00 00 00 00	 call	 _rand
  00064	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00069	79 05		 jns	 SHORT $LN19@ChaosBoxIt
  0006b	48		 dec	 eax
  0006c	83 c8 fe	 or	 eax, -2			; fffffffeH
  0006f	40		 inc	 eax
$LN19@ChaosBoxIt:
  00070	75 01		 jne	 SHORT $LN17@ChaosBoxIt

; 86   : 				{
; 87   : 					op--;

  00072	4b		 dec	 ebx
$LN17@ChaosBoxIt:

; 88   : 				}
; 89   : 			}
; 90   : 
; 91   : 			lpObj->pChaosBox[n].m_Option1 = op;

  00073	8b 87 dc 0c 00
	00		 mov	 eax, DWORD PTR [edi+3292]
  00079	88 5c 06 78	 mov	 BYTE PTR [esi+eax+120], bl

; 92   : 			op = lpObj->pChaosBox[n].m_Option3;

  0007d	8b 8f dc 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3292]
  00083	0f b6 5c 0e 7a	 movzx	 ebx, BYTE PTR [esi+ecx+122]

; 93   : 
; 94   : 			if ( op > 0 )

  00088	85 db		 test	 ebx, ebx
  0008a	7e 14		 jle	 SHORT $LN18@ChaosBoxIt

; 95   : 			{
; 96   : 				if ( (rand() % 2) == 0 )

  0008c	e8 00 00 00 00	 call	 _rand
  00091	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00096	79 05		 jns	 SHORT $LN20@ChaosBoxIt
  00098	48		 dec	 eax
  00099	83 c8 fe	 or	 eax, -2			; fffffffeH
  0009c	40		 inc	 eax
$LN20@ChaosBoxIt:
  0009d	75 01		 jne	 SHORT $LN18@ChaosBoxIt

; 97   : 				{
; 98   : 					op--;

  0009f	4b		 dec	 ebx
$LN18@ChaosBoxIt:

; 99   : 				}
; 100  : 			}
; 101  : 
; 102  : 			lpObj->pChaosBox[n].m_Option3 = op;

  000a0	8b 97 dc 0c 00
	00		 mov	 edx, DWORD PTR [edi+3292]
  000a6	88 5c 16 7a	 mov	 BYTE PTR [esi+edx+122], bl

; 103  : 
; 104  : 			if ( lpObj->pChaosBox[n].m_Level > 0 )

  000aa	8b 87 dc 0c 00
	00		 mov	 eax, DWORD PTR [edi+3292]
  000b0	66 83 7c 06 08
	00		 cmp	 WORD PTR [esi+eax+8], 0
  000b6	7e 12		 jle	 SHORT $LN1@ChaosBoxIt

; 105  : 			{
; 106  : 				lpObj->pChaosBox[n].m_Level = rand() % lpObj->pChaosBox[n].m_Level;

  000b8	8d 5c 06 08	 lea	 ebx, DWORD PTR [esi+eax+8]
  000bc	e8 00 00 00 00	 call	 _rand
  000c1	0f bf 0b	 movsx	 ecx, WORD PTR [ebx]
  000c4	99		 cdq
  000c5	f7 f9		 idiv	 ecx
  000c7	66 89 13	 mov	 WORD PTR [ebx], dx
$LN1@ChaosBoxIt:

; 107  : 			}
; 108  : 
; 109  : 			float dur = ItemGetDurability(lpObj->pChaosBox[n].m_Type, lpObj->pChaosBox[n].m_Level, lpObj->pChaosBox[n].IsExtItem(), lpObj->pChaosBox[n].IsSetItem());

  000ca	8b 97 dc 0c 00
	00		 mov	 edx, DWORD PTR [edi+3292]
  000d0	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  000d3	8d 1c 16	 lea	 ebx, DWORD PTR [esi+edx]
  000d6	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  000db	8b 8f dc 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3292]
  000e1	50		 push	 eax
  000e2	03 ce		 add	 ecx, esi
  000e4	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  000e9	0f bf 4b 06	 movsx	 ecx, WORD PTR [ebx+6]
  000ed	50		 push	 eax
  000ee	0f bf 43 08	 movsx	 eax, WORD PTR [ebx+8]
  000f2	50		 push	 eax
  000f3	51		 push	 ecx
  000f4	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability

; 110  : 			
; 111  : 			lpObj->pChaosBox[n].m_Durability =  dur * lpObj->pChaosBox[n].m_Durability / lpObj->pChaosBox[n].m_BaseDurability;

  000f9	8b 97 dc 0c 00
	00		 mov	 edx, DWORD PTR [edi+3292]
  000ff	89 45 08	 mov	 DWORD PTR tv534[ebp], eax
  00102	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00105	db 45 08	 fild	 DWORD PTR tv534[ebp]
  00108	83 c4 10	 add	 esp, 16			; 00000010H

; 112  : 			lpObj->pChaosBox[n].Convert(lpObj->pChaosBox[n].m_Type, lpObj->pChaosBox[n].m_Option1,
; 113  : 				lpObj->pChaosBox[n].m_Option2, lpObj->pChaosBox[n].m_Option3, lpObj->pChaosBox[n].m_NewOption,
; 114  : 				lpObj->pChaosBox[n].m_SetOption, 0, CURRENT_DB_VERSION);

  0010b	6a 03		 push	 3
  0010d	6a 00		 push	 0
  0010f	d9 5d 08	 fstp	 DWORD PTR _dur$155589[ebp]
  00112	d9 45 08	 fld	 DWORD PTR _dur$155589[ebp]
  00115	d8 48 24	 fmul	 DWORD PTR [eax+36]
  00118	d8 70 2c	 fdiv	 DWORD PTR [eax+44]
  0011b	d9 58 24	 fstp	 DWORD PTR [eax+36]
  0011e	8b 87 dc 0c 00
	00		 mov	 eax, DWORD PTR [edi+3292]
  00124	0f b6 94 06 92
	00 00 00	 movzx	 edx, BYTE PTR [esi+eax+146]
  0012c	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0012f	0f b6 41 7b	 movzx	 eax, BYTE PTR [ecx+123]
  00133	52		 push	 edx
  00134	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  00138	50		 push	 eax
  00139	0f b6 41 79	 movzx	 eax, BYTE PTR [ecx+121]
  0013d	52		 push	 edx
  0013e	0f b6 51 78	 movzx	 edx, BYTE PTR [ecx+120]
  00142	50		 push	 eax
  00143	0f bf 41 06	 movsx	 eax, WORD PTR [ecx+6]
  00147	52		 push	 edx
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEE@Z ; CItem::Convert
  0014e	eb 05		 jmp	 SHORT $LN10@ChaosBoxIt
$LN7@ChaosBoxIt:

; 76   : 		{
; 77   : 			lpObj->pChaosBox[n].Clear();

  00150	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
$LN10@ChaosBoxIt:

; 71   : 	}
; 72   : 
; 73   : 	for (int n=0;n<CHAOS_BOX_SIZE;n++)

  00155	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  0015b	81 fe 00 15 00
	00		 cmp	 esi, 5376		; 00001500H
  00161	0f 8c b9 fe ff
	ff		 jl	 $LL11@ChaosBoxIt

; 115  : 		}
; 116  : 	}
; 117  : 
; 118  : 	return TRUE;

  00167	5e		 pop	 esi
  00168	5b		 pop	 ebx
  00169	b8 01 00 00 00	 mov	 eax, 1
  0016e	5f		 pop	 edi

; 119  : }

  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
?ChaosBoxItemDown@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; ChaosBoxItemDown
_TEXT	ENDS
PUBLIC	??_C@_0DO@PLIHJFD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5need?5Zen?5?3?5?$CFd?5Suc@ ; `string'
PUBLIC	??_C@_0FA@LILHPMOA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5?$FL?$CFd?0?$CFs?0?$CFd?0?$CFd?0?$CFd?0?$CF@ ; `string'
PUBLIC	_Result2$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ChaosBoxMix@@YAHPAUOBJECTSTRUCT@@AAH@Z		; ChaosBoxMix
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
EXTRN	?OldValue@CItem@@QAEXXZ:PROC			; CItem::OldValue
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0DO@PLIHJFD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5need?5Zen?5?3?5?$CFd?5Suc@
CONST	SEGMENT
??_C@_0DO@PLIHJFD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5need?5Zen?5?3?5?$CFd?5Suc@ DB '['
	DB	'%s][%s] CBMix need Zen : %d SuccessRate : %d, CharmRate : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@LILHPMOA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5?$FL?$CFd?0?$CFs?0?$CFd?0?$CFd?0?$CFd?0?$CF@
CONST	SEGMENT
??_C@_0FA@LILHPMOA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5?$FL?$CFd?0?$CFs?0?$CFd?0?$CFd?0?$CFd?0?$CF@ DB '['
	DB	'%s][%s] CBMix [%d,%s,%d,%d,%d,%d]serial:[%d][%d][%d] Ex:[%d,%'
	DB	'd,%d,%d,%d,%d,%d]', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ChaosBoxMix@@YAHPAUOBJECTSTRUCT@@AAH@Z
_TEXT	SEGMENT
_Result2$GSCopy$ = -44					; size = 4
_ChaosDiamond$ = -40					; size = 4
_n$155602 = -36						; size = 4
_iCharmOfLuckCount$ = -32				; size = 4
_ChaosItems$ = -28					; size = 4
tv530 = -24						; size = 4
_add$ = -20						; size = 4
_value$ = -16						; size = 4
_ExOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_Result2$ = 12						; size = 4
?ChaosBoxMix@@YAHPAUOBJECTSTRUCT@@AAH@Z PROC		; ChaosBoxMix, COMDAT

; 124  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _Result2$[ebp]
  00013	56		 push	 esi

; 125  : 	BYTE ExOption[8];
; 126  : 	int ChaosDiamond = 0;

  00014	33 f6		 xor	 esi, esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0001a	89 45 d4	 mov	 DWORD PTR _Result2$GSCopy$[ebp], eax
  0001d	89 75 d8	 mov	 DWORD PTR _ChaosDiamond$[ebp], esi

; 127  : 	int ChaosItems = 0;

  00020	89 75 e4	 mov	 DWORD PTR _ChaosItems$[ebp], esi

; 128  : 
; 129  : 	if ( lpObj->pChaosBox == NULL )

  00023	39 b7 dc 0c 00
	00		 cmp	 DWORD PTR [edi+3292], esi
  00029	75 12		 jne	 SHORT $LN19@ChaosBoxMi

; 130  : 	{
; 131  : 		return 0;

  0002b	5f		 pop	 edi
  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 234  : 	return value;
; 235  : }

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00032	33 cd		 xor	 ecx, ebp
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN19@ChaosBoxMi:
  0003d	53		 push	 ebx

; 132  : 	}
; 133  : 
; 134  : 	int value = 0;
; 135  : 	int add = 0;
; 136  : 	int nv = 0;	// NEW VALUE
; 137  : 	Result2 = 0;

  0003e	89 30		 mov	 DWORD PTR [eax], esi

; 138  : 	lpObj->ChaosSuccessRate = 0;
; 139  : 	lpObj->ChaosMoney = 0;
; 140  : 	int iCharmOfLuckCount = 0;

  00040	33 db		 xor	 ebx, ebx
  00042	89 75 f0	 mov	 DWORD PTR _value$[ebp], esi
  00045	89 b7 e8 0c 00
	00		 mov	 DWORD PTR [edi+3304], esi
  0004b	89 b7 e4 0c 00
	00		 mov	 DWORD PTR [edi+3300], esi
  00051	89 5d e0	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], ebx

; 141  : 
; 142  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00054	89 75 dc	 mov	 DWORD PTR _n$155602[ebp], esi
  00057	89 75 e8	 mov	 DWORD PTR tv530[ebp], esi
  0005a	8d 9b 00 00 00
	00		 npad	 6
$LL18@ChaosBoxMi:

; 143  : 	{
; 144  : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00060	8b 8f dc 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3292]
  00066	03 ce		 add	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006d	83 f8 01	 cmp	 eax, 1
  00070	0f 85 68 01 00
	00		 jne	 $LN17@ChaosBoxMi

; 145  : 		{
; 146  : 			lpObj->pChaosBox[n].OldValue();

  00076	8b 8f dc 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3292]
  0007c	03 ce		 add	 ecx, esi
  0007e	e8 00 00 00 00	 call	 ?OldValue@CItem@@QAEXXZ	; CItem::OldValue

; 147  : 			add = 0;
; 148  : 			nv = 0;
; 149  : 
; 150  : 			if ( lpObj->pChaosBox[n].m_Level >= MIN_CHAOS_ITEM_LEVEL && (lpObj->pChaosBox[n].m_Option3 *4) >= MIN_CHAOS_ITEM_LEVEL )

  00083	8b 87 dc 0c 00
	00		 mov	 eax, DWORD PTR [edi+3292]
  00089	33 db		 xor	 ebx, ebx
  0008b	03 c6		 add	 eax, esi
  0008d	66 83 78 08 04	 cmp	 WORD PTR [eax+8], 4
  00092	89 5d ec	 mov	 DWORD PTR _add$[ebp], ebx
  00095	7c 45		 jl	 SHORT $LN25@ChaosBoxMi
  00097	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  0009b	03 c9		 add	 ecx, ecx
  0009d	03 c9		 add	 ecx, ecx
  0009f	83 f9 04	 cmp	 ecx, 4
  000a2	7c 38		 jl	 SHORT $LN25@ChaosBoxMi

; 151  : 			{
; 152  : 				nv = lpObj->pChaosBox[n].m_OldBuyMoney;

  000a4	8b 58 74	 mov	 ebx, DWORD PTR [eax+116]

; 153  : 				value += lpObj->pChaosBox[n].m_OldBuyMoney;
; 154  : 				add = 1;
; 155  : 
; 156  : 				if ( lpObj->pChaosBox[n].m_Type == ITEMGET(2,6) || lpObj->pChaosBox[n].m_Type == ITEMGET(4,6) || lpObj->pChaosBox[n].m_Type == ITEMGET(5,7) )	// Chaos Items

  000a7	0f b7 40 06	 movzx	 eax, WORD PTR [eax+6]
  000ab	01 5d f0	 add	 DWORD PTR _value$[ebp], ebx
  000ae	ba 06 04 00 00	 mov	 edx, 1030		; 00000406H
  000b3	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _add$[ebp], 1
  000ba	66 3b c2	 cmp	 ax, dx
  000bd	74 14		 je	 SHORT $LN12@ChaosBoxMi
  000bf	b9 06 08 00 00	 mov	 ecx, 2054		; 00000806H
  000c4	66 3b c1	 cmp	 ax, cx
  000c7	74 0a		 je	 SHORT $LN12@ChaosBoxMi
  000c9	ba 07 0a 00 00	 mov	 edx, 2567		; 00000a07H
  000ce	66 3b c2	 cmp	 ax, dx
  000d1	75 09		 jne	 SHORT $LN25@ChaosBoxMi
$LN12@ChaosBoxMi:

; 157  : 				{
; 158  : 					Result2 = 1;

  000d3	8b 45 d4	 mov	 eax, DWORD PTR _Result2$GSCopy$[ebp]
  000d6	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
$LN25@ChaosBoxMi:

; 159  : 				}
; 160  : 			}
; 161  : 
; 162  : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,15) )

  000dc	03 b7 dc 0c 00
	00		 add	 esi, DWORD PTR [edi+3292]
  000e2	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  000e7	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  000eb	66 3b c2	 cmp	 ax, dx
  000ee	75 13		 jne	 SHORT $LN11@ChaosBoxMi

; 163  : 			{
; 164  : 				value += lpObj->pChaosBox[n].m_OldBuyMoney;

  000f0	8b 5e 74	 mov	 ebx, DWORD PTR [esi+116]
  000f3	01 5d f0	 add	 DWORD PTR _value$[ebp], ebx

; 165  : 				nv = lpObj->pChaosBox[n].m_OldBuyMoney;
; 166  : 				ChaosDiamond++;

  000f6	b9 01 00 00 00	 mov	 ecx, 1
  000fb	01 4d d8	 add	 DWORD PTR _ChaosDiamond$[ebp], ecx

; 167  : 				add = 1;

  000fe	89 4d ec	 mov	 DWORD PTR _add$[ebp], ecx
  00101	eb 21		 jmp	 SHORT $LN26@ChaosBoxMi
$LN11@ChaosBoxMi:

; 168  : 			}
; 169  : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,13) || lpObj->pChaosBox[n].m_Type == ITEMGET(14,14) )	// Jewel of Bless, Jewel of Soul

  00103	b9 0d 1c 00 00	 mov	 ecx, 7181		; 00001c0dH
  00108	66 3b c1	 cmp	 ax, cx
  0010b	74 0a		 je	 SHORT $LN8@ChaosBoxMi
  0010d	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  00112	66 3b c2	 cmp	 ax, dx
  00115	75 0d		 jne	 SHORT $LN26@ChaosBoxMi
$LN8@ChaosBoxMi:

; 170  : 			{
; 171  : 				value += lpObj->pChaosBox[n].m_OldBuyMoney;

  00117	8b 5e 74	 mov	 ebx, DWORD PTR [esi+116]
  0011a	01 5d f0	 add	 DWORD PTR _value$[ebp], ebx

; 172  : 				nv = lpObj->pChaosBox[n].m_OldBuyMoney;
; 173  : 				add = 1;

  0011d	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _add$[ebp], 1
$LN26@ChaosBoxMi:

; 174  : 			}
; 175  : 
; 176  : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(13,14) ) // Loch Feather

  00124	b9 0e 1a 00 00	 mov	 ecx, 6670		; 00001a0eH
  00129	66 3b c1	 cmp	 ax, cx
  0012c	0f 84 dc 00 00
	00		 je	 $LN23@ChaosBoxMi

; 177  : 			{
; 178  : 				return FALSE;
; 179  : 			}
; 180  : 
; 181  : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,53) )	// Charm Of Luck

  00132	ba 35 1c 00 00	 mov	 edx, 7221		; 00001c35H
  00137	66 3b c2	 cmp	 ax, dx
  0013a	75 0e		 jne	 SHORT $LN6@ChaosBoxMi

; 182  : 			{
; 183  : 				iCharmOfLuckCount += lpObj->pChaosBox[n].m_Durability;

  0013c	db 45 e0	 fild	 DWORD PTR _iCharmOfLuckCount$[ebp]
  0013f	d8 46 24	 fadd	 DWORD PTR [esi+36]
  00142	e8 00 00 00 00	 call	 __ftol2_sse
  00147	89 45 e0	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], eax
$LN6@ChaosBoxMi:

; 184  : 			}
; 185  : 
; 186  : 			if ( add != 0  )

  0014a	83 7d ec 00	 cmp	 DWORD PTR _add$[ebp], 0
  0014e	74 03		 je	 SHORT $LN5@ChaosBoxMi

; 187  : 			{
; 188  : 				ChaosItems++;

  00150	ff 45 e4	 inc	 DWORD PTR _ChaosItems$[ebp]
$LN5@ChaosBoxMi:

; 189  : 			}
; 190  : 
; 191  : 			ItemIsBufExOption(ExOption, &lpObj->pChaosBox[n]);

  00153	8d 45 f4	 lea	 eax, DWORD PTR _ExOption$[ebp]
  00156	56		 push	 esi
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 192  : 			LogAdd(LOG_BLACK, "[%s][%s] CBMix [%d,%s,%d,%d,%d,%d]serial:[%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d]",
; 193  : 				lpObj->AccountID, lpObj->Name, n, lpObj->pChaosBox[n].GetName(),
; 194  : 				lpObj->pChaosBox[n].m_Level, lpObj->pChaosBox[n].m_Option1,
; 195  : 				lpObj->pChaosBox[n].m_Option2, lpObj->pChaosBox[n].m_Option3,
; 196  : 				lpObj->pChaosBox[n].m_Number, (int)lpObj->pChaosBox[n].m_Durability,
; 197  : 				nv, ExOption[0], ExOption[1], ExOption[2], ExOption[3], ExOption[4], ExOption[5],
; 198  : 				ExOption[6], lpObj->pChaosBox[n].m_SetOption);

  0015d	8b 75 e8	 mov	 esi, DWORD PTR tv530[ebp]
  00160	03 b7 dc 0c 00
	00		 add	 esi, DWORD PTR [edi+3292]
  00166	0f b6 4d fa	 movzx	 ecx, BYTE PTR _ExOption$[ebp+6]
  0016a	0f b6 86 92 00
	00 00		 movzx	 eax, BYTE PTR [esi+146]
  00171	d9 46 24	 fld	 DWORD PTR [esi+36]
  00174	0f b6 55 f9	 movzx	 edx, BYTE PTR _ExOption$[ebp+5]
  00178	83 c4 08	 add	 esp, 8
  0017b	50		 push	 eax
  0017c	0f b6 45 f8	 movzx	 eax, BYTE PTR _ExOption$[ebp+4]
  00180	51		 push	 ecx
  00181	0f b6 4d f7	 movzx	 ecx, BYTE PTR _ExOption$[ebp+3]
  00185	52		 push	 edx
  00186	0f b6 55 f6	 movzx	 edx, BYTE PTR _ExOption$[ebp+2]
  0018a	50		 push	 eax
  0018b	0f b6 45 f5	 movzx	 eax, BYTE PTR _ExOption$[ebp+1]
  0018f	51		 push	 ecx
  00190	0f b6 4d f4	 movzx	 ecx, BYTE PTR _ExOption$[ebp]
  00194	52		 push	 edx
  00195	50		 push	 eax
  00196	51		 push	 ecx
  00197	53		 push	 ebx
  00198	e8 00 00 00 00	 call	 __ftol2_sse
  0019d	8b 16		 mov	 edx, DWORD PTR [esi]
  0019f	0f b6 4e 79	 movzx	 ecx, BYTE PTR [esi+121]
  001a3	50		 push	 eax
  001a4	0f b6 46 7a	 movzx	 eax, BYTE PTR [esi+122]
  001a8	52		 push	 edx
  001a9	0f b6 56 78	 movzx	 edx, BYTE PTR [esi+120]
  001ad	50		 push	 eax
  001ae	0f bf 46 08	 movsx	 eax, WORD PTR [esi+8]
  001b2	51		 push	 ecx
  001b3	52		 push	 edx
  001b4	50		 push	 eax
  001b5	8b ce		 mov	 ecx, esi
  001b7	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  001bc	8b 4d dc	 mov	 ecx, DWORD PTR _n$155602[ebp]
  001bf	50		 push	 eax
  001c0	51		 push	 ecx
  001c1	8d 57 6f	 lea	 edx, DWORD PTR [edi+111]
  001c4	52		 push	 edx
  001c5	8d 47 64	 lea	 eax, DWORD PTR [edi+100]
  001c8	50		 push	 eax
  001c9	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@LILHPMOA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5?$FL?$CFd?0?$CFs?0?$CFd?0?$CFd?0?$CFd?0?$CF@
  001ce	6a 00		 push	 0
  001d0	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001d5	8b 5d e0	 mov	 ebx, DWORD PTR _iCharmOfLuckCount$[ebp]
  001d8	8b 75 e8	 mov	 esi, DWORD PTR tv530[ebp]
  001db	83 c4 54	 add	 esp, 84			; 00000054H
$LN17@ChaosBoxMi:

; 141  : 
; 142  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  001de	ff 45 dc	 inc	 DWORD PTR _n$155602[ebp]
  001e1	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  001e7	89 75 e8	 mov	 DWORD PTR tv530[ebp], esi
  001ea	81 fe 00 15 00
	00		 cmp	 esi, 5376		; 00001500H
  001f0	0f 8c 6a fe ff
	ff		 jl	 $LL18@ChaosBoxMi

; 199  : 		
; 200  : 
; 201  : 
; 202  : 
; 203  : 		}
; 204  : 	}
; 205  : 
; 206  : 	if ( ChaosDiamond == 0 )

  001f6	33 c0		 xor	 eax, eax
  001f8	39 45 d8	 cmp	 DWORD PTR _ChaosDiamond$[ebp], eax
  001fb	75 03		 jne	 SHORT $LN4@ChaosBoxMi

; 207  : 	{
; 208  : 		value = 0;	// 0% of success

  001fd	89 45 f0	 mov	 DWORD PTR _value$[ebp], eax
$LN4@ChaosBoxMi:

; 209  : 	}
; 210  : 
; 211  : 	if ( ChaosItems < 2 )

  00200	83 7d e4 02	 cmp	 DWORD PTR _ChaosItems$[ebp], 2
  00204	7d 03		 jge	 SHORT $LN3@ChaosBoxMi

; 212  : 	{
; 213  : 		value = 0;// 0% of success

  00206	89 45 f0	 mov	 DWORD PTR _value$[ebp], eax
$LN3@ChaosBoxMi:

; 214  : 	}
; 215  : 
; 216  : 	if ( iCharmOfLuckCount > 10 )

  00209	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  0020c	7e 13		 jle	 SHORT $LN2@ChaosBoxMi
$LN23@ChaosBoxMi:
  0020e	5b		 pop	 ebx
  0020f	5f		 pop	 edi

; 217  : 		return FALSE;

  00210	33 c0		 xor	 eax, eax
  00212	5e		 pop	 esi

; 234  : 	return value;
; 235  : }

  00213	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00216	33 cd		 xor	 ecx, ebp
  00218	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021d	8b e5		 mov	 esp, ebp
  0021f	5d		 pop	 ebp
  00220	c3		 ret	 0
$LN2@ChaosBoxMi:

; 218  : 
; 219  : 
; 220  : 	
; 221  : 	lpObj->ChaosSuccessRate = value / 20000;

  00221	8b 75 f0	 mov	 esi, DWORD PTR _value$[ebp]
  00224	b8 ad 8b db 68	 mov	 eax, 1759218605		; 68db8badH
  00229	f7 ee		 imul	 esi
  0022b	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  0022e	8b c2		 mov	 eax, edx
  00230	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00233	03 c2		 add	 eax, edx

; 222  : 	lpObj->ChaosSuccessRate += iCharmOfLuckCount;

  00235	03 c3		 add	 eax, ebx
  00237	89 87 e8 0c 00
	00		 mov	 DWORD PTR [edi+3304], eax

; 223  : 
; 224  : 	if ( lpObj->ChaosSuccessRate  > 100 )

  0023d	83 f8 64	 cmp	 eax, 100		; 00000064H
  00240	7e 0a		 jle	 SHORT $LN1@ChaosBoxMi

; 225  : 	{
; 226  : 		lpObj->ChaosSuccessRate = 100;

  00242	c7 87 e8 0c 00
	00 64 00 00 00	 mov	 DWORD PTR [edi+3304], 100 ; 00000064H
$LN1@ChaosBoxMi:

; 227  : 	}
; 228  : 
; 229  : 	lpObj->ChaosMoney = lpObj->ChaosSuccessRate * 10000;	// Required Money to MIX anc createe a Chaos Item

  0024c	8b 8f e8 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3304]
  00252	8b c1		 mov	 eax, ecx
  00254	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H

; 230  : 
; 231  : 	LogAdd(LOG_BLACK, "[%s][%s] CBMix need Zen : %d SuccessRate : %d, CharmRate : %d",
; 232  : 		lpObj->AccountID, lpObj->Name, lpObj->ChaosMoney, 
; 233  : 		lpObj->ChaosSuccessRate, iCharmOfLuckCount);

  0025a	53		 push	 ebx
  0025b	51		 push	 ecx
  0025c	50		 push	 eax
  0025d	8d 57 6f	 lea	 edx, DWORD PTR [edi+111]
  00260	52		 push	 edx
  00261	89 87 e4 0c 00
	00		 mov	 DWORD PTR [edi+3300], eax
  00267	83 c7 64	 add	 edi, 100		; 00000064H
  0026a	57		 push	 edi
  0026b	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@PLIHJFD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5need?5Zen?5?3?5?$CFd?5Suc@
  00270	6a 00		 push	 0
  00272	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 234  : 	return value;
; 235  : }

  00277	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0027a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0027d	5b		 pop	 ebx
  0027e	5f		 pop	 edi
  0027f	8b c6		 mov	 eax, esi
  00281	33 cd		 xor	 ecx, ebp
  00283	5e		 pop	 esi
  00284	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c3		 ret	 0
?ChaosBoxMix@@YAHPAUOBJECTSTRUCT@@AAH@Z ENDP		; ChaosBoxMix
_TEXT	ENDS
PUBLIC	??_C@_0CI@FBGJBFGF@?$FLDevilSquare?$FN?5?$MA?L?$LK?$KF?F?$KO?5?$LA?f?G?$LA?5?$LP?d?C?$LL?5?$FL@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CBUPS_ItemRequest@@YAXHPAD0@Z			; CBUPS_ItemRequest
EXTRN	?SendData@WzUdp@@QAEHPAEK@Z:PROC		; WzUdp::SendData
EXTRN	?gUdpSocCE@@3VWzUdp@@A:BYTE			; gUdpSocCE
;	COMDAT ??_C@_0CI@FBGJBFGF@?$FLDevilSquare?$FN?5?$MA?L?$LK?$KF?F?$KO?5?$LA?f?G?$LA?5?$LP?d?C?$LL?5?$FL@
CONST	SEGMENT
??_C@_0CI@FBGJBFGF@?$FLDevilSquare?$FN?5?$MA?L?$LK?$KF?F?$KO?5?$LA?f?G?$LA?5?$LP?d?C?$LL?5?$FL@ DB '['
	DB	'DevilSquare] ', 0c0H, 0ccH, 0baH, 0a5H, 0c6H, 0aeH, ' ', 0b0H
	DB	0e6H, 0c7H, 0b0H, ' ', 0bfH, 0e4H, 0c3H, 0bbH, ' [%s][%s]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CBUPS_ItemRequest@@YAXHPAD0@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_AccountId$ = 12					; size = 4
_Name$ = 16						; size = 4
?CBUPS_ItemRequest@@YAXHPAD0@Z PROC			; CBUPS_ItemRequest, COMDAT

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _AccountId$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 10	 mov	 edi, DWORD PTR _Name$[ebp]

; 250  : 	LogAdd(LOG_BLACK, "[DevilSquare] 이벤트 경품 요청 [%s][%s]", AccountId, Name);	// #warning Translation

  00018	57		 push	 edi
  00019	56		 push	 esi
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FBGJBFGF@?$FLDevilSquare?$FN?5?$MA?L?$LK?$KF?F?$KO?5?$LA?f?G?$LA?5?$LP?d?C?$LL?5?$FL@
  0001f	6a 00		 push	 0
  00021	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 251  : 
; 252  : 	CB_PMSG_REQ_PRESENT pMsg;
; 253  : 
; 254  : 	pMsg.h.c = 0xC1;
; 255  : 	pMsg.h.headcode = 0x01;
; 256  : 	pMsg.h.size = sizeof(pMsg);
; 257  : 	pMsg.Sequence = aIndex;

  00026	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 258  : 	memcpy(pMsg.AccountId, AccountId, sizeof(pMsg.AccountId));

  00029	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002b	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002e	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  00031	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00035	89 4d e3	 mov	 DWORD PTR _pMsg$[ebp+3], ecx

; 259  : 	memcpy(pMsg.GameId, Name, sizeof(pMsg.GameId));

  00038	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0003a	83 c4 10	 add	 esp, 16			; 00000010H
  0003d	89 4d ed	 mov	 DWORD PTR _pMsg$[ebp+13], ecx
  00040	66 89 45 eb	 mov	 WORD PTR _pMsg$[ebp+11], ax
  00044	0f b7 47 08	 movzx	 eax, WORD PTR [edi+8]

; 260  : 
; 261  : 	gUdpSocCE.SendData((LPBYTE)&pMsg, pMsg.h.size);

  00048	6a 1c		 push	 28			; 0000001cH
  0004a	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0004d	89 55 e7	 mov	 DWORD PTR _pMsg$[ebp+7], edx
  00050	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00053	51		 push	 ecx
  00054	b9 00 00 00 00	 mov	 ecx, OFFSET ?gUdpSocCE@@3VWzUdp@@A ; gUdpSocCE
  00059	c6 45 e0 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H
  0005d	66 c7 45 e1 1c
	01		 mov	 WORD PTR _pMsg$[ebp+1], 284 ; 0000011cH
  00063	89 55 f1	 mov	 DWORD PTR _pMsg$[ebp+17], edx
  00066	66 89 45 f5	 mov	 WORD PTR _pMsg$[ebp+21], ax
  0006a	e8 00 00 00 00	 call	 ?SendData@WzUdp@@QAEHPAEK@Z ; WzUdp::SendData

; 262  : }

  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00072	5f		 pop	 edi
  00073	33 cd		 xor	 ecx, ebp
  00075	5e		 pop	 esi
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?CBUPS_ItemRequest@@YAXHPAD0@Z ENDP			; CBUPS_ItemRequest
_TEXT	ENDS
PUBLIC	??_C@_0DG@OBDBFEEN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Suc@ ; `string'
PUBLIC	??_C@_0DD@DJMFCPCF@?$FLDevilSquare?$FN?5Present?5Prize?5Noti@ ; `string'
PUBLIC	??_C@_0BM@KEGLNHFM@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL?$CFs?5?$DN?$DN?5?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	??_C@_0N@HLJBBJOF@ChaosBox?4cpp?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CBUPR_ItemRequestRecv@@YAXPAUCB_PMSG_REQ_PRESENT_RESULT@@@Z ; CBUPR_ItemRequestRecv
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	__imp__wsprintfA:PROC
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:BYTE			; gObj
EXTRN	?gObjIsConnectedGP@@YAHH@Z:PROC			; gObjIsConnectedGP
EXTRN	_memset:PROC
;	COMDAT ??_C@_0DG@OBDBFEEN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Suc@
CONST	SEGMENT
??_C@_0DG@OBDBFEEN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Suc@ DB '['
	DB	'DevilSquare] [%s][%s] CBMix Success %d Money : %d-%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@DJMFCPCF@?$FLDevilSquare?$FN?5Present?5Prize?5Noti@
CONST	SEGMENT
??_C@_0DD@DJMFCPCF@?$FLDevilSquare?$FN?5Present?5Prize?5Noti@ DB '[DevilS'
	DB	'quare] Present Prize Notice %d(%s) %d %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KEGLNHFM@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL?$CFs?5?$DN?$DN?5?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BM@KEGLNHFM@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL?$CFs?5?$DN?$DN?5?$CFs?$FN?$AA@ DB 'e'
	DB	'rror-L3 [%s][%d][%s == %s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ DB 'error-L'
	DB	'3 [%s][%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HLJBBJOF@ChaosBox?4cpp?$AA@
CONST	SEGMENT
??_C@_0N@HLJBBJOF@ChaosBox?4cpp?$AA@ DB 'ChaosBox.cpp', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CBUPR_ItemRequestRecv@@YAXPAUCB_PMSG_REQ_PRESENT_RESULT@@@Z
_TEXT	SEGMENT
tv335 = -396						; size = 4
tv332 = -392						; size = 4
_aIndex$ = -388						; size = 4
_pMsg$ = -384						; size = 36
_pMsg$155686 = -348					; size = 11
_szTemp$155683 = -336					; size = 256
_szPresentName$ = -80					; size = 51
_szName$ = -28						; size = 11
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?CBUPR_ItemRequestRecv@@YAXPAUCB_PMSG_REQ_PRESENT_RESULT@@@Z PROC ; CBUPR_ItemRequestRecv, COMDAT

; 296  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi

; 297  : 	LPOBJ lpObj;
; 298  : 	char szId[11];
; 299  : 	char szName[11];
; 300  : 	char szPresentName[51];
; 301  : 	int aIndex;
; 302  : 	PMSG_PRIZE_INFO pMsg;
; 303  : 
; 304  : 	szId[10] = 0;
; 305  : 	szName[10] = 0;
; 306  : 	memset(szPresentName, 0, sizeof(szPresentName));

  00019	6a 33		 push	 51			; 00000033H
  0001b	8d 45 b0	 lea	 eax, DWORD PTR _szPresentName$[ebp]
  0001e	6a 00		 push	 0
  00020	50		 push	 eax
  00021	c6 45 fa 00	 mov	 BYTE PTR _szId$[ebp+10], 0
  00025	c6 45 ee 00	 mov	 BYTE PTR _szName$[ebp+10], 0
  00029	e8 00 00 00 00	 call	 _memset

; 307  : 	memcpy(szId, lpMsg->AccountId, sizeof(lpMsg->AccountId));

  0002e	8b 4b 03	 mov	 ecx, DWORD PTR [ebx+3]
  00031	0f b7 43 0b	 movzx	 eax, WORD PTR [ebx+11]
  00035	8b 53 07	 mov	 edx, DWORD PTR [ebx+7]
  00038	89 4d f0	 mov	 DWORD PTR _szId$[ebp], ecx

; 308  : 	memcpy(szName, lpMsg->GameId, sizeof(lpMsg->GameId));

  0003b	8b 4b 0d	 mov	 ecx, DWORD PTR [ebx+13]
  0003e	89 4d e4	 mov	 DWORD PTR _szName$[ebp], ecx

; 309  : 	memcpy(szPresentName, lpMsg->presentname, sizeof(lpMsg->presentname));

  00041	8d 73 1d	 lea	 esi, DWORD PTR [ebx+29]
  00044	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00049	8d 7d b0	 lea	 edi, DWORD PTR _szPresentName$[ebp]
  0004c	f3 a5		 rep movsd
  0004e	66 89 45 f8	 mov	 WORD PTR _szId$[ebp+8], ax
  00052	0f b7 43 15	 movzx	 eax, WORD PTR [ebx+21]
  00056	66 a5		 movsw

; 310  : 	aIndex = lpMsg->Sequence;

  00058	8b 73 18	 mov	 esi, DWORD PTR [ebx+24]
  0005b	89 55 f4	 mov	 DWORD PTR _szId$[ebp+4], edx
  0005e	8b 53 11	 mov	 edx, DWORD PTR [ebx+17]

; 311  : 
; 312  : 	if (gObjIsConnectedGP(aIndex) == FALSE )

  00061	56		 push	 esi
  00062	89 55 e8	 mov	 DWORD PTR _szName$[ebp+4], edx
  00065	66 89 45 ec	 mov	 WORD PTR _szName$[ebp+8], ax
  00069	89 b5 7c fe ff
	ff		 mov	 DWORD PTR _aIndex$[ebp], esi
  0006f	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00074	83 c4 10	 add	 esp, 16			; 00000010H
  00077	85 c0		 test	 eax, eax
  00079	75 2a		 jne	 SHORT $LN5@CBUPR_Item

; 313  : 	{
; 314  : 		LogAdd(LOG_RED,  "error-L3 [%s][%d]", __FILE__, __LINE__);

  0007b	68 3a 01 00 00	 push	 314			; 0000013aH
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HLJBBJOF@ChaosBox?4cpp?$AA@
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  0008a	6a 01		 push	 1
  0008c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00091	83 c4 10	 add	 esp, 16			; 00000010H
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx

; 375  : 	}
; 376  : }

  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	33 cd		 xor	 ecx, ebp
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
$LN5@CBUPR_Item:

; 315  : 		return;
; 316  : 	}
; 317  : 
; 318  : 	lpObj = &gObj[aIndex];

  000a5	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000ab	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 319  : 
; 320  : 	if ( strcmp(szId, lpObj->AccountID) != 0 )

  000b1	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  000b4	89 95 78 fe ff
	ff		 mov	 DWORD PTR tv332[ebp], edx
  000ba	8b fa		 mov	 edi, edx
  000bc	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  000bf	90		 npad	 1
$LL8@CBUPR_Item:
  000c0	8a 08		 mov	 cl, BYTE PTR [eax]
  000c2	3a 0f		 cmp	 cl, BYTE PTR [edi]
  000c4	75 1a		 jne	 SHORT $LN9@CBUPR_Item
  000c6	84 c9		 test	 cl, cl
  000c8	74 12		 je	 SHORT $LN10@CBUPR_Item
  000ca	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000cd	3a 4f 01	 cmp	 cl, BYTE PTR [edi+1]
  000d0	75 0e		 jne	 SHORT $LN9@CBUPR_Item
  000d2	83 c0 02	 add	 eax, 2
  000d5	83 c7 02	 add	 edi, 2
  000d8	84 c9		 test	 cl, cl
  000da	75 e4		 jne	 SHORT $LL8@CBUPR_Item
$LN10@CBUPR_Item:
  000dc	33 c0		 xor	 eax, eax
  000de	eb 05		 jmp	 SHORT $LN11@CBUPR_Item
$LN9@CBUPR_Item:
  000e0	1b c0		 sbb	 eax, eax
  000e2	83 d8 ff	 sbb	 eax, -1
$LN11@CBUPR_Item:
  000e5	85 c0		 test	 eax, eax
  000e7	74 2f		 je	 SHORT $LN4@CBUPR_Item

; 321  : 	{
; 322  : 		LogAdd(LOG_RED,  "error-L3 [%s][%d][%s == %s]", __FILE__, __LINE__, szId, lpObj->AccountID);

  000e9	52		 push	 edx
  000ea	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  000ed	51		 push	 ecx
  000ee	68 42 01 00 00	 push	 322			; 00000142H
  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HLJBBJOF@ChaosBox?4cpp?$AA@
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KEGLNHFM@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL?$CFs?5?$DN?$DN?5?$CFs?$FN?$AA@
  000fd	6a 01		 push	 1
  000ff	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00104	83 c4 18	 add	 esp, 24			; 00000018H
  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx

; 375  : 	}
; 376  : }

  0010a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010d	33 cd		 xor	 ecx, ebp
  0010f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c3		 ret	 0
$LN4@CBUPR_Item:

; 323  : 		return;
; 324  : 	}
; 325  : 
; 326  : 	if ( strcmp(szName, lpObj->Name) != 0 )

  00118	8d 7e 6f	 lea	 edi, DWORD PTR [esi+111]
  0011b	89 bd 74 fe ff
	ff		 mov	 DWORD PTR tv335[ebp], edi
  00121	8d 45 e4	 lea	 eax, DWORD PTR _szName$[ebp]
$LL12@CBUPR_Item:
  00124	8a 08		 mov	 cl, BYTE PTR [eax]
  00126	3a 0f		 cmp	 cl, BYTE PTR [edi]
  00128	75 1a		 jne	 SHORT $LN13@CBUPR_Item
  0012a	84 c9		 test	 cl, cl
  0012c	74 12		 je	 SHORT $LN14@CBUPR_Item
  0012e	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00131	3a 4f 01	 cmp	 cl, BYTE PTR [edi+1]
  00134	75 0e		 jne	 SHORT $LN13@CBUPR_Item
  00136	83 c0 02	 add	 eax, 2
  00139	83 c7 02	 add	 edi, 2
  0013c	84 c9		 test	 cl, cl
  0013e	75 e4		 jne	 SHORT $LL12@CBUPR_Item
$LN14@CBUPR_Item:
  00140	33 c0		 xor	 eax, eax
  00142	eb 05		 jmp	 SHORT $LN15@CBUPR_Item
$LN13@CBUPR_Item:
  00144	1b c0		 sbb	 eax, eax
  00146	83 d8 ff	 sbb	 eax, -1
$LN15@CBUPR_Item:
  00149	85 c0		 test	 eax, eax
  0014b	74 2a		 je	 SHORT $LN3@CBUPR_Item

; 327  : 	{
; 328  : 		LogAdd(LOG_RED,  "error-L3 [%s][%d]", __FILE__, __LINE__);

  0014d	68 48 01 00 00	 push	 328			; 00000148H
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HLJBBJOF@ChaosBox?4cpp?$AA@
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  0015c	6a 01		 push	 1
  0015e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00163	83 c4 10	 add	 esp, 16			; 00000010H
  00166	5f		 pop	 edi
  00167	5e		 pop	 esi
  00168	5b		 pop	 ebx

; 375  : 	}
; 376  : }

  00169	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016c	33 cd		 xor	 ecx, ebp
  0016e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00173	8b e5		 mov	 esp, ebp
  00175	5d		 pop	 ebp
  00176	c3		 ret	 0
$LN3@CBUPR_Item:

; 329  : 		return;
; 330  : 	}
; 331  : 
; 332  : 	if ( lpMsg->present != -1 )

  00177	80 7b 1c ff	 cmp	 BYTE PTR [ebx+28], -1
  0017b	0f 84 7c 01 00
	00		 je	 $LN2@CBUPR_Item

; 333  : 	{
; 334  : 		char szTemp[256]="";

  00181	68 ff 00 00 00	 push	 255			; 000000ffH
  00186	8d 95 b1 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$155683[ebp+1]
  0018c	6a 00		 push	 0
  0018e	52		 push	 edx
  0018f	c6 85 b0 fe ff
	ff 00		 mov	 BYTE PTR _szTemp$155683[ebp], 0
  00196	e8 00 00 00 00	 call	 _memset
  0019b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 335  : 
; 336  : 		wsprintf(szTemp, lMsg.Get(MSGGET(6, 65)), szName, szPresentName);

  0019e	8d 45 b0	 lea	 eax, DWORD PTR _szPresentName$[ebp]
  001a1	50		 push	 eax
  001a2	8d 4d e4	 lea	 ecx, DWORD PTR _szName$[ebp]
  001a5	51		 push	 ecx
  001a6	68 41 06 00 00	 push	 1601			; 00000641H
  001ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001b0	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001b5	50		 push	 eax
  001b6	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$155683[ebp]
  001bc	52		 push	 edx
  001bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 337  : 		AllSendServerMsg(szTemp);

  001c3	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$155683[ebp]
  001c9	50		 push	 eax
  001ca	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg

; 338  : 
; 339  : 		pMsg.h.c = 0xC1;
; 340  : 		pMsg.h.headcode = 0x02;
; 341  : 		pMsg.h.size = sizeof(pMsg);
; 342  : 		pMsg.present = lpMsg->present;
; 343  : 		pMsg.Seq_present = lpMsg->Seq_present;
; 344  : 		pMsg.servernumber = gGameServerCode;

  001cf	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  001d6	8a 4b 1c	 mov	 cl, BYTE PTR [ebx+28]
  001d9	8b 53 50	 mov	 edx, DWORD PTR [ebx+80]
  001dc	88 8d 9c fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+28], cl

; 345  : 		memcpy(pMsg.AccountID, lpMsg->AccountId, sizeof(pMsg.AccountID));

  001e2	8b 4b 03	 mov	 ecx, DWORD PTR [ebx+3]
  001e5	89 85 98 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+24], eax
  001eb	0f b7 43 0b	 movzx	 eax, WORD PTR [ebx+11]
  001ef	89 8d 83 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+3], ecx

; 346  : 		memcpy(pMsg.GameID, lpMsg->GameId, sizeof(pMsg.GameID));

  001f5	8b 4b 0d	 mov	 ecx, DWORD PTR [ebx+13]
  001f8	83 c4 14	 add	 esp, 20			; 00000014H
  001fb	89 95 a0 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+32], edx
  00201	8b 53 07	 mov	 edx, DWORD PTR [ebx+7]
  00204	89 8d 8d fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+13], ecx
  0020a	66 89 85 8b fe
	ff ff		 mov	 WORD PTR _pMsg$[ebp+11], ax
  00211	0f b7 43 15	 movzx	 eax, WORD PTR [ebx+21]

; 347  : 
; 348  : 		gUdpSocCE.SendData((LPBYTE)&pMsg, pMsg.h.size);

  00215	6a 24		 push	 36			; 00000024H
  00217	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0021d	89 95 87 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+7], edx
  00223	8b 53 11	 mov	 edx, DWORD PTR [ebx+17]
  00226	51		 push	 ecx
  00227	b9 00 00 00 00	 mov	 ecx, OFFSET ?gUdpSocCE@@3VWzUdp@@A ; gUdpSocCE
  0022c	c6 85 80 fe ff
	ff c1		 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H
  00233	66 c7 85 81 fe
	ff ff 24 02	 mov	 WORD PTR _pMsg$[ebp+1], 548 ; 00000224H
  0023c	89 95 91 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+17], edx
  00242	66 89 85 95 fe
	ff ff		 mov	 WORD PTR _pMsg$[ebp+21], ax
  00249	e8 00 00 00 00	 call	 ?SendData@WzUdp@@QAEHPAEK@Z ; WzUdp::SendData

; 349  : 
; 350  : 		LogAdd(LOG_BLACK, "[DevilSquare] Present Prize Notice %d(%s) %d %s %s",
; 351  : 			lpMsg->present, szPresentName, lpMsg->Seq_present, szId, szName);

  0024e	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  00251	8d 55 e4	 lea	 edx, DWORD PTR _szName$[ebp]
  00254	52		 push	 edx
  00255	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  00258	50		 push	 eax
  00259	0f be 43 1c	 movsx	 eax, BYTE PTR [ebx+28]
  0025d	51		 push	 ecx
  0025e	8d 55 b0	 lea	 edx, DWORD PTR _szPresentName$[ebp]
  00261	52		 push	 edx
  00262	50		 push	 eax
  00263	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@DJMFCPCF@?$FLDevilSquare?$FN?5Present?5Prize?5Noti@
  00268	6a 00		 push	 0
  0026a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 352  : 
; 353  : 		ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, 0x1FF, 0, 255, 0, 0, 0, -1, 0, 0);

  0026f	6a 00		 push	 0
  00271	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00273	6a 00		 push	 0
  00275	6a ff		 push	 -1
  00277	6a 00		 push	 0
  00279	6a 00		 push	 0
  0027b	6a 00		 push	 0
  0027d	68 ff 00 00 00	 push	 255			; 000000ffH
  00282	6a 00		 push	 0
  00284	68 ff 01 00 00	 push	 511			; 000001ffH
  00289	6a 00		 push	 0
  0028b	6a 00		 push	 0
  0028d	68 ff 00 00 00	 push	 255			; 000000ffH
  00292	51		 push	 ecx
  00293	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 354  : 		lpObj->Money -= 10000;
; 355  : 		GCMoneySend(lpObj->m_Index, lpObj->Money);

  00298	8b 16		 mov	 edx, DWORD PTR [esi]
  0029a	83 c4 50	 add	 esp, 80			; 00000050H
  0029d	81 86 b0 00 00
	00 f0 d8 ff ff	 add	 DWORD PTR [esi+176], -10000 ; ffffd8f0H
  002a7	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  002ad	50		 push	 eax
  002ae	52		 push	 edx
  002af	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 356  : 
; 357  : 		PMSG_CHAOSMIXRESULT pMsg;
; 358  : 
; 359  : 		PHeadSetB((LPBYTE)&pMsg, 0x86, sizeof(pMsg));

  002b4	6a 0b		 push	 11			; 0000000bH
  002b6	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$155686[ebp]
  002bc	68 86 00 00 00	 push	 134			; 00000086H
  002c1	50		 push	 eax
  002c2	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 360  : 		pMsg.Result = 5;
; 361  : 
; 362  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  002c7	0f b6 8d a5 fe
	ff ff		 movzx	 ecx, BYTE PTR _pMsg$155686[ebp+1]
  002ce	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  002d4	51		 push	 ecx
  002d5	8d 95 a4 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$155686[ebp]
  002db	52		 push	 edx
  002dc	50		 push	 eax
  002dd	c6 85 a7 fe ff
	ff 05		 mov	 BYTE PTR _pMsg$155686[ebp+3], 5
  002e4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002e9	83 c4 20	 add	 esp, 32			; 00000020H
  002ec	5f		 pop	 edi
  002ed	5e		 pop	 esi
  002ee	5b		 pop	 ebx

; 375  : 	}
; 376  : }

  002ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f2	33 cd		 xor	 ecx, ebp
  002f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f9	8b e5		 mov	 esp, ebp
  002fb	5d		 pop	 ebp
  002fc	c3		 ret	 0
$LN2@CBUPR_Item:

; 363  : 	}
; 364  : 	else
; 365  : 	{
; 366  : 		int in = ITEMGET(14,19); // Devil Square Invitation
; 367  : 		ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, in, 0, 0, 0, 0, 0, -1, 0, 0);

  002fd	6a 00		 push	 0
  002ff	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00301	6a 00		 push	 0
  00303	6a ff		 push	 -1
  00305	6a 00		 push	 0
  00307	6a 00		 push	 0
  00309	6a 00		 push	 0
  0030b	6a 00		 push	 0
  0030d	6a 00		 push	 0
  0030f	68 13 1c 00 00	 push	 7187			; 00001c13H
  00314	6a 00		 push	 0
  00316	6a 00		 push	 0
  00318	68 ff 00 00 00	 push	 255			; 000000ffH
  0031d	51		 push	 ecx
  0031e	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 368  : 		lpObj->Money -= 10000;

  00323	81 86 b0 00 00
	00 f0 d8 ff ff	 add	 DWORD PTR [esi+176], -10000 ; ffffd8f0H
  0032d	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]

; 369  : 		GCMoneySend(lpObj->m_Index, lpObj->Money);

  00333	8b 16		 mov	 edx, DWORD PTR [esi]
  00335	50		 push	 eax
  00336	52		 push	 edx
  00337	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 370  : 		lpObj->ChaosLock = FALSE;
; 371  : 
; 372  : 		LogAdd(LOG_BLACK, "[DevilSquare] [%s][%s] CBMix Success %d Money : %d-%d",
; 373  : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate,
; 374  : 			lpObj->Money, lpObj->ChaosMoney);

  0033c	8b 86 e4 0c 00
	00		 mov	 eax, DWORD PTR [esi+3300]
  00342	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  00348	8b 96 e8 0c 00
	00		 mov	 edx, DWORD PTR [esi+3304]
  0034e	50		 push	 eax
  0034f	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR tv335[ebp]
  00355	51		 push	 ecx
  00356	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR tv332[ebp]
  0035c	52		 push	 edx
  0035d	50		 push	 eax
  0035e	51		 push	 ecx
  0035f	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@OBDBFEEN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Suc@
  00364	6a 00		 push	 0
  00366	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  00370	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 375  : 	}
; 376  : }

  00375	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00378	83 c4 58	 add	 esp, 88			; 00000058H
  0037b	5f		 pop	 edi
  0037c	5e		 pop	 esi
  0037d	33 cd		 xor	 ecx, ebp
  0037f	5b		 pop	 ebx
  00380	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00385	8b e5		 mov	 esp, ebp
  00387	5d		 pop	 ebp
  00388	c3		 ret	 0
?CBUPR_ItemRequestRecv@@YAXPAUCB_PMSG_REQ_PRESENT_RESULT@@@Z ENDP ; CBUPR_ItemRequestRecv
_TEXT	ENDS
PUBLIC	??_C@_0GG@KBCKFEB@?$FLDevilSquare?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogDQChaosItem@@YAXPAUOBJECTSTRUCT@@@Z		; LogDQChaosItem
;	COMDAT ??_C@_0GG@KBCKFEB@?$FLDevilSquare?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@
CONST	SEGMENT
??_C@_0GG@KBCKFEB@?$FLDevilSquare?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@ DB '['
	DB	'DevilSquare,%d] [%s][%s] CBMix [%d,%s,%d,%d,%d,%d]serial:[%d]'
	DB	'[%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LogDQChaosItem@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$155739 = -16						; size = 4
_ExOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?LogDQChaosItem@@YAXPAUOBJECTSTRUCT@@@Z PROC		; LogDQChaosItem, COMDAT

; 498  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi

; 499  : 	BYTE ExOption[MAX_EXOPTION_SIZE];
; 500  : 
; 501  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00016	33 ff		 xor	 edi, edi
  00018	89 7d f0	 mov	 DWORD PTR _n$155739[ebp], edi
  0001b	eb 03 8d 49 00	 npad	 5
$LL4@LogDQChaos:

; 502  : 	{
; 503  : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00020	8b 8b dc 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3292]
  00026	03 cf		 add	 ecx, edi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	0f 85 9a 00 00
	00		 jne	 $LN3@LogDQChaos

; 504  : 		{
; 505  : 			::ItemIsBufExOption(ExOption, &lpObj->pChaosBox[n] );

  00036	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  0003c	03 c7		 add	 eax, edi
  0003e	50		 push	 eax
  0003f	8d 4d f4	 lea	 ecx, DWORD PTR _ExOption$[ebp]
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 506  : 
; 507  : 			LogAdd(LOG_BLACK, "[DevilSquare,%d] [%s][%s] CBMix [%d,%s,%d,%d,%d,%d]serial:[%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 508  : 				lpObj->pChaosBox[n].m_Level,
; 509  : 				lpObj->AccountID, lpObj->Name, n, lpObj->pChaosBox[n].GetName(), lpObj->pChaosBox[n].m_Level,
; 510  : 				lpObj->pChaosBox[n].m_Option1, lpObj->pChaosBox[n].m_Option2, lpObj->pChaosBox[n].m_Option3, 
; 511  : 				lpObj->pChaosBox[n].m_Number, (int)lpObj->pChaosBox[n].m_Durability, 
; 512  : 				ExOption[0], ExOption[1], ExOption[2], ExOption[3], ExOption[4], ExOption[5], ExOption[6],
; 513  : 				lpObj->pChaosBox[n].m_SetOption);

  00048	8b 93 dc 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3292]
  0004e	0f b6 84 17 92
	00 00 00	 movzx	 eax, BYTE PTR [edi+edx+146]
  00056	d9 44 17 24	 fld	 DWORD PTR [edi+edx+36]
  0005a	0f b6 4d fa	 movzx	 ecx, BYTE PTR _ExOption$[ebp+6]
  0005e	8d 34 17	 lea	 esi, DWORD PTR [edi+edx]
  00061	0f b6 55 f9	 movzx	 edx, BYTE PTR _ExOption$[ebp+5]
  00065	83 c4 08	 add	 esp, 8
  00068	50		 push	 eax
  00069	0f b6 45 f8	 movzx	 eax, BYTE PTR _ExOption$[ebp+4]
  0006d	51		 push	 ecx
  0006e	0f b6 4d f7	 movzx	 ecx, BYTE PTR _ExOption$[ebp+3]
  00072	52		 push	 edx
  00073	0f b6 55 f6	 movzx	 edx, BYTE PTR _ExOption$[ebp+2]
  00077	50		 push	 eax
  00078	0f b6 45 f5	 movzx	 eax, BYTE PTR _ExOption$[ebp+1]
  0007c	51		 push	 ecx
  0007d	0f b6 4d f4	 movzx	 ecx, BYTE PTR _ExOption$[ebp]
  00081	52		 push	 edx
  00082	50		 push	 eax
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 __ftol2_sse
  00089	8b 16		 mov	 edx, DWORD PTR [esi]
  0008b	0f b6 4e 79	 movzx	 ecx, BYTE PTR [esi+121]
  0008f	50		 push	 eax
  00090	0f b6 46 7a	 movzx	 eax, BYTE PTR [esi+122]
  00094	52		 push	 edx
  00095	0f b6 56 78	 movzx	 edx, BYTE PTR [esi+120]
  00099	50		 push	 eax
  0009a	0f bf 46 08	 movsx	 eax, WORD PTR [esi+8]
  0009e	51		 push	 ecx
  0009f	52		 push	 edx
  000a0	50		 push	 eax
  000a1	8b ce		 mov	 ecx, esi
  000a3	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000a8	8b 4d f0	 mov	 ecx, DWORD PTR _n$155739[ebp]
  000ab	50		 push	 eax
  000ac	51		 push	 ecx
  000ad	8b 8b dc 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3292]
  000b3	8d 53 6f	 lea	 edx, DWORD PTR [ebx+111]
  000b6	52		 push	 edx
  000b7	0f bf 54 0f 08	 movsx	 edx, WORD PTR [edi+ecx+8]
  000bc	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  000bf	50		 push	 eax
  000c0	52		 push	 edx
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@KBCKFEB@?$FLDevilSquare?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@
  000c6	6a 00		 push	 0
  000c8	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000cd	83 c4 54	 add	 esp, 84			; 00000054H
$LN3@LogDQChaos:

; 499  : 	BYTE ExOption[MAX_EXOPTION_SIZE];
; 500  : 
; 501  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  000d0	ff 45 f0	 inc	 DWORD PTR _n$155739[ebp]
  000d3	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  000d9	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  000df	0f 8c 3b ff ff
	ff		 jl	 $LL4@LogDQChaos

; 514  : 		}
; 515  : 	}
; 516  : }

  000e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	33 cd		 xor	 ecx, ebp
  000ec	5b		 pop	 ebx
  000ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c3		 ret	 0
?LogDQChaosItem@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; LogDQChaosItem
_TEXT	ENDS
PUBLIC	??_C@_0GI@EHFMHMBI@?$FLPlusItemLevel?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMi@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogPlusItemLevelChaosItem@@YAXPAUOBJECTSTRUCT@@H@Z ; LogPlusItemLevelChaosItem
;	COMDAT ??_C@_0GI@EHFMHMBI@?$FLPlusItemLevel?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMi@
CONST	SEGMENT
??_C@_0GI@EHFMHMBI@?$FLPlusItemLevel?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMi@ DB '['
	DB	'PlusItemLevel,%d] [%s][%s] CBMix [%d,%s,%d,%d,%d,%d]serial:[%'
	DB	'd][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LogPlusItemLevelChaosItem@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_n$155800 = -20						; size = 4
_iMixLevel$ = -16					; size = 4
_ExOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iPlusMixLevel$ = 12					; size = 4
?LogPlusItemLevelChaosItem@@YAXPAUOBJECTSTRUCT@@H@Z PROC ; LogPlusItemLevelChaosItem, COMDAT

; 670  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 671  : 	int iMixLevel = 0;

  00012	33 db		 xor	 ebx, ebx
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00018	89 5d f0	 mov	 DWORD PTR _iMixLevel$[ebp], ebx

; 672  : 	BYTE ExOption[MAX_EXOPTION_SIZE];
; 673  : 
; 674  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  0001b	89 5d ec	 mov	 DWORD PTR _n$155800[ebp], ebx
  0001e	8b ff		 npad	 2
$LL11@LogPlusIte:

; 675  : 	{
; 676  : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00020	8b 8f dc 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3292]
  00026	03 cb		 add	 ecx, ebx
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	0f 85 cb 00 00
	00		 jne	 $LN10@LogPlusIte

; 677  : 		{
; 678  : 			::ItemIsBufExOption(ExOption, &lpObj->pChaosBox[n]);

  00036	8b 87 dc 0c 00
	00		 mov	 eax, DWORD PTR [edi+3292]
  0003c	03 c3		 add	 eax, ebx
  0003e	50		 push	 eax
  0003f	8d 4d f4	 lea	 ecx, DWORD PTR _ExOption$[ebp]
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 679  : 
; 680  : 			if ( iPlusMixLevel == 3 )

  00048	8b 45 0c	 mov	 eax, DWORD PTR _iPlusMixLevel$[ebp]
  0004b	83 c4 08	 add	 esp, 8
  0004e	83 f8 03	 cmp	 eax, 3
  00051	75 09		 jne	 SHORT $LN7@LogPlusIte

; 681  : 				iMixLevel = 1;

  00053	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _iMixLevel$[ebp], 1
  0005a	eb 28		 jmp	 SHORT $LN1@LogPlusIte
$LN7@LogPlusIte:

; 682  : 			else if ( iPlusMixLevel == 4 )

  0005c	83 f8 04	 cmp	 eax, 4
  0005f	75 09		 jne	 SHORT $LN5@LogPlusIte

; 683  : 				iMixLevel = 2;

  00061	c7 45 f0 02 00
	00 00		 mov	 DWORD PTR _iMixLevel$[ebp], 2
  00068	eb 1a		 jmp	 SHORT $LN1@LogPlusIte
$LN5@LogPlusIte:

; 684  : 			else if ( iPlusMixLevel == 22 )

  0006a	83 f8 16	 cmp	 eax, 22			; 00000016H
  0006d	75 09		 jne	 SHORT $LN3@LogPlusIte

; 685  : 				iMixLevel = 3;

  0006f	c7 45 f0 03 00
	00 00		 mov	 DWORD PTR _iMixLevel$[ebp], 3
  00076	eb 0c		 jmp	 SHORT $LN1@LogPlusIte
$LN3@LogPlusIte:

; 686  : 			else if ( iPlusMixLevel == 23 )

  00078	83 f8 17	 cmp	 eax, 23			; 00000017H
  0007b	75 07		 jne	 SHORT $LN1@LogPlusIte

; 687  : 				iMixLevel = 4;

  0007d	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR _iMixLevel$[ebp], 4
$LN1@LogPlusIte:

; 688  : 
; 689  : 			LogAdd(LOG_BLACK, "[PlusItemLevel,%d] [%s][%s] CBMix [%d,%s,%d,%d,%d,%d]serial:[%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]", iMixLevel,
; 690  : 				lpObj->AccountID, lpObj->Name, n, lpObj->pChaosBox[n].GetName(), lpObj->pChaosBox[n].m_Level,
; 691  : 				lpObj->pChaosBox[n].m_Option1, lpObj->pChaosBox[n].m_Option2, lpObj->pChaosBox[n].m_Option3, 
; 692  : 				lpObj->pChaosBox[n].m_Number, (int)lpObj->pChaosBox[n].m_Durability, 
; 693  : 				ExOption[0], ExOption[1], ExOption[2], ExOption[3], ExOption[4], ExOption[5], ExOption[6], lpObj->pChaosBox[n].m_SetOption);

  00084	8b 97 dc 0c 00
	00		 mov	 edx, DWORD PTR [edi+3292]
  0008a	0f b6 84 13 92
	00 00 00	 movzx	 eax, BYTE PTR [ebx+edx+146]
  00092	d9 44 13 24	 fld	 DWORD PTR [ebx+edx+36]
  00096	0f b6 4d fa	 movzx	 ecx, BYTE PTR _ExOption$[ebp+6]
  0009a	8d 34 13	 lea	 esi, DWORD PTR [ebx+edx]
  0009d	0f b6 55 f9	 movzx	 edx, BYTE PTR _ExOption$[ebp+5]
  000a1	50		 push	 eax
  000a2	0f b6 45 f8	 movzx	 eax, BYTE PTR _ExOption$[ebp+4]
  000a6	51		 push	 ecx
  000a7	0f b6 4d f7	 movzx	 ecx, BYTE PTR _ExOption$[ebp+3]
  000ab	52		 push	 edx
  000ac	0f b6 55 f6	 movzx	 edx, BYTE PTR _ExOption$[ebp+2]
  000b0	50		 push	 eax
  000b1	0f b6 45 f5	 movzx	 eax, BYTE PTR _ExOption$[ebp+1]
  000b5	51		 push	 ecx
  000b6	0f b6 4d f4	 movzx	 ecx, BYTE PTR _ExOption$[ebp]
  000ba	52		 push	 edx
  000bb	50		 push	 eax
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 __ftol2_sse
  000c2	8b 16		 mov	 edx, DWORD PTR [esi]
  000c4	0f b6 4e 79	 movzx	 ecx, BYTE PTR [esi+121]
  000c8	50		 push	 eax
  000c9	0f b6 46 7a	 movzx	 eax, BYTE PTR [esi+122]
  000cd	52		 push	 edx
  000ce	0f b6 56 78	 movzx	 edx, BYTE PTR [esi+120]
  000d2	50		 push	 eax
  000d3	0f bf 46 08	 movsx	 eax, WORD PTR [esi+8]
  000d7	51		 push	 ecx
  000d8	52		 push	 edx
  000d9	50		 push	 eax
  000da	8b ce		 mov	 ecx, esi
  000dc	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000e1	8b 4d ec	 mov	 ecx, DWORD PTR _n$155800[ebp]
  000e4	50		 push	 eax
  000e5	51		 push	 ecx
  000e6	8b 4d f0	 mov	 ecx, DWORD PTR _iMixLevel$[ebp]
  000e9	8d 57 6f	 lea	 edx, DWORD PTR [edi+111]
  000ec	52		 push	 edx
  000ed	8d 47 64	 lea	 eax, DWORD PTR [edi+100]
  000f0	50		 push	 eax
  000f1	51		 push	 ecx
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@EHFMHMBI@?$FLPlusItemLevel?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMi@
  000f7	6a 00		 push	 0
  000f9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000fe	83 c4 54	 add	 esp, 84			; 00000054H
$LN10@LogPlusIte:

; 672  : 	BYTE ExOption[MAX_EXOPTION_SIZE];
; 673  : 
; 674  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00101	ff 45 ec	 inc	 DWORD PTR _n$155800[ebp]
  00104	81 c3 a8 00 00
	00		 add	 ebx, 168		; 000000a8H
  0010a	81 fb 00 15 00
	00		 cmp	 ebx, 5376		; 00001500H
  00110	0f 8c 0a ff ff
	ff		 jl	 $LL11@LogPlusIte

; 694  : 		}
; 695  : 	}
; 696  : }

  00116	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	33 cd		 xor	 ecx, ebp
  0011d	5b		 pop	 ebx
  0011e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
?LogPlusItemLevelChaosItem@@YAXPAUOBJECTSTRUCT@@H@Z ENDP ; LogPlusItemLevelChaosItem
_TEXT	ENDS
PUBLIC	??_C@_0FK@PNAJDFDA@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5?$FL?$CFd?0?$CFs?0?$CFd?0?$CFd@ ; `string'
PUBLIC	_sLogType$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z	; LogChaosItem
;	COMDAT ??_C@_0FK@PNAJDFDA@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5?$FL?$CFd?0?$CFs?0?$CFd?0?$CFd@
CONST	SEGMENT
??_C@_0FK@PNAJDFDA@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5?$FL?$CFd?0?$CFs?0?$CFd?0?$CFd@ DB '['
	DB	'%s] [%s][%s] CBMix [%d,%s,%d,%d,%d,%d]serial:[%d][%d] Ex:[%d,'
	DB	'%d,%d,%d,%d,%d,%d] Set:[%d]', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z
_TEXT	SEGMENT
_sLogType$GSCopy$ = -20					; size = 4
_n$155819 = -16						; size = 4
_ExOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_sLogType$ = 12						; size = 4
?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z PROC		; LogChaosItem, COMDAT

; 703  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _sLogType$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi

; 704  : 	BYTE ExOption[MAX_EXOPTION_SIZE];
; 705  : 
; 706  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00015	33 db		 xor	 ebx, ebx
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0001b	89 45 ec	 mov	 DWORD PTR _sLogType$GSCopy$[ebp], eax
  0001e	89 5d f0	 mov	 DWORD PTR _n$155819[ebp], ebx
$LL4@LogChaosIt:

; 707  : 	{
; 708  : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00021	8b 8f dc 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3292]
  00027	03 cb		 add	 ecx, ebx
  00029	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002e	83 f8 01	 cmp	 eax, 1
  00031	0f 85 92 00 00
	00		 jne	 $LN3@LogChaosIt

; 709  : 		{
; 710  : 			::ItemIsBufExOption(ExOption, &lpObj->pChaosBox[n]);

  00037	8b 8f dc 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3292]
  0003d	03 cb		 add	 ecx, ebx
  0003f	51		 push	 ecx
  00040	8d 55 f4	 lea	 edx, DWORD PTR _ExOption$[ebp]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 711  : 
; 712  : 			LogAdd(LOG_BLACK, "[%s] [%s][%s] CBMix [%d,%s,%d,%d,%d,%d]serial:[%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 713  : 				sLogType, lpObj->AccountID, lpObj->Name, n, lpObj->pChaosBox[n].GetName(), lpObj->pChaosBox[n].m_Level,
; 714  : 				lpObj->pChaosBox[n].m_Option1, lpObj->pChaosBox[n].m_Option2, lpObj->pChaosBox[n].m_Option3, 
; 715  : 				lpObj->pChaosBox[n].m_Number, (int)lpObj->pChaosBox[n].m_Durability, 
; 716  : 				ExOption[0], ExOption[1], ExOption[2], ExOption[3], ExOption[4], ExOption[5], ExOption[6], lpObj->pChaosBox[n].m_SetOption);

  00049	8b 87 dc 0c 00
	00		 mov	 eax, DWORD PTR [edi+3292]
  0004f	0f b6 8c 03 92
	00 00 00	 movzx	 ecx, BYTE PTR [ebx+eax+146]
  00057	d9 44 03 24	 fld	 DWORD PTR [ebx+eax+36]
  0005b	0f b6 55 fa	 movzx	 edx, BYTE PTR _ExOption$[ebp+6]
  0005f	8d 34 03	 lea	 esi, DWORD PTR [ebx+eax]
  00062	0f b6 45 f9	 movzx	 eax, BYTE PTR _ExOption$[ebp+5]
  00066	83 c4 08	 add	 esp, 8
  00069	51		 push	 ecx
  0006a	0f b6 4d f8	 movzx	 ecx, BYTE PTR _ExOption$[ebp+4]
  0006e	52		 push	 edx
  0006f	0f b6 55 f7	 movzx	 edx, BYTE PTR _ExOption$[ebp+3]
  00073	50		 push	 eax
  00074	0f b6 45 f6	 movzx	 eax, BYTE PTR _ExOption$[ebp+2]
  00078	51		 push	 ecx
  00079	0f b6 4d f5	 movzx	 ecx, BYTE PTR _ExOption$[ebp+1]
  0007d	52		 push	 edx
  0007e	0f b6 55 f4	 movzx	 edx, BYTE PTR _ExOption$[ebp]
  00082	50		 push	 eax
  00083	51		 push	 ecx
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 __ftol2_sse
  0008a	0f b6 4e 7a	 movzx	 ecx, BYTE PTR [esi+122]
  0008e	0f b6 56 79	 movzx	 edx, BYTE PTR [esi+121]
  00092	50		 push	 eax
  00093	8b 06		 mov	 eax, DWORD PTR [esi]
  00095	50		 push	 eax
  00096	0f b6 46 78	 movzx	 eax, BYTE PTR [esi+120]
  0009a	51		 push	 ecx
  0009b	0f bf 4e 08	 movsx	 ecx, WORD PTR [esi+8]
  0009f	52		 push	 edx
  000a0	50		 push	 eax
  000a1	51		 push	 ecx
  000a2	8b ce		 mov	 ecx, esi
  000a4	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000a9	8b 55 f0	 mov	 edx, DWORD PTR _n$155819[ebp]
  000ac	50		 push	 eax
  000ad	52		 push	 edx
  000ae	8b 55 ec	 mov	 edx, DWORD PTR _sLogType$GSCopy$[ebp]
  000b1	8d 47 6f	 lea	 eax, DWORD PTR [edi+111]
  000b4	50		 push	 eax
  000b5	8d 4f 64	 lea	 ecx, DWORD PTR [edi+100]
  000b8	51		 push	 ecx
  000b9	52		 push	 edx
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@PNAJDFDA@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5?$FL?$CFd?0?$CFs?0?$CFd?0?$CFd@
  000bf	6a 00		 push	 0
  000c1	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000c6	83 c4 54	 add	 esp, 84			; 00000054H
$LN3@LogChaosIt:

; 704  : 	BYTE ExOption[MAX_EXOPTION_SIZE];
; 705  : 
; 706  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  000c9	ff 45 f0	 inc	 DWORD PTR _n$155819[ebp]
  000cc	81 c3 a8 00 00
	00		 add	 ebx, 168		; 000000a8H
  000d2	81 fb 00 15 00
	00		 cmp	 ebx, 5376		; 00001500H
  000d8	0f 8c 43 ff ff
	ff		 jl	 $LL4@LogChaosIt

; 717  : 		}
; 718  : 	}
; 719  : }

  000de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	33 cd		 xor	 ecx, ebp
  000e5	5b		 pop	 ebx
  000e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z ENDP		; LogChaosItem
_TEXT	ENDS
PUBLIC	??_C@_0EB@GCGNBAFG@?$FLWingMix?02?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5@ ; `string'
PUBLIC	??_C@_0EE@BHIPJGFK@?$FLWingMix?02?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Succe@ ; `string'
PUBLIC	??_C@_0BM@JPABEGNL@?$FLWingMix?02?$FN?5Chaos?5Mix?5Start?$AA@ ; `string'
PUBLIC	??_C@_09GJEFJCKN@WingMix?02?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?WingChaosMix@@YAHPAUOBJECTSTRUCT@@@Z		; WingChaosMix
EXTRN	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GCUserChaosBoxSend
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z:PROC	; CCastleSiegeSync::AddTributeMoney
EXTRN	?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateChaos
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
;	COMDAT ??_C@_0EB@GCGNBAFG@?$FLWingMix?02?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5@
CONST	SEGMENT
??_C@_0EB@GCGNBAFG@?$FLWingMix?02?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5@ DB '['
	DB	'WingMix,2] [%s][%s] CBMix Fail %d Money : %d-%d, CharmRate : '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@BHIPJGFK@?$FLWingMix?02?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Succe@
CONST	SEGMENT
??_C@_0EE@BHIPJGFK@?$FLWingMix?02?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Succe@ DB '['
	DB	'WingMix,2] [%s][%s] CBMix Success %d Money : %d-%d, CharmRate'
	DB	' : %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JPABEGNL@?$FLWingMix?02?$FN?5Chaos?5Mix?5Start?$AA@
CONST	SEGMENT
??_C@_0BM@JPABEGNL@?$FLWingMix?02?$FN?5Chaos?5Mix?5Start?$AA@ DB '[WingMi'
	DB	'x,2] Chaos Mix Start', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09GJEFJCKN@WingMix?02?$AA@
CONST	SEGMENT
??_C@_09GJEFJCKN@WingMix?02?$AA@ DB 'WingMix,2', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?WingChaosMix@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iOption1$156092 = -44					; size = 4
_iWingChaosMoney$ = -44					; size = 4
_LokesFeathersCount$ = -40				; size = 4
_iCharmOfLuckCount$ = -36				; size = 4
_iSleeveOfLord$ = -32					; size = 4
_iWingNum$156091 = -28					; size = 4
_WingCount$ = -28					; size = 4
_iRandomValue$156096 = -24				; size = 4
_iChaosMoney$ = -24					; size = 4
_nChaosNeedMoney$ = -20					; size = 4
_ChoasGemCount$ = -20					; size = 4
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?WingChaosMix@@YAHPAUOBJECTSTRUCT@@@Z PROC		; WingChaosMix, COMDAT

; 1260 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 1261 : 	lpObj->ChaosLock = TRUE;
; 1262 : 
; 1263 : 	int WingCount = 0;

  00016	33 ff		 xor	 edi, edi
  00018	c7 86 ec 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3308], 1
  00022	89 7d e4	 mov	 DWORD PTR _WingCount$[ebp], edi

; 1264 : 	int ChoasGemCount = 0;

  00025	89 7d ec	 mov	 DWORD PTR _ChoasGemCount$[ebp], edi

; 1265 : 	int LokesFeathersCount = 0;

  00028	89 7d d8	 mov	 DWORD PTR _LokesFeathersCount$[ebp], edi

; 1266 : 	int WingIndex = -1;
; 1267 : 	int iChaosMoney = 0;

  0002b	33 db		 xor	 ebx, ebx

; 1268 : 	int iWingChaosMoney = 0;

  0002d	89 7d d4	 mov	 DWORD PTR _iWingChaosMoney$[ebp], edi

; 1269 : 	int iSleeveOfLord = 0;

  00030	89 7d e0	 mov	 DWORD PTR _iSleeveOfLord$[ebp], edi

; 1270 : 	int iCharmOfLuckCount = 0;

  00033	89 7d dc	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], edi
  00036	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL60@WingChaosM:

; 1273 : 	{
; 1274 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00040	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00046	03 cf		 add	 ecx, edi
  00048	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004d	83 f8 01	 cmp	 eax, 1
  00050	0f 85 b1 00 00
	00		 jne	 $LN59@WingChaosM

; 1275 : 		{
; 1276 : 			if ( (lpObj->pChaosBox[n].m_Type >= ITEMGET(12,3) && lpObj->pChaosBox[n].m_Type <= ITEMGET(12,6)) || lpObj->pChaosBox[n].m_Type == ITEMGET(14,30) )	

  00056	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  0005c	0f b7 44 39 06	 movzx	 eax, WORD PTR [ecx+edi+6]
  00061	03 cf		 add	 ecx, edi
  00063	ba 03 18 00 00	 mov	 edx, 6147		; 00001803H
  00068	66 3b c2	 cmp	 ax, dx
  0006b	7c 0e		 jl	 SHORT $LN54@WingChaosM
  0006d	ba 06 18 00 00	 mov	 edx, 6150		; 00001806H
  00072	66 3b c2	 cmp	 ax, dx
  00075	0f 8e 73 04 00
	00		 jle	 $LN55@WingChaosM
$LN54@WingChaosM:
  0007b	ba 1e 1c 00 00	 mov	 edx, 7198		; 00001c1eH
  00080	66 3b c2	 cmp	 ax, dx
  00083	0f 84 65 04 00
	00		 je	 $LN55@WingChaosM

; 1277 : 			{
; 1278 : 				lpObj->ChaosLock = FALSE;
; 1279 : 
; 1280 : 				return FALSE;
; 1281 : 			}
; 1282 : 			if ( lpObj->pChaosBox[n].m_Type >= ITEMGET(12,0) && lpObj->pChaosBox[n].m_Type <= ITEMGET(12,2) ) 

  00089	ba 00 18 00 00	 mov	 edx, 6144		; 00001800H
  0008e	66 3b c2	 cmp	 ax, dx
  00091	7c 15		 jl	 SHORT $LN53@WingChaosM
  00093	ba 02 18 00 00	 mov	 edx, 6146		; 00001802H
  00098	66 3b c2	 cmp	 ax, dx
  0009b	7f 0b		 jg	 SHORT $LN53@WingChaosM

; 1283 : 			{
; 1284 : 				WingCount++;
; 1285 : 				WingIndex = n;
; 1286 : 				iWingChaosMoney = lpObj->pChaosBox[n].m_BuyMoney;

  0009d	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  000a0	ff 45 e4	 inc	 DWORD PTR _WingCount$[ebp]
  000a3	89 45 d4	 mov	 DWORD PTR _iWingChaosMoney$[ebp], eax
  000a6	eb 5f		 jmp	 SHORT $LN59@WingChaosM
$LN53@WingChaosM:

; 1287 : 			}
; 1288 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,15) ) // Chaos

  000a8	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  000ad	66 3b c2	 cmp	 ax, dx
  000b0	75 05		 jne	 SHORT $LN51@WingChaosM

; 1289 : 			{
; 1290 : 				ChoasGemCount++;

  000b2	ff 45 ec	 inc	 DWORD PTR _ChoasGemCount$[ebp]
  000b5	eb 50		 jmp	 SHORT $LN59@WingChaosM
$LN51@WingChaosM:

; 1291 : 			}
; 1292 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(13,14) ) // Feather

  000b7	ba 0e 1a 00 00	 mov	 edx, 6670		; 00001a0eH
  000bc	66 3b c2	 cmp	 ax, dx
  000bf	75 11		 jne	 SHORT $LN49@WingChaosM

; 1293 : 			{
; 1294 : 				if ( lpObj->pChaosBox[n].m_Level == 0 ) // Feather

  000c1	66 83 79 08 00	 cmp	 WORD PTR [ecx+8], 0
  000c6	75 05		 jne	 SHORT $LN48@WingChaosM

; 1295 : 				{
; 1296 : 					LokesFeathersCount++;

  000c8	ff 45 d8	 inc	 DWORD PTR _LokesFeathersCount$[ebp]

; 1297 : 				}
; 1298 : 				else	// Crst of Monarch

  000cb	eb 3a		 jmp	 SHORT $LN59@WingChaosM
$LN48@WingChaosM:

; 1299 : 				{
; 1300 : 					iSleeveOfLord ++;

  000cd	ff 45 e0	 inc	 DWORD PTR _iSleeveOfLord$[ebp]

; 1301 : 				}

  000d0	eb 35		 jmp	 SHORT $LN59@WingChaosM
$LN49@WingChaosM:

; 1302 : 			}
; 1303 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,53) )	// Charm Of Luck

  000d2	ba 35 1c 00 00	 mov	 edx, 7221		; 00001c35H
  000d7	66 3b c2	 cmp	 ax, dx
  000da	75 10		 jne	 SHORT $LN45@WingChaosM

; 1304 : 			{
; 1305 : 				iCharmOfLuckCount += lpObj->pChaosBox[n].m_Durability;

  000dc	db 45 dc	 fild	 DWORD PTR _iCharmOfLuckCount$[ebp]
  000df	d8 41 24	 fadd	 DWORD PTR [ecx+36]
  000e2	e8 00 00 00 00	 call	 __ftol2_sse
  000e7	89 45 dc	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], eax
  000ea	eb 1b		 jmp	 SHORT $LN59@WingChaosM
$LN45@WingChaosM:

; 1306 : 			}
; 1307 : 			else if ( lpObj->pChaosBox[n].IsExtItem() != FALSE )

  000ec	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  000f1	85 c0		 test	 eax, eax
  000f3	74 12		 je	 SHORT $LN59@WingChaosM

; 1308 : 			{
; 1309 : 				if ( lpObj->pChaosBox[n].m_Level >= 4 )

  000f5	8b 86 dc 0c 00
	00		 mov	 eax, DWORD PTR [esi+3292]
  000fb	66 83 7c 38 08
	04		 cmp	 WORD PTR [eax+edi+8], 4
  00101	7c 04		 jl	 SHORT $LN59@WingChaosM

; 1310 : 				{
; 1311 : 					iChaosMoney += lpObj->pChaosBox[n].m_BuyMoney;

  00103	03 5c 38 64	 add	 ebx, DWORD PTR [eax+edi+100]
$LN59@WingChaosM:

; 1271 : 
; 1272 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00107	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  0010d	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  00113	0f 8c 27 ff ff
	ff		 jl	 $LL60@WingChaosM

; 1312 : 				}
; 1313 : 			}
; 1314 : 		}
; 1315 : 	}
; 1316 : 
; 1317 : 	PMSG_CHAOSMIXRESULT pMsg;
; 1318 : 
; 1319 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00119	6a 0b		 push	 11			; 0000000bH
  0011b	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0011e	68 86 00 00 00	 push	 134			; 00000086H
  00123	51		 push	 ecx
  00124	89 5d e8	 mov	 DWORD PTR _iChaosMoney$[ebp], ebx
  00127	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1320 : 	pMsg.Result = CB_ERROR;
; 1321 : 
; 1322 : 	
; 1323 : 
; 1324 : 	if ( iSleeveOfLord == 1 )

  0012c	8b 4d e0	 mov	 ecx, DWORD PTR _iSleeveOfLord$[ebp]
  0012f	b8 01 00 00 00	 mov	 eax, 1
  00134	83 c4 0c	 add	 esp, 12			; 0000000cH
  00137	c6 45 f3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  0013b	3b c8		 cmp	 ecx, eax
  0013d	75 21		 jne	 SHORT $LN41@WingChaosM

; 1325 : 	{
; 1326 : 		if ( WingCount != 1 || ChoasGemCount != 1 || LokesFeathersCount != 0 )

  0013f	39 45 e4	 cmp	 DWORD PTR _WingCount$[ebp], eax
  00142	75 0b		 jne	 SHORT $LN67@WingChaosM
  00144	39 45 ec	 cmp	 DWORD PTR _ChoasGemCount$[ebp], eax
  00147	75 06		 jne	 SHORT $LN67@WingChaosM
  00149	83 7d d8 00	 cmp	 DWORD PTR _LokesFeathersCount$[ebp], 0
  0014d	74 34		 je	 SHORT $LN36@WingChaosM
$LN67@WingChaosM:

; 1327 : 		{
; 1328 : 			lpObj->ChaosLock = FALSE;
; 1329 : 			pMsg.Result = CB_INCORRECT_MIX_ITEMS;
; 1330 : 			DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  0014f	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00153	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00155	52		 push	 edx
  00156	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00159	50		 push	 eax
  0015a	51		 push	 ecx

; 1331 : 			return FALSE;

  0015b	e9 b7 03 00 00	 jmp	 $LN75@WingChaosM
$LN41@WingChaosM:

; 1332 : 		}
; 1333 : 	}
; 1334 : 	else if ( LokesFeathersCount == 1 )

  00160	39 45 d8	 cmp	 DWORD PTR _LokesFeathersCount$[ebp], eax
  00163	0f 85 a2 03 00
	00		 jne	 $LN37@WingChaosM

; 1335 : 	{
; 1336 : 		if ( WingCount != 1 || ChoasGemCount != 1 || iSleeveOfLord != 0 )

  00169	39 45 e4	 cmp	 DWORD PTR _WingCount$[ebp], eax
  0016c	0f 85 e8 00 00
	00		 jne	 $LN35@WingChaosM
  00172	39 45 ec	 cmp	 DWORD PTR _ChoasGemCount$[ebp], eax
  00175	0f 85 df 00 00
	00		 jne	 $LN35@WingChaosM
  0017b	85 c9		 test	 ecx, ecx
  0017d	0f 85 d7 00 00
	00		 jne	 $LN35@WingChaosM
$LN36@WingChaosM:

; 1350 : 
; 1351 : 		return FALSE;
; 1352 : 	}
; 1353 : 
; 1354 : 	if ( iCharmOfLuckCount > 10 )

  00183	83 7d dc 0a	 cmp	 DWORD PTR _iCharmOfLuckCount$[ebp], 10 ; 0000000aH
  00187	7e 22		 jle	 SHORT $LN68@WingChaosM

; 1355 : 	{
; 1356 : 		lpObj->ChaosLock = FALSE;
; 1357 : 		pMsg.Result = 0xF0;
; 1358 : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00189	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0018d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0018f	52		 push	 edx
  00190	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00193	50		 push	 eax
  00194	51		 push	 ecx
  00195	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  0019f	c6 45 f3 f0	 mov	 BYTE PTR _pMsg$[ebp+3], 240 ; 000000f0H
  001a3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001a8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN68@WingChaosM:

; 1359 : 	}
; 1360 : 
; 1361 : 	int nChaosNeedMoney = 5000000;
; 1362 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  001ab	8b 16		 mov	 edx, DWORD PTR [esi]
  001ad	52		 push	 edx
  001ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  001b3	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  001b8	6a 00		 push	 0
  001ba	99		 cdq
  001bb	68 40 4b 4c 00	 push	 5000000			; 004c4b40H
  001c0	52		 push	 edx
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 __allmul
  001c7	6a 00		 push	 0
  001c9	6a 64		 push	 100			; 00000064H
  001cb	52		 push	 edx
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 __alldiv
  001d2	8b f8		 mov	 edi, eax

; 1363 : 
; 1364 : 	if ( iChaosTaxMoney < 0 )

  001d4	85 ff		 test	 edi, edi
  001d6	79 02		 jns	 SHORT $LN32@WingChaosM

; 1365 : 	{
; 1366 : 		iChaosTaxMoney = 0;

  001d8	33 ff		 xor	 edi, edi
$LN32@WingChaosM:

; 1367 : 	}
; 1368 : 
; 1369 : 	nChaosNeedMoney += iChaosTaxMoney;

  001da	8d 9f 40 4b 4c
	00		 lea	 ebx, DWORD PTR [edi+5000000]
  001e0	89 5d ec	 mov	 DWORD PTR _nChaosNeedMoney$[ebp], ebx

; 1370 : 
; 1371 : 	if ( nChaosNeedMoney < 0 )

  001e3	85 db		 test	 ebx, ebx
  001e5	79 0a		 jns	 SHORT $LN31@WingChaosM

; 1372 : 	{
; 1373 : 		nChaosNeedMoney = 0;

  001e7	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _nChaosNeedMoney$[ebp], 0
  001ee	8b 5d ec	 mov	 ebx, DWORD PTR _nChaosNeedMoney$[ebp]
$LN31@WingChaosM:

; 1374 : 	}
; 1375 : 
; 1376 : 	if ( lpObj->Money < nChaosNeedMoney )

  001f1	39 9e b0 00 00
	00		 cmp	 DWORD PTR [esi+176], ebx
  001f7	7d 38		 jge	 SHORT $LN30@WingChaosM

; 1377 : 	{
; 1378 : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;
; 1379 : 		
; 1380 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  001f9	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  001fd	8b 16		 mov	 edx, DWORD PTR [esi]
  001ff	50		 push	 eax
  00200	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00203	51		 push	 ecx
  00204	52		 push	 edx
  00205	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
  00209	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0020e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00211	5f		 pop	 edi

; 1381 : 		lpObj->ChaosLock = FALSE;

  00212	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  0021c	5e		 pop	 esi

; 1382 : 
; 1383 : 		return TRUE;

  0021d	b8 01 00 00 00	 mov	 eax, 1
  00222	5b		 pop	 ebx

; 1522 : 
; 1523 : 		return FALSE;
; 1524 : 	}
; 1525 : }

  00223	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00226	33 cd		 xor	 ecx, ebp
  00228	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022d	8b e5		 mov	 esp, ebp
  0022f	5d		 pop	 ebp
  00230	c3		 ret	 0
$LN30@WingChaosM:

; 1384 : 	}
; 1385 : 
; 1386 : 	CItem * pWing = &lpObj->pChaosBox[WingIndex];
; 1387 : 	lpObj->ChaosSuccessRate = (DWORD)((DWORD)iWingChaosMoney / (DWORD)4000000);

  00231	b8 83 de 1b 43	 mov	 eax, 1125899907		; 431bde83H
  00236	f7 65 d4	 mul	 DWORD PTR _iWingChaosMoney$[ebp]
  00239	8b ca		 mov	 ecx, edx

; 1388 : 	lpObj->ChaosSuccessRate += iChaosMoney / 40000;

  0023b	b8 ad 8b db 68	 mov	 eax, 1759218605		; 68db8badH
  00240	f7 6d e8	 imul	 DWORD PTR _iChaosMoney$[ebp]
  00243	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00246	c1 e9 14	 shr	 ecx, 20			; 00000014H
  00249	8b c2		 mov	 eax, edx
  0024b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0024e	03 ca		 add	 ecx, edx
  00250	03 c1		 add	 eax, ecx
  00252	89 86 e8 0c 00
	00		 mov	 DWORD PTR [esi+3304], eax

; 1389 : 
; 1390 : 	if ( lpObj->ChaosSuccessRate == 0 )

  00258	75 24		 jne	 SHORT $LN29@WingChaosM
$LN35@WingChaosM:

; 1391 : 	{
; 1392 : 		pMsg.Result = CB_INCORRECT_MIX_ITEMS;
; 1393 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  0025a	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0025e	8b 06		 mov	 eax, DWORD PTR [esi]
  00260	51		 push	 ecx
  00261	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00264	52		 push	 edx
  00265	50		 push	 eax
  00266	c6 45 f3 07	 mov	 BYTE PTR _pMsg$[ebp+3], 7
  0026a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1394 : 		lpObj->ChaosLock = FALSE;

  0026f	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0

; 1395 : 
; 1396 : 		return FALSE;

  00279	e9 ac 02 00 00	 jmp	 $LN76@WingChaosM
$LN29@WingChaosM:

; 1397 : 	}
; 1398 : 
; 1399 : 	LogChaosItem(lpObj, "WingMix,2");

  0027e	68 00 00 00 00	 push	 OFFSET ??_C@_09GJEFJCKN@WingMix?02?$AA@
  00283	56		 push	 esi
  00284	e8 00 00 00 00	 call	 ?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z ; LogChaosItem

; 1400 : 	LogAdd(LOG_BLACK, "[WingMix,2] Chaos Mix Start");

  00289	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JPABEGNL@?$FLWingMix?02?$FN?5Chaos?5Mix?5Start?$AA@
  0028e	6a 00		 push	 0
  00290	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 1401 : 
; 1402 : 	if ( iSleeveOfLord == 1 )

  00295	b8 01 00 00 00	 mov	 eax, 1
  0029a	83 c4 10	 add	 esp, 16			; 00000010H
  0029d	39 45 e0	 cmp	 DWORD PTR _iSleeveOfLord$[ebp], eax
  002a0	75 07		 jne	 SHORT $LN28@WingChaosM

; 1403 : 	{
; 1404 : 		if ( lpObj->ChaosSuccessRate > 90)

  002a2	b8 5a 00 00 00	 mov	 eax, 90			; 0000005aH

; 1405 : 		{
; 1406 : 			lpObj->ChaosSuccessRate = 90;
; 1407 : 		}
; 1408 : 	}

  002a7	eb 0a		 jmp	 SHORT $LN77@WingChaosM
$LN28@WingChaosM:

; 1409 : 	else if ( LokesFeathersCount == 1 )

  002a9	39 45 d8	 cmp	 DWORD PTR _LokesFeathersCount$[ebp], eax
  002ac	75 15		 jne	 SHORT $LN25@WingChaosM

; 1410 : 	{
; 1411 : 		if ( lpObj->ChaosSuccessRate > 100 )

  002ae	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
$LN77@WingChaosM:
  002b3	39 86 e8 0c 00
	00		 cmp	 DWORD PTR [esi+3304], eax
  002b9	7e 1b		 jle	 SHORT $LN22@WingChaosM

; 1412 : 		{
; 1413 : 			lpObj->ChaosSuccessRate =  100;

  002bb	89 86 e8 0c 00
	00		 mov	 DWORD PTR [esi+3304], eax

; 1414 : 		}
; 1415 : 	}

  002c1	eb 13		 jmp	 SHORT $LN22@WingChaosM
$LN25@WingChaosM:

; 1416 : 	else if ( lpObj->ChaosSuccessRate > 100 )

  002c3	83 be e8 0c 00
	00 64		 cmp	 DWORD PTR [esi+3304], 100 ; 00000064H
  002ca	7e 0a		 jle	 SHORT $LN22@WingChaosM

; 1417 : 	{
; 1418 : 		lpObj->ChaosSuccessRate = 100;

  002cc	c7 86 e8 0c 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+3304], 100 ; 00000064H
$LN22@WingChaosM:

; 1419 : 	}
; 1420 : 
; 1421 : 	lpObj->ChaosSuccessRate += iCharmOfLuckCount;

  002d6	8b 4d dc	 mov	 ecx, DWORD PTR _iCharmOfLuckCount$[ebp]
  002d9	01 8e e8 0c 00
	00		 add	 DWORD PTR [esi+3304], ecx

; 1422 : 	lpObj->Money  -= nChaosNeedMoney;

  002df	29 9e b0 00 00
	00		 sub	 DWORD PTR [esi+176], ebx

; 1423 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  002e5	57		 push	 edi
  002e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  002eb	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 1424 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  002f0	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  002f6	8b 06		 mov	 eax, DWORD PTR [esi]
  002f8	52		 push	 edx
  002f9	50		 push	 eax
  002fa	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  002ff	83 c4 08	 add	 esp, 8

; 1425 : 
; 1426 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  00302	e8 00 00 00 00	 call	 _rand
  00307	99		 cdq
  00308	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0030d	f7 f9		 idiv	 ecx
  0030f	3b 96 e8 0c 00
	00		 cmp	 edx, DWORD PTR [esi+3304]
  00315	0f 8d 67 01 00
	00		 jge	 $LN21@WingChaosM

; 1427 : 	{
; 1428 : 		int iWingLevel = 0;
; 1429 : 		int iItemType;
; 1430 : 		int iItemSubType;
; 1431 : 
; 1432 : 		if ( iSleeveOfLord != 0 )

  0031b	33 db		 xor	 ebx, ebx
  0031d	39 5d e0	 cmp	 DWORD PTR _iSleeveOfLord$[ebp], ebx
  00320	74 08		 je	 SHORT $LN20@WingChaosM

; 1433 : 		{
; 1434 : 			iItemType = 13;

  00322	8d 79 a9	 lea	 edi, DWORD PTR [ecx-87]

; 1435 : 			iItemSubType = 30;

  00325	8d 41 ba	 lea	 eax, DWORD PTR [ecx-70]

; 1436 : 		}
; 1437 : 		else

  00328	eb 19		 jmp	 SHORT $LN19@WingChaosM
$LN20@WingChaosM:

; 1438 : 		{
; 1439 : 			iItemType = 12;

  0032a	bf 0c 00 00 00	 mov	 edi, 12			; 0000000cH

; 1440 : 			iItemSubType = rand()%4 + 3;

  0032f	e8 00 00 00 00	 call	 _rand
  00334	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00339	79 05		 jns	 SHORT $LN71@WingChaosM
  0033b	48		 dec	 eax
  0033c	83 c8 fc	 or	 eax, -4			; fffffffcH
  0033f	40		 inc	 eax
$LN71@WingChaosM:
  00340	83 c0 03	 add	 eax, 3
$LN19@WingChaosM:

; 1441 : 		}
; 1442 : 
; 1443 : 		int iWingNum = ITEMGET(iItemType, iItemSubType);

  00343	c1 e7 09	 shl	 edi, 9
  00346	03 f8		 add	 edi, eax
  00348	89 7d e4	 mov	 DWORD PTR _iWingNum$156091[ebp], edi

; 1444 : 		int iOption1 = 0;

  0034b	89 5d d4	 mov	 DWORD PTR _iOption1$156092[ebp], ebx

; 1445 : 		int iOption2 = 0;
; 1446 : 		int iOption3 = 0;

  0034e	33 ff		 xor	 edi, edi

; 1447 : 
; 1448 : 		if ( (rand()%5) == 0 )

  00350	e8 00 00 00 00	 call	 _rand
  00355	99		 cdq
  00356	b9 05 00 00 00	 mov	 ecx, 5
  0035b	f7 f9		 idiv	 ecx
  0035d	85 d2		 test	 edx, edx
  0035f	75 07		 jne	 SHORT $LN18@WingChaosM

; 1449 : 		{
; 1450 : 			iOption1 = 1;

  00361	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _iOption1$156092[ebp], 1
$LN18@WingChaosM:

; 1451 : 		}
; 1452 : 
; 1453 : 		int iRandomValue = rand() % 100;

  00368	e8 00 00 00 00	 call	 _rand
  0036d	99		 cdq
  0036e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00373	f7 f9		 idiv	 ecx
  00375	89 55 e8	 mov	 DWORD PTR _iRandomValue$156096[ebp], edx

; 1454 : 		int iRandomValue2 = rand() % 3;

  00378	e8 00 00 00 00	 call	 _rand
  0037d	99		 cdq
  0037e	b9 03 00 00 00	 mov	 ecx, 3
  00383	f7 f9		 idiv	 ecx

; 1455 : 
; 1456 : 		switch ( iRandomValue2 )

  00385	2b d3		 sub	 edx, ebx
  00387	74 1e		 je	 SHORT $LN15@WingChaosM
  00389	4a		 dec	 edx
  0038a	74 0e		 je	 SHORT $LN13@WingChaosM
  0038c	4a		 dec	 edx
  0038d	75 20		 jne	 SHORT $LN14@WingChaosM

; 1471 : 
; 1472 : 			case 2:
; 1473 : 				if ( iRandomValue < 20 )

  0038f	83 7d e8 14	 cmp	 DWORD PTR _iRandomValue$156096[ebp], 20 ; 00000014H
  00393	7d 1a		 jge	 SHORT $LN14@WingChaosM

; 1474 : 				{
; 1475 : 					iOption2 = 1;	// +4;

  00395	8d 59 fe	 lea	 ebx, DWORD PTR [ecx-2]
  00398	eb 15		 jmp	 SHORT $LN14@WingChaosM
$LN13@WingChaosM:

; 1462 : 				}
; 1463 : 				break;
; 1464 : 
; 1465 : 			case 1:
; 1466 : 				if ( iRandomValue < 10 )

  0039a	83 7d e8 0a	 cmp	 DWORD PTR _iRandomValue$156096[ebp], 10 ; 0000000aH
  0039e	7d 0f		 jge	 SHORT $LN14@WingChaosM

; 1467 : 				{
; 1468 : 					iOption2 = 2;	// +8

  003a0	bb 02 00 00 00	 mov	 ebx, 2

; 1469 : 				}
; 1470 : 				break;

  003a5	eb 08		 jmp	 SHORT $LN14@WingChaosM
$LN15@WingChaosM:

; 1457 : 		{
; 1458 : 			case 0:
; 1459 : 				if ( iRandomValue < 4 )

  003a7	83 7d e8 04	 cmp	 DWORD PTR _iRandomValue$156096[ebp], 4
  003ab	7d 02		 jge	 SHORT $LN14@WingChaosM

; 1460 : 				{
; 1461 : 					iOption2 = 3;	// +12

  003ad	8b d9		 mov	 ebx, ecx
$LN14@WingChaosM:

; 1476 : 				}
; 1477 : 		}
; 1478 : 
; 1479 : 		//int ExOption;
; 1480 : 
; 1481 : 		if ( iSleeveOfLord != FALSE )
; 1482 : 		{
; 1483 : 			if ( (rand()%5) == 0 )

  003af	e8 00 00 00 00	 call	 _rand
  003b4	99		 cdq
  003b5	b9 05 00 00 00	 mov	 ecx, 5
  003ba	f7 f9		 idiv	 ecx
  003bc	39 7d e0	 cmp	 DWORD PTR _iSleeveOfLord$[ebp], edi
  003bf	74 21		 je	 SHORT $LN9@WingChaosM
  003c1	85 d2		 test	 edx, edx
  003c3	75 4a		 jne	 SHORT $LN8@WingChaosM

; 1484 : 			{
; 1485 : 				iOption3 = 1 << (rand()%4);

  003c5	e8 00 00 00 00	 call	 _rand
  003ca	8b c8		 mov	 ecx, eax
  003cc	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  003d2	79 05		 jns	 SHORT $LN72@WingChaosM
  003d4	49		 dec	 ecx
  003d5	83 c9 fc	 or	 ecx, -4			; fffffffcH
  003d8	41		 inc	 ecx
$LN72@WingChaosM:
  003d9	bf 01 00 00 00	 mov	 edi, 1
  003de	d3 e7		 shl	 edi, cl

; 1486 : 			}
; 1487 : 				iOption3 |= 0x20;
; 1488 : 		}
; 1489 : 		else

  003e0	eb 2d		 jmp	 SHORT $LN8@WingChaosM
$LN9@WingChaosM:

; 1490 : 		{
; 1491 : 			if ( (rand()%5) == 0 )

  003e2	85 d2		 test	 edx, edx
  003e4	75 16		 jne	 SHORT $LN6@WingChaosM

; 1492 : 			{
; 1493 : 				iOption3 = 1 << (rand()%3);

  003e6	e8 00 00 00 00	 call	 _rand
  003eb	99		 cdq
  003ec	b9 03 00 00 00	 mov	 ecx, 3
  003f1	f7 f9		 idiv	 ecx
  003f3	bf 01 00 00 00	 mov	 edi, 1
  003f8	8b ca		 mov	 ecx, edx
  003fa	d3 e7		 shl	 edi, cl
$LN6@WingChaosM:

; 1494 : 			}
; 1495 : 
; 1496 : 			if ( (rand()%2) != 0 )

  003fc	e8 00 00 00 00	 call	 _rand
  00401	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00406	79 05		 jns	 SHORT $LN73@WingChaosM
  00408	48		 dec	 eax
  00409	83 c8 fe	 or	 eax, -2			; fffffffeH
  0040c	40		 inc	 eax
$LN73@WingChaosM:
  0040d	74 03		 je	 SHORT $LN5@WingChaosM
$LN8@WingChaosM:

; 1497 : 			{
; 1498 : 				iOption3 |= 0x20;

  0040f	83 cf 20	 or	 edi, 32			; 00000020H
$LN5@WingChaosM:

; 1499 : 			}
; 1500 : 		
; 1501 : 		}
; 1502 : 
; 1503 : 		::ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, iWingNum, iWingLevel, 0, 0, iOption1, iOption2, -1, iOption3, 0);

  00412	8b 55 d4	 mov	 edx, DWORD PTR _iOption1$156092[ebp]
  00415	8b 45 e4	 mov	 eax, DWORD PTR _iWingNum$156091[ebp]
  00418	6a 00		 push	 0
  0041a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0041c	57		 push	 edi
  0041d	6a ff		 push	 -1
  0041f	53		 push	 ebx
  00420	52		 push	 edx
  00421	6a 00		 push	 0
  00423	6a 00		 push	 0
  00425	6a 00		 push	 0
  00427	50		 push	 eax
  00428	6a 00		 push	 0
  0042a	6a 00		 push	 0
  0042c	68 ff 00 00 00	 push	 255			; 000000ffH
  00431	51		 push	 ecx
  00432	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 1504 : 		::gObjInventoryCommit(lpObj->m_Index);

  00437	8b 16		 mov	 edx, DWORD PTR [esi]
  00439	52		 push	 edx
  0043a	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit

; 1505 : 		::LogAdd(LOG_BLACK, "[WingMix,2] [%s][%s] CBMix Success %d Money : %d-%d, CharmRate : %d",
; 1506 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney, iCharmOfLuckCount);

  0043f	8b 45 dc	 mov	 eax, DWORD PTR _iCharmOfLuckCount$[ebp]
  00442	8b 4d ec	 mov	 ecx, DWORD PTR _nChaosNeedMoney$[ebp]
  00445	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  0044b	50		 push	 eax
  0044c	8b 86 e8 0c 00
	00		 mov	 eax, DWORD PTR [esi+3304]
  00452	51		 push	 ecx
  00453	52		 push	 edx
  00454	50		 push	 eax
  00455	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  00458	51		 push	 ecx
  00459	83 c6 64	 add	 esi, 100		; 00000064H
  0045c	56		 push	 esi
  0045d	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@BHIPJGFK@?$FLWingMix?02?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Succe@
  00462	6a 00		 push	 0
  00464	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00469	83 c4 58	 add	 esp, 88			; 00000058H
  0046c	5f		 pop	 edi
  0046d	5e		 pop	 esi

; 1507 : 		return TRUE;

  0046e	b8 01 00 00 00	 mov	 eax, 1
  00473	5b		 pop	 ebx

; 1522 : 
; 1523 : 		return FALSE;
; 1524 : 	}
; 1525 : }

  00474	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00477	33 cd		 xor	 ecx, ebp
  00479	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0047e	8b e5		 mov	 esp, ebp
  00480	5d		 pop	 ebp
  00481	c3		 ret	 0
$LN21@WingChaosM:

; 1508 : 	}
; 1509 : 	else
; 1510 : 	{
; 1511 : 		for (int n=0;n<CHAOS_BOX_SIZE;n++)

  00482	33 ff		 xor	 edi, edi
  00484	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL3@WingChaosM:

; 1512 : 		{
; 1513 : 			lpObj->pChaosBox[n].Clear();

  00490	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00496	03 cf		 add	 ecx, edi
  00498	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  0049d	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  004a3	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  004a9	7c e5		 jl	 SHORT $LL3@WingChaosM

; 1514 : 		}
; 1515 : 
; 1516 : 		GCUserChaosBoxSend(lpObj, 0);

  004ab	6a 00		 push	 0
  004ad	56		 push	 esi
  004ae	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 1517 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  004b3	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  004b7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  004b9	52		 push	 edx
  004ba	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  004bd	50		 push	 eax
  004be	51		 push	 ecx
  004bf	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1518 : 		::LogAdd(LOG_BLACK, "[WingMix,2] [%s][%s] CBMix Fail %d Money : %d-%d, CharmRate : %d",
; 1519 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney, iCharmOfLuckCount);

  004c4	8b 55 dc	 mov	 edx, DWORD PTR _iCharmOfLuckCount$[ebp]
  004c7	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  004cd	8b 8e e8 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3304]
  004d3	52		 push	 edx
  004d4	53		 push	 ebx
  004d5	50		 push	 eax
  004d6	51		 push	 ecx
  004d7	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  004da	52		 push	 edx
  004db	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  004de	50		 push	 eax
  004df	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@GCGNBAFG@?$FLWingMix?02?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5@
  004e4	6a 00		 push	 0
  004e6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  004eb	83 c4 34	 add	 esp, 52			; 00000034H
$LN55@WingChaosM:

; 1520 : 		
; 1521 : 		lpObj->ChaosLock = FALSE;

  004ee	5f		 pop	 edi
  004ef	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  004f9	5e		 pop	 esi
  004fa	33 c0		 xor	 eax, eax
  004fc	5b		 pop	 ebx

; 1522 : 
; 1523 : 		return FALSE;
; 1524 : 	}
; 1525 : }

  004fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00500	33 cd		 xor	 ecx, ebp
  00502	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00507	8b e5		 mov	 esp, ebp
  00509	5d		 pop	 ebp
  0050a	c3		 ret	 0
$LN37@WingChaosM:

; 1349 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  0050b	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0050f	8b 06		 mov	 eax, DWORD PTR [esi]
  00511	51		 push	 ecx
  00512	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00515	52		 push	 edx
  00516	50		 push	 eax
$LN75@WingChaosM:

; 1337 : 		{
; 1338 : 			pMsg.Result = CB_INCORRECT_MIX_ITEMS;
; 1339 : 			DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);
; 1340 : 			lpObj->ChaosLock = FALSE;
; 1341 : 
; 1342 : 			return FALSE;
; 1343 : 		}
; 1344 : 	}
; 1345 : 	else
; 1346 : 	{
; 1347 : 		lpObj->ChaosLock = FALSE;
; 1348 : 		pMsg.Result = CB_INCORRECT_MIX_ITEMS;

  00517	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  00521	c6 45 f3 07	 mov	 BYTE PTR _pMsg$[ebp+3], 7

; 1349 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  00525	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
$LN76@WingChaosM:

; 1522 : 
; 1523 : 		return FALSE;
; 1524 : 	}
; 1525 : }

  0052a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0052d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00530	5f		 pop	 edi
  00531	5e		 pop	 esi
  00532	33 cd		 xor	 ecx, ebp
  00534	33 c0		 xor	 eax, eax
  00536	5b		 pop	 ebx
  00537	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0053c	8b e5		 mov	 esp, ebp
  0053e	5d		 pop	 ebp
  0053f	c3		 ret	 0
?WingChaosMix@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; WingChaosMix
_TEXT	ENDS
PUBLIC	??_C@_0CK@IKEPLJDI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Success?5Rate?3?$CFd?5M@ ; `string'
PUBLIC	??_C@_0CF@NPEOFJKC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5?$CFd?5Money?5?3?5?$CF@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DefaultChaosMix@@YAXPAUOBJECTSTRUCT@@@Z	; DefaultChaosMix
EXTRN	?gChaosEvent@@3HA:DWORD				; gChaosEvent
;	COMDAT ??_C@_0CK@IKEPLJDI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Success?5Rate?3?$CFd?5M@
CONST	SEGMENT
??_C@_0CK@IKEPLJDI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Success?5Rate?3?$CFd?5M@ DB '['
	DB	'%s][%s] CBMix Success Rate:%d Money : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NPEOFJKC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5?$CFd?5Money?5?3?5?$CF@
CONST	SEGMENT
??_C@_0CF@NPEOFJKC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5?$CFd?5Money?5?3?5?$CF@ DB '['
	DB	'%s][%s] CBMix Fail %d Money : %d-%d', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DefaultChaosMix@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_MixResult2$ = -44					; size = 4
_Level$156145 = -40					; size = 4
_fail$ = -36						; size = 4
_aIndex$ = -32						; size = 4
_Option2$156147 = -28					; size = 4
_iChaosTaxMoney$ = -24					; size = 4
_Option1$156146 = -20					; size = 4
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?DefaultChaosMix@@YAXPAUOBJECTSTRUCT@@@Z PROC		; DefaultChaosMix, COMDAT

; 1533 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00014	57		 push	 edi

; 1534 : 	PMSG_CHAOSMIXRESULT pMsg;
; 1535 : 
; 1536 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00015	6a 0b		 push	 11			; 0000000bH
  00017	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	68 86 00 00 00	 push	 134			; 00000086H
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1537 : 	pMsg.Result = CB_ERROR;
; 1538 : 	int aIndex = lpObj->m_Index;

  00025	8b 3e		 mov	 edi, DWORD PTR [esi]

; 1539 : 	BOOL fail = TRUE;
; 1540 : 	int MixResult2;
; 1541 : 	lpObj->ChaosLock = TRUE;
; 1542 : 
; 1543 : 	if ( ChaosBoxMix(lpObj, MixResult2) == 0 )

  00027	8d 4d d4	 lea	 ecx, DWORD PTR _MixResult2$[ebp]
  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	51		 push	 ecx
  00030	56		 push	 esi
  00031	c6 45 f3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  00035	89 7d e0	 mov	 DWORD PTR _aIndex$[ebp], edi
  00038	89 45 dc	 mov	 DWORD PTR _fail$[ebp], eax
  0003b	89 86 ec 0c 00
	00		 mov	 DWORD PTR [esi+3308], eax
  00041	e8 00 00 00 00	 call	 ?ChaosBoxMix@@YAHPAUOBJECTSTRUCT@@AAH@Z ; ChaosBoxMix
  00046	83 c4 14	 add	 esp, 20			; 00000014H
  00049	85 c0		 test	 eax, eax
  0004b	75 30		 jne	 SHORT $LN33@DefaultCha

; 1544 : 	{
; 1545 : 		pMsg.Result = CB_INCORRECT_MIX_ITEMS;
; 1546 : 		DataSend(aIndex, (BYTE *)&pMsg, pMsg.h.size);

  0004d	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00051	52		 push	 edx
  00052	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00055	50		 push	 eax
  00056	57		 push	 edi
  00057	c6 45 f3 07	 mov	 BYTE PTR _pMsg$[ebp+3], 7
  0005b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	5f		 pop	 edi

; 1547 : 		lpObj->ChaosLock = FALSE;

  00064	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  0006e	5e		 pop	 esi

; 1704 : }

  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00072	33 cd		 xor	 ecx, ebp
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$LN33@DefaultCha:

; 1548 : 
; 1549 : 		return;
; 1550 : 	}
; 1551 : 
; 1552 : 	int iChaosTaxMoney = (int)((__int64)lpObj->ChaosMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  0007d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0007f	53		 push	 ebx
  00080	51		 push	 ecx
  00081	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00086	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  0008b	f7 ae e4 0c 00
	00		 imul	 DWORD PTR [esi+3300]
  00091	33 db		 xor	 ebx, ebx
  00093	53		 push	 ebx
  00094	6a 64		 push	 100			; 00000064H
  00096	52		 push	 edx
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 __alldiv
  0009d	89 45 e8	 mov	 DWORD PTR _iChaosTaxMoney$[ebp], eax

; 1553 : 
; 1554 : 	if ( iChaosTaxMoney < 0 )

  000a0	3b c3		 cmp	 eax, ebx
  000a2	7d 03		 jge	 SHORT $LN32@DefaultCha

; 1555 : 	{
; 1556 : 		iChaosTaxMoney = 0;

  000a4	89 5d e8	 mov	 DWORD PTR _iChaosTaxMoney$[ebp], ebx
$LN32@DefaultCha:

; 1557 : 	}
; 1558 : 
; 1559 : 	lpObj->ChaosMoney += iChaosTaxMoney;

  000a7	8b 55 e8	 mov	 edx, DWORD PTR _iChaosTaxMoney$[ebp]
  000aa	01 96 e4 0c 00
	00		 add	 DWORD PTR [esi+3300], edx

; 1560 : 
; 1561 : 	if ( lpObj->ChaosMoney < 0 )

  000b0	79 06		 jns	 SHORT $LN31@DefaultCha

; 1562 : 	{
; 1563 : 		lpObj->ChaosMoney = 0;

  000b2	89 9e e4 0c 00
	00		 mov	 DWORD PTR [esi+3300], ebx
$LN31@DefaultCha:

; 1564 : 	}
; 1565 : 
; 1566 : 	if ( lpObj->Money < lpObj->ChaosMoney )

  000b8	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  000be	3b 86 e4 0c 00
	00		 cmp	 eax, DWORD PTR [esi+3300]
  000c4	7d 1e		 jge	 SHORT $LN30@DefaultCha

; 1567 : 	{
; 1568 : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;
; 1569 : 		
; 1570 : 		DataSend(aIndex, (BYTE *)&pMsg, pMsg.h.size);

  000c6	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000ca	51		 push	 ecx
  000cb	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000ce	52		 push	 edx
  000cf	57		 push	 edi
  000d0	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
  000d4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1571 : 		lpObj->ChaosLock = FALSE;

  000d9	89 9e ec 0c 00
	00		 mov	 DWORD PTR [esi+3308], ebx

; 1572 : 
; 1573 : 
; 1574 : 	}
; 1575 : 	else 

  000df	e9 ae 02 00 00	 jmp	 $LN41@DefaultCha
$LN30@DefaultCha:

; 1576 : 	{
; 1577 : 		if ( lpObj->ChaosSuccessRate > 0 )

  000e4	8b 86 e8 0c 00
	00		 mov	 eax, DWORD PTR [esi+3304]
  000ea	3b c3		 cmp	 eax, ebx
  000ec	0f 8e e2 01 00
	00		 jle	 $LN40@DefaultCha

; 1578 : 		{
; 1579 : 			if ( lpObj->ChaosSuccessRate >= 100 )

  000f2	83 f8 64	 cmp	 eax, 100		; 00000064H
  000f5	7c 0a		 jl	 SHORT $LN27@DefaultCha

; 1580 : 			{
; 1581 : 				lpObj->ChaosSuccessRate = 100;

  000f7	c7 86 e8 0c 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+3304], 100 ; 00000064H
$LN27@DefaultCha:

; 1582 : 			}
; 1583 : 
; 1584 : 			if ( (rand()%100) <= (lpObj->ChaosSuccessRate-1) ) 

  00101	e8 00 00 00 00	 call	 _rand
  00106	99		 cdq
  00107	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0010c	f7 f9		 idiv	 ecx
  0010e	8b 86 e8 0c 00
	00		 mov	 eax, DWORD PTR [esi+3304]
  00114	48		 dec	 eax
  00115	3b d0		 cmp	 edx, eax
  00117	0f 8f b7 01 00
	00		 jg	 $LN40@DefaultCha

; 1585 : 			{
; 1586 : 				fail = FALSE;

  0011d	89 5d dc	 mov	 DWORD PTR _fail$[ebp], ebx

; 1587 : 				pMsg.Result = CB_SUCCESS;

  00120	c6 45 f3 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1

; 1588 : 
; 1589 : 				int Level = rand()%5;

  00124	e8 00 00 00 00	 call	 _rand
  00129	99		 cdq
  0012a	b9 05 00 00 00	 mov	 ecx, 5
  0012f	f7 f9		 idiv	 ecx

; 1590 : 				int Option1 = 0;

  00131	89 5d ec	 mov	 DWORD PTR _Option1$156146[ebp], ebx

; 1591 : 				int Option2 = 0;

  00134	89 5d e4	 mov	 DWORD PTR _Option2$156147[ebp], ebx
  00137	89 55 d8	 mov	 DWORD PTR _Level$156145[ebp], edx

; 1592 : 				int Option3 = 0;
; 1593 : 
; 1594 : 				if ( (rand()%100)< (lpObj->ChaosSuccessRate/5 + 6) )

  0013a	e8 00 00 00 00	 call	 _rand
  0013f	99		 cdq
  00140	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00145	f7 f9		 idiv	 ecx
  00147	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0014c	8b fa		 mov	 edi, edx
  0014e	f7 ae e8 0c 00
	00		 imul	 DWORD PTR [esi+3304]
  00154	d1 fa		 sar	 edx, 1
  00156	8b c2		 mov	 eax, edx
  00158	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0015b	8d 4c 02 06	 lea	 ecx, DWORD PTR [edx+eax+6]
  0015f	3b f9		 cmp	 edi, ecx
  00161	7d 07		 jge	 SHORT $LN39@DefaultCha

; 1595 : 				{
; 1596 : 					Option1 = 1;

  00163	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _Option1$156146[ebp], 1
$LN39@DefaultCha:

; 1597 : 				}
; 1598 : 
; 1599 : 				if ( (rand()%100)< (lpObj->ChaosSuccessRate/5 + 4) )

  0016a	e8 00 00 00 00	 call	 _rand
  0016f	99		 cdq
  00170	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00175	f7 f9		 idiv	 ecx
  00177	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0017c	8b fa		 mov	 edi, edx
  0017e	f7 ae e8 0c 00
	00		 imul	 DWORD PTR [esi+3304]
  00184	d1 fa		 sar	 edx, 1
  00186	8b c2		 mov	 eax, edx
  00188	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0018b	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  0018f	3b f9		 cmp	 edi, ecx
  00191	7d 07		 jge	 SHORT $LN24@DefaultCha

; 1600 : 				{
; 1601 : 					Option2 = 1;

  00193	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _Option2$156147[ebp], 1
$LN24@DefaultCha:

; 1602 : 				}
; 1603 : 
; 1604 : 				int OpProb;
; 1605 : 				int OpType = rand()%3;

  0019a	e8 00 00 00 00	 call	 _rand
  0019f	99		 cdq
  001a0	b9 03 00 00 00	 mov	 ecx, 3
  001a5	f7 f9		 idiv	 ecx
  001a7	8b fa		 mov	 edi, edx

; 1606 : 				OpProb = rand()%100;

  001a9	e8 00 00 00 00	 call	 _rand
  001ae	99		 cdq
  001af	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001b4	f7 f9		 idiv	 ecx

; 1607 : 
; 1608 : 				switch ( OpType )

  001b6	8b c7		 mov	 eax, edi
  001b8	83 e8 00	 sub	 eax, 0
  001bb	8b ca		 mov	 ecx, edx
  001bd	74 48		 je	 SHORT $LN21@DefaultCha
  001bf	48		 dec	 eax
  001c0	74 24		 je	 SHORT $LN19@DefaultCha
  001c2	48		 dec	 eax
  001c3	75 61		 jne	 SHORT $LN36@DefaultCha

; 1623 : 
; 1624 : 					case 2:
; 1625 : 						if ( OpProb < (lpObj->ChaosSuccessRate / 5 + 12) ) 

  001c5	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  001ca	f7 ae e8 0c 00
	00		 imul	 DWORD PTR [esi+3304]
  001d0	d1 fa		 sar	 edx, 1
  001d2	8b c2		 mov	 eax, edx
  001d4	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001d7	8d 54 02 0c	 lea	 edx, DWORD PTR [edx+eax+12]
  001db	3b ca		 cmp	 ecx, edx
  001dd	7d 47		 jge	 SHORT $LN36@DefaultCha

; 1626 : 						{
; 1627 : 							Option3 = 1;

  001df	bb 01 00 00 00	 mov	 ebx, 1

; 1628 : 						}
; 1629 : 						break;

  001e4	eb 40		 jmp	 SHORT $LN36@DefaultCha
$LN19@DefaultCha:

; 1614 : 						}
; 1615 : 						break;
; 1616 : 
; 1617 : 					case 1:
; 1618 : 						if ( OpProb < (lpObj->ChaosSuccessRate / 5 + 8) ) 

  001e6	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  001eb	f7 ae e8 0c 00
	00		 imul	 DWORD PTR [esi+3304]
  001f1	d1 fa		 sar	 edx, 1
  001f3	8b c2		 mov	 eax, edx
  001f5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001f8	8d 54 02 08	 lea	 edx, DWORD PTR [edx+eax+8]
  001fc	3b ca		 cmp	 ecx, edx
  001fe	7d 26		 jge	 SHORT $LN36@DefaultCha

; 1619 : 						{
; 1620 : 							Option3 = 2;

  00200	bb 02 00 00 00	 mov	 ebx, 2

; 1621 : 						}
; 1622 : 						break;

  00205	eb 1f		 jmp	 SHORT $LN36@DefaultCha
$LN21@DefaultCha:

; 1609 : 				{
; 1610 : 					case 0:
; 1611 : 						if ( OpProb < (lpObj->ChaosSuccessRate / 5 + 4) ) 

  00207	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0020c	f7 ae e8 0c 00
	00		 imul	 DWORD PTR [esi+3304]
  00212	d1 fa		 sar	 edx, 1
  00214	8b c2		 mov	 eax, edx
  00216	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00219	8d 54 02 04	 lea	 edx, DWORD PTR [edx+eax+4]
  0021d	3b ca		 cmp	 ecx, edx
  0021f	7d 05		 jge	 SHORT $LN36@DefaultCha

; 1612 : 						{
; 1613 : 							Option3 = 3;

  00221	bb 03 00 00 00	 mov	 ebx, 3
$LN36@DefaultCha:

; 1630 : 				}
; 1631 : 
; 1632 : 				if ( MixResult2 == TRUE )
; 1633 : 				{
; 1634 : 					int WingType = rand()%3;

  00226	e8 00 00 00 00	 call	 _rand
  0022b	99		 cdq
  0022c	b9 03 00 00 00	 mov	 ecx, 3
  00231	f7 f9		 idiv	 ecx

; 1635 : 					int WingNum = 0;

  00233	33 c0		 xor	 eax, eax
  00235	83 7d d4 01	 cmp	 DWORD PTR _MixResult2$[ebp], 1
  00239	75 46		 jne	 SHORT $LN15@DefaultCha

; 1636 : 
; 1637 : 					if ( WingType == 0 )

  0023b	85 d2		 test	 edx, edx
  0023d	75 07		 jne	 SHORT $LN14@DefaultCha

; 1638 : 					{
; 1639 : 						WingNum = ITEMGET(12,0);

  0023f	b8 00 18 00 00	 mov	 eax, 6144		; 00001800H
  00244	eb 16		 jmp	 SHORT $LN10@DefaultCha
$LN14@DefaultCha:

; 1640 : 					}
; 1641 : 					else if ( WingType == 1 )

  00246	83 fa 01	 cmp	 edx, 1
  00249	75 07		 jne	 SHORT $LN12@DefaultCha

; 1642 : 					{
; 1643 : 						WingNum = ITEMGET(12,1);

  0024b	b8 01 18 00 00	 mov	 eax, 6145		; 00001801H
  00250	eb 0a		 jmp	 SHORT $LN10@DefaultCha
$LN12@DefaultCha:

; 1644 : 					}
; 1645 : 					else if ( WingType == 2 )

  00252	83 fa 02	 cmp	 edx, 2
  00255	75 05		 jne	 SHORT $LN10@DefaultCha

; 1646 : 					{
; 1647 : 						WingNum = ITEMGET(12,2);

  00257	b8 02 18 00 00	 mov	 eax, 6146		; 00001802H
$LN10@DefaultCha:

; 1648 : 					}
; 1649 : 
; 1650 : 					::ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, WingNum, 0, 255, Option1, Option2, Option3, -1, 0, 0);

  0025c	8b 55 e4	 mov	 edx, DWORD PTR _Option2$156147[ebp]
  0025f	8b 4d ec	 mov	 ecx, DWORD PTR _Option1$156146[ebp]
  00262	6a 00		 push	 0
  00264	6a 00		 push	 0
  00266	6a ff		 push	 -1
  00268	53		 push	 ebx
  00269	52		 push	 edx
  0026a	8b 16		 mov	 edx, DWORD PTR [esi]
  0026c	51		 push	 ecx
  0026d	68 ff 00 00 00	 push	 255			; 000000ffH
  00272	6a 00		 push	 0
  00274	50		 push	 eax
  00275	6a 00		 push	 0
  00277	6a 00		 push	 0
  00279	68 ff 00 00 00	 push	 255			; 000000ffH
  0027e	52		 push	 edx

; 1651 : 				}
; 1652 : 				else

  0027f	eb 46		 jmp	 SHORT $LN42@DefaultCha
$LN15@DefaultCha:

; 1653 : 				{
; 1654 : 					int ChaosItemType = rand()%3;
; 1655 : 					int ChaosItemNum = 0;
; 1656 : 
; 1657 : 					if ( ChaosItemType == 0 )	// Chaos Dragon Axe

  00281	85 d2		 test	 edx, edx
  00283	75 07		 jne	 SHORT $LN8@DefaultCha

; 1658 : 					{
; 1659 : 						ChaosItemNum = ITEMGET(2,6);

  00285	b8 06 04 00 00	 mov	 eax, 1030		; 00000406H
  0028a	eb 16		 jmp	 SHORT $LN4@DefaultCha
$LN8@DefaultCha:

; 1660 : 					}
; 1661 : 					else if ( ChaosItemType == 1 )	// Chaos Nature Bow

  0028c	83 fa 01	 cmp	 edx, 1
  0028f	75 07		 jne	 SHORT $LN6@DefaultCha

; 1662 : 					{
; 1663 : 						ChaosItemNum = ITEMGET(4,6);

  00291	b8 06 08 00 00	 mov	 eax, 2054		; 00000806H
  00296	eb 0a		 jmp	 SHORT $LN4@DefaultCha
$LN6@DefaultCha:

; 1664 : 					}
; 1665 : 					else if ( ChaosItemType == 2 )	// Chaos Lighting Staff

  00298	83 fa 02	 cmp	 edx, 2
  0029b	75 05		 jne	 SHORT $LN4@DefaultCha

; 1666 : 					{
; 1667 : 						ChaosItemNum = ITEMGET(5,7);

  0029d	b8 07 0a 00 00	 mov	 eax, 2567		; 00000a07H
$LN4@DefaultCha:

; 1668 : 					}
; 1669 : 
; 1670 : 					::ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ChaosItemNum, Level, 255, Option1, Option2, Option3, -1, 0, 0);

  002a2	8b 55 e4	 mov	 edx, DWORD PTR _Option2$156147[ebp]
  002a5	8b 4d ec	 mov	 ecx, DWORD PTR _Option1$156146[ebp]
  002a8	6a 00		 push	 0
  002aa	6a 00		 push	 0
  002ac	6a ff		 push	 -1
  002ae	53		 push	 ebx
  002af	52		 push	 edx
  002b0	8b 55 d8	 mov	 edx, DWORD PTR _Level$156145[ebp]
  002b3	51		 push	 ecx
  002b4	68 ff 00 00 00	 push	 255			; 000000ffH
  002b9	52		 push	 edx
  002ba	50		 push	 eax
  002bb	8b 06		 mov	 eax, DWORD PTR [esi]
  002bd	6a 00		 push	 0
  002bf	6a 00		 push	 0
  002c1	68 ff 00 00 00	 push	 255			; 000000ffH
  002c6	50		 push	 eax
$LN42@DefaultCha:
  002c7	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  002cc	8b 7d e0	 mov	 edi, DWORD PTR _aIndex$[ebp]
  002cf	83 c4 34	 add	 esp, 52			; 00000034H
  002d2	33 db		 xor	 ebx, ebx
$LN40@DefaultCha:

; 1671 : 				}
; 1672 : 			}
; 1673 : 		}
; 1674 : 
; 1675 : 
; 1676 : 		lpObj->Money -= lpObj->ChaosMoney;

  002d4	8b 8e e4 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3300]

; 1677 : 		g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  002da	8b 55 e8	 mov	 edx, DWORD PTR _iChaosTaxMoney$[ebp]
  002dd	29 8e b0 00 00
	00		 sub	 DWORD PTR [esi+176], ecx
  002e3	52		 push	 edx
  002e4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  002e9	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 1678 : 		GCMoneySend(lpObj->m_Index, lpObj->Money);

  002ee	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  002f4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002f6	50		 push	 eax
  002f7	51		 push	 ecx
  002f8	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  002fd	83 c4 08	 add	 esp, 8

; 1679 : 
; 1680 : 		if ( fail == TRUE )

  00300	83 7d dc 01	 cmp	 DWORD PTR _fail$[ebp], 1
  00304	75 54		 jne	 SHORT $LN3@DefaultCha

; 1681 : 		{
; 1682 : 			ChaosBoxItemDown(lpObj);

  00306	56		 push	 esi
  00307	e8 00 00 00 00	 call	 ?ChaosBoxItemDown@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxItemDown

; 1683 : 			GCUserChaosBoxSend(lpObj, 0);

  0030c	53		 push	 ebx
  0030d	56		 push	 esi
  0030e	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 1684 : 			DataSend(aIndex, (BYTE*)&pMsg, pMsg.h.size);

  00313	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00317	52		 push	 edx
  00318	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0031b	50		 push	 eax
  0031c	57		 push	 edi
  0031d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1685 : 			LogAdd(LOG_BLACK, "[%s][%s] CBMix Fail %d Money : %d-%d",
; 1686 : 				lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate,
; 1687 : 				lpObj->Money, lpObj->ChaosMoney);

  00322	8b 8e e4 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3300]
  00328	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  0032e	8b 86 e8 0c 00
	00		 mov	 eax, DWORD PTR [esi+3304]
  00334	51		 push	 ecx
  00335	52		 push	 edx
  00336	50		 push	 eax
  00337	8d 7e 6f	 lea	 edi, DWORD PTR [esi+111]
  0033a	57		 push	 edi
  0033b	8d 5e 64	 lea	 ebx, DWORD PTR [esi+100]
  0033e	53		 push	 ebx
  0033f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NPEOFJKC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5?$CFd?5Money?5?3?5?$CF@
  00344	6a 00		 push	 0
  00346	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0034b	83 c4 34	 add	 esp, 52			; 00000034H

; 1688 : 			lpObj->ChaosLock = FALSE;

  0034e	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0

; 1689 : 		}
; 1690 : 		else

  00358	eb 25		 jmp	 SHORT $LN2@DefaultCha
$LN3@DefaultCha:

; 1691 : 		{
; 1692 : 			LogAdd(LOG_BLACK, "[%s][%s] CBMix Success Rate:%d Money : %d",
; 1693 : 				lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate,
; 1694 : 				lpObj->ChaosMoney);

  0035a	8b 8e e4 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3300]
  00360	8b 96 e8 0c 00
	00		 mov	 edx, DWORD PTR [esi+3304]
  00366	51		 push	 ecx
  00367	52		 push	 edx
  00368	8d 7e 6f	 lea	 edi, DWORD PTR [esi+111]
  0036b	57		 push	 edi
  0036c	8d 5e 64	 lea	 ebx, DWORD PTR [esi+100]
  0036f	53		 push	 ebx
  00370	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IKEPLJDI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Success?5Rate?3?$CFd?5M@
  00375	6a 00		 push	 0
  00377	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0037c	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@DefaultCha:

; 1695 : 		}
; 1696 : 
; 1697 : 		if ( gChaosEvent != FALSE )

  0037f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gChaosEvent@@3HA, 0 ; gChaosEvent
  00386	74 0d		 je	 SHORT $LN1@DefaultCha

; 1698 : 		{
; 1699 : 			CBUPS_ItemRequest(lpObj->m_Index, lpObj->AccountID, lpObj->Name);

  00388	8b 06		 mov	 eax, DWORD PTR [esi]
  0038a	57		 push	 edi
  0038b	53		 push	 ebx
  0038c	50		 push	 eax
  0038d	e8 00 00 00 00	 call	 ?CBUPS_ItemRequest@@YAXHPAD0@Z ; CBUPS_ItemRequest
$LN41@DefaultCha:
  00392	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@DefaultCha:

; 1700 : 		}
; 1701 : 	}
; 1702 : 
; 1703 : 	::gObjInventoryCommit(lpObj->m_Index);

  00395	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00397	51		 push	 ecx
  00398	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit

; 1704 : }

  0039d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a0	83 c4 04	 add	 esp, 4
  003a3	5b		 pop	 ebx
  003a4	5f		 pop	 edi
  003a5	33 cd		 xor	 ecx, ebp
  003a7	5e		 pop	 esi
  003a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ad	8b e5		 mov	 esp, ebp
  003af	5d		 pop	 ebp
  003b0	c3		 ret	 0
?DefaultChaosMix@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; DefaultChaosMix
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?BloodCastleItemChaosMix@@YAXPAUOBJECTSTRUCT@@@Z ; BloodCastleItemChaosMix
EXTRN	?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z:PROC ; CBloodCastle::BloodCastleChaosMix
EXTRN	?CheckChoasMixItem@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::CheckChoasMixItem
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
; Function compile flags: /Ogtp
;	COMDAT ?BloodCastleItemChaosMix@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?BloodCastleItemChaosMix@@YAXPAUOBJECTSTRUCT@@@Z PROC	; BloodCastleItemChaosMix, COMDAT

; 1801 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 1802 : 	lpObj->ChaosLock = TRUE;
; 1803 : 	
; 1804 : 	PMSG_CHAOSMIXRESULT pMsg;
; 1805 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00016	6a 0b		 push	 11			; 0000000bH
  00018	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001b	68 86 00 00 00	 push	 134			; 00000086H
  00020	50		 push	 eax
  00021	c7 86 ec 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3308], 1
  0002b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1806 : 	pMsg.Result = CB_ERROR;
; 1807 : 
; 1808 : 	int aIndex = lpObj->m_Index;

  00030	8b 3e		 mov	 edi, DWORD PTR [esi]
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	33 db		 xor	 ebx, ebx

; 1809 : 
; 1810 : 	int iRET_VAL = g_BloodCastle.CheckChoasMixItem(aIndex);

  00037	57		 push	 edi
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0003d	88 5d f3	 mov	 BYTE PTR _pMsg$[ebp+3], bl
  00040	e8 00 00 00 00	 call	 ?CheckChoasMixItem@CBloodCastle@@QAEHH@Z ; CBloodCastle::CheckChoasMixItem

; 1811 : 
; 1812 : 	if ( BC_MAP_RANGE((iRET_VAL+(MAP_INDEX_BLOODCASTLE1-1))) != FALSE )

  00045	8d 48 0a	 lea	 ecx, DWORD PTR [eax+10]
  00048	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0004b	7c 1e		 jl	 SHORT $LN12@BloodCastl
  0004d	33 d2		 xor	 edx, edx
  0004f	83 f9 11	 cmp	 ecx, 17			; 00000011H
  00052	0f 9e c2	 setle	 dl
  00055	3b d3		 cmp	 edx, ebx
  00057	74 12		 je	 SHORT $LN12@BloodCastl

; 1813 : 	{
; 1814 : 		if ( g_BloodCastle.BloodCastleChaosMix(aIndex, iRET_VAL) == false )

  00059	50		 push	 eax
  0005a	57		 push	 edi
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00060	e8 00 00 00 00	 call	 ?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z ; CBloodCastle::BloodCastleChaosMix
  00065	84 c0		 test	 al, al
  00067	75 75		 jne	 SHORT $LN9@BloodCastl

; 1815 : 		{
; 1816 : 			lpObj->ChaosLock = FALSE;
; 1817 : 		}
; 1818 : 
; 1819 : 		return;

  00069	eb 6d		 jmp	 SHORT $LN1@BloodCastl
$LN12@BloodCastl:

; 1820 : 	}
; 1821 : 
; 1822 : 	switch ( iRET_VAL )

  0006b	83 c0 f7	 add	 eax, -9			; fffffff7H
  0006e	83 f8 06	 cmp	 eax, 6
  00071	77 65		 ja	 SHORT $LN1@BloodCastl
  00073	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN19@BloodCastl[eax*4]
$LN8@BloodCastl:

; 1823 : 	{
; 1824 : 		case 9:
; 1825 : 			pMsg.Result = CB_NO_BC_CORRECT_ITEMS	;

  0007a	c6 45 f3 0a	 mov	 BYTE PTR _pMsg$[ebp+3], 10 ; 0000000aH

; 1826 : 			DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);
; 1827 : 			lpObj->m_Index;
; 1828 : 			lpObj->ChaosLock = FALSE;
; 1829 : 			break;

  0007e	eb 46		 jmp	 SHORT $LN17@BloodCastl
$LN7@BloodCastl:

; 1830 : 
; 1831 : 		case 10:
; 1832 : 			pMsg.Result = CB_NO_BC_CORRECT_ITEMS	;
; 1833 : 			DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00080	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00084	52		 push	 edx
  00085	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00088	c6 45 f3 0a	 mov	 BYTE PTR _pMsg$[ebp+3], 10 ; 0000000aH
  0008c	50		 push	 eax

; 1834 : 			lpObj->m_Index;
; 1835 : 			lpObj->ChaosLock = FALSE;
; 1836 : 			break;

  0008d	eb 40		 jmp	 SHORT $LN18@BloodCastl
$LN6@BloodCastl:

; 1837 : 
; 1838 : 		case 11:
; 1839 : 			pMsg.Result = CB_NO_BC_CORRECT_ITEMS	;
; 1840 : 			DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0008f	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00093	51		 push	 ecx
  00094	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00097	c6 45 f3 0a	 mov	 BYTE PTR _pMsg$[ebp+3], 10 ; 0000000aH
  0009b	52		 push	 edx

; 1841 : 			lpObj->m_Index;
; 1842 : 			lpObj->ChaosLock = FALSE;
; 1843 : 			break;

  0009c	eb 31		 jmp	 SHORT $LN18@BloodCastl
$LN5@BloodCastl:

; 1844 : 
; 1845 : 		case 12:
; 1846 : 			pMsg.Result = CB_INVALID_ITEM_LEVEL	;

  0009e	c6 45 f3 08	 mov	 BYTE PTR _pMsg$[ebp+3], 8

; 1847 : 			DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);
; 1848 : 			lpObj->m_Index;
; 1849 : 			lpObj->ChaosLock = FALSE;
; 1850 : 			break;

  000a2	eb 22		 jmp	 SHORT $LN17@BloodCastl
$LN4@BloodCastl:

; 1851 : 
; 1852 : 		case 13:
; 1853 : 			pMsg.Result = CB_BC_NOT_ENOUGH_ZEN	;
; 1854 : 			DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  000a4	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  000a8	52		 push	 edx
  000a9	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ac	c6 45 f3 0b	 mov	 BYTE PTR _pMsg$[ebp+3], 11 ; 0000000bH
  000b0	50		 push	 eax

; 1855 : 			lpObj->m_Index;
; 1856 : 			lpObj->ChaosLock = FALSE;
; 1857 : 			break;

  000b1	eb 1c		 jmp	 SHORT $LN18@BloodCastl
$LN3@BloodCastl:

; 1858 : 
; 1859 : 		case 14:
; 1860 : 			pMsg.Result = CB_USER_CLASS_LOW_LEVEL	;
; 1861 : 			DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  000b3	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000b7	51		 push	 ecx
  000b8	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000bb	c6 45 f3 09	 mov	 BYTE PTR _pMsg$[ebp+3], 9
  000bf	52		 push	 edx

; 1862 : 			lpObj->m_Index;
; 1863 : 			lpObj->ChaosLock = FALSE;
; 1864 : 			break;

  000c0	eb 0d		 jmp	 SHORT $LN18@BloodCastl
$LN2@BloodCastl:

; 1865 : 		case 15:
; 1866 : 			pMsg.Result = 0xF0;

  000c2	c6 45 f3 f0	 mov	 BYTE PTR _pMsg$[ebp+3], 240 ; 000000f0H
$LN17@BloodCastl:

; 1867 : 			DataSend(aIndex, (BYTE*)&pMsg, pMsg.h.size);

  000c6	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000ca	50		 push	 eax
  000cb	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000ce	51		 push	 ecx
$LN18@BloodCastl:
  000cf	57		 push	 edi
  000d0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@BloodCastl:

; 1868 : 			lpObj->ChaosLock = FALSE;
; 1869 : 			break;
; 1870 : 		default:
; 1871 : 			lpObj->ChaosLock = FALSE;

  000d8	89 9e ec 0c 00
	00		 mov	 DWORD PTR [esi+3308], ebx
$LN9@BloodCastl:

; 1872 : 	}
; 1873 : 
; 1874 : }

  000de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	33 cd		 xor	 ecx, ebp
  000e5	5b		 pop	 ebx
  000e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
  000ef	90		 npad	 1
$LN19@BloodCastl:
  000f0	00 00 00 00	 DD	 $LN8@BloodCastl
  000f4	00 00 00 00	 DD	 $LN7@BloodCastl
  000f8	00 00 00 00	 DD	 $LN6@BloodCastl
  000fc	00 00 00 00	 DD	 $LN5@BloodCastl
  00100	00 00 00 00	 DD	 $LN4@BloodCastl
  00104	00 00 00 00	 DD	 $LN3@BloodCastl
  00108	00 00 00 00	 DD	 $LN2@BloodCastl
?BloodCastleItemChaosMix@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; BloodCastleItemChaosMix
_TEXT	ENDS
PUBLIC	?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z		; ChaosBoxInit
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??0CItem@@QAE@XZ:PROC				; CItem::CItem
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z$0
__ehfuncinfo$?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T156855 = 8						; size = 4
_lpObj$ = 8						; size = 4
?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z PROC		; ChaosBoxInit, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 25   : 	int n;
; 26   : 
; 27   : 	if ( lpObj->pChaosBox != NULL )

  00025	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00028	83 bf dc 0c 00
	00 00		 cmp	 DWORD PTR [edi+3292], 0
  0002f	74 34		 je	 SHORT $LN12@ChaosBoxIn

; 28   : 	{
; 29   : 		for (n=0;n<CHAOS_BOX_SIZE;n++)

  00031	33 f6		 xor	 esi, esi
$LL11@ChaosBoxIn:

; 30   : 		{
; 31   : 			lpObj->pChaosBox[n].Clear();

  00033	8b 8f dc 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3292]
  00039	03 ce		 add	 ecx, esi
  0003b	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  00040	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00046	81 fe 00 15 00
	00		 cmp	 esi, 5376		; 00001500H
  0004c	7c e5		 jl	 SHORT $LL11@ChaosBoxIn

; 32   : 		}
; 33   : 
; 34   : 		for (n=0;n<CHAOS_BOX_SIZE;n++)

  0004e	33 c0		 xor	 eax, eax
$LL8@ChaosBoxIn:

; 35   : 		{
; 36   : 			lpObj->pChaosBoxMap[n] = -1;

  00050	8b 8f e0 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3296]
  00056	c6 04 08 ff	 mov	 BYTE PTR [eax+ecx], 255	; 000000ffH
  0005a	40		 inc	 eax
  0005b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0005e	7c f0		 jl	 SHORT $LL8@ChaosBoxIn

; 37   : 		}
; 38   : 		return true;

  00060	e9 9b 00 00 00	 jmp	 $LN31@ChaosBoxIn
$LN12@ChaosBoxIn:

; 39   : 	}
; 40   : 
; 41   : 	lpObj->pChaosBox = new CItem[CHAOS_BOX_SIZE];

  00065	68 00 15 00 00	 push	 5376			; 00001500H
  0006a	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0006f	83 c4 04	 add	 esp, 4
  00072	89 45 08	 mov	 DWORD PTR $T156855[ebp], eax
  00075	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007c	85 c0		 test	 eax, eax
  0007e	74 1c		 je	 SHORT $LN15@ChaosBoxIn
  00080	8b f0		 mov	 esi, eax
  00082	bb 1f 00 00 00	 mov	 ebx, 31			; 0000001fH
$LL19@ChaosBoxIn:
  00087	8b ce		 mov	 ecx, esi
  00089	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  0008e	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00094	4b		 dec	 ebx
  00095	79 f0		 jns	 SHORT $LL19@ChaosBoxIn
  00097	8b 45 08	 mov	 eax, DWORD PTR $T156855[ebp]
  0009a	eb 02		 jmp	 SHORT $LN16@ChaosBoxIn
$LN15@ChaosBoxIn:
  0009c	33 c0		 xor	 eax, eax
$LN16@ChaosBoxIn:
  0009e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a5	89 87 dc 0c 00
	00		 mov	 DWORD PTR [edi+3292], eax

; 42   : 
; 43   : 	if ( lpObj->pChaosBox == NULL )

  000ab	85 c0		 test	 eax, eax

; 44   : 	{
; 45   : 		return false;

  000ad	74 23		 je	 SHORT $LN32@ChaosBoxIn

; 46   : 	}
; 47   : 
; 48   : 	lpObj->pChaosBoxMap = new unsigned char[CHAOS_BOX_SIZE];

  000af	6a 20		 push	 32			; 00000020H
  000b1	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000b6	83 c4 04	 add	 esp, 4
  000b9	89 87 e0 0c 00
	00		 mov	 DWORD PTR [edi+3296], eax

; 49   : 
; 50   : 	if ( lpObj->pChaosBoxMap == NULL )

  000bf	85 c0		 test	 eax, eax
  000c1	75 23		 jne	 SHORT $LN4@ChaosBoxIn

; 51   : 	{
; 52   : 		delete lpObj->pChaosBox;

  000c3	8b 97 dc 0c 00
	00		 mov	 edx, DWORD PTR [edi+3292]
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000cf	83 c4 04	 add	 esp, 4
$LN32@ChaosBoxIn:

; 53   : 		return false;

  000d2	33 c0		 xor	 eax, eax

; 62   : }

  000d4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000de	59		 pop	 ecx
  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
$LN4@ChaosBoxIn:

; 54   : 	}
; 55   : 
; 56   : 	for (n=0;n<CHAOS_BOX_SIZE;n++)

  000e6	33 c0		 xor	 eax, eax
  000e8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL3@ChaosBoxIn:

; 57   : 	{
; 58   : 		lpObj->pChaosBoxMap[n] = -1;

  000f0	8b 8f e0 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3296]
  000f6	c6 04 08 ff	 mov	 BYTE PTR [eax+ecx], 255	; 000000ffH
  000fa	40		 inc	 eax
  000fb	83 f8 20	 cmp	 eax, 32			; 00000020H
  000fe	7c f0		 jl	 SHORT $LL3@ChaosBoxIn
$LN31@ChaosBoxIn:

; 59   : 	}
; 60   : 
; 61   : 	return true;

  00100	b8 01 00 00 00	 mov	 eax, 1

; 62   : }

  00105	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00108	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010f	59		 pop	 ecx
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR $T156855[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; ChaosBoxInit
PUBLIC	?ChaosEventProtocolCore@@YAXEPAEH@Z		; ChaosEventProtocolCore
; Function compile flags: /Ogtp
;	COMDAT ?ChaosEventProtocolCore@@YAXEPAEH@Z
_TEXT	SEGMENT
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
?ChaosEventProtocolCore@@YAXEPAEH@Z PROC		; ChaosEventProtocolCore, COMDAT

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 269  : 	#ifdef TRACE_PROTOCOL
; 270  : 		LogAddHeadHex("CHAOS_EVENT", aRecv, aLen);
; 271  : 	#endif
; 272  : 
; 273  : 	switch ( protoNum )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  00007	48		 dec	 eax
  00008	75 0c		 jne	 SHORT $LN2@ChaosEvent

; 274  : 	{
; 275  : 		case 0x01:
; 276  : 			CBUPR_ItemRequestRecv( (CB_PMSG_REQ_PRESENT_RESULT *)aRecv);

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?CBUPR_ItemRequestRecv@@YAXPAUCB_PMSG_REQ_PRESENT_RESULT@@@Z ; CBUPR_ItemRequestRecv
  00013	83 c4 04	 add	 esp, 4
$LN2@ChaosEvent:

; 277  : 			break;
; 278  : 	}
; 279  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?ChaosEventProtocolCore@@YAXEPAEH@Z ENDP		; ChaosEventProtocolCore
_TEXT	ENDS
PUBLIC	??_C@_0CA@IANBADIL@?$FLDevilSquare?$FN?5DQItems?5Not?5Found?$AA@ ; `string'
PUBLIC	??_C@_0CH@EJJKJEAB@?$FLDevilSquare?$FN?5Charm?5Of?5Luck?5Coun@ ; `string'
PUBLIC	??_C@_0CG@FFFDDFEO@?$FLDevilSquare?$FN?5DiffLevel?5DQItems?5@ ; `string'
PUBLIC	??_C@_0CC@LINAPAPC@?$FLDevilSquare?$FN?5Other?5DQItems?5Foun@ ; `string'
PUBLIC	??_C@_0CF@MGDMILOL@?$FLDevilSquare?$FN?5Search?5DevilSquare@ ; `string'
PUBLIC	?CheckDevilSquareItem@@YAHPAUOBJECTSTRUCT@@AAH1@Z ; CheckDevilSquareItem
;	COMDAT ??_C@_0CA@IANBADIL@?$FLDevilSquare?$FN?5DQItems?5Not?5Found?$AA@
CONST	SEGMENT
??_C@_0CA@IANBADIL@?$FLDevilSquare?$FN?5DQItems?5Not?5Found?$AA@ DB '[Dev'
	DB	'ilSquare] DQItems Not Found', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EJJKJEAB@?$FLDevilSquare?$FN?5Charm?5Of?5Luck?5Coun@
CONST	SEGMENT
??_C@_0CH@EJJKJEAB@?$FLDevilSquare?$FN?5Charm?5Of?5Luck?5Coun@ DB '[Devil'
	DB	'Square] Charm Of Luck Count Over', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FFFDDFEO@?$FLDevilSquare?$FN?5DiffLevel?5DQItems?5@
CONST	SEGMENT
??_C@_0CG@FFFDDFEO@?$FLDevilSquare?$FN?5DiffLevel?5DQItems?5@ DB '[DevilS'
	DB	'quare] DiffLevel DQItems Found', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LINAPAPC@?$FLDevilSquare?$FN?5Other?5DQItems?5Foun@
CONST	SEGMENT
??_C@_0CC@LINAPAPC@?$FLDevilSquare?$FN?5Other?5DQItems?5Foun@ DB '[DevilS'
	DB	'quare] Other DQItems Found', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MGDMILOL@?$FLDevilSquare?$FN?5Search?5DevilSquare@
CONST	SEGMENT
??_C@_0CF@MGDMILOL@?$FLDevilSquare?$FN?5Search?5DevilSquare@ DB '[DevilSq'
	DB	'uare] Search DevilSquareItem', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckDevilSquareItem@@YAHPAUOBJECTSTRUCT@@AAH1@Z
_TEXT	SEGMENT
tv310 = -28						; size = 4
_bChaoseGem$ = -24					; size = 4
_bCharmOfLuckOver$ = -20				; size = 4
_FoundOtherItem$ = -16					; size = 4
_bKeyOfDevil$ = -12					; size = 4
_bEyeOfDevil$ = -8					; size = 4
_bLevelCheck$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iCharmOfLuckCount$ = 12				; size = 4
_eventitemcount$ = 12					; size = 4
_itemlevel$ = 16					; size = 4
?CheckDevilSquareItem@@YAHPAUOBJECTSTRUCT@@AAH1@Z PROC	; CheckDevilSquareItem, COMDAT

; 384  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx

; 385  : 	BOOL bChaoseGem = FALSE;
; 386  : 	BOOL bEyeOfDevil = FALSE;
; 387  : 	BOOL bKeyOfDevil = FALSE;
; 388  : 	eventitemcount = 0;

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _eventitemcount$[ebp]
  0000a	56		 push	 esi
  0000b	33 f6		 xor	 esi, esi
  0000d	57		 push	 edi

; 389  : 	BOOL FoundOtherItem = FALSE;
; 390  : 	int level = -1;
; 391  : 	BOOL bLevelCheck = FALSE;
; 392  : 	int iCharmOfLuckCount = 0;
; 393  : 	BOOL bCharmOfLuckOver = FALSE;
; 394  : 
; 395  : 	LogAdd(LOG_BLACK, "[DevilSquare] Search DevilSquareItem");

  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MGDMILOL@?$FLDevilSquare?$FN?5Search?5DevilSquare@
  00013	56		 push	 esi
  00014	89 75 e8	 mov	 DWORD PTR _bChaoseGem$[ebp], esi
  00017	89 75 f8	 mov	 DWORD PTR _bEyeOfDevil$[ebp], esi
  0001a	89 75 f4	 mov	 DWORD PTR _bKeyOfDevil$[ebp], esi
  0001d	89 33		 mov	 DWORD PTR [ebx], esi
  0001f	89 75 f0	 mov	 DWORD PTR _FoundOtherItem$[ebp], esi
  00022	83 cf ff	 or	 edi, -1
  00025	89 75 fc	 mov	 DWORD PTR _bLevelCheck$[ebp], esi
  00028	89 75 0c	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], esi
  0002b	89 75 ec	 mov	 DWORD PTR _bCharmOfLuckOver$[ebp], esi
  0002e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00033	83 c4 08	 add	 esp, 8
  00036	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL24@CheckDevil:

; 398  : 	{
; 399  : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00040	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00043	8b 88 dc 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3292]
  00049	03 ce		 add	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00050	83 f8 01	 cmp	 eax, 1
  00053	0f 85 9a 00 00
	00		 jne	 $LN23@CheckDevil

; 400  : 		{
; 401  : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,15) )	// Chaos

  00059	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0005c	8b 81 dc 0c 00
	00		 mov	 eax, DWORD PTR [ecx+3292]
  00062	03 c6		 add	 eax, esi
  00064	89 45 e4	 mov	 DWORD PTR tv310[ebp], eax
  00067	0f b7 40 06	 movzx	 eax, WORD PTR [eax+6]
  0006b	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  00070	66 3b c2	 cmp	 ax, dx
  00073	75 09		 jne	 SHORT $LN20@CheckDevil

; 402  : 			{
; 403  : 				bChaoseGem = TRUE;

  00075	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bChaoseGem$[ebp], 1
  0007c	eb 75		 jmp	 SHORT $LN23@CheckDevil
$LN20@CheckDevil:

; 404  : 			}
; 405  : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,17) )	// Eye

  0007e	ba 11 1c 00 00	 mov	 edx, 7185		; 00001c11H
  00083	66 3b c2	 cmp	 ax, dx
  00086	75 22		 jne	 SHORT $LN18@CheckDevil

; 406  : 			{
; 407  : 				eventitemcount +=1;

  00088	ba 01 00 00 00	 mov	 edx, 1

; 408  : 				bEyeOfDevil = TRUE;

  0008d	89 55 f8	 mov	 DWORD PTR _bEyeOfDevil$[ebp], edx
$LN33@CheckDevil:

; 409  : 
; 410  : 				if ( level != lpObj->pChaosBox[n].m_Level )

  00090	01 13		 add	 DWORD PTR [ebx], edx
  00092	8b 81 dc 0c 00
	00		 mov	 eax, DWORD PTR [ecx+3292]
  00098	0f bf 44 30 08	 movsx	 eax, WORD PTR [eax+esi+8]
  0009d	3b f8		 cmp	 edi, eax
  0009f	74 52		 je	 SHORT $LN23@CheckDevil

; 411  : 				{
; 412  : 					if ( level == -1 )

  000a1	83 ff ff	 cmp	 edi, -1
  000a4	75 18		 jne	 SHORT $LN11@CheckDevil

; 413  : 					{
; 414  : 						level = lpObj->pChaosBox[n].m_Level;

  000a6	8b f8		 mov	 edi, eax

; 415  : 					}
; 416  : 					else

  000a8	eb 49		 jmp	 SHORT $LN23@CheckDevil
$LN18@CheckDevil:

; 417  : 					{
; 418  : 						bLevelCheck = TRUE;
; 419  : 					}
; 420  : 				}
; 421  : 			}
; 422  : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,18) )	// Key

  000aa	ba 12 1c 00 00	 mov	 edx, 7186		; 00001c12H
  000af	66 3b c2	 cmp	 ax, dx
  000b2	75 0f		 jne	 SHORT $LN13@CheckDevil

; 423  : 			{
; 424  : 				eventitemcount +=1;

  000b4	ba 01 00 00 00	 mov	 edx, 1

; 425  : 				bKeyOfDevil = TRUE;

  000b9	89 55 f4	 mov	 DWORD PTR _bKeyOfDevil$[ebp], edx

; 426  : 
; 427  : 				if ( level != lpObj->pChaosBox[n].m_Level )
; 428  : 				{
; 429  : 					if ( level == -1 )
; 430  : 					{
; 431  : 						level = lpObj->pChaosBox[n].m_Level;
; 432  : 					}
; 433  : 					else

  000bc	eb d2		 jmp	 SHORT $LN33@CheckDevil
$LN11@CheckDevil:

; 434  : 					{
; 435  : 						bLevelCheck = TRUE;

  000be	89 55 fc	 mov	 DWORD PTR _bLevelCheck$[ebp], edx

; 436  : 					}
; 437  : 				}
; 438  : 			}

  000c1	eb 30		 jmp	 SHORT $LN23@CheckDevil
$LN13@CheckDevil:

; 439  : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,53) )	// Charm Of Luck

  000c3	b9 35 1c 00 00	 mov	 ecx, 7221		; 00001c35H
  000c8	66 3b c1	 cmp	 ax, cx
  000cb	75 1f		 jne	 SHORT $LN8@CheckDevil

; 440  : 			{
; 441  : 				iCharmOfLuckCount += lpObj->pChaosBox[n].m_Durability;

  000cd	db 45 0c	 fild	 DWORD PTR _iCharmOfLuckCount$[ebp]
  000d0	8b 55 e4	 mov	 edx, DWORD PTR tv310[ebp]
  000d3	d8 42 24	 fadd	 DWORD PTR [edx+36]
  000d6	e8 00 00 00 00	 call	 __ftol2_sse
  000db	89 45 0c	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], eax

; 442  : 
; 443  : 				if ( iCharmOfLuckCount > 10 )

  000de	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000e1	7e 10		 jle	 SHORT $LN23@CheckDevil

; 444  : 				{
; 445  : 					bCharmOfLuckOver = TRUE;

  000e3	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _bCharmOfLuckOver$[ebp], 1

; 446  : 				}
; 447  : 			}
; 448  : 			else

  000ea	eb 07		 jmp	 SHORT $LN23@CheckDevil
$LN8@CheckDevil:

; 449  : 			{
; 450  : 				FoundOtherItem = TRUE;

  000ec	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _FoundOtherItem$[ebp], 1
$LN23@CheckDevil:

; 396  : 
; 397  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  000f3	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  000f9	81 fe 00 15 00
	00		 cmp	 esi, 5376		; 00001500H
  000ff	0f 8c 3b ff ff
	ff		 jl	 $LL24@CheckDevil

; 451  : 			}
; 452  : 		}
; 453  : 	}
; 454  : 
; 455  : 	itemlevel = level;
; 456  : 	lpObj->ChaosSuccessRate = iCharmOfLuckCount;
; 457  : 
; 458  : 	if ( FoundOtherItem != FALSE )

  00105	83 7d f0 00	 cmp	 DWORD PTR _FoundOtherItem$[ebp], 0
  00109	8b 45 10	 mov	 eax, DWORD PTR _itemlevel$[ebp]
  0010c	8b 4d 0c	 mov	 ecx, DWORD PTR _iCharmOfLuckCount$[ebp]
  0010f	89 38		 mov	 DWORD PTR [eax], edi
  00111	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00114	5f		 pop	 edi
  00115	5e		 pop	 esi
  00116	89 88 e8 0c 00
	00		 mov	 DWORD PTR [eax+3304], ecx
  0011c	5b		 pop	 ebx
  0011d	74 15		 je	 SHORT $LN5@CheckDevil

; 459  : 	{
; 460  : 		LogAdd(LOG_BLACK, "[DevilSquare] Other DQItems Found");

  0011f	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@LINAPAPC@?$FLDevilSquare?$FN?5Other?5DQItems?5Foun@

; 486  : 	}
; 487  : 
; 488  : 	LogAdd(LOG_BLACK, "[DevilSquare] DQItems Not Found");

  00124	6a 00		 push	 0
  00126	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0012b	83 c4 08	 add	 esp, 8

; 489  : 
; 490  : 	return 0;

  0012e	33 c0		 xor	 eax, eax

; 491  : }

  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c3		 ret	 0
$LN5@CheckDevil:

; 461  : 		return 0;
; 462  : 	}
; 463  : 
; 464  : 	if ( bLevelCheck != FALSE )

  00134	83 7d fc 00	 cmp	 DWORD PTR _bLevelCheck$[ebp], 0
  00138	74 18		 je	 SHORT $LN4@CheckDevil

; 465  : 	{
; 466  : 		LogAdd(LOG_BLACK, "[DevilSquare] DiffLevel DQItems Found");

  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@FFFDDFEO@?$FLDevilSquare?$FN?5DiffLevel?5DQItems?5@
  0013f	6a 00		 push	 0
  00141	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00146	83 c4 08	 add	 esp, 8

; 467  : 		return 3;

  00149	b8 03 00 00 00	 mov	 eax, 3

; 491  : }

  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
$LN4@CheckDevil:

; 468  : 	}
; 469  : 
; 470  : 	if ( bCharmOfLuckOver == TRUE )

  00152	83 7d ec 01	 cmp	 DWORD PTR _bCharmOfLuckOver$[ebp], 1
  00156	75 18		 jne	 SHORT $LN3@CheckDevil

; 471  : 	{
; 472  : 		LogAdd(LOG_BLACK, "[DevilSquare] Charm Of Luck Count Over");

  00158	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@EJJKJEAB@?$FLDevilSquare?$FN?5Charm?5Of?5Luck?5Coun@
  0015d	6a 00		 push	 0
  0015f	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00164	83 c4 08	 add	 esp, 8

; 473  : 		return 4;

  00167	b8 04 00 00 00	 mov	 eax, 4

; 491  : }

  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
$LN3@CheckDevil:

; 474  : 	}
; 475  : 
; 476  : 	if ( bChaoseGem != FALSE && bEyeOfDevil != FALSE && bKeyOfDevil != FALSE )

  00170	83 7d e8 00	 cmp	 DWORD PTR _bChaoseGem$[ebp], 0
  00174	74 1e		 je	 SHORT $LN30@CheckDevil
  00176	83 7d f8 00	 cmp	 DWORD PTR _bEyeOfDevil$[ebp], 0
  0017a	74 36		 je	 SHORT $LN1@CheckDevil
  0017c	83 7d f4 00	 cmp	 DWORD PTR _bKeyOfDevil$[ebp], 0
  00180	74 12		 je	 SHORT $LN30@CheckDevil

; 477  : 	{
; 478  : 		LogDQChaosItem(lpObj);

  00182	50		 push	 eax
  00183	e8 00 00 00 00	 call	 ?LogDQChaosItem@@YAXPAUOBJECTSTRUCT@@@Z ; LogDQChaosItem
  00188	83 c4 04	 add	 esp, 4

; 479  : 		return 1;

  0018b	b8 01 00 00 00	 mov	 eax, 1

; 491  : }

  00190	8b e5		 mov	 esp, ebp
  00192	5d		 pop	 ebp
  00193	c3		 ret	 0
$LN30@CheckDevil:

; 480  : 	}
; 481  : 
; 482  : 	if ( bEyeOfDevil != FALSE && bKeyOfDevil != FALSE )

  00194	83 7d f8 00	 cmp	 DWORD PTR _bEyeOfDevil$[ebp], 0
  00198	74 18		 je	 SHORT $LN1@CheckDevil
  0019a	83 7d f4 00	 cmp	 DWORD PTR _bKeyOfDevil$[ebp], 0
  0019e	74 12		 je	 SHORT $LN1@CheckDevil

; 483  : 	{
; 484  : 		LogDQChaosItem(lpObj);

  001a0	50		 push	 eax
  001a1	e8 00 00 00 00	 call	 ?LogDQChaosItem@@YAXPAUOBJECTSTRUCT@@@Z ; LogDQChaosItem
  001a6	83 c4 04	 add	 esp, 4

; 485  : 		return 2;

  001a9	b8 02 00 00 00	 mov	 eax, 2

; 491  : }

  001ae	8b e5		 mov	 esp, ebp
  001b0	5d		 pop	 ebp
  001b1	c3		 ret	 0
$LN1@CheckDevil:

; 486  : 	}
; 487  : 
; 488  : 	LogAdd(LOG_BLACK, "[DevilSquare] DQItems Not Found");

  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@IANBADIL@?$FLDevilSquare?$FN?5DQItems?5Not?5Found?$AA@
  001b7	6a 00		 push	 0
  001b9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001be	83 c4 08	 add	 esp, 8

; 489  : 
; 490  : 	return 0;

  001c1	33 c0		 xor	 eax, eax

; 491  : }

  001c3	8b e5		 mov	 esp, ebp
  001c5	5d		 pop	 ebp
  001c6	c3		 ret	 0
?CheckDevilSquareItem@@YAHPAUOBJECTSTRUCT@@AAH1@Z ENDP	; CheckDevilSquareItem
_TEXT	ENDS
PUBLIC	??_C@_0DB@BMAIOAHL@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Invalid?5D@ ; `string'
PUBLIC	??_C@_0DL@ODHCGDBD@?$FLDevilSquare?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@ ; `string'
PUBLIC	??_C@_0DG@KKBIIBFP@?$FLDevilSquare?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@ ; `string'
PUBLIC	??_C@_0EB@HHHNMGIM@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Not@ ; `string'
PUBLIC	??_C@_0BO@MDACFBLC@?$FLDevilSquare?$FN?5Chaos?5Mix?5Start?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DevilSquareEventChaosMix@@YAHPAUOBJECTSTRUCT@@HH@Z ; DevilSquareEventChaosMix
EXTRN	?gDQChaosSuccessRateLevel6@@3HA:DWORD		; gDQChaosSuccessRateLevel6
EXTRN	?gDQChaosSuccessRateLevel5@@3HA:DWORD		; gDQChaosSuccessRateLevel5
EXTRN	?gDQChaosSuccessRateLevel4@@3HA:DWORD		; gDQChaosSuccessRateLevel4
EXTRN	?gDQChaosSuccessRateLevel3@@3HA:DWORD		; gDQChaosSuccessRateLevel3
EXTRN	?gDQChaosSuccessRateLevel2@@3HA:DWORD		; gDQChaosSuccessRateLevel2
EXTRN	?gDQChaosSuccessRateLevel1@@3HA:DWORD		; gDQChaosSuccessRateLevel1
;	COMDAT ??_C@_0DB@BMAIOAHL@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Invalid?5D@
CONST	SEGMENT
??_C@_0DB@BMAIOAHL@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Invalid?5D@ DB '['
	DB	'DevilSquare] [%s][%s] Invalid DQItem Level [%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@ODHCGDBD@?$FLDevilSquare?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@
CONST	SEGMENT
??_C@_0DL@ODHCGDBD@?$FLDevilSquare?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@ DB '['
	DB	'DevilSquare,%d] [%s][%s] CBMix Success Rate:%d Money : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KKBIIBFP@?$FLDevilSquare?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@
CONST	SEGMENT
??_C@_0DG@KKBIIBFP@?$FLDevilSquare?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@ DB '['
	DB	'DevilSquare,%d] [%s][%s] CBMix Fail %d Money : %d-%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@HHHNMGIM@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Not@
CONST	SEGMENT
??_C@_0EB@HHHNMGIM@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Not@ DB '['
	DB	'DevilSquare] [%s][%s] CBMix Not Enough Money [%d] need zen [%'
	DB	'd]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MDACFBLC@?$FLDevilSquare?$FN?5Chaos?5Mix?5Start?$AA@
CONST	SEGMENT
??_C@_0BO@MDACFBLC@?$FLDevilSquare?$FN?5Chaos?5Mix?5Start?$AA@ DB '[Devil'
	DB	'Square] Chaos Mix Start', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DevilSquareEventChaosMix@@YAHPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_iCharmOfLuckCount$ = -28				; size = 4
_fail$ = -24						; size = 4
_aIndex$ = -20						; size = 4
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_bCheckType$ = 12					; size = 4
_iItemLevel$ = 16					; size = 4
?DevilSquareEventChaosMix@@YAHPAUOBJECTSTRUCT@@HH@Z PROC ; DevilSquareEventChaosMix, COMDAT

; 524  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 525  : 	BOOL fail = TRUE;
; 526  : 	int aIndex = lpObj->m_Index;

  00016	8b 3e		 mov	 edi, DWORD PTR [esi]

; 527  : 	PMSG_CHAOSMIXRESULT pMsg;
; 528  : 
; 529  : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00018	6a 0b		 push	 11			; 0000000bH
  0001a	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001d	68 86 00 00 00	 push	 134			; 00000086H
  00022	bb 01 00 00 00	 mov	 ebx, 1
  00027	50		 push	 eax
  00028	89 5d e8	 mov	 DWORD PTR _fail$[ebp], ebx
  0002b	89 7d ec	 mov	 DWORD PTR _aIndex$[ebp], edi
  0002e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 530  : 	pMsg.Result = CB_ERROR;
; 531  : 	lpObj->ChaosLock = TRUE;
; 532  : 
; 533  : 	LogAdd(LOG_BLACK, "[DevilSquare] Chaos Mix Start");

  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@MDACFBLC@?$FLDevilSquare?$FN?5Chaos?5Mix?5Start?$AA@
  00038	6a 00		 push	 0
  0003a	c6 45 f3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  0003e	89 9e ec 0c 00
	00		 mov	 DWORD PTR [esi+3308], ebx
  00044	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 534  : 	INT nChaosNeedMoney = 0;
; 535  : 	int iCharmOfLuckCount = 0;
; 536  : 	iCharmOfLuckCount = lpObj->ChaosSuccessRate;

  00049	8b 86 e8 0c 00
	00		 mov	 eax, DWORD PTR [esi+3304]
  0004f	83 c4 14	 add	 esp, 20			; 00000014H
  00052	89 45 e4	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], eax

; 537  : 
; 538  : 	if ( iCharmOfLuckCount > 10 )

  00055	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00058	7e 20		 jle	 SHORT $LN18@DevilSquar

; 539  : 	{
; 540  : 		pMsg.Result = 0xF0;
; 541  : 		lpObj->ChaosLock = FALSE;
; 542  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0005a	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0005e	51		 push	 ecx
  0005f	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00062	52		 push	 edx
  00063	57		 push	 edi
  00064	c6 45 f3 f0	 mov	 BYTE PTR _pMsg$[ebp+3], 240 ; 000000f0H
  00068	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  00072	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@DevilSquar:

; 543  : 	}
; 544  : 
; 545  : 	switch ( iItemLevel )

  0007a	8b 45 10	 mov	 eax, DWORD PTR _iItemLevel$[ebp]
  0007d	83 f8 06	 cmp	 eax, 6
  00080	0f 87 06 02 00
	00		 ja	 $LN8@DevilSquar
  00086	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN23@DevilSquar[eax*4]
$LN15@DevilSquar:

; 546  : 	{
; 547  : 		case 0:
; 548  : 			lpObj->ChaosSuccessRate = 60;

  0008d	c7 86 e8 0c 00
	00 3c 00 00 00	 mov	 DWORD PTR [esi+3304], 60 ; 0000003cH

; 549  : 			nChaosNeedMoney = 100000;

  00097	bf a0 86 01 00	 mov	 edi, 100000		; 000186a0H

; 550  : 			break;

  0009c	eb 68		 jmp	 SHORT $LN16@DevilSquar
$LN14@DevilSquar:

; 551  : 
; 552  : 		case 1:
; 553  : 			lpObj->ChaosSuccessRate = gDQChaosSuccessRateLevel1;

  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gDQChaosSuccessRateLevel1@@3HA ; gDQChaosSuccessRateLevel1
  000a3	89 86 e8 0c 00
	00		 mov	 DWORD PTR [esi+3304], eax

; 554  : 			nChaosNeedMoney = 100000;

  000a9	bf a0 86 01 00	 mov	 edi, 100000		; 000186a0H

; 555  : 			break;

  000ae	eb 56		 jmp	 SHORT $LN16@DevilSquar
$LN13@DevilSquar:

; 556  : 
; 557  : 		case 2:
; 558  : 			lpObj->ChaosSuccessRate = gDQChaosSuccessRateLevel2;

  000b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gDQChaosSuccessRateLevel2@@3HA ; gDQChaosSuccessRateLevel2
  000b6	89 8e e8 0c 00
	00		 mov	 DWORD PTR [esi+3304], ecx

; 559  : 			nChaosNeedMoney = 200000;

  000bc	bf 40 0d 03 00	 mov	 edi, 200000		; 00030d40H

; 560  : 			break;

  000c1	eb 43		 jmp	 SHORT $LN16@DevilSquar
$LN12@DevilSquar:

; 561  : 
; 562  : 		case 3:
; 563  : 			lpObj->ChaosSuccessRate = gDQChaosSuccessRateLevel3;

  000c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gDQChaosSuccessRateLevel3@@3HA ; gDQChaosSuccessRateLevel3

; 564  : 			nChaosNeedMoney = 400000;

  000c9	bf 80 1a 06 00	 mov	 edi, 400000		; 00061a80H

; 565  : 			break;

  000ce	eb 30		 jmp	 SHORT $LN21@DevilSquar
$LN11@DevilSquar:

; 566  : 
; 567  : 		case 4:
; 568  : 			lpObj->ChaosSuccessRate = gDQChaosSuccessRateLevel4;

  000d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gDQChaosSuccessRateLevel4@@3HA ; gDQChaosSuccessRateLevel4
  000d5	89 86 e8 0c 00
	00		 mov	 DWORD PTR [esi+3304], eax

; 569  : 			nChaosNeedMoney = 700000;

  000db	bf 60 ae 0a 00	 mov	 edi, 700000		; 000aae60H

; 570  : 			break;

  000e0	eb 24		 jmp	 SHORT $LN16@DevilSquar
$LN10@DevilSquar:

; 571  : 
; 572  : 		case 5:
; 573  : 			lpObj->ChaosSuccessRate = gDQChaosSuccessRateLevel5;

  000e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gDQChaosSuccessRateLevel5@@3HA ; gDQChaosSuccessRateLevel5
  000e8	89 8e e8 0c 00
	00		 mov	 DWORD PTR [esi+3304], ecx

; 574  : 			nChaosNeedMoney = 1100000;

  000ee	bf e0 c8 10 00	 mov	 edi, 1100000		; 0010c8e0H

; 575  : 			break;

  000f3	eb 11		 jmp	 SHORT $LN16@DevilSquar
$LN9@DevilSquar:

; 576  : 
; 577  : 		case 6:
; 578  : 			lpObj->ChaosSuccessRate = gDQChaosSuccessRateLevel6;

  000f5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gDQChaosSuccessRateLevel6@@3HA ; gDQChaosSuccessRateLevel6

; 579  : 			nChaosNeedMoney = 1600000;

  000fb	bf 00 6a 18 00	 mov	 edi, 1600000		; 00186a00H
$LN21@DevilSquar:

; 576  : 
; 577  : 		case 6:
; 578  : 			lpObj->ChaosSuccessRate = gDQChaosSuccessRateLevel6;

  00100	89 96 e8 0c 00
	00		 mov	 DWORD PTR [esi+3304], edx
$LN16@DevilSquar:

; 590  : 			break;
; 591  : 	}
; 592  : 
; 593  : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  00106	8b 06		 mov	 eax, DWORD PTR [esi]
  00108	50		 push	 eax
  00109	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0010e	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00113	f7 ef		 imul	 edi
  00115	6a 00		 push	 0
  00117	6a 64		 push	 100			; 00000064H
  00119	52		 push	 edx
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 __alldiv
  00120	8b d8		 mov	 ebx, eax

; 594  : 
; 595  : 	if ( iChaosTaxMoney < 0 )

  00122	85 db		 test	 ebx, ebx
  00124	79 02		 jns	 SHORT $LN7@DevilSquar

; 596  : 	{
; 597  : 		iChaosTaxMoney = 0;

  00126	33 db		 xor	 ebx, ebx
$LN7@DevilSquar:

; 598  : 	}
; 599  : 
; 600  : 	nChaosNeedMoney += iChaosTaxMoney;

  00128	03 fb		 add	 edi, ebx

; 601  : 
; 602  : 	if ( nChaosNeedMoney < 0 )

  0012a	79 02		 jns	 SHORT $LN6@DevilSquar

; 603  : 	{
; 604  : 		nChaosNeedMoney = 0;

  0012c	33 ff		 xor	 edi, edi
$LN6@DevilSquar:

; 605  : 	}
; 606  : 
; 607  : 	if ( (lpObj->Money - nChaosNeedMoney) < 0 )

  0012e	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  00134	8b c8		 mov	 ecx, eax
  00136	2b cf		 sub	 ecx, edi
  00138	79 39		 jns	 SHORT $LN5@DevilSquar

; 608  : 	{
; 609  : 		LogAdd(LOG_BLACK, "[DevilSquare] [%s][%s] CBMix Not Enough Money [%d] need zen [%d]",
; 610  : 			lpObj->AccountID, lpObj->Name, lpObj->Money, nChaosNeedMoney);

  0013a	57		 push	 edi
  0013b	50		 push	 eax
  0013c	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  0013f	52		 push	 edx
  00140	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  00143	50		 push	 eax
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@HHHNMGIM@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Not@
  00149	6a 00		 push	 0
  0014b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 611  : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;
; 612  : 		DataSend(aIndex, (BYTE *)&pMsg, pMsg.h.size);

  00150	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00154	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00157	51		 push	 ecx
  00158	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0015b	52		 push	 edx
  0015c	50		 push	 eax
  0015d	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
  00161	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00166	83 c4 24	 add	 esp, 36			; 00000024H

; 613  : 		lpObj->ChaosLock = FALSE;
; 614  : 		return 1;

  00169	b8 01 00 00 00	 mov	 eax, 1
  0016e	e9 46 01 00 00	 jmp	 $LN22@DevilSquar
$LN5@DevilSquar:

; 615  : 
; 616  : 	}
; 617  : 
; 618  : 	lpObj->ChaosSuccessRate += iCharmOfLuckCount;

  00173	8b 4d e4	 mov	 ecx, DWORD PTR _iCharmOfLuckCount$[ebp]
  00176	01 8e e8 0c 00
	00		 add	 DWORD PTR [esi+3304], ecx

; 619  : 
; 620  : 	int iRate = rand() % 100;

  0017c	e8 00 00 00 00	 call	 _rand
  00181	99		 cdq
  00182	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00187	f7 f9		 idiv	 ecx

; 621  : 
; 622  : 	if ( bCheckType == TRUE )

  00189	83 7d 0c 01	 cmp	 DWORD PTR _bCheckType$[ebp], 1
  0018d	75 3a		 jne	 SHORT $LN3@DevilSquar

; 623  : 	{
; 624  : 		if ( iRate < lpObj->ChaosSuccessRate )

  0018f	3b 96 e8 0c 00
	00		 cmp	 edx, DWORD PTR [esi+3304]
  00195	7d 32		 jge	 SHORT $LN3@DevilSquar

; 625  : 		{
; 626  : 			int DevilInv = ITEMGET(14,19);	// Devil Ticket
; 627  : 			ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, DevilInv, iItemLevel, 0, 0, 0, 0, -1, 0, 0);

  00197	8b 55 10	 mov	 edx, DWORD PTR _iItemLevel$[ebp]
  0019a	6a 00		 push	 0
  0019c	8b 06		 mov	 eax, DWORD PTR [esi]
  0019e	6a 00		 push	 0
  001a0	6a ff		 push	 -1
  001a2	6a 00		 push	 0
  001a4	6a 00		 push	 0
  001a6	6a 00		 push	 0
  001a8	6a 00		 push	 0
  001aa	52		 push	 edx
  001ab	68 13 1c 00 00	 push	 7187			; 00001c13H
  001b0	6a 00		 push	 0
  001b2	6a 00		 push	 0
  001b4	68 ff 00 00 00	 push	 255			; 000000ffH
  001b9	50		 push	 eax
  001ba	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  001bf	83 c4 34	 add	 esp, 52			; 00000034H

; 628  : 			fail = FALSE;

  001c2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _fail$[ebp], 0
$LN3@DevilSquar:

; 629  : 		}
; 630  : 	}
; 631  : 
; 632  : 	lpObj->Money -= nChaosNeedMoney;

  001c9	29 be b0 00 00
	00		 sub	 DWORD PTR [esi+176], edi

; 633  : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  001cf	53		 push	 ebx
  001d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  001d5	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 634  : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  001da	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  001e0	8b 16		 mov	 edx, DWORD PTR [esi]
  001e2	51		 push	 ecx
  001e3	52		 push	 edx
  001e4	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  001e9	83 c4 08	 add	 esp, 8

; 635  : 
; 636  : /*#if (FOREIGN_GAMESERVER==1)
; 637  : 	if ( szAuthKey[17] != AUTHKEY17 )
; 638  : 	{
; 639  : 		::DestroyGIocp();
; 640  : 	}
; 641  : #endif*/
; 642  : 
; 643  : 	if ( fail == TRUE )

  001ec	83 7d e8 01	 cmp	 DWORD PTR _fail$[ebp], 1
  001f0	75 56		 jne	 SHORT $LN2@DevilSquar

; 644  : 	{
; 645  : 		ChaosBoxInit(lpObj);

  001f2	56		 push	 esi
  001f3	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit

; 646  : 		GCUserChaosBoxSend(lpObj, 0);

  001f8	6a 00		 push	 0
  001fa	56		 push	 esi
  001fb	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 647  : 		DataSend(aIndex, (BYTE *)&pMsg, pMsg.h.size);

  00200	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00204	8b 55 ec	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00207	50		 push	 eax
  00208	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0020b	51		 push	 ecx
  0020c	52		 push	 edx
  0020d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 648  : 
; 649  : 		LogAdd(LOG_BLACK, "[DevilSquare,%d] [%s][%s] CBMix Fail %d Money : %d-%d", iItemLevel,
; 650  : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate,
; 651  : 			lpObj->Money, nChaosNeedMoney);

  00212	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  00218	8b 8e e8 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3304]
  0021e	57		 push	 edi
  0021f	50		 push	 eax
  00220	51		 push	 ecx
  00221	8b 4d 10	 mov	 ecx, DWORD PTR _iItemLevel$[ebp]
  00224	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  00227	52		 push	 edx
  00228	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  0022b	50		 push	 eax
  0022c	51		 push	 ecx
  0022d	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@KKBIIBFP@?$FLDevilSquare?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@
  00232	6a 00		 push	 0
  00234	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00239	83 c4 38	 add	 esp, 56			; 00000038H

; 652  : 		lpObj->ChaosLock = FALSE;

  0023c	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0

; 653  : 	}
; 654  : 	else

  00246	eb 23		 jmp	 SHORT $LN1@DevilSquar
$LN2@DevilSquar:

; 655  : 	{
; 656  : 		LogAdd(LOG_BLACK, "[DevilSquare,%d] [%s][%s] CBMix Success Rate:%d Money : %d", iItemLevel,
; 657  : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate,
; 658  : 			nChaosNeedMoney);

  00248	8b 96 e8 0c 00
	00		 mov	 edx, DWORD PTR [esi+3304]
  0024e	57		 push	 edi
  0024f	52		 push	 edx
  00250	8b 55 10	 mov	 edx, DWORD PTR _iItemLevel$[ebp]
  00253	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00256	50		 push	 eax
  00257	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  0025a	51		 push	 ecx
  0025b	52		 push	 edx
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@ODHCGDBD@?$FLDevilSquare?0?$CFd?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@
  00261	6a 00		 push	 0
  00263	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00268	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@DevilSquar:

; 659  : 	}
; 660  : 
; 661  : 	::gObjInventoryCommit(lpObj->m_Index);

  0026b	8b 06		 mov	 eax, DWORD PTR [esi]
  0026d	50		 push	 eax
  0026e	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  00273	83 c4 04	 add	 esp, 4
  00276	5f		 pop	 edi
  00277	5e		 pop	 esi

; 662  : 
; 663  : 	return TRUE;

  00278	b8 01 00 00 00	 mov	 eax, 1
  0027d	5b		 pop	 ebx

; 664  : }

  0027e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00281	33 cd		 xor	 ecx, ebp
  00283	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00288	8b e5		 mov	 esp, ebp
  0028a	5d		 pop	 ebp
  0028b	c3		 ret	 0
$LN8@DevilSquar:

; 580  : 			break;
; 581  : 
; 582  : 		default:
; 583  : 			LogAdd(LOG_BLACK, "[DevilSquare] [%s][%s] Invalid DQItem Level [%d]",
; 584  : 				lpObj->AccountID, lpObj->Name, iItemLevel);

  0028c	50		 push	 eax
  0028d	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  00290	51		 push	 ecx
  00291	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  00294	52		 push	 edx
  00295	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@BMAIOAHL@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Invalid?5D@
  0029a	6a 00		 push	 0
  0029c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 585  : 
; 586  : 			pMsg.Result = CB_INVALID_ITEM_LEVEL;
; 587  : 			DataSend(aIndex, (BYTE *)&pMsg, pMsg.h.size);

  002a1	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  002a5	50		 push	 eax
  002a6	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  002a9	51		 push	 ecx
  002aa	57		 push	 edi
  002ab	c6 45 f3 08	 mov	 BYTE PTR _pMsg$[ebp+3], 8
  002af	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002b4	83 c4 20	 add	 esp, 32			; 00000020H

; 588  : 			lpObj->ChaosLock = FALSE;
; 589  : 			return 1;

  002b7	8b c3		 mov	 eax, ebx
$LN22@DevilSquar:

; 664  : }

  002b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002bc	5f		 pop	 edi
  002bd	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  002c7	5e		 pop	 esi
  002c8	33 cd		 xor	 ecx, ebp
  002ca	5b		 pop	 ebx
  002cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d0	8b e5		 mov	 esp, ebp
  002d2	5d		 pop	 ebp
  002d3	c3		 ret	 0
$LN23@DevilSquar:
  002d4	00 00 00 00	 DD	 $LN15@DevilSquar
  002d8	00 00 00 00	 DD	 $LN14@DevilSquar
  002dc	00 00 00 00	 DD	 $LN13@DevilSquar
  002e0	00 00 00 00	 DD	 $LN12@DevilSquar
  002e4	00 00 00 00	 DD	 $LN11@DevilSquar
  002e8	00 00 00 00	 DD	 $LN10@DevilSquar
  002ec	00 00 00 00	 DD	 $LN9@DevilSquar
?DevilSquareEventChaosMix@@YAHPAUOBJECTSTRUCT@@HH@Z ENDP ; DevilSquareEventChaosMix
_TEXT	ENDS
PUBLIC	??_C@_0EK@JJBHLEGP@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@ ; `string'
PUBLIC	??_C@_0EN@NDGFLPHI@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5S@ ; `string'
PUBLIC	??_C@_0ED@HJNGDDFB@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5N@ ; `string'
PUBLIC	??_C@_0CA@BGIGBHFB@?$FLPlusItemLevel?$FN?5Chaos?5Mix?5Start?$AA@ ; `string'
PUBLIC	??_C@_0DL@KGOODEAG@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5C@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?PlusItemLevelChaosMix@@YAHPAUOBJECTSTRUCT@@H@Z	; PlusItemLevelChaosMix
EXTRN	?gObjChaosItemSet@@YAXHHE@Z:PROC		; gObjChaosItemSet
EXTRN	?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z:PROC ; gObjChaosBoxInsertItemPos
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
;	COMDAT ??_C@_0EK@JJBHLEGP@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@
CONST	SEGMENT
??_C@_0EK@JJBHLEGP@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@ DB '['
	DB	'PlusItemLevel] [%s][%s] CBMix Fail %d Money : %d-%d [%d], Cha'
	DB	'rmRate : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@NDGFLPHI@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5S@
CONST	SEGMENT
??_C@_0EN@NDGFLPHI@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5S@ DB '['
	DB	'PlusItemLevel] [%s][%s] CBMix Success %d Money : %d-%d [%d], '
	DB	'CharmRate : %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@HJNGDDFB@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5N@
CONST	SEGMENT
??_C@_0ED@HJNGDDFB@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5N@ DB '['
	DB	'PlusItemLevel] [%s][%s] CBMix Not Enough Money [%d] need zen '
	DB	'[%d]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BGIGBHFB@?$FLPlusItemLevel?$FN?5Chaos?5Mix?5Start?$AA@
CONST	SEGMENT
??_C@_0CA@BGIGBHFB@?$FLPlusItemLevel?$FN?5Chaos?5Mix?5Start?$AA@ DB '[Plu'
	DB	'sItemLevel] Chaos Mix Start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@KGOODEAG@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5C@
CONST	SEGMENT
??_C@_0DL@KGOODEAG@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5C@ DB '['
	DB	'PlusItemLevel] [%s][%s] CBMix Charm of luck over 10% (%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?PlusItemLevelChaosMix@@YAHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_OtherItemFound$ = -240					; size = 4
_ChaosGemCount$ = -236					; size = 4
_BlessGemCount$ = -232					; size = 4
_iCharmOfLuckCount$ = -228				; size = 4
_PlusItemPos$ = -224					; size = 4
_SoulGemCount$ = -220					; size = 4
_Plus10ItemCount$ = -216				; size = 4
_Plus12ItemCount$ = -212				; size = 4
_Plus11ItemCount$ = -208				; size = 4
tv922 = -204						; size = 4
_Dur$155905 = -204					; size = 4
_Plus9ItemCount$ = -204					; size = 4
_btItemLuckValue$ = -197				; size = 1
_Item$155904 = -196					; size = 168
_pResult$155865 = -28					; size = 11
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_mixType$ = 12						; size = 4
?PlusItemLevelChaosMix@@YAHPAUOBJECTSTRUCT@@H@Z PROC	; PlusItemLevelChaosMix, COMDAT

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00017	56		 push	 esi

; 728  : 	int ChaosGemCount = 0;

  00018	33 f6		 xor	 esi, esi
  0001a	57		 push	 edi
  0001b	89 b5 14 ff ff
	ff		 mov	 DWORD PTR _ChaosGemCount$[ebp], esi

; 729  : 	int BlessGemCount = 0;

  00021	89 b5 18 ff ff
	ff		 mov	 DWORD PTR _BlessGemCount$[ebp], esi

; 730  : 	int SoulGemCount = 0;

  00027	89 b5 24 ff ff
	ff		 mov	 DWORD PTR _SoulGemCount$[ebp], esi

; 731  : 	int Plus9ItemCount = 0;

  0002d	89 b5 34 ff ff
	ff		 mov	 DWORD PTR _Plus9ItemCount$[ebp], esi

; 732  : 	int Plus10ItemCount = 0;

  00033	89 b5 28 ff ff
	ff		 mov	 DWORD PTR _Plus10ItemCount$[ebp], esi

; 733  : 	int PlusItemPos = -1;

  00039	c7 85 20 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _PlusItemPos$[ebp], -1

; 734  : 	int OtherItemFound = 0;

  00043	89 b5 10 ff ff
	ff		 mov	 DWORD PTR _OtherItemFound$[ebp], esi

; 735  : 	int Plus11ItemCount = 0;

  00049	89 b5 30 ff ff
	ff		 mov	 DWORD PTR _Plus11ItemCount$[ebp], esi

; 736  : 	int Plus12ItemCount = 0;

  0004f	89 b5 2c ff ff
	ff		 mov	 DWORD PTR _Plus12ItemCount$[ebp], esi

; 737  : 	int ExtraBlessGemCount = 0;
; 738  : 	int ExtraSoulGemCount = 0;
; 739  : 	int iCharmOfLuckCount = 0;

  00055	89 b5 1c ff ff
	ff		 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], esi

; 743  : 	{
; 744  : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  0005b	33 ff		 xor	 edi, edi
  0005d	8d 49 00	 npad	 3
$LL49@PlusItemLe:
  00060	8b 8b dc 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3292]
  00066	03 cf		 add	 ecx, edi
  00068	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006d	83 f8 01	 cmp	 eax, 1
  00070	0f 85 c3 00 00
	00		 jne	 $LN48@PlusItemLe

; 745  : 		{
; 746  : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,15) )

  00076	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  0007c	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0007f	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00083	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  00088	66 3b c2	 cmp	 ax, dx
  0008b	75 0b		 jne	 SHORT $LN45@PlusItemLe

; 747  : 			{
; 748  : 				ChaosGemCount++;

  0008d	ff 85 14 ff ff
	ff		 inc	 DWORD PTR _ChaosGemCount$[ebp]
  00093	e9 a1 00 00 00	 jmp	 $LN48@PlusItemLe
$LN45@PlusItemLe:

; 749  : 			}
; 750  : 			else if (  lpObj->pChaosBox[n].m_Type == ITEMGET(14,13) )

  00098	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  0009d	66 3b c2	 cmp	 ax, dx
  000a0	75 0b		 jne	 SHORT $LN43@PlusItemLe

; 751  : 			{
; 752  : 				BlessGemCount++;

  000a2	ff 85 18 ff ff
	ff		 inc	 DWORD PTR _BlessGemCount$[ebp]
  000a8	e9 8c 00 00 00	 jmp	 $LN48@PlusItemLe
$LN43@PlusItemLe:

; 753  : 			}
; 754  : 			else if (  lpObj->pChaosBox[n].m_Type == ITEMGET(14,14) )

  000ad	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  000b2	66 3b c2	 cmp	 ax, dx
  000b5	75 08		 jne	 SHORT $LN41@PlusItemLe

; 755  : 			{
; 756  : 				SoulGemCount++;

  000b7	ff 85 24 ff ff
	ff		 inc	 DWORD PTR _SoulGemCount$[ebp]
  000bd	eb 7a		 jmp	 SHORT $LN48@PlusItemLe
$LN41@PlusItemLe:

; 757  : 			}
; 758  : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,53) )	// Charm Of Luck

  000bf	ba 35 1c 00 00	 mov	 edx, 7221		; 00001c35H
  000c4	66 3b c2	 cmp	 ax, dx
  000c7	75 16		 jne	 SHORT $LN39@PlusItemLe

; 759  : 			{
; 760  : 				iCharmOfLuckCount += lpObj->pChaosBox[n].m_Durability;

  000c9	db 85 1c ff ff
	ff		 fild	 DWORD PTR _iCharmOfLuckCount$[ebp]
  000cf	d8 41 24	 fadd	 DWORD PTR [ecx+36]
  000d2	e8 00 00 00 00	 call	 __ftol2_sse
  000d7	89 85 1c ff ff
	ff		 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], eax
  000dd	eb 5a		 jmp	 SHORT $LN48@PlusItemLe
$LN39@PlusItemLe:

; 761  : 			}
; 762  : 			else if ( lpObj->pChaosBox[n].m_Level == 9 )

  000df	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  000e3	66 83 f8 09	 cmp	 ax, 9
  000e7	75 0e		 jne	 SHORT $LN37@PlusItemLe

; 763  : 			{
; 764  : 				Plus9ItemCount++;

  000e9	ff 85 34 ff ff
	ff		 inc	 DWORD PTR _Plus9ItemCount$[ebp]

; 765  : 				PlusItemPos = n;

  000ef	89 b5 20 ff ff
	ff		 mov	 DWORD PTR _PlusItemPos$[ebp], esi
  000f5	eb 42		 jmp	 SHORT $LN48@PlusItemLe
$LN37@PlusItemLe:

; 766  : 			}
; 767  : 			else if ( lpObj->pChaosBox[n].m_Level == 10 )

  000f7	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  000fb	75 0e		 jne	 SHORT $LN35@PlusItemLe

; 768  : 			{
; 769  : 				Plus10ItemCount++;

  000fd	ff 85 28 ff ff
	ff		 inc	 DWORD PTR _Plus10ItemCount$[ebp]

; 770  : 				PlusItemPos = n;

  00103	89 b5 20 ff ff
	ff		 mov	 DWORD PTR _PlusItemPos$[ebp], esi
  00109	eb 2e		 jmp	 SHORT $LN48@PlusItemLe
$LN35@PlusItemLe:

; 771  : 			}
; 772  : 			else if ( lpObj->pChaosBox[n].m_Level == 11 )

  0010b	66 83 f8 0b	 cmp	 ax, 11			; 0000000bH
  0010f	75 0e		 jne	 SHORT $LN33@PlusItemLe

; 773  : 			{
; 774  : 				Plus11ItemCount++;

  00111	ff 85 30 ff ff
	ff		 inc	 DWORD PTR _Plus11ItemCount$[ebp]

; 775  : 				PlusItemPos = n;

  00117	89 b5 20 ff ff
	ff		 mov	 DWORD PTR _PlusItemPos$[ebp], esi
  0011d	eb 1a		 jmp	 SHORT $LN48@PlusItemLe
$LN33@PlusItemLe:

; 776  : 			}
; 777  : 			else if ( lpObj->pChaosBox[n].m_Level == 12 )

  0011f	66 83 f8 0c	 cmp	 ax, 12			; 0000000cH
  00123	75 0e		 jne	 SHORT $LN31@PlusItemLe

; 778  : 			{
; 779  : 				Plus12ItemCount++;

  00125	ff 85 2c ff ff
	ff		 inc	 DWORD PTR _Plus12ItemCount$[ebp]

; 780  : 				PlusItemPos = n;

  0012b	89 b5 20 ff ff
	ff		 mov	 DWORD PTR _PlusItemPos$[ebp], esi

; 781  : 			}
; 782  : 			else

  00131	eb 06		 jmp	 SHORT $LN48@PlusItemLe
$LN31@PlusItemLe:

; 783  : 			{
; 784  : 				OtherItemFound ++;

  00133	ff 85 10 ff ff
	ff		 inc	 DWORD PTR _OtherItemFound$[ebp]
$LN48@PlusItemLe:

; 740  : 	BYTE btItemLuckValue = 0;
; 741  : 
; 742  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00139	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  0013f	46		 inc	 esi
  00140	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  00146	0f 8c 14 ff ff
	ff		 jl	 $LL49@PlusItemLe

; 785  : 			}
; 786  : 		}
; 787  : 	}
; 788  : 
; 789  : 	if ( iCharmOfLuckCount > 10 )

  0014c	8b bd 1c ff ff
	ff		 mov	 edi, DWORD PTR _iCharmOfLuckCount$[ebp]
  00152	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  00155	7e 44		 jle	 SHORT $LN29@PlusItemLe

; 790  : 	{
; 791  : 		PMSG_CHAOSMIXRESULT pResult;
; 792  : 
; 793  : 		PHeadSetB((LPBYTE)&pResult, 0x86, sizeof(pResult));

  00157	6a 0b		 push	 11			; 0000000bH
  00159	8d 45 e4	 lea	 eax, DWORD PTR _pResult$155865[ebp]
  0015c	68 86 00 00 00	 push	 134			; 00000086H
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 794  : 
; 795  : 		LogAdd(LOG_BLACK, "[PlusItemLevel] [%s][%s] CBMix Charm of luck over 10% (%d)",
; 796  : 			lpObj->AccountID, lpObj->Name, iCharmOfLuckCount);

  00167	57		 push	 edi
  00168	8d 4b 6f	 lea	 ecx, DWORD PTR [ebx+111]
  0016b	51		 push	 ecx
  0016c	8d 53 64	 lea	 edx, DWORD PTR [ebx+100]
  0016f	52		 push	 edx
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@KGOODEAG@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5C@
  00175	6a 00		 push	 0
  00177	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 797  : 
; 798  : 		pResult.Result = 0xF0;
; 799  : 
; 800  : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  0017c	0f b6 45 e5	 movzx	 eax, BYTE PTR _pResult$155865[ebp+1]
  00180	8b 13		 mov	 edx, DWORD PTR [ebx]
  00182	50		 push	 eax
  00183	8d 4d e4	 lea	 ecx, DWORD PTR _pResult$155865[ebp]
  00186	51		 push	 ecx
  00187	52		 push	 edx
  00188	c6 45 e7 f0	 mov	 BYTE PTR _pResult$155865[ebp+3], 240 ; 000000f0H
  0018c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00191	83 c4 2c	 add	 esp, 44			; 0000002cH

; 801  : 
; 802  : 		lpObj->ChaosLock = FALSE;
; 803  : 
; 804  : 		return 0;

  00194	33 c0		 xor	 eax, eax
  00196	e9 ea 04 00 00	 jmp	 $LN63@PlusItemLe
$LN29@PlusItemLe:

; 805  : 	}
; 806  : 
; 807  : 
; 808  : 
; 809  : 	if ( OtherItemFound != FALSE )

  0019b	33 f6		 xor	 esi, esi
  0019d	39 b5 10 ff ff
	ff		 cmp	 DWORD PTR _OtherItemFound$[ebp], esi
  001a3	74 13		 je	 SHORT $LN28@PlusItemLe
$LN54@PlusItemLe:

; 810  : 	{
; 811  : 		return FALSE;

  001a5	33 c0		 xor	 eax, eax

; 987  : }

  001a7	5f		 pop	 edi
  001a8	5e		 pop	 esi
  001a9	5b		 pop	 ebx
  001aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ad	33 cd		 xor	 ecx, ebp
  001af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b4	8b e5		 mov	 esp, ebp
  001b6	5d		 pop	 ebp
  001b7	c3		 ret	 0
$LN28@PlusItemLe:

; 812  : 	}
; 813  : 
; 814  : 	lpObj->ChaosMoney = 0;
; 815  : 	int MixType = 0;
; 816  : 
; 817  : 	if ( Plus9ItemCount == 1 && ChaosGemCount == 1 && BlessGemCount == 1 && SoulGemCount == 1 && Plus10ItemCount == 0 && Plus11ItemCount == 0 && Plus12ItemCount == 0 )

  001b8	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _Plus9ItemCount$[ebp]
  001be	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _ChaosGemCount$[ebp]
  001c4	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _BlessGemCount$[ebp]
  001ca	89 b3 e4 0c 00
	00		 mov	 DWORD PTR [ebx+3300], esi
  001d0	83 fa 01	 cmp	 edx, 1
  001d3	75 3e		 jne	 SHORT $LN57@PlusItemLe
  001d5	3b ca		 cmp	 ecx, edx
  001d7	75 3a		 jne	 SHORT $LN57@PlusItemLe
  001d9	3b c2		 cmp	 eax, edx
  001db	75 36		 jne	 SHORT $LN57@PlusItemLe
  001dd	39 95 24 ff ff
	ff		 cmp	 DWORD PTR _SoulGemCount$[ebp], edx
  001e3	75 2e		 jne	 SHORT $LN57@PlusItemLe
  001e5	39 b5 28 ff ff
	ff		 cmp	 DWORD PTR _Plus10ItemCount$[ebp], esi
  001eb	75 26		 jne	 SHORT $LN57@PlusItemLe
  001ed	39 b5 30 ff ff
	ff		 cmp	 DWORD PTR _Plus11ItemCount$[ebp], esi
  001f3	75 5c		 jne	 SHORT $LN59@PlusItemLe
  001f5	39 b5 2c ff ff
	ff		 cmp	 DWORD PTR _Plus12ItemCount$[ebp], esi
  001fb	0f 85 8e 00 00
	00		 jne	 $LN60@PlusItemLe

; 818  : 	{
; 819  : 		MixType = 3;

  00201	8d 72 02	 lea	 esi, DWORD PTR [edx+2]

; 820  : 		lpObj->ChaosMoney = 2000000;

  00204	c7 83 e4 0c 00
	00 80 84 1e 00	 mov	 DWORD PTR [ebx+3300], 2000000 ; 001e8480H

; 821  : 		ExtraBlessGemCount = BlessGemCount - 1;
; 822  : 		ExtraSoulGemCount = SoulGemCount - 1;

  0020e	e9 ba 00 00 00	 jmp	 $LN62@PlusItemLe
$LN57@PlusItemLe:

; 823  : 	}
; 824  : 	else if ( Plus10ItemCount == 1 && ChaosGemCount == 1 && BlessGemCount == 2 && SoulGemCount == 2 && Plus9ItemCount == 0 && Plus11ItemCount == 0 && Plus12ItemCount == 0 )

  00213	83 bd 28 ff ff
	ff 01		 cmp	 DWORD PTR _Plus10ItemCount$[ebp], 1
  0021a	75 35		 jne	 SHORT $LN59@PlusItemLe
  0021c	83 f9 01	 cmp	 ecx, 1
  0021f	75 30		 jne	 SHORT $LN59@PlusItemLe
  00221	83 f8 02	 cmp	 eax, 2
  00224	75 2b		 jne	 SHORT $LN59@PlusItemLe
  00226	39 85 24 ff ff
	ff		 cmp	 DWORD PTR _SoulGemCount$[ebp], eax
  0022c	75 23		 jne	 SHORT $LN59@PlusItemLe
  0022e	85 d2		 test	 edx, edx
  00230	75 1f		 jne	 SHORT $LN59@PlusItemLe
  00232	39 b5 30 ff ff
	ff		 cmp	 DWORD PTR _Plus11ItemCount$[ebp], esi
  00238	75 17		 jne	 SHORT $LN59@PlusItemLe
  0023a	39 b5 2c ff ff
	ff		 cmp	 DWORD PTR _Plus12ItemCount$[ebp], esi
  00240	75 4d		 jne	 SHORT $LN60@PlusItemLe

; 825  : 	{
; 826  : 		MixType = 4;

  00242	8d 71 03	 lea	 esi, DWORD PTR [ecx+3]

; 827  : 		lpObj->ChaosMoney = 4000000;

  00245	c7 83 e4 0c 00
	00 00 09 3d 00	 mov	 DWORD PTR [ebx+3300], 4000000 ; 003d0900H

; 828  : 		ExtraBlessGemCount = BlessGemCount - 2;
; 829  : 		ExtraSoulGemCount = SoulGemCount - 2;

  0024f	eb 7c		 jmp	 SHORT $LN62@PlusItemLe
$LN59@PlusItemLe:

; 830  : 	}
; 831  : 	else if ( Plus11ItemCount == 1 && ChaosGemCount == 1 && BlessGemCount == 3 && SoulGemCount == 3 && Plus9ItemCount == 0 && Plus10ItemCount == 0 && Plus12ItemCount == 0 )

  00251	83 bd 30 ff ff
	ff 01		 cmp	 DWORD PTR _Plus11ItemCount$[ebp], 1
  00258	75 35		 jne	 SHORT $LN60@PlusItemLe
  0025a	83 f9 01	 cmp	 ecx, 1
  0025d	75 30		 jne	 SHORT $LN60@PlusItemLe
  0025f	83 f8 03	 cmp	 eax, 3
  00262	75 2b		 jne	 SHORT $LN60@PlusItemLe
  00264	39 85 24 ff ff
	ff		 cmp	 DWORD PTR _SoulGemCount$[ebp], eax
  0026a	75 23		 jne	 SHORT $LN60@PlusItemLe
  0026c	85 d2		 test	 edx, edx
  0026e	75 1f		 jne	 SHORT $LN60@PlusItemLe
  00270	39 b5 28 ff ff
	ff		 cmp	 DWORD PTR _Plus10ItemCount$[ebp], esi
  00276	75 17		 jne	 SHORT $LN60@PlusItemLe
  00278	39 b5 2c ff ff
	ff		 cmp	 DWORD PTR _Plus12ItemCount$[ebp], esi
  0027e	75 0f		 jne	 SHORT $LN60@PlusItemLe

; 832  : 	{
; 833  : 		MixType = 22;

  00280	8d 71 15	 lea	 esi, DWORD PTR [ecx+21]

; 834  : 		lpObj->ChaosMoney = 6000000;

  00283	c7 83 e4 0c 00
	00 80 8d 5b 00	 mov	 DWORD PTR [ebx+3300], 6000000 ; 005b8d80H

; 835  : 		ExtraBlessGemCount = BlessGemCount - 3;
; 836  : 		ExtraSoulGemCount = SoulGemCount - 3;

  0028d	eb 3e		 jmp	 SHORT $LN62@PlusItemLe
$LN60@PlusItemLe:

; 837  : 	}
; 838  : 	else if ( Plus12ItemCount == 1 && ChaosGemCount == 1 && BlessGemCount == 4 && SoulGemCount == 4 && Plus9ItemCount == 0 && Plus10ItemCount == 0 && Plus11ItemCount == 0 )

  0028f	83 bd 2c ff ff
	ff 01		 cmp	 DWORD PTR _Plus12ItemCount$[ebp], 1
  00296	75 35		 jne	 SHORT $LN62@PlusItemLe
  00298	83 f9 01	 cmp	 ecx, 1
  0029b	75 30		 jne	 SHORT $LN62@PlusItemLe
  0029d	83 f8 04	 cmp	 eax, 4
  002a0	75 2b		 jne	 SHORT $LN62@PlusItemLe
  002a2	39 85 24 ff ff
	ff		 cmp	 DWORD PTR _SoulGemCount$[ebp], eax
  002a8	75 23		 jne	 SHORT $LN62@PlusItemLe
  002aa	85 d2		 test	 edx, edx
  002ac	75 1f		 jne	 SHORT $LN62@PlusItemLe
  002ae	39 b5 28 ff ff
	ff		 cmp	 DWORD PTR _Plus10ItemCount$[ebp], esi
  002b4	75 17		 jne	 SHORT $LN62@PlusItemLe
  002b6	39 b5 30 ff ff
	ff		 cmp	 DWORD PTR _Plus11ItemCount$[ebp], esi
  002bc	75 0f		 jne	 SHORT $LN62@PlusItemLe

; 839  : 	{
; 840  : 		MixType = 23;

  002be	be 17 00 00 00	 mov	 esi, 23			; 00000017H

; 841  : 		lpObj->ChaosMoney = 8000000;

  002c3	c7 83 e4 0c 00
	00 00 12 7a 00	 mov	 DWORD PTR [ebx+3300], 8000000 ; 007a1200H
$LN62@PlusItemLe:

; 842  : 		ExtraBlessGemCount = BlessGemCount - 4;
; 843  : 		ExtraSoulGemCount = SoulGemCount - 4;
; 844  : 	}
; 845  : 
; 846  : 	if ( MixType != mixType )

  002cd	3b 75 0c	 cmp	 esi, DWORD PTR _mixType$[ebp]

; 847  : 	{
; 848  : 		MixType = 0;
; 849  : 	}
; 850  : 
; 851  : 	if ( MixType == 0 )

  002d0	0f 85 cf fe ff
	ff		 jne	 $LN54@PlusItemLe
  002d6	85 f6		 test	 esi, esi

; 852  : 	{
; 853  : 		return FALSE;

  002d8	0f 84 c7 fe ff
	ff		 je	 $LN54@PlusItemLe

; 854  : 	}
; 855  : 
; 856  : 	PMSG_CHAOSMIXRESULT pMsg;
; 857  : 
; 858  : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  002de	6a 0b		 push	 11			; 0000000bH
  002e0	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  002e3	68 86 00 00 00	 push	 134			; 00000086H
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 859  : 	pMsg.Result = CB_ERROR;
; 860  : 	lpObj->ChaosLock = TRUE;
; 861  : 	::LogPlusItemLevelChaosItem(lpObj, MixType);

  002ee	56		 push	 esi
  002ef	53		 push	 ebx
  002f0	c6 45 f3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  002f4	c7 83 ec 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [ebx+3308], 1
  002fe	e8 00 00 00 00	 call	 ?LogPlusItemLevelChaosItem@@YAXPAUOBJECTSTRUCT@@H@Z ; LogPlusItemLevelChaosItem

; 862  : 	LogAdd(LOG_BLACK, "[PlusItemLevel] Chaos Mix Start");

  00303	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@BGIGBHFB@?$FLPlusItemLevel?$FN?5Chaos?5Mix?5Start?$AA@
  00308	33 f6		 xor	 esi, esi
  0030a	56		 push	 esi
  0030b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 863  : 
; 864  : 	int iChaosTaxMoney = (int)((__int64)lpObj->ChaosMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  00310	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00312	83 c4 1c	 add	 esp, 28			; 0000001cH
  00315	51		 push	 ecx
  00316	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0031b	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00320	f7 ab e4 0c 00
	00		 imul	 DWORD PTR [ebx+3300]
  00326	56		 push	 esi
  00327	6a 64		 push	 100			; 00000064H
  00329	52		 push	 edx
  0032a	50		 push	 eax
  0032b	e8 00 00 00 00	 call	 __alldiv

; 865  : 
; 866  : 	if ( iChaosTaxMoney < 0 )

  00330	3b c6		 cmp	 eax, esi
  00332	7d 02		 jge	 SHORT $LN18@PlusItemLe

; 867  : 	{
; 868  : 		iChaosTaxMoney = 0;

  00334	33 c0		 xor	 eax, eax
$LN18@PlusItemLe:

; 869  : 	}
; 870  : 
; 871  : 	lpObj->ChaosMoney += iChaosTaxMoney;

  00336	01 83 e4 0c 00
	00		 add	 DWORD PTR [ebx+3300], eax

; 872  : 
; 873  : 	if ( lpObj->ChaosMoney < 0 )

  0033c	79 06		 jns	 SHORT $LN17@PlusItemLe

; 874  : 	{
; 875  : 		lpObj->ChaosMoney = 0;

  0033e	89 b3 e4 0c 00
	00		 mov	 DWORD PTR [ebx+3300], esi
$LN17@PlusItemLe:

; 876  : 	}
; 877  : 
; 878  : 	if ( lpObj->Money < lpObj->ChaosMoney )

  00344	8b 8b b0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+176]
  0034a	8b 93 e4 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3300]
  00350	3b ca		 cmp	 ecx, edx
  00352	7d 49		 jge	 SHORT $LN16@PlusItemLe

; 879  : 	{
; 880  : 		LogAdd(LOG_BLACK, "[PlusItemLevel] [%s][%s] CBMix Not Enough Money [%d] need zen [%d]",
; 881  : 			lpObj->AccountID, lpObj->Name, lpObj->Money, lpObj->ChaosMoney);

  00354	52		 push	 edx
  00355	51		 push	 ecx
  00356	8d 53 6f	 lea	 edx, DWORD PTR [ebx+111]
  00359	52		 push	 edx
  0035a	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  0035d	50		 push	 eax
  0035e	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@HJNGDDFB@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5N@
  00363	56		 push	 esi
  00364	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 882  : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;
; 883  : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  00369	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0036d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0036f	51		 push	 ecx
  00370	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00373	52		 push	 edx
  00374	50		 push	 eax
  00375	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
  00379	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0037e	83 c4 24	 add	 esp, 36			; 00000024H

; 884  : 		lpObj->ChaosLock = FALSE;

  00381	89 b3 ec 0c 00
	00		 mov	 DWORD PTR [ebx+3308], esi

; 885  : 		
; 886  : 		return TRUE;

  00387	b8 01 00 00 00	 mov	 eax, 1

; 987  : }

  0038c	5f		 pop	 edi
  0038d	5e		 pop	 esi
  0038e	5b		 pop	 ebx
  0038f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00392	33 cd		 xor	 ecx, ebp
  00394	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00399	8b e5		 mov	 esp, ebp
  0039b	5d		 pop	 ebp
  0039c	c3		 ret	 0
$LN16@PlusItemLe:

; 887  : 	}
; 888  : 
; 889  : 
; 890  : 	lpObj->Money -= lpObj->ChaosMoney;

  0039d	2b ca		 sub	 ecx, edx
  0039f	89 8b b0 00 00
	00		 mov	 DWORD PTR [ebx+176], ecx

; 891  : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  003a5	50		 push	 eax
  003a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  003ab	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 892  : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  003b0	8b 8b b0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+176]
  003b6	8b 13		 mov	 edx, DWORD PTR [ebx]
  003b8	51		 push	 ecx
  003b9	52		 push	 edx
  003ba	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 893  : 
; 894  : 	if ( lpObj->pChaosBox[PlusItemPos].m_Level == 9 )

  003bf	8b b5 20 ff ff
	ff		 mov	 esi, DWORD PTR _PlusItemPos$[ebp]
  003c5	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  003cb	69 f6 a8 00 00
	00		 imul	 esi, 168		; 000000a8H
  003d1	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  003d4	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  003d8	83 c4 08	 add	 esp, 8
  003db	66 83 f8 09	 cmp	 ax, 9
  003df	75 0c		 jne	 SHORT $LN15@PlusItemLe

; 895  : 	{
; 896  : 		lpObj->ChaosSuccessRate = 50;

  003e1	c7 83 e8 0c 00
	00 32 00 00 00	 mov	 DWORD PTR [ebx+3304], 50 ; 00000032H
  003eb	eb 1c		 jmp	 SHORT $LN9@PlusItemLe
$LN15@PlusItemLe:

; 897  : 	}
; 898  : 	else if ( lpObj->pChaosBox[PlusItemPos].m_Level == 10 )

  003ed	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH

; 899  : 	{
; 900  : 		lpObj->ChaosSuccessRate = 45;

  003f1	74 0c		 je	 SHORT $LN64@PlusItemLe

; 901  : 	}
; 902  : 	else if ( lpObj->pChaosBox[PlusItemPos].m_Level == 11 )

  003f3	66 83 f8 0b	 cmp	 ax, 11			; 0000000bH

; 903  : 	{
; 904  : 		lpObj->ChaosSuccessRate =45;

  003f7	74 06		 je	 SHORT $LN64@PlusItemLe

; 905  : 	}
; 906  : 	else if ( lpObj->pChaosBox[PlusItemPos].m_Level == 12 )

  003f9	66 83 f8 0c	 cmp	 ax, 12			; 0000000cH
  003fd	75 0a		 jne	 SHORT $LN9@PlusItemLe
$LN64@PlusItemLe:

; 907  : 	{
; 908  : 		lpObj->ChaosSuccessRate = 45;

  003ff	c7 83 e8 0c 00
	00 2d 00 00 00	 mov	 DWORD PTR [ebx+3304], 45 ; 0000002dH
$LN9@PlusItemLe:

; 909  : 	}
; 910  : 
; 911  : 	if ( lpObj->pChaosBox[PlusItemPos].m_Option2 != FALSE )	// if Have Luck

  00409	80 79 79 00	 cmp	 BYTE PTR [ecx+121], 0
  0040d	74 07		 je	 SHORT $LN8@PlusItemLe

; 912  : 	{
; 913  : 		lpObj->ChaosSuccessRate += 20;

  0040f	83 83 e8 0c 00
	00 14		 add	 DWORD PTR [ebx+3304], 20 ; 00000014H
$LN8@PlusItemLe:

; 914  : 	}
; 915  : 
; 916  : 	if ( lpObj->ChaosSuccessRate > 75 )

  00416	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  0041b	39 83 e8 0c 00
	00		 cmp	 DWORD PTR [ebx+3304], eax
  00421	7e 06		 jle	 SHORT $LN7@PlusItemLe

; 917  : 	{
; 918  : 		lpObj->ChaosSuccessRate = 75;

  00423	89 83 e8 0c 00
	00		 mov	 DWORD PTR [ebx+3304], eax
$LN7@PlusItemLe:

; 919  : 	}
; 920  : 
; 921  : 	lpObj->ChaosSuccessRate += iCharmOfLuckCount;

  00429	01 bb e8 0c 00
	00		 add	 DWORD PTR [ebx+3304], edi

; 922  : 	btItemLuckValue = lpObj->pChaosBox[PlusItemPos].m_Option2;

  0042f	8a 49 79	 mov	 cl, BYTE PTR [ecx+121]
  00432	88 8d 3b ff ff
	ff		 mov	 BYTE PTR _btItemLuckValue$[ebp], cl

; 923  : 
; 924  : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  00438	e8 00 00 00 00	 call	 _rand
  0043d	99		 cdq
  0043e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00443	f7 f9		 idiv	 ecx
  00445	3b 93 e8 0c 00
	00		 cmp	 edx, DWORD PTR [ebx+3304]

; 925  : 	{
; 926  : 		lpObj->pChaosBox[PlusItemPos].m_Level++;

  0044b	8b 93 dc 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3292]
  00451	0f 8d a8 01 00
	00		 jge	 $LN6@PlusItemLe
  00457	66 ff 44 16 08	 inc	 WORD PTR [esi+edx+8]
  0045c	8d 44 16 08	 lea	 eax, DWORD PTR [esi+edx+8]

; 927  : 		pMsg.Result = CB_SUCCESS;
; 928  : 
; 929  : 		CItem Item;

  00460	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _Item$155904[ebp]
  00466	c6 45 f3 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1
  0046a	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 930  : 
; 931  : 		float Dur = ItemGetDurability(lpObj->pChaosBox[PlusItemPos].m_Type, lpObj->pChaosBox[PlusItemPos].m_Level,
; 932  : 			lpObj->pChaosBox[PlusItemPos].IsExtItem(), lpObj->pChaosBox[PlusItemPos].IsSetItem());

  0046f	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  00475	8b c8		 mov	 ecx, eax
  00477	03 ce		 add	 ecx, esi
  00479	8d 3c 06	 lea	 edi, DWORD PTR [esi+eax]
  0047c	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00481	8b 8b dc 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3292]
  00487	50		 push	 eax
  00488	03 ce		 add	 ecx, esi
  0048a	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  0048f	0f bf 4f 08	 movsx	 ecx, WORD PTR [edi+8]
  00493	0f bf 57 06	 movsx	 edx, WORD PTR [edi+6]
  00497	50		 push	 eax
  00498	51		 push	 ecx
  00499	52		 push	 edx
  0049a	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  0049f	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv922[ebp], eax

; 933  : 
; 934  : 		Item.m_Level = lpObj->pChaosBox[PlusItemPos].m_Level;

  004a5	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  004ab	66 8b 4c 30 08	 mov	 cx, WORD PTR [eax+esi+8]
  004b0	db 85 34 ff ff
	ff		 fild	 DWORD PTR tv922[ebp]
  004b6	03 c6		 add	 eax, esi
  004b8	66 89 8d 44 ff
	ff ff		 mov	 WORD PTR _Item$155904[ebp+8], cx
  004bf	d9 9d 34 ff ff
	ff		 fstp	 DWORD PTR _Dur$155905[ebp]
  004c5	83 c4 10	 add	 esp, 16			; 00000010H

; 935  : 		Item.m_Durability = Dur * lpObj->pChaosBox[PlusItemPos].m_Durability / lpObj->pChaosBox[PlusItemPos].m_BaseDurability;

  004c8	d9 40 24	 fld	 DWORD PTR [eax+36]

; 936  : 
; 937  : 		Item.Convert(lpObj->pChaosBox[PlusItemPos].m_Type, lpObj->pChaosBox[PlusItemPos].m_Option1, lpObj->pChaosBox[PlusItemPos].m_Option2,
; 938  : 			lpObj->pChaosBox[PlusItemPos].m_Option3, lpObj->pChaosBox[PlusItemPos].m_NewOption, 
; 939  : 			lpObj->pChaosBox[PlusItemPos].m_SetOption, 0, CURRENT_DB_VERSION);

  004cb	6a 03		 push	 3
  004cd	d8 8d 34 ff ff
	ff		 fmul	 DWORD PTR _Dur$155905[ebp]
  004d3	6a 00		 push	 0
  004d5	d8 70 2c	 fdiv	 DWORD PTR [eax+44]
  004d8	d9 9d 60 ff ff
	ff		 fstp	 DWORD PTR _Item$155904[ebp+36]
  004de	0f b6 90 92 00
	00 00		 movzx	 edx, BYTE PTR [eax+146]
  004e5	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  004e9	52		 push	 edx
  004ea	0f b6 50 7a	 movzx	 edx, BYTE PTR [eax+122]
  004ee	51		 push	 ecx
  004ef	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  004f3	52		 push	 edx
  004f4	0f b6 50 78	 movzx	 edx, BYTE PTR [eax+120]
  004f8	0f bf 40 06	 movsx	 eax, WORD PTR [eax+6]
  004fc	51		 push	 ecx
  004fd	52		 push	 edx
  004fe	50		 push	 eax
  004ff	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _Item$155904[ebp]
  00505	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEE@Z ; CItem::Convert

; 940  : 
; 941  : 		Item.m_Number = lpObj->pChaosBox[PlusItemPos].m_Number;

  0050a	8b 8b dc 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3292]
  00510	8b 14 0e	 mov	 edx, DWORD PTR [esi+ecx]

; 942  : 
; 943  : 		ItemByteConvert(pMsg.ItemInfo, Item);

  00513	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00519	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0051c	8b fc		 mov	 edi, esp
  0051e	89 95 3c ff ff
	ff		 mov	 DWORD PTR _Item$155904[ebp], edx
  00524	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00529	8d b5 3c ff ff
	ff		 lea	 esi, DWORD PTR _Item$155904[ebp]
  0052f	50		 push	 eax
  00530	f3 a5		 rep movsd
  00532	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 944  : 		ChaosBoxInit(lpObj);

  00537	53		 push	 ebx
  00538	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit
  0053d	81 c4 b0 00 00
	00		 add	 esp, 176		; 000000b0H

; 945  : 		::gObjChaosBoxInsertItemPos(lpObj->m_Index, Item, 0, -1);

  00543	6a ff		 push	 -1
  00545	6a 00		 push	 0
  00547	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0054d	8b fc		 mov	 edi, esp
  0054f	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00554	8d b5 3c ff ff
	ff		 lea	 esi, DWORD PTR _Item$155904[ebp]
  0055a	f3 a5		 rep movsd
  0055c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0055e	51		 push	 ecx
  0055f	e8 00 00 00 00	 call	 ?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z ; gObjChaosBoxInsertItemPos

; 946  : 		gObjChaosItemSet(lpObj->m_Index, 0, 1);

  00564	8b 13		 mov	 edx, DWORD PTR [ebx]
  00566	6a 01		 push	 1
  00568	6a 00		 push	 0
  0056a	52		 push	 edx
  0056b	e8 00 00 00 00	 call	 ?gObjChaosItemSet@@YAXHHE@Z ; gObjChaosItemSet

; 947  : 
; 948  : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  00570	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00574	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0057a	50		 push	 eax
  0057b	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0057e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00580	51		 push	 ecx
  00581	52		 push	 edx
  00582	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00587	83 c4 0c	 add	 esp, 12			; 0000000cH

; 949  : 
; 950  : 		if ( btItemLuckValue )

  0058a	80 bd 3b ff ff
	ff 00		 cmp	 BYTE PTR _btItemLuckValue$[ebp], 0
  00591	74 39		 je	 SHORT $LN5@PlusItemLe

; 951  : 		{
; 952  : 			LogAdd(LOG_BLACK, "[PlusItemLevel] [%s][%s] CBMix Success %d Money : %d-%d [%d], CharmRate : %d",
; 953  : 				lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate+5, lpObj->Money,
; 954  : 				lpObj->ChaosMoney, Item.m_Level, iCharmOfLuckCount);

  00593	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _iCharmOfLuckCount$[ebp]
  00599	0f bf 8d 44 ff
	ff ff		 movsx	 ecx, WORD PTR _Item$155904[ebp+8]
  005a0	8b 93 e4 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3300]
  005a6	50		 push	 eax
  005a7	8b 83 b0 00 00
	00		 mov	 eax, DWORD PTR [ebx+176]
  005ad	51		 push	 ecx
  005ae	8b 8b e8 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3304]
  005b4	52		 push	 edx
  005b5	50		 push	 eax
  005b6	83 c1 05	 add	 ecx, 5
  005b9	51		 push	 ecx
  005ba	8d 53 6f	 lea	 edx, DWORD PTR [ebx+111]
  005bd	52		 push	 edx
  005be	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  005c1	50		 push	 eax
  005c2	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@NDGFLPHI@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5S@

; 955  : 		}
; 956  : 		else

  005c7	e9 aa 00 00 00	 jmp	 $LN65@PlusItemLe
$LN5@PlusItemLe:

; 957  : 		{
; 958  : 			LogAdd(LOG_BLACK, "[PlusItemLevel] [%s][%s] CBMix Success %d Money : %d-%d [%d], CharmRate : %d",
; 959  : 				lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money,
; 960  : 				lpObj->ChaosMoney, Item.m_Level, iCharmOfLuckCount);

  005cc	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _iCharmOfLuckCount$[ebp]
  005d2	0f bf 95 44 ff
	ff ff		 movsx	 edx, WORD PTR _Item$155904[ebp+8]
  005d9	8b 83 e4 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3300]
  005df	51		 push	 ecx
  005e0	8b 8b b0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+176]
  005e6	52		 push	 edx
  005e7	8b 93 e8 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3304]
  005ed	50		 push	 eax
  005ee	51		 push	 ecx
  005ef	52		 push	 edx
  005f0	8d 43 6f	 lea	 eax, DWORD PTR [ebx+111]
  005f3	50		 push	 eax
  005f4	8d 4b 64	 lea	 ecx, DWORD PTR [ebx+100]
  005f7	51		 push	 ecx
  005f8	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@NDGFLPHI@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5S@

; 961  : 		}
; 962  : 	}
; 963  : 	else

  005fd	eb 77		 jmp	 SHORT $LN65@PlusItemLe
$LN6@PlusItemLe:

; 964  : 	{
; 965  : 		int FailLevel = lpObj->pChaosBox[PlusItemPos].m_Level+1;

  005ff	0f bf 74 16 08	 movsx	 esi, WORD PTR [esi+edx+8]

; 966  : 		ChaosBoxInit(lpObj);

  00604	53		 push	 ebx
  00605	46		 inc	 esi
  00606	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit

; 967  : 		GCUserChaosBoxSend(lpObj, 0);

  0060b	6a 00		 push	 0
  0060d	53		 push	 ebx
  0060e	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 968  : 
; 969  : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  00613	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00617	8b 13		 mov	 edx, DWORD PTR [ebx]
  00619	50		 push	 eax
  0061a	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0061d	51		 push	 ecx
  0061e	52		 push	 edx
  0061f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00624	83 c4 18	 add	 esp, 24			; 00000018H

; 970  : 
; 971  : 		if ( btItemLuckValue )

  00627	80 bd 3b ff ff
	ff 00		 cmp	 BYTE PTR _btItemLuckValue$[ebp], 0

; 972  : 		{
; 973  : 			LogAdd(LOG_BLACK, "[PlusItemLevel] [%s][%s] CBMix Fail %d Money : %d-%d [%d], CharmRate : %d",
; 974  : 				lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate+5, lpObj->Money,
; 975  : 				lpObj->ChaosMoney, FailLevel, iCharmOfLuckCount);

  0062e	57		 push	 edi
  0062f	56		 push	 esi
  00630	74 22		 je	 SHORT $LN2@PlusItemLe
  00632	8b 83 e4 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3300]
  00638	8b 8b b0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+176]
  0063e	8b 93 e8 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3304]
  00644	50		 push	 eax
  00645	51		 push	 ecx
  00646	83 c2 05	 add	 edx, 5
  00649	52		 push	 edx
  0064a	8d 43 6f	 lea	 eax, DWORD PTR [ebx+111]
  0064d	50		 push	 eax
  0064e	8d 4b 64	 lea	 ecx, DWORD PTR [ebx+100]
  00651	51		 push	 ecx

; 976  : 		}
; 977  : 		else

  00652	eb 1d		 jmp	 SHORT $LN66@PlusItemLe
$LN2@PlusItemLe:

; 978  : 		{
; 979  : 			LogAdd(LOG_BLACK, "[PlusItemLevel] [%s][%s] CBMix Fail %d Money : %d-%d [%d], CharmRate : %d",
; 980  : 				lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money,
; 981  : 				lpObj->ChaosMoney, FailLevel, iCharmOfLuckCount);

  00654	8b 93 e4 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3300]
  0065a	8b 83 b0 00 00
	00		 mov	 eax, DWORD PTR [ebx+176]
  00660	8b 8b e8 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3304]
  00666	52		 push	 edx
  00667	50		 push	 eax
  00668	51		 push	 ecx
  00669	8d 53 6f	 lea	 edx, DWORD PTR [ebx+111]
  0066c	52		 push	 edx
  0066d	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  00670	50		 push	 eax
$LN66@PlusItemLe:
  00671	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@JJBHLEGP@?$FLPlusItemLevel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@
$LN65@PlusItemLe:
  00676	6a 00		 push	 0
  00678	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0067d	83 c4 24	 add	 esp, 36			; 00000024H

; 982  : 		}
; 983  : 	}
; 984  : 
; 985  : 	lpObj->ChaosLock = FALSE;
; 986  : 	return TRUE;

  00680	b8 01 00 00 00	 mov	 eax, 1
$LN63@PlusItemLe:

; 987  : }

  00685	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00688	5f		 pop	 edi
  00689	5e		 pop	 esi
  0068a	c7 83 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+3308], 0
  00694	33 cd		 xor	 ecx, ebp
  00696	5b		 pop	 ebx
  00697	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0069c	8b e5		 mov	 esp, ebp
  0069e	5d		 pop	 ebp
  0069f	c3		 ret	 0
?PlusItemLevelChaosMix@@YAHPAUOBJECTSTRUCT@@H@Z ENDP	; PlusItemLevelChaosMix
_TEXT	ENDS
PUBLIC	??_C@_0ED@JKKAJEKA@?$FLDinorantMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fai@ ; `string'
PUBLIC	??_C@_0EG@BMPMHKIC@?$FLDinorantMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Suc@ ; `string'
PUBLIC	??_C@_0BO@BKFHPCAO@?$FLDinorantMix?$FN?5Chaos?5Mix?5Start?$AA@ ; `string'
PUBLIC	??_C@_0M@OEKEBNDM@DinorantMix?$AA@		; `string'
PUBLIC	__real@406fe00000000000
PUBLIC	__$ArrayPad$
PUBLIC	?PegasiaChaosMix@@YAHPAUOBJECTSTRUCT@@@Z	; PegasiaChaosMix
;	COMDAT ??_C@_0ED@JKKAJEKA@?$FLDinorantMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fai@
CONST	SEGMENT
??_C@_0ED@JKKAJEKA@?$FLDinorantMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fai@ DB '['
	DB	'DinorantMix] [%s][%s] CBMix Fail %d Money : %d-%d, CharmRate '
	DB	': %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@BMPMHKIC@?$FLDinorantMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Suc@
CONST	SEGMENT
??_C@_0EG@BMPMHKIC@?$FLDinorantMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Suc@ DB '['
	DB	'DinorantMix] [%s][%s] CBMix Success %d Money : %d-%d, CharmRa'
	DB	'te : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BKFHPCAO@?$FLDinorantMix?$FN?5Chaos?5Mix?5Start?$AA@
CONST	SEGMENT
??_C@_0BO@BKFHPCAO@?$FLDinorantMix?$FN?5Chaos?5Mix?5Start?$AA@ DB '[Dinor'
	DB	'antMix] Chaos Mix Start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OEKEBNDM@DinorantMix?$AA@
CONST	SEGMENT
??_C@_0M@OEKEBNDM@DinorantMix?$AA@ DB 'DinorantMix', 00H ; `string'
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?PegasiaChaosMix@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_ChoasGemCount$ = -24					; size = 4
_iCharmOfLuckCount$ = -20				; size = 4
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?PegasiaChaosMix@@YAHPAUOBJECTSTRUCT@@@Z PROC		; PegasiaChaosMix, COMDAT

; 995  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 996  : 	lpObj->ChaosLock = TRUE;
; 997  : 	int UniriaCount = 0;

  00016	33 ff		 xor	 edi, edi
  00018	c7 86 ec 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3308], 1
  00022	33 db		 xor	 ebx, ebx

; 998  : 	int ChoasGemCount = 0;

  00024	89 7d e8	 mov	 DWORD PTR _ChoasGemCount$[ebp], edi

; 999  : 	int iCharmOfLuckCount = 0;

  00027	89 7d ec	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], edi
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL19@PegasiaCha:

; 1002 : 	{
; 1003 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00030	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00036	03 cf		 add	 ecx, edi
  00038	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0003d	83 f8 01	 cmp	 eax, 1
  00040	75 53		 jne	 SHORT $LN18@PegasiaCha

; 1004 : 		{
; 1005 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(13,2) && lpObj->pChaosBox[n].m_Durability == 255.0f )	// Uniria

  00042	8b 96 dc 0c 00
	00		 mov	 edx, DWORD PTR [esi+3292]
  00048	0f b7 4c 3a 06	 movzx	 ecx, WORD PTR [edx+edi+6]
  0004d	b8 02 1a 00 00	 mov	 eax, 6658		; 00001a02H
  00052	66 3b c8	 cmp	 cx, ax
  00055	75 16		 jne	 SHORT $LN15@PegasiaCha
  00057	d9 44 3a 24	 fld	 DWORD PTR [edx+edi+36]
  0005b	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@406fe00000000000
  00061	da e9		 fucompp
  00063	df e0		 fnstsw	 ax
  00065	f6 c4 44	 test	 ah, 68			; 00000044H
  00068	7a 03		 jp	 SHORT $LN15@PegasiaCha

; 1006 : 			{
; 1007 : 				UniriaCount++;

  0006a	43		 inc	 ebx
  0006b	eb 28		 jmp	 SHORT $LN18@PegasiaCha
$LN15@PegasiaCha:

; 1008 : 			}
; 1009 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,15) ) // Chaos Gem

  0006d	b8 0f 18 00 00	 mov	 eax, 6159		; 0000180fH
  00072	66 3b c8	 cmp	 cx, ax
  00075	75 05		 jne	 SHORT $LN13@PegasiaCha

; 1010 : 			{
; 1011 : 				ChoasGemCount++;

  00077	ff 45 e8	 inc	 DWORD PTR _ChoasGemCount$[ebp]
  0007a	eb 19		 jmp	 SHORT $LN18@PegasiaCha
$LN13@PegasiaCha:

; 1012 : 			}
; 1013 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,53) )	// Charm Of Luck

  0007c	b8 35 1c 00 00	 mov	 eax, 7221		; 00001c35H
  00081	66 3b c8	 cmp	 cx, ax
  00084	75 0f		 jne	 SHORT $LN18@PegasiaCha

; 1014 : 			{
; 1015 : 				iCharmOfLuckCount += lpObj->pChaosBox[n].m_Durability;

  00086	db 45 ec	 fild	 DWORD PTR _iCharmOfLuckCount$[ebp]
  00089	d8 44 3a 24	 fadd	 DWORD PTR [edx+edi+36]
  0008d	e8 00 00 00 00	 call	 __ftol2_sse
  00092	89 45 ec	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], eax
$LN18@PegasiaCha:

; 1000 : 
; 1001 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00095	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  0009b	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  000a1	7c 8d		 jl	 SHORT $LL19@PegasiaCha

; 1016 : 			}
; 1017 : 		}
; 1018 : 	}
; 1019 : 
; 1020 : 	if ( UniriaCount != 10 || ChoasGemCount != 1 )

  000a3	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  000a6	0f 85 4e 02 00
	00		 jne	 $LN9@PegasiaCha
  000ac	83 7d e8 01	 cmp	 DWORD PTR _ChoasGemCount$[ebp], 1
  000b0	0f 85 44 02 00
	00		 jne	 $LN9@PegasiaCha

; 1021 : 	{
; 1022 : 		lpObj->ChaosLock = FALSE;
; 1023 : 		return FALSE;
; 1024 : 	}
; 1025 : 
; 1026 : 	PMSG_CHAOSMIXRESULT pMsg;
; 1027 : 
; 1028 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  000b6	6a 0b		 push	 11			; 0000000bH
  000b8	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000bb	68 86 00 00 00	 push	 134			; 00000086H
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1029 : 	pMsg.Result = CB_ERROR;

  000c9	c6 45 f3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 1030 : 
; 1031 : 	if ( iCharmOfLuckCount > 10 )

  000cd	39 5d ec	 cmp	 DWORD PTR _iCharmOfLuckCount$[ebp], ebx
  000d0	7e 35		 jle	 SHORT $LN8@PegasiaCha

; 1032 : 	{
; 1033 : 		lpObj->ChaosLock = FALSE;
; 1034 : 		pMsg.Result = 0xF0;
; 1035 : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  000d2	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  000d6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000d8	52		 push	 edx
  000d9	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000dc	50		 push	 eax
  000dd	51		 push	 ecx
  000de	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  000e8	c6 45 f3 f0	 mov	 BYTE PTR _pMsg$[ebp+3], 240 ; 000000f0H
  000ec	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	33 c0		 xor	 eax, eax
  000f8	5b		 pop	 ebx

; 1106 : 
; 1107 : 		lpObj->ChaosLock = FALSE;
; 1108 : 		return FALSE;
; 1109 : 	}
; 1110 : }

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fc	33 cd		 xor	 ecx, ebp
  000fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
$LN8@PegasiaCha:

; 1036 : 
; 1037 : 		return 0;
; 1038 : 	}
; 1039 : 
; 1040 : 	int nChaosNeedMoney = 500000;
; 1041 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  00107	8b 16		 mov	 edx, DWORD PTR [esi]
  00109	52		 push	 edx
  0010a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0010f	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00114	6a 00		 push	 0
  00116	99		 cdq
  00117	68 20 a1 07 00	 push	 500000			; 0007a120H
  0011c	52		 push	 edx
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 __allmul
  00123	6a 00		 push	 0
  00125	6a 64		 push	 100			; 00000064H
  00127	52		 push	 edx
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 __alldiv
  0012e	8b d8		 mov	 ebx, eax

; 1042 : 
; 1043 : 	if ( iChaosTaxMoney < 0 )

  00130	85 db		 test	 ebx, ebx
  00132	79 02		 jns	 SHORT $LN7@PegasiaCha

; 1044 : 	{
; 1045 : 		iChaosTaxMoney = 0;

  00134	33 db		 xor	 ebx, ebx
$LN7@PegasiaCha:

; 1046 : 	}
; 1047 : 
; 1048 : 	nChaosNeedMoney += iChaosTaxMoney;

  00136	8d bb 20 a1 07
	00		 lea	 edi, DWORD PTR [ebx+500000]

; 1049 : 
; 1050 : 	if ( nChaosNeedMoney < 0 )

  0013c	85 ff		 test	 edi, edi
  0013e	79 02		 jns	 SHORT $LN6@PegasiaCha

; 1051 : 	{
; 1052 : 		nChaosNeedMoney = 0;

  00140	33 ff		 xor	 edi, edi
$LN6@PegasiaCha:

; 1053 : 	}
; 1054 : 
; 1055 : 	if ( lpObj->Money < nChaosNeedMoney )

  00142	39 be b0 00 00
	00		 cmp	 DWORD PTR [esi+176], edi
  00148	7d 42		 jge	 SHORT $LN5@PegasiaCha

; 1056 : 	{
; 1057 : 		lpObj->ChaosLock = FALSE;
; 1058 : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;
; 1059 : 		
; 1060 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  0014a	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0014e	8b 16		 mov	 edx, DWORD PTR [esi]
  00150	50		 push	 eax
  00151	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00154	51		 push	 ecx
  00155	52		 push	 edx
  00156	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  00160	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
  00164	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00169	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016c	5f		 pop	 edi

; 1061 : 		lpObj->ChaosLock = FALSE;

  0016d	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  00177	5e		 pop	 esi

; 1062 : 
; 1063 : 		return TRUE;

  00178	b8 01 00 00 00	 mov	 eax, 1
  0017d	5b		 pop	 ebx

; 1106 : 
; 1107 : 		lpObj->ChaosLock = FALSE;
; 1108 : 		return FALSE;
; 1109 : 	}
; 1110 : }

  0017e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00181	33 cd		 xor	 ecx, ebp
  00183	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
$LN5@PegasiaCha:

; 1064 : 	}
; 1065 : 
; 1066 : 	LogChaosItem(lpObj, "DinorantMix");

  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OEKEBNDM@DinorantMix?$AA@
  00191	56		 push	 esi
  00192	e8 00 00 00 00	 call	 ?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z ; LogChaosItem

; 1067 : 	LogAdd(LOG_BLACK, "[DinorantMix] Chaos Mix Start");

  00197	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BKFHPCAO@?$FLDinorantMix?$FN?5Chaos?5Mix?5Start?$AA@
  0019c	6a 00		 push	 0
  0019e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 1068 : 	lpObj->ChaosSuccessRate = 70;	// Succes Rate for Dinorant
; 1069 : 	lpObj->ChaosSuccessRate += iCharmOfLuckCount;

  001a3	8b 45 ec	 mov	 eax, DWORD PTR _iCharmOfLuckCount$[ebp]

; 1070 : 	lpObj->Money -= nChaosNeedMoney;

  001a6	29 be b0 00 00
	00		 sub	 DWORD PTR [esi+176], edi
  001ac	83 c4 10	 add	 esp, 16			; 00000010H
  001af	83 c0 46	 add	 eax, 70			; 00000046H

; 1071 : 
; 1072 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  001b2	53		 push	 ebx
  001b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  001b8	89 86 e8 0c 00
	00		 mov	 DWORD PTR [esi+3304], eax
  001be	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 1073 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  001c3	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  001c9	8b 16		 mov	 edx, DWORD PTR [esi]
  001cb	51		 push	 ecx
  001cc	52		 push	 edx
  001cd	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  001d2	83 c4 08	 add	 esp, 8

; 1074 : 
; 1075 : 	if ( (rand()%100 ) < lpObj->ChaosSuccessRate )

  001d5	e8 00 00 00 00	 call	 _rand
  001da	99		 cdq
  001db	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001e0	f7 f9		 idiv	 ecx
  001e2	3b 96 e8 0c 00
	00		 cmp	 edx, DWORD PTR [esi+3304]
  001e8	0f 8d c3 00 00
	00		 jge	 $LN4@PegasiaCha

; 1076 : 	{
; 1077 : 		int Dinorant = ITEMGET(13,3);
; 1078 : 		int Option3 = 0;

  001ee	33 db		 xor	 ebx, ebx

; 1079 : 
; 1080 : 		if ( (rand()% 100) < 30 )

  001f0	e8 00 00 00 00	 call	 _rand
  001f5	99		 cdq
  001f6	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001fb	f7 f9		 idiv	 ecx
  001fd	83 fa 1e	 cmp	 edx, 30			; 0000001eH
  00200	7d 3f		 jge	 SHORT $LN24@PegasiaCha

; 1081 : 		{
; 1082 : 			Option3 = 1 <<  ((rand()%3)) ;

  00202	e8 00 00 00 00	 call	 _rand
  00207	99		 cdq
  00208	b9 03 00 00 00	 mov	 ecx, 3
  0020d	f7 f9		 idiv	 ecx
  0020f	bb 01 00 00 00	 mov	 ebx, 1
  00214	8b ca		 mov	 ecx, edx
  00216	d3 e3		 shl	 ebx, cl

; 1083 : 
; 1084 : 			if ( (rand()%5) == 0 )

  00218	e8 00 00 00 00	 call	 _rand
  0021d	99		 cdq
  0021e	b9 05 00 00 00	 mov	 ecx, 5
  00223	f7 f9		 idiv	 ecx
  00225	85 d2		 test	 edx, edx
  00227	75 18		 jne	 SHORT $LN24@PegasiaCha

; 1085 : 			{
; 1086 : 				Option3 |= 1 << (rand()%3);

  00229	e8 00 00 00 00	 call	 _rand
  0022e	99		 cdq
  0022f	b9 03 00 00 00	 mov	 ecx, 3
  00234	f7 f9		 idiv	 ecx
  00236	b8 01 00 00 00	 mov	 eax, 1
  0023b	8b ca		 mov	 ecx, edx
  0023d	d3 e0		 shl	 eax, cl
  0023f	0b d8		 or	 ebx, eax
$LN24@PegasiaCha:

; 1087 : 			}
; 1088 : 		}
; 1089 : 
; 1090 : 		::ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, Dinorant, 0, 255, 1, 0, Option3, -1, 0, 0);

  00241	6a 00		 push	 0
  00243	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00245	6a 00		 push	 0
  00247	6a ff		 push	 -1
  00249	53		 push	 ebx
  0024a	6a 00		 push	 0
  0024c	6a 01		 push	 1
  0024e	68 ff 00 00 00	 push	 255			; 000000ffH
  00253	6a 00		 push	 0
  00255	68 03 1a 00 00	 push	 6659			; 00001a03H
  0025a	6a 00		 push	 0
  0025c	6a 00		 push	 0
  0025e	68 ff 00 00 00	 push	 255			; 000000ffH
  00263	51		 push	 ecx
  00264	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 1091 : 		::gObjInventoryCommit(lpObj->m_Index);

  00269	8b 16		 mov	 edx, DWORD PTR [esi]
  0026b	52		 push	 edx
  0026c	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit

; 1092 : 
; 1093 : 		LogAdd(LOG_BLACK, "[DinorantMix] [%s][%s] CBMix Success %d Money : %d-%d, CharmRate : %d",
; 1094 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney, iCharmOfLuckCount);

  00271	8b 45 ec	 mov	 eax, DWORD PTR _iCharmOfLuckCount$[ebp]
  00274	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  0027a	8b 96 e8 0c 00
	00		 mov	 edx, DWORD PTR [esi+3304]
  00280	50		 push	 eax
  00281	57		 push	 edi
  00282	51		 push	 ecx
  00283	52		 push	 edx
  00284	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00287	50		 push	 eax
  00288	83 c6 64	 add	 esi, 100		; 00000064H
  0028b	56		 push	 esi
  0028c	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@BMPMHKIC@?$FLDinorantMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Suc@
  00291	6a 00		 push	 0
  00293	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00298	83 c4 58	 add	 esp, 88			; 00000058H
  0029b	5f		 pop	 edi
  0029c	5e		 pop	 esi

; 1095 : 
; 1096 : 		return TRUE;

  0029d	b8 01 00 00 00	 mov	 eax, 1
  002a2	5b		 pop	 ebx

; 1106 : 
; 1107 : 		lpObj->ChaosLock = FALSE;
; 1108 : 		return FALSE;
; 1109 : 	}
; 1110 : }

  002a3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a6	33 cd		 xor	 ecx, ebp
  002a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ad	8b e5		 mov	 esp, ebp
  002af	5d		 pop	 ebp
  002b0	c3		 ret	 0
$LN4@PegasiaCha:

; 1097 : 	}
; 1098 : 	else
; 1099 : 	{
; 1100 : 		ChaosBoxInit(lpObj);	// Errase Chaos Box

  002b1	56		 push	 esi
  002b2	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit

; 1101 : 		GCUserChaosBoxSend(lpObj, 0);

  002b7	6a 00		 push	 0
  002b9	56		 push	 esi
  002ba	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 1102 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  002bf	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  002c3	8b 06		 mov	 eax, DWORD PTR [esi]
  002c5	51		 push	 ecx
  002c6	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  002c9	52		 push	 edx
  002ca	50		 push	 eax
  002cb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1103 : 
; 1104 : 		LogAdd(LOG_BLACK, "[DinorantMix] [%s][%s] CBMix Fail %d Money : %d-%d, CharmRate : %d",
; 1105 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney, iCharmOfLuckCount);

  002d0	8b 4d ec	 mov	 ecx, DWORD PTR _iCharmOfLuckCount$[ebp]
  002d3	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  002d9	8b 86 e8 0c 00
	00		 mov	 eax, DWORD PTR [esi+3304]
  002df	51		 push	 ecx
  002e0	57		 push	 edi
  002e1	52		 push	 edx
  002e2	50		 push	 eax
  002e3	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  002e6	51		 push	 ecx
  002e7	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  002ea	52		 push	 edx
  002eb	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@JKKAJEKA@?$FLDinorantMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fai@
  002f0	6a 00		 push	 0
  002f2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  002f7	83 c4 38	 add	 esp, 56			; 00000038H
$LN9@PegasiaCha:

; 1106 : 
; 1107 : 		lpObj->ChaosLock = FALSE;
; 1108 : 		return FALSE;
; 1109 : 	}
; 1110 : }

  002fa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002fd	5f		 pop	 edi
  002fe	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  00308	5e		 pop	 esi
  00309	33 cd		 xor	 ecx, ebp
  0030b	33 c0		 xor	 eax, eax
  0030d	5b		 pop	 ebx
  0030e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00313	8b e5		 mov	 esp, ebp
  00315	5d		 pop	 ebp
  00316	c3		 ret	 0
?PegasiaChaosMix@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; PegasiaChaosMix
_TEXT	ENDS
PUBLIC	??_C@_0EB@FKBAIBLL@?$FLCircleMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5@ ; `string'
PUBLIC	??_C@_0EE@PAFLGDEL@?$FLCircleMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Succe@ ; `string'
PUBLIC	??_C@_0BM@EFIHICLO@?$FLCircleMix?$FN?5Chaos?5Mix?5Start?$AA@ ; `string'
PUBLIC	??_C@_09CKGJGION@CircleMix?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CircleChaosMix@@YAHPAUOBJECTSTRUCT@@@Z		; CircleChaosMix
;	COMDAT ??_C@_0EB@FKBAIBLL@?$FLCircleMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5@
CONST	SEGMENT
??_C@_0EB@FKBAIBLL@?$FLCircleMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5@ DB '['
	DB	'CircleMix] [%s][%s] CBMix Fail %d Money : %d-%d, CharmRate : '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@PAFLGDEL@?$FLCircleMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Succe@
CONST	SEGMENT
??_C@_0EE@PAFLGDEL@?$FLCircleMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Succe@ DB '['
	DB	'CircleMix] [%s][%s] CBMix Success %d Money : %d-%d, CharmRate'
	DB	' : %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EFIHICLO@?$FLCircleMix?$FN?5Chaos?5Mix?5Start?$AA@
CONST	SEGMENT
??_C@_0BM@EFIHICLO@?$FLCircleMix?$FN?5Chaos?5Mix?5Start?$AA@ DB '[CircleM'
	DB	'ix] Chaos Mix Start', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09CKGJGION@CircleMix?$AA@
CONST	SEGMENT
??_C@_09CKGJGION@CircleMix?$AA@ DB 'CircleMix', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CircleChaosMix@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_ChoasGemCount$ = -24					; size = 4
_iCharmOfLuckCount$ = -20				; size = 4
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?CircleChaosMix@@YAHPAUOBJECTSTRUCT@@@Z PROC		; CircleChaosMix, COMDAT

; 1118 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 1119 : 	lpObj->ChaosLock = TRUE;
; 1120 : 
; 1121 : 	int CreatureGemCount = 0;

  00016	33 ff		 xor	 edi, edi
  00018	c7 86 ec 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3308], 1
  00022	33 db		 xor	 ebx, ebx

; 1122 : 	int ChoasGemCount = 0;

  00024	89 7d e8	 mov	 DWORD PTR _ChoasGemCount$[ebp], edi

; 1123 : 	int iCharmOfLuckCount = 0;

  00027	89 7d ec	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], edi
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL26@CircleChao:

; 1126 : 	{
; 1127 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00030	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00036	03 cf		 add	 ecx, edi
  00038	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0003d	83 f8 01	 cmp	 eax, 1
  00040	75 40		 jne	 SHORT $LN25@CircleChao

; 1128 : 		{
; 1129 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,22) )	// Jewel of Creation

  00042	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00048	0f b7 44 39 06	 movzx	 eax, WORD PTR [ecx+edi+6]
  0004d	ba 16 1c 00 00	 mov	 edx, 7190		; 00001c16H
  00052	66 3b c2	 cmp	 ax, dx
  00055	75 03		 jne	 SHORT $LN22@CircleChao

; 1130 : 			{
; 1131 : 				CreatureGemCount++;

  00057	43		 inc	 ebx
  00058	eb 28		 jmp	 SHORT $LN25@CircleChao
$LN22@CircleChao:

; 1132 : 			}
; 1133 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,15) ) // Chaos Gem

  0005a	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  0005f	66 3b c2	 cmp	 ax, dx
  00062	75 05		 jne	 SHORT $LN20@CircleChao

; 1134 : 			{
; 1135 : 				ChoasGemCount++;

  00064	ff 45 e8	 inc	 DWORD PTR _ChoasGemCount$[ebp]
  00067	eb 19		 jmp	 SHORT $LN25@CircleChao
$LN20@CircleChao:

; 1136 : 			}
; 1137 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,53) )	// Charm Of Luck

  00069	ba 35 1c 00 00	 mov	 edx, 7221		; 00001c35H
  0006e	66 3b c2	 cmp	 ax, dx
  00071	75 0f		 jne	 SHORT $LN25@CircleChao

; 1138 : 			{
; 1139 : 				iCharmOfLuckCount += lpObj->pChaosBox[n].m_Durability;

  00073	db 45 ec	 fild	 DWORD PTR _iCharmOfLuckCount$[ebp]
  00076	d8 44 39 24	 fadd	 DWORD PTR [ecx+edi+36]
  0007a	e8 00 00 00 00	 call	 __ftol2_sse
  0007f	89 45 ec	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], eax
$LN25@CircleChao:

; 1124 : 
; 1125 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00082	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00088	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  0008e	7c a0		 jl	 SHORT $LL26@CircleChao

; 1140 : 			}
; 1141 : 		}
; 1142 : 	}
; 1143 : 
; 1144 : 	if ( CreatureGemCount != 1 || ChoasGemCount != 1 )

  00090	83 fb 01	 cmp	 ebx, 1
  00093	0f 85 4f 02 00
	00		 jne	 $LN16@CircleChao
  00099	39 5d e8	 cmp	 DWORD PTR _ChoasGemCount$[ebp], ebx
  0009c	0f 85 46 02 00
	00		 jne	 $LN16@CircleChao

; 1145 : 	{
; 1146 : 		return FALSE;
; 1147 : 	}
; 1148 : 
; 1149 : 	PMSG_CHAOSMIXRESULT pMsg;
; 1150 : 
; 1151 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  000a2	6a 0b		 push	 11			; 0000000bH
  000a4	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000a7	68 86 00 00 00	 push	 134			; 00000086H
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1152 : 	pMsg.Result = CB_ERROR;
; 1153 : 
; 1154 : 	if ( iCharmOfLuckCount > 10 )

  000b2	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ba	c6 45 f3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  000be	39 45 ec	 cmp	 DWORD PTR _iCharmOfLuckCount$[ebp], eax
  000c1	7e 35		 jle	 SHORT $LN15@CircleChao

; 1155 : 	{
; 1156 : 		lpObj->ChaosLock = FALSE;
; 1157 : 		pMsg.Result = 0xF0;
; 1158 : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  000c3	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000c7	8b 06		 mov	 eax, DWORD PTR [esi]
  000c9	51		 push	 ecx
  000ca	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000cd	52		 push	 edx
  000ce	50		 push	 eax
  000cf	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  000d9	c6 45 f3 f0	 mov	 BYTE PTR _pMsg$[ebp+3], 240 ; 000000f0H
  000dd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi

; 1159 : 
; 1160 : 		return 1;

  000e7	8b c3		 mov	 eax, ebx
  000e9	5b		 pop	 ebx

; 1252 : 
; 1253 : 		return FALSE;
; 1254 : 	}
; 1255 : }

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ed	33 cd		 xor	 ecx, ebp
  000ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
$LN15@CircleChao:

; 1161 : 	}
; 1162 : 
; 1163 : 	if ( lpObj->Level < 10 )

  000f8	66 39 86 9c 00
	00 00		 cmp	 WORD PTR [esi+156], ax
  000ff	7d 38		 jge	 SHORT $LN14@CircleChao

; 1164 : 	{
; 1165 : 		pMsg.Result = CB_LOW_LEVEL_USER;
; 1166 : 
; 1167 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  00101	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00105	8b 06		 mov	 eax, DWORD PTR [esi]
  00107	51		 push	 ecx
  00108	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0010b	52		 push	 edx
  0010c	c6 45 f3 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4
  00110	50		 push	 eax
$LN31@CircleChao:
  00111	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1168 : 		lpObj->ChaosLock = FALSE;

  00119	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
$LN32@CircleChao:

; 1169 : 
; 1170 : 		return TRUE;

  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	b8 01 00 00 00	 mov	 eax, 1
  0012a	5b		 pop	 ebx

; 1252 : 
; 1253 : 		return FALSE;
; 1254 : 	}
; 1255 : }

  0012b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012e	33 cd		 xor	 ecx, ebp
  00130	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
$LN14@CircleChao:

; 1171 : 	}
; 1172 : 
; 1173 : 	int nChaosNeedMoney = 3000000;
; 1174 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  00139	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0013b	51		 push	 ecx
  0013c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00141	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00146	6a 00		 push	 0
  00148	99		 cdq
  00149	68 c0 c6 2d 00	 push	 3000000			; 002dc6c0H
  0014e	52		 push	 edx
  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 __allmul
  00155	6a 00		 push	 0
  00157	6a 64		 push	 100			; 00000064H
  00159	52		 push	 edx
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 __alldiv
  00160	8b d8		 mov	 ebx, eax

; 1175 : 
; 1176 : 	if ( iChaosTaxMoney < 0 )

  00162	85 db		 test	 ebx, ebx
  00164	79 02		 jns	 SHORT $LN13@CircleChao

; 1177 : 	{
; 1178 : 		iChaosTaxMoney = 0;

  00166	33 db		 xor	 ebx, ebx
$LN13@CircleChao:

; 1179 : 	}
; 1180 : 
; 1181 : 	nChaosNeedMoney += iChaosTaxMoney;

  00168	8d bb c0 c6 2d
	00		 lea	 edi, DWORD PTR [ebx+3000000]

; 1182 : 
; 1183 : 	if ( nChaosNeedMoney < 0 )

  0016e	85 ff		 test	 edi, edi
  00170	79 02		 jns	 SHORT $LN12@CircleChao

; 1184 : 	{
; 1185 : 		nChaosNeedMoney = 0;

  00172	33 ff		 xor	 edi, edi
$LN12@CircleChao:

; 1186 : 	}
; 1187 : 
; 1188 : 	if ( lpObj->Money < nChaosNeedMoney )

  00174	39 be b0 00 00
	00		 cmp	 DWORD PTR [esi+176], edi
  0017a	7d 1f		 jge	 SHORT $LN11@CircleChao

; 1189 : 	{
; 1190 : 		lpObj->ChaosLock = FALSE;
; 1191 : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;
; 1192 : 		
; 1193 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  0017c	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00180	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00182	52		 push	 edx
  00183	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00186	50		 push	 eax
  00187	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  00191	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
  00195	51		 push	 ecx

; 1194 : 		lpObj->ChaosLock = FALSE;
; 1195 : 
; 1196 : 		return TRUE;

  00196	e9 76 ff ff ff	 jmp	 $LN31@CircleChao
$LN11@CircleChao:

; 1197 : 	}
; 1198 : 
; 1199 : 	LogChaosItem(lpObj, "CircleMix");

  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_09CKGJGION@CircleMix?$AA@
  001a0	56		 push	 esi
  001a1	e8 00 00 00 00	 call	 ?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z ; LogChaosItem

; 1200 : 	LogAdd(LOG_BLACK, "[CircleMix] Chaos Mix Start");

  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@EFIHICLO@?$FLCircleMix?$FN?5Chaos?5Mix?5Start?$AA@
  001ab	6a 00		 push	 0
  001ad	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 1201 : 	lpObj->ChaosSuccessRate = 90;	// Succes Rate for Fruit
; 1202 : 	lpObj->ChaosSuccessRate += iCharmOfLuckCount;

  001b2	8b 55 ec	 mov	 edx, DWORD PTR _iCharmOfLuckCount$[ebp]

; 1203 : 	lpObj->Money -= nChaosNeedMoney;

  001b5	29 be b0 00 00
	00		 sub	 DWORD PTR [esi+176], edi
  001bb	83 c4 10	 add	 esp, 16			; 00000010H
  001be	83 c2 5a	 add	 edx, 90			; 0000005aH

; 1204 : 
; 1205 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  001c1	53		 push	 ebx
  001c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  001c7	89 96 e8 0c 00
	00		 mov	 DWORD PTR [esi+3304], edx
  001cd	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 1206 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  001d2	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  001d8	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001da	50		 push	 eax
  001db	51		 push	 ecx
  001dc	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  001e1	83 c4 08	 add	 esp, 8

; 1207 : 
; 1208 : 	if ( (rand()%100 ) < lpObj->ChaosSuccessRate )

  001e4	e8 00 00 00 00	 call	 _rand
  001e9	99		 cdq
  001ea	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001ef	f7 f9		 idiv	 ecx
  001f1	3b 96 e8 0c 00
	00		 cmp	 edx, DWORD PTR [esi+3304]
  001f7	0f 8d 98 00 00
	00		 jge	 $LN10@CircleChao

; 1209 : 	{
; 1210 : 		int Fruit = ITEMGET(13,15);	// Fruit
; 1211 : 		int FruitType;
; 1212 : 		int RandonValue = rand() % 100;

  001fd	e8 00 00 00 00	 call	 _rand
  00202	99		 cdq
  00203	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00208	f7 f9		 idiv	 ecx

; 1213 : 
; 1214 : 		if ( RandonValue < 30 )

  0020a	83 fa 1e	 cmp	 edx, 30			; 0000001eH
  0020d	7d 04		 jge	 SHORT $LN9@CircleChao

; 1215 : 		{
; 1216 : 			FruitType = 0;

  0020f	33 c0		 xor	 eax, eax
  00211	eb 23		 jmp	 SHORT $LN3@CircleChao
$LN9@CircleChao:

; 1217 : 		}
; 1218 : 		else if ( RandonValue < 55 )

  00213	83 fa 37	 cmp	 edx, 55			; 00000037H
  00216	7d 07		 jge	 SHORT $LN7@CircleChao

; 1219 : 		{
; 1220 : 			FruitType = 1;

  00218	b8 01 00 00 00	 mov	 eax, 1
  0021d	eb 17		 jmp	 SHORT $LN3@CircleChao
$LN7@CircleChao:

; 1221 : 		}
; 1222 : 		else if ( RandonValue < 75 )

  0021f	83 fa 4b	 cmp	 edx, 75			; 0000004bH
  00222	7d 07		 jge	 SHORT $LN5@CircleChao

; 1223 : 		{
; 1224 : 			FruitType = 2;

  00224	b8 02 00 00 00	 mov	 eax, 2
  00229	eb 0b		 jmp	 SHORT $LN3@CircleChao
$LN5@CircleChao:

; 1225 : 		}
; 1226 : 		else if ( RandonValue < 95 )

  0022b	33 c0		 xor	 eax, eax
  0022d	83 fa 5f	 cmp	 edx, 95			; 0000005fH
  00230	0f 9d c0	 setge	 al
  00233	83 c0 03	 add	 eax, 3
$LN3@CircleChao:

; 1227 : 		{
; 1228 : 			FruitType = 3;
; 1229 : 		}
; 1230 : 		else
; 1231 : 		{
; 1232 : 			FruitType = 4;
; 1233 : 		}
; 1234 : 
; 1235 : 		::ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, Fruit, FruitType, 255, 1, 0, 0, -1, 0, 0);

  00236	6a 00		 push	 0
  00238	8b 16		 mov	 edx, DWORD PTR [esi]
  0023a	6a 00		 push	 0
  0023c	6a ff		 push	 -1
  0023e	6a 00		 push	 0
  00240	6a 00		 push	 0
  00242	6a 01		 push	 1
  00244	68 ff 00 00 00	 push	 255			; 000000ffH
  00249	50		 push	 eax
  0024a	68 0f 1a 00 00	 push	 6671			; 00001a0fH
  0024f	6a 00		 push	 0
  00251	6a 00		 push	 0
  00253	68 ff 00 00 00	 push	 255			; 000000ffH
  00258	52		 push	 edx
  00259	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 1236 : 		::gObjInventoryCommit(lpObj->m_Index);

  0025e	8b 06		 mov	 eax, DWORD PTR [esi]
  00260	50		 push	 eax
  00261	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit

; 1237 : 
; 1238 : 		LogAdd(LOG_BLACK, "[CircleMix] [%s][%s] CBMix Success %d Money : %d-%d, CharmRate : %d",
; 1239 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney, iCharmOfLuckCount);

  00266	8b 4d ec	 mov	 ecx, DWORD PTR _iCharmOfLuckCount$[ebp]
  00269	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  0026f	8b 86 e8 0c 00
	00		 mov	 eax, DWORD PTR [esi+3304]
  00275	51		 push	 ecx
  00276	57		 push	 edi
  00277	52		 push	 edx
  00278	50		 push	 eax
  00279	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  0027c	51		 push	 ecx
  0027d	83 c6 64	 add	 esi, 100		; 00000064H
  00280	56		 push	 esi
  00281	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@PAFLGDEL@?$FLCircleMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Succe@
  00286	6a 00		 push	 0
  00288	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0028d	83 c4 58	 add	 esp, 88			; 00000058H

; 1240 : 
; 1241 : 		return TRUE;

  00290	e9 8e fe ff ff	 jmp	 $LN32@CircleChao
$LN10@CircleChao:

; 1242 : 	}
; 1243 : 	else
; 1244 : 	{
; 1245 : 		ChaosBoxInit(lpObj);

  00295	56		 push	 esi
  00296	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit

; 1246 : 		GCUserChaosBoxSend(lpObj, 0);

  0029b	6a 00		 push	 0
  0029d	56		 push	 esi
  0029e	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 1247 : 
; 1248 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  002a3	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  002a7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002a9	52		 push	 edx
  002aa	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  002ad	50		 push	 eax
  002ae	51		 push	 ecx
  002af	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1249 : 		LogAdd(LOG_BLACK, "[CircleMix] [%s][%s] CBMix Fail %d Money : %d-%d, CharmRate : %d",
; 1250 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney, iCharmOfLuckCount);

  002b4	8b 55 ec	 mov	 edx, DWORD PTR _iCharmOfLuckCount$[ebp]
  002b7	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  002bd	8b 8e e8 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3304]
  002c3	52		 push	 edx
  002c4	57		 push	 edi
  002c5	50		 push	 eax
  002c6	51		 push	 ecx
  002c7	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  002ca	52		 push	 edx
  002cb	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  002ce	50		 push	 eax
  002cf	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@FKBAIBLL@?$FLCircleMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5@
  002d4	6a 00		 push	 0
  002d6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  002db	83 c4 38	 add	 esp, 56			; 00000038H

; 1251 : 		lpObj->ChaosLock = FALSE;

  002de	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
$LN16@CircleChao:

; 1252 : 
; 1253 : 		return FALSE;
; 1254 : 	}
; 1255 : }

  002e8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002eb	5f		 pop	 edi
  002ec	5e		 pop	 esi
  002ed	33 cd		 xor	 ecx, ebp
  002ef	33 c0		 xor	 eax, eax
  002f1	5b		 pop	 ebx
  002f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f7	8b e5		 mov	 esp, ebp
  002f9	5d		 pop	 ebp
  002fa	c3		 ret	 0
?CircleChaosMix@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; CircleChaosMix
_TEXT	ENDS
PUBLIC	??_C@_0DA@FMJGNMLI@?$FLDevilSquare?$FN?5Too?5many?5Devil?8s?5K@ ; `string'
PUBLIC	??_C@_0CK@JNMMBAIA@?$FLDevilSquare?$FN?5Charm?5Of?5Luck?5Over@ ; `string'
PUBLIC	??_C@_0CH@NMBMOEEC@?$FLDevilSquare?$FN?5Not?5Found?5Chaos?5Ge@ ; `string'
PUBLIC	??_C@_0DB@DMIHKADD@?$FLDevilSquare?$FN?5DiffLevel?5Devil?8s?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DevilSquareItemChaosMix@@YAXPAUOBJECTSTRUCT@@@Z ; DevilSquareItemChaosMix
EXTRN	?gDevilSquareEvent@@3HA:DWORD			; gDevilSquareEvent
;	COMDAT ??_C@_0DA@FMJGNMLI@?$FLDevilSquare?$FN?5Too?5many?5Devil?8s?5K@
CONST	SEGMENT
??_C@_0DA@FMJGNMLI@?$FLDevilSquare?$FN?5Too?5many?5Devil?8s?5K@ DB '[Devi'
	DB	'lSquare] Too many Devil''s Key or Eyes [%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JNMMBAIA@?$FLDevilSquare?$FN?5Charm?5Of?5Luck?5Over@
CONST	SEGMENT
??_C@_0CK@JNMMBAIA@?$FLDevilSquare?$FN?5Charm?5Of?5Luck?5Over@ DB '[Devil'
	DB	'Square] Charm Of Luck Over 10% [%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NMBMOEEC@?$FLDevilSquare?$FN?5Not?5Found?5Chaos?5Ge@
CONST	SEGMENT
??_C@_0CH@NMBMOEEC@?$FLDevilSquare?$FN?5Not?5Found?5Chaos?5Ge@ DB '[Devil'
	DB	'Square] Not Found Chaos Gem [%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@DMIHKADD@?$FLDevilSquare?$FN?5DiffLevel?5Devil?8s?5@
CONST	SEGMENT
??_C@_0DB@DMIHKADD@?$FLDevilSquare?$FN?5DiffLevel?5Devil?8s?5@ DB '[Devil'
	DB	'Square] DiffLevel Devil''s Key or Eyes [%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DevilSquareItemChaosMix@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_itemlevel$156194 = -24					; size = 4
_eventitemcount$156193 = -20				; size = 4
_pMsg$156189 = -16					; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?DevilSquareItemChaosMix@@YAXPAUOBJECTSTRUCT@@@Z PROC	; DevilSquareItemChaosMix, COMDAT

; 1710 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 1711 : 	lpObj->ChaosLock = TRUE;
; 1712 : 
; 1713 : #if(GS_CASTLE==0)
; 1714 : 	if ( gDevilSquareEvent != FALSE )

  00015	33 db		 xor	 ebx, ebx
  00017	c7 86 ec 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3308], 1
  00021	57		 push	 edi
  00022	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?gDevilSquareEvent@@3HA, ebx ; gDevilSquareEvent
  00028	0f 84 30 01 00
	00		 je	 $LN1@DevilSquar@2

; 1715 : #endif
; 1716 : 	{
; 1717 : 		PMSG_CHAOSMIXRESULT pMsg;
; 1718 : 		PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  0002e	6a 0b		 push	 11			; 0000000bH
  00030	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$156189[ebp]
  00033	68 86 00 00 00	 push	 134			; 00000086H
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1719 : 		pMsg.Result = CB_ERROR;
; 1720 : 		int aIndex = lpObj->m_Index;

  0003e	8b 3e		 mov	 edi, DWORD PTR [esi]

; 1721 : 		int eventitemcount;
; 1722 : 		int itemlevel;
; 1723 : 		int Ret = ::CheckDevilSquareItem(lpObj, eventitemcount, itemlevel);

  00040	8d 4d e8	 lea	 ecx, DWORD PTR _itemlevel$156194[ebp]
  00043	51		 push	 ecx
  00044	8d 55 ec	 lea	 edx, DWORD PTR _eventitemcount$156193[ebp]
  00047	52		 push	 edx
  00048	56		 push	 esi
  00049	88 5d f3	 mov	 BYTE PTR _pMsg$156189[ebp+3], bl
  0004c	e8 00 00 00 00	 call	 ?CheckDevilSquareItem@@YAHPAUOBJECTSTRUCT@@AAH1@Z ; CheckDevilSquareItem
  00051	83 c4 18	 add	 esp, 24			; 00000018H

; 1724 : 
; 1725 : 		if ( Ret != FALSE )

  00054	3b c3		 cmp	 eax, ebx
  00056	0f 84 e6 00 00
	00		 je	 $LN7@DevilSquar@2

; 1726 : 		{
; 1727 : 			if ( Ret == 3 )

  0005c	83 f8 03	 cmp	 eax, 3
  0005f	75 2a		 jne	 SHORT $LN6@DevilSquar@2

; 1728 : 			{
; 1729 : 				pMsg.Result = CB_INCORRECT_MIX_ITEMS;
; 1730 : 				DataSend(aIndex, (BYTE*)&pMsg, pMsg.h.size);

  00061	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$156189[ebp+1]
  00065	50		 push	 eax
  00066	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$156189[ebp]
  00069	51		 push	 ecx
  0006a	57		 push	 edi
  0006b	c6 45 f3 07	 mov	 BYTE PTR _pMsg$156189[ebp+3], 7
  0006f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1731 : 				LogAdd(LOG_BLACK, "[DevilSquare] DiffLevel Devil's Key or Eyes [%d]", eventitemcount);

  00074	8b 55 ec	 mov	 edx, DWORD PTR _eventitemcount$156193[ebp]
  00077	52		 push	 edx
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@DMIHKADD@?$FLDevilSquare?$FN?5DiffLevel?5Devil?8s?5@
  0007d	53		 push	 ebx
  0007e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00083	83 c4 18	 add	 esp, 24			; 00000018H

; 1732 : 				lpObj->ChaosLock = FALSE;
; 1733 : 
; 1734 : 				return;

  00086	e9 d3 00 00 00	 jmp	 $LN1@DevilSquar@2
$LN6@DevilSquar@2:

; 1735 : 			}
; 1736 : 			
; 1737 : 			if ( Ret == 2 )

  0008b	83 f8 02	 cmp	 eax, 2
  0008e	75 2a		 jne	 SHORT $LN5@DevilSquar@2

; 1738 : 			{
; 1739 : 				pMsg.Result = CB_INCORRECT_MIX_ITEMS;
; 1740 : 				DataSend(aIndex, (BYTE*)&pMsg, pMsg.h.size);

  00090	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$156189[ebp+1]
  00094	50		 push	 eax
  00095	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$156189[ebp]
  00098	51		 push	 ecx
  00099	57		 push	 edi
  0009a	c6 45 f3 07	 mov	 BYTE PTR _pMsg$156189[ebp+3], 7
  0009e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1741 : 				LogAdd(LOG_BLACK, "[DevilSquare] Not Found Chaos Gem [%d]", eventitemcount);

  000a3	8b 55 ec	 mov	 edx, DWORD PTR _eventitemcount$156193[ebp]
  000a6	52		 push	 edx
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@NMBMOEEC@?$FLDevilSquare?$FN?5Not?5Found?5Chaos?5Ge@
  000ac	53		 push	 ebx
  000ad	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000b2	83 c4 18	 add	 esp, 24			; 00000018H

; 1742 : 				lpObj->ChaosLock = FALSE;
; 1743 : 				
; 1744 : 				return;

  000b5	e9 a4 00 00 00	 jmp	 $LN1@DevilSquar@2
$LN5@DevilSquar@2:

; 1745 : 			}
; 1746 : 
; 1747 : 			if ( Ret == 4 )

  000ba	83 f8 04	 cmp	 eax, 4
  000bd	75 27		 jne	 SHORT $LN4@DevilSquar@2

; 1748 : 			{
; 1749 : 				pMsg.Result = 0xF0;
; 1750 : 				DataSend(aIndex, (BYTE*)&pMsg, pMsg.h.size);

  000bf	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$156189[ebp+1]
  000c3	50		 push	 eax
  000c4	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$156189[ebp]
  000c7	51		 push	 ecx
  000c8	57		 push	 edi
  000c9	c6 45 f3 f0	 mov	 BYTE PTR _pMsg$156189[ebp+3], 240 ; 000000f0H
  000cd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1751 : 				LogAdd(LOG_BLACK, "[DevilSquare] Charm Of Luck Over 10% [%d]", eventitemcount);

  000d2	8b 55 ec	 mov	 edx, DWORD PTR _eventitemcount$156193[ebp]
  000d5	52		 push	 edx
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JNMMBAIA@?$FLDevilSquare?$FN?5Charm?5Of?5Luck?5Over@
  000db	53		 push	 ebx
  000dc	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000e1	83 c4 18	 add	 esp, 24			; 00000018H

; 1752 : 				lpObj->ChaosLock = FALSE;
; 1753 : 				
; 1754 : 				return;

  000e4	eb 78		 jmp	 SHORT $LN1@DevilSquar@2
$LN4@DevilSquar@2:

; 1755 : 			}
; 1756 : 
; 1757 : 			
; 1758 : 			if ( eventitemcount > 2 )

  000e6	83 7d ec 02	 cmp	 DWORD PTR _eventitemcount$156193[ebp], 2
  000ea	7e 27		 jle	 SHORT $LN3@DevilSquar@2

; 1759 : 			{
; 1760 : 				pMsg.Result = CB_TOO_MANY_ITEMS;
; 1761 : 				DataSend(aIndex, (BYTE*)&pMsg, pMsg.h.size);

  000ec	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$156189[ebp+1]
  000f0	50		 push	 eax
  000f1	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$156189[ebp]
  000f4	51		 push	 ecx
  000f5	57		 push	 edi
  000f6	c6 45 f3 03	 mov	 BYTE PTR _pMsg$156189[ebp+3], 3
  000fa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1762 : 				LogAdd(LOG_BLACK, "[DevilSquare] Too many Devil's Key or Eyes [%d]", eventitemcount);

  000ff	8b 55 ec	 mov	 edx, DWORD PTR _eventitemcount$156193[ebp]
  00102	52		 push	 edx
  00103	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@FMJGNMLI@?$FLDevilSquare?$FN?5Too?5many?5Devil?8s?5K@
  00108	53		 push	 ebx
  00109	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0010e	83 c4 18	 add	 esp, 24			; 00000018H

; 1763 : 				lpObj->ChaosLock = FALSE;
; 1764 : 
; 1765 : 				return;

  00111	eb 4b		 jmp	 SHORT $LN1@DevilSquar@2
$LN3@DevilSquar@2:

; 1766 : 			}
; 1767 : 
; 1768 : 			if ( lpObj->Level < 10 )

  00113	66 83 be 9c 00
	00 00 0a	 cmp	 WORD PTR [esi+156], 10	; 0000000aH
  0011b	7d 06		 jge	 SHORT $LN2@DevilSquar@2

; 1769 : 			{
; 1770 : 				pMsg.Result = CB_LOW_LEVEL_USER;

  0011d	c6 45 f3 04	 mov	 BYTE PTR _pMsg$156189[ebp+3], 4

; 1771 : 				DataSend(aIndex, (BYTE*)&pMsg, pMsg.h.size);
; 1772 : 				lpObj->ChaosLock = FALSE;
; 1773 : 
; 1774 : 				return;

  00121	eb 29		 jmp	 SHORT $LN11@DevilSquar@2
$LN2@DevilSquar@2:

; 1775 : 			}
; 1776 : 
; 1777 : 			::DevilSquareEventChaosMix(lpObj, Ret, itemlevel);

  00123	8b 55 e8	 mov	 edx, DWORD PTR _itemlevel$156194[ebp]
  00126	52		 push	 edx
  00127	50		 push	 eax
  00128	56		 push	 esi
  00129	e8 00 00 00 00	 call	 ?DevilSquareEventChaosMix@@YAHPAUOBJECTSTRUCT@@HH@Z ; DevilSquareEventChaosMix
  0012e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00131	5f		 pop	 edi
  00132	5e		 pop	 esi
  00133	5b		 pop	 ebx

; 1785 : 			lpObj->ChaosLock = FALSE;
; 1786 : 
; 1787 : 			return;
; 1788 : 		}
; 1789 : 	}
; 1790 : 
; 1791 : 	lpObj->ChaosLock = FALSE;
; 1792 : }

  00134	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00137	33 cd		 xor	 ecx, ebp
  00139	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
$LN7@DevilSquar@2:

; 1778 : 			return;
; 1779 : 		}
; 1780 : 		
; 1781 : 		if ( eventitemcount > 1 )

  00142	83 7d ec 01	 cmp	 DWORD PTR _eventitemcount$156193[ebp], 1
  00146	7e 16		 jle	 SHORT $LN1@DevilSquar@2

; 1782 : 		{
; 1783 : 			pMsg.Result = CB_LACKING_MIX_ITEMS;

  00148	c6 45 f3 06	 mov	 BYTE PTR _pMsg$156189[ebp+3], 6
$LN11@DevilSquar@2:

; 1784 : 			DataSend(aIndex, (BYTE*)&pMsg, pMsg.h.size);

  0014c	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$156189[ebp+1]
  00150	50		 push	 eax
  00151	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$156189[ebp]
  00154	51		 push	 ecx
  00155	57		 push	 edi
  00156	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@DevilSquar@2:

; 1785 : 			lpObj->ChaosLock = FALSE;
; 1786 : 
; 1787 : 			return;
; 1788 : 		}
; 1789 : 	}
; 1790 : 
; 1791 : 	lpObj->ChaosLock = FALSE;
; 1792 : }

  0015e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00161	5f		 pop	 edi
  00162	89 9e ec 0c 00
	00		 mov	 DWORD PTR [esi+3308], ebx
  00168	5e		 pop	 esi
  00169	33 cd		 xor	 ecx, ebp
  0016b	5b		 pop	 ebx
  0016c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00171	8b e5		 mov	 esp, ebp
  00173	5d		 pop	 ebp
  00174	c3		 ret	 0
?DevilSquareItemChaosMix@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; DevilSquareItemChaosMix
_TEXT	ENDS
PUBLIC	??_C@_0DC@ILPOEBCF@?$FLSetItemMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail@ ; `string'
PUBLIC	??_C@_0EC@BFAACIGE@?$FLSetItemMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Succ@ ; `string'
PUBLIC	??_C@_0BN@JHMGADIL@?$FLSetItemMix?$FN?5Chaos?5Mix?5Start?$AA@ ; `string'
PUBLIC	??_C@_0L@DBFFCLIB@SetItemMix?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?SetItemChaosMix@@YAXPAUOBJECTSTRUCT@@@Z	; SetItemChaosMix
EXTRN	?GetSetOptionName@CSetItemOption@@QAEPADHH@Z:PROC ; CSetItemOption::GetSetOptionName
EXTRN	?MakeSetOption@CSetItemOption@@QAEHHH@Z:PROC	; CSetItemOption::MakeSetOption
EXTRN	?CheckMixContition@CSetItemOption@@QAEHHH@Z:PROC ; CSetItemOption::CheckMixContition
EXTRN	?IsSetItem@CSetItemOption@@QAEHH@Z:PROC		; CSetItemOption::IsSetItem
EXTRN	?gSetItemOption@@3VCSetItemOption@@A:BYTE	; gSetItemOption
;	COMDAT ??_C@_0DC@ILPOEBCF@?$FLSetItemMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail@
CONST	SEGMENT
??_C@_0DC@ILPOEBCF@?$FLSetItemMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail@ DB '['
	DB	'SetItemMix] [%s][%s] CBMix Fail %d Money : %d-%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@BFAACIGE@?$FLSetItemMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Succ@
CONST	SEGMENT
??_C@_0EC@BFAACIGE@?$FLSetItemMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Succ@ DB '['
	DB	'SetItemMix] [%s][%s] CBMix Success %d Money : %d-%d (SetName:'
	DB	'%s)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JHMGADIL@?$FLSetItemMix?$FN?5Chaos?5Mix?5Start?$AA@
CONST	SEGMENT
??_C@_0BN@JHMGADIL@?$FLSetItemMix?$FN?5Chaos?5Mix?5Start?$AA@ DB '[SetIte'
	DB	'mMix] Chaos Mix Start', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DBFFCLIB@SetItemMix?$AA@
CONST	SEGMENT
??_C@_0L@DBFFCLIB@SetItemMix?$AA@ DB 'SetItemMix', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetItemChaosMix@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_BlessGemCount$ = -220					; size = 4
_ChoasGemCount$ = -216					; size = 4
_SoulGemCount$ = -212					; size = 4
_n$156257 = -208					; size = 4
tv665 = -204						; size = 4
_MetalOfAncientCount$ = -204				; size = 4
_MixItemCount$ = -200					; size = 4
_setoption$ = -196					; size = 4
_iMetalOfAncientItemLevel$ = -196			; size = 4
tv756 = -192						; size = 4
_Dur$156299 = -192					; size = 4
_MixSetItemIndex$ = -192				; size = 4
_iChaosMoney$ = -188					; size = 4
_Item$156298 = -184					; size = 168
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?SetItemChaosMix@@YAXPAUOBJECTSTRUCT@@@Z PROC		; SetItemChaosMix, COMDAT

; 1880 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi

; 1881 : 	lpObj->ChaosLock = TRUE;
; 1882 : 
; 1883 : 	int ChoasGemCount = 0;

  00019	33 f6		 xor	 esi, esi

; 1884 : 	int BlessGemCount = 0;
; 1885 : 	int SoulGemCount = 0;
; 1886 : 	int MetalOfAncientCount = 0;
; 1887 : 	int MixItemCount = 0;
; 1888 : 	int MixSetItemIndex = 0;
; 1889 : 	int iMixItemChaosMoney = 0;
; 1890 : 	int iChaosMoney = 0;
; 1891 : 	int iMetalOfAncientItemLevel = -1;
; 1892 : 
; 1893 : 	PMSG_CHAOSMIXRESULT pMsg;
; 1894 : 
; 1895 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  0001b	6a 0b		 push	 11			; 0000000bH
  0001d	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00020	68 86 00 00 00	 push	 134			; 00000086H
  00025	50		 push	 eax
  00026	c7 83 ec 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [ebx+3308], 1
  00030	89 b5 28 ff ff
	ff		 mov	 DWORD PTR _ChoasGemCount$[ebp], esi
  00036	89 b5 24 ff ff
	ff		 mov	 DWORD PTR _BlessGemCount$[ebp], esi
  0003c	89 b5 2c ff ff
	ff		 mov	 DWORD PTR _SoulGemCount$[ebp], esi
  00042	89 b5 34 ff ff
	ff		 mov	 DWORD PTR _MetalOfAncientCount$[ebp], esi
  00048	89 b5 38 ff ff
	ff		 mov	 DWORD PTR _MixItemCount$[ebp], esi
  0004e	89 b5 40 ff ff
	ff		 mov	 DWORD PTR _MixSetItemIndex$[ebp], esi
  00054	33 ff		 xor	 edi, edi
  00056	89 b5 44 ff ff
	ff		 mov	 DWORD PTR _iChaosMoney$[ebp], esi
  0005c	c7 85 3c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _iMetalOfAncientItemLevel$[ebp], -1
  00066	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1896 : 	pMsg.Result = CB_ERROR;

  0006e	c6 45 f3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 1897 : 
; 1898 : 
; 1899 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00072	89 b5 30 ff ff
	ff		 mov	 DWORD PTR _n$156257[ebp], esi
  00078	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL32@SetItemCha:

; 1900 : 	{
; 1901 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00080	8b 8b dc 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3292]
  00086	03 ce		 add	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0008d	83 f8 01	 cmp	 eax, 1
  00090	0f 85 7d 01 00
	00		 jne	 $LN31@SetItemCha

; 1902 : 		{
; 1903 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,13) )

  00096	8b 8b dc 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3292]
  0009c	0f b7 44 31 06	 movzx	 eax, WORD PTR [ecx+esi+6]
  000a1	03 ce		 add	 ecx, esi
  000a3	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  000a8	66 3b c2	 cmp	 ax, dx
  000ab	75 1b		 jne	 SHORT $LN37@SetItemCha

; 1904 : 			{
; 1905 : 				BlessGemCount++;

  000ad	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _BlessGemCount$[ebp]
  000b3	42		 inc	 edx
  000b4	89 95 24 ff ff
	ff		 mov	 DWORD PTR _BlessGemCount$[ebp], edx

; 1906 : 
; 1907 : 				if ( BlessGemCount > 3 )

  000ba	83 fa 03	 cmp	 edx, 3
  000bd	7e 09		 jle	 SHORT $LN37@SetItemCha

; 1908 : 				{
; 1909 : 					iChaosMoney += lpObj->pChaosBox[n].m_BuyMoney;

  000bf	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  000c2	01 95 44 ff ff
	ff		 add	 DWORD PTR _iChaosMoney$[ebp], edx
$LN37@SetItemCha:

; 1910 : 				}
; 1911 : 			}
; 1912 : 
; 1913 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,14) )

  000c8	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  000cd	66 3b c2	 cmp	 ax, dx
  000d0	75 1b		 jne	 SHORT $LN25@SetItemCha

; 1914 : 			{
; 1915 : 				SoulGemCount++;

  000d2	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _SoulGemCount$[ebp]
  000d8	42		 inc	 edx
  000d9	89 95 2c ff ff
	ff		 mov	 DWORD PTR _SoulGemCount$[ebp], edx

; 1916 : 
; 1917 : 				if ( SoulGemCount > 3 )

  000df	83 fa 03	 cmp	 edx, 3
  000e2	7e 09		 jle	 SHORT $LN25@SetItemCha

; 1918 : 				{
; 1919 : 					iChaosMoney += lpObj->pChaosBox[n].m_BuyMoney;

  000e4	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  000e7	01 95 44 ff ff
	ff		 add	 DWORD PTR _iChaosMoney$[ebp], edx
$LN25@SetItemCha:

; 1920 : 				}
; 1921 : 			}
; 1922 : 
; 1923 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,16) )

  000ed	ba 10 1c 00 00	 mov	 edx, 7184		; 00001c10H
  000f2	66 3b c2	 cmp	 ax, dx
  000f5	75 0e		 jne	 SHORT $LN24@SetItemCha

; 1924 : 			{
; 1925 : 				iChaosMoney += lpObj->pChaosBox[n].m_BuyMoney;

  000f7	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  000fa	01 85 44 ff ff
	ff		 add	 DWORD PTR _iChaosMoney$[ebp], eax
  00100	e9 0e 01 00 00	 jmp	 $LN31@SetItemCha
$LN24@SetItemCha:

; 1926 : 			}
; 1927 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,15) )

  00105	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  0010a	66 3b c2	 cmp	 ax, dx
  0010d	75 0b		 jne	 SHORT $LN22@SetItemCha

; 1928 : 			{
; 1929 : 				ChoasGemCount++;

  0010f	ff 85 28 ff ff
	ff		 inc	 DWORD PTR _ChoasGemCount$[ebp]
  00115	e9 f9 00 00 00	 jmp	 $LN31@SetItemCha
$LN22@SetItemCha:

; 1930 : 			}
; 1931 : 			else if ( lpObj->pChaosBox[n].m_Level >= 6 && lpObj->pChaosBox[n].IsExtItem() != FALSE)

  0011a	66 83 79 08 06	 cmp	 WORD PTR [ecx+8], 6
  0011f	7c 48		 jl	 SHORT $LN20@SetItemCha
  00121	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  00126	85 c0		 test	 eax, eax
  00128	74 3f		 je	 SHORT $LN20@SetItemCha

; 1932 : 			{
; 1933 : 				if ( gSetItemOption.IsSetItem(lpObj->pChaosBox[n].m_Type) != FALSE )

  0012a	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  00130	0f bf 4c 06 06	 movsx	 ecx, WORD PTR [esi+eax+6]
  00135	51		 push	 ecx
  00136	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  0013b	e8 00 00 00 00	 call	 ?IsSetItem@CSetItemOption@@QAEHH@Z ; CSetItemOption::IsSetItem
  00140	85 c0		 test	 eax, eax
  00142	0f 84 cb 00 00
	00		 je	 $LN31@SetItemCha

; 1934 : 				{
; 1935 : 					MixItemCount++;
; 1936 : 					MixSetItemIndex = n;

  00148	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _n$156257[ebp]

; 1937 : 					iMixItemChaosMoney += lpObj->pChaosBox[n].m_BuyMoney;

  0014e	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  00154	ff 85 38 ff ff
	ff		 inc	 DWORD PTR _MixItemCount$[ebp]
  0015a	03 7c 06 64	 add	 edi, DWORD PTR [esi+eax+100]
  0015e	89 95 40 ff ff
	ff		 mov	 DWORD PTR _MixSetItemIndex$[ebp], edx

; 1938 : 				}
; 1939 : 			}

  00164	e9 aa 00 00 00	 jmp	 $LN31@SetItemCha
$LN20@SetItemCha:

; 1940 : 			else if ( ((lpObj->pChaosBox[n].m_Type >= ITEMGET(13,8) && lpObj->pChaosBox[n].m_Type < ITEMGET(13,14)) || (lpObj->pChaosBox[n].m_Type >= ITEMGET(13,20) && lpObj->pChaosBox[n].m_Type < ITEMGET(13,28) ) ) && ( lpObj->pChaosBox[n].m_Option3 >= 2  && lpObj->pChaosBox[n].m_Level >= 3 ) )	

  00169	8b 8b dc 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3292]
  0016f	0f b7 44 31 06	 movzx	 eax, WORD PTR [ecx+esi+6]
  00174	03 ce		 add	 ecx, esi
  00176	ba 08 1a 00 00	 mov	 edx, 6664		; 00001a08H
  0017b	66 3b c2	 cmp	 ax, dx
  0017e	7c 0a		 jl	 SHORT $LN15@SetItemCha
  00180	ba 0e 1a 00 00	 mov	 edx, 6670		; 00001a0eH
  00185	66 3b c2	 cmp	 ax, dx
  00188	7c 14		 jl	 SHORT $LN16@SetItemCha
$LN15@SetItemCha:
  0018a	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  0018f	66 3b c2	 cmp	 ax, dx
  00192	7c 45		 jl	 SHORT $LN17@SetItemCha
  00194	ba 1c 1a 00 00	 mov	 edx, 6684		; 00001a1cH
  00199	66 3b c2	 cmp	 ax, dx
  0019c	7d 3b		 jge	 SHORT $LN17@SetItemCha
$LN16@SetItemCha:
  0019e	80 79 7a 02	 cmp	 BYTE PTR [ecx+122], 2
  001a2	72 35		 jb	 SHORT $LN17@SetItemCha
  001a4	66 83 79 08 03	 cmp	 WORD PTR [ecx+8], 3
  001a9	7c 2e		 jl	 SHORT $LN17@SetItemCha

; 1941 : 			{
; 1942 : 				if ( gSetItemOption.IsSetItem(lpObj->pChaosBox[n].m_Type ) != FALSE )

  001ab	98		 cwde
  001ac	50		 push	 eax
  001ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  001b2	e8 00 00 00 00	 call	 ?IsSetItem@CSetItemOption@@QAEHH@Z ; CSetItemOption::IsSetItem
  001b7	85 c0		 test	 eax, eax
  001b9	74 58		 je	 SHORT $LN31@SetItemCha

; 1943 : 				{
; 1944 : 					MixItemCount++;
; 1945 : 					MixSetItemIndex = n;

  001bb	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _n$156257[ebp]

; 1946 : 					iMixItemChaosMoney += lpObj->pChaosBox[n].m_BuyMoney;

  001c1	8b 93 dc 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3292]
  001c7	ff 85 38 ff ff
	ff		 inc	 DWORD PTR _MixItemCount$[ebp]
  001cd	03 7c 16 64	 add	 edi, DWORD PTR [esi+edx+100]
  001d1	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _MixSetItemIndex$[ebp], ecx

; 1947 : 				}
; 1948 : 			}

  001d7	eb 3a		 jmp	 SHORT $LN31@SetItemCha
$LN17@SetItemCha:

; 1949 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,27) ) // Ancien Metal, Apply Deathway Fix here

  001d9	ba 1b 1c 00 00	 mov	 edx, 7195		; 00001c1bH
  001de	66 3b c2	 cmp	 ax, dx
  001e1	75 12		 jne	 SHORT $LN12@SetItemCha

; 1950 : 			{
; 1951 : 				MetalOfAncientCount++;
; 1952 : 				iMetalOfAncientItemLevel = lpObj->pChaosBox[n].m_Level;

  001e3	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  001e7	ff 85 34 ff ff
	ff		 inc	 DWORD PTR _MetalOfAncientCount$[ebp]
  001ed	89 85 3c ff ff
	ff		 mov	 DWORD PTR _iMetalOfAncientItemLevel$[ebp], eax

; 1953 : 			}
; 1954 : 			else

  001f3	eb 1e		 jmp	 SHORT $LN31@SetItemCha
$LN12@SetItemCha:

; 1955 : 			{
; 1956 : 				DataSend(lpObj->m_Index, (BYTE*)&pMsg, pMsg.h.size);

  001f5	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  001f9	8b 03		 mov	 eax, DWORD PTR [ebx]
  001fb	51		 push	 ecx
  001fc	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  001ff	52		 push	 edx
  00200	50		 push	 eax
  00201	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00206	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1957 : 				lpObj->ChaosLock = FALSE;

  00209	c7 83 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+3308], 0
$LN31@SetItemCha:

; 1897 : 
; 1898 : 
; 1899 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00213	b9 01 00 00 00	 mov	 ecx, 1
  00218	01 8d 30 ff ff
	ff		 add	 DWORD PTR _n$156257[ebp], ecx
  0021e	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00224	81 fe 00 15 00
	00		 cmp	 esi, 5376		; 00001500H
  0022a	0f 8c 50 fe ff
	ff		 jl	 $LL32@SetItemCha

; 1958 : 			}
; 1959 : 		}
; 1960 : 	}
; 1961 : 
; 1962 : 
; 1963 : 	if ( ChoasGemCount < 1 || BlessGemCount < 3 || SoulGemCount < 3 || MetalOfAncientCount != 1 || MixItemCount != 1 )

  00230	39 8d 28 ff ff
	ff		 cmp	 DWORD PTR _ChoasGemCount$[ebp], ecx
  00236	0f 8c 66 03 00
	00		 jl	 $LN9@SetItemCha
  0023c	b8 03 00 00 00	 mov	 eax, 3
  00241	39 85 24 ff ff
	ff		 cmp	 DWORD PTR _BlessGemCount$[ebp], eax
  00247	0f 8c 55 03 00
	00		 jl	 $LN9@SetItemCha
  0024d	39 85 2c ff ff
	ff		 cmp	 DWORD PTR _SoulGemCount$[ebp], eax
  00253	0f 8c 49 03 00
	00		 jl	 $LN9@SetItemCha
  00259	39 8d 34 ff ff
	ff		 cmp	 DWORD PTR _MetalOfAncientCount$[ebp], ecx
  0025f	0f 85 3d 03 00
	00		 jne	 $LN9@SetItemCha
  00265	39 8d 38 ff ff
	ff		 cmp	 DWORD PTR _MixItemCount$[ebp], ecx
  0026b	0f 85 31 03 00
	00		 jne	 $LN9@SetItemCha

; 1966 : 		lpObj->ChaosLock = FALSE;
; 1967 : 		return;
; 1968 : 	}
; 1969 : 
; 1970 : 	LogChaosItem(lpObj, "SetItemMix");

  00271	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DBFFCLIB@SetItemMix?$AA@
  00276	53		 push	 ebx
  00277	e8 00 00 00 00	 call	 ?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z ; LogChaosItem

; 1971 : 	LogAdd(LOG_BLACK, "[SetItemMix] Chaos Mix Start");

  0027c	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JHMGADIL@?$FLSetItemMix?$FN?5Chaos?5Mix?5Start?$AA@
  00281	6a 00		 push	 0
  00283	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 1972 : 
; 1973 : 	if ( gSetItemOption.CheckMixContition(lpObj->pChaosBox[MixSetItemIndex].m_Type, iMetalOfAncientItemLevel ) == FALSE )

  00288	8b b5 40 ff ff
	ff		 mov	 esi, DWORD PTR _MixSetItemIndex$[ebp]
  0028e	8b 93 dc 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3292]
  00294	69 f6 a8 00 00
	00		 imul	 esi, 168		; 000000a8H
  0029a	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _iMetalOfAncientItemLevel$[ebp]
  002a0	0f bf 44 32 06	 movsx	 eax, WORD PTR [edx+esi+6]
  002a5	83 c4 10	 add	 esp, 16			; 00000010H
  002a8	51		 push	 ecx
  002a9	50		 push	 eax
  002aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  002af	89 b5 34 ff ff
	ff		 mov	 DWORD PTR tv665[ebp], esi
  002b5	e8 00 00 00 00	 call	 ?CheckMixContition@CSetItemOption@@QAEHHH@Z ; CSetItemOption::CheckMixContition
  002ba	85 c0		 test	 eax, eax

; 1974 : 	{
; 1975 : 		DataSend(lpObj->m_Index, (BYTE*)&pMsg, pMsg.h.size);
; 1976 : 		lpObj->ChaosLock = FALSE;
; 1977 : 
; 1978 : 		return;

  002bc	74 45		 je	 SHORT $LN42@SetItemCha

; 1979 : 	}
; 1980 : 
; 1981 : 	lpObj->ChaosSuccessRate = iMixItemChaosMoney / 40000;
; 1982 : 	lpObj->ChaosSuccessRate = iChaosMoney / 400000;

  002be	b8 89 b5 f8 14	 mov	 eax, 351843721		; 14f8b589H
  002c3	f7 ad 44 ff ff
	ff		 imul	 DWORD PTR _iChaosMoney$[ebp]
  002c9	c1 fa 0f	 sar	 edx, 15			; 0000000fH
  002cc	8b c2		 mov	 eax, edx
  002ce	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002d1	03 c2		 add	 eax, edx
  002d3	89 83 e8 0c 00
	00		 mov	 DWORD PTR [ebx+3304], eax

; 1983 : 
; 1984 : 	if ( lpObj->ChaosSuccessRate > 80 )

  002d9	83 f8 50	 cmp	 eax, 80			; 00000050H
  002dc	7e 0a		 jle	 SHORT $LN7@SetItemCha

; 1985 : 	{
; 1986 : 		lpObj->ChaosSuccessRate = 80;

  002de	c7 83 e8 0c 00
	00 50 00 00 00	 mov	 DWORD PTR [ebx+3304], 80 ; 00000050H
$LN7@SetItemCha:

; 1987 : 	}
; 1988 : 
; 1989 : 	int nChaosNeedMoney = (lpObj->ChaosSuccessRate - 50 ) * 1000000;

  002e8	8b bb e8 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3304]
  002ee	83 ef 32	 sub	 edi, 50			; 00000032H
  002f1	69 ff 40 42 0f
	00		 imul	 edi, 1000000		; 000f4240H

; 1990 : 
; 1991 : 	if ( lpObj->Money < nChaosNeedMoney )

  002f7	39 bb b0 00 00
	00		 cmp	 DWORD PTR [ebx+176], edi
  002fd	7d 15		 jge	 SHORT $LN6@SetItemCha

; 1992 : 	{
; 1993 : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;

  002ff	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
$LN42@SetItemCha:

; 1994 : 		DataSend(lpObj->m_Index, (BYTE*)&pMsg, pMsg.h.size);

  00303	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00307	8b 03		 mov	 eax, DWORD PTR [ebx]
  00309	51		 push	 ecx
  0030a	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0030d	52		 push	 edx
  0030e	50		 push	 eax

; 1995 : 		lpObj->ChaosLock = FALSE;
; 1996 : 
; 1997 : 		return;

  0030f	e9 9a 02 00 00	 jmp	 $LN40@SetItemCha
$LN6@SetItemCha:

; 1998 : 	}
; 1999 : 
; 2000 : 	int setoption = gSetItemOption.MakeSetOption(lpObj->pChaosBox[MixSetItemIndex].m_Type, iMetalOfAncientItemLevel);

  00314	8b 93 dc 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3292]
  0031a	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _iMetalOfAncientItemLevel$[ebp]
  00320	0f bf 44 32 06	 movsx	 eax, WORD PTR [edx+esi+6]
  00325	51		 push	 ecx
  00326	50		 push	 eax
  00327	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  0032c	e8 00 00 00 00	 call	 ?MakeSetOption@CSetItemOption@@QAEHHH@Z ; CSetItemOption::MakeSetOption
  00331	89 85 3c ff ff
	ff		 mov	 DWORD PTR _setoption$[ebp], eax

; 2001 : 
; 2002 : 	if ( setoption == 0 )

  00337	85 c0		 test	 eax, eax
  00339	75 14		 jne	 SHORT $LN5@SetItemCha

; 2003 : 	{
; 2004 : 		pMsg.Result = CB_ERROR;
; 2005 : 		DataSend(lpObj->m_Index, (BYTE*)&pMsg, pMsg.h.size);

  0033b	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0033f	51		 push	 ecx
  00340	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00343	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00346	8b 03		 mov	 eax, DWORD PTR [ebx]
  00348	52		 push	 edx
  00349	50		 push	 eax

; 2006 : 		lpObj->ChaosLock = FALSE;
; 2007 : 
; 2008 : 		return;

  0034a	e9 5f 02 00 00	 jmp	 $LN40@SetItemCha
$LN5@SetItemCha:

; 2009 : 	}
; 2010 : 
; 2011 : 	lpObj->Money -= nChaosNeedMoney;

  0034f	29 bb b0 00 00
	00		 sub	 DWORD PTR [ebx+176], edi
  00355	8b 83 b0 00 00
	00		 mov	 eax, DWORD PTR [ebx+176]

; 2012 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  0035b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0035d	50		 push	 eax
  0035e	51		 push	 ecx
  0035f	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00364	83 c4 08	 add	 esp, 8

; 2013 : 
; 2014 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  00367	e8 00 00 00 00	 call	 _rand
  0036c	99		 cdq
  0036d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00372	f7 f9		 idiv	 ecx
  00374	3b 93 e8 0c 00
	00		 cmp	 edx, DWORD PTR [ebx+3304]
  0037a	0f 8d db 01 00
	00		 jge	 $LN4@SetItemCha

; 2015 : 	{
; 2016 : 		lpObj->pChaosBox[MixSetItemIndex].m_SetOption = setoption;

  00380	8b 93 dc 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3292]
  00386	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR _setoption$[ebp]
  0038c	88 84 32 92 00
	00 00		 mov	 BYTE PTR [edx+esi+146], al

; 2017 : 
; 2018 : 		if ( (rand()%100 ) < 80 )

  00393	e8 00 00 00 00	 call	 _rand
  00398	99		 cdq
  00399	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0039e	f7 f9		 idiv	 ecx
  003a0	83 fa 50	 cmp	 edx, 80			; 00000050H
  003a3	7d 17		 jge	 SHORT $LN3@SetItemCha

; 2019 : 		{
; 2020 : 			lpObj->pChaosBox[MixSetItemIndex].m_SetOption |= 4;

  003a5	8b 93 dc 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3292]
  003ab	80 8c 32 92 00
	00 00 04	 or	 BYTE PTR [edx+esi+146], 4
  003b3	8d 84 32 92 00
	00 00		 lea	 eax, DWORD PTR [edx+esi+146]

; 2021 : 		}
; 2022 : 		else

  003ba	eb 15		 jmp	 SHORT $LN2@SetItemCha
$LN3@SetItemCha:

; 2023 : 		{
; 2024 : 			lpObj->pChaosBox[MixSetItemIndex].m_SetOption |= 8;

  003bc	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  003c2	80 8c 30 92 00
	00 00 08	 or	 BYTE PTR [eax+esi+146], 8
  003ca	8d 84 30 92 00
	00 00		 lea	 eax, DWORD PTR [eax+esi+146]
$LN2@SetItemCha:

; 2025 : 		}
; 2026 : 
; 2027 : 		pMsg.Result = CB_SUCCESS;
; 2028 : 		CItem Item;

  003d1	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _Item$156298[ebp]
  003d7	c6 45 f3 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1
  003db	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 2029 : 
; 2030 : 		float Dur = ItemGetDurability(lpObj->pChaosBox[MixSetItemIndex].m_Type, lpObj->pChaosBox[MixSetItemIndex].m_Level,
; 2031 : 			lpObj->pChaosBox[MixSetItemIndex].IsExtItem(), lpObj->pChaosBox[MixSetItemIndex].IsSetItem());

  003e0	8b 8b dc 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3292]
  003e6	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]
  003e9	8d 0c 0e	 lea	 ecx, DWORD PTR [esi+ecx]
  003ec	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  003f1	8b 8b dc 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3292]
  003f7	50		 push	 eax
  003f8	03 ce		 add	 ecx, esi
  003fa	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  003ff	0f bf 57 08	 movsx	 edx, WORD PTR [edi+8]
  00403	50		 push	 eax
  00404	0f bf 47 06	 movsx	 eax, WORD PTR [edi+6]
  00408	52		 push	 edx
  00409	50		 push	 eax
  0040a	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  0040f	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv756[ebp], eax

; 2032 : 
; 2033 : 		Item.m_Level = lpObj->pChaosBox[MixSetItemIndex].m_Level;

  00415	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  0041b	66 8b 54 30 08	 mov	 dx, WORD PTR [eax+esi+8]
  00420	db 85 40 ff ff
	ff		 fild	 DWORD PTR tv756[ebp]
  00426	03 c6		 add	 eax, esi
  00428	66 89 95 50 ff
	ff ff		 mov	 WORD PTR _Item$156298[ebp+8], dx
  0042f	d9 9d 40 ff ff
	ff		 fstp	 DWORD PTR _Dur$156299[ebp]
  00435	83 c4 10	 add	 esp, 16			; 00000010H

; 2034 : 		Item.m_Durability = Dur * lpObj->pChaosBox[MixSetItemIndex].m_Durability / lpObj->pChaosBox[MixSetItemIndex].m_BaseDurability;

  00438	d9 40 24	 fld	 DWORD PTR [eax+36]

; 2035 : 		
; 2036 : 		Item.Convert(lpObj->pChaosBox[MixSetItemIndex].m_Type, lpObj->pChaosBox[MixSetItemIndex].m_Option1, lpObj->pChaosBox[MixSetItemIndex].m_Option2,
; 2037 : 			lpObj->pChaosBox[MixSetItemIndex].m_Option3, lpObj->pChaosBox[MixSetItemIndex].m_NewOption, 
; 2038 : 			lpObj->pChaosBox[MixSetItemIndex].m_SetOption, 0, CURRENT_DB_VERSION);

  0043b	6a 03		 push	 3
  0043d	d8 8d 40 ff ff
	ff		 fmul	 DWORD PTR _Dur$156299[ebp]
  00443	6a 00		 push	 0
  00445	d8 70 2c	 fdiv	 DWORD PTR [eax+44]
  00448	d9 9d 6c ff ff
	ff		 fstp	 DWORD PTR _Item$156298[ebp+36]
  0044e	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00455	0f b6 50 7b	 movzx	 edx, BYTE PTR [eax+123]
  00459	51		 push	 ecx
  0045a	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  0045e	52		 push	 edx
  0045f	0f b6 50 79	 movzx	 edx, BYTE PTR [eax+121]
  00463	51		 push	 ecx
  00464	0f b6 48 78	 movzx	 ecx, BYTE PTR [eax+120]
  00468	52		 push	 edx
  00469	0f bf 50 06	 movsx	 edx, WORD PTR [eax+6]
  0046d	51		 push	 ecx
  0046e	52		 push	 edx
  0046f	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _Item$156298[ebp]
  00475	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEE@Z ; CItem::Convert

; 2039 : 
; 2040 : 		Item.m_Number = lpObj->pChaosBox[MixSetItemIndex].m_Number;

  0047a	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  00480	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  00483	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _Item$156298[ebp], ecx

; 2041 : 
; 2042 : 		ItemByteConvert(pMsg.ItemInfo, Item);

  00489	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0048f	8d 55 f4	 lea	 edx, DWORD PTR _pMsg$[ebp+4]
  00492	8b fc		 mov	 edi, esp
  00494	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00499	8d b5 48 ff ff
	ff		 lea	 esi, DWORD PTR _Item$156298[ebp]
  0049f	52		 push	 edx
  004a0	f3 a5		 rep movsd
  004a2	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 2043 : 		ChaosBoxInit(lpObj);

  004a7	53		 push	 ebx
  004a8	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit

; 2044 : 		::gObjChaosBoxInsertItemPos(lpObj->m_Index, Item, 0, -1);

  004ad	8b 03		 mov	 eax, DWORD PTR [ebx]
  004af	81 c4 b0 00 00
	00		 add	 esp, 176		; 000000b0H
  004b5	6a ff		 push	 -1
  004b7	6a 00		 push	 0
  004b9	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  004bf	8b fc		 mov	 edi, esp
  004c1	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  004c6	8d b5 48 ff ff
	ff		 lea	 esi, DWORD PTR _Item$156298[ebp]
  004cc	50		 push	 eax
  004cd	f3 a5		 rep movsd
  004cf	e8 00 00 00 00	 call	 ?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z ; gObjChaosBoxInsertItemPos

; 2045 : 		gObjChaosItemSet(lpObj->m_Index, 0, 1);

  004d4	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  004d6	6a 01		 push	 1
  004d8	6a 00		 push	 0
  004da	51		 push	 ecx
  004db	e8 00 00 00 00	 call	 ?gObjChaosItemSet@@YAXHHE@Z ; gObjChaosItemSet

; 2046 : 
; 2047 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  004e0	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  004e4	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  004e6	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  004ec	52		 push	 edx
  004ed	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  004f0	50		 push	 eax
  004f1	51		 push	 ecx
  004f2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2048 : 
; 2049 : 		LogAdd(LOG_BLACK, "[SetItemMix] [%s][%s] CBMix Success %d Money : %d-%d (SetName:%s)", lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate,
; 2050 : 			lpObj->Money, lpObj->ChaosMoney, gSetItemOption.GetSetOptionName(lpObj->pChaosBox[MixSetItemIndex].m_Type, setoption));

  004f7	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _setoption$[ebp]
  004fd	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  00503	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv665[ebp]
  00509	83 c4 0c	 add	 esp, 12			; 0000000cH
  0050c	52		 push	 edx
  0050d	0f bf 54 08 06	 movsx	 edx, WORD PTR [eax+ecx+6]
  00512	52		 push	 edx
  00513	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  00518	e8 00 00 00 00	 call	 ?GetSetOptionName@CSetItemOption@@QAEPADHH@Z ; CSetItemOption::GetSetOptionName
  0051d	8b 8b b0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+176]
  00523	8b 93 e8 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3304]
  00529	50		 push	 eax
  0052a	8b 83 e4 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3300]
  00530	50		 push	 eax
  00531	51		 push	 ecx
  00532	52		 push	 edx
  00533	8d 43 6f	 lea	 eax, DWORD PTR [ebx+111]
  00536	50		 push	 eax
  00537	83 c3 64	 add	 ebx, 100		; 00000064H
  0053a	53		 push	 ebx
  0053b	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@BFAACIGE@?$FLSetItemMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Succ@
  00540	6a 00		 push	 0
  00542	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00547	83 c4 20	 add	 esp, 32			; 00000020H

; 2064 : 	}
; 2065 : }

  0054a	5f		 pop	 edi
  0054b	5e		 pop	 esi
  0054c	5b		 pop	 ebx
  0054d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00550	33 cd		 xor	 ecx, ebp
  00552	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00557	8b e5		 mov	 esp, ebp
  00559	5d		 pop	 ebp
  0055a	c3		 ret	 0
$LN4@SetItemCha:

; 2051 : 	}
; 2052 : 	else
; 2053 : 	{
; 2054 : 		ChaosBoxInit(lpObj);

  0055b	53		 push	 ebx
  0055c	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit

; 2055 : 		GCUserChaosBoxSend(lpObj, 0);

  00561	6a 00		 push	 0
  00563	53		 push	 ebx
  00564	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 2056 : 
; 2057 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  00569	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0056d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0056f	51		 push	 ecx
  00570	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00573	52		 push	 edx
  00574	50		 push	 eax
  00575	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2058 : 
; 2059 : 		LogAdd(LOG_BLACK, "[SetItemMix] [%s][%s] CBMix Fail %d Money : %d-%d",
; 2060 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money,
; 2061 : 			nChaosNeedMoney);

  0057a	8b 8b b0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+176]
  00580	8b 93 e8 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3304]
  00586	57		 push	 edi
  00587	51		 push	 ecx
  00588	52		 push	 edx
  00589	8d 43 6f	 lea	 eax, DWORD PTR [ebx+111]
  0058c	50		 push	 eax
  0058d	8d 4b 64	 lea	 ecx, DWORD PTR [ebx+100]
  00590	51		 push	 ecx
  00591	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@ILPOEBCF@?$FLSetItemMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail@
  00596	6a 00		 push	 0
  00598	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0059d	83 c4 34	 add	 esp, 52			; 00000034H

; 2062 : 
; 2063 : 		lpObj->ChaosLock = FALSE;

  005a0	eb 14		 jmp	 SHORT $LN41@SetItemCha
$LN9@SetItemCha:

; 1964 : 	{
; 1965 : 		DataSend(lpObj->m_Index, (BYTE*)&pMsg, pMsg.h.size);

  005a2	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  005a6	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  005a8	52		 push	 edx
  005a9	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  005ac	50		 push	 eax
  005ad	51		 push	 ecx
$LN40@SetItemCha:
  005ae	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005b3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN41@SetItemCha:

; 2064 : 	}
; 2065 : }

  005b6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005b9	5f		 pop	 edi
  005ba	5e		 pop	 esi
  005bb	c7 83 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+3308], 0
  005c5	33 cd		 xor	 ecx, ebp
  005c7	5b		 pop	 ebx
  005c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005cd	8b e5		 mov	 esp, ebp
  005cf	5d		 pop	 ebp
  005d0	c3		 ret	 0
?SetItemChaosMix@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; SetItemChaosMix
_TEXT	ENDS
PUBLIC	??_C@_0EE@MAGJAMAN@?$FLDarkHorseMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@ ; `string'
PUBLIC	??_C@_0EH@JGHMMOON@?$FLDarkHorseMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@ ; `string'
PUBLIC	??_C@_0BP@IMILBLLO@?$FLDarkHorseMix?$FN?5Chaos?5Mix?5Start?$AA@ ; `string'
PUBLIC	??_C@_0N@LDINKAHL@DarkHorseMix?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DarkHorseChaosMix@@YAXPAUOBJECTSTRUCT@@@Z	; DarkHorseChaosMix
EXTRN	?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC ; PetItemSerialCreateSend
;	COMDAT ??_C@_0EE@MAGJAMAN@?$FLDarkHorseMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@
CONST	SEGMENT
??_C@_0EE@MAGJAMAN@?$FLDarkHorseMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@ DB '['
	DB	'DarkHorseMix] [%s][%s] CBMix Fail %d Money : %d-%d, CharmRate'
	DB	' : %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@JGHMMOON@?$FLDarkHorseMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@
CONST	SEGMENT
??_C@_0EH@JGHMMOON@?$FLDarkHorseMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@ DB '['
	DB	'DarkHorseMix] [%s][%s] CBMix Success %d Money : %d-%d, CharmR'
	DB	'ate : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IMILBLLO@?$FLDarkHorseMix?$FN?5Chaos?5Mix?5Start?$AA@
CONST	SEGMENT
??_C@_0BP@IMILBLLO@?$FLDarkHorseMix?$FN?5Chaos?5Mix?5Start?$AA@ DB '[Dark'
	DB	'HorseMix] Chaos Mix Start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LDINKAHL@DarkHorseMix?$AA@
CONST	SEGMENT
??_C@_0N@LDINKAHL@DarkHorseMix?$AA@ DB 'DarkHorseMix', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DarkHorseChaosMix@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_ChoasGemCount$ = -44					; size = 4
_BlessGemCount$ = -40					; size = 4
_SoulGemCount$ = -36					; size = 4
_iCharmOfLuckCount$ = -32				; size = 4
_Option1$156358 = -28					; size = 4
_SoulOfDarkHorse$ = -28					; size = 4
_Add$156361 = -24					; size = 4
_CreatureGemCount$ = -24				; size = 4
tv447 = -20						; size = 4
_lc22$156364 = -20					; size = 4
_iInvalidItemCount$ = -20				; size = 4
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?DarkHorseChaosMix@@YAXPAUOBJECTSTRUCT@@@Z PROC		; DarkHorseChaosMix, COMDAT

; 2070 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 2071 : 	lpObj->ChaosLock = TRUE;
; 2072 : 	int ChoasGemCount = 0;

  00016	33 ff		 xor	 edi, edi

; 2073 : 	int BlessGemCount = 0;
; 2074 : 	int SoulGemCount = 0;
; 2075 : 	int CreatureGemCount = 0;
; 2076 : 	int SoulOfDarkHorse = 0;
; 2077 : 	int iChaosMoney = 0;
; 2078 : 
; 2079 : 	PMSG_CHAOSMIXRESULT pMsg;
; 2080 : 
; 2081 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00018	6a 0b		 push	 11			; 0000000bH
  0001a	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001d	68 86 00 00 00	 push	 134			; 00000086H
  00022	50		 push	 eax
  00023	c7 86 ec 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3308], 1
  0002d	89 7d d4	 mov	 DWORD PTR _ChoasGemCount$[ebp], edi
  00030	89 7d d8	 mov	 DWORD PTR _BlessGemCount$[ebp], edi
  00033	89 7d dc	 mov	 DWORD PTR _SoulGemCount$[ebp], edi
  00036	89 7d e8	 mov	 DWORD PTR _CreatureGemCount$[ebp], edi
  00039	89 7d e4	 mov	 DWORD PTR _SoulOfDarkHorse$[ebp], edi
  0003c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2082 : 	pMsg.Result = CB_ERROR;
; 2083 : 	int iCharmOfLuckCount = 0;

  00044	33 db		 xor	 ebx, ebx
  00046	c6 45 f3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  0004a	89 5d e0	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], ebx

; 2084 : 	int iInvalidItemCount = 0;

  0004d	89 7d ec	 mov	 DWORD PTR _iInvalidItemCount$[ebp], edi
$LL34@DarkHorseC:

; 2087 : 	{
; 2088 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00050	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00056	03 cf		 add	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005d	83 f8 01	 cmp	 eax, 1
  00060	75 7e		 jne	 SHORT $LN33@DarkHorseC

; 2089 : 		{
; 2090 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,13) )

  00062	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00068	0f b7 44 39 06	 movzx	 eax, WORD PTR [ecx+edi+6]
  0006d	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  00072	66 3b c2	 cmp	 ax, dx
  00075	75 05		 jne	 SHORT $LN30@DarkHorseC

; 2091 : 			{
; 2092 : 				BlessGemCount++;

  00077	ff 45 d8	 inc	 DWORD PTR _BlessGemCount$[ebp]
  0007a	eb 64		 jmp	 SHORT $LN33@DarkHorseC
$LN30@DarkHorseC:

; 2093 : 			}
; 2094 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,14) )

  0007c	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  00081	66 3b c2	 cmp	 ax, dx
  00084	75 05		 jne	 SHORT $LN28@DarkHorseC

; 2095 : 			{
; 2096 : 				SoulGemCount++;

  00086	ff 45 dc	 inc	 DWORD PTR _SoulGemCount$[ebp]
  00089	eb 55		 jmp	 SHORT $LN33@DarkHorseC
$LN28@DarkHorseC:

; 2097 : 			}
; 2098 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,22) )	// Creation

  0008b	ba 16 1c 00 00	 mov	 edx, 7190		; 00001c16H
  00090	66 3b c2	 cmp	 ax, dx
  00093	75 05		 jne	 SHORT $LN26@DarkHorseC

; 2099 : 			{
; 2100 : 				CreatureGemCount++;

  00095	ff 45 e8	 inc	 DWORD PTR _CreatureGemCount$[ebp]
  00098	eb 46		 jmp	 SHORT $LN33@DarkHorseC
$LN26@DarkHorseC:

; 2101 : 			}
; 2102 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,15) )	// SUPE CHOAS HAHAHA

  0009a	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  0009f	66 3b c2	 cmp	 ax, dx
  000a2	75 05		 jne	 SHORT $LN24@DarkHorseC

; 2103 : 			{
; 2104 : 				ChoasGemCount++;

  000a4	ff 45 d4	 inc	 DWORD PTR _ChoasGemCount$[ebp]
  000a7	eb 37		 jmp	 SHORT $LN33@DarkHorseC
$LN24@DarkHorseC:

; 2105 : 			}
; 2106 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(13,31) && lpObj->pChaosBox[n].m_Level == 0 )	// Spirit

  000a9	ba 1f 1a 00 00	 mov	 edx, 6687		; 00001a1fH
  000ae	66 3b c2	 cmp	 ax, dx
  000b1	75 0d		 jne	 SHORT $LN22@DarkHorseC
  000b3	66 83 7c 39 08
	00		 cmp	 WORD PTR [ecx+edi+8], 0
  000b9	75 05		 jne	 SHORT $LN22@DarkHorseC

; 2107 : 			{
; 2108 : 				SoulOfDarkHorse++;

  000bb	ff 45 e4	 inc	 DWORD PTR _SoulOfDarkHorse$[ebp]
  000be	eb 20		 jmp	 SHORT $LN33@DarkHorseC
$LN22@DarkHorseC:

; 2109 : 			}
; 2110 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,53) )	// Charm Of Luck

  000c0	ba 35 1c 00 00	 mov	 edx, 7221		; 00001c35H
  000c5	66 3b c2	 cmp	 ax, dx
  000c8	75 13		 jne	 SHORT $LN20@DarkHorseC

; 2111 : 			{
; 2112 : 				iCharmOfLuckCount += lpObj->pChaosBox[n].m_Durability;

  000ca	db 45 e0	 fild	 DWORD PTR _iCharmOfLuckCount$[ebp]
  000cd	d8 44 39 24	 fadd	 DWORD PTR [ecx+edi+36]
  000d1	e8 00 00 00 00	 call	 __ftol2_sse
  000d6	89 45 e0	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], eax

; 2113 : 			}
; 2114 : 			else

  000d9	8b d8		 mov	 ebx, eax
  000db	eb 03		 jmp	 SHORT $LN33@DarkHorseC
$LN20@DarkHorseC:

; 2115 : 			{
; 2116 : 				iInvalidItemCount++;

  000dd	ff 45 ec	 inc	 DWORD PTR _iInvalidItemCount$[ebp]
$LN33@DarkHorseC:

; 2085 : 
; 2086 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  000e0	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  000e6	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  000ec	0f 8c 5e ff ff
	ff		 jl	 $LL34@DarkHorseC

; 2117 : 			}
; 2118 : 			
; 2119 : 
; 2120 : 		}
; 2121 : 	}
; 2122 : 
; 2123 : 	if ( ChoasGemCount != 1 || BlessGemCount != 5 || SoulGemCount != 5 || CreatureGemCount != 1 || SoulOfDarkHorse != 1 || iInvalidItemCount > 0 )

  000f2	b9 01 00 00 00	 mov	 ecx, 1
  000f7	39 4d d4	 cmp	 DWORD PTR _ChoasGemCount$[ebp], ecx
  000fa	0f 85 b4 00 00
	00		 jne	 $LN39@DarkHorseC
  00100	b8 05 00 00 00	 mov	 eax, 5
  00105	39 45 d8	 cmp	 DWORD PTR _BlessGemCount$[ebp], eax
  00108	0f 85 a6 00 00
	00		 jne	 $LN39@DarkHorseC
  0010e	39 45 dc	 cmp	 DWORD PTR _SoulGemCount$[ebp], eax
  00111	0f 85 9d 00 00
	00		 jne	 $LN39@DarkHorseC
  00117	39 4d e8	 cmp	 DWORD PTR _CreatureGemCount$[ebp], ecx
  0011a	0f 85 94 00 00
	00		 jne	 $LN39@DarkHorseC
  00120	39 4d e4	 cmp	 DWORD PTR _SoulOfDarkHorse$[ebp], ecx
  00123	0f 85 8b 00 00
	00		 jne	 $LN39@DarkHorseC
  00129	83 7d ec 00	 cmp	 DWORD PTR _iInvalidItemCount$[ebp], 0
  0012d	0f 8f 81 00 00
	00		 jg	 $LN39@DarkHorseC

; 2127 : 
; 2128 : 		return;
; 2129 : 	}
; 2130 : 
; 2131 : 	if ( iCharmOfLuckCount > 10 )

  00133	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  00136	7e 12		 jle	 SHORT $LN16@DarkHorseC

; 2132 : 	{
; 2133 : 		pMsg.Result = 0xF0;
; 2134 : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00138	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0013c	8b 16		 mov	 edx, DWORD PTR [esi]
  0013e	50		 push	 eax
  0013f	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00142	51		 push	 ecx
  00143	c6 45 f3 f0	 mov	 BYTE PTR _pMsg$[ebp+3], 240 ; 000000f0H
  00147	52		 push	 edx

; 2135 : 		lpObj->ChaosLock = FALSE;
; 2136 : 
; 2137 : 		return ;

  00148	eb 76		 jmp	 SHORT $LN40@DarkHorseC
$LN16@DarkHorseC:

; 2138 : 	}
; 2139 : 
; 2140 : 	LogChaosItem(lpObj, "DarkHorseMix");

  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LDINKAHL@DarkHorseMix?$AA@
  0014f	56		 push	 esi
  00150	e8 00 00 00 00	 call	 ?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z ; LogChaosItem

; 2141 : 	LogAdd(LOG_BLACK, "[DarkHorseMix] Chaos Mix Start");

  00155	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@IMILBLLO@?$FLDarkHorseMix?$FN?5Chaos?5Mix?5Start?$AA@
  0015a	6a 00		 push	 0
  0015c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2142 : 	lpObj->ChaosSuccessRate = 60;
; 2143 : 	lpObj->ChaosSuccessRate += iCharmOfLuckCount;
; 2144 : 
; 2145 : 	int nChaosNeedMoney = 5000000;
; 2146 : 
; 2147 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  00161	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00163	83 c4 10	 add	 esp, 16			; 00000010H
  00166	8d 43 3c	 lea	 eax, DWORD PTR [ebx+60]
  00169	51		 push	 ecx
  0016a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0016f	89 86 e8 0c 00
	00		 mov	 DWORD PTR [esi+3304], eax
  00175	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  0017a	6a 00		 push	 0
  0017c	99		 cdq
  0017d	68 40 4b 4c 00	 push	 5000000			; 004c4b40H
  00182	52		 push	 edx
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 __allmul
  00189	6a 00		 push	 0
  0018b	6a 64		 push	 100			; 00000064H
  0018d	52		 push	 edx
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 __alldiv

; 2148 : 
; 2149 : 	if ( iChaosTaxMoney < 0 )

  00194	85 c0		 test	 eax, eax
  00196	79 02		 jns	 SHORT $LN15@DarkHorseC

; 2150 : 	{
; 2151 : 		iChaosTaxMoney = 0;

  00198	33 c0		 xor	 eax, eax
$LN15@DarkHorseC:

; 2152 : 	}
; 2153 : 
; 2154 : 	nChaosNeedMoney += iChaosTaxMoney;

  0019a	8d b8 40 4b 4c
	00		 lea	 edi, DWORD PTR [eax+5000000]

; 2155 : 
; 2156 : 	if ( nChaosNeedMoney < 0 )

  001a0	85 ff		 test	 edi, edi
  001a2	79 02		 jns	 SHORT $LN14@DarkHorseC

; 2157 : 	{
; 2158 : 		nChaosNeedMoney = 0;

  001a4	33 ff		 xor	 edi, edi
$LN14@DarkHorseC:

; 2159 : 	}
; 2160 : 
; 2161 : 	if ( lpObj->Money < nChaosNeedMoney )

  001a6	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  001ac	3b cf		 cmp	 ecx, edi
  001ae	7d 33		 jge	 SHORT $LN13@DarkHorseC

; 2162 : 	{
; 2163 : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;

  001b0	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
$LN39@DarkHorseC:

; 2124 : 	{
; 2125 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  001b4	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  001b8	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001ba	52		 push	 edx
  001bb	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001be	50		 push	 eax
  001bf	51		 push	 ecx
$LN40@DarkHorseC:
  001c0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001c5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN41@DarkHorseC:

; 2126 : 		lpObj->ChaosLock = FALSE;

  001c8	5f		 pop	 edi
  001c9	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  001d3	5e		 pop	 esi
  001d4	5b		 pop	 ebx

; 2241 : 	}
; 2242 : }

  001d5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d8	33 cd		 xor	 ecx, ebp
  001da	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c3		 ret	 0
$LN13@DarkHorseC:

; 2164 : 		
; 2165 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);
; 2166 : 		lpObj->ChaosLock = FALSE;
; 2167 : 
; 2168 : 		return;
; 2169 : 	}
; 2170 : 
; 2171 : 	lpObj->Money -= nChaosNeedMoney;

  001e3	2b cf		 sub	 ecx, edi
  001e5	89 8e b0 00 00
	00		 mov	 DWORD PTR [esi+176], ecx

; 2172 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  001eb	50		 push	 eax
  001ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  001f1	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 2173 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  001f6	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  001fc	8b 06		 mov	 eax, DWORD PTR [esi]
  001fe	52		 push	 edx
  001ff	50		 push	 eax
  00200	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00205	83 c4 08	 add	 esp, 8

; 2174 : 
; 2175 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  00208	e8 00 00 00 00	 call	 _rand
  0020d	99		 cdq
  0020e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00213	f7 f9		 idiv	 ecx
  00215	3b 96 e8 0c 00
	00		 cmp	 edx, DWORD PTR [esi+3304]
  0021b	0f 8d 05 01 00
	00		 jge	 $LN12@DarkHorseC

; 2176 : 	{
; 2177 : 		int Level = 0;
; 2178 : 		int ItemType = 13;
; 2179 : 		int ItemSubType = 4;
; 2180 : 		int ItemNum = ITEMGET(ItemType, ItemSubType);
; 2181 : 		int Option1 = 0;

  00221	33 db		 xor	 ebx, ebx
  00223	89 5d e4	 mov	 DWORD PTR _Option1$156358[ebp], ebx

; 2182 : 		int Option2 = 0;
; 2183 : 		int Option3 = 0;
; 2184 : 
; 2185 : 		int Add = 0;

  00226	89 5d e8	 mov	 DWORD PTR _Add$156361[ebp], ebx

; 2186 : 
; 2187 : 		if ( (rand()%100) < (lpObj->ChaosSuccessRate/5+6) )

  00229	e8 00 00 00 00	 call	 _rand
  0022e	99		 cdq
  0022f	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00234	f7 f9		 idiv	 ecx
  00236	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0023b	89 55 ec	 mov	 DWORD PTR tv447[ebp], edx
  0023e	f7 ae e8 0c 00
	00		 imul	 DWORD PTR [esi+3304]
  00244	d1 fa		 sar	 edx, 1
  00246	8b c2		 mov	 eax, edx
  00248	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0024b	8d 4c 02 06	 lea	 ecx, DWORD PTR [edx+eax+6]
  0024f	39 4d ec	 cmp	 DWORD PTR tv447[ebp], ecx
  00252	7d 07		 jge	 SHORT $LN11@DarkHorseC

; 2188 : 		{
; 2189 : 			Add = 1;

  00254	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _Add$156361[ebp], 1
$LN11@DarkHorseC:

; 2190 : 		}
; 2191 : 
; 2192 : 		if ( (rand()%5) == 0 )

  0025b	e8 00 00 00 00	 call	 _rand
  00260	99		 cdq
  00261	b9 05 00 00 00	 mov	 ecx, 5
  00266	f7 f9		 idiv	 ecx
  00268	85 d2		 test	 edx, edx
  0026a	75 07		 jne	 SHORT $LN10@DarkHorseC

; 2193 : 		{
; 2194 : 			Option1 = 1;

  0026c	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _Option1$156358[ebp], 1
$LN10@DarkHorseC:

; 2195 : 		}
; 2196 : 
; 2197 : 		int lc22 = rand()%100;	

  00273	e8 00 00 00 00	 call	 _rand
  00278	99		 cdq
  00279	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0027e	f7 f9		 idiv	 ecx
  00280	89 55 ec	 mov	 DWORD PTR _lc22$156364[ebp], edx

; 2198 : 		int lc23 = rand()%3;

  00283	e8 00 00 00 00	 call	 _rand
  00288	99		 cdq
  00289	b9 03 00 00 00	 mov	 ecx, 3
  0028e	f7 f9		 idiv	 ecx

; 2199 : 		//int lc24 = lc23;
; 2200 : 
; 2201 : 		switch ( lc23 )

  00290	2b d3		 sub	 edx, ebx
  00292	74 1e		 je	 SHORT $LN7@DarkHorseC
  00294	4a		 dec	 edx
  00295	74 0e		 je	 SHORT $LN5@DarkHorseC
  00297	4a		 dec	 edx
  00298	75 20		 jne	 SHORT $LN6@DarkHorseC

; 2216 : 
; 2217 : 			case 2:
; 2218 : 				if ( lc22 <  20 )

  0029a	83 7d ec 14	 cmp	 DWORD PTR _lc22$156364[ebp], 20 ; 00000014H
  0029e	7d 1a		 jge	 SHORT $LN6@DarkHorseC

; 2219 : 				{
; 2220 : 					Option2 = 1;

  002a0	8d 59 fe	 lea	 ebx, DWORD PTR [ecx-2]

; 2221 : 				}
; 2222 : 				break;

  002a3	eb 15		 jmp	 SHORT $LN6@DarkHorseC
$LN5@DarkHorseC:

; 2207 : 				}
; 2208 : 				break;
; 2209 : 
; 2210 : 			case 1:
; 2211 : 				if ( lc22 <  10 )

  002a5	83 7d ec 0a	 cmp	 DWORD PTR _lc22$156364[ebp], 10 ; 0000000aH
  002a9	7d 0f		 jge	 SHORT $LN6@DarkHorseC

; 2212 : 				{
; 2213 : 					Option2 = 2;

  002ab	bb 02 00 00 00	 mov	 ebx, 2

; 2214 : 				}
; 2215 : 				break;

  002b0	eb 08		 jmp	 SHORT $LN6@DarkHorseC
$LN7@DarkHorseC:

; 2202 : 		{
; 2203 : 			case 0:
; 2204 : 				if ( lc22 <  4 )

  002b2	83 7d ec 04	 cmp	 DWORD PTR _lc22$156364[ebp], 4
  002b6	7d 02		 jge	 SHORT $LN6@DarkHorseC

; 2205 : 				{
; 2206 : 					Option2 = 3;

  002b8	8b d9		 mov	 ebx, ecx
$LN6@DarkHorseC:

; 2223 : 		}
; 2224 : 
; 2225 : 		::PetItemSerialCreateSend(lpObj->m_Index, -2, 0, 0, ItemNum, Level, 0,Add,  Option1, Option2, -1, 0, 0); 

  002ba	8b 55 e4	 mov	 edx, DWORD PTR _Option1$156358[ebp]
  002bd	8b 45 e8	 mov	 eax, DWORD PTR _Add$156361[ebp]
  002c0	6a 00		 push	 0
  002c2	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002c4	6a 00		 push	 0
  002c6	6a ff		 push	 -1
  002c8	53		 push	 ebx
  002c9	52		 push	 edx
  002ca	50		 push	 eax
  002cb	6a 00		 push	 0
  002cd	6a 00		 push	 0
  002cf	68 04 1a 00 00	 push	 6660			; 00001a04H
  002d4	6a 00		 push	 0
  002d6	6a 00		 push	 0
  002d8	68 fe 00 00 00	 push	 254			; 000000feH
  002dd	51		 push	 ecx
  002de	e8 00 00 00 00	 call	 ?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; PetItemSerialCreateSend

; 2226 : 		::gObjInventoryCommit(lpObj->m_Index);

  002e3	8b 16		 mov	 edx, DWORD PTR [esi]
  002e5	52		 push	 edx
  002e6	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit

; 2227 : 		LogAdd(LOG_BLACK, "[DarkHorseMix] [%s][%s] CBMix Success %d Money : %d-%d, CharmRate : %d",
; 2228 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate,
; 2229 : 			lpObj->Money, nChaosNeedMoney, iCharmOfLuckCount);

  002eb	8b 45 e0	 mov	 eax, DWORD PTR _iCharmOfLuckCount$[ebp]
  002ee	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  002f4	8b 96 e8 0c 00
	00		 mov	 edx, DWORD PTR [esi+3304]
  002fa	50		 push	 eax
  002fb	57		 push	 edi
  002fc	51		 push	 ecx
  002fd	52		 push	 edx
  002fe	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00301	50		 push	 eax
  00302	83 c6 64	 add	 esi, 100		; 00000064H
  00305	56		 push	 esi
  00306	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@JGHMMOON@?$FLDarkHorseMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@
  0030b	6a 00		 push	 0
  0030d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2241 : 	}
; 2242 : }

  00312	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00315	83 c4 58	 add	 esp, 88			; 00000058H
  00318	5f		 pop	 edi
  00319	5e		 pop	 esi
  0031a	33 cd		 xor	 ecx, ebp
  0031c	5b		 pop	 ebx
  0031d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00322	8b e5		 mov	 esp, ebp
  00324	5d		 pop	 ebp
  00325	c3		 ret	 0
$LN12@DarkHorseC:

; 2230 : 	}
; 2231 : 	else
; 2232 : 	{
; 2233 : 		ChaosBoxInit(lpObj);

  00326	56		 push	 esi
  00327	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit

; 2234 : 		GCUserChaosBoxSend(lpObj, 1);

  0032c	6a 01		 push	 1
  0032e	56		 push	 esi
  0032f	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 2235 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00334	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00338	8b 06		 mov	 eax, DWORD PTR [esi]
  0033a	51		 push	 ecx
  0033b	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0033e	52		 push	 edx
  0033f	50		 push	 eax
  00340	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2236 : 
; 2237 : 		LogAdd(LOG_BLACK, "[DarkHorseMix] [%s][%s] CBMix Fail %d Money : %d-%d, CharmRate : %d",
; 2238 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate,
; 2239 : 			lpObj->Money, nChaosNeedMoney, iCharmOfLuckCount);

  00345	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  0034b	8b 96 e8 0c 00
	00		 mov	 edx, DWORD PTR [esi+3304]
  00351	53		 push	 ebx
  00352	57		 push	 edi
  00353	51		 push	 ecx
  00354	52		 push	 edx
  00355	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00358	50		 push	 eax
  00359	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  0035c	51		 push	 ecx
  0035d	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@MAGJAMAN@?$FLDarkHorseMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@
  00362	6a 00		 push	 0
  00364	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00369	83 c4 38	 add	 esp, 56			; 00000038H

; 2240 : 		lpObj->ChaosLock = FALSE;

  0036c	e9 57 fe ff ff	 jmp	 $LN41@DarkHorseC
?DarkHorseChaosMix@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; DarkHorseChaosMix
_TEXT	ENDS
PUBLIC	??_C@_0EF@ENJLGEHL@?$FLDarkSpiritMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@ ; `string'
PUBLIC	??_C@_0EI@DIJHKIBN@?$FLDarkSpiritMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5S@ ; `string'
PUBLIC	??_C@_0CA@HOBPNGGO@?$FLDarkSpiritMix?$FN?5Chaos?5Mix?5Start?$AA@ ; `string'
PUBLIC	??_C@_0O@OCFEOMDO@DarkSpiritMix?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DarkSpiritChaosMix@@YAXPAUOBJECTSTRUCT@@@Z	; DarkSpiritChaosMix
;	COMDAT ??_C@_0EF@ENJLGEHL@?$FLDarkSpiritMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@
CONST	SEGMENT
??_C@_0EF@ENJLGEHL@?$FLDarkSpiritMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@ DB '['
	DB	'DarkSpiritMix] [%s][%s] CBMix Fail %d Money : %d-%d, CharmRat'
	DB	'e : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@DIJHKIBN@?$FLDarkSpiritMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5S@
CONST	SEGMENT
??_C@_0EI@DIJHKIBN@?$FLDarkSpiritMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5S@ DB '['
	DB	'DarkSpiritMix] [%s][%s] CBMix Success %d Money : %d-%d, Charm'
	DB	'Rate : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HOBPNGGO@?$FLDarkSpiritMix?$FN?5Chaos?5Mix?5Start?$AA@
CONST	SEGMENT
??_C@_0CA@HOBPNGGO@?$FLDarkSpiritMix?$FN?5Chaos?5Mix?5Start?$AA@ DB '[Dar'
	DB	'kSpiritMix] Chaos Mix Start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OCFEOMDO@DarkSpiritMix?$AA@
CONST	SEGMENT
??_C@_0O@OCFEOMDO@DarkSpiritMix?$AA@ DB 'DarkSpiritMix', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DarkSpiritChaosMix@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_ChoasGemCount$ = -44					; size = 4
_BlessGemCount$ = -40					; size = 4
_SoulGemCount$ = -36					; size = 4
_iCharmOfLuckCount$ = -32				; size = 4
_Option1$156433 = -28					; size = 4
_SoulOfSpirit$ = -28					; size = 4
_Add$156436 = -24					; size = 4
_CreatureGemCount$ = -24				; size = 4
tv447 = -20						; size = 4
_lc22$156439 = -20					; size = 4
_iInvalidItemCount$ = -20				; size = 4
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?DarkSpiritChaosMix@@YAXPAUOBJECTSTRUCT@@@Z PROC	; DarkSpiritChaosMix, COMDAT

; 2250 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 2251 : 	lpObj->ChaosLock = TRUE;
; 2252 : 	int ChoasGemCount = 0;

  00016	33 ff		 xor	 edi, edi

; 2253 : 	int BlessGemCount = 0;
; 2254 : 	int SoulGemCount = 0;
; 2255 : 	int CreatureGemCount = 0;
; 2256 : 	int SoulOfSpirit = 0;
; 2257 : 	int iChaosMoney = 0;
; 2258 : 
; 2259 : 	PMSG_CHAOSMIXRESULT pMsg;
; 2260 : 
; 2261 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00018	6a 0b		 push	 11			; 0000000bH
  0001a	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001d	68 86 00 00 00	 push	 134			; 00000086H
  00022	50		 push	 eax
  00023	c7 86 ec 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3308], 1
  0002d	89 7d d4	 mov	 DWORD PTR _ChoasGemCount$[ebp], edi
  00030	89 7d d8	 mov	 DWORD PTR _BlessGemCount$[ebp], edi
  00033	89 7d dc	 mov	 DWORD PTR _SoulGemCount$[ebp], edi
  00036	89 7d e8	 mov	 DWORD PTR _CreatureGemCount$[ebp], edi
  00039	89 7d e4	 mov	 DWORD PTR _SoulOfSpirit$[ebp], edi
  0003c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2262 : 	pMsg.Result = CB_ERROR;
; 2263 : 	int iCharmOfLuckCount = 0;

  00044	33 db		 xor	 ebx, ebx
  00046	c6 45 f3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  0004a	89 5d e0	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], ebx

; 2264 : 	int iInvalidItemCount = 0;

  0004d	89 7d ec	 mov	 DWORD PTR _iInvalidItemCount$[ebp], edi
$LL34@DarkSpirit:

; 2267 : 	{
; 2268 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00050	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00056	03 cf		 add	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005d	83 f8 01	 cmp	 eax, 1
  00060	0f 85 82 00 00
	00		 jne	 $LN33@DarkSpirit

; 2269 : 		{
; 2270 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,13) )

  00066	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  0006c	0f b7 44 39 06	 movzx	 eax, WORD PTR [ecx+edi+6]
  00071	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  00076	66 3b c2	 cmp	 ax, dx
  00079	75 05		 jne	 SHORT $LN30@DarkSpirit

; 2271 : 			{
; 2272 : 				BlessGemCount++;

  0007b	ff 45 d8	 inc	 DWORD PTR _BlessGemCount$[ebp]
  0007e	eb 68		 jmp	 SHORT $LN33@DarkSpirit
$LN30@DarkSpirit:

; 2273 : 			}
; 2274 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,14) )

  00080	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  00085	66 3b c2	 cmp	 ax, dx
  00088	75 05		 jne	 SHORT $LN28@DarkSpirit

; 2275 : 			{
; 2276 : 				SoulGemCount++;

  0008a	ff 45 dc	 inc	 DWORD PTR _SoulGemCount$[ebp]
  0008d	eb 59		 jmp	 SHORT $LN33@DarkSpirit
$LN28@DarkSpirit:

; 2277 : 			}
; 2278 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,22) )	// Creation

  0008f	ba 16 1c 00 00	 mov	 edx, 7190		; 00001c16H
  00094	66 3b c2	 cmp	 ax, dx
  00097	75 05		 jne	 SHORT $LN26@DarkSpirit

; 2279 : 			{
; 2280 : 				CreatureGemCount++;

  00099	ff 45 e8	 inc	 DWORD PTR _CreatureGemCount$[ebp]
  0009c	eb 4a		 jmp	 SHORT $LN33@DarkSpirit
$LN26@DarkSpirit:

; 2281 : 			}
; 2282 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,15) )	// SUPE CHOAS HAHAHA

  0009e	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  000a3	66 3b c2	 cmp	 ax, dx
  000a6	75 05		 jne	 SHORT $LN24@DarkSpirit

; 2283 : 			{
; 2284 : 				ChoasGemCount++;

  000a8	ff 45 d4	 inc	 DWORD PTR _ChoasGemCount$[ebp]
  000ab	eb 3b		 jmp	 SHORT $LN33@DarkSpirit
$LN24@DarkSpirit:

; 2285 : 			}
; 2286 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(13,31) && lpObj->pChaosBox[n].m_Level == 1 )	// Spirit

  000ad	ba 1f 1a 00 00	 mov	 edx, 6687		; 00001a1fH
  000b2	66 3b c2	 cmp	 ax, dx
  000b5	75 11		 jne	 SHORT $LN22@DarkSpirit
  000b7	ba 01 00 00 00	 mov	 edx, 1
  000bc	66 39 54 39 08	 cmp	 WORD PTR [ecx+edi+8], dx
  000c1	75 05		 jne	 SHORT $LN22@DarkSpirit

; 2287 : 			{
; 2288 : 				SoulOfSpirit++;

  000c3	01 55 e4	 add	 DWORD PTR _SoulOfSpirit$[ebp], edx
  000c6	eb 20		 jmp	 SHORT $LN33@DarkSpirit
$LN22@DarkSpirit:

; 2289 : 			}
; 2290 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,53) )	// Charm Of Luck

  000c8	ba 35 1c 00 00	 mov	 edx, 7221		; 00001c35H
  000cd	66 3b c2	 cmp	 ax, dx
  000d0	75 13		 jne	 SHORT $LN20@DarkSpirit

; 2291 : 			{
; 2292 : 				iCharmOfLuckCount += lpObj->pChaosBox[n].m_Durability;

  000d2	db 45 e0	 fild	 DWORD PTR _iCharmOfLuckCount$[ebp]
  000d5	d8 44 39 24	 fadd	 DWORD PTR [ecx+edi+36]
  000d9	e8 00 00 00 00	 call	 __ftol2_sse
  000de	89 45 e0	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], eax

; 2293 : 			}
; 2294 : 			else

  000e1	8b d8		 mov	 ebx, eax
  000e3	eb 03		 jmp	 SHORT $LN33@DarkSpirit
$LN20@DarkSpirit:

; 2295 : 			{
; 2296 : 				iInvalidItemCount++;

  000e5	ff 45 ec	 inc	 DWORD PTR _iInvalidItemCount$[ebp]
$LN33@DarkSpirit:

; 2265 : 
; 2266 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  000e8	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  000ee	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  000f4	0f 8c 56 ff ff
	ff		 jl	 $LL34@DarkSpirit

; 2297 : 			}
; 2298 : 		}
; 2299 : 	}
; 2300 : 
; 2301 : 	if ( ChoasGemCount != 1 || BlessGemCount != 2 || SoulGemCount != 2 || CreatureGemCount != 1 || SoulOfSpirit != 1 || iInvalidItemCount > 0 )

  000fa	b9 01 00 00 00	 mov	 ecx, 1
  000ff	39 4d d4	 cmp	 DWORD PTR _ChoasGemCount$[ebp], ecx
  00102	0f 85 b4 00 00
	00		 jne	 $LN39@DarkSpirit
  00108	b8 02 00 00 00	 mov	 eax, 2
  0010d	39 45 d8	 cmp	 DWORD PTR _BlessGemCount$[ebp], eax
  00110	0f 85 a6 00 00
	00		 jne	 $LN39@DarkSpirit
  00116	39 45 dc	 cmp	 DWORD PTR _SoulGemCount$[ebp], eax
  00119	0f 85 9d 00 00
	00		 jne	 $LN39@DarkSpirit
  0011f	39 4d e8	 cmp	 DWORD PTR _CreatureGemCount$[ebp], ecx
  00122	0f 85 94 00 00
	00		 jne	 $LN39@DarkSpirit
  00128	39 4d e4	 cmp	 DWORD PTR _SoulOfSpirit$[ebp], ecx
  0012b	0f 85 8b 00 00
	00		 jne	 $LN39@DarkSpirit
  00131	83 7d ec 00	 cmp	 DWORD PTR _iInvalidItemCount$[ebp], 0
  00135	0f 8f 81 00 00
	00		 jg	 $LN39@DarkSpirit

; 2305 : 
; 2306 : 		return;
; 2307 : 	}
; 2308 : 
; 2309 : 	if ( iCharmOfLuckCount > 10 )

  0013b	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  0013e	7e 12		 jle	 SHORT $LN16@DarkSpirit

; 2310 : 	{
; 2311 : 		pMsg.Result = 0xF0;
; 2312 : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00140	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00144	8b 16		 mov	 edx, DWORD PTR [esi]
  00146	50		 push	 eax
  00147	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0014a	51		 push	 ecx
  0014b	c6 45 f3 f0	 mov	 BYTE PTR _pMsg$[ebp+3], 240 ; 000000f0H
  0014f	52		 push	 edx

; 2313 : 		lpObj->ChaosLock = FALSE;
; 2314 : 
; 2315 : 		return ;

  00150	eb 76		 jmp	 SHORT $LN40@DarkSpirit
$LN16@DarkSpirit:

; 2316 : 	}
; 2317 : 
; 2318 : 	LogChaosItem(lpObj, "DarkSpiritMix");

  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OCFEOMDO@DarkSpiritMix?$AA@
  00157	56		 push	 esi
  00158	e8 00 00 00 00	 call	 ?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z ; LogChaosItem

; 2319 : 	LogAdd(LOG_BLACK, "[DarkSpiritMix] Chaos Mix Start");

  0015d	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HOBPNGGO@?$FLDarkSpiritMix?$FN?5Chaos?5Mix?5Start?$AA@
  00162	6a 00		 push	 0
  00164	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2320 : 	lpObj->ChaosSuccessRate = 60;
; 2321 : 	lpObj->ChaosSuccessRate += iCharmOfLuckCount;
; 2322 : 
; 2323 : 	int nChaosNeedMoney = 1000000;
; 2324 : 
; 2325 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  00169	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0016b	83 c4 10	 add	 esp, 16			; 00000010H
  0016e	8d 43 3c	 lea	 eax, DWORD PTR [ebx+60]
  00171	51		 push	 ecx
  00172	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00177	89 86 e8 0c 00
	00		 mov	 DWORD PTR [esi+3304], eax
  0017d	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00182	6a 00		 push	 0
  00184	99		 cdq
  00185	68 40 42 0f 00	 push	 1000000			; 000f4240H
  0018a	52		 push	 edx
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 __allmul
  00191	6a 00		 push	 0
  00193	6a 64		 push	 100			; 00000064H
  00195	52		 push	 edx
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 __alldiv

; 2326 : 
; 2327 : 	if ( iChaosTaxMoney < 0 )

  0019c	85 c0		 test	 eax, eax
  0019e	79 02		 jns	 SHORT $LN15@DarkSpirit

; 2328 : 	{
; 2329 : 		iChaosTaxMoney = 0;

  001a0	33 c0		 xor	 eax, eax
$LN15@DarkSpirit:

; 2330 : 	}
; 2331 : 
; 2332 : 	nChaosNeedMoney += iChaosTaxMoney;

  001a2	8d b8 40 42 0f
	00		 lea	 edi, DWORD PTR [eax+1000000]

; 2333 : 
; 2334 : 	if ( nChaosNeedMoney < 0 )

  001a8	85 ff		 test	 edi, edi
  001aa	79 02		 jns	 SHORT $LN14@DarkSpirit

; 2335 : 	{
; 2336 : 		nChaosNeedMoney = 0;

  001ac	33 ff		 xor	 edi, edi
$LN14@DarkSpirit:

; 2337 : 	}
; 2338 : 
; 2339 : 	if ( lpObj->Money < nChaosNeedMoney )

  001ae	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  001b4	3b cf		 cmp	 ecx, edi
  001b6	7d 33		 jge	 SHORT $LN13@DarkSpirit

; 2340 : 	{
; 2341 : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;

  001b8	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
$LN39@DarkSpirit:

; 2302 : 	{
; 2303 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  001bc	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  001c0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001c2	52		 push	 edx
  001c3	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001c6	50		 push	 eax
  001c7	51		 push	 ecx
$LN40@DarkSpirit:
  001c8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001cd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN41@DarkSpirit:

; 2304 : 		lpObj->ChaosLock = FALSE;

  001d0	5f		 pop	 edi
  001d1	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  001db	5e		 pop	 esi
  001dc	5b		 pop	 ebx

; 2419 : 	}
; 2420 : }

  001dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e0	33 cd		 xor	 ecx, ebp
  001e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c3		 ret	 0
$LN13@DarkSpirit:

; 2342 : 		
; 2343 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);
; 2344 : 		lpObj->ChaosLock = FALSE;
; 2345 : 
; 2346 : 		return;
; 2347 : 	}
; 2348 : 
; 2349 : 	lpObj->Money -= nChaosNeedMoney;

  001eb	2b cf		 sub	 ecx, edi
  001ed	89 8e b0 00 00
	00		 mov	 DWORD PTR [esi+176], ecx

; 2350 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  001f3	50		 push	 eax
  001f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  001f9	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 2351 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  001fe	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  00204	8b 06		 mov	 eax, DWORD PTR [esi]
  00206	52		 push	 edx
  00207	50		 push	 eax
  00208	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0020d	83 c4 08	 add	 esp, 8

; 2352 : 
; 2353 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  00210	e8 00 00 00 00	 call	 _rand
  00215	99		 cdq
  00216	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0021b	f7 f9		 idiv	 ecx
  0021d	3b 96 e8 0c 00
	00		 cmp	 edx, DWORD PTR [esi+3304]
  00223	0f 8d 05 01 00
	00		 jge	 $LN12@DarkSpirit

; 2354 : 	{
; 2355 : 		int Level = 0;
; 2356 : 		int ItemType = 13;
; 2357 : 		int ItemSubType = 5;
; 2358 : 		int ItemNum = ITEMGET(ItemType, ItemSubType);
; 2359 : 		int Option1 = 0;

  00229	33 db		 xor	 ebx, ebx
  0022b	89 5d e4	 mov	 DWORD PTR _Option1$156433[ebp], ebx

; 2360 : 		int Option2 = 0;
; 2361 : 		int Option3 = 0;
; 2362 : 
; 2363 : 		int Add = 0;

  0022e	89 5d e8	 mov	 DWORD PTR _Add$156436[ebp], ebx

; 2364 : 
; 2365 : 		if ( (rand()%100) < (lpObj->ChaosSuccessRate/5+6) )

  00231	e8 00 00 00 00	 call	 _rand
  00236	99		 cdq
  00237	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0023c	f7 f9		 idiv	 ecx
  0023e	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00243	89 55 ec	 mov	 DWORD PTR tv447[ebp], edx
  00246	f7 ae e8 0c 00
	00		 imul	 DWORD PTR [esi+3304]
  0024c	d1 fa		 sar	 edx, 1
  0024e	8b c2		 mov	 eax, edx
  00250	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00253	8d 4c 02 06	 lea	 ecx, DWORD PTR [edx+eax+6]
  00257	39 4d ec	 cmp	 DWORD PTR tv447[ebp], ecx
  0025a	7d 07		 jge	 SHORT $LN11@DarkSpirit

; 2366 : 		{
; 2367 : 			Add = 1;

  0025c	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _Add$156436[ebp], 1
$LN11@DarkSpirit:

; 2368 : 		}
; 2369 : 
; 2370 : 		if ( (rand()%5) == 0 )

  00263	e8 00 00 00 00	 call	 _rand
  00268	99		 cdq
  00269	b9 05 00 00 00	 mov	 ecx, 5
  0026e	f7 f9		 idiv	 ecx
  00270	85 d2		 test	 edx, edx
  00272	75 07		 jne	 SHORT $LN10@DarkSpirit

; 2371 : 		{
; 2372 : 			Option1 = 1;

  00274	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _Option1$156433[ebp], 1
$LN10@DarkSpirit:

; 2373 : 		}
; 2374 : 
; 2375 : 		int lc22 = rand()%100;	

  0027b	e8 00 00 00 00	 call	 _rand
  00280	99		 cdq
  00281	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00286	f7 f9		 idiv	 ecx
  00288	89 55 ec	 mov	 DWORD PTR _lc22$156439[ebp], edx

; 2376 : 		int lc23 = rand()%3;

  0028b	e8 00 00 00 00	 call	 _rand
  00290	99		 cdq
  00291	b9 03 00 00 00	 mov	 ecx, 3
  00296	f7 f9		 idiv	 ecx

; 2377 : //		int lc24 = lc23;
; 2378 : 
; 2379 : 		switch ( lc23 )

  00298	2b d3		 sub	 edx, ebx
  0029a	74 1e		 je	 SHORT $LN7@DarkSpirit
  0029c	4a		 dec	 edx
  0029d	74 0e		 je	 SHORT $LN5@DarkSpirit
  0029f	4a		 dec	 edx
  002a0	75 20		 jne	 SHORT $LN6@DarkSpirit

; 2394 : 
; 2395 : 			case 2:
; 2396 : 				if ( lc22 <  20 )

  002a2	83 7d ec 14	 cmp	 DWORD PTR _lc22$156439[ebp], 20 ; 00000014H
  002a6	7d 1a		 jge	 SHORT $LN6@DarkSpirit

; 2397 : 				{
; 2398 : 					Option2 = 1;

  002a8	8d 59 fe	 lea	 ebx, DWORD PTR [ecx-2]

; 2399 : 				}
; 2400 : 				break;

  002ab	eb 15		 jmp	 SHORT $LN6@DarkSpirit
$LN5@DarkSpirit:

; 2385 : 				}
; 2386 : 				break;
; 2387 : 
; 2388 : 			case 1:
; 2389 : 				if ( lc22 <  10 )

  002ad	83 7d ec 0a	 cmp	 DWORD PTR _lc22$156439[ebp], 10 ; 0000000aH
  002b1	7d 0f		 jge	 SHORT $LN6@DarkSpirit

; 2390 : 				{
; 2391 : 					Option2 = 2;

  002b3	bb 02 00 00 00	 mov	 ebx, 2

; 2392 : 				}
; 2393 : 				break;

  002b8	eb 08		 jmp	 SHORT $LN6@DarkSpirit
$LN7@DarkSpirit:

; 2380 : 		{
; 2381 : 			case 0:
; 2382 : 				if ( lc22 <  4 )

  002ba	83 7d ec 04	 cmp	 DWORD PTR _lc22$156439[ebp], 4
  002be	7d 02		 jge	 SHORT $LN6@DarkSpirit

; 2383 : 				{
; 2384 : 					Option2 = 3;

  002c0	8b d9		 mov	 ebx, ecx
$LN6@DarkSpirit:

; 2401 : 		}
; 2402 : 
; 2403 : 		::PetItemSerialCreateSend(lpObj->m_Index, -2, 0, 0, ItemNum, Level, 0, Add, Option1, Option2, -1, 0, 0); 

  002c2	8b 55 e4	 mov	 edx, DWORD PTR _Option1$156433[ebp]
  002c5	8b 45 e8	 mov	 eax, DWORD PTR _Add$156436[ebp]
  002c8	6a 00		 push	 0
  002ca	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002cc	6a 00		 push	 0
  002ce	6a ff		 push	 -1
  002d0	53		 push	 ebx
  002d1	52		 push	 edx
  002d2	50		 push	 eax
  002d3	6a 00		 push	 0
  002d5	6a 00		 push	 0
  002d7	68 05 1a 00 00	 push	 6661			; 00001a05H
  002dc	6a 00		 push	 0
  002de	6a 00		 push	 0
  002e0	68 fe 00 00 00	 push	 254			; 000000feH
  002e5	51		 push	 ecx
  002e6	e8 00 00 00 00	 call	 ?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; PetItemSerialCreateSend

; 2404 : 		::gObjInventoryCommit(lpObj->m_Index);

  002eb	8b 16		 mov	 edx, DWORD PTR [esi]
  002ed	52		 push	 edx
  002ee	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit

; 2405 : 		LogAdd(LOG_BLACK, "[DarkSpiritMix] [%s][%s] CBMix Success %d Money : %d-%d, CharmRate : %d",
; 2406 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate,
; 2407 : 			lpObj->Money, nChaosNeedMoney, iCharmOfLuckCount);

  002f3	8b 45 e0	 mov	 eax, DWORD PTR _iCharmOfLuckCount$[ebp]
  002f6	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  002fc	8b 96 e8 0c 00
	00		 mov	 edx, DWORD PTR [esi+3304]
  00302	50		 push	 eax
  00303	57		 push	 edi
  00304	51		 push	 ecx
  00305	52		 push	 edx
  00306	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00309	50		 push	 eax
  0030a	83 c6 64	 add	 esi, 100		; 00000064H
  0030d	56		 push	 esi
  0030e	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@DIJHKIBN@?$FLDarkSpiritMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5S@
  00313	6a 00		 push	 0
  00315	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2419 : 	}
; 2420 : }

  0031a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0031d	83 c4 58	 add	 esp, 88			; 00000058H
  00320	5f		 pop	 edi
  00321	5e		 pop	 esi
  00322	33 cd		 xor	 ecx, ebp
  00324	5b		 pop	 ebx
  00325	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032a	8b e5		 mov	 esp, ebp
  0032c	5d		 pop	 ebp
  0032d	c3		 ret	 0
$LN12@DarkSpirit:

; 2408 : 	}
; 2409 : 	else
; 2410 : 	{
; 2411 : 		ChaosBoxInit(lpObj);

  0032e	56		 push	 esi
  0032f	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit

; 2412 : 		GCUserChaosBoxSend(lpObj, 1);

  00334	6a 01		 push	 1
  00336	56		 push	 esi
  00337	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 2413 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0033c	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00340	8b 06		 mov	 eax, DWORD PTR [esi]
  00342	51		 push	 ecx
  00343	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00346	52		 push	 edx
  00347	50		 push	 eax
  00348	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2414 : 
; 2415 : 		LogAdd(LOG_BLACK, "[DarkSpiritMix] [%s][%s] CBMix Fail %d Money : %d-%d, CharmRate : %d",
; 2416 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate,
; 2417 : 			lpObj->Money, nChaosNeedMoney, iCharmOfLuckCount);

  0034d	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  00353	8b 96 e8 0c 00
	00		 mov	 edx, DWORD PTR [esi+3304]
  00359	53		 push	 ebx
  0035a	57		 push	 edi
  0035b	51		 push	 ecx
  0035c	52		 push	 edx
  0035d	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00360	50		 push	 eax
  00361	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  00364	51		 push	 ecx
  00365	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@ENJLGEHL@?$FLDarkSpiritMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@
  0036a	6a 00		 push	 0
  0036c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00371	83 c4 38	 add	 esp, 56			; 00000038H

; 2418 : 		lpObj->ChaosLock = FALSE;

  00374	e9 57 fe ff ff	 jmp	 $LN41@DarkSpirit
?DarkSpiritChaosMix@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; DarkSpiritChaosMix
_TEXT	ENDS
PUBLIC	??_C@_0DG@ECHLAENJ@?$FLBlessPotionMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@ ; `string'
PUBLIC	??_C@_0DJ@CHGCMDK@?$FLBlessPotionMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@ ; `string'
PUBLIC	??_C@_0CB@EBJOJCKF@?$FLBlessPotionMix?$FN?5Chaos?5Mix?5Start@ ; `string'
PUBLIC	??_C@_0P@NBHFIPDI@BlessPotionMix?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?BlessPotionChaosMix@@YAXPAUOBJECTSTRUCT@@@Z	; BlessPotionChaosMix
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
;	COMDAT ??_C@_0DG@ECHLAENJ@?$FLBlessPotionMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@
CONST	SEGMENT
??_C@_0DG@ECHLAENJ@?$FLBlessPotionMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@ DB '['
	DB	'BlessPotionMix] [%s][%s] CBMix Fail %d Money : %d-%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@CHGCMDK@?$FLBlessPotionMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@
CONST	SEGMENT
??_C@_0DJ@CHGCMDK@?$FLBlessPotionMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@ DB '['
	DB	'BlessPotionMix] [%s][%s] CBMix Success %d Money : %d-%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EBJOJCKF@?$FLBlessPotionMix?$FN?5Chaos?5Mix?5Start@
CONST	SEGMENT
??_C@_0CB@EBJOJCKF@?$FLBlessPotionMix?$FN?5Chaos?5Mix?5Start@ DB '[BlessP'
	DB	'otionMix] Chaos Mix Start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NBHFIPDI@BlessPotionMix?$AA@
CONST	SEGMENT
??_C@_0P@NBHFIPDI@BlessPotionMix?$AA@ DB 'BlessPotionMix', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?BlessPotionChaosMix@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iInvalidItemCount$ = -20				; size = 4
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?BlessPotionChaosMix@@YAXPAUOBJECTSTRUCT@@@Z PROC	; BlessPotionChaosMix, COMDAT

; 2429 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 2430 : 	lpObj->ChaosLock = TRUE;
; 2431 : 	int iBlessGemCount = 0;
; 2432 : 	int iChaosMoney = 0;
; 2433 : 	int iInvalidItemCount = 0;
; 2434 : 
; 2435 : 	PMSG_CHAOSMIXRESULT pMsg;
; 2436 : 
; 2437 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00016	6a 0b		 push	 11			; 0000000bH
  00018	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001b	68 86 00 00 00	 push	 134			; 00000086H
  00020	33 ff		 xor	 edi, edi
  00022	50		 push	 eax
  00023	c7 86 ec 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3308], 1
  0002d	33 db		 xor	 ebx, ebx
  0002f	89 7d ec	 mov	 DWORD PTR _iInvalidItemCount$[ebp], edi
  00032	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2438 : 	pMsg.Result = CB_ERROR;

  0003a	88 5d f3	 mov	 BYTE PTR _pMsg$[ebp+3], bl
  0003d	8d 49 00	 npad	 3
$LL14@BlessPotio:

; 2441 : 	{
; 2442 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00040	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00046	03 cf		 add	 ecx, edi
  00048	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004d	83 f8 01	 cmp	 eax, 1
  00050	75 18		 jne	 SHORT $LN13@BlessPotio

; 2443 : 		{
; 2444 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,13) )

  00052	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00058	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  0005d	66 39 54 39 06	 cmp	 WORD PTR [ecx+edi+6], dx
  00062	75 03		 jne	 SHORT $LN10@BlessPotio

; 2445 : 			{
; 2446 : 				iBlessGemCount++;

  00064	43		 inc	 ebx

; 2447 : 			}
; 2448 : 			else

  00065	eb 03		 jmp	 SHORT $LN13@BlessPotio
$LN10@BlessPotio:

; 2449 : 			{
; 2450 : 				iInvalidItemCount++;

  00067	ff 45 ec	 inc	 DWORD PTR _iInvalidItemCount$[ebp]
$LN13@BlessPotio:

; 2439 : 
; 2440 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  0006a	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00070	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  00076	7c c8		 jl	 SHORT $LL14@BlessPotio

; 2451 : 			}
; 2452 : 		}
; 2453 : 	}
; 2454 : 
; 2455 : 	if ( iBlessGemCount == 0 )

  00078	85 db		 test	 ebx, ebx
  0007a	0f 84 be 01 00
	00		 je	 $LN1@BlessPotio

; 2456 : 		return;
; 2457 : 
; 2458 : 	if ( iInvalidItemCount > 0 )

  00080	83 7d ec 00	 cmp	 DWORD PTR _iInvalidItemCount$[ebp], 0
  00084	0f 8f b4 01 00
	00		 jg	 $LN1@BlessPotio

; 2459 : 		return;
; 2460 : 
; 2461 : 	if ( iBlessGemCount > 25 )

  0008a	83 fb 19	 cmp	 ebx, 25			; 00000019H
  0008d	7e 31		 jle	 SHORT $LN6@BlessPotio

; 2462 : 	{
; 2463 : 		MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(6,201)));

  0008f	68 c9 06 00 00	 push	 1737			; 000006c9H
  00094	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00099	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0009e	50		 push	 eax
  0009f	8b 06		 mov	 eax, DWORD PTR [esi]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 2464 : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  000a7	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000ab	8b 06		 mov	 eax, DWORD PTR [esi]
  000ad	51		 push	 ecx
  000ae	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000b1	52		 push	 edx
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000b8	83 c4 14	 add	 esp, 20			; 00000014H

; 2465 : 		lpObj->ChaosLock = FALSE;
; 2466 : 
; 2467 : 		return;

  000bb	e9 74 01 00 00	 jmp	 $LN19@BlessPotio
$LN6@BlessPotio:

; 2468 : 	}
; 2469 : 
; 2470 : 	LogChaosItem(lpObj, "BlessPotionMix");

  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0P@NBHFIPDI@BlessPotionMix?$AA@
  000c5	56		 push	 esi
  000c6	e8 00 00 00 00	 call	 ?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z ; LogChaosItem

; 2471 : 	LogAdd(LOG_BLACK, "[BlessPotionMix] Chaos Mix Start");

  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@EBJOJCKF@?$FLBlessPotionMix?$FN?5Chaos?5Mix?5Start@
  000d0	6a 00		 push	 0
  000d2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2472 : 	lpObj->ChaosSuccessRate = 100;
; 2473 : 
; 2474 : 	int nChaosNeedMoney = 100000;
; 2475 : 
; 2476 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  000d7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000d9	83 c4 10	 add	 esp, 16			; 00000010H
  000dc	51		 push	 ecx
  000dd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  000e2	c7 86 e8 0c 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+3304], 100 ; 00000064H
  000ec	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  000f1	6a 00		 push	 0
  000f3	99		 cdq
  000f4	68 a0 86 01 00	 push	 100000			; 000186a0H
  000f9	52		 push	 edx
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 __allmul
  00100	6a 00		 push	 0
  00102	6a 64		 push	 100			; 00000064H
  00104	52		 push	 edx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 __alldiv

; 2477 : 
; 2478 : 	if ( iChaosTaxMoney < 0 )

  0010b	85 c0		 test	 eax, eax
  0010d	79 02		 jns	 SHORT $LN5@BlessPotio

; 2479 : 	{
; 2480 : 		iChaosTaxMoney = 0;

  0010f	33 c0		 xor	 eax, eax
$LN5@BlessPotio:

; 2481 : 	}
; 2482 : 
; 2483 : 	nChaosNeedMoney += iChaosTaxMoney;

  00111	8d b8 a0 86 01
	00		 lea	 edi, DWORD PTR [eax+100000]

; 2484 : 
; 2485 : 	if ( nChaosNeedMoney < 0 )

  00117	85 ff		 test	 edi, edi
  00119	79 02		 jns	 SHORT $LN4@BlessPotio

; 2486 : 	{
; 2487 : 		nChaosNeedMoney = 0;

  0011b	33 ff		 xor	 edi, edi
$LN4@BlessPotio:

; 2488 : 	}
; 2489 : 
; 2490 : 	if ( lpObj->Money < nChaosNeedMoney )

  0011d	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  00123	3b cf		 cmp	 ecx, edi
  00125	7d 1d		 jge	 SHORT $LN3@BlessPotio

; 2491 : 	{
; 2492 : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;
; 2493 : 		
; 2494 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  00127	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0012b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0012d	52		 push	 edx
  0012e	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00131	50		 push	 eax
  00132	51		 push	 ecx
  00133	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
  00137	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0013c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2495 : 		lpObj->ChaosLock = FALSE;
; 2496 : 
; 2497 : 		return;

  0013f	e9 f0 00 00 00	 jmp	 $LN19@BlessPotio
$LN3@BlessPotio:

; 2498 : 	}
; 2499 : 
; 2500 : 	lpObj->Money -= nChaosNeedMoney;

  00144	2b cf		 sub	 ecx, edi
  00146	89 8e b0 00 00
	00		 mov	 DWORD PTR [esi+176], ecx

; 2501 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  0014c	50		 push	 eax
  0014d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00152	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 2502 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  00157	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  0015d	8b 06		 mov	 eax, DWORD PTR [esi]
  0015f	52		 push	 edx
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00166	83 c4 08	 add	 esp, 8

; 2503 : 
; 2504 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  00169	e8 00 00 00 00	 call	 _rand
  0016e	99		 cdq
  0016f	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00174	f7 f9		 idiv	 ecx
  00176	3b 96 e8 0c 00
	00		 cmp	 edx, DWORD PTR [esi+3304]
  0017c	7d 71		 jge	 SHORT $LN2@BlessPotio

; 2505 : 	{
; 2506 : 		int ItemNum = ITEMGET(14,7);
; 2507 : 		int Level = 0;
; 2508 : 		int Dur = iBlessGemCount * 10;
; 2509 : 
; 2510 : 		ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ItemNum, Level, Dur, 0, 0, 0, -1, 0, 0);

  0017e	6a 00		 push	 0
  00180	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00182	6a 00		 push	 0
  00184	6a ff		 push	 -1
  00186	8a d3		 mov	 dl, bl
  00188	6a 00		 push	 0
  0018a	02 d2		 add	 dl, dl
  0018c	6a 00		 push	 0
  0018e	02 d2		 add	 dl, dl
  00190	02 da		 add	 bl, dl
  00192	6a 00		 push	 0
  00194	02 db		 add	 bl, bl
  00196	0f b6 c3	 movzx	 eax, bl
  00199	50		 push	 eax
  0019a	6a 00		 push	 0
  0019c	68 07 1c 00 00	 push	 7175			; 00001c07H
  001a1	6a 00		 push	 0
  001a3	6a 00		 push	 0
  001a5	68 ff 00 00 00	 push	 255			; 000000ffH
  001aa	51		 push	 ecx
  001ab	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 2511 : 		::gObjInventoryCommit(lpObj->m_Index);

  001b0	8b 16		 mov	 edx, DWORD PTR [esi]
  001b2	52		 push	 edx
  001b3	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit

; 2512 : 
; 2513 : 		LogAdd(LOG_BLACK, "[BlessPotionMix] [%s][%s] CBMix Success %d Money : %d-%d",
; 2514 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, 
; 2515 : 			lpObj->Money, nChaosNeedMoney);

  001b8	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  001be	8b 8e e8 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3304]
  001c4	57		 push	 edi
  001c5	50		 push	 eax
  001c6	51		 push	 ecx
  001c7	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  001ca	52		 push	 edx
  001cb	83 c6 64	 add	 esi, 100		; 00000064H
  001ce	56		 push	 esi
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@CHGCMDK@?$FLBlessPotionMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@
  001d4	6a 00		 push	 0
  001d6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001db	83 c4 54	 add	 esp, 84			; 00000054H
  001de	5f		 pop	 edi
  001df	5e		 pop	 esi
  001e0	5b		 pop	 ebx

; 2528 : 	}
; 2529 : }

  001e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e4	33 cd		 xor	 ecx, ebp
  001e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c3		 ret	 0
$LN2@BlessPotio:

; 2516 : 	}
; 2517 : 	else
; 2518 : 	{
; 2519 : 		ChaosBoxInit(lpObj);

  001ef	56		 push	 esi
  001f0	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit

; 2520 : 		::GCUserChaosBoxSend(lpObj, 1);

  001f5	6a 01		 push	 1
  001f7	56		 push	 esi
  001f8	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 2521 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  001fd	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00201	8b 16		 mov	 edx, DWORD PTR [esi]
  00203	50		 push	 eax
  00204	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00207	51		 push	 ecx
  00208	52		 push	 edx
  00209	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2522 : 
; 2523 : 		LogAdd(LOG_BLACK, "[BlessPotionMix] [%s][%s] CBMix Fail %d Money : %d-%d",
; 2524 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, 
; 2525 : 			lpObj->Money, nChaosNeedMoney);

  0020e	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  00214	8b 8e e8 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3304]
  0021a	57		 push	 edi
  0021b	50		 push	 eax
  0021c	51		 push	 ecx
  0021d	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  00220	52		 push	 edx
  00221	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  00224	50		 push	 eax
  00225	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@ECHLAENJ@?$FLBlessPotionMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@
  0022a	6a 00		 push	 0
  0022c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00231	83 c4 34	 add	 esp, 52			; 00000034H
$LN19@BlessPotio:

; 2526 : 
; 2527 : 		lpObj->ChaosLock = FALSE;

  00234	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
$LN1@BlessPotio:

; 2528 : 	}
; 2529 : }

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00241	5f		 pop	 edi
  00242	5e		 pop	 esi
  00243	33 cd		 xor	 ecx, ebp
  00245	5b		 pop	 ebx
  00246	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024b	8b e5		 mov	 esp, ebp
  0024d	5d		 pop	 ebp
  0024e	c3		 ret	 0
?BlessPotionChaosMix@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; BlessPotionChaosMix
_TEXT	ENDS
PUBLIC	??_C@_0DF@MJBBEIMO@?$FLSoulPotionMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@ ; `string'
PUBLIC	??_C@_0CA@GHNNBMIL@?$FLSoulPotionMix?$FN?5Chaos?5Mix?5Start?$AA@ ; `string'
PUBLIC	??_C@_0O@KAEODMHN@SoulPotionMix?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?SoulPotionChaosMix@@YAXPAUOBJECTSTRUCT@@@Z	; SoulPotionChaosMix
;	COMDAT ??_C@_0DF@MJBBEIMO@?$FLSoulPotionMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@
CONST	SEGMENT
??_C@_0DF@MJBBEIMO@?$FLSoulPotionMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@ DB '['
	DB	'SoulPotionMix] [%s][%s] CBMix Fail %d Money : %d-%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GHNNBMIL@?$FLSoulPotionMix?$FN?5Chaos?5Mix?5Start?$AA@
CONST	SEGMENT
??_C@_0CA@GHNNBMIL@?$FLSoulPotionMix?$FN?5Chaos?5Mix?5Start?$AA@ DB '[Sou'
	DB	'lPotionMix] Chaos Mix Start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KAEODMHN@SoulPotionMix?$AA@
CONST	SEGMENT
??_C@_0O@KAEODMHN@SoulPotionMix?$AA@ DB 'SoulPotionMix', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SoulPotionChaosMix@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iInvalidItemCount$ = -20				; size = 4
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?SoulPotionChaosMix@@YAXPAUOBJECTSTRUCT@@@Z PROC	; SoulPotionChaosMix, COMDAT

; 2534 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 2535 : 	lpObj->ChaosLock = TRUE;
; 2536 : 	int iSoulGemCount = 0;
; 2537 : 	int iChaosMoney = 0;
; 2538 : 	int iInvalidItemCount = 0;
; 2539 : 
; 2540 : 	PMSG_CHAOSMIXRESULT pMsg;
; 2541 : 
; 2542 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00016	6a 0b		 push	 11			; 0000000bH
  00018	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001b	68 86 00 00 00	 push	 134			; 00000086H
  00020	33 ff		 xor	 edi, edi
  00022	50		 push	 eax
  00023	c7 86 ec 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3308], 1
  0002d	33 db		 xor	 ebx, ebx
  0002f	89 7d ec	 mov	 DWORD PTR _iInvalidItemCount$[ebp], edi
  00032	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2543 : 	pMsg.Result = CB_ERROR;

  0003a	88 5d f3	 mov	 BYTE PTR _pMsg$[ebp+3], bl
  0003d	8d 49 00	 npad	 3
$LL14@SoulPotion:

; 2546 : 	{
; 2547 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00040	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00046	03 cf		 add	 ecx, edi
  00048	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004d	83 f8 01	 cmp	 eax, 1
  00050	75 18		 jne	 SHORT $LN13@SoulPotion

; 2548 : 		{
; 2549 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,14) )

  00052	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00058	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  0005d	66 39 54 39 06	 cmp	 WORD PTR [ecx+edi+6], dx
  00062	75 03		 jne	 SHORT $LN10@SoulPotion

; 2550 : 			{
; 2551 : 				iSoulGemCount++;

  00064	43		 inc	 ebx

; 2552 : 			}
; 2553 : 			else

  00065	eb 03		 jmp	 SHORT $LN13@SoulPotion
$LN10@SoulPotion:

; 2554 : 			{
; 2555 : 				iInvalidItemCount++;

  00067	ff 45 ec	 inc	 DWORD PTR _iInvalidItemCount$[ebp]
$LN13@SoulPotion:

; 2544 : 
; 2545 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  0006a	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00070	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  00076	7c c8		 jl	 SHORT $LL14@SoulPotion

; 2556 : 			}
; 2557 : 		}
; 2558 : 	}
; 2559 : 
; 2560 : 	if ( iSoulGemCount == 0 )

  00078	85 db		 test	 ebx, ebx
  0007a	0f 84 be 01 00
	00		 je	 $LN1@SoulPotion

; 2561 : 		return;
; 2562 : 
; 2563 : 	if ( iInvalidItemCount > 0 )

  00080	83 7d ec 00	 cmp	 DWORD PTR _iInvalidItemCount$[ebp], 0
  00084	0f 8f b4 01 00
	00		 jg	 $LN1@SoulPotion

; 2564 : 		return;
; 2565 : 
; 2566 : 	if ( iSoulGemCount > 25 )

  0008a	83 fb 19	 cmp	 ebx, 25			; 00000019H
  0008d	7e 31		 jle	 SHORT $LN6@SoulPotion

; 2567 : 	{
; 2568 : 		MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(6,201)));

  0008f	68 c9 06 00 00	 push	 1737			; 000006c9H
  00094	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00099	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0009e	50		 push	 eax
  0009f	8b 06		 mov	 eax, DWORD PTR [esi]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 2569 : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  000a7	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000ab	8b 06		 mov	 eax, DWORD PTR [esi]
  000ad	51		 push	 ecx
  000ae	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000b1	52		 push	 edx
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000b8	83 c4 14	 add	 esp, 20			; 00000014H

; 2570 : 		lpObj->ChaosLock = FALSE;
; 2571 : 
; 2572 : 		return;

  000bb	e9 74 01 00 00	 jmp	 $LN19@SoulPotion
$LN6@SoulPotion:

; 2573 : 	}
; 2574 : 
; 2575 : 	LogChaosItem(lpObj, "SoulPotionMix");

  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KAEODMHN@SoulPotionMix?$AA@
  000c5	56		 push	 esi
  000c6	e8 00 00 00 00	 call	 ?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z ; LogChaosItem

; 2576 : 	LogAdd(LOG_BLACK, "[SoulPotionMix] Chaos Mix Start");

  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@GHNNBMIL@?$FLSoulPotionMix?$FN?5Chaos?5Mix?5Start?$AA@
  000d0	6a 00		 push	 0
  000d2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2577 : 	lpObj->ChaosSuccessRate = 100;
; 2578 : 
; 2579 : 	int nChaosNeedMoney = 50000;
; 2580 : 
; 2581 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  000d7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000d9	83 c4 10	 add	 esp, 16			; 00000010H
  000dc	51		 push	 ecx
  000dd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  000e2	c7 86 e8 0c 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+3304], 100 ; 00000064H
  000ec	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  000f1	6a 00		 push	 0
  000f3	99		 cdq
  000f4	68 50 c3 00 00	 push	 50000			; 0000c350H
  000f9	52		 push	 edx
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 __allmul
  00100	6a 00		 push	 0
  00102	6a 64		 push	 100			; 00000064H
  00104	52		 push	 edx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 __alldiv

; 2582 : 
; 2583 : 	if ( iChaosTaxMoney < 0 )

  0010b	85 c0		 test	 eax, eax
  0010d	79 02		 jns	 SHORT $LN5@SoulPotion

; 2584 : 	{
; 2585 : 		iChaosTaxMoney = 0;

  0010f	33 c0		 xor	 eax, eax
$LN5@SoulPotion:

; 2586 : 	}
; 2587 : 
; 2588 : 	nChaosNeedMoney += iChaosTaxMoney;

  00111	8d b8 50 c3 00
	00		 lea	 edi, DWORD PTR [eax+50000]

; 2589 : 
; 2590 : 	if ( nChaosNeedMoney < 0 )

  00117	85 ff		 test	 edi, edi
  00119	79 02		 jns	 SHORT $LN4@SoulPotion

; 2591 : 	{
; 2592 : 		nChaosNeedMoney = 0;

  0011b	33 ff		 xor	 edi, edi
$LN4@SoulPotion:

; 2593 : 	}
; 2594 : 
; 2595 : 	if ( lpObj->Money < nChaosNeedMoney )

  0011d	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  00123	3b cf		 cmp	 ecx, edi
  00125	7d 1d		 jge	 SHORT $LN3@SoulPotion

; 2596 : 	{
; 2597 : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;
; 2598 : 		
; 2599 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  00127	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0012b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0012d	52		 push	 edx
  0012e	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00131	50		 push	 eax
  00132	51		 push	 ecx
  00133	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
  00137	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0013c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2600 : 		lpObj->ChaosLock = FALSE;
; 2601 : 
; 2602 : 		return;

  0013f	e9 f0 00 00 00	 jmp	 $LN19@SoulPotion
$LN3@SoulPotion:

; 2603 : 	}
; 2604 : 
; 2605 : 	lpObj->Money -= nChaosNeedMoney;

  00144	2b cf		 sub	 ecx, edi
  00146	89 8e b0 00 00
	00		 mov	 DWORD PTR [esi+176], ecx

; 2606 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  0014c	50		 push	 eax
  0014d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00152	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 2607 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  00157	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  0015d	8b 06		 mov	 eax, DWORD PTR [esi]
  0015f	52		 push	 edx
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00166	83 c4 08	 add	 esp, 8

; 2608 : 
; 2609 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  00169	e8 00 00 00 00	 call	 _rand
  0016e	99		 cdq
  0016f	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00174	f7 f9		 idiv	 ecx
  00176	3b 96 e8 0c 00
	00		 cmp	 edx, DWORD PTR [esi+3304]
  0017c	7d 71		 jge	 SHORT $LN2@SoulPotion

; 2610 : 	{
; 2611 : 		int ItemNum = ITEMGET(14,7);
; 2612 : 		int Level = 1;
; 2613 : 		int Dur = iSoulGemCount * 10;
; 2614 : 
; 2615 : 		ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ItemNum, Level, Dur, 0, 0, 0, -1, 0, 0);

  0017e	6a 00		 push	 0
  00180	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00182	6a 00		 push	 0
  00184	6a ff		 push	 -1
  00186	8a d3		 mov	 dl, bl
  00188	6a 00		 push	 0
  0018a	02 d2		 add	 dl, dl
  0018c	6a 00		 push	 0
  0018e	02 d2		 add	 dl, dl
  00190	02 da		 add	 bl, dl
  00192	6a 00		 push	 0
  00194	02 db		 add	 bl, bl
  00196	0f b6 c3	 movzx	 eax, bl
  00199	50		 push	 eax
  0019a	6a 01		 push	 1
  0019c	68 07 1c 00 00	 push	 7175			; 00001c07H
  001a1	6a 00		 push	 0
  001a3	6a 00		 push	 0
  001a5	68 ff 00 00 00	 push	 255			; 000000ffH
  001aa	51		 push	 ecx
  001ab	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 2616 : 		::gObjInventoryCommit(lpObj->m_Index);

  001b0	8b 16		 mov	 edx, DWORD PTR [esi]
  001b2	52		 push	 edx
  001b3	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit

; 2617 : 
; 2618 : 		LogAdd(LOG_BLACK, "[BlessPotionMix] [%s][%s] CBMix Success %d Money : %d-%d",	// #error Change to SoulPotionMix
; 2619 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, 
; 2620 : 			lpObj->Money, nChaosNeedMoney);

  001b8	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  001be	8b 8e e8 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3304]
  001c4	57		 push	 edi
  001c5	50		 push	 eax
  001c6	51		 push	 ecx
  001c7	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  001ca	52		 push	 edx
  001cb	83 c6 64	 add	 esi, 100		; 00000064H
  001ce	56		 push	 esi
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@CHGCMDK@?$FLBlessPotionMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5@
  001d4	6a 00		 push	 0
  001d6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001db	83 c4 54	 add	 esp, 84			; 00000054H
  001de	5f		 pop	 edi
  001df	5e		 pop	 esi
  001e0	5b		 pop	 ebx

; 2633 : 	}
; 2634 : }

  001e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e4	33 cd		 xor	 ecx, ebp
  001e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c3		 ret	 0
$LN2@SoulPotion:

; 2621 : 	}
; 2622 : 	else
; 2623 : 	{
; 2624 : 		ChaosBoxInit(lpObj);

  001ef	56		 push	 esi
  001f0	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit

; 2625 : 		::GCUserChaosBoxSend(lpObj, 1);

  001f5	6a 01		 push	 1
  001f7	56		 push	 esi
  001f8	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 2626 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  001fd	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00201	8b 16		 mov	 edx, DWORD PTR [esi]
  00203	50		 push	 eax
  00204	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00207	51		 push	 ecx
  00208	52		 push	 edx
  00209	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2627 : 
; 2628 : 		LogAdd(LOG_BLACK, "[SoulPotionMix] [%s][%s] CBMix Fail %d Money : %d-%d",
; 2629 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, 
; 2630 : 			lpObj->Money, nChaosNeedMoney);

  0020e	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  00214	8b 8e e8 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3304]
  0021a	57		 push	 edi
  0021b	50		 push	 eax
  0021c	51		 push	 ecx
  0021d	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  00220	52		 push	 edx
  00221	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  00224	50		 push	 eax
  00225	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@MJBBEIMO@?$FLSoulPotionMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@
  0022a	6a 00		 push	 0
  0022c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00231	83 c4 34	 add	 esp, 52			; 00000034H
$LN19@SoulPotion:

; 2631 : 
; 2632 : 		lpObj->ChaosLock = FALSE;

  00234	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
$LN1@SoulPotion:

; 2633 : 	}
; 2634 : }

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00241	5f		 pop	 edi
  00242	5e		 pop	 esi
  00243	33 cd		 xor	 ecx, ebp
  00245	5b		 pop	 ebx
  00246	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024b	8b e5		 mov	 esp, ebp
  0024d	5d		 pop	 ebp
  0024e	c3		 ret	 0
?SoulPotionChaosMix@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; SoulPotionChaosMix
_TEXT	ENDS
PUBLIC	??_C@_0DE@PMLDDIAP@?$FLLifeStoneMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@ ; `string'
PUBLIC	??_C@_0DH@GNDOFGHL@?$FLLifeStoneMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@ ; `string'
PUBLIC	??_C@_0BP@OKAOMBJE@?$FLLifeStoneMix?$FN?5Chaos?5Mix?5Start?$AA@ ; `string'
PUBLIC	??_C@_0N@FJGBJPII@LifeStoneMix?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LifeStoneChaosMix@@YAXPAUOBJECTSTRUCT@@@Z	; LifeStoneChaosMix
;	COMDAT ??_C@_0DE@PMLDDIAP@?$FLLifeStoneMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@
CONST	SEGMENT
??_C@_0DE@PMLDDIAP@?$FLLifeStoneMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@ DB '['
	DB	'LifeStoneMix] [%s][%s] CBMix Fail %d Money : %d-%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@GNDOFGHL@?$FLLifeStoneMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@
CONST	SEGMENT
??_C@_0DH@GNDOFGHL@?$FLLifeStoneMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@ DB '['
	DB	'LifeStoneMix] [%s][%s] CBMix Success %d Money : %d-%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OKAOMBJE@?$FLLifeStoneMix?$FN?5Chaos?5Mix?5Start?$AA@
CONST	SEGMENT
??_C@_0BP@OKAOMBJE@?$FLLifeStoneMix?$FN?5Chaos?5Mix?5Start?$AA@ DB '[Life'
	DB	'StoneMix] Chaos Mix Start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FJGBJPII@LifeStoneMix?$AA@
CONST	SEGMENT
??_C@_0N@FJGBJPII@LifeStoneMix?$AA@ DB 'LifeStoneMix', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LifeStoneChaosMix@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iSoulGemCount$ = -32					; size = 4
_iBlessGemCount$ = -28					; size = 4
_iInvalidItemCount$ = -24				; size = 4
_iProtectionGemCount$ = -20				; size = 4
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?LifeStoneChaosMix@@YAXPAUOBJECTSTRUCT@@@Z PROC		; LifeStoneChaosMix, COMDAT

; 2641 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 2642 : 	lpObj->ChaosLock = TRUE;
; 2643 : 	int iChoasGemCount = 0;
; 2644 : 	int iBlessGemCount = 0;
; 2645 : 	int iSoulGemCount = 0;
; 2646 : 	int iProtectionGemCount = 0;
; 2647 : 	int iInvalidItemCount = 0;
; 2648 : 	int iChaosMoney = 0;
; 2649 : 
; 2650 : 	PMSG_CHAOSMIXRESULT pMsg;
; 2651 : 
; 2652 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00016	6a 0b		 push	 11			; 0000000bH
  00018	33 ff		 xor	 edi, edi
  0001a	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001d	68 86 00 00 00	 push	 134			; 00000086H
  00022	50		 push	 eax
  00023	c7 86 ec 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3308], 1
  0002d	33 db		 xor	 ebx, ebx
  0002f	89 7d e4	 mov	 DWORD PTR _iBlessGemCount$[ebp], edi
  00032	89 7d e0	 mov	 DWORD PTR _iSoulGemCount$[ebp], edi
  00035	89 7d ec	 mov	 DWORD PTR _iProtectionGemCount$[ebp], edi
  00038	89 7d e8	 mov	 DWORD PTR _iInvalidItemCount$[ebp], edi
  0003b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2653 : 	pMsg.Result = CB_ERROR;

  00043	88 5d f3	 mov	 BYTE PTR _pMsg$[ebp+3], bl
  00046	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL19@LifeStoneC:

; 2657 : 	{
; 2658 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00050	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00056	03 cf		 add	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005d	b9 01 00 00 00	 mov	 ecx, 1
  00062	3b c1		 cmp	 eax, ecx
  00064	75 49		 jne	 SHORT $LN18@LifeStoneC

; 2659 : 		{
; 2660 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,13) )

  00066	8b 96 dc 0c 00
	00		 mov	 edx, DWORD PTR [esi+3292]
  0006c	0f b7 44 3a 06	 movzx	 eax, WORD PTR [edx+edi+6]
  00071	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  00076	66 3b c2	 cmp	 ax, dx
  00079	75 05		 jne	 SHORT $LN15@LifeStoneC

; 2661 : 			{
; 2662 : 				iBlessGemCount++;

  0007b	01 4d e4	 add	 DWORD PTR _iBlessGemCount$[ebp], ecx
  0007e	eb 2f		 jmp	 SHORT $LN18@LifeStoneC
$LN15@LifeStoneC:

; 2663 : 			}
; 2664 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,14) )

  00080	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  00085	66 3b c2	 cmp	 ax, dx
  00088	75 05		 jne	 SHORT $LN13@LifeStoneC

; 2665 : 			{
; 2666 : 				iSoulGemCount++;

  0008a	01 4d e0	 add	 DWORD PTR _iSoulGemCount$[ebp], ecx
  0008d	eb 20		 jmp	 SHORT $LN18@LifeStoneC
$LN13@LifeStoneC:

; 2667 : 			}
; 2668 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,31) )	// Guardian Jewel

  0008f	ba 1f 1c 00 00	 mov	 edx, 7199		; 00001c1fH
  00094	66 3b c2	 cmp	 ax, dx
  00097	75 05		 jne	 SHORT $LN11@LifeStoneC

; 2669 : 			{
; 2670 : 				iProtectionGemCount++;

  00099	01 4d ec	 add	 DWORD PTR _iProtectionGemCount$[ebp], ecx
  0009c	eb 11		 jmp	 SHORT $LN18@LifeStoneC
$LN11@LifeStoneC:

; 2671 : 			}
; 2672 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,15) )	// Habla pe super CHOAS

  0009e	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  000a3	66 3b c2	 cmp	 ax, dx
  000a6	75 04		 jne	 SHORT $LN9@LifeStoneC

; 2673 : 			{
; 2674 : 				iChoasGemCount++;

  000a8	03 d9		 add	 ebx, ecx

; 2675 : 			}
; 2676 : 			else 

  000aa	eb 03		 jmp	 SHORT $LN18@LifeStoneC
$LN9@LifeStoneC:

; 2677 : 			{
; 2678 : 				iInvalidItemCount++;

  000ac	01 4d e8	 add	 DWORD PTR _iInvalidItemCount$[ebp], ecx
$LN18@LifeStoneC:

; 2654 : 
; 2655 : 
; 2656 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  000af	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  000b5	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  000bb	7c 93		 jl	 SHORT $LL19@LifeStoneC

; 2679 : 			}
; 2680 : 		}
; 2681 : 	}
; 2682 : 
; 2683 : 	if ( iChoasGemCount != 1 || iBlessGemCount != 5 || iSoulGemCount != 5 || iProtectionGemCount != 1 || iInvalidItemCount > 0 )

  000bd	3b d9		 cmp	 ebx, ecx
  000bf	0f 85 80 01 00
	00		 jne	 $LN24@LifeStoneC
  000c5	b8 05 00 00 00	 mov	 eax, 5
  000ca	39 45 e4	 cmp	 DWORD PTR _iBlessGemCount$[ebp], eax
  000cd	0f 85 72 01 00
	00		 jne	 $LN24@LifeStoneC
  000d3	39 45 e0	 cmp	 DWORD PTR _iSoulGemCount$[ebp], eax
  000d6	0f 85 69 01 00
	00		 jne	 $LN24@LifeStoneC
  000dc	39 4d ec	 cmp	 DWORD PTR _iProtectionGemCount$[ebp], ecx
  000df	0f 85 60 01 00
	00		 jne	 $LN24@LifeStoneC
  000e5	33 db		 xor	 ebx, ebx
  000e7	39 5d e8	 cmp	 DWORD PTR _iInvalidItemCount$[ebp], ebx
  000ea	0f 8f 57 01 00
	00		 jg	 $LN6@LifeStoneC

; 2686 : 		lpObj->ChaosLock = FALSE;
; 2687 : 
; 2688 : 		return;
; 2689 : 	}
; 2690 : 
; 2691 : 	LogChaosItem(lpObj, "LifeStoneMix");

  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FJGBJPII@LifeStoneMix?$AA@
  000f5	56		 push	 esi
  000f6	e8 00 00 00 00	 call	 ?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z ; LogChaosItem

; 2692 : 	LogAdd(LOG_BLACK, "[LifeStoneMix] Chaos Mix Start");

  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OKAOMBJE@?$FLLifeStoneMix?$FN?5Chaos?5Mix?5Start?$AA@
  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2693 : 	lpObj->ChaosSuccessRate = 100;
; 2694 : 
; 2695 : 	int nChaosNeedMoney = 5000000;
; 2696 : 
; 2697 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  00106	8b 06		 mov	 eax, DWORD PTR [esi]
  00108	83 c4 10	 add	 esp, 16			; 00000010H
  0010b	50		 push	 eax
  0010c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00111	c7 86 e8 0c 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+3304], 100 ; 00000064H
  0011b	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00120	53		 push	 ebx
  00121	99		 cdq
  00122	68 40 4b 4c 00	 push	 5000000			; 004c4b40H
  00127	52		 push	 edx
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 __allmul
  0012e	53		 push	 ebx
  0012f	6a 64		 push	 100			; 00000064H
  00131	52		 push	 edx
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 __alldiv

; 2698 : 
; 2699 : 	if ( iChaosTaxMoney < 0 )

  00138	3b c3		 cmp	 eax, ebx
  0013a	7d 02		 jge	 SHORT $LN5@LifeStoneC

; 2700 : 	{
; 2701 : 		iChaosTaxMoney = 0;

  0013c	33 c0		 xor	 eax, eax
$LN5@LifeStoneC:

; 2702 : 	}
; 2703 : 
; 2704 : 	nChaosNeedMoney += iChaosTaxMoney;

  0013e	8d b8 40 4b 4c
	00		 lea	 edi, DWORD PTR [eax+5000000]

; 2705 : 
; 2706 : 	if ( nChaosNeedMoney < 0 )

  00144	3b fb		 cmp	 edi, ebx
  00146	7d 02		 jge	 SHORT $LN4@LifeStoneC

; 2707 : 	{
; 2708 : 		nChaosNeedMoney = 0;

  00148	33 ff		 xor	 edi, edi
$LN4@LifeStoneC:

; 2709 : 	}
; 2710 : 
; 2711 : 	if ( lpObj->Money < nChaosNeedMoney )

  0014a	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  00150	3b cf		 cmp	 ecx, edi
  00152	7d 15		 jge	 SHORT $LN3@LifeStoneC

; 2712 : 	{
; 2713 : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;
; 2714 : 		
; 2715 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  00154	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00158	8b 06		 mov	 eax, DWORD PTR [esi]
  0015a	51		 push	 ecx
  0015b	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0015e	52		 push	 edx
  0015f	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
  00163	50		 push	 eax

; 2716 : 		lpObj->ChaosLock = FALSE;
; 2717 : 
; 2718 : 		return;

  00164	e9 ea 00 00 00	 jmp	 $LN25@LifeStoneC
$LN3@LifeStoneC:

; 2719 : 	}
; 2720 : 
; 2721 : 	lpObj->Money -= nChaosNeedMoney;

  00169	2b cf		 sub	 ecx, edi
  0016b	89 8e b0 00 00
	00		 mov	 DWORD PTR [esi+176], ecx

; 2722 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  00171	50		 push	 eax
  00172	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00177	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 2723 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  0017c	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  00182	8b 16		 mov	 edx, DWORD PTR [esi]
  00184	51		 push	 ecx
  00185	52		 push	 edx
  00186	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0018b	83 c4 08	 add	 esp, 8

; 2724 : 
; 2725 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  0018e	e8 00 00 00 00	 call	 _rand
  00193	99		 cdq
  00194	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00199	f7 f9		 idiv	 ecx
  0019b	3b 96 e8 0c 00
	00		 cmp	 edx, DWORD PTR [esi+3304]
  001a1	7d 5c		 jge	 SHORT $LN2@LifeStoneC

; 2726 : 	{
; 2727 : 		ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ITEMGET(13,11) , 1, 0, 0, 0, 0, -1, 0, 0);

  001a3	53		 push	 ebx
  001a4	8b 16		 mov	 edx, DWORD PTR [esi]
  001a6	53		 push	 ebx
  001a7	6a ff		 push	 -1
  001a9	53		 push	 ebx
  001aa	53		 push	 ebx
  001ab	53		 push	 ebx
  001ac	53		 push	 ebx
  001ad	6a 01		 push	 1
  001af	68 0b 1a 00 00	 push	 6667			; 00001a0bH
  001b4	53		 push	 ebx
  001b5	53		 push	 ebx
  001b6	68 ff 00 00 00	 push	 255			; 000000ffH
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 2728 : 		::gObjInventoryCommit(lpObj->m_Index);

  001c1	8b 06		 mov	 eax, DWORD PTR [esi]
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit

; 2729 : 
; 2730 : 		LogAdd(LOG_BLACK, "[LifeStoneMix] [%s][%s] CBMix Success %d Money : %d-%d",
; 2731 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, 
; 2732 : 			lpObj->Money, nChaosNeedMoney);

  001c9	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  001cf	8b 96 e8 0c 00
	00		 mov	 edx, DWORD PTR [esi+3304]
  001d5	57		 push	 edi
  001d6	51		 push	 ecx
  001d7	52		 push	 edx
  001d8	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  001db	50		 push	 eax
  001dc	83 c6 64	 add	 esi, 100		; 00000064H
  001df	56		 push	 esi
  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@GNDOFGHL@?$FLLifeStoneMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@
  001e5	53		 push	 ebx
  001e6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001eb	83 c4 54	 add	 esp, 84			; 00000054H
  001ee	5f		 pop	 edi
  001ef	5e		 pop	 esi
  001f0	5b		 pop	 ebx

; 2745 : 	}
; 2746 : }

  001f1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f4	33 cd		 xor	 ecx, ebp
  001f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fb	8b e5		 mov	 esp, ebp
  001fd	5d		 pop	 ebp
  001fe	c3		 ret	 0
$LN2@LifeStoneC:

; 2733 : 	}
; 2734 : 	else
; 2735 : 	{
; 2736 : 		ChaosBoxInit(lpObj);

  001ff	56		 push	 esi
  00200	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit

; 2737 : 		::GCUserChaosBoxSend(lpObj, 1);

  00205	6a 01		 push	 1
  00207	56		 push	 esi
  00208	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 2738 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0020d	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00211	8b 06		 mov	 eax, DWORD PTR [esi]
  00213	51		 push	 ecx
  00214	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00217	52		 push	 edx
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2739 : 
; 2740 : 		LogAdd(LOG_BLACK, "[LifeStoneMix] [%s][%s] CBMix Fail %d Money : %d-%d",
; 2741 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, 
; 2742 : 			lpObj->Money, nChaosNeedMoney);

  0021e	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  00224	8b 96 e8 0c 00
	00		 mov	 edx, DWORD PTR [esi+3304]
  0022a	57		 push	 edi
  0022b	51		 push	 ecx
  0022c	52		 push	 edx
  0022d	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00230	50		 push	 eax
  00231	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  00234	51		 push	 ecx
  00235	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@PMLDDIAP@?$FLLifeStoneMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@
  0023a	53		 push	 ebx
  0023b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00240	83 c4 34	 add	 esp, 52			; 00000034H

; 2743 : 
; 2744 : 		lpObj->ChaosLock = FALSE;

  00243	eb 16		 jmp	 SHORT $LN26@LifeStoneC
$LN24@LifeStoneC:
  00245	33 db		 xor	 ebx, ebx
$LN6@LifeStoneC:

; 2684 : 	{
; 2685 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00247	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0024b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0024d	52		 push	 edx
  0024e	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00251	50		 push	 eax
  00252	51		 push	 ecx
$LN25@LifeStoneC:
  00253	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00258	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@LifeStoneC:

; 2745 : 	}
; 2746 : }

  0025b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025e	5f		 pop	 edi
  0025f	89 9e ec 0c 00
	00		 mov	 DWORD PTR [esi+3308], ebx
  00265	5e		 pop	 esi
  00266	33 cd		 xor	 ecx, ebp
  00268	5b		 pop	 ebx
  00269	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0026e	8b e5		 mov	 esp, ebp
  00270	5d		 pop	 ebp
  00271	c3		 ret	 0
?LifeStoneChaosMix@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; LifeStoneChaosMix
_TEXT	ENDS
PUBLIC	??_C@_0DH@JBMEKCLH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0FB@PDPGCOFM@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0DN@CFIDABAI@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0DE@FILNLJPO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0BH@FJMEBBCF@Hidden?5TreasureBox?5Mix?$AA@ ; `string'
PUBLIC	??_C@_0DE@OHGHLCDC@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?HiddenTreasureBoxItemMix@@YAXPAUOBJECTSTRUCT@@@Z ; HiddenTreasureBoxItemMix
;	COMDAT ??_C@_0DH@JBMEKCLH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0DH@JBMEKCLH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] CBMix Fail Rate:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@PDPGCOFM@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0FB@PDPGCOFM@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] CBMix Failed - iCrystalMix'
	DB	'Type is wrong : %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CFIDABAI@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0DN@CFIDABAI@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] CBMix Success:%d Type:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FILNLJPO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0DE@FILNLJPO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Chaos Mix Start', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FJMEBBCF@Hidden?5TreasureBox?5Mix?$AA@
CONST	SEGMENT
??_C@_0BH@FJMEBBCF@Hidden?5TreasureBox?5Mix?$AA@ DB 'Hidden TreasureBox M'
	DB	'ix', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OHGHLCDC@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0DE@OHGHLCDC@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Item Mix Failed', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?HiddenTreasureBoxItemMix@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iInvalidItemCount$ = -36				; size = 4
_iRedCrystal$ = -32					; size = 4
tv329 = -28						; size = 4
_iBlueCrystal$ = -28					; size = 4
_iBlackCrystal$ = -24					; size = 4
_iCrystalMixType$ = -20					; size = 4
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?HiddenTreasureBoxItemMix@@YAXPAUOBJECTSTRUCT@@@Z PROC	; HiddenTreasureBoxItemMix, COMDAT

; 2949 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 2950 : 	lpObj->ChaosLock = TRUE;
; 2951 : 	int iBlueCrystal = 0;
; 2952 : 	int iRedCrystal = 0;
; 2953 : 	int iBlackCrystal = 0;
; 2954 : 	int iInvalidItemCount = 0;
; 2955 : 	int iChaosMoney = 0;
; 2956 : 
; 2957 : 	PMSG_CHAOSMIXRESULT pMsg;
; 2958 : 
; 2959 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00016	6a 0b		 push	 11			; 0000000bH
  00018	33 ff		 xor	 edi, edi
  0001a	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001d	68 86 00 00 00	 push	 134			; 00000086H
  00022	bb 01 00 00 00	 mov	 ebx, 1
  00027	50		 push	 eax
  00028	89 9e ec 0c 00
	00		 mov	 DWORD PTR [esi+3308], ebx
  0002e	89 7d e4	 mov	 DWORD PTR _iBlueCrystal$[ebp], edi
  00031	89 7d e0	 mov	 DWORD PTR _iRedCrystal$[ebp], edi
  00034	89 7d e8	 mov	 DWORD PTR _iBlackCrystal$[ebp], edi
  00037	89 7d dc	 mov	 DWORD PTR _iInvalidItemCount$[ebp], edi
  0003a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2960 : 	pMsg.Result = CB_ERROR;

  00042	c6 45 f3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  00046	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL31@HiddenTrea:

; 2964 : 	{
; 2965 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00050	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3292]
  00056	03 cf		 add	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005d	3b c3		 cmp	 eax, ebx
  0005f	75 35		 jne	 SHORT $LN30@HiddenTrea

; 2966 : 		{
; 2967 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,26) )

  00061	8b 86 dc 0c 00
	00		 mov	 eax, DWORD PTR [esi+3292]
  00067	ba 1a 18 00 00	 mov	 edx, 6170		; 0000181aH
  0006c	66 39 54 38 06	 cmp	 WORD PTR [eax+edi+6], dx
  00071	75 20		 jne	 SHORT $LN27@HiddenTrea

; 2968 : 			{
; 2969 : 				switch ( lpObj->pChaosBox[n].m_Level )

  00073	0f bf 44 38 08	 movsx	 eax, WORD PTR [eax+edi+8]
  00078	2b c3		 sub	 eax, ebx
  0007a	74 12		 je	 SHORT $LN24@HiddenTrea
  0007c	2b c3		 sub	 eax, ebx
  0007e	74 09		 je	 SHORT $LN23@HiddenTrea
  00080	2b c3		 sub	 eax, ebx
  00082	75 12		 jne	 SHORT $LN30@HiddenTrea

; 2977 : 					case 3:
; 2978 : 						iBlackCrystal++;

  00084	01 5d e8	 add	 DWORD PTR _iBlackCrystal$[ebp], ebx

; 2979 : 						break;

  00087	eb 0d		 jmp	 SHORT $LN30@HiddenTrea
$LN23@HiddenTrea:

; 2973 : 						break;
; 2974 : 					case 2:
; 2975 : 						iBlueCrystal++;

  00089	01 5d e4	 add	 DWORD PTR _iBlueCrystal$[ebp], ebx

; 2976 : 						break;

  0008c	eb 08		 jmp	 SHORT $LN30@HiddenTrea
$LN24@HiddenTrea:

; 2970 : 				{
; 2971 : 					case 1:
; 2972 : 						iRedCrystal++;

  0008e	01 5d e0	 add	 DWORD PTR _iRedCrystal$[ebp], ebx

; 2980 : 				}
; 2981 : 			}
; 2982 : 			else

  00091	eb 03		 jmp	 SHORT $LN30@HiddenTrea
$LN27@HiddenTrea:

; 2983 : 			{
; 2984 : 				iInvalidItemCount++;

  00093	01 5d dc	 add	 DWORD PTR _iInvalidItemCount$[ebp], ebx
$LN30@HiddenTrea:

; 2961 : 
; 2962 : 
; 2963 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00096	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  0009c	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  000a2	7c ac		 jl	 SHORT $LL31@HiddenTrea

; 2985 : 			}
; 2986 : 		}
; 2987 : 	}
; 2988 : 
; 2989 : 	int iCrystalMixType = -1;
; 2990 : 
; 2991 : 	if ( iInvalidItemCount == 0 )

  000a4	33 ff		 xor	 edi, edi
  000a6	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _iCrystalMixType$[ebp], -1
  000ad	39 7d dc	 cmp	 DWORD PTR _iInvalidItemCount$[ebp], edi
  000b0	0f 85 3a 02 00
	00		 jne	 $LN20@HiddenTrea

; 2992 : 	{
; 2993 : 		if ( iBlueCrystal == 7 )

  000b6	8b 45 e4	 mov	 eax, DWORD PTR _iBlueCrystal$[ebp]
  000b9	83 f8 07	 cmp	 eax, 7
  000bc	75 24		 jne	 SHORT $LN19@HiddenTrea

; 2994 : 		{
; 2995 : 			if ( iRedCrystal == 0 && iBlackCrystal == 0 )

  000be	39 7d e0	 cmp	 DWORD PTR _iRedCrystal$[ebp], edi
  000c1	0f 85 ae 00 00
	00		 jne	 $LN9@HiddenTrea
  000c7	39 7d e8	 cmp	 DWORD PTR _iBlackCrystal$[ebp], edi
  000ca	0f 85 a5 00 00
	00		 jne	 $LN9@HiddenTrea

; 2996 : 			{
; 2997 : 				iCrystalMixType = 0;

  000d0	89 7d ec	 mov	 DWORD PTR _iCrystalMixType$[ebp], edi

; 2998 : 				lpObj->ChaosSuccessRate = 100;

  000d3	c7 86 e8 0c 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+3304], 100 ; 00000064H

; 2999 : 			}
; 3000 : 		}

  000dd	e9 93 00 00 00	 jmp	 $LN9@HiddenTrea
$LN19@HiddenTrea:

; 3001 : 		else if ( iRedCrystal == 5 )

  000e2	8b 4d e0	 mov	 ecx, DWORD PTR _iRedCrystal$[ebp]
  000e5	83 f9 05	 cmp	 ecx, 5
  000e8	75 1c		 jne	 SHORT $LN16@HiddenTrea

; 3002 : 		{
; 3003 : 			if ( iBlueCrystal == 0 && iBlackCrystal == 0 )

  000ea	3b c7		 cmp	 eax, edi
  000ec	0f 85 83 00 00
	00		 jne	 $LN9@HiddenTrea
  000f2	39 7d e8	 cmp	 DWORD PTR _iBlackCrystal$[ebp], edi
  000f5	75 7e		 jne	 SHORT $LN9@HiddenTrea

; 3004 : 			{
; 3005 : 				iCrystalMixType = 1;

  000f7	89 5d ec	 mov	 DWORD PTR _iCrystalMixType$[ebp], ebx

; 3006 : 				lpObj->ChaosSuccessRate = 100;

  000fa	c7 86 e8 0c 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+3304], 100 ; 00000064H

; 3007 : 			}
; 3008 : 		}

  00104	eb 6f		 jmp	 SHORT $LN9@HiddenTrea
$LN16@HiddenTrea:

; 3009 : 		else if ( iBlackCrystal == 3 )

  00106	8b 55 e8	 mov	 edx, DWORD PTR _iBlackCrystal$[ebp]
  00109	83 fa 03	 cmp	 edx, 3
  0010c	75 1b		 jne	 SHORT $LN13@HiddenTrea

; 3010 : 		{
; 3011 : 			if ( iRedCrystal == 0 && iBlueCrystal == 0 )

  0010e	3b cf		 cmp	 ecx, edi
  00110	75 63		 jne	 SHORT $LN9@HiddenTrea
  00112	3b c7		 cmp	 eax, edi
  00114	75 5f		 jne	 SHORT $LN9@HiddenTrea

; 3012 : 			{
; 3013 : 				iCrystalMixType = 2;

  00116	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _iCrystalMixType$[ebp], 2

; 3014 : 				lpObj->ChaosSuccessRate = 100;

  0011d	c7 86 e8 0c 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+3304], 100 ; 00000064H

; 3015 : 			}
; 3016 : 		}

  00127	eb 4c		 jmp	 SHORT $LN9@HiddenTrea
$LN13@HiddenTrea:

; 3017 : 		else if ( iBlueCrystal == 1 && iRedCrystal == 1 && iBlackCrystal == 1 )

  00129	3b c3		 cmp	 eax, ebx
  0012b	75 1b		 jne	 SHORT $LN10@HiddenTrea
  0012d	3b cb		 cmp	 ecx, ebx
  0012f	75 17		 jne	 SHORT $LN10@HiddenTrea
  00131	3b d3		 cmp	 edx, ebx
  00133	75 13		 jne	 SHORT $LN10@HiddenTrea

; 3018 : 		{
; 3019 : 			{
; 3020 : 				iCrystalMixType = 3;

  00135	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _iCrystalMixType$[ebp], 3

; 3021 : 				lpObj->ChaosSuccessRate = 100;

  0013c	c7 86 e8 0c 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+3304], 100 ; 00000064H

; 3022 : 			}
; 3023 : 		}
; 3024 : 		else

  00146	eb 2d		 jmp	 SHORT $LN9@HiddenTrea
$LN10@HiddenTrea:

; 3025 : 		{
; 3026 : 			LogAdd(LOG_BLACK, "[Hidden TreasureBox Event] [%s][%s] Item Mix Failed",
; 3027 : 				lpObj->AccountID, lpObj->Name);

  00148	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  0014b	50		 push	 eax
  0014c	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  0014f	51		 push	 ecx
  00150	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@OHGHLCDC@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  00155	57		 push	 edi
  00156	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 3028 : 		
; 3029 : 			DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0015b	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0015f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00161	52		 push	 edx
  00162	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00165	50		 push	 eax
  00166	51		 push	 ecx
  00167	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0016c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3030 : 			lpObj->ChaosLock = FALSE;

  0016f	89 be ec 0c 00
	00		 mov	 DWORD PTR [esi+3308], edi
$LN9@HiddenTrea:

; 3039 : 		lpObj->ChaosLock = FALSE;
; 3040 : 
; 3041 : 		return;
; 3042 : 	}
; 3043 : 
; 3044 : 
; 3045 : 	LogChaosItem(lpObj, "Hidden TreasureBox Mix");

  00175	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FJMEBBCF@Hidden?5TreasureBox?5Mix?$AA@
  0017a	56		 push	 esi
  0017b	e8 00 00 00 00	 call	 ?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z ; LogChaosItem

; 3046 : 	LogAdd(LOG_BLACK, "[Hidden TreasureBox Event] [%s][%s] Chaos Mix Start",
; 3047 : 		lpObj->AccountID, lpObj->Name);

  00180	8d 7e 6f	 lea	 edi, DWORD PTR [esi+111]
  00183	57		 push	 edi
  00184	8d 5e 64	 lea	 ebx, DWORD PTR [esi+100]
  00187	53		 push	 ebx
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@FILNLJPO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  0018d	6a 00		 push	 0
  0018f	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 3048 : 
; 3049 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  00194	8b 96 e8 0c 00
	00		 mov	 edx, DWORD PTR [esi+3304]
  0019a	83 c4 18	 add	 esp, 24			; 00000018H
  0019d	89 55 e4	 mov	 DWORD PTR tv329[ebp], edx
  001a0	e8 00 00 00 00	 call	 _rand
  001a5	99		 cdq
  001a6	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001ab	f7 f9		 idiv	 ecx
  001ad	8b 45 e4	 mov	 eax, DWORD PTR tv329[ebp]
  001b0	3b d0		 cmp	 edx, eax
  001b2	0f 8d e2 00 00
	00		 jge	 $LN7@HiddenTrea

; 3050 : 	{
; 3051 : 		switch ( iCrystalMixType )

  001b8	8b 45 ec	 mov	 eax, DWORD PTR _iCrystalMixType$[ebp]
  001bb	85 c0		 test	 eax, eax
  001bd	0f 88 99 00 00
	00		 js	 $LN2@HiddenTrea
  001c3	83 f8 02	 cmp	 eax, 2
  001c6	7e 2c		 jle	 SHORT $LN4@HiddenTrea
  001c8	83 f8 03	 cmp	 eax, 3
  001cb	0f 85 8b 00 00
	00		 jne	 $LN2@HiddenTrea

; 3055 : 				break;
; 3056 : 			case 3:
; 3057 : 				ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ITEMGET(12,26) , 5, 1, 0, 0, 0, -1, 0, 0);

  001d1	6a 00		 push	 0
  001d3	8b 16		 mov	 edx, DWORD PTR [esi]
  001d5	6a 00		 push	 0
  001d7	6a ff		 push	 -1
  001d9	6a 00		 push	 0
  001db	6a 00		 push	 0
  001dd	6a 00		 push	 0
  001df	6a 01		 push	 1
  001e1	6a 05		 push	 5
  001e3	68 1a 18 00 00	 push	 6170			; 0000181aH
  001e8	6a 00		 push	 0
  001ea	6a 00		 push	 0
  001ec	68 ff 00 00 00	 push	 255			; 000000ffH
  001f1	52		 push	 edx

; 3058 : 				break;

  001f2	eb 21		 jmp	 SHORT $LN36@HiddenTrea
$LN4@HiddenTrea:

; 3052 : 		{
; 3053 : 			case 0:	case 1:	case 2:
; 3054 : 				ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ITEMGET(12,26) , 4, 1, 0, 0, 0, -1, 0, 0);

  001f4	6a 00		 push	 0
  001f6	8b 06		 mov	 eax, DWORD PTR [esi]
  001f8	6a 00		 push	 0
  001fa	6a ff		 push	 -1
  001fc	6a 00		 push	 0
  001fe	6a 00		 push	 0
  00200	6a 00		 push	 0
  00202	6a 01		 push	 1
  00204	6a 04		 push	 4
  00206	68 1a 18 00 00	 push	 6170			; 0000181aH
  0020b	6a 00		 push	 0
  0020d	6a 00		 push	 0
  0020f	68 ff 00 00 00	 push	 255			; 000000ffH
  00214	50		 push	 eax
$LN36@HiddenTrea:
  00215	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 3064 : 				return;
; 3065 : 		}
; 3066 : 
; 3067 : 		::gObjInventoryCommit(lpObj->m_Index);

  0021a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0021c	83 c4 34	 add	 esp, 52			; 00000034H
  0021f	51		 push	 ecx
  00220	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit

; 3068 : 		LogAdd(LOG_BLACK, "[Hidden TreasureBox Event] [%s][%s] CBMix Success:%d Type:%d",
; 3069 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, iCrystalMixType);

  00225	8b 55 ec	 mov	 edx, DWORD PTR _iCrystalMixType$[ebp]
  00228	8b 86 e8 0c 00
	00		 mov	 eax, DWORD PTR [esi+3304]
  0022e	52		 push	 edx
  0022f	50		 push	 eax
  00230	57		 push	 edi
  00231	53		 push	 ebx
  00232	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@CFIDABAI@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  00237	6a 00		 push	 0
  00239	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0023e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00241	5f		 pop	 edi

; 3081 : 	}
; 3082 : 
; 3083 : 	lpObj->ChaosLock = FALSE;

  00242	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  0024c	5e		 pop	 esi
  0024d	5b		 pop	 ebx

; 3084 : }

  0024e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00251	33 cd		 xor	 ecx, ebp
  00253	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c3		 ret	 0
$LN2@HiddenTrea:

; 3059 : 			default:
; 3060 : 				LogAdd(LOG_BLACK, "[Hidden TreasureBox Event] [%s][%s] CBMix Failed - iCrystalMixType is wrong : %d",
; 3061 : 					lpObj->AccountID, lpObj->Name, iCrystalMixType);

  0025c	50		 push	 eax
  0025d	57		 push	 edi
  0025e	53		 push	 ebx
  0025f	68 00 00 00 00	 push	 OFFSET ??_C@_0FB@PDPGCOFM@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  00264	6a 00		 push	 0
  00266	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 3062 : 				DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0026b	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0026f	8b 06		 mov	 eax, DWORD PTR [esi]
  00271	51		 push	 ecx
  00272	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00275	52		 push	 edx
  00276	50		 push	 eax
  00277	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0027c	83 c4 20	 add	 esp, 32			; 00000020H
  0027f	5f		 pop	 edi

; 3063 : 				lpObj->ChaosLock = FALSE;

  00280	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  0028a	5e		 pop	 esi
  0028b	5b		 pop	 ebx

; 3084 : }

  0028c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0028f	33 cd		 xor	 ecx, ebp
  00291	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00296	8b e5		 mov	 esp, ebp
  00298	5d		 pop	 ebp
  00299	c3		 ret	 0
$LN7@HiddenTrea:

; 3070 : 	}
; 3071 : 	else
; 3072 : 	{
; 3073 : 		LogAdd(LOG_BLACK, "[Hidden TreasureBox Event] [%s][%s] CBMix Fail Rate:%d",
; 3074 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate);

  0029a	50		 push	 eax
  0029b	57		 push	 edi
  0029c	53		 push	 ebx
  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@JBMEKCLH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  002a2	6a 00		 push	 0
  002a4	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 3075 : 
; 3076 : 		ChaosBoxInit(lpObj);

  002a9	56		 push	 esi
  002aa	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit

; 3077 : 		::GCUserChaosBoxSend(lpObj, 1);

  002af	6a 01		 push	 1
  002b1	56		 push	 esi
  002b2	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 3078 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  002b7	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  002bb	8b 06		 mov	 eax, DWORD PTR [esi]
  002bd	51		 push	 ecx
  002be	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  002c1	52		 push	 edx
  002c2	50		 push	 eax
  002c3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002c8	83 c4 2c	 add	 esp, 44			; 0000002cH

; 3079 : 
; 3080 : 		lpObj->ChaosLock = FALSE;

  002cb	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  002d5	5f		 pop	 edi

; 3081 : 	}
; 3082 : 
; 3083 : 	lpObj->ChaosLock = FALSE;

  002d6	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3308], 0
  002e0	5e		 pop	 esi
  002e1	5b		 pop	 ebx

; 3084 : }

  002e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e5	33 cd		 xor	 ecx, ebp
  002e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ec	8b e5		 mov	 esp, ebp
  002ee	5d		 pop	 ebp
  002ef	c3		 ret	 0
$LN20@HiddenTrea:

; 3031 : 		}
; 3032 : 	}
; 3033 : 	else
; 3034 : 	{
; 3035 : 		LogAdd(LOG_BLACK, "[Hidden TreasureBox Event] [%s][%s] Item Mix Failed",
; 3036 : 			lpObj->AccountID, lpObj->Name);

  002f0	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  002f3	51		 push	 ecx
  002f4	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  002f7	52		 push	 edx
  002f8	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@OHGHLCDC@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  002fd	57		 push	 edi
  002fe	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 3037 : 	
; 3038 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00303	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00307	8b 16		 mov	 edx, DWORD PTR [esi]
  00309	50		 push	 eax
  0030a	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0030d	51		 push	 ecx
  0030e	52		 push	 edx
  0030f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3084 : }

  00314	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00317	83 c4 1c	 add	 esp, 28			; 0000001cH
  0031a	89 be ec 0c 00
	00		 mov	 DWORD PTR [esi+3308], edi
  00320	5f		 pop	 edi
  00321	5e		 pop	 esi
  00322	33 cd		 xor	 ecx, ebp
  00324	5b		 pop	 ebx
  00325	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032a	8b e5		 mov	 esp, ebp
  0032c	5d		 pop	 ebp
  0032d	c3		 ret	 0
?HiddenTreasureBoxItemMix@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; HiddenTreasureBoxItemMix
_TEXT	ENDS
END
