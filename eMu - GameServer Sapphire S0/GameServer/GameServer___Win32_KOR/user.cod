; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\user.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ChangeCount@@3HA				; ChangeCount
PUBLIC	?lOfsChange@@3HA				; lOfsChange
PUBLIC	?GuildUserCount@@3HA				; GuildUserCount
PUBLIC	?GuildUserOfs@@3HA				; GuildUserOfs
PUBLIC	?GuildInfoCount@@3HA				; GuildInfoCount
PUBLIC	?GuildInfoOfs@@3HA				; GuildInfoOfs
PUBLIC	?skillSuccess@@3HA				; skillSuccess
PUBLIC	?gCurConnectUser@@3HA				; gCurConnectUser
PUBLIC	?aaaaaaaaa@@3HA					; aaaaaaaaa
PUBLIC	?gDisconnect@@3HA				; gDisconnect
PUBLIC	?gObjTotalUser@@3HA				; gObjTotalUser
PUBLIC	?gItemLoopMax@@3HA				; gItemLoopMax
PUBLIC	?gItemLoop@@3HA					; gItemLoop
PUBLIC	?gItemLoop2@@3HA				; gItemLoop2
PUBLIC	?gObjCSFlag@@3HA				; gObjCSFlag
PUBLIC	?gObjCount@@3HA					; gObjCount
PUBLIC	?gObjMonCount@@3HA				; gObjMonCount
PUBLIC	?gObjCallMonCount@@3HA				; gObjCallMonCount
PUBLIC	?gSMMsg@@3PAY09UMessageStateMachine@@A		; gSMMsg
PUBLIC	?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A ; gSMAttackProcMsg
PUBLIC	?hThread_gObjMove@@3PAXA			; hThread_gObjMove
PUBLIC	?GuildInfoBuf@@3PAEA				; GuildInfoBuf
PUBLIC	?GuildUserBuf@@3PAEA				; GuildUserBuf
PUBLIC	?SendGBufChange@@3PAEA				; SendGBufChange
PUBLIC	?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A	; pViewportCreate
PUBLIC	?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A ; pViewportCreateChange
PUBLIC	?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A	; pViewportDestroy
PUBLIC	?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A ; pMonsterViewportCreate
PUBLIC	?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A ; pCallMonsterViewportCreate
PUBLIC	?pItemCount@@3UPWMSG_COUNT@@A			; pItemCount
PUBLIC	?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A ; pItemViewportCreate
PUBLIC	?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pItemViewportDestroy
PUBLIC	?RoadPathTable@@3PAFA				; RoadPathTable
PUBLIC	?gServerMaxUser@@3HA				; gServerMaxUser
PUBLIC	?g_EnergyCheckOff@@3HA				; g_EnergyCheckOff
_BSS	SEGMENT
?ChangeCount@@3HA DD 01H DUP (?)			; ChangeCount
?lOfsChange@@3HA DD 01H DUP (?)				; lOfsChange
?GuildUserCount@@3HA DD 01H DUP (?)			; GuildUserCount
?GuildUserOfs@@3HA DD 01H DUP (?)			; GuildUserOfs
?GuildInfoCount@@3HA DD 01H DUP (?)			; GuildInfoCount
?GuildInfoOfs@@3HA DD 01H DUP (?)			; GuildInfoOfs
?skillSuccess@@3HA DD 01H DUP (?)			; skillSuccess
?gCurConnectUser@@3HA DD 01H DUP (?)			; gCurConnectUser
?aaaaaaaaa@@3HA DD 01H DUP (?)				; aaaaaaaaa
?gDisconnect@@3HA DD 01H DUP (?)			; gDisconnect
?gObjTotalUser@@3HA DD 01H DUP (?)			; gObjTotalUser
?gItemLoopMax@@3HA DD 01H DUP (?)			; gItemLoopMax
?gItemLoop@@3HA DD 01H DUP (?)				; gItemLoop
?gItemLoop2@@3HA DD 01H DUP (?)				; gItemLoop2
?gObjCSFlag@@3HA DD 01H DUP (?)				; gObjCSFlag
?gObjCount@@3HA DD 01H DUP (?)				; gObjCount
?gObjMonCount@@3HA DD 01H DUP (?)			; gObjMonCount
?gObjCallMonCount@@3HA DD 01H DUP (?)			; gObjCallMonCount
?gSMMsg@@3PAY09UMessageStateMachine@@A DB 0121100H DUP (?) ; gSMMsg
?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A DB 070ea40H DUP (?) ; gSMAttackProcMsg
?hThread_gObjMove@@3PAXA DD 01H DUP (?)			; hThread_gObjMove
?GuildInfoBuf@@3PAEA DB 02710H DUP (?)			; GuildInfoBuf
?GuildUserBuf@@3PAEA DB 02710H DUP (?)			; GuildUserBuf
?SendGBufChange@@3PAEA DB 01388H DUP (?)		; SendGBufChange
?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A DB 02cH DUP (?) ; pViewportCreate
?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A DB 01cH DUP (?) ; pViewportCreateChange
?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A DW 01H DUP (?) ; pViewportDestroy
	ALIGN	4

?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A DB 010H DUP (?) ; pMonsterViewportCreate
?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A DB 018H DUP (?) ; pCallMonsterViewportCreate
?pItemCount@@3UPWMSG_COUNT@@A DB 05H DUP (?)		; pItemCount
	ALIGN	4

?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A DB 0bH DUP (?) ; pItemViewportCreate
	ALIGN	4

?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A DW 01H DUP (?) ; pItemViewportDestroy
_BSS	ENDS
_DATA	SEGMENT
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	070H
_g_sttKALIMAGATE_LEVEL DD 028H
	DD	082H
	DD	014H
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	015dH
	DD	0137H
	DD	015dH
	DD	015eH
	DD	0190H
	DD	015eH
	DD	0190H
_g_iKalimaGateGateIndex DD 058H
	DD	059H
	DD	05aH
	DD	05bH
	DD	05cH
	DD	05dH
	DD	074H
?gServerMaxUser@@3HA DD 01f4H				; gServerMaxUser
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
_g_sttCHAOSCASTLE_LEVEL DD 0aH
	DD	031H
	DD	0aH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
?RoadPathTable@@3PAFA DW 0ffffH				; RoadPathTable
	DW	0ffffH
	DW	00H
	DW	0ffffH
	DW	01H
	DW	0ffffH
	DW	01H
	DW	00H
	DW	01H
	DW	01H
	DW	00H
	DW	01H
	DW	0ffffH
	DW	01H
	DW	0ffffH
	DW	00H
?g_EnergyCheckOff@@3HA DD 01H				; g_EnergyCheckOff
_DATA	ENDS
PUBLIC	?GetInfinityArrowUseLevel@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetInfinityArrowUseLevel
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\skilladditioninfo.h
;	COMDAT ?GetInfinityArrowUseLevel@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetInfinityArrowUseLevel@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetInfinityArrowUseLevel, COMDAT
; _this$ = ecx

; 25   : 	int GetInfinityArrowUseLevel(){return this->m_iInfinityArrowUseLevel;}

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetInfinityArrowUseLevel@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetInfinityArrowUseLevel
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
	ALIGN	4

_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??0OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::OBJECTSTRUCT
EXTRN	??0CSkillDelay@@QAE@XZ:PROC			; CSkillDelay::CSkillDelay
; Function compile flags: /Ogtp
;	COMDAT ??0OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??0OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e bc 10 00
	00		 lea	 ecx, DWORD PTR [esi+4284]
  00009	e8 00 00 00 00	 call	 ??0CSkillDelay@@QAE@XZ	; CSkillDelay::CSkillDelay
  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::OBJECTSTRUCT
_TEXT	ENDS
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	81 c1 bc 10 00
	00		 add	 ecx, 4284		; 000010bcH
  00006	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?gObjRefillProcess@@YAXHPAUOBJECTSTRUCT@@@Z	; gObjRefillProcess
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
;	COMDAT ?gObjRefillProcess@@YAXHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpObj$ = 12						; size = 4
?gObjRefillProcess@@YAXHPAUOBJECTSTRUCT@@@Z PROC	; gObjRefillProcess, COMDAT

; 613  : 	return;	// HEre is a MACRO
; 614  : }

  00000	c3		 ret	 0
?gObjRefillProcess@@YAXHPAUOBJECTSTRUCT@@@Z ENDP	; gObjRefillProcess
_TEXT	ENDS
PUBLIC	??_ECMagicInf@@UAEPAXI@Z			; CMagicInf::`vector deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??1CMagicInf@@UAE@XZ:PROC			; CMagicInf::~CMagicInf
; Function compile flags: /Ogtp
;	COMDAT ??_ECMagicInf@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECMagicInf@@UAEPAXI@Z PROC				; CMagicInf::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8a 5d 08	 mov	 bl, BYTE PTR ___flags$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	f6 c3 02	 test	 bl, 2
  0000d	74 2c		 je	 SHORT $LN3@vector@2
  0000f	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00012	57		 push	 edi
  00013	68 00 00 00 00	 push	 OFFSET ??1CMagicInf@@UAE@XZ ; CMagicInf::~CMagicInf
  00018	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0001b	50		 push	 eax
  0001c	6a 10		 push	 16			; 00000010H
  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00024	f6 c3 01	 test	 bl, 1
  00027	74 09		 je	 SHORT $LN2@vector@2
  00029	57		 push	 edi
  0002a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002f	83 c4 04	 add	 esp, 4
$LN2@vector@2:
  00032	8b c7		 mov	 eax, edi
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN3@vector@2:
  0003b	e8 00 00 00 00	 call	 ??1CMagicInf@@UAE@XZ	; CMagicInf::~CMagicInf
  00040	f6 c3 01	 test	 bl, 1
  00043	74 09		 je	 SHORT $LN1@vector@2
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004b	83 c4 04	 add	 esp, 4
$LN1@vector@2:
  0004e	8b c6		 mov	 eax, esi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
??_ECMagicInf@@UAEPAXI@Z ENDP				; CMagicInf::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?gObjClearViewportOfMine@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewportOfMine
; Function compile flags: /Ogtp
;	COMDAT ?gObjClearViewportOfMine@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjClearViewportOfMine@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjClearViewportOfMine, COMDAT

; 743  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 744  : 	for (int i=0;i<MAX_VIEWPORT;i++)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	57		 push	 edi
  00008	8d 86 92 03 00
	00		 lea	 eax, DWORD PTR [esi+914]
  0000e	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00013	33 d2		 xor	 edx, edx
$LL3@gObjClearV:

; 745  : 	{
; 746  : 		lpObj->VpPlayer[i].state =0;
; 747  : 		lpObj->VpPlayer[i].number =-1;

  00015	83 cf ff	 or	 edi, -1
  00018	88 50 fe	 mov	 BYTE PTR [eax-2], dl
  0001b	66 89 38	 mov	 WORD PTR [eax], di
  0001e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00021	49		 dec	 ecx
  00022	75 f1		 jne	 SHORT $LL3@gObjClearV

; 748  : 	}
; 749  : 
; 750  : 	lpObj->VPCount=0;

  00024	5f		 pop	 edi
  00025	89 96 98 0a 00
	00		 mov	 DWORD PTR [esi+2712], edx
  0002b	5e		 pop	 esi

; 751  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?gObjClearViewportOfMine@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjClearViewportOfMine
_TEXT	ENDS
PUBLIC	?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z	; gObjClearViewport
; Function compile flags: /Ogtp
;	COMDAT ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjClearViewport, COMDAT

; 754  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 755  : 	for ( int i=0;i<MAX_VIEWPORT;i++)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	57		 push	 edi
  00008	8d 86 92 03 00
	00		 lea	 eax, DWORD PTR [esi+914]
  0000e	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  00013	33 c9		 xor	 ecx, ecx
$LL3@gObjClearV@2:

; 756  : 	{
; 757  : 		lpObj->VpPlayer[i].state=0;
; 758  : 		lpObj->VpPlayer[i].number =-1;

  00015	83 cf ff	 or	 edi, -1
  00018	66 89 38	 mov	 WORD PTR [eax], di

; 759  : 		lpObj->VpPlayer2[i].state=0;
; 760  : 		lpObj->VpPlayer2[i].number=-1;

  0001b	0b ff		 or	 edi, edi
  0001d	88 48 fe	 mov	 BYTE PTR [eax-2], cl
  00020	88 88 82 03 00
	00		 mov	 BYTE PTR [eax+898], cl
  00026	66 89 b8 84 03
	00 00		 mov	 WORD PTR [eax+900], di
  0002d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00030	4a		 dec	 edx
  00031	75 e2		 jne	 SHORT $LL3@gObjClearV@2

; 761  : 	}
; 762  : 
; 763  : 	lpObj->VPCount = 0;

  00033	5f		 pop	 edi
  00034	89 8e 98 0a 00
	00		 mov	 DWORD PTR [esi+2712], ecx

; 764  : 	lpObj->VPCount2 = 0;

  0003a	89 8e 9c 0a 00
	00		 mov	 DWORD PTR [esi+2716], ecx
  00040	5e		 pop	 esi

; 765  : }

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjClearViewport
_TEXT	ENDS
PUBLIC	?gObjCharTradeClear@@YAXPAUOBJECTSTRUCT@@@Z	; gObjCharTradeClear
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
; Function compile flags: /Ogtp
;	COMDAT ?gObjCharTradeClear@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjCharTradeClear@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjCharTradeClear, COMDAT

; 828  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 829  : 	if ( lpObj->Type != OBJ_USER )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00007	66 83 7f 60 01	 cmp	 WORD PTR [edi+96], 1
  0000c	75 50		 jne	 SHORT $LN5@gObjCharTr

; 830  : 	{
; 831  : 		return;
; 832  : 	}
; 833  : 
; 834  : 	memset(lpObj->TradeMap, 0xFF , TRADE_BOX_SIZE);

  0000e	8b 8f b8 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3256]
  00014	83 c8 ff	 or	 eax, -1
  00017	89 01		 mov	 DWORD PTR [ecx], eax
  00019	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0001f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00022	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00025	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00028	56		 push	 esi
  00029	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0002c	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0002f	33 f6		 xor	 esi, esi
$LL3@gObjCharTr:

; 835  : 
; 836  : 	for ( int i=0 ; i< TRADE_BOX_SIZE ; i++)
; 837  : 	{
; 838  : 		lpObj->Trade[i].Clear();

  00031	8b 8f b4 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3252]
  00037	03 ce		 add	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  0003e	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00044	81 fe 00 15 00
	00		 cmp	 esi, 5376		; 00001500H
  0004a	7c e5		 jl	 SHORT $LL3@gObjCharTr

; 839  : 	}
; 840  : 
; 841  : 	lpObj->TradeMoney = 0;

  0004c	c7 87 bc 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+3260], 0

; 842  : 	lpObj->TradeOk = false;

  00056	c6 87 c0 0c 00
	00 00		 mov	 BYTE PTR [edi+3264], 0
  0005d	5e		 pop	 esi
$LN5@gObjCharTr:
  0005e	5f		 pop	 edi

; 843  : }

  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?gObjCharTradeClear@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjCharTradeClear
_TEXT	ENDS
PUBLIC	?gObjGetSocket@@YAHI@Z				; gObjGetSocket
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetSocket@@YAHI@Z
_TEXT	SEGMENT
_socket$ = 8						; size = 4
?gObjGetSocket@@YAHI@Z PROC				; gObjGetSocket, COMDAT

; 1230 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1231 : 	for (int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  00003	8b 55 08	 mov	 edx, DWORD PTR _socket$[ebp]
  00006	b8 00 19 00 00	 mov	 eax, 6400		; 00001900H
  0000b	b9 10 c4 16 02	 mov	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046416
$LL5@gObjGetSoc:

; 1232 : 	{
; 1233 : 		if (gObj[n].Connected != PLAYER_EMPTY)

  00010	80 79 f4 00	 cmp	 BYTE PTR [ecx-12], 0
  00014	74 04		 je	 SHORT $LN4@gObjGetSoc

; 1234 : 		{
; 1235 : 			if (gObj[n].m_socket == socket)

  00016	39 11		 cmp	 DWORD PTR [ecx], edx
  00018	74 12		 je	 SHORT $LN6@gObjGetSoc
$LN4@gObjGetSoc:

; 1231 : 	for (int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  0001a	81 c1 64 15 00
	00		 add	 ecx, 5476		; 00001564H
  00020	40		 inc	 eax
  00021	81 f9 b0 52 6a
	02		 cmp	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522416
  00027	7c e7		 jl	 SHORT $LL5@gObjGetSoc

; 1236 : 			{
; 1237 : 				return n;
; 1238 : 			}
; 1239 : 		}
; 1240 : 	}
; 1241 : 	return -1;

  00029	83 c8 ff	 or	 eax, -1
$LN6@gObjGetSoc:

; 1242 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?gObjGetSocket@@YAHI@Z ENDP				; gObjGetSocket
_TEXT	ENDS
PUBLIC	?IsOnDuel@@YA_NHH@Z				; IsOnDuel
; Function compile flags: /Ogtp
;	COMDAT ?IsOnDuel@@YA_NHH@Z
_TEXT	SEGMENT
_aIndex1$ = 8						; size = 4
_aIndex2$ = 12						; size = 4
?IsOnDuel@@YA_NHH@Z PROC				; IsOnDuel, COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1296 : 	if ( OBJMAX_RANGE(aIndex1) == FALSE || OBJMAX_RANGE(aIndex2) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex1$[ebp]
  00008	85 ff		 test	 edi, edi
  0000a	78 5c		 js	 SHORT $LN4@IsOnDuel
  0000c	33 c0		 xor	 eax, eax
  0000e	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	74 4d		 je	 SHORT $LN4@IsOnDuel
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _aIndex2$[ebp]
  0001e	85 f6		 test	 esi, esi
  00020	78 46		 js	 SHORT $LN4@IsOnDuel
  00022	33 c0		 xor	 eax, eax
  00024	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  0002a	0f 9e c0	 setle	 al
  0002d	85 c0		 test	 eax, eax
  0002f	74 37		 je	 SHORT $LN4@IsOnDuel

; 1299 : 	}
; 1300 : 
; 1301 : 	if ( gObj[aIndex1].Type != OBJ_USER || gObj[aIndex2].Type != OBJ_USER )

  00031	8b d7		 mov	 edx, edi
  00033	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00039	b8 01 00 00 00	 mov	 eax, 1
  0003e	66 39 82 60 00
	00 00		 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+96], ax
  00045	75 21		 jne	 SHORT $LN4@IsOnDuel
  00047	8b ce		 mov	 ecx, esi
  00049	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0004f	66 39 81 60 00
	00 00		 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+96], ax
  00056	75 10		 jne	 SHORT $LN4@IsOnDuel

; 1302 : 	{
; 1303 : 		return false;
; 1304 : 	}
; 1305 : 
; 1306 : 	if ( gObj[aIndex1].m_iDuelUser == aIndex2 && gObj[aIndex2].m_iDuelUser == aIndex1 )

  00058	39 b2 1c 0d 00
	00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3356], esi
  0005e	75 08		 jne	 SHORT $LN4@IsOnDuel
  00060	39 b9 1c 0d 00
	00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3356], edi

; 1307 : 	{
; 1308 : 		return true;

  00066	74 02		 je	 SHORT $LN6@IsOnDuel
$LN4@IsOnDuel:

; 1297 : 	{
; 1298 : 		return false;

  00068	32 c0		 xor	 al, al
$LN6@IsOnDuel:
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi

; 1309 : 	}
; 1310 : 
; 1311 : 	return false;
; 1312 : }

  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?IsOnDuel@@YA_NHH@Z ENDP				; IsOnDuel
_TEXT	ENDS
PUBLIC	??_C@_0CA@HDKCFMCD@error?9L3?5?3?5map?5number?5not?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_08DCNFOMBO@user?4cpp?$AA@			; `string'
PUBLIC	?GetMapMoveLevel@@YAHPAUOBJECTSTRUCT@@HH@Z	; GetMapMoveLevel
EXTRN	?MapMinUserLevel@@3PAHA:BYTE			; MapMinUserLevel
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
;	COMDAT ??_C@_0CA@HDKCFMCD@error?9L3?5?3?5map?5number?5not?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0CA@HDKCFMCD@error?9L3?5?3?5map?5number?5not?5?$CFs?5?$CFd?$AA@ DB 'e'
	DB	'rror-L3 : map number not %s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DCNFOMBO@user?4cpp?$AA@
CONST	SEGMENT
??_C@_08DCNFOMBO@user?4cpp?$AA@ DB 'user.cpp', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GetMapMoveLevel@@YAHPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_mapnumber$ = 12					; size = 4
_max_over$ = 16						; size = 4
?GetMapMoveLevel@@YAHPAUOBJECTSTRUCT@@HH@Z PROC		; GetMapMoveLevel, COMDAT

; 1315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1316 : 	int overLevel = 0;
; 1317 : 
; 1318 : 	if ( mapnumber > MAX_NUMBER_MAP-1 )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _mapnumber$[ebp]
  00006	83 f8 27	 cmp	 eax, 39			; 00000027H
  00009	7e 1d		 jle	 SHORT $LN6@GetMapMove

; 1319 : 	{
; 1320 : 		mapnumber = 0;
; 1321 : 		LogAdd(LOG_BLACK, "error-L3 : map number not %s %d", __FILE__, __LINE__);

  0000b	68 29 05 00 00	 push	 1321			; 00000529H
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HDKCFMCD@error?9L3?5?3?5map?5number?5not?5?$CFs?5?$CFd?$AA@
  0001a	6a 00		 push	 0
  0001c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 1322 : 		return 0;

  00024	33 c0		 xor	 eax, eax

; 1340 : 		}
; 1341 : 	}
; 1342 : 
; 1343 : 	return overLevel;
; 1344 : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
$LN6@GetMapMove:

; 1323 : 	}
; 1324 : 
; 1325 : 	if ( max_over != 0 )

  00028	8b 4d 10	 mov	 ecx, DWORD PTR _max_over$[ebp]
  0002b	85 c9		 test	 ecx, ecx

; 1326 : 	{
; 1327 : 		overLevel = max_over;
; 1328 : 	}
; 1329 : 	else

  0002d	75 07		 jne	 SHORT $LN9@GetMapMove

; 1330 : 	{
; 1331 : 		max_over = MapMinUserLevel[mapnumber];

  0002f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?MapMinUserLevel@@3PAHA[eax*4]
$LN9@GetMapMove:

; 1332 : 		overLevel = MapMinUserLevel[mapnumber];
; 1333 : 	}
; 1334 : 	
; 1335 : 	if ( lpObj->Class == 4 || lpObj->Class == 3 )

  00036	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00039	0f b7 92 98 00
	00 00		 movzx	 edx, WORD PTR [edx+152]
  00040	8b c1		 mov	 eax, ecx
  00042	83 fa 04	 cmp	 edx, 4
  00045	74 05		 je	 SHORT $LN2@GetMapMove
  00047	83 fa 03	 cmp	 edx, 3
  0004a	75 18		 jne	 SHORT $LN7@GetMapMove
$LN2@GetMapMove:

; 1336 : 	{
; 1337 : 		if ( overLevel > 0 && max_over > 0 )

  0004c	85 c0		 test	 eax, eax
  0004e	7e 14		 jle	 SHORT $LN7@GetMapMove
  00050	85 c9		 test	 ecx, ecx
  00052	7e 10		 jle	 SHORT $LN7@GetMapMove

; 1338 : 		{
; 1339 : 			overLevel = (max_over/3)*2;

  00054	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00059	f7 e9		 imul	 ecx
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00060	03 c2		 add	 eax, edx
  00062	03 c0		 add	 eax, eax
$LN7@GetMapMove:

; 1340 : 		}
; 1341 : 	}
; 1342 : 
; 1343 : 	return overLevel;
; 1344 : }

  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?GetMapMoveLevel@@YAHPAUOBJECTSTRUCT@@HH@Z ENDP		; GetMapMoveLevel
_TEXT	ENDS
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fc3333333333333
PUBLIC	__real@3fd3333333333333
PUBLIC	__real@3fc999999999999a
PUBLIC	__real@3fd999999999999a
PUBLIC	?gObjSetBP@@YAXH@Z				; gObjSetBP
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3fc3333333333333
CONST	SEGMENT
__real@3fc3333333333333 DQ 03fc3333333333333r	; 0.15
CONST	ENDS
;	COMDAT __real@3fd3333333333333
CONST	SEGMENT
__real@3fd3333333333333 DQ 03fd3333333333333r	; 0.3
CONST	ENDS
;	COMDAT __real@3fc999999999999a
CONST	SEGMENT
__real@3fc999999999999a DQ 03fc999999999999ar	; 0.2
CONST	ENDS
;	COMDAT __real@3fd999999999999a
CONST	SEGMENT
__real@3fd999999999999a DQ 03fd999999999999ar	; 0.4
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjSetBP@@YAXH@Z
_TEXT	SEGMENT
_Energy$ = -12						; size = 4
_Vitality$ = -8						; size = 4
_Strength$ = -4						; size = 4
tv342 = 8						; size = 4
_Dexterity$ = 8						; size = 4
_aIndex$ = 8						; size = 4
?gObjSetBP@@YAXH@Z PROC					; gObjSetBP, COMDAT

; 1567 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 1568 : 	int Strength	= gObj[aIndex].Strength + gObj[aIndex].AddStrength;

  00007	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000a	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00010	0f b7 8e b4 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+180]
  00017	0f bf 86 e0 00
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+224]

; 1569 : 	int Dexterity	= gObj[aIndex].Dexterity + gObj[aIndex].AddDexterity;

  0001e	0f bf 96 e2 00
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+226]
  00025	03 c1		 add	 eax, ecx

; 1570 : 	int Vitality	= gObj[aIndex].Vitality + gObj[aIndex].AddVitality;

  00027	0f bf 8e e4 00
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+228]
  0002e	89 45 fc	 mov	 DWORD PTR _Strength$[ebp], eax
  00031	0f b7 86 b6 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+182]
  00038	03 d0		 add	 edx, eax

; 1571 : 	int Energy		= gObj[aIndex].Energy + gObj[aIndex].AddEnergy;

  0003a	0f bf 86 e6 00
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+230]
  00041	89 55 08	 mov	 DWORD PTR _Dexterity$[ebp], edx
  00044	0f b7 96 b8 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+184]
  0004b	03 ca		 add	 ecx, edx
  0004d	89 4d f8	 mov	 DWORD PTR _Vitality$[ebp], ecx
  00050	0f b7 8e ba 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+186]
  00057	03 c1		 add	 eax, ecx
  00059	89 45 f4	 mov	 DWORD PTR _Energy$[ebp], eax

; 1572 : 	int Leadership	= gObj[aIndex].Leadership + gObj[aIndex].AddLeadership;
; 1573 : 	// ---
; 1574 : 	switch(gObj[aIndex].Class)

  0005c	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152]
  00063	83 f8 04	 cmp	 eax, 4
  00066	0f 87 36 01 00
	00		 ja	 $LN6@gObjSetBP
  0006c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN13@gObjSetBP[eax*4]
$LN5@gObjSetBP:

; 1575 : 	{
; 1576 : 		case 0: gObj[aIndex].MaxBP = (Strength * 0.2) + (Dexterity * 0.4) + (Vitality * 0.3) + (Energy * 0.2); break;

  00073	db 45 08	 fild	 DWORD PTR _Dexterity$[ebp]
  00076	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fd999999999999a
  0007c	db 45 fc	 fild	 DWORD PTR _Strength$[ebp]
  0007f	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fc999999999999a
  00085	dc c9		 fmul	 ST(1), ST(0)
  00087	d9 ca		 fxch	 ST(2)
  00089	de c1		 faddp	 ST(1), ST(0)
  0008b	db 45 f8	 fild	 DWORD PTR _Vitality$[ebp]
  0008e	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fd3333333333333
  00094	de c1		 faddp	 ST(1), ST(0)
  00096	db 45 f4	 fild	 DWORD PTR _Energy$[ebp]

; 1580 : 		case 4: gObj[aIndex].MaxBP = (Strength * 0.3) + (Dexterity * 0.2) + (Vitality * 0.1) + (Energy * 0.15) + (Leadership * 0.3); break;

  00099	de ca		 fmulp	 ST(2), ST(0)
  0009b	de c1		 faddp	 ST(1), ST(0)
  0009d	e8 00 00 00 00	 call	 __ftol2_sse
  000a2	89 86 ec 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+236], eax
  000a8	5e		 pop	 esi

; 1581 : 	}
; 1582 : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN4@gObjSetBP:

; 1577 : 		case 1: gObj[aIndex].MaxBP = (Strength * 0.15) + (Dexterity * 0.2) + (Vitality * 0.3) + (Energy * 1.0); break;

  000ad	db 45 08	 fild	 DWORD PTR _Dexterity$[ebp]
  000b0	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fc999999999999a
  000b6	db 45 fc	 fild	 DWORD PTR _Strength$[ebp]
  000b9	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fc3333333333333
  000bf	de c1		 faddp	 ST(1), ST(0)
  000c1	db 45 f8	 fild	 DWORD PTR _Vitality$[ebp]
  000c4	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fd3333333333333
  000ca	de c1		 faddp	 ST(1), ST(0)
  000cc	da 45 f4	 fiadd	 DWORD PTR _Energy$[ebp]

; 1580 : 		case 4: gObj[aIndex].MaxBP = (Strength * 0.3) + (Dexterity * 0.2) + (Vitality * 0.1) + (Energy * 0.15) + (Leadership * 0.3); break;

  000cf	e8 00 00 00 00	 call	 __ftol2_sse
  000d4	89 86 ec 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+236], eax
  000da	5e		 pop	 esi

; 1581 : 	}
; 1582 : }

  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
$LN3@gObjSetBP:

; 1578 : 		case 2: gObj[aIndex].MaxBP = (Strength * 0.3) + (Dexterity * 0.2) + (Vitality * 0.3) + (Energy * 0.2); break;

  000df	db 45 08	 fild	 DWORD PTR _Dexterity$[ebp]
  000e2	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fc999999999999a
  000e8	dc c9		 fmul	 ST(1), ST(0)
  000ea	db 45 fc	 fild	 DWORD PTR _Strength$[ebp]
  000ed	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fd3333333333333
  000f3	dc c9		 fmul	 ST(1), ST(0)
  000f5	d9 cb		 fxch	 ST(3)
  000f7	de c1		 faddp	 ST(1), ST(0)
  000f9	db 45 f8	 fild	 DWORD PTR _Vitality$[ebp]
  000fc	de cb		 fmulp	 ST(3), ST(0)
  000fe	de c2		 faddp	 ST(2), ST(0)
  00100	da 4d f4	 fimul	 DWORD PTR _Energy$[ebp]

; 1580 : 		case 4: gObj[aIndex].MaxBP = (Strength * 0.3) + (Dexterity * 0.2) + (Vitality * 0.1) + (Energy * 0.15) + (Leadership * 0.3); break;

  00103	de c1		 faddp	 ST(1), ST(0)
  00105	e8 00 00 00 00	 call	 __ftol2_sse
  0010a	89 86 ec 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+236], eax
  00110	5e		 pop	 esi

; 1581 : 	}
; 1582 : }

  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
$LN2@gObjSetBP:

; 1579 : 		case 3: gObj[aIndex].MaxBP = (Strength * 0.2) + (Dexterity * 0.25) + (Vitality * 0.3) + (Energy * 0.15); break;

  00115	db 45 fc	 fild	 DWORD PTR _Strength$[ebp]
  00118	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fc999999999999a
  0011e	db 45 08	 fild	 DWORD PTR _Dexterity$[ebp]
  00121	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fd0000000000000
  00127	de c1		 faddp	 ST(1), ST(0)
  00129	db 45 f8	 fild	 DWORD PTR _Vitality$[ebp]
  0012c	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fd3333333333333
  00132	de c1		 faddp	 ST(1), ST(0)
  00134	db 45 f4	 fild	 DWORD PTR _Energy$[ebp]
  00137	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fc3333333333333

; 1580 : 		case 4: gObj[aIndex].MaxBP = (Strength * 0.3) + (Dexterity * 0.2) + (Vitality * 0.1) + (Energy * 0.15) + (Leadership * 0.3); break;

  0013d	de c1		 faddp	 ST(1), ST(0)
  0013f	e8 00 00 00 00	 call	 __ftol2_sse
  00144	89 86 ec 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+236], eax
  0014a	5e		 pop	 esi

; 1581 : 	}
; 1582 : }

  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c3		 ret	 0
$LN1@gObjSetBP:

; 1580 : 		case 4: gObj[aIndex].MaxBP = (Strength * 0.3) + (Dexterity * 0.2) + (Vitality * 0.1) + (Energy * 0.15) + (Leadership * 0.3); break;

  0014f	db 45 08	 fild	 DWORD PTR _Dexterity$[ebp]
  00152	0f b7 86 d8 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+216]
  00159	0f b7 96 da 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+218]
  00160	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fc999999999999a
  00166	db 45 fc	 fild	 DWORD PTR _Strength$[ebp]
  00169	03 d0		 add	 edx, eax
  0016b	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fd3333333333333
  00171	89 55 08	 mov	 DWORD PTR tv342[ebp], edx
  00174	dc c9		 fmul	 ST(1), ST(0)
  00176	d9 ca		 fxch	 ST(2)
  00178	de c1		 faddp	 ST(1), ST(0)
  0017a	db 45 f8	 fild	 DWORD PTR _Vitality$[ebp]
  0017d	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fb999999999999a
  00183	de c1		 faddp	 ST(1), ST(0)
  00185	db 45 f4	 fild	 DWORD PTR _Energy$[ebp]
  00188	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fc3333333333333
  0018e	de c1		 faddp	 ST(1), ST(0)
  00190	db 45 08	 fild	 DWORD PTR tv342[ebp]
  00193	de ca		 fmulp	 ST(2), ST(0)
  00195	de c1		 faddp	 ST(1), ST(0)
  00197	e8 00 00 00 00	 call	 __ftol2_sse
  0019c	89 86 ec 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+236], eax
$LN6@gObjSetBP:
  001a2	5e		 pop	 esi

; 1581 : 	}
; 1582 : }

  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c3		 ret	 0
  001a7	90		 npad	 1
$LN13@gObjSetBP:
  001a8	00 00 00 00	 DD	 $LN5@gObjSetBP
  001ac	00 00 00 00	 DD	 $LN4@gObjSetBP
  001b0	00 00 00 00	 DD	 $LN3@gObjSetBP
  001b4	00 00 00 00	 DD	 $LN2@gObjSetBP
  001b8	00 00 00 00	 DD	 $LN1@gObjSetBP
?gObjSetBP@@YAXH@Z ENDP					; gObjSetBP
_TEXT	ENDS
PUBLIC	?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z	; gObjCanItemTouch
; Function compile flags: /Ogtp
;	COMDAT ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_type$ = 12						; size = 4
?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z PROC		; gObjCanItemTouch, COMDAT

; 2185 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2186 : 	if ( (lpObj->Penalty &4) == 4 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [eax+428]
  0000c	a8 04		 test	 al, 4
  0000e	74 04		 je	 SHORT $LN4@gObjCanIte
$LN7@gObjCanIte:

; 2187 : 	{
; 2188 : 		return false;

  00010	33 c0		 xor	 eax, eax

; 2200 : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
$LN4@gObjCanIte:

; 2189 : 	}
; 2190 : 
; 2191 : 	if ( (lpObj->Penalty &8) == 8 )

  00014	a8 08		 test	 al, 8
  00016	74 0d		 je	 SHORT $LN3@gObjCanIte

; 2192 : 	{
; 2193 : 		if ( type == 6 || type == 8 )

  00018	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  0001b	83 f8 06	 cmp	 eax, 6
  0001e	74 05		 je	 SHORT $LN3@gObjCanIte
  00020	83 f8 08	 cmp	 eax, 8

; 2194 : 		{
; 2195 : 			return true;
; 2196 : 		}
; 2197 : 		return false;

  00023	75 eb		 jne	 SHORT $LN7@gObjCanIte
$LN3@gObjCanIte:

; 2198 : 	}
; 2199 : 	return true;

  00025	b8 01 00 00 00	 mov	 eax, 1

; 2200 : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ENDP		; gObjCanItemTouch
_TEXT	ENDS
PUBLIC	?gObjMagicTextSave@@YAXPAUOBJECTSTRUCT@@@Z	; gObjMagicTextSave
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?IsMagic@CMagicInf@@QAEHXZ:PROC			; CMagicInf::IsMagic
; Function compile flags: /Ogtp
;	COMDAT ?gObjMagicTextSave@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjMagicTextSave@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjMagicTextSave, COMDAT

; 2203 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 2204 : 	int total=0;
; 2205 : 
; 2206 : 	for ( int n=0;n<MAGIC_SIZE;n++)

  00006	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00009	33 db		 xor	 ebx, ebx
  0000b	33 f6		 xor	 esi, esi
  0000d	8d 49 00	 npad	 3
$LL4@gObjMagicT:

; 2207 : 	{
; 2208 : 		if ( lpObj->Magic[n].IsMagic() == TRUE )

  00010	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  00016	03 ce		 add	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 2f		 jne	 SHORT $LN3@gObjMagicT

; 2209 : 		{
; 2210 : 			LogAdd(LOG_BLACK, lMsg.Get(MSGGET(1, 247)), lpObj->AccountID, lpObj->Name, n, lpObj->Magic[n].m_Skill);

  00022	8b 87 38 03 00
	00		 mov	 eax, DWORD PTR [edi+824]
  00028	0f b6 4c 30 05	 movzx	 ecx, BYTE PTR [eax+esi+5]
  0002d	51		 push	 ecx
  0002e	53		 push	 ebx
  0002f	8d 57 6f	 lea	 edx, DWORD PTR [edi+111]
  00032	52		 push	 edx
  00033	8d 47 64	 lea	 eax, DWORD PTR [edi+100]
  00036	50		 push	 eax
  00037	68 f7 01 00 00	 push	 503			; 000001f7H
  0003c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00041	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00046	50		 push	 eax
  00047	6a 00		 push	 0
  00049	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0004e	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@gObjMagicT:

; 2204 : 	int total=0;
; 2205 : 
; 2206 : 	for ( int n=0;n<MAGIC_SIZE;n++)

  00051	83 c6 10	 add	 esi, 16			; 00000010H
  00054	43		 inc	 ebx
  00055	81 fe c0 03 00
	00		 cmp	 esi, 960		; 000003c0H
  0005b	7c b3		 jl	 SHORT $LL4@gObjMagicT
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 2211 : 			total++;
; 2212 : 		}
; 2213 : 	}
; 2214 : }

  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?gObjMagicTextSave@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjMagicTextSave
_TEXT	ENDS
PUBLIC	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z		; ItemIsBufExOption
EXTRN	?IsExtMonsterMoney@CItem@@QAEHXZ:PROC		; CItem::IsExtMonsterMoney
EXTRN	?IsExtDefenseSuccessfull@CItem@@QAEHXZ:PROC	; CItem::IsExtDefenseSuccessfull
EXTRN	?IsExtDamageReflect@CItem@@QAEHXZ:PROC		; CItem::IsExtDamageReflect
EXTRN	?IsExtDamageMinus@CItem@@QAEHXZ:PROC		; CItem::IsExtDamageMinus
EXTRN	?IsExtManaAdd@CItem@@QAEHXZ:PROC		; CItem::IsExtManaAdd
EXTRN	?IsExtLifeAdd@CItem@@QAEHXZ:PROC		; CItem::IsExtLifeAdd
; Function compile flags: /Ogtp
;	COMDAT ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_lpItem$ = 12						; size = 4
?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z PROC		; ItemIsBufExOption, COMDAT

; 2217 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2218 : 	for ( int i=0;i<MAX_EXOPTION_SIZE;i++ )
; 2219 : 	{
; 2220 : 		buf[i] = 0;

  00005	8b 75 08	 mov	 esi, DWORD PTR _buf$[ebp]
  00008	57		 push	 edi

; 2221 : 	}
; 2222 : 
; 2223 : 	if ( lpItem->IsExtLifeAdd() != FALSE )

  00009	8b 7d 0c	 mov	 edi, DWORD PTR _lpItem$[ebp]
  0000c	33 c0		 xor	 eax, eax
  0000e	89 06		 mov	 DWORD PTR [esi], eax
  00010	8b cf		 mov	 ecx, edi
  00012	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00015	e8 00 00 00 00	 call	 ?IsExtLifeAdd@CItem@@QAEHXZ ; CItem::IsExtLifeAdd
  0001a	b3 01		 mov	 bl, 1
  0001c	85 c0		 test	 eax, eax
  0001e	74 02		 je	 SHORT $LN6@ItemIsBufE

; 2224 : 	{
; 2225 : 		buf[0] = TRUE;

  00020	88 1e		 mov	 BYTE PTR [esi], bl
$LN6@ItemIsBufE:

; 2226 : 	}
; 2227 : 
; 2228 : 	if ( lpItem->IsExtManaAdd() != FALSE )

  00022	8b cf		 mov	 ecx, edi
  00024	e8 00 00 00 00	 call	 ?IsExtManaAdd@CItem@@QAEHXZ ; CItem::IsExtManaAdd
  00029	85 c0		 test	 eax, eax
  0002b	74 03		 je	 SHORT $LN5@ItemIsBufE

; 2229 : 	{
; 2230 : 		buf[1] = TRUE;

  0002d	88 5e 01	 mov	 BYTE PTR [esi+1], bl
$LN5@ItemIsBufE:

; 2231 : 	}
; 2232 : 
; 2233 : 	if ( lpItem->IsExtDamageMinus() != FALSE )

  00030	8b cf		 mov	 ecx, edi
  00032	e8 00 00 00 00	 call	 ?IsExtDamageMinus@CItem@@QAEHXZ ; CItem::IsExtDamageMinus
  00037	85 c0		 test	 eax, eax
  00039	74 03		 je	 SHORT $LN4@ItemIsBufE

; 2234 : 	{
; 2235 : 		buf[2] = TRUE;

  0003b	88 5e 02	 mov	 BYTE PTR [esi+2], bl
$LN4@ItemIsBufE:

; 2236 : 	}
; 2237 : 
; 2238 : 	if ( lpItem->IsExtDamageReflect() != FALSE )

  0003e	8b cf		 mov	 ecx, edi
  00040	e8 00 00 00 00	 call	 ?IsExtDamageReflect@CItem@@QAEHXZ ; CItem::IsExtDamageReflect
  00045	85 c0		 test	 eax, eax
  00047	74 03		 je	 SHORT $LN3@ItemIsBufE

; 2239 : 	{
; 2240 : 		buf[3] = TRUE;

  00049	88 5e 03	 mov	 BYTE PTR [esi+3], bl
$LN3@ItemIsBufE:

; 2241 : 	}
; 2242 : 
; 2243 : 	if ( lpItem->IsExtDefenseSuccessfull() != FALSE )

  0004c	8b cf		 mov	 ecx, edi
  0004e	e8 00 00 00 00	 call	 ?IsExtDefenseSuccessfull@CItem@@QAEHXZ ; CItem::IsExtDefenseSuccessfull
  00053	85 c0		 test	 eax, eax
  00055	74 03		 je	 SHORT $LN2@ItemIsBufE

; 2244 : 	{
; 2245 : 		buf[4] = TRUE;

  00057	88 5e 04	 mov	 BYTE PTR [esi+4], bl
$LN2@ItemIsBufE:

; 2246 : 	}
; 2247 : 
; 2248 : 	if ( lpItem->IsExtMonsterMoney() != FALSE )

  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 ?IsExtMonsterMoney@CItem@@QAEHXZ ; CItem::IsExtMonsterMoney
  00061	85 c0		 test	 eax, eax
  00063	74 03		 je	 SHORT $LN1@ItemIsBufE

; 2249 : 	{
; 2250 : 		buf[5] = TRUE;

  00065	88 5e 05	 mov	 BYTE PTR [esi+5], bl
$LN1@ItemIsBufE:
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx

; 2251 : 	}
; 2252 : 
; 2253 : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ENDP		; ItemIsBufExOption
_TEXT	ENDS
PUBLIC	??_C@_0HG@OJODFIFG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CharInfoSave?5?3?5Class?$DN?$CFd@ ; `string'
PUBLIC	?gObjStatTextSave@@YAXPAUOBJECTSTRUCT@@@Z	; gObjStatTextSave
;	COMDAT ??_C@_0HG@OJODFIFG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CharInfoSave?5?3?5Class?$DN?$CFd@
CONST	SEGMENT
??_C@_0HG@OJODFIFG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CharInfoSave?5?3?5Class?$DN?$CFd@ DB '['
	DB	'%s][%s] CharInfoSave : Class=%d Level=%d LVPoint=%d Exp=%u St'
	DB	'r=%d Dex=%d Vit=%d Energy=%d Leadership:%d Map=%d Pk=%d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjStatTextSave@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjStatTextSave@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjStatTextSave, COMDAT

; 2256 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2257 : 	LogAdd(LOG_BLACK, "[%s][%s] CharInfoSave : Class=%d Level=%d LVPoint=%d Exp=%u Str=%d Dex=%d Vit=%d Energy=%d Leadership:%d Map=%d Pk=%d",
; 2258 : 		lpObj->AccountID, lpObj->Name, lpObj->DbClass,lpObj->Level, lpObj->LevelUpPoint, lpObj->Experience, 
; 2259 : 		lpObj->Strength, lpObj->Dexterity, lpObj->Vitality, lpObj->Energy, lpObj->Leadership, lpObj->MapNumber,
; 2260 : 		lpObj->m_PK_Level);

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  0000d	0f b6 90 09 01
	00 00		 movzx	 edx, BYTE PTR [eax+265]
  00014	51		 push	 ecx
  00015	0f b7 88 d8 00
	00 00		 movzx	 ecx, WORD PTR [eax+216]
  0001c	52		 push	 edx
  0001d	0f b7 90 ba 00
	00 00		 movzx	 edx, WORD PTR [eax+186]
  00024	51		 push	 ecx
  00025	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0002c	52		 push	 edx
  0002d	0f b7 90 b6 00
	00 00		 movzx	 edx, WORD PTR [eax+182]
  00034	51		 push	 ecx
  00035	0f b7 88 b4 00
	00 00		 movzx	 ecx, WORD PTR [eax+180]
  0003c	52		 push	 edx
  0003d	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  00043	51		 push	 ecx
  00044	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0004a	52		 push	 edx
  0004b	0f bf 90 9c 00
	00 00		 movsx	 edx, WORD PTR [eax+156]
  00052	51		 push	 ecx
  00053	0f b6 88 9a 00
	00 00		 movzx	 ecx, BYTE PTR [eax+154]
  0005a	52		 push	 edx
  0005b	51		 push	 ecx
  0005c	8d 50 6f	 lea	 edx, DWORD PTR [eax+111]
  0005f	52		 push	 edx
  00060	83 c0 64	 add	 eax, 100		; 00000064H
  00063	50		 push	 eax
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0HG@OJODFIFG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CharInfoSave?5?3?5Class?$DN?$CFd@
  00069	6a 00		 push	 0
  0006b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00070	83 c4 3c	 add	 esp, 60			; 0000003cH

; 2261 : }

  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?gObjStatTextSave@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjStatTextSave
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z	; gObjItemTextSave
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv361 = -20						; size = 4
tv359 = -20						; size = 4
tv364 = -14						; size = 2
_NewOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjItemTextSave, COMDAT

; 2264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 2265 : 	BYTE NewOption[MAX_EXOPTION_SIZE];
; 2266 : 	int n;
; 2267 : 
; 2268 : 	for (int n=0;n<INVENTORY_SIZE;n++)

  00016	33 db		 xor	 ebx, ebx

; 2269 : 	{
; 2270 : 		if ( lpObj->pInventory[n].IsItem() == TRUE )

  00018	33 ff		 xor	 edi, edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL5@gObjItemTe:
  00020	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00026	03 cf		 add	 ecx, edi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	0f 85 bd 00 00
	00		 jne	 $LN4@gObjItemTe

; 2271 : 		{
; 2272 : 			if ( lpObj->pInventory[n].m_serial != 0 )

  00036	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0003c	03 c7		 add	 eax, edi
  0003e	80 78 04 00	 cmp	 BYTE PTR [eax+4], 0
  00042	0f 84 ab 00 00
	00		 je	 $LN4@gObjItemTe

; 2273 : 			{
; 2274 : 				ItemIsBufExOption(NewOption, &lpObj->pInventory[n]);

  00048	50		 push	 eax
  00049	8d 4d f4	 lea	 ecx, DWORD PTR _NewOption$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 2275 : 				LogAdd(LOG_BLACK, lMsg.Get(MSGGET(1, 248)), lpObj->AccountID, lpObj->Name, n, lpObj->pInventory[n].GetName(),
; 2276 : 					lpObj->pInventory[n].m_Level, lpObj->pInventory[n].m_Option1,
; 2277 : 					lpObj->pInventory[n].m_Option2, lpObj->pInventory[n].m_Option3,
; 2278 : 					lpObj->pInventory[n].m_Number, (BYTE)lpObj->pInventory[n].m_Durability,
; 2279 : 					NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6],
; 2280 : 					lpObj->pInventory[n].m_SetOption, 0, 0, 0);

  00052	d9 7d f2	 fnstcw	 WORD PTR tv364[ebp]
  00055	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  0005b	d9 44 17 24	 fld	 DWORD PTR [edi+edx+36]
  0005f	0f b6 84 17 92
	00 00 00	 movzx	 eax, BYTE PTR [edi+edx+146]
  00067	83 c4 08	 add	 esp, 8
  0006a	6a 00		 push	 0
  0006c	8d 0c 17	 lea	 ecx, DWORD PTR [edi+edx]
  0006f	0f b6 55 fa	 movzx	 edx, BYTE PTR _NewOption$[ebp+6]
  00073	6a 00		 push	 0
  00075	6a 00		 push	 0
  00077	50		 push	 eax
  00078	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$[ebp+5]
  0007c	52		 push	 edx
  0007d	0f b6 55 f8	 movzx	 edx, BYTE PTR _NewOption$[ebp+4]
  00081	50		 push	 eax
  00082	0f b6 45 f7	 movzx	 eax, BYTE PTR _NewOption$[ebp+3]
  00086	52		 push	 edx
  00087	0f b6 55 f6	 movzx	 edx, BYTE PTR _NewOption$[ebp+2]
  0008b	50		 push	 eax
  0008c	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$[ebp+1]
  00090	52		 push	 edx
  00091	0f b6 55 f4	 movzx	 edx, BYTE PTR _NewOption$[ebp]
  00095	50		 push	 eax
  00096	0f b7 45 f2	 movzx	 eax, WORD PTR tv364[ebp]
  0009a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0009f	89 45 ec	 mov	 DWORD PTR tv361[ebp], eax
  000a2	52		 push	 edx
  000a3	d9 6d ec	 fldcw	 WORD PTR tv361[ebp]
  000a6	db 5d ec	 fistp	 DWORD PTR tv359[ebp]
  000a9	8a 45 ec	 mov	 al, BYTE PTR tv359[ebp]
  000ac	0f b6 d0	 movzx	 edx, al
  000af	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b1	d9 6d f2	 fldcw	 WORD PTR tv364[ebp]
  000b4	52		 push	 edx
  000b5	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  000b9	50		 push	 eax
  000ba	0f b6 41 79	 movzx	 eax, BYTE PTR [ecx+121]
  000be	52		 push	 edx
  000bf	0f b6 51 78	 movzx	 edx, BYTE PTR [ecx+120]
  000c3	50		 push	 eax
  000c4	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  000c8	52		 push	 edx
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000cf	50		 push	 eax
  000d0	53		 push	 ebx
  000d1	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  000d4	51		 push	 ecx
  000d5	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  000d8	52		 push	 edx
  000d9	68 f8 01 00 00	 push	 504			; 000001f8H
  000de	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000e3	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000e8	50		 push	 eax
  000e9	6a 00		 push	 0
  000eb	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000f0	83 c4 5c	 add	 esp, 92			; 0000005cH
$LN4@gObjItemTe:

; 2265 : 	BYTE NewOption[MAX_EXOPTION_SIZE];
; 2266 : 	int n;
; 2267 : 
; 2268 : 	for (int n=0;n<INVENTORY_SIZE;n++)

  000f3	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  000f9	43		 inc	 ebx
  000fa	81 ff e0 46 00
	00		 cmp	 edi, 18144		; 000046e0H
  00100	0f 8c 1a ff ff
	ff		 jl	 $LL5@gObjItemTe

; 2281 : 			}
; 2282 : 		}
; 2283 : 	}
; 2284 : 
; 2285 : 	LogAdd(LOG_BLACK, lMsg.Get(MSGGET(1, 249)), lpObj->AccountID, lpObj->Name, lpObj->Money);

  00106	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  0010c	50		 push	 eax
  0010d	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  00110	51		 push	 ecx
  00111	83 c6 64	 add	 esi, 100		; 00000064H
  00114	56		 push	 esi
  00115	68 f9 01 00 00	 push	 505			; 000001f9H
  0011a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0011f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00124	50		 push	 eax
  00125	6a 00		 push	 0
  00127	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2286 : }

  0012c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012f	83 c4 14	 add	 esp, 20			; 00000014H
  00132	5f		 pop	 edi
  00133	5e		 pop	 esi
  00134	33 cd		 xor	 ecx, ebp
  00136	5b		 pop	 ebx
  00137	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c3		 ret	 0
?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjItemTextSave
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z	; gObjWarehouseTextSave
; Function compile flags: /Ogtp
;	COMDAT ?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv361 = -20						; size = 4
tv359 = -20						; size = 4
tv364 = -14						; size = 2
_NewOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjWarehouseTextSave, COMDAT

; 2289 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 2290 : 	BYTE NewOption[MAX_EXOPTION_SIZE];
; 2291 : 	int n;
; 2292 : 
; 2293 : 	for (int n=0;n<WAREHOUSE_SIZE;n++)

  00016	33 db		 xor	 ebx, ebx

; 2294 : 	{
; 2295 : 		if ( lpObj->pWarehouse[n].IsItem() == TRUE )

  00018	33 ff		 xor	 edi, edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL5@gObjWareho:
  00020	8b 8e c4 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3268]
  00026	03 cf		 add	 ecx, edi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	0f 85 bd 00 00
	00		 jne	 $LN4@gObjWareho

; 2296 : 		{
; 2297 : 			if ( lpObj->pWarehouse[n].m_serial != 0 )

  00036	8b 86 c4 0c 00
	00		 mov	 eax, DWORD PTR [esi+3268]
  0003c	03 c7		 add	 eax, edi
  0003e	80 78 04 00	 cmp	 BYTE PTR [eax+4], 0
  00042	0f 84 ab 00 00
	00		 je	 $LN4@gObjWareho

; 2298 : 			{
; 2299 : 				ItemIsBufExOption(NewOption, &lpObj->pWarehouse[n]);

  00048	50		 push	 eax
  00049	8d 4d f4	 lea	 ecx, DWORD PTR _NewOption$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 2300 : 				LogAdd(LOG_BLACK, lMsg.Get(MSGGET(1, 250)), lpObj->AccountID, lpObj->Name, n, lpObj->pWarehouse[n].GetName(),
; 2301 : 					lpObj->pWarehouse[n].m_Level, lpObj->pWarehouse[n].m_Option1,
; 2302 : 					lpObj->pWarehouse[n].m_Option2, lpObj->pWarehouse[n].m_Option3,
; 2303 : 					lpObj->pWarehouse[n].m_Number, (BYTE)lpObj->pWarehouse[n].m_Durability,
; 2304 : 					NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6],
; 2305 : 					lpObj->pWarehouse[n].m_SetOption, 0, 0, 0);

  00052	d9 7d f2	 fnstcw	 WORD PTR tv364[ebp]
  00055	8b 96 c4 0c 00
	00		 mov	 edx, DWORD PTR [esi+3268]
  0005b	d9 44 17 24	 fld	 DWORD PTR [edi+edx+36]
  0005f	0f b6 84 17 92
	00 00 00	 movzx	 eax, BYTE PTR [edi+edx+146]
  00067	83 c4 08	 add	 esp, 8
  0006a	6a 00		 push	 0
  0006c	8d 0c 17	 lea	 ecx, DWORD PTR [edi+edx]
  0006f	0f b6 55 fa	 movzx	 edx, BYTE PTR _NewOption$[ebp+6]
  00073	6a 00		 push	 0
  00075	6a 00		 push	 0
  00077	50		 push	 eax
  00078	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$[ebp+5]
  0007c	52		 push	 edx
  0007d	0f b6 55 f8	 movzx	 edx, BYTE PTR _NewOption$[ebp+4]
  00081	50		 push	 eax
  00082	0f b6 45 f7	 movzx	 eax, BYTE PTR _NewOption$[ebp+3]
  00086	52		 push	 edx
  00087	0f b6 55 f6	 movzx	 edx, BYTE PTR _NewOption$[ebp+2]
  0008b	50		 push	 eax
  0008c	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$[ebp+1]
  00090	52		 push	 edx
  00091	0f b6 55 f4	 movzx	 edx, BYTE PTR _NewOption$[ebp]
  00095	50		 push	 eax
  00096	0f b7 45 f2	 movzx	 eax, WORD PTR tv364[ebp]
  0009a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0009f	89 45 ec	 mov	 DWORD PTR tv361[ebp], eax
  000a2	52		 push	 edx
  000a3	d9 6d ec	 fldcw	 WORD PTR tv361[ebp]
  000a6	db 5d ec	 fistp	 DWORD PTR tv359[ebp]
  000a9	8a 45 ec	 mov	 al, BYTE PTR tv359[ebp]
  000ac	0f b6 d0	 movzx	 edx, al
  000af	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b1	d9 6d f2	 fldcw	 WORD PTR tv364[ebp]
  000b4	52		 push	 edx
  000b5	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  000b9	50		 push	 eax
  000ba	0f b6 41 79	 movzx	 eax, BYTE PTR [ecx+121]
  000be	52		 push	 edx
  000bf	0f b6 51 78	 movzx	 edx, BYTE PTR [ecx+120]
  000c3	50		 push	 eax
  000c4	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  000c8	52		 push	 edx
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000cf	50		 push	 eax
  000d0	53		 push	 ebx
  000d1	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  000d4	51		 push	 ecx
  000d5	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  000d8	52		 push	 edx
  000d9	68 fa 01 00 00	 push	 506			; 000001faH
  000de	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000e3	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000e8	50		 push	 eax
  000e9	6a 00		 push	 0
  000eb	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000f0	83 c4 5c	 add	 esp, 92			; 0000005cH
$LN4@gObjWareho:

; 2290 : 	BYTE NewOption[MAX_EXOPTION_SIZE];
; 2291 : 	int n;
; 2292 : 
; 2293 : 	for (int n=0;n<WAREHOUSE_SIZE;n++)

  000f3	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  000f9	43		 inc	 ebx
  000fa	81 ff c0 4e 00
	00		 cmp	 edi, 20160		; 00004ec0H
  00100	0f 8c 1a ff ff
	ff		 jl	 $LL5@gObjWareho

; 2306 : 			}
; 2307 : 		}
; 2308 : 	}
; 2309 : 
; 2310 : 	LogAdd(LOG_BLACK, lMsg.Get(MSGGET(1, 251)), lpObj->AccountID, lpObj->Name, lpObj->WarehouseMoney);

  00106	8b 86 d4 0c 00
	00		 mov	 eax, DWORD PTR [esi+3284]
  0010c	50		 push	 eax
  0010d	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  00110	51		 push	 ecx
  00111	83 c6 64	 add	 esi, 100		; 00000064H
  00114	56		 push	 esi
  00115	68 fb 01 00 00	 push	 507			; 000001fbH
  0011a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0011f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00124	50		 push	 eax
  00125	6a 00		 push	 0
  00127	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2311 : }

  0012c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012f	83 c4 14	 add	 esp, 20			; 00000014H
  00132	5f		 pop	 edi
  00133	5e		 pop	 esi
  00134	33 cd		 xor	 ecx, ebp
  00136	5b		 pop	 ebx
  00137	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c3		 ret	 0
?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjWarehouseTextSave
_TEXT	ENDS
PUBLIC	?gObjAuthorityCodeSet@@YAXPAUOBJECTSTRUCT@@@Z	; gObjAuthorityCodeSet
; Function compile flags: /Ogtp
;	COMDAT ?gObjAuthorityCodeSet@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjAuthorityCodeSet@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjAuthorityCodeSet, COMDAT

; 2314 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2315 : 	if ( (lpObj->Authority&1) == 1 )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00006	8b 81 a4 01 00
	00		 mov	 eax, DWORD PTR [ecx+420]
  0000c	a8 01		 test	 al, 1
  0000e	75 27		 jne	 SHORT $LN1@gObjAuthor

; 2316 : 	{
; 2317 : 		return;
; 2318 : 	}
; 2319 : 
; 2320 : 	if ( (lpObj->Authority&2)== 2 )

  00010	a8 02		 test	 al, 2
  00012	74 0c		 je	 SHORT $LN5@gObjAuthor

; 2321 : 	{
; 2322 : 		lpObj->AuthorityCode = -1;

  00014	c7 81 a8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+424], -1

; 2356 : 
; 2357 : 		return;
; 2358 : 	}
; 2359 : 
; 2360 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
$LN5@gObjAuthor:

; 2323 : 		return;
; 2324 : 	}
; 2325 : 
; 2326 : 	if ( (lpObj->Authority&4) == 4 )

  00020	a8 04		 test	 al, 4
  00022	75 13		 jne	 SHORT $LN1@gObjAuthor

; 2327 : 	{
; 2328 : 		return;
; 2329 : 	}
; 2330 : 
; 2331 : 	if ( (lpObj->Authority&8) == 8 )

  00024	a8 08		 test	 al, 8

; 2332 : 	{
; 2333 : 		lpObj->AuthorityCode |= 1;
; 2334 : 		lpObj->AuthorityCode |= 2;
; 2335 : 		lpObj->AuthorityCode |= 4;
; 2336 : 		lpObj->AuthorityCode |= 8;
; 2337 : 		lpObj->AuthorityCode |= 16;
; 2338 : 		lpObj->AuthorityCode |= 32;
; 2339 : 
; 2340 : 		return;

  00026	75 08		 jne	 SHORT $LN9@gObjAuthor

; 2341 : 	}
; 2342 : 
; 2343 : 	if ( (lpObj->Authority&16) == 16 )

  00028	a8 10		 test	 al, 16			; 00000010H
  0002a	75 0b		 jne	 SHORT $LN1@gObjAuthor

; 2344 : 	{
; 2345 : 		return;
; 2346 : 	}
; 2347 : 
; 2348 : 	if ( (lpObj->Authority&32) == 32 )

  0002c	a8 20		 test	 al, 32			; 00000020H
  0002e	74 07		 je	 SHORT $LN1@gObjAuthor
$LN9@gObjAuthor:

; 2349 : 	{
; 2350 : 		lpObj->AuthorityCode |= 1;
; 2351 : 		lpObj->AuthorityCode |= 2;
; 2352 : 		lpObj->AuthorityCode |= 4;
; 2353 : 		lpObj->AuthorityCode |= 8;
; 2354 : 		lpObj->AuthorityCode |= 16;
; 2355 : 		lpObj->AuthorityCode |= 32;

  00030	83 89 a8 01 00
	00 3f		 or	 DWORD PTR [ecx+424], 63	; 0000003fH
$LN1@gObjAuthor:

; 2356 : 
; 2357 : 		return;
; 2358 : 	}
; 2359 : 
; 2360 : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?gObjAuthorityCodeSet@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjAuthorityCodeSet
_TEXT	ENDS
PUBLIC	??_C@_0BJ@KEIINKC@error?9L2?5?3?5?$CFd?5class?5?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	?gObjSetPosMonster@@YAHHH@Z			; gObjSetPosMonster
EXTRN	?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z:PROC	; CMonsterSetBase::GetPosition
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
;	COMDAT ??_C@_0BJ@KEIINKC@error?9L2?5?3?5?$CFd?5class?5?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BJ@KEIINKC@error?9L2?5?3?5?$CFd?5class?5?3?5?$CFd?$AA@ DB 'error-L'
	DB	'2 : %d class : %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@ DB 'error : %s %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjSetPosMonster@@YAHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_PosTableNum$ = 12					; size = 4
?gObjSetPosMonster@@YAHHH@Z PROC			; gObjSetPosMonster, COMDAT

; 2363 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2364 : 	if ( (  (aIndex<0)? FALSE: (aIndex > OBJMAX-1)? FALSE: TRUE ) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 0f		 js	 SHORT $LN15@gObjSetPos
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 1e		 jne	 SHORT $LN8@gObjSetPos
$LN15@gObjSetPos:

; 2365 : 	{
; 2366 : 		LogAdd(LOG_BLACK, "error : %s %d", __FILE__, __LINE__);

  0001a	68 3e 09 00 00	 push	 2366			; 0000093eH
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00029	6a 00		 push	 0
  0002b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00030	83 c4 10	 add	 esp, 16			; 00000010H

; 2367 : 		return FALSE;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 2413 : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN8@gObjSetPos:
  00038	57		 push	 edi

; 2368 : 	}
; 2369 : 
; 2370 : 	if ( (  (PosTableNum<0)? FALSE: (PosTableNum > OBJ_MAXMONSTER-1)? FALSE: TRUE ) == FALSE )

  00039	8b 7d 0c	 mov	 edi, DWORD PTR _PosTableNum$[ebp]
  0003c	85 ff		 test	 edi, edi
  0003e	78 0f		 js	 SHORT $LN16@gObjSetPos
  00040	33 c0		 xor	 eax, eax
  00042	81 ff a7 16 00
	00		 cmp	 edi, 5799		; 000016a7H
  00048	0f 9e c0	 setle	 al
  0004b	85 c0		 test	 eax, eax
  0004d	75 1f		 jne	 SHORT $LN7@gObjSetPos
$LN16@gObjSetPos:

; 2371 : 	{
; 2372 : 		LogAdd(LOG_BLACK, "error : %s %d", __FILE__, __LINE__);

  0004f	68 44 09 00 00	 push	 2372			; 00000944H
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  0005e	6a 00		 push	 0
  00060	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00065	83 c4 10	 add	 esp, 16			; 00000010H
  00068	5f		 pop	 edi

; 2373 : 		return FALSE;

  00069	33 c0		 xor	 eax, eax
  0006b	5e		 pop	 esi

; 2413 : }

  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN7@gObjSetPos:

; 2374 : 	}
; 2375 : 
; 2376 : 	LPOBJ lpObj = &gObj[aIndex];

  0006e	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00074	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2377 : 	lpObj->m_PosNum = PosTableNum;

  0007a	66 89 be 10 02
	00 00		 mov	 WORD PTR [esi+528], di

; 2378 : 	lpObj->X = gMSetBase.m_Mp[PosTableNum].m_X;

  00081	8d 3c 7f	 lea	 edi, DWORD PTR [edi+edi*2]
  00084	03 ff		 add	 edi, edi

; 2379 : 	lpObj->Y = gMSetBase.m_Mp[PosTableNum].m_Y;

  00086	0f b6 8c 3f 0b
	00 00 00	 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[edi+edi+11]
  0008e	0f b6 84 3f 0a
	00 00 00	 movzx	 eax, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[edi+edi+10]

; 2380 : 	lpObj->MapNumber = gMSetBase.m_Mp[PosTableNum].m_MapNumber;

  00096	8a 94 3f 08 00
	00 00		 mov	 dl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[edi+edi+8]
  0009d	03 ff		 add	 edi, edi
  0009f	53		 push	 ebx
  000a0	8d 9e 04 01 00
	00		 lea	 ebx, DWORD PTR [esi+260]
  000a6	66 89 03	 mov	 WORD PTR [ebx], ax
  000a9	66 89 8e 06 01
	00 00		 mov	 WORD PTR [esi+262], cx

; 2381 : 	lpObj->TX = lpObj->X;

  000b0	66 89 86 20 01
	00 00		 mov	 WORD PTR [esi+288], ax

; 2382 : 	lpObj->TY = lpObj->Y;
; 2383 : 	lpObj->m_OldX = lpObj->X;

  000b7	66 89 86 1c 01
	00 00		 mov	 WORD PTR [esi+284], ax

; 2384 : 	lpObj->m_OldY = lpObj->Y;
; 2385 : 	lpObj->Dir = gMSetBase.m_Mp[PosTableNum].m_Dir;

  000be	0f b6 87 0c 00
	00 00		 movzx	 eax, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[edi+12]
  000c5	66 89 8e 22 01
	00 00		 mov	 WORD PTR [esi+290], cx
  000cc	66 89 8e 1e 01
	00 00		 mov	 WORD PTR [esi+286], cx

; 2386 : 	lpObj->StartX = lpObj->X;

  000d3	8a 0b		 mov	 cl, BYTE PTR [ebx]
  000d5	88 8e 1a 01 00
	00		 mov	 BYTE PTR [esi+282], cl
  000db	88 86 08 01 00
	00		 mov	 BYTE PTR [esi+264], al

; 2387 : 	lpObj->StartY = lpObj->Y;

  000e1	0f b6 86 06 01
	00 00		 movzx	 eax, BYTE PTR [esi+262]
  000e8	8d 8e 06 01 00
	00		 lea	 ecx, DWORD PTR [esi+262]
  000ee	88 86 1b 01 00
	00		 mov	 BYTE PTR [esi+283], al

; 2388 : 
; 2389 : 	if ( lpObj->Class == 44 ||  lpObj->Class == 53 ||  lpObj->Class == 54 ||  lpObj->Class == 55 ||  lpObj->Class == 56)

  000f4	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  000fb	88 96 09 01 00
	00		 mov	 BYTE PTR [esi+265], dl
  00101	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00104	74 79		 je	 SHORT $LN5@gObjSetPos
  00106	83 f8 35	 cmp	 eax, 53			; 00000035H
  00109	74 74		 je	 SHORT $LN5@gObjSetPos
  0010b	83 f8 36	 cmp	 eax, 54			; 00000036H
  0010e	74 6f		 je	 SHORT $LN5@gObjSetPos
  00110	83 f8 37	 cmp	 eax, 55			; 00000037H
  00113	74 6a		 je	 SHORT $LN5@gObjSetPos
  00115	83 f8 38	 cmp	 eax, 56			; 00000038H
  00118	74 65		 je	 SHORT $LN5@gObjSetPos

; 2390 : 	{
; 2391 : 
; 2392 : 	}
; 2393 : 	else if (  lpObj->Class >= 78 &&  lpObj->Class <= 83)

  0011a	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  0011d	72 05		 jb	 SHORT $LN3@gObjSetPos
  0011f	83 f8 53	 cmp	 eax, 83			; 00000053H
  00122	76 5b		 jbe	 SHORT $LN5@gObjSetPos
$LN3@gObjSetPos:

; 2394 : 	{
; 2395 : 
; 2396 : 	}
; 2397 : 	else if ( gMSetBase.GetPosition(PosTableNum, lpObj->MapNumber, lpObj->X, lpObj->Y) == FALSE )

  00124	8b 45 0c	 mov	 eax, DWORD PTR _PosTableNum$[ebp]
  00127	51		 push	 ecx
  00128	0f b6 d2	 movzx	 edx, dl
  0012b	53		 push	 ebx
  0012c	52		 push	 edx
  0012d	50		 push	 eax
  0012e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A ; gMSetBase
  00133	e8 00 00 00 00	 call	 ?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z ; CMonsterSetBase::GetPosition
  00138	85 c0		 test	 eax, eax
  0013a	75 43		 jne	 SHORT $LN5@gObjSetPos

; 2398 : 	{
; 2399 : 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(1, 252)), __FILE__, __LINE__);

  0013c	68 5f 09 00 00	 push	 2399			; 0000095fH
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00146	68 fc 01 00 00	 push	 508			; 000001fcH
  0014b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00150	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00155	50		 push	 eax
  00156	6a 00		 push	 0
  00158	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2400 : 		LogAdd(LOG_BLACK, "error-L2 : %d class : %d", PosTableNum, lpObj->Class);

  0015d	0f b7 8e 98 00
	00 00		 movzx	 ecx, WORD PTR [esi+152]
  00164	8b 55 0c	 mov	 edx, DWORD PTR _PosTableNum$[ebp]
  00167	51		 push	 ecx
  00168	52		 push	 edx
  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@KEIINKC@error?9L2?5?3?5?$CFd?5class?5?3?5?$CFd?$AA@
  0016e	6a 00		 push	 0
  00170	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00175	83 c4 20	 add	 esp, 32			; 00000020H
  00178	5b		 pop	 ebx
  00179	5f		 pop	 edi

; 2401 : 		return FALSE;

  0017a	33 c0		 xor	 eax, eax
  0017c	5e		 pop	 esi

; 2413 : }

  0017d	5d		 pop	 ebp
  0017e	c3		 ret	 0
$LN5@gObjSetPos:

; 2402 : 	}
; 2403 : 
; 2404 : 	lpObj->TX = lpObj->X;
; 2405 : 	lpObj->TY = lpObj->Y;

  0017f	0f b7 8e 06 01
	00 00		 movzx	 ecx, WORD PTR [esi+262]
  00186	0f b7 03	 movzx	 eax, WORD PTR [ebx]

; 2406 : 	lpObj->m_OldX = lpObj->X;
; 2407 : 	lpObj->m_OldY = lpObj->Y;
; 2408 : 	lpObj->Dir = gMSetBase.m_Mp[PosTableNum].m_Dir;
; 2409 : 	lpObj->StartX = lpObj->X;
; 2410 : 	lpObj->StartY = lpObj->Y;

  00189	8a 96 06 01 00
	00		 mov	 dl, BYTE PTR [esi+262]
  0018f	66 89 8e 22 01
	00 00		 mov	 WORD PTR [esi+290], cx
  00196	66 89 8e 1e 01
	00 00		 mov	 WORD PTR [esi+286], cx
  0019d	8a 0b		 mov	 cl, BYTE PTR [ebx]
  0019f	66 89 86 20 01
	00 00		 mov	 WORD PTR [esi+288], ax
  001a6	66 89 86 1c 01
	00 00		 mov	 WORD PTR [esi+284], ax
  001ad	8a 87 0c 00 00
	00		 mov	 al, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[edi+12]
  001b3	5b		 pop	 ebx
  001b4	88 86 08 01 00
	00		 mov	 BYTE PTR [esi+264], al
  001ba	5f		 pop	 edi
  001bb	88 8e 1a 01 00
	00		 mov	 BYTE PTR [esi+282], cl
  001c1	88 96 1b 01 00
	00		 mov	 BYTE PTR [esi+283], dl

; 2411 : 
; 2412 : 	return true;

  001c7	b8 01 00 00 00	 mov	 eax, 1
  001cc	5e		 pop	 esi

; 2413 : }

  001cd	5d		 pop	 ebp
  001ce	c3		 ret	 0
?gObjSetPosMonster@@YAHHH@Z ENDP			; gObjSetPosMonster
_TEXT	ENDS
PUBLIC	?gObjDestroy@@YAXIH@Z				; gObjDestroy
; Function compile flags: /Ogtp
;	COMDAT ?gObjDestroy@@YAXIH@Z
_TEXT	SEGMENT
_aSocket$ = 8						; size = 4
_client$ = 12						; size = 4
?gObjDestroy@@YAXIH@Z PROC				; gObjDestroy, COMDAT

; 2711 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2712 : 	if ( client < 0 || client > OBJMAX-1)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _client$[ebp]
  00006	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  0000b	77 0d		 ja	 SHORT $LN1@gObjDestro

; 2713 : 	{
; 2714 : 		return;
; 2715 : 	}
; 2716 : 
; 2717 : 	gObj[client].Connected = PLAYER_EMPTY;

  0000d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00013	c6 80 04 00 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 0
$LN1@gObjDestro:

; 2718 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?gObjDestroy@@YAXIH@Z ENDP				; gObjDestroy
_TEXT	ENDS
PUBLIC	?gObjAddSearch@@YAFIPAD@Z			; gObjAddSearch
EXTRN	?GCJoinSocketResult@@YAXEI@Z:PROC		; GCJoinSocketResult
EXTRN	?IsIp@CAcceptIp@@QAEHPAD@Z:PROC			; CAcceptIp::IsIp
EXTRN	?acceptIP@@3VCAcceptIp@@A:BYTE			; acceptIP
; Function compile flags: /Ogtp
;	COMDAT ?gObjAddSearch@@YAFIPAD@Z
_TEXT	SEGMENT
_aSocket$ = 8						; size = 4
_ip$ = 12						; size = 4
?gObjAddSearch@@YAFIPAD@Z PROC				; gObjAddSearch, COMDAT

; 2721 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2722 : 	int count;
; 2723 : 	int totalcount = 0;

  00004	33 f6		 xor	 esi, esi

; 2724 : 
; 2725 : 	if ( gDisconnect == 1 )

  00006	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect

; 2726 : 	{
; 2727 : 		return -1;

  0000d	74 2d		 je	 SHORT $LN14@gObjAddSea

; 2728 : 	}
; 2729 : 
; 2730 : 	if ( gObjTotalUser > gServerMaxUser )

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjTotalUser@@3HA ; gObjTotalUser
  00014	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?gServerMaxUser@@3HA ; gServerMaxUser
  0001a	7e 26		 jle	 SHORT $LN6@gObjAddSea

; 2731 : 	{
; 2732 : 		if (acceptIP.IsIp(ip) == 0 )

  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _ip$[ebp]
  0001f	51		 push	 ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET ?acceptIP@@3VCAcceptIp@@A ; acceptIP
  00025	e8 00 00 00 00	 call	 ?IsIp@CAcceptIp@@QAEHPAD@Z ; CAcceptIp::IsIp
  0002a	85 c0		 test	 eax, eax
  0002c	75 14		 jne	 SHORT $LN6@gObjAddSea

; 2733 : 		{
; 2734 : 			GCJoinSocketResult(4, aSocket);

  0002e	8b 55 08	 mov	 edx, DWORD PTR _aSocket$[ebp]
  00031	52		 push	 edx
  00032	6a 04		 push	 4
  00034	e8 00 00 00 00	 call	 ?GCJoinSocketResult@@YAXEI@Z ; GCJoinSocketResult
  00039	83 c4 08	 add	 esp, 8
$LN14@gObjAddSea:

; 2756 : 		{
; 2757 : 			break;
; 2758 : 		}
; 2759 : 	}
; 2760 : 	return -1;

  0003c	83 c8 ff	 or	 eax, -1
$LN9@gObjAddSea:
  0003f	5e		 pop	 esi

; 2761 : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN6@gObjAddSea:

; 2735 : 			return -1;
; 2736 : 		}
; 2737 : 	}
; 2738 : 
; 2739 : 	count = gObjCount;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjCount@@3HA ; gObjCount

; 2740 : 	
; 2741 : 	while ( true )
; 2742 : 	{
; 2743 : 		if ( gObj[count].Connected == PLAYER_EMPTY )

  00047	8b c8		 mov	 ecx, eax
  00049	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0004f	80 b9 04 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], 0
  00056	74 e7		 je	 SHORT $LN9@gObjAddSea
$LL5@gObjAddSea:

; 2744 : 		{
; 2745 : 			return count;
; 2746 : 		}
; 2747 : 
; 2748 : 		count++;

  00058	40		 inc	 eax

; 2749 : 
; 2750 : 		if ( count >= OBJMAX )

  00059	3d e8 1c 00 00	 cmp	 eax, 7400		; 00001ce8H
  0005e	7c 05		 jl	 SHORT $LN2@gObjAddSea

; 2751 : 		{
; 2752 : 			count = OBJ_STARTUSERINDEX;

  00060	b8 00 19 00 00	 mov	 eax, 6400		; 00001900H
$LN2@gObjAddSea:

; 2753 : 		}
; 2754 : 		totalcount++;

  00065	46		 inc	 esi

; 2755 : 		if ( totalcount >= OBJMAXUSER )

  00066	81 fe e8 03 00
	00		 cmp	 esi, 1000		; 000003e8H
  0006c	7d ce		 jge	 SHORT $LN14@gObjAddSea

; 2740 : 	
; 2741 : 	while ( true )
; 2742 : 	{
; 2743 : 		if ( gObj[count].Connected == PLAYER_EMPTY )

  0006e	8b d0		 mov	 edx, eax
  00070	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00076	80 ba 04 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+4], 0
  0007d	75 d9		 jne	 SHORT $LL5@gObjAddSea
  0007f	5e		 pop	 esi

; 2761 : }

  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?gObjAddSearch@@YAFIPAD@Z ENDP				; gObjAddSearch
_TEXT	ENDS
PUBLIC	?gObjUserKill@@YAXH@Z				; gObjUserKill
; Function compile flags: /Ogtp
;	COMDAT ?gObjUserKill@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjUserKill@@YAXH@Z PROC				; gObjUserKill, COMDAT

; 2902 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2903 : 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0000c	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2904 : 
; 2905 : 	if ( lpObj->CloseCount < 1 )

  00011	80 78 07 01	 cmp	 BYTE PTR [eax+7], 1
  00015	7d 06		 jge	 SHORT $LN1@gObjUserKi

; 2906 : 	{
; 2907 : 		lpObj->CloseCount = 6;

  00017	66 c7 40 07 06
	00		 mov	 WORD PTR [eax+7], 6
$LN1@gObjUserKi:

; 2908 : 		lpObj->CloseType = 0;
; 2909 : 	}
; 2910 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?gObjUserKill@@YAXH@Z ENDP				; gObjUserKill
_TEXT	ENDS
PUBLIC	?gObjAllDisconnect@@YAXXZ			; gObjAllDisconnect
EXTRN	?CloseClient@@YAXH@Z:PROC			; CloseClient
; Function compile flags: /Ogtp
;	COMDAT ?gObjAllDisconnect@@YAXXZ
_TEXT	SEGMENT
?gObjAllDisconnect@@YAXXZ PROC				; gObjAllDisconnect, COMDAT

; 2926 : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 2927 : 	gDisconnect = TRUE;

  00002	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect

; 2928 : 
; 2929 : 	for ( int n=OBJ_STARTUSERINDEX; n< OBJMAX; n++)

  0000c	bf 00 19 00 00	 mov	 edi, 6400		; 00001900H
  00011	be 60 c4 16 02	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046496
$LL5@gObjAllDis:

; 2930 : 	{
; 2931 : 		if ( gObj[n].Connected > PLAYER_EMPTY )

  00016	80 7e a4 00	 cmp	 BYTE PTR [esi-92], 0
  0001a	76 0f		 jbe	 SHORT $LN4@gObjAllDis

; 2932 : 		{
; 2933 : 			if ( gObj[n].Type == OBJ_USER )

  0001c	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  00020	75 09		 jne	 SHORT $LN4@gObjAllDis

; 2934 : 			{
; 2935 : 				CloseClient(n);

  00022	57		 push	 edi
  00023	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00028	83 c4 04	 add	 esp, 4
$LN4@gObjAllDis:

; 2928 : 
; 2929 : 	for ( int n=OBJ_STARTUSERINDEX; n< OBJMAX; n++)

  0002b	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  00031	47		 inc	 edi
  00032	81 fe 00 53 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522496
  00038	7c dc		 jl	 SHORT $LL5@gObjAllDis

; 2936 : 			}
; 2937 : 		}
; 2938 : 	}
; 2939 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	c3		 ret	 0
?gObjAllDisconnect@@YAXXZ ENDP				; gObjAllDisconnect
_TEXT	ENDS
PUBLIC	?gObjIsGamePlaing@@YAHPAUOBJECTSTRUCT@@@Z	; gObjIsGamePlaing
; Function compile flags: /Ogtp
;	COMDAT ?gObjIsGamePlaing@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjIsGamePlaing@@YAHPAUOBJECTSTRUCT@@@Z PROC		; gObjIsGamePlaing, COMDAT

; 3337 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3338 : 	if ( lpObj->Connected < PLAYER_PLAYING )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	80 78 04 03	 cmp	 BYTE PTR [eax+4], 3
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 3339 : 	{
; 3340 : 		return false;
; 3341 : 	}
; 3342 : 
; 3343 : 	return TRUE;
; 3344 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?gObjIsGamePlaing@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; gObjIsGamePlaing
_TEXT	ENDS
PUBLIC	?gObjIsConnectedGP@@YAHH@Z			; gObjIsConnectedGP
; Function compile flags: /Ogtp
;	COMDAT ?gObjIsConnectedGP@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjIsConnectedGP@@YAHH@Z PROC				; gObjIsConnectedGP, COMDAT

; 3347 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3348 : 	if (aIndex < 0 || aIndex > OBJMAX-1 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  0000b	77 28		 ja	 SHORT $LN4@gObjIsConn

; 3351 : 	}
; 3352 : 	
; 3353 : 	if ( gObj[aIndex].Type != OBJ_USER )

  0000d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00013	66 83 b8 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 1

; 3354 : 	{
; 3355 : 		return FALSE;

  0001b	75 18		 jne	 SHORT $LN4@gObjIsConn

; 3356 : 	}
; 3357 : 
; 3358 : 	if ( gObj[aIndex].Connected < PLAYER_PLAYING )

  0001d	80 b8 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 3

; 3359 : 	{
; 3360 : 		return FALSE;

  00024	72 0f		 jb	 SHORT $LN4@gObjIsConn

; 3361 : 	}
; 3362 : 
; 3363 : 	if ( gObj[aIndex].CloseCount > 0 )

  00026	33 c9		 xor	 ecx, ecx
  00028	38 88 07 00 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+7], cl
  0002e	0f 9e c1	 setle	 cl
  00031	8b c1		 mov	 eax, ecx

; 3364 : 	{
; 3365 : 		return FALSE;
; 3366 : 	}
; 3367 : 
; 3368 : 	return TRUE;
; 3369 : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN4@gObjIsConn:

; 3349 : 	{
; 3350 : 		return FALSE;

  00035	33 c0		 xor	 eax, eax

; 3364 : 	{
; 3365 : 		return FALSE;
; 3366 : 	}
; 3367 : 
; 3368 : 	return TRUE;
; 3369 : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?gObjIsConnectedGP@@YAHH@Z ENDP				; gObjIsConnectedGP
_TEXT	ENDS
PUBLIC	?gObjIsConnectedGP@@YAHHPAD@Z			; gObjIsConnectedGP
; Function compile flags: /Ogtp
;	COMDAT ?gObjIsConnectedGP@@YAHHPAD@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_CharName$ = 12						; size = 4
?gObjIsConnectedGP@@YAHHPAD@Z PROC			; gObjIsConnectedGP, COMDAT

; 3372 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3373 : 	if (aIndex < 0 || aIndex > OBJMAX-1 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  0000b	77 64		 ja	 SHORT $LN5@gObjIsConn@2

; 3376 : 	}
; 3377 : 	
; 3378 : 	if ( gObj[aIndex].Type != OBJ_USER )

  0000d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00013	66 83 b8 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 1

; 3379 : 	{
; 3380 : 		return FALSE;

  0001b	75 54		 jne	 SHORT $LN5@gObjIsConn@2

; 3381 : 	}
; 3382 : 
; 3383 : 	if ( gObj[aIndex].Connected < PLAYER_PLAYING )

  0001d	80 b8 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 3

; 3384 : 	{
; 3385 : 		return FALSE;

  00024	72 4b		 jb	 SHORT $LN5@gObjIsConn@2

; 3386 : 	}
; 3387 : 
; 3388 : 	if ( gObj[aIndex].CloseCount > 0 )

  00026	80 b8 07 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+7], 0

; 3389 : 	{
; 3390 : 		return FALSE;

  0002d	7f 42		 jg	 SHORT $LN5@gObjIsConn@2

; 3391 : 	}
; 3392 : 
; 3393 : 	if ( strcmp(gObj[aIndex].Name, CharName) != 0 )

  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _CharName$[ebp]
  00032	8d 80 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
$LL9@gObjIsConn@2:
  00038	8a 10		 mov	 dl, BYTE PTR [eax]
  0003a	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0003c	75 23		 jne	 SHORT $LN10@gObjIsConn@2
  0003e	84 d2		 test	 dl, dl
  00040	74 12		 je	 SHORT $LN11@gObjIsConn@2
  00042	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00045	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00048	75 17		 jne	 SHORT $LN10@gObjIsConn@2
  0004a	83 c0 02	 add	 eax, 2
  0004d	83 c1 02	 add	 ecx, 2
  00050	84 d2		 test	 dl, dl
  00052	75 e4		 jne	 SHORT $LL9@gObjIsConn@2
$LN11@gObjIsConn@2:
  00054	33 c0		 xor	 eax, eax
  00056	33 c9		 xor	 ecx, ecx
  00058	85 c0		 test	 eax, eax
  0005a	0f 94 c1	 sete	 cl
  0005d	8b c1		 mov	 eax, ecx

; 3394 : 	{
; 3395 : 		return FALSE;
; 3396 : 	}
; 3397 : 
; 3398 : 	return TRUE;
; 3399 : }

  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
$LN10@gObjIsConn@2:

; 3391 : 	}
; 3392 : 
; 3393 : 	if ( strcmp(gObj[aIndex].Name, CharName) != 0 )

  00061	1b c0		 sbb	 eax, eax
  00063	83 d8 ff	 sbb	 eax, -1
  00066	33 c9		 xor	 ecx, ecx
  00068	85 c0		 test	 eax, eax
  0006a	0f 94 c1	 sete	 cl
  0006d	8b c1		 mov	 eax, ecx

; 3394 : 	{
; 3395 : 		return FALSE;
; 3396 : 	}
; 3397 : 
; 3398 : 	return TRUE;
; 3399 : }

  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN5@gObjIsConn@2:

; 3374 : 	{
; 3375 : 		return FALSE;

  00071	33 c0		 xor	 eax, eax

; 3394 : 	{
; 3395 : 		return FALSE;
; 3396 : 	}
; 3397 : 
; 3398 : 	return TRUE;
; 3399 : }

  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?gObjIsConnectedGP@@YAHHPAD@Z ENDP			; gObjIsConnectedGP
_TEXT	ENDS
PUBLIC	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z	; gObjIsConnected
; Function compile flags: /Ogtp
;	COMDAT ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z PROC		; gObjIsConnected, COMDAT

; 3402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3403 : 	if ( lpObj->Type != OBJ_USER )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	66 83 78 60 01	 cmp	 WORD PTR [eax+96], 1
  0000b	74 04		 je	 SHORT $LN3@gObjIsConn@3
$LN6@gObjIsConn@3:

; 3404 : 	{
; 3405 : 		return FALSE;

  0000d	33 c0		 xor	 eax, eax

; 3414 : 	{
; 3415 : 		return FALSE;
; 3416 : 	}
; 3417 : 
; 3418 : 	return TRUE;
; 3419 : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN3@gObjIsConn@3:

; 3406 : 	}
; 3407 : 
; 3408 : 	if ( lpObj->Connected < PLAYER_PLAYING )

  00011	80 78 04 03	 cmp	 BYTE PTR [eax+4], 3

; 3409 : 	{
; 3410 : 		return FALSE;

  00015	72 f6		 jb	 SHORT $LN6@gObjIsConn@3

; 3411 : 	}
; 3412 : 
; 3413 : 	if ( lpObj->CloseCount > 0 )

  00017	33 c9		 xor	 ecx, ecx
  00019	38 48 07	 cmp	 BYTE PTR [eax+7], cl
  0001c	0f 9e c1	 setle	 cl
  0001f	8b c1		 mov	 eax, ecx

; 3414 : 	{
; 3415 : 		return FALSE;
; 3416 : 	}
; 3417 : 
; 3418 : 	return TRUE;
; 3419 : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; gObjIsConnected
_TEXT	ENDS
PUBLIC	?gObjIsConnected@@YAHH@Z			; gObjIsConnected
; Function compile flags: /Ogtp
;	COMDAT ?gObjIsConnected@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjIsConnected@@YAHH@Z PROC				; gObjIsConnected, COMDAT

; 3428 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3429 : 	if ( aIndex < 0 || aIndex > OBJMAX-1)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  0000b	77 12		 ja	 SHORT $LN2@gObjIsConn@4

; 3432 : 	}
; 3433 : 	if ( gObj[aIndex].Connected < PLAYER_PLAYING )

  0000d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00013	80 b8 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 3
  0001a	1b c0		 sbb	 eax, eax
  0001c	40		 inc	 eax

; 3434 : 	{
; 3435 : 		return FALSE;
; 3436 : 	}
; 3437 : 	return TRUE;
; 3438 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN2@gObjIsConn@4:

; 3430 : 	{
; 3431 : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax

; 3434 : 	{
; 3435 : 		return FALSE;
; 3436 : 	}
; 3437 : 	return TRUE;
; 3438 : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?gObjIsConnected@@YAHH@Z ENDP				; gObjIsConnected
_TEXT	ENDS
PUBLIC	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@H@Z	; gObjIsConnected
; Function compile flags: /Ogtp
;	COMDAT ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_dbnumber$ = 12						; size = 4
?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@H@Z PROC		; gObjIsConnected, COMDAT

; 3441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3442 : 	if (lpObj->Connected < PLAYER_PLAYING)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	80 78 04 03	 cmp	 BYTE PTR [eax+4], 3
  0000a	73 04		 jae	 SHORT $LN2@gObjIsConn@5

; 3443 : 	{
; 3444 : 		return 0;

  0000c	33 c0		 xor	 eax, eax

; 3448 : 	{
; 3449 : 		return 0;
; 3450 : 	}
; 3451 : 
; 3452 : 	return 1;
; 3453 : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN2@gObjIsConn@5:

; 3445 : 	}
; 3446 : 
; 3447 : 	if (lpObj->DBNumber != dbnumber)

  00010	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  00013	33 c9		 xor	 ecx, ecx
  00015	3b 55 0c	 cmp	 edx, DWORD PTR _dbnumber$[ebp]
  00018	0f 94 c1	 sete	 cl
  0001b	8b c1		 mov	 eax, ecx

; 3448 : 	{
; 3449 : 		return 0;
; 3450 : 	}
; 3451 : 
; 3452 : 	return 1;
; 3453 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@H@Z ENDP		; gObjIsConnected
_TEXT	ENDS
PUBLIC	?gObjIsAccontConnect@@YAHHPAD@Z			; gObjIsAccontConnect
; Function compile flags: /Ogtp
;	COMDAT ?gObjIsAccontConnect@@YAHHPAD@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_accountid$ = 12					; size = 4
?gObjIsAccontConnect@@YAHHPAD@Z PROC			; gObjIsAccontConnect, COMDAT

; 3456 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3457 : 	if (aIndex <0 || aIndex > OBJMAX-1) // Bad

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  0000b	77 6c		 ja	 SHORT $LN4@gObjIsAcco

; 3460 : 	}
; 3461 : 
; 3462 : 	if (gObj[aIndex].Connected< PLAYER_CONNECTED)

  0000d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00013	80 b8 04 00 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 1

; 3463 : 	{
; 3464 : 		return 0;

  0001a	72 5d		 jb	 SHORT $LN4@gObjIsAcco

; 3465 : 	}
; 3466 : 
; 3467 : 	if (strlen(&gObj[aIndex].AccountID[0]) < 1 )

  0001c	8d 88 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00022	8b c1		 mov	 eax, ecx
  00024	56		 push	 esi
  00025	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL8@gObjIsAcco:
  00028	8a 10		 mov	 dl, BYTE PTR [eax]
  0002a	40		 inc	 eax
  0002b	84 d2		 test	 dl, dl
  0002d	75 f9		 jne	 SHORT $LL8@gObjIsAcco
  0002f	2b c6		 sub	 eax, esi
  00031	5e		 pop	 esi
  00032	83 f8 01	 cmp	 eax, 1

; 3468 : 	{
; 3469 : 		return 0;

  00035	72 42		 jb	 SHORT $LN4@gObjIsAcco

; 3470 : 	}
; 3471 : 
; 3472 : 	if ( strcmp(accountid, &gObj[aIndex].AccountID[0]) != 0)

  00037	8b 45 0c	 mov	 eax, DWORD PTR _accountid$[ebp]
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL9@gObjIsAcco:
  00040	8a 10		 mov	 dl, BYTE PTR [eax]
  00042	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00044	75 23		 jne	 SHORT $LN10@gObjIsAcco
  00046	84 d2		 test	 dl, dl
  00048	74 12		 je	 SHORT $LN11@gObjIsAcco
  0004a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0004d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00050	75 17		 jne	 SHORT $LN10@gObjIsAcco
  00052	83 c0 02	 add	 eax, 2
  00055	83 c1 02	 add	 ecx, 2
  00058	84 d2		 test	 dl, dl
  0005a	75 e4		 jne	 SHORT $LL9@gObjIsAcco
$LN11@gObjIsAcco:
  0005c	33 c0		 xor	 eax, eax
  0005e	33 c9		 xor	 ecx, ecx
  00060	85 c0		 test	 eax, eax
  00062	0f 94 c1	 sete	 cl
  00065	8b c1		 mov	 eax, ecx

; 3473 : 	{
; 3474 : 		return 0;
; 3475 : 	}
; 3476 : 	return 1;
; 3477 : }

  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN10@gObjIsAcco:

; 3470 : 	}
; 3471 : 
; 3472 : 	if ( strcmp(accountid, &gObj[aIndex].AccountID[0]) != 0)

  00069	1b c0		 sbb	 eax, eax
  0006b	83 d8 ff	 sbb	 eax, -1
  0006e	33 c9		 xor	 ecx, ecx
  00070	85 c0		 test	 eax, eax
  00072	0f 94 c1	 sete	 cl
  00075	8b c1		 mov	 eax, ecx

; 3473 : 	{
; 3474 : 		return 0;
; 3475 : 	}
; 3476 : 	return 1;
; 3477 : }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN4@gObjIsAcco:

; 3458 : 	{
; 3459 : 		return 0;

  00079	33 c0		 xor	 eax, eax

; 3473 : 	{
; 3474 : 		return 0;
; 3475 : 	}
; 3476 : 	return 1;
; 3477 : }

  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?gObjIsAccontConnect@@YAHHPAD@Z ENDP			; gObjIsAccontConnect
_TEXT	ENDS
PUBLIC	?gObjJoominCheck@@YAHHPAD@Z			; gObjJoominCheck
EXTRN	_strcmpi:PROC
EXTRN	_strncmp:PROC
EXTRN	?gLanguage@@3HA:DWORD				; gLanguage
; Function compile flags: /Ogtp
;	COMDAT ?gObjJoominCheck@@YAHHPAD@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_szInJN$ = 12						; size = 4
?gObjJoominCheck@@YAHHPAD@Z PROC			; gObjJoominCheck, COMDAT

; 3480 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3481 : 	LPOBJ lpObj = &gObj[aIndex];
; 3482 : 	
; 3483 : 	switch ( gLanguage )

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gLanguage@@3HA ; gLanguage
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000c	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00012	48		 dec	 eax
  00013	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	57		 push	 edi
  0001a	83 f8 07	 cmp	 eax, 7
  0001d	0f 87 a6 00 00
	00		 ja	 $LN2@gObjJoomin
  00023	8b 7d 0c	 mov	 edi, DWORD PTR _szInJN$[ebp]
  00026	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN24@gObjJoomin[eax*4]
$LN16@gObjJoomin:

; 3484 : 	{
; 3485 : 		case 1:
; 3486 : 		case 5:
; 3487 : 		case 6:
; 3488 : 		case 8:
; 3489 : 			if ( strncmp(szInJN, lpObj->LastJoominNumber, 7) == 0 )

  0002d	6a 07		 push	 7
  0002f	8d 46 7a	 lea	 eax, DWORD PTR [esi+122]
  00032	50		 push	 eax
  00033	57		 push	 edi
  00034	e8 00 00 00 00	 call	 _strncmp
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	85 c0		 test	 eax, eax

; 3490 : 			{
; 3491 : 				return TRUE;

  0003e	74 24		 je	 SHORT $LN22@gObjJoomin
$LN15@gObjJoomin:

; 3492 : 			}
; 3493 : 		case 2:
; 3494 : 			if ( strncmp(szInJN, &lpObj->LastJoominNumber[5], 8) == 0 )

  00040	6a 08		 push	 8
  00042	8d 4e 7f	 lea	 ecx, DWORD PTR [esi+127]
  00045	51		 push	 ecx
  00046	57		 push	 edi
  00047	e8 00 00 00 00	 call	 _strncmp
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	85 c0		 test	 eax, eax

; 3495 : 			{
; 3496 : 				return TRUE;

  00051	74 11		 je	 SHORT $LN22@gObjJoomin
$LN13@gObjJoomin:

; 3497 : 			}
; 3498 : 		case 3:
; 3499 : 			if ( strcmpi(szInJN, &lpObj->LastJoominNumber[6]) == 0 )

  00053	83 ee 80	 sub	 esi, -128		; ffffff80H
  00056	56		 push	 esi
  00057	57		 push	 edi
  00058	e8 00 00 00 00	 call	 _strcmpi
  0005d	83 c4 08	 add	 esp, 8
  00060	85 c0		 test	 eax, eax
  00062	75 71		 jne	 SHORT $LN1@gObjJoomin
$LN22@gObjJoomin:
  00064	5f		 pop	 edi

; 3500 : 			{
; 3501 : 				return TRUE;

  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	5e		 pop	 esi

; 3538 : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
$LN10@gObjJoomin:

; 3502 : 			}
; 3503 : 			break;
; 3504 : 		case 4:
; 3505 : 			if ( strlen(szInJN) < 2 )

  0006d	8b c7		 mov	 eax, edi
  0006f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL21@gObjJoomin:
  00072	8a 08		 mov	 cl, BYTE PTR [eax]
  00074	40		 inc	 eax
  00075	84 c9		 test	 cl, cl
  00077	75 f9		 jne	 SHORT $LL21@gObjJoomin
  00079	2b c2		 sub	 eax, edx
  0007b	83 f8 02	 cmp	 eax, 2

; 3506 : 			{
; 3507 : 				return FALSE;

  0007e	72 55		 jb	 SHORT $LN1@gObjJoomin

; 3508 : 			}
; 3509 : 
; 3510 : 			if ( (szInJN[0] >= 'A' && szInJN[0] <= 'Z') || (szInJN[0] >= 'a' && szInJN[0] <= 'z') )

  00080	8a 07		 mov	 al, BYTE PTR [edi]
  00082	3c 41		 cmp	 al, 65			; 00000041H
  00084	7c 04		 jl	 SHORT $LN6@gObjJoomin
  00086	3c 5a		 cmp	 al, 90			; 0000005aH
  00088	7e 08		 jle	 SHORT $LN7@gObjJoomin
$LN6@gObjJoomin:
  0008a	3c 61		 cmp	 al, 97			; 00000061H
  0008c	7c 47		 jl	 SHORT $LN1@gObjJoomin
  0008e	3c 7a		 cmp	 al, 122			; 0000007aH
  00090	7f 43		 jg	 SHORT $LN1@gObjJoomin
$LN7@gObjJoomin:

; 3511 : 			{
; 3512 : 				if ( szInJN[0] >= 'A' && szInJN[0] <= 'Z' )

  00092	3c 41		 cmp	 al, 65			; 00000041H
  00094	7c 08		 jl	 SHORT $LN5@gObjJoomin
  00096	3c 5a		 cmp	 al, 90			; 0000005aH
  00098	7f 04		 jg	 SHORT $LN5@gObjJoomin

; 3513 : 				{
; 3514 : 					szInJN[0] = szInJN[0] + 32;

  0009a	04 20		 add	 al, 32			; 00000020H
  0009c	88 07		 mov	 BYTE PTR [edi], al
$LN5@gObjJoomin:

; 3515 : 				}
; 3516 : 
; 3517 : 				if ( lpObj->LastJoominNumber[0] >= 'A' && lpObj->LastJoominNumber[0] <= 'Z' )

  0009e	8a 46 7a	 mov	 al, BYTE PTR [esi+122]
  000a1	8d 4e 7a	 lea	 ecx, DWORD PTR [esi+122]
  000a4	3c 41		 cmp	 al, 65			; 00000041H
  000a6	7c 08		 jl	 SHORT $LN4@gObjJoomin
  000a8	3c 5a		 cmp	 al, 90			; 0000005aH
  000aa	7f 04		 jg	 SHORT $LN4@gObjJoomin

; 3518 : 				{
; 3519 : 					lpObj->LastJoominNumber[0] = lpObj->LastJoominNumber[0] + 32;

  000ac	04 20		 add	 al, 32			; 00000020H
  000ae	88 01		 mov	 BYTE PTR [ecx], al
$LN4@gObjJoomin:

; 3520 : 				}
; 3521 : 
; 3522 : 				if ( strncmp(lpObj->LastJoominNumber, szInJN, 10) == 0 )

  000b0	6a 0a		 push	 10			; 0000000aH
  000b2	57		 push	 edi
  000b3	51		 push	 ecx
$LN23@gObjJoomin:
  000b4	e8 00 00 00 00	 call	 _strncmp
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bc	85 c0		 test	 eax, eax
  000be	75 15		 jne	 SHORT $LN1@gObjJoomin

; 3523 : 				{
; 3524 : 					return TRUE;

  000c0	5f		 pop	 edi
  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	5e		 pop	 esi

; 3538 : }

  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
$LN2@gObjJoomin:

; 3525 : 				}
; 3526 : 			}
; 3527 : 			break;
; 3528 : 
; 3529 : 		default:
; 3530 : 
; 3531 : 			if ( strncmp(szInJN, &lpObj->LastJoominNumber[6], 7) == 0 )

  000c9	8b 55 0c	 mov	 edx, DWORD PTR _szInJN$[ebp]
  000cc	6a 07		 push	 7
  000ce	83 ee 80	 sub	 esi, -128		; ffffff80H
  000d1	56		 push	 esi
  000d2	52		 push	 edx

; 3532 : 			{
; 3533 : 				return TRUE;

  000d3	eb df		 jmp	 SHORT $LN23@gObjJoomin
$LN1@gObjJoomin:
  000d5	5f		 pop	 edi

; 3534 : 			}
; 3535 : 	}
; 3536 : 
; 3537 : 	return FALSE;

  000d6	33 c0		 xor	 eax, eax
  000d8	5e		 pop	 esi

; 3538 : }

  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
  000db	90		 npad	 1
$LN24@gObjJoomin:
  000dc	00 00 00 00	 DD	 $LN16@gObjJoomin
  000e0	00 00 00 00	 DD	 $LN15@gObjJoomin
  000e4	00 00 00 00	 DD	 $LN13@gObjJoomin
  000e8	00 00 00 00	 DD	 $LN10@gObjJoomin
  000ec	00 00 00 00	 DD	 $LN16@gObjJoomin
  000f0	00 00 00 00	 DD	 $LN16@gObjJoomin
  000f4	00 00 00 00	 DD	 $LN2@gObjJoomin
  000f8	00 00 00 00	 DD	 $LN16@gObjJoomin
?gObjJoominCheck@@YAHHPAD@Z ENDP			; gObjJoominCheck
_TEXT	ENDS
PUBLIC	?gObjTaiwanJoominCheck@@YAHHPAD@Z		; gObjTaiwanJoominCheck
; Function compile flags: /Ogtp
;	COMDAT ?gObjTaiwanJoominCheck@@YAHHPAD@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_szInJN$ = 12						; size = 4
?gObjTaiwanJoominCheck@@YAHHPAD@Z PROC			; gObjTaiwanJoominCheck, COMDAT

; 3541 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3543 : 
; 3544 : 	if ( strlen(szInJN) < 2 )

  00004	8b 75 0c	 mov	 esi, DWORD PTR _szInJN$[ebp]
  00007	8b c6		 mov	 eax, esi
  00009	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000c	8d 64 24 00	 npad	 4
$LL5@gObjTaiwan:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL5@gObjTaiwan
  00017	2b c2		 sub	 eax, edx
  00019	83 f8 02	 cmp	 eax, 2
  0001c	73 05		 jae	 SHORT $LN2@gObjTaiwan

; 3545 : 	{
; 3546 : 		return FALSE;

  0001e	33 c0		 xor	 eax, eax
  00020	5e		 pop	 esi

; 3550 : 	{
; 3551 : 		return TRUE;
; 3552 : 	}
; 3553 : 
; 3554 : 	return FALSE;
; 3555 : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
$LN2@gObjTaiwan:

; 3542 : 	LPOBJ lpObj = &gObj[aIndex];

  00023	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00026	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 3547 : 	}
; 3548 : 	
; 3549 : 	if ( strncmp(&lpObj->LastJoominNumber[1], szInJN, 9) == 0 )

  0002c	6a 09		 push	 9
  0002e	05 7b 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+123
  00033	56		 push	 esi
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _strncmp
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	f7 d8		 neg	 eax
  0003f	1b c0		 sbb	 eax, eax
  00041	40		 inc	 eax
  00042	5e		 pop	 esi

; 3550 : 	{
; 3551 : 		return TRUE;
; 3552 : 	}
; 3553 : 
; 3554 : 	return FALSE;
; 3555 : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?gObjTaiwanJoominCheck@@YAHHPAD@Z ENDP			; gObjTaiwanJoominCheck
_TEXT	ENDS
PUBLIC	?gObjSetAccountLogin@@YAHHPADHH0@Z		; gObjSetAccountLogin
EXTRN	?SendGame@CReconnect@@QAEXH@Z:PROC		; CReconnect::SendGame
EXTRN	?gReconnect@@3VCReconnect@@A:BYTE		; gReconnect
; Function compile flags: /Ogtp
;	COMDAT ?gObjSetAccountLogin@@YAHHPADHH0@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_szId$ = 12						; size = 4
_aUserNumber$ = 16					; size = 4
_aDBNumber$ = 20					; size = 4
_JoominNumber$ = 24					; size = 4
?gObjSetAccountLogin@@YAHHPADHH0@Z PROC			; gObjSetAccountLogin, COMDAT

; 3646 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 3647 : 	if ( !OBJMAX_RANGE(aIndex) )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	78 0f		 js	 SHORT $LN11@gObjSetAcc
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 1e		 jne	 SHORT $LN4@gObjSetAcc
$LN11@gObjSetAcc:

; 3648 : 	{
; 3649 : 		LogAdd(LOG_BLACK, "error : %s %d", __FILE__, __LINE__);

  0001a	68 41 0e 00 00	 push	 3649			; 00000e41H
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00029	6a 00		 push	 0
  0002b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00030	83 c4 10	 add	 esp, 16			; 00000010H

; 3650 : 		return 0;

  00033	33 c0		 xor	 eax, eax
  00035	5b		 pop	 ebx

; 3676 : 
; 3677 : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN4@gObjSetAcc:
  00038	56		 push	 esi

; 3651 : 	}
; 3652 : 
; 3653 : 	if ( gObj[aIndex].Connected != PLAYER_CONNECTED )

  00039	8b f3		 mov	 esi, ebx
  0003b	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00041	80 be 04 00 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+4], 1
  00048	74 33		 je	 SHORT $LN3@gObjSetAcc

; 3654 : 	{
; 3655 : 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2, 6)), aIndex, szId, aDBNumber, __FILE__, __LINE__);

  0004a	8b 45 14	 mov	 eax, DWORD PTR _aDBNumber$[ebp]
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _szId$[ebp]
  00050	68 47 0e 00 00	 push	 3655			; 00000e47H
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0005a	50		 push	 eax
  0005b	51		 push	 ecx
  0005c	53		 push	 ebx
  0005d	68 06 02 00 00	 push	 518			; 00000206H
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00067	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0006c	50		 push	 eax
  0006d	6a 00		 push	 0
  0006f	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00074	83 c4 1c	 add	 esp, 28			; 0000001cH
  00077	5e		 pop	 esi

; 3656 : 		return 0;

  00078	33 c0		 xor	 eax, eax
  0007a	5b		 pop	 ebx

; 3676 : 
; 3677 : }

  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$LN3@gObjSetAcc:
  0007d	57		 push	 edi

; 3657 : 	}
; 3658 : 
; 3659 : 	if ( strcmp(gObj[aIndex].AccountID, szId) != 0 )

  0007e	8b 7d 0c	 mov	 edi, DWORD PTR _szId$[ebp]
  00081	8b cf		 mov	 ecx, edi
  00083	8d 86 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  00089	8d a4 24 00 00
	00 00		 npad	 7
$LL12@gObjSetAcc:
  00090	8a 10		 mov	 dl, BYTE PTR [eax]
  00092	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00094	75 1a		 jne	 SHORT $LN13@gObjSetAcc
  00096	84 d2		 test	 dl, dl
  00098	74 12		 je	 SHORT $LN14@gObjSetAcc
  0009a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0009d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000a0	75 0e		 jne	 SHORT $LN13@gObjSetAcc
  000a2	83 c0 02	 add	 eax, 2
  000a5	83 c1 02	 add	 ecx, 2
  000a8	84 d2		 test	 dl, dl
  000aa	75 e4		 jne	 SHORT $LL12@gObjSetAcc
$LN14@gObjSetAcc:
  000ac	33 c0		 xor	 eax, eax
  000ae	eb 05		 jmp	 SHORT $LN15@gObjSetAcc
$LN13@gObjSetAcc:
  000b0	1b c0		 sbb	 eax, eax
  000b2	83 d8 ff	 sbb	 eax, -1
$LN15@gObjSetAcc:
  000b5	85 c0		 test	 eax, eax
  000b7	74 22		 je	 SHORT $LN2@gObjSetAcc

; 3660 : 	{
; 3661 : 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2, 7)), szId);

  000b9	57		 push	 edi
  000ba	68 07 02 00 00	 push	 519			; 00000207H
  000bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000c4	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000c9	50		 push	 eax
  000ca	6a 00		 push	 0
  000cc	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi

; 3662 : 		return 0;

  000d6	33 c0		 xor	 eax, eax
  000d8	5b		 pop	 ebx

; 3676 : 
; 3677 : }

  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
$LN2@gObjSetAcc:

; 3663 : 	}
; 3664 : 
; 3665 : 	gObj[aIndex].UserNumber = aUserNumber;

  000db	8b 55 10	 mov	 edx, DWORD PTR _aUserNumber$[ebp]

; 3666 : 	gObj[aIndex].DBNumber = aDBNumber;

  000de	8b 45 14	 mov	 eax, DWORD PTR _aDBNumber$[ebp]
  000e1	89 96 24 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+36], edx
  000e7	89 86 28 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+40], eax

; 3667 : 	gObj[aIndex].Connected = PLAYER_LOGGED;
; 3668 : 	strcpy(gObj[aIndex].LastJoominNumber, JoominNumber);

  000ed	8b 45 18	 mov	 eax, DWORD PTR _JoominNumber$[ebp]
  000f0	8d 96 7a 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+122]
  000f6	c6 86 04 00 00
	00 02		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+4], 2
  000fd	2b d0		 sub	 edx, eax
  000ff	90		 npad	 1
$LL9@gObjSetAcc:
  00100	8a 08		 mov	 cl, BYTE PTR [eax]
  00102	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00105	40		 inc	 eax
  00106	84 c9		 test	 cl, cl
  00108	75 f6		 jne	 SHORT $LL9@gObjSetAcc

; 3669 : 	// ---
; 3670 : 	if(gObj[aIndex].bReconnect)

  0010a	38 8e 5c 15 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+5468], cl
  00110	74 0b		 je	 SHORT $LN1@gObjSetAcc

; 3671 : 	{
; 3672 : 		gReconnect.SendGame(aIndex);

  00112	53		 push	 ebx
  00113	b9 00 00 00 00	 mov	 ecx, OFFSET ?gReconnect@@3VCReconnect@@A ; gReconnect
  00118	e8 00 00 00 00	 call	 ?SendGame@CReconnect@@QAEXH@Z ; CReconnect::SendGame
$LN1@gObjSetAcc:

; 3673 : 	}
; 3674 : 	// ---
; 3675 : 	return TRUE;

  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	b8 01 00 00 00	 mov	 eax, 1
  00124	5b		 pop	 ebx

; 3676 : 
; 3677 : }

  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
?gObjSetAccountLogin@@YAHHPADHH0@Z ENDP			; gObjSetAccountLogin
_TEXT	ENDS
PUBLIC	?gObjGetUserNumber@@YAHH@Z			; gObjGetUserNumber
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetUserNumber@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjGetUserNumber@@YAHH@Z PROC				; gObjGetUserNumber, COMDAT

; 3680 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3681 : 	int usernumber;
; 3682 : 
; 3683 : 	if ( !OBJMAX_RANGE(aIndex))

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN6@gObjGetUse
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 1d		 jne	 SHORT $LN1@gObjGetUse
$LN6@gObjGetUse:

; 3684 : 	{
; 3685 : 		LogAdd(LOG_BLACK, "error : %s %d",__FILE__, __LINE__);

  00018	68 65 0e 00 00	 push	 3685			; 00000e65H
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00027	6a 00		 push	 0
  00029	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0002e	83 c4 10	 add	 esp, 16			; 00000010H

; 3686 : 		return 0;

  00031	33 c0		 xor	 eax, eax

; 3691 : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN1@gObjGetUse:

; 3687 : 	}
; 3688 : 
; 3689 : 	usernumber=gObj[aIndex].UserNumber;

  00035	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 3690 : 	return usernumber;

  0003b	8b 80 24 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+36]

; 3691 : }

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?gObjGetUserNumber@@YAHH@Z ENDP				; gObjGetUserNumber
_TEXT	ENDS
PUBLIC	?gObjGetNumber@@YAHHAAH0@Z			; gObjGetNumber
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetNumber@@YAHHAAH0@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_UN$ = 12						; size = 4
_DBN$ = 16						; size = 4
?gObjGetNumber@@YAHHAAH0@Z PROC				; gObjGetNumber, COMDAT

; 3694 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3695 : 	if ( aIndex < 0 || aIndex > OBJMAX-1)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  0000b	77 23		 ja	 SHORT $LN1@gObjGetNum

; 3699 : 	}
; 3700 : 	UN=gObj[aIndex].UserNumber;

  0000d	8b 55 0c	 mov	 edx, DWORD PTR _UN$[ebp]
  00010	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00016	8b 88 24 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+36]
  0001c	89 0a		 mov	 DWORD PTR [edx], ecx

; 3701 : 	DBN=gObj[aIndex].DBNumber;

  0001e	8b 80 28 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+40]
  00024	8b 4d 10	 mov	 ecx, DWORD PTR _DBN$[ebp]
  00027	89 01		 mov	 DWORD PTR [ecx], eax

; 3702 : 	return 1;

  00029	b8 01 00 00 00	 mov	 eax, 1

; 3703 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN1@gObjGetNum:

; 3696 : 	{
; 3697 : 		LogAdd(LOG_BLACK, "error : %s %d",__FILE__, __LINE__);

  00030	68 71 0e 00 00	 push	 3697			; 00000e71H
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  0003f	6a 00		 push	 0
  00041	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00046	83 c4 10	 add	 esp, 16			; 00000010H

; 3698 : 		return 0;

  00049	33 c0		 xor	 eax, eax

; 3703 : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?gObjGetNumber@@YAHHAAH0@Z ENDP				; gObjGetNumber
_TEXT	ENDS
PUBLIC	?gObjGetAccountId@@YAPADH@Z			; gObjGetAccountId
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetAccountId@@YAPADH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjGetAccountId@@YAPADH@Z PROC			; gObjGetAccountId, COMDAT

; 3707 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3708 : 	if ( aIndex < 0 || aIndex > OBJMAX-1)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  0000b	77 17		 ja	 SHORT $LN2@gObjGetAcc

; 3712 : 	}
; 3713 : 
; 3714 : 	if ( gObj[aIndex].Connected == 2)

  0000d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00013	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  0001a	75 21		 jne	 SHORT $LN1@gObjGetAcc

; 3715 : 	{
; 3716 : 		return &gObj[aIndex].AccountID[0];

  0001c	8d 80 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]

; 3717 : 	}
; 3718 : 	return 0;
; 3719 : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
$LN2@gObjGetAcc:

; 3709 : 	{
; 3710 : 		LogAdd(LOG_BLACK, "error : %s %d",__FILE__, __LINE__);

  00024	68 7e 0e 00 00	 push	 3710			; 00000e7eH
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00033	6a 00		 push	 0
  00035	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0003a	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@gObjGetAcc:

; 3711 : 		return 0;

  0003d	33 c0		 xor	 eax, eax

; 3717 : 	}
; 3718 : 	return 0;
; 3719 : }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?gObjGetAccountId@@YAPADH@Z ENDP			; gObjGetAccountId
_TEXT	ENDS
PUBLIC	?gObjGetIndex@@YAHPAD@Z				; gObjGetIndex
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetIndex@@YAHPAD@Z
_TEXT	SEGMENT
_szId$ = 8						; size = 4
?gObjGetIndex@@YAHPAD@Z PROC				; gObjGetIndex, COMDAT

; 3722 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 3723 : 	int n;
; 3724 : 
; 3725 : 	for (n=OBJ_STARTUSERINDEX;n<OBJMAX; n++)

  00006	8b 7d 08	 mov	 edi, DWORD PTR _szId$[ebp]
  00009	b8 00 19 00 00	 mov	 eax, 6400		; 00001900H
  0000e	be 6f c4 16 02	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046511
$LL6@gObjGetInd:

; 3726 : 	{
; 3727 : 		if ( gObj[n].Connected >= PLAYER_PLAYING)

  00013	80 7e 95 03	 cmp	 BYTE PTR [esi-107], 3
  00017	72 33		 jb	 SHORT $LN5@gObjGetInd

; 3728 : 		{
; 3729 : 			if ( gObj[n].Name[0] == *szId )

  00019	8a 0e		 mov	 cl, BYTE PTR [esi]
  0001b	3a 0f		 cmp	 cl, BYTE PTR [edi]
  0001d	75 2d		 jne	 SHORT $LN5@gObjGetInd

; 3730 : 			{
; 3731 : 				if ( strcmp(&gObj[n].Name[0] , szId) == 0)

  0001f	8b d7		 mov	 edx, edi
  00021	8b ce		 mov	 ecx, esi
$LL12@gObjGetInd:
  00023	8a 19		 mov	 bl, BYTE PTR [ecx]
  00025	3a 1a		 cmp	 bl, BYTE PTR [edx]
  00027	75 1a		 jne	 SHORT $LN13@gObjGetInd
  00029	84 db		 test	 bl, bl
  0002b	74 12		 je	 SHORT $LN14@gObjGetInd
  0002d	8a 59 01	 mov	 bl, BYTE PTR [ecx+1]
  00030	3a 5a 01	 cmp	 bl, BYTE PTR [edx+1]
  00033	75 0e		 jne	 SHORT $LN13@gObjGetInd
  00035	83 c1 02	 add	 ecx, 2
  00038	83 c2 02	 add	 edx, 2
  0003b	84 db		 test	 bl, bl
  0003d	75 e4		 jne	 SHORT $LL12@gObjGetInd
$LN14@gObjGetInd:
  0003f	33 c9		 xor	 ecx, ecx
  00041	eb 05		 jmp	 SHORT $LN15@gObjGetInd
$LN13@gObjGetInd:
  00043	1b c9		 sbb	 ecx, ecx
  00045	83 d9 ff	 sbb	 ecx, -1
$LN15@gObjGetInd:
  00048	85 c9		 test	 ecx, ecx
  0004a	74 12		 je	 SHORT $LN7@gObjGetInd
$LN5@gObjGetInd:

; 3723 : 	int n;
; 3724 : 
; 3725 : 	for (n=OBJ_STARTUSERINDEX;n<OBJMAX; n++)

  0004c	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  00052	40		 inc	 eax
  00053	81 fe 0f 53 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522511
  00059	7c b8		 jl	 SHORT $LL6@gObjGetInd

; 3732 : 				{
; 3733 : 					return n;
; 3734 : 				}
; 3735 : 			}
; 3736 : 		}
; 3737 : 	}
; 3738 : 	return -1;

  0005b	83 c8 ff	 or	 eax, -1
$LN7@gObjGetInd:
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 3739 : }

  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?gObjGetIndex@@YAHPAD@Z ENDP				; gObjGetIndex
_TEXT	ENDS
PUBLIC	??_C@_0BN@NCIMKKEA@error?5?3?5index?5error?5?$CB?$CB?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	?gObjUserIdConnectCheck@@YAHPADH@Z		; gObjUserIdConnectCheck
;	COMDAT ??_C@_0BN@NCIMKKEA@error?5?3?5index?5error?5?$CB?$CB?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BN@NCIMKKEA@error?5?3?5index?5error?5?$CB?$CB?5?$CFs?5?$CFd?$AA@ DB 'e'
	DB	'rror : index error !! %s %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjUserIdConnectCheck@@YAHPADH@Z
_TEXT	SEGMENT
_szId$ = 8						; size = 4
_index$ = 12						; size = 4
?gObjUserIdConnectCheck@@YAHPADH@Z PROC			; gObjUserIdConnectCheck, COMDAT

; 3742 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3743 : 	if ( index < 0 || index > OBJMAX)	// Deathway Fix Here

  00003	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  00006	3d e8 1c 00 00	 cmp	 eax, 7400		; 00001ce8H
  0000b	77 5c		 ja	 SHORT $LN4@gObjUserId

; 3747 : 	}
; 3748 : 
; 3749 : 	if ( gObj[index].Connected < PLAYER_PLAYING)

  0000d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00013	80 b8 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 3

; 3750 : 	{
; 3751 : 		return 0;

  0001a	72 66		 jb	 SHORT $LN12@gObjUserId

; 3752 : 	}
; 3753 : 
; 3754 : 	if (gObj[index].Name[0] != *szId)

  0001c	8a 90 6f 00 00
	00		 mov	 dl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _szId$[ebp]
  00025	8d 80 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  0002b	3a 11		 cmp	 dl, BYTE PTR [ecx]

; 3755 : 	{
; 3756 : 		return 0;

  0002d	75 53		 jne	 SHORT $LN12@gObjUserId
  0002f	90		 npad	 1
$LL2@gObjUserId:

; 3757 : 	}
; 3758 : 
; 3759 : 	if ( strcmp(gObj[index].Name , szId) == 0)

  00030	8a 10		 mov	 dl, BYTE PTR [eax]
  00032	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00034	75 23		 jne	 SHORT $LN9@gObjUserId
  00036	84 d2		 test	 dl, dl
  00038	74 12		 je	 SHORT $LN10@gObjUserId
  0003a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0003d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00040	75 17		 jne	 SHORT $LN9@gObjUserId
  00042	83 c0 02	 add	 eax, 2
  00045	83 c1 02	 add	 ecx, 2
  00048	84 d2		 test	 dl, dl
  0004a	75 e4		 jne	 SHORT $LL2@gObjUserId
$LN10@gObjUserId:
  0004c	33 c0		 xor	 eax, eax
  0004e	33 c9		 xor	 ecx, ecx
  00050	85 c0		 test	 eax, eax
  00052	0f 94 c1	 sete	 cl
  00055	8b c1		 mov	 eax, ecx

; 3760 : 	{
; 3761 : 		return 1;
; 3762 : 	}
; 3763 : 	return 0;
; 3764 : }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN9@gObjUserId:

; 3757 : 	}
; 3758 : 
; 3759 : 	if ( strcmp(gObj[index].Name , szId) == 0)

  00059	1b c0		 sbb	 eax, eax
  0005b	83 d8 ff	 sbb	 eax, -1
  0005e	33 c9		 xor	 ecx, ecx
  00060	85 c0		 test	 eax, eax
  00062	0f 94 c1	 sete	 cl
  00065	8b c1		 mov	 eax, ecx

; 3760 : 	{
; 3761 : 		return 1;
; 3762 : 	}
; 3763 : 	return 0;
; 3764 : }

  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN4@gObjUserId:

; 3744 : 	{
; 3745 : 		LogAdd(LOG_BLACK, "error : index error !! %s %d",__FILE__, __LINE__);

  00069	68 a1 0e 00 00	 push	 3745			; 00000ea1H
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NCIMKKEA@error?5?3?5index?5error?5?$CB?$CB?5?$CFs?5?$CFd?$AA@
  00078	6a 00		 push	 0
  0007a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0007f	83 c4 10	 add	 esp, 16			; 00000010H
$LN12@gObjUserId:

; 3746 : 		return 0;

  00082	33 c0		 xor	 eax, eax

; 3760 : 	{
; 3761 : 		return 1;
; 3762 : 	}
; 3763 : 	return 0;
; 3764 : }

  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?gObjUserIdConnectCheck@@YAHPADH@Z ENDP			; gObjUserIdConnectCheck
_TEXT	ENDS
PUBLIC	?GetPathPacketDirPos@@YAEHH@Z			; GetPathPacketDirPos
; Function compile flags: /Ogtp
;	COMDAT ?GetPathPacketDirPos@@YAEHH@Z
_TEXT	SEGMENT
_px$ = 8						; size = 4
_py$ = 12						; size = 4
?GetPathPacketDirPos@@YAEHH@Z PROC			; GetPathPacketDirPos, COMDAT

; 3767 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3768 : 	BYTE pos = 0;
; 3769 : 
; 3770 : 	if (px <= -1 && py <= -1)

  00003	8b 55 08	 mov	 edx, DWORD PTR _px$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _py$[ebp]
  00009	32 c0		 xor	 al, al
  0000b	83 fa ff	 cmp	 edx, -1
  0000e	7f 18		 jg	 SHORT $LN11@GetPathPac
  00010	83 f9 ff	 cmp	 ecx, -1
  00013	7f 02		 jg	 SHORT $LN15@GetPathPac

; 3801 : 	}
; 3802 : 
; 3803 : 	return pos;
; 3804 : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
$LN15@GetPathPac:

; 3771 : 	{
; 3772 : 		pos=0;
; 3773 : 	}
; 3774 : 	else if (px <= -1 && py == 0)

  00017	85 c9		 test	 ecx, ecx
  00019	75 04		 jne	 SHORT $LN13@GetPathPac

; 3775 : 	{
; 3776 : 		pos=7;

  0001b	b0 07		 mov	 al, 7

; 3801 : 	}
; 3802 : 
; 3803 : 	return pos;
; 3804 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN13@GetPathPac:

; 3777 : 	}
; 3778 : 	else if ( px <= -1 && py >= 1)

  0001f	83 f9 01	 cmp	 ecx, 1
  00022	7c 04		 jl	 SHORT $LN11@GetPathPac

; 3779 : 	{
; 3780 : 		pos=6;

  00024	b0 06		 mov	 al, 6

; 3801 : 	}
; 3802 : 
; 3803 : 	return pos;
; 3804 : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
$LN11@GetPathPac:

; 3781 : 	}
; 3782 : 	else if ( px == 0 && py <= -1)

  00028	85 d2		 test	 edx, edx
  0002a	75 12		 jne	 SHORT $LN7@GetPathPac
  0002c	83 f9 ff	 cmp	 ecx, -1
  0002f	7f 04		 jg	 SHORT $LN18@GetPathPac

; 3783 : 	{
; 3784 : 		pos= 1;

  00031	b0 01		 mov	 al, 1

; 3801 : 	}
; 3802 : 
; 3803 : 	return pos;
; 3804 : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN18@GetPathPac:

; 3785 : 	}
; 3786 : 	else if ( px == 0 && py >= 1)

  00035	83 f9 01	 cmp	 ecx, 1
  00038	7c 21		 jl	 SHORT $LN1@GetPathPac

; 3787 : 	{
; 3788 : 		pos = 5;

  0003a	b0 05		 mov	 al, 5

; 3801 : 	}
; 3802 : 
; 3803 : 	return pos;
; 3804 : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN7@GetPathPac:

; 3789 : 	}
; 3790 : 	else if ( px >= 1 && py <=-1)

  0003e	83 fa 01	 cmp	 edx, 1
  00041	7c 18		 jl	 SHORT $LN1@GetPathPac
  00043	83 f9 ff	 cmp	 ecx, -1
  00046	7f 04		 jg	 SHORT $LN5@GetPathPac

; 3791 : 	{
; 3792 : 		pos=2;

  00048	b0 02		 mov	 al, 2

; 3801 : 	}
; 3802 : 
; 3803 : 	return pos;
; 3804 : }

  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN5@GetPathPac:

; 3793 : 	}
; 3794 : 	else if ( px >= 1 && py == 0)

  0004c	85 c9		 test	 ecx, ecx
  0004e	75 04		 jne	 SHORT $LN3@GetPathPac

; 3795 : 	{
; 3796 : 		pos = 3;

  00050	b0 03		 mov	 al, 3

; 3801 : 	}
; 3802 : 
; 3803 : 	return pos;
; 3804 : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN3@GetPathPac:

; 3797 : 	}
; 3798 : 	else if ( px >=1  && py >= 1)

  00054	83 f9 01	 cmp	 ecx, 1
  00057	7c 02		 jl	 SHORT $LN1@GetPathPac

; 3799 : 	{
; 3800 : 		pos = 4;

  00059	b0 04		 mov	 al, 4
$LN1@GetPathPac:

; 3801 : 	}
; 3802 : 
; 3803 : 	return pos;
; 3804 : }

  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?GetPathPacketDirPos@@YAEHH@Z ENDP			; GetPathPacketDirPos
_TEXT	ENDS
PUBLIC	?gObjPositionCheck@@YAHPAUOBJECTSTRUCT@@@Z	; gObjPositionCheck
; Function compile flags: /Ogtp
;	COMDAT ?gObjPositionCheck@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjPositionCheck@@YAHPAUOBJECTSTRUCT@@@Z PROC		; gObjPositionCheck, COMDAT

; 3820 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3821 : 	int ix = lpObj->m_OldX - lpObj->TX;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	0f bf 90 20 01
	00 00		 movsx	 edx, WORD PTR [eax+288]
  0000d	0f bf 88 1c 01
	00 00		 movsx	 ecx, WORD PTR [eax+284]
  00014	2b ca		 sub	 ecx, edx

; 3822 : 	int iy = lpObj->m_OldY - lpObj->TY;

  00016	0f bf 90 22 01
	00 00		 movsx	 edx, WORD PTR [eax+290]
  0001d	0f bf 80 1e 01
	00 00		 movsx	 eax, WORD PTR [eax+286]

; 3823 : 
; 3824 : 	if ( ix <= -15 ||  ix >= 15 )

  00024	83 c1 0e	 add	 ecx, 14			; 0000000eH
  00027	2b c2		 sub	 eax, edx
  00029	83 f9 1c	 cmp	 ecx, 28			; 0000001cH
  0002c	77 0f		 ja	 SHORT $LN3@gObjPositi

; 3827 : 	}
; 3828 : 
; 3829 : 	if ( iy <= -15 ||  iy >= 15 )

  0002e	83 c0 0e	 add	 eax, 14			; 0000000eH
  00031	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00036	3b c8		 cmp	 ecx, eax
  00038	1b c0		 sbb	 eax, eax
  0003a	40		 inc	 eax

; 3830 : 	{
; 3831 : 		return FALSE;
; 3832 : 	}
; 3833 : 
; 3834 : 	return TRUE;
; 3835 : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN3@gObjPositi:

; 3825 : 	{
; 3826 : 		return FALSE;

  0003d	33 c0		 xor	 eax, eax

; 3830 : 	{
; 3831 : 		return FALSE;
; 3832 : 	}
; 3833 : 
; 3834 : 	return TRUE;
; 3835 : }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?gObjPositionCheck@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; gObjPositionCheck
_TEXT	ENDS
PUBLIC	?gObjCheckTileArea@@YAHHHHH@Z			; gObjCheckTileArea
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckTileArea@@YAHHHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_dis$ = 20						; size = 4
?gObjCheckTileArea@@YAHHHHH@Z PROC			; gObjCheckTileArea, COMDAT

; 3838 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3839 : 	LPOBJ lpObj = & gObj[aIndex];

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 3840 : 
; 3841 : 	if ( x < (lpObj->X - dis) || x > (lpObj->X + dis) || y < (lpObj->Y - dis) || y > (lpObj->Y + dis) )

  00006	8b 4d 14	 mov	 ecx, DWORD PTR _dis$[ebp]
  00009	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0000f	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00014	0f bf 90 04 01
	00 00		 movsx	 edx, WORD PTR [eax+260]
  0001b	56		 push	 esi
  0001c	8b 75 0c	 mov	 esi, DWORD PTR _x$[ebp]
  0001f	57		 push	 edi
  00020	8b fa		 mov	 edi, edx
  00022	2b f9		 sub	 edi, ecx
  00024	3b f7		 cmp	 esi, edi
  00026	7c 27		 jl	 SHORT $LN1@gObjCheckT
  00028	03 d1		 add	 edx, ecx
  0002a	3b f2		 cmp	 esi, edx
  0002c	7f 21		 jg	 SHORT $LN1@gObjCheckT
  0002e	0f bf 80 06 01
	00 00		 movsx	 eax, WORD PTR [eax+262]
  00035	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  00038	8b f0		 mov	 esi, eax
  0003a	2b f1		 sub	 esi, ecx
  0003c	3b d6		 cmp	 edx, esi
  0003e	7c 0f		 jl	 SHORT $LN1@gObjCheckT
  00040	03 c1		 add	 eax, ecx
  00042	3b d0		 cmp	 edx, eax
  00044	7f 09		 jg	 SHORT $LN1@gObjCheckT

; 3844 : 	}
; 3845 : 	return TRUE;

  00046	5f		 pop	 edi
  00047	b8 01 00 00 00	 mov	 eax, 1
  0004c	5e		 pop	 esi

; 3846 : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN1@gObjCheckT:
  0004f	5f		 pop	 edi

; 3842 : 	{
; 3843 : 		return FALSE;

  00050	33 c0		 xor	 eax, eax
  00052	5e		 pop	 esi

; 3846 : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?gObjCheckTileArea@@YAHHHHH@Z ENDP			; gObjCheckTileArea
_TEXT	ENDS
PUBLIC	?ExtentCheck@@YAHHHHH@Z				; ExtentCheck
; Function compile flags: /Ogtp
;	COMDAT ?ExtentCheck@@YAHHHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
?ExtentCheck@@YAHHHHH@Z PROC				; ExtentCheck, COMDAT

; 3849 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3850 : 	if ( (x >=0) && (x<w) && (y >=0) && (y<h) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 18		 js	 SHORT $LN1@ExtentChec
  0000a	3b 45 10	 cmp	 eax, DWORD PTR _w$[ebp]
  0000d	7d 13		 jge	 SHORT $LN1@ExtentChec
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00012	85 c0		 test	 eax, eax
  00014	78 0c		 js	 SHORT $LN1@ExtentChec
  00016	3b 45 14	 cmp	 eax, DWORD PTR _h$[ebp]
  00019	7d 07		 jge	 SHORT $LN1@ExtentChec

; 3851 : 	{
; 3852 : 		return 1;

  0001b	b8 01 00 00 00	 mov	 eax, 1

; 3855 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$LN1@ExtentChec:

; 3853 : 	}
; 3854 : 	return 0;

  00022	33 c0		 xor	 eax, eax

; 3855 : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?ExtentCheck@@YAHHHHH@Z ENDP				; ExtentCheck
_TEXT	ENDS
PUBLIC	?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer
; Function compile flags: /Ogtp
;	COMDAT ?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjSetInventory1Pointer, COMDAT

; 3858 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3859 : 	lpObj->pInventory = lpObj->Inventory1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	8b 88 9c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3228]

; 3860 : 	lpObj->pInventoryMap = lpObj->InventoryMap1;

  0000c	8b 90 a0 0c 00
	00		 mov	 edx, DWORD PTR [eax+3232]
  00012	89 88 8c 0c 00
	00		 mov	 DWORD PTR [eax+3212], ecx

; 3861 : 	lpObj->pInventoryCount  = &lpObj->InventoryCount1;

  00018	8d 88 a4 0c 00
	00		 lea	 ecx, DWORD PTR [eax+3236]
  0001e	89 90 90 0c 00
	00		 mov	 DWORD PTR [eax+3216], edx
  00024	89 88 94 0c 00
	00		 mov	 DWORD PTR [eax+3220], ecx

; 3862 : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjSetInventory1Pointer
_TEXT	ENDS
PUBLIC	?gObjSetInventory2Pointer@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSetInventory2Pointer
; Function compile flags: /Ogtp
;	COMDAT ?gObjSetInventory2Pointer@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjSetInventory2Pointer@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjSetInventory2Pointer, COMDAT

; 3865 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3866 : 	lpObj->pInventory = lpObj->Inventory2;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	8b 88 a8 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3240]

; 3867 : 	lpObj->pInventoryMap = lpObj->InventoryMap2;

  0000c	8b 90 ac 0c 00
	00		 mov	 edx, DWORD PTR [eax+3244]
  00012	89 88 8c 0c 00
	00		 mov	 DWORD PTR [eax+3212], ecx

; 3868 : 	lpObj->pInventoryCount  = &lpObj->InventoryCount2;

  00018	8d 88 b0 0c 00
	00		 lea	 ecx, DWORD PTR [eax+3248]
  0001e	89 90 90 0c 00
	00		 mov	 DWORD PTR [eax+3216], edx
  00024	89 88 94 0c 00
	00		 mov	 DWORD PTR [eax+3220], ecx

; 3869 : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?gObjSetInventory2Pointer@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjSetInventory2Pointer
_TEXT	ENDS
PUBLIC	?gObjAddMsgSend@@YAXPAUOBJECTSTRUCT@@HHH@Z	; gObjAddMsgSend
EXTRN	__imp__GetTickCount@0:PROC
; Function compile flags: /Ogtp
;	COMDAT ?gObjAddMsgSend@@YAXPAUOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
_SubCode$ = 20						; size = 4
?gObjAddMsgSend@@YAXPAUOBJECTSTRUCT@@HHH@Z PROC		; gObjAddMsgSend, COMDAT

; 3872 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 3873 : 	for ( int n=0;n<MAX_MONSTER_SEND_MSG;n++)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00008	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0000a	8d 14 89	 lea	 edx, DWORD PTR [ecx+ecx*4]
  0000d	33 f6		 xor	 esi, esi
  0000f	c1 e2 05	 shl	 edx, 5
  00012	8d 92 00 00 00
	00		 lea	 edx, DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[edx]
  00018	8b c2		 mov	 eax, edx
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL9@gObjAddMsg:

; 3874 : 	{
; 3875 : 		if ( gSMMsg[lpObj->m_Index][n].MsgCode < 0 )

  00020	83 38 00	 cmp	 DWORD PTR [eax], 0
  00023	7c 29		 jl	 SHORT $LN15@gObjAddMsg

; 3873 : 	for ( int n=0;n<MAX_MONSTER_SEND_MSG;n++)

  00025	46		 inc	 esi
  00026	83 c0 10	 add	 eax, 16			; 00000010H
  00029	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  0002c	7c f2		 jl	 SHORT $LL9@gObjAddMsg

; 3876 : 		{
; 3877 : 			gSMMsg[lpObj->m_Index][n].MsgCode = aMsgCode;
; 3878 : 			gSMMsg[lpObj->m_Index][n].MsgTime = GetTickCount();
; 3879 : 			gSMMsg[lpObj->m_Index][n].SendUser = aIndex;
; 3880 : 			gSMMsg[lpObj->m_Index][n].SubCode = SubCode;
; 3881 : 
; 3882 : 			return;
; 3883 : 		}
; 3884 : 	}
; 3885 : 
; 3886 : 	for (int n=0;n<MAX_MONSTER_SEND_MSG;n++)

  0002e	33 f6		 xor	 esi, esi
$LL5@gObjAddMsg:

; 3887 : 	{
; 3888 : 		if ( gSMMsg[lpObj->m_Index][n].MsgCode == 2 || gSMMsg[lpObj->m_Index][n].MsgCode == 6 || gSMMsg[lpObj->m_Index][n].MsgCode == 7 )

  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	83 f8 02	 cmp	 eax, 2
  00035	74 17		 je	 SHORT $LN15@gObjAddMsg
  00037	83 f8 06	 cmp	 eax, 6
  0003a	74 12		 je	 SHORT $LN15@gObjAddMsg
  0003c	83 f8 07	 cmp	 eax, 7
  0003f	74 0d		 je	 SHORT $LN15@gObjAddMsg

; 3876 : 		{
; 3877 : 			gSMMsg[lpObj->m_Index][n].MsgCode = aMsgCode;
; 3878 : 			gSMMsg[lpObj->m_Index][n].MsgTime = GetTickCount();
; 3879 : 			gSMMsg[lpObj->m_Index][n].SendUser = aIndex;
; 3880 : 			gSMMsg[lpObj->m_Index][n].SubCode = SubCode;
; 3881 : 
; 3882 : 			return;
; 3883 : 		}
; 3884 : 	}
; 3885 : 
; 3886 : 	for (int n=0;n<MAX_MONSTER_SEND_MSG;n++)

  00041	46		 inc	 esi
  00042	83 c2 10	 add	 edx, 16			; 00000010H
  00045	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00048	7c e6		 jl	 SHORT $LL5@gObjAddMsg
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 3894 : 			
; 3895 : 			return;
; 3896 : 		}
; 3897 : 	}
; 3898 : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN15@gObjAddMsg:

; 3889 : 		{
; 3890 : 			gSMMsg[lpObj->m_Index][n].MsgCode = aMsgCode;

  0004e	8b 55 0c	 mov	 edx, DWORD PTR _aMsgCode$[ebp]
  00051	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00054	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]
  00057	c1 e1 04	 shl	 ecx, 4
  0005a	89 91 00 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx], edx

; 3891 : 			gSMMsg[lpObj->m_Index][n].MsgTime = GetTickCount();

  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00066	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00068	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  0006b	8d 14 4e	 lea	 edx, DWORD PTR [esi+ecx*2]
  0006e	c1 e2 04	 shl	 edx, 4
  00071	89 82 08 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[edx+8], eax

; 3892 : 			gSMMsg[lpObj->m_Index][n].SendUser = aIndex;

  00077	8b 07		 mov	 eax, DWORD PTR [edi]
  00079	8b 55 10	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0007c	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0007f	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]
  00082	c1 e1 04	 shl	 ecx, 4
  00085	89 91 04 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+4], edx

; 3893 : 			gSMMsg[lpObj->m_Index][n].SubCode = SubCode;

  0008b	8b 07		 mov	 eax, DWORD PTR [edi]
  0008d	8b 55 14	 mov	 edx, DWORD PTR _SubCode$[ebp]
  00090	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00093	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]
  00096	c1 e1 04	 shl	 ecx, 4
  00099	5f		 pop	 edi
  0009a	89 91 0c 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+12], edx
  000a0	5e		 pop	 esi

; 3894 : 			
; 3895 : 			return;
; 3896 : 		}
; 3897 : 	}
; 3898 : }

  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
?gObjAddMsgSend@@YAXPAUOBJECTSTRUCT@@HHH@Z ENDP		; gObjAddMsgSend
_TEXT	ENDS
PUBLIC	?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
; Function compile flags: /Ogtp
;	COMDAT ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
_delay$ = 20						; size = 4
_SubCode$ = 24						; size = 4
?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z PROC	; gObjAddMsgSendDelay, COMDAT

; 3901 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 3902 : 	for ( int n=0;n<MAX_MONSTER_SEND_MSG;n++)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00008	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0000a	8d 14 89	 lea	 edx, DWORD PTR [ecx+ecx*4]
  0000d	33 f6		 xor	 esi, esi
  0000f	c1 e2 05	 shl	 edx, 5
  00012	8d 92 00 00 00
	00		 lea	 edx, DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[edx]
  00018	8b c2		 mov	 eax, edx
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL9@gObjAddMsg@2:

; 3903 : 	{
; 3904 : 		if ( gSMMsg[lpObj->m_Index][n].MsgCode < 0 )

  00020	83 38 00	 cmp	 DWORD PTR [eax], 0
  00023	7c 29		 jl	 SHORT $LN14@gObjAddMsg@2

; 3902 : 	for ( int n=0;n<MAX_MONSTER_SEND_MSG;n++)

  00025	46		 inc	 esi
  00026	83 c0 10	 add	 eax, 16			; 00000010H
  00029	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  0002c	7c f2		 jl	 SHORT $LL9@gObjAddMsg@2

; 3910 : 
; 3911 : 			return;
; 3912 : 		}
; 3913 : 	}
; 3914 : 
; 3915 : 	for (int n=0;n<MAX_MONSTER_SEND_MSG;n++)

  0002e	33 f6		 xor	 esi, esi
$LL5@gObjAddMsg@2:

; 3916 : 	{
; 3917 : 		if ( gSMMsg[lpObj->m_Index][n].MsgCode == 2 || gSMMsg[lpObj->m_Index][n].MsgCode == 6 || gSMMsg[lpObj->m_Index][n].MsgCode == 7 )

  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	83 f8 02	 cmp	 eax, 2
  00035	74 71		 je	 SHORT $LN15@gObjAddMsg@2
  00037	83 f8 06	 cmp	 eax, 6
  0003a	74 6c		 je	 SHORT $LN15@gObjAddMsg@2
  0003c	83 f8 07	 cmp	 eax, 7
  0003f	74 67		 je	 SHORT $LN15@gObjAddMsg@2

; 3910 : 
; 3911 : 			return;
; 3912 : 		}
; 3913 : 	}
; 3914 : 
; 3915 : 	for (int n=0;n<MAX_MONSTER_SEND_MSG;n++)

  00041	46		 inc	 esi
  00042	83 c2 10	 add	 edx, 16			; 00000010H
  00045	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00048	7c e6		 jl	 SHORT $LL5@gObjAddMsg@2
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 3923 : 			
; 3924 : 			return;
; 3925 : 		}
; 3926 : 	}
; 3927 : 
; 3928 : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN14@gObjAddMsg@2:

; 3905 : 		{
; 3906 : 			gSMMsg[lpObj->m_Index][n].MsgCode = aMsgCode;

  0004e	8b 55 0c	 mov	 edx, DWORD PTR _aMsgCode$[ebp]
  00051	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00054	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]
  00057	c1 e1 04	 shl	 ecx, 4
  0005a	89 91 00 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx], edx

; 3907 : 			gSMMsg[lpObj->m_Index][n].MsgTime = GetTickCount() + delay;

  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00066	8b c8		 mov	 ecx, eax
  00068	8b 07		 mov	 eax, DWORD PTR [edi]
  0006a	03 4d 14	 add	 ecx, DWORD PTR _delay$[ebp]
  0006d	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00070	8d 04 56	 lea	 eax, DWORD PTR [esi+edx*2]
  00073	c1 e0 04	 shl	 eax, 4
  00076	89 88 08 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+8], ecx

; 3908 : 			gSMMsg[lpObj->m_Index][n].SendUser = aIndex;

  0007c	8b 07		 mov	 eax, DWORD PTR [edi]
  0007e	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00081	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00084	8d 14 4e	 lea	 edx, DWORD PTR [esi+ecx*2]
  00087	c1 e2 04	 shl	 edx, 4
  0008a	89 82 04 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[edx+4], eax

; 3909 : 			gSMMsg[lpObj->m_Index][n].SubCode = SubCode;

  00090	8b 07		 mov	 eax, DWORD PTR [edi]
  00092	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00095	8b 45 18	 mov	 eax, DWORD PTR _SubCode$[ebp]
  00098	8d 14 4e	 lea	 edx, DWORD PTR [esi+ecx*2]
  0009b	c1 e2 04	 shl	 edx, 4
  0009e	5f		 pop	 edi
  0009f	89 82 0c 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[edx+12], eax
  000a5	5e		 pop	 esi

; 3923 : 			
; 3924 : 			return;
; 3925 : 		}
; 3926 : 	}
; 3927 : 
; 3928 : }

  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
$LN15@gObjAddMsg@2:

; 3918 : 		{
; 3919 : 			gSMMsg[lpObj->m_Index][n].MsgCode = aMsgCode;

  000a8	8b 45 0c	 mov	 eax, DWORD PTR _aMsgCode$[ebp]
  000ab	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  000ae	8d 14 4e	 lea	 edx, DWORD PTR [esi+ecx*2]
  000b1	c1 e2 04	 shl	 edx, 4
  000b4	89 82 00 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[edx], eax

; 3920 : 			gSMMsg[lpObj->m_Index][n].MsgTime = GetTickCount();

  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000c0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c2	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  000c5	8d 14 4e	 lea	 edx, DWORD PTR [esi+ecx*2]
  000c8	c1 e2 04	 shl	 edx, 4
  000cb	89 82 08 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[edx+8], eax

; 3921 : 			gSMMsg[lpObj->m_Index][n].SendUser= aIndex;

  000d1	8b 07		 mov	 eax, DWORD PTR [edi]
  000d3	8b 55 10	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000d6	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000d9	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]
  000dc	c1 e1 04	 shl	 ecx, 4
  000df	89 91 04 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+4], edx

; 3922 : 			gSMMsg[lpObj->m_Index][n].SubCode = SubCode;

  000e5	8b 07		 mov	 eax, DWORD PTR [edi]
  000e7	8b 55 18	 mov	 edx, DWORD PTR _SubCode$[ebp]
  000ea	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000ed	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]
  000f0	c1 e1 04	 shl	 ecx, 4
  000f3	5f		 pop	 edi
  000f4	89 91 0c 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+12], edx
  000fa	5e		 pop	 esi

; 3923 : 			
; 3924 : 			return;
; 3925 : 		}
; 3926 : 	}
; 3927 : 
; 3928 : }

  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ENDP	; gObjAddMsgSendDelay
_TEXT	ENDS
PUBLIC	?gObjAddMsgSendDelayInSpecificQPos@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddMsgSendDelayInSpecificQPos
; Function compile flags: /Ogtp
;	COMDAT ?gObjAddMsgSendDelayInSpecificQPos@@YAXPAUOBJECTSTRUCT@@HHHHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
_delay$ = 20						; size = 4
_SubCode$ = 24						; size = 4
_iQPosition$ = 28					; size = 4
?gObjAddMsgSendDelayInSpecificQPos@@YAXPAUOBJECTSTRUCT@@HHHHH@Z PROC ; gObjAddMsgSendDelayInSpecificQPos, COMDAT

; 3931 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3932 : 	if ( iQPosition >= 0 &&  iQPosition < MAX_MONSTER_SEND_MSG )

  00004	8b 75 1c	 mov	 esi, DWORD PTR _iQPosition$[ebp]
  00007	83 fe 09	 cmp	 esi, 9
  0000a	77 58		 ja	 SHORT $LN1@gObjAddMsg@3

; 3933 : 	{
; 3934 : 		gSMMsg[lpObj->m_Index][iQPosition].MsgCode = aMsgCode;

  0000c	8b 55 0c	 mov	 edx, DWORD PTR _aMsgCode$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00013	8b 07		 mov	 eax, DWORD PTR [edi]
  00015	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00018	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]
  0001b	c1 e1 04	 shl	 ecx, 4
  0001e	89 91 00 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx], edx

; 3935 : 		gSMMsg[lpObj->m_Index][iQPosition].MsgTime = GetTickCount();

  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0002c	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  0002f	8d 14 4e	 lea	 edx, DWORD PTR [esi+ecx*2]
  00032	c1 e2 04	 shl	 edx, 4
  00035	89 82 08 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[edx+8], eax

; 3936 : 		gSMMsg[lpObj->m_Index][iQPosition].SendUser = aIndex;

  0003b	8b 07		 mov	 eax, DWORD PTR [edi]
  0003d	8b 55 10	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00040	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00043	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]
  00046	c1 e1 04	 shl	 ecx, 4
  00049	89 91 04 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+4], edx

; 3937 : 		gSMMsg[lpObj->m_Index][iQPosition].SubCode = SubCode;

  0004f	8b 3f		 mov	 edi, DWORD PTR [edi]
  00051	8b 55 18	 mov	 edx, DWORD PTR _SubCode$[ebp]
  00054	8d 04 bf	 lea	 eax, DWORD PTR [edi+edi*4]
  00057	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]
  0005a	c1 e1 04	 shl	 ecx, 4
  0005d	89 91 0c 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+12], edx
  00063	5f		 pop	 edi
$LN1@gObjAddMsg@3:
  00064	5e		 pop	 esi

; 3938 : 	}
; 3939 : 
; 3940 : }

  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?gObjAddMsgSendDelayInSpecificQPos@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ENDP ; gObjAddMsgSendDelayInSpecificQPos
_TEXT	ENDS
PUBLIC	?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
; Function compile flags: /Ogtp
;	COMDAT ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
_delay$ = 20						; size = 4
_SubCode$ = 24						; size = 4
_SubCode2$ = 28						; size = 4
?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z PROC ; gObjAddAttackProcMsgSendDelay, COMDAT

; 3943 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3945 : 	{
; 3946 : 		int iIndex = lpObj->m_Index - OBJ_STARTUSERINDEX;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	81 ea 00 19 00
	00		 sub	 edx, 6400		; 00001900H
  0000e	33 c0		 xor	 eax, eax
  00010	6b d2 32	 imul	 edx, 50			; 00000032H
  00013	eb 0b 8d a4 24
	00 00 00 00 8d
	64 24 00	 npad	 13
$LL4@gObjAddAtt:

; 3947 : 
; 3948 : 		if ( gSMAttackProcMsg[iIndex][n].MsgCode < 0 )

  00020	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  00023	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  00026	83 3c 8d 00 00
	00 00 00	 cmp	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[ecx*4], 0
  0002e	7c 08		 jl	 SHORT $LN8@gObjAddAtt

; 3944 : 	for ( int n=0;n<MAX_MONSTER_SEND_ATTACK_MSG;n++)

  00030	40		 inc	 eax
  00031	83 f8 32	 cmp	 eax, 50			; 00000032H
  00034	7c ea		 jl	 SHORT $LL4@gObjAddAtt

; 3955 : 			return;
; 3956 : 		}
; 3957 : 	}
; 3958 : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN8@gObjAddAtt:
  00038	56		 push	 esi

; 3949 : 		{
; 3950 : 			gSMAttackProcMsg[iIndex][n].MsgCode = aMsgCode;

  00039	03 c2		 add	 eax, edx
  0003b	8b 55 0c	 mov	 edx, DWORD PTR _aMsgCode$[ebp]
  0003e	8d 34 80	 lea	 esi, DWORD PTR [eax+eax*4]
  00041	03 f6		 add	 esi, esi
  00043	03 f6		 add	 esi, esi
  00045	89 96 00 00 00
	00		 mov	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[esi], edx

; 3951 : 			gSMAttackProcMsg[iIndex][n].MsgTime = GetTickCount() + delay;

  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00051	03 45 14	 add	 eax, DWORD PTR _delay$[ebp]

; 3952 : 			gSMAttackProcMsg[iIndex][n].SendUser = aIndex;
; 3953 : 			gSMAttackProcMsg[iIndex][n].SubCode = SubCode;

  00054	8b 4d 18	 mov	 ecx, DWORD PTR _SubCode$[ebp]

; 3954 : 			gSMAttackProcMsg[iIndex][n].SubCode2 = SubCode2;

  00057	8b 55 1c	 mov	 edx, DWORD PTR _SubCode2$[ebp]
  0005a	89 86 08 00 00
	00		 mov	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[esi+8], eax
  00060	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00063	89 86 04 00 00
	00		 mov	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[esi+4], eax
  00069	89 8e 0c 00 00
	00		 mov	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[esi+12], ecx
  0006f	89 96 10 00 00
	00		 mov	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[esi+16], edx
  00075	5e		 pop	 esi

; 3955 : 			return;
; 3956 : 		}
; 3957 : 	}
; 3958 : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ENDP ; gObjAddAttackProcMsgSendDelay
_TEXT	ENDS
PUBLIC	?gObjBackSpring@@YAHPAUOBJECTSTRUCT@@0@Z	; gObjBackSpring
EXTRN	?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z:PROC ; RecvPositionSetProc
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?ClearStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::ClearStandAttr
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	_rand:PROC
; Function compile flags: /Ogtp
;	COMDAT ?gObjBackSpring@@YAHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_pMove$ = -8						; size = 5
_y$ = 8							; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjBackSpring@@YAHPAUOBJECTSTRUCT@@0@Z PROC		; gObjBackSpring, COMDAT

; 4085 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 4086 : 	if ( MAX_MAP_RANGE(lpObj->MapNumber) == FALSE )

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000a	b8 27 00 00 00	 mov	 eax, 39			; 00000027H
  0000f	3a 86 09 01 00
	00		 cmp	 al, BYTE PTR [esi+265]
  00015	1b c0		 sbb	 eax, eax
  00017	40		 inc	 eax
  00018	75 1f		 jne	 SHORT $LN11@gObjBackSp

; 4087 : 	{
; 4088 : 		LogAdd(LOG_BLACK, "error : %s %d", __FILE__, __LINE__);

  0001a	68 f8 0f 00 00	 push	 4088			; 00000ff8H
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0002f	83 c4 10	 add	 esp, 16			; 00000010H
$LN17@gObjBackSp:

; 4089 : 		return FALSE;

  00032	33 c0		 xor	 eax, eax
  00034	5e		 pop	 esi

; 4200 : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN11@gObjBackSp:

; 4090 : 	}
; 4091 : 
; 4092 : 	if ( lpObj->Type == OBJ_USER )

  00039	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0003e	75 09		 jne	 SHORT $LN9@gObjBackSp

; 4093 : 	{
; 4094 : 		if ( lpObj->m_LastTeleportTime > 0 )

  00040	80 be 21 0f 00
	00 00		 cmp	 BYTE PTR [esi+3873], 0

; 4095 : 		{
; 4096 : 			return FALSE;

  00047	7f e9		 jg	 SHORT $LN17@gObjBackSp
$LN9@gObjBackSp:

; 4097 : 		}
; 4098 : 	}
; 4099 : 
; 4100 : #if GS_CASTLE == 1
; 4101 : 	if ( lpObj->Type == OBJ_USER )
; 4102 : 	{
; 4103 : 		if ( (lpObj->Authority & 2) == 2 )
; 4104 : 			return FALSE;
; 4105 : 	}
; 4106 : #endif
; 4107 : 
; 4108 : 	if ( lpObj->Class >= 131 && lpObj->Class <= 134 )

  00049	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00050	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00055	66 3b c1	 cmp	 ax, cx
  00058	72 0a		 jb	 SHORT $LN8@gObjBackSp
  0005a	ba 86 00 00 00	 mov	 edx, 134		; 00000086H
  0005f	66 3b c2	 cmp	 ax, dx

; 4109 : 	{
; 4110 : 		return FALSE;

  00062	76 ce		 jbe	 SHORT $LN17@gObjBackSp
$LN8@gObjBackSp:

; 4111 : 	}
; 4112 : 
; 4113 : 	int tdir;
; 4114 : 
; 4115 : #if GS_CASTLE == 1
; 4116 : 	if( lpObj->Class == 277 || lpObj->Class == 283 ||
; 4117 : 		lpObj->Class == 288 || lpObj->Class == 278 ||
; 4118 : 		lpObj->Class == 215 || lpObj->Class == 216 || 
; 4119 : 		lpObj->Class == 217 || lpObj->Class == 218 ||
; 4120 : 		lpObj->Class == 219 )
; 4121 : 	{
; 4122 : 		return FALSE;
; 4123 : 	}
; 4124 : 
; 4125 : 
; 4126 : 	if ( g_CastleSiege.GetCrownUserIndex() == lpObj->m_Index )
; 4127 : 	{
; 4128 : 		if ( lpObj->pInventory[8].m_Type == ITEMGET(13,4) )
; 4129 : 		{
; 4130 : 			return FALSE;
; 4131 : 		}
; 4132 : 	}
; 4133 : 
; 4134 : 	if ( CHECK_LIMIT2(lpObj->Class, 205, 210) || 
; 4135 : 		 CHECK_CLASS(lpObj->Class, 204) )
; 4136 : 	{
; 4137 : 		return FALSE;
; 4138 : 	}
; 4139 : 	
; 4140 : 	if ( lpObj->Class == 348 )
; 4141 : 	{
; 4142 : 		return FALSE;
; 4143 : 	}
; 4144 : #endif
; 4145 : 
; 4146 : 	if ( (rand()%3) == 0 )

  00064	e8 00 00 00 00	 call	 _rand
  00069	99		 cdq
  0006a	b9 03 00 00 00	 mov	 ecx, 3
  0006f	f7 f9		 idiv	 ecx
  00071	85 d2		 test	 edx, edx
  00073	75 1a		 jne	 SHORT $LN7@gObjBackSp

; 4147 : 	{
; 4148 : 		if ( lpTargetObj->Dir < 4 )

  00075	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00078	8a 82 08 01 00
	00		 mov	 al, BYTE PTR [edx+264]
  0007e	3c 04		 cmp	 al, 4

; 4149 : 		{
; 4150 : 			tdir = lpTargetObj->Dir + 4;

  00080	0f b6 c0	 movzx	 eax, al
  00083	73 05		 jae	 SHORT $LN6@gObjBackSp
  00085	83 c0 04	 add	 eax, 4

; 4151 : 		}
; 4152 : 		else

  00088	eb 0f		 jmp	 SHORT $LN5@gObjBackSp
$LN6@gObjBackSp:

; 4153 : 		{
; 4154 : 			tdir = lpTargetObj->Dir - 4;

  0008a	83 e8 04	 sub	 eax, 4

; 4155 : 		}
; 4156 : 
; 4157 : 		tdir *= 2;
; 4158 : 	}
; 4159 : 	else

  0008d	eb 0a		 jmp	 SHORT $LN5@gObjBackSp
$LN7@gObjBackSp:

; 4160 : 	{
; 4161 : 		tdir = lpTargetObj->Dir * 2;

  0008f	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00092	0f b6 80 08 01
	00 00		 movzx	 eax, BYTE PTR [eax+264]
$LN5@gObjBackSp:

; 4162 : 	}
; 4163 : 
; 4164 : 	
; 4165 : 	int x = lpObj->X;
; 4166 : 	int y = lpObj->Y;
; 4167 : 	x += RoadPathTable[tdir];

  00099	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]

; 4168 : 	y += RoadPathTable[1+tdir];

  000a0	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  000a7	03 c0		 add	 eax, eax
  000a9	53		 push	 ebx
  000aa	0f bf 1c 45 00
	00 00 00	 movsx	 ebx, WORD PTR ?RoadPathTable@@3PAFA[eax*2]
  000b2	0f bf 04 45 02
	00 00 00	 movsx	 eax, WORD PTR ?RoadPathTable@@3PAFA[eax*2+2]
  000ba	03 d9		 add	 ebx, ecx

; 4169 : 	BYTE attr = MapC[lpObj->MapNumber].GetAttr(x, y);

  000bc	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  000c3	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  000c9	03 c2		 add	 eax, edx
  000cb	50		 push	 eax
  000cc	53		 push	 ebx
  000cd	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000d3	89 45 08	 mov	 DWORD PTR _y$[ebp], eax
  000d6	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 4170 : 
; 4171 : 	if ( (attr&1)==1 || (attr&2)==2 || (attr&4)== 4 || (attr&8)== 8 
; 4172 : #if GS_CASTLE == 1
; 4173 : 		 || (attr&16)== 16 
; 4174 : #endif
; 4175 : 		 )

  000db	a8 0f		 test	 al, 15			; 0000000fH
  000dd	0f 85 9c 00 00
	00		 jne	 $LN2@gObjBackSp

; 4178 : 	}
; 4179 : 
; 4180 : 	PMSG_POSISTION_SET pMove;
; 4181 : 	pMove.h.c = 0xC1;
; 4182 : 	pMove.h.headcode = PROTOCOL_POSITION;
; 4183 : 	pMove.h.size = sizeof(pMove);
; 4184 : 	pMove.X = x;
; 4185 : 	pMove.Y = y;
; 4186 : 
; 4187 : 	lpObj->m_Rest = 0;
; 4188 : 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  000e3	0f bf 8e 1e 01
	00 00		 movsx	 ecx, WORD PTR [esi+286]
  000ea	0f bf 96 1c 01
	00 00		 movsx	 edx, WORD PTR [esi+284]
  000f1	8a 45 08	 mov	 al, BYTE PTR _y$[ebp]
  000f4	51		 push	 ecx
  000f5	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  000fc	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00102	52		 push	 edx
  00103	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00109	c6 45 f8 c1	 mov	 BYTE PTR _pMove$[ebp], 193 ; 000000c1H
  0010d	66 c7 45 f9 05
	df		 mov	 WORD PTR _pMove$[ebp+1], 57093 ; 0000df05H
  00113	88 5d fb	 mov	 BYTE PTR _pMove$[ebp+3], bl
  00116	88 45 fc	 mov	 BYTE PTR _pMove$[ebp+4], al
  00119	c6 86 c1 01 00
	00 00		 mov	 BYTE PTR [esi+449], 0
  00120	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 4189 : 	MapC[lpObj->MapNumber].SetStandAttr(x, y);

  00125	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  0012c	8b 45 08	 mov	 eax, DWORD PTR _y$[ebp]
  0012f	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00135	50		 push	 eax
  00136	53		 push	 ebx
  00137	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0013d	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 4190 : 	lpObj->m_OldX = x;
; 4191 : 	lpObj->m_OldY = y;
; 4192 : 	RecvPositionSetProc(&pMove, lpObj->m_Index);

  00142	8b 16		 mov	 edx, DWORD PTR [esi]
  00144	66 8b 4d 08	 mov	 cx, WORD PTR _y$[ebp]
  00148	52		 push	 edx
  00149	8d 45 f8	 lea	 eax, DWORD PTR _pMove$[ebp]
  0014c	50		 push	 eax
  0014d	66 89 9e 1c 01
	00 00		 mov	 WORD PTR [esi+284], bx
  00154	66 89 8e 1e 01
	00 00		 mov	 WORD PTR [esi+286], cx
  0015b	e8 00 00 00 00	 call	 ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
  00160	83 c4 08	 add	 esp, 8

; 4193 : 
; 4194 : 	if ( lpObj->Type == OBJ_USER )

  00163	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00168	75 0a		 jne	 SHORT $LN1@gObjBackSp

; 4195 : 	{
; 4196 : 		lpObj->PathCount = 0;

  0016a	c7 86 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+296], 0
$LN1@gObjBackSp:
  00174	5b		 pop	 ebx

; 4197 : 	}
; 4198 : 
; 4199 : 	return TRUE;

  00175	b8 01 00 00 00	 mov	 eax, 1
  0017a	5e		 pop	 esi

; 4200 : }

  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c3		 ret	 0
$LN2@gObjBackSp:
  0017f	5b		 pop	 ebx

; 4176 : 	{
; 4177 : 		return FALSE;

  00180	33 c0		 xor	 eax, eax
  00182	5e		 pop	 esi

; 4200 : }

  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c3		 ret	 0
?gObjBackSpring@@YAHPAUOBJECTSTRUCT@@0@Z ENDP		; gObjBackSpring
_TEXT	ENDS
PUBLIC	?BackSpringCheck@@YAHAAH00E@Z			; BackSpringCheck
; Function compile flags: /Ogtp
;	COMDAT ?BackSpringCheck@@YAHAAH00E@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_dir$ = 16						; size = 4
_map$ = 20						; size = 1
?BackSpringCheck@@YAHAAH00E@Z PROC			; BackSpringCheck, COMDAT

; 4203 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4204 : 	BYTE attr;
; 4205 : 	int tx = x;
; 4206 : 	int ty = y;
; 4207 : 	int tdir = dir/2;

  00003	8b 45 10	 mov	 eax, DWORD PTR _dir$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 4208 : 
; 4209 : 	tx = tx + RoadPathTable[dir];

  0000a	0f bf 34 4d 00
	00 00 00	 movsx	 esi, WORD PTR ?RoadPathTable@@3PAFA[ecx*2]
  00012	57		 push	 edi

; 4210 : 	ty = ty + RoadPathTable[1+dir];

  00013	0f bf 3c 4d 02
	00 00 00	 movsx	 edi, WORD PTR ?RoadPathTable@@3PAFA[ecx*2+2]
  0001b	8b c1		 mov	 eax, ecx

; 4211 : 
; 4212 : 	attr = MapC[map].GetAttr(tx, ty);

  0001d	0f b6 4d 14	 movzx	 ecx, BYTE PTR _map$[ebp]
  00021	99		 cdq
  00022	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00028	2b c2		 sub	 eax, edx
  0002a	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0002d	03 32		 add	 esi, DWORD PTR [edx]
  0002f	8b d8		 mov	 ebx, eax
  00031	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00034	03 38		 add	 edi, DWORD PTR [eax]
  00036	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0003c	57		 push	 edi
  0003d	56		 push	 esi
  0003e	d1 fb		 sar	 ebx, 1
  00040	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 4213 : 
; 4214 : 	if ( (attr&1)==1 || (attr&4)== 4 || (attr&8)== 8 
; 4215 : #if GS_CASTLE == 1
; 4216 : 		 || (attr&16)== 16 
; 4217 : #endif
; 4218 : 		 )

  00045	a8 0d		 test	 al, 13			; 0000000dH
  00047	75 14		 jne	 SHORT $LN2@BackSpring

; 4229 : 	}
; 4230 : 
; 4231 : 	x = tx;

  00049	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]

; 4232 : 	y = ty;

  0004c	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  0004f	89 31		 mov	 DWORD PTR [ecx], esi
  00051	89 3a		 mov	 DWORD PTR [edx], edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 4233 : 
; 4234 : 	return TRUE;

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	5b		 pop	 ebx

; 4235 : }

  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
$LN2@BackSpring:

; 4219 : 	{
; 4220 : 		tdir += 4;

  0005d	83 c3 04	 add	 ebx, 4

; 4221 : 
; 4222 : 		if ( tdir > 7 )

  00060	83 fb 07	 cmp	 ebx, 7
  00063	7e 03		 jle	 SHORT $LN1@BackSpring

; 4223 : 		{
; 4224 : 			tdir -= 8;

  00065	83 eb 08	 sub	 ebx, 8
$LN1@BackSpring:

; 4225 : 		}
; 4226 : 
; 4227 : 		dir = tdir * 2;

  00068	8b 4d 10	 mov	 ecx, DWORD PTR _dir$[ebp]
  0006b	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	89 01		 mov	 DWORD PTR [ecx], eax

; 4228 : 		return FALSE;

  00072	33 c0		 xor	 eax, eax
  00074	5b		 pop	 ebx

; 4235 : }

  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?BackSpringCheck@@YAHAAH00E@Z ENDP			; BackSpringCheck
_TEXT	ENDS
PUBLIC	?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z	; gObjBackSpring2
; Function compile flags: /Ogtp
;	COMDAT ?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
_pMove$ = -16						; size = 5
_tdir$ = -8						; size = 4
_x$ = -4						; size = 4
_y$ = 8							; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_count$ = 16						; size = 4
?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z PROC		; gObjBackSpring2, COMDAT

; 4238 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 4239 : 	if ( MAX_MAP_RANGE(lpObj->MapNumber) == FALSE )

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000a	b8 27 00 00 00	 mov	 eax, 39			; 00000027H
  0000f	3a 86 09 01 00
	00		 cmp	 al, BYTE PTR [esi+265]
  00015	1b c0		 sbb	 eax, eax
  00017	40		 inc	 eax
  00018	75 1f		 jne	 SHORT $LN11@gObjBackSp@2

; 4240 : 	{
; 4241 : 		LogAdd(LOG_BLACK, "error : %s %d", __FILE__, __LINE__);

  0001a	68 91 10 00 00	 push	 4241			; 00001091H
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0002f	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@gObjBackSp@2:

; 4253 : 	{
; 4254 : 		return FALSE;

  00032	33 c0		 xor	 eax, eax
  00034	5e		 pop	 esi

; 4336 : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN11@gObjBackSp@2:

; 4242 : 		return FALSE;
; 4243 : 	}
; 4244 : 
; 4245 : #if GS_CASTLE == 1
; 4246 : 	if ( lpObj->Type == OBJ_USER )
; 4247 : 	{
; 4248 : 		if ( (lpObj->Authority & 2) == 2 )
; 4249 : 			return FALSE;
; 4250 : 	}
; 4251 : #endif
; 4252 : 	if ( lpObj->Class == 287 || lpObj->Class == 286 )

  00039	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00040	b9 1f 01 00 00	 mov	 ecx, 287		; 0000011fH
  00045	66 3b c1	 cmp	 ax, cx
  00048	74 e8		 je	 SHORT $LN9@gObjBackSp@2
  0004a	ba 1e 01 00 00	 mov	 edx, 286		; 0000011eH
  0004f	66 3b c2	 cmp	 ax, dx
  00052	74 de		 je	 SHORT $LN9@gObjBackSp@2

; 4255 : 	}
; 4256 : 
; 4257 : #if GS_CASTLE == 1
; 4258 : 	if ( lpObj->Class == 278 )
; 4259 : 	{
; 4260 : 		return FALSE;
; 4261 : 	}
; 4262 : #endif
; 4263 : 
; 4264 : 	if ( lpObj->Class >= 131 && lpObj->Class <= 134 )

  00054	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00059	66 3b c1	 cmp	 ax, cx
  0005c	72 0a		 jb	 SHORT $LN8@gObjBackSp@2
  0005e	ba 86 00 00 00	 mov	 edx, 134		; 00000086H
  00063	66 3b c2	 cmp	 ax, dx

; 4265 : 	{
; 4266 : 		return FALSE;

  00066	76 ca		 jbe	 SHORT $LN9@gObjBackSp@2
$LN8@gObjBackSp@2:

; 4267 : 	}
; 4268 : 
; 4269 : 	int tdir;
; 4270 : #if GS_CASTLE == 1
; 4271 : 	if( lpObj->Class == 277 || lpObj->Class == 283 ||
; 4272 : 		lpObj->Class == 288 || lpObj->Class == 278 ||
; 4273 : 		lpObj->Class == 215 || lpObj->Class == 216 || 
; 4274 : 		lpObj->Class == 217 || lpObj->Class == 218 ||
; 4275 : 		lpObj->Class == 219 )
; 4276 : 	{
; 4277 : 		return FALSE;
; 4278 : 	}
; 4279 : 
; 4280 : 
; 4281 : 	if ( g_CastleSiege.GetCrownUserIndex() == lpObj->m_Index )
; 4282 : 	{
; 4283 : 		if ( lpObj->pInventory[8].m_Type == ITEMGET(13,4) )
; 4284 : 		{
; 4285 : 			return FALSE;
; 4286 : 		}
; 4287 : 	}
; 4288 : 
; 4289 : 	if ( CHECK_LIMIT2(lpObj->Class, 205, 210) || 
; 4290 : 		 CHECK_CLASS(lpObj->Class, 204) )
; 4291 : 	{
; 4292 : 		return FALSE;
; 4293 : 	}
; 4294 : 	
; 4295 : 	if ( lpObj->Class == 348 )
; 4296 : 	{
; 4297 : 		return FALSE;
; 4298 : 	}
; 4299 : #endif
; 4300 : 	
; 4301 : 	tdir = GetPathPacketDirPos(lpObj->X - lpTargetObj->X, lpObj->Y - lpTargetObj->Y) * 2;

  00068	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0006b	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00072	0f bf 80 04 01
	00 00		 movsx	 eax, WORD PTR [eax+260]
  00079	53		 push	 ebx
  0007a	0f bf 9e 04 01
	00 00		 movsx	 ebx, WORD PTR [esi+260]
  00081	57		 push	 edi
  00082	0f bf be 06 01
	00 00		 movsx	 edi, WORD PTR [esi+262]
  00089	8b d7		 mov	 edx, edi
  0008b	2b d1		 sub	 edx, ecx
  0008d	8b cb		 mov	 ecx, ebx
  0008f	52		 push	 edx
  00090	2b c8		 sub	 ecx, eax
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  00098	0f b6 d0	 movzx	 edx, al

; 4302 : 	int x = lpObj->X;
; 4303 : 	int y = lpObj->Y;

  0009b	89 7d 08	 mov	 DWORD PTR _y$[ebp], edi
  0009e	03 d2		 add	 edx, edx

; 4304 : 
; 4305 : 	for ( int n=0;n<count;n++)

  000a0	33 ff		 xor	 edi, edi
  000a2	83 c4 08	 add	 esp, 8
  000a5	89 55 f8	 mov	 DWORD PTR _tdir$[ebp], edx
  000a8	89 5d fc	 mov	 DWORD PTR _x$[ebp], ebx
  000ab	39 7d 10	 cmp	 DWORD PTR _count$[ebp], edi
  000ae	7e 56		 jle	 SHORT $LN5@gObjBackSp@2
$LL7@gObjBackSp@2:

; 4306 : 	{
; 4307 : 		if ( n >= 2 )

  000b0	83 ff 02	 cmp	 edi, 2
  000b3	7c 2c		 jl	 SHORT $LN4@gObjBackSp@2

; 4308 : 		{
; 4309 : 			if ( lpObj->Class == 4 || lpObj->Class == 3 || lpObj->Class == 1 )

  000b5	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  000bc	83 f8 04	 cmp	 eax, 4
  000bf	74 0a		 je	 SHORT $LN18@gObjBackSp@2
  000c1	83 f8 03	 cmp	 eax, 3
  000c4	74 05		 je	 SHORT $LN18@gObjBackSp@2
  000c6	83 f8 01	 cmp	 eax, 1
  000c9	75 32		 jne	 SHORT $LN6@gObjBackSp@2
$LN18@gObjBackSp@2:

; 4310 : 			{
; 4311 : 				BackSpringCheck(x, y, tdir, lpObj->MapNumber);

  000cb	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  000d2	50		 push	 eax
  000d3	8d 4d f8	 lea	 ecx, DWORD PTR _tdir$[ebp]
  000d6	51		 push	 ecx
  000d7	8d 55 08	 lea	 edx, DWORD PTR _y$[ebp]
  000da	52		 push	 edx
  000db	8d 45 fc	 lea	 eax, DWORD PTR _x$[ebp]
  000de	50		 push	 eax

; 4312 : 			}
; 4313 : 		}
; 4314 : 		else

  000df	eb 14		 jmp	 SHORT $LN19@gObjBackSp@2
$LN4@gObjBackSp@2:

; 4315 : 		{
; 4316 : 			BackSpringCheck(x, y, tdir, lpObj->MapNumber);

  000e1	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  000e8	51		 push	 ecx
  000e9	8d 55 f8	 lea	 edx, DWORD PTR _tdir$[ebp]
  000ec	52		 push	 edx
  000ed	8d 45 08	 lea	 eax, DWORD PTR _y$[ebp]
  000f0	50		 push	 eax
  000f1	8d 4d fc	 lea	 ecx, DWORD PTR _x$[ebp]
  000f4	51		 push	 ecx
$LN19@gObjBackSp@2:
  000f5	e8 00 00 00 00	 call	 ?BackSpringCheck@@YAHAAH00E@Z ; BackSpringCheck
  000fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@gObjBackSp@2:

; 4304 : 
; 4305 : 	for ( int n=0;n<count;n++)

  000fd	47		 inc	 edi
  000fe	3b 7d 10	 cmp	 edi, DWORD PTR _count$[ebp]
  00101	7c ad		 jl	 SHORT $LL7@gObjBackSp@2
  00103	8b 5d fc	 mov	 ebx, DWORD PTR _x$[ebp]
$LN5@gObjBackSp@2:

; 4317 : 		}
; 4318 : 	}
; 4319 : 
; 4320 : 	PMSG_POSISTION_SET pMove;
; 4321 : 
; 4322 : 	pMove.h.c = 0xC1;
; 4323 : 	pMove.h.headcode = PROTOCOL_POSITION;
; 4324 : 	pMove.h.size = sizeof(pMove);
; 4325 : 	pMove.X = x;
; 4326 : 	pMove.Y = y;
; 4327 : 
; 4328 : 	lpObj->m_Rest = 0;
; 4329 : 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  00106	0f bf 86 1e 01
	00 00		 movsx	 eax, WORD PTR [esi+286]
  0010d	0f bf 8e 1c 01
	00 00		 movsx	 ecx, WORD PTR [esi+284]
  00114	8a 55 08	 mov	 dl, BYTE PTR _y$[ebp]
  00117	50		 push	 eax
  00118	51		 push	 ecx
  00119	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00120	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00126	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0012c	c6 45 f0 c1	 mov	 BYTE PTR _pMove$[ebp], 193 ; 000000c1H
  00130	66 c7 45 f1 05
	df		 mov	 WORD PTR _pMove$[ebp+1], 57093 ; 0000df05H
  00136	88 5d f3	 mov	 BYTE PTR _pMove$[ebp+3], bl
  00139	88 55 f4	 mov	 BYTE PTR _pMove$[ebp+4], dl
  0013c	c6 86 c1 01 00
	00 00		 mov	 BYTE PTR [esi+449], 0
  00143	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 4330 : 	MapC[lpObj->MapNumber].SetStandAttr(x, y);

  00148	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  0014f	8b 55 08	 mov	 edx, DWORD PTR _y$[ebp]
  00152	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00158	52		 push	 edx
  00159	53		 push	 ebx
  0015a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00160	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 4331 : 	lpObj->m_OldX = x;
; 4332 : 	lpObj->m_OldY = y;
; 4333 : 	RecvPositionSetProc(&pMove, lpObj->m_Index);

  00165	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00167	66 8b 45 08	 mov	 ax, WORD PTR _y$[ebp]
  0016b	51		 push	 ecx
  0016c	8d 55 f0	 lea	 edx, DWORD PTR _pMove$[ebp]
  0016f	52		 push	 edx
  00170	66 89 9e 1c 01
	00 00		 mov	 WORD PTR [esi+284], bx
  00177	66 89 86 1e 01
	00 00		 mov	 WORD PTR [esi+286], ax
  0017e	e8 00 00 00 00	 call	 ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
  00183	83 c4 08	 add	 esp, 8
  00186	5f		 pop	 edi
  00187	5b		 pop	 ebx

; 4334 : 
; 4335 : 	return TRUE;

  00188	b8 01 00 00 00	 mov	 eax, 1
  0018d	5e		 pop	 esi

; 4336 : }

  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c3		 ret	 0
?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z ENDP		; gObjBackSpring2
_TEXT	ENDS
PUBLIC	?gObjGiveItemSearch@@YAXPAUOBJECTSTRUCT@@H@Z	; gObjGiveItemSearch
; Function compile flags: /Ogtp
;	COMDAT ?gObjGiveItemSearch@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_maxlevel$ = 12						; size = 4
?gObjGiveItemSearch@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; gObjGiveItemSearch, COMDAT

; 4591 : #if ACTIVE_ITEM_SEARCH == 0
; 4592 : 	//goto lavelend;
; 4593 : #endif
; 4594 : 
; 4595 : //	int count;
; 4596 : 	//while (--count)
; 4597 : 	{
; 4598 : 
; 4599 : 	}
; 4600 : 
; 4601 : #if ACTIVE_ITEM_SEARCH == 0
; 4602 : 	//labelend:
; 4603 : #endif
; 4604 : }

  00000	c3		 ret	 0
?gObjGiveItemSearch@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; gObjGiveItemSearch
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjWarehouseInsertItem@@YAEPAUOBJECTSTRUCT@@HHHH@Z ; gObjWarehouseInsertItem
EXTRN	?Convert@CItem@@QAEXHEEEEEEE@Z:PROC		; CItem::Convert
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	??0CItem@@QAE@XZ:PROC				; CItem::CItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjWarehouseInsertItem@@YAEPAUOBJECTSTRUCT@@HHHH@Z
_TEXT	SEGMENT
_item$ = -172						; size = 168
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_type$ = 12						; size = 4
_index$ = 16						; size = 4
_level$ = 20						; size = 4
_pos$ = 24						; size = 4
?gObjWarehouseInsertItem@@YAEPAUOBJECTSTRUCT@@HHHH@Z PROC ; gObjWarehouseInsertItem, COMDAT

; 4611 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 18	 mov	 ebx, DWORD PTR _pos$[ebp]
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0001b	57		 push	 edi

; 4612 : 	CItem item;

  0001c	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00022	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 4613 : 
; 4614 : 	int item_type = ItemGetNumberMake(type, index);

  00027	8b 45 10	 mov	 eax, DWORD PTR _index$[ebp]
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 4615 : 	item.m_Level =level;

  00034	66 8b 55 14	 mov	 dx, WORD PTR _level$[ebp]
  00038	83 c4 08	 add	 esp, 8

; 4616 : 	item.Convert(item_type, 0 , 0, 0, 0, 0,0,  CURRENT_DB_VERSION);

  0003b	6a 03		 push	 3
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	6a 00		 push	 0
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	50		 push	 eax
  0004a	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00050	66 89 95 5c ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], dx
  00057	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEE@Z ; CItem::Convert

; 4617 : 	lpObj->pWarehouse[pos] = item;

  0005c	8b be c4 0c 00
	00		 mov	 edi, DWORD PTR [esi+3268]
  00062	8b c3		 mov	 eax, ebx
  00064	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  0006a	03 f8		 add	 edi, eax
  0006c	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00071	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  00077	f3 a5		 rep movsd

; 4618 : 	return pos;
; 4619 : }

  00079	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	8a c3		 mov	 al, bl
  00080	33 cd		 xor	 ecx, ebp
  00082	5b		 pop	 ebx
  00083	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?gObjWarehouseInsertItem@@YAEPAUOBJECTSTRUCT@@HHHH@Z ENDP ; gObjWarehouseInsertItem
_TEXT	ENDS
PUBLIC	?gObjGiveItemWarehouseSearch@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjGiveItemWarehouseSearch
; Function compile flags: /Ogtp
;	COMDAT ?gObjGiveItemWarehouseSearch@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_maxlevel$ = 12						; size = 4
?gObjGiveItemWarehouseSearch@@YAXPAUOBJECTSTRUCT@@H@Z PROC ; gObjGiveItemWarehouseSearch, COMDAT

; 4629 : #if ACTIVE_ITEM_SEARCH == 0
; 4630 : 	//goto lavelend;
; 4631 : #endif
; 4632 : 
; 4633 : 	
; 4634 : 
; 4635 : #if ACTIVE_ITEM_SEARCH == 0
; 4636 : 	//labelend:
; 4637 : #endif
; 4638 : }

  00000	c3		 ret	 0
?gObjGiveItemWarehouseSearch@@YAXPAUOBJECTSTRUCT@@H@Z ENDP ; gObjGiveItemWarehouseSearch
_TEXT	ENDS
PUBLIC	?gObjGuildMasterCapacityTest@@YAHPAUOBJECTSTRUCT@@@Z ; gObjGuildMasterCapacityTest
EXTRN	?gGuildCreateLevel@@3HA:DWORD			; gGuildCreateLevel
; Function compile flags: /Ogtp
;	COMDAT ?gObjGuildMasterCapacityTest@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjGuildMasterCapacityTest@@YAHPAUOBJECTSTRUCT@@@Z PROC ; gObjGuildMasterCapacityTest, COMDAT

; 4646 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4647 : 	if (lpObj->Level < gGuildCreateLevel)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	0f bf 88 9c 00
	00 00		 movsx	 ecx, WORD PTR [eax+156]
  0000d	33 c0		 xor	 eax, eax
  0000f	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gGuildCreateLevel@@3HA ; gGuildCreateLevel
  00015	0f 9d c0	 setge	 al

; 4648 : 	{
; 4649 : 		return 0;
; 4650 : 	}
; 4651 : 	return 1;
; 4652 : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?gObjGuildMasterCapacityTest@@YAHPAUOBJECTSTRUCT@@@Z ENDP ; gObjGuildMasterCapacityTest
_TEXT	ENDS
PUBLIC	?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z		; gObjNextExpCal
EXTRN	?gLevelExperience@@3PAKA:BYTE			; gLevelExperience
; Function compile flags: /Ogtp
;	COMDAT ?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjNextExpCal, COMDAT

; 4655 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4656 : 	lpObj->NextExp = gLevelExperience[lpObj->Level];

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	0f bf 88 9c 00
	00 00		 movsx	 ecx, WORD PTR [eax+156]
  0000d	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?gLevelExperience@@3PAKA[ecx*4]
  00014	89 90 ac 00 00
	00		 mov	 DWORD PTR [eax+172], edx

; 4657 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjNextExpCal
_TEXT	ENDS
PUBLIC	?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z		; retResistance
; Function compile flags: /Ogtp
;	COMDAT ?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_Resistance_Type$ = 12					; size = 4
?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z PROC		; retResistance, COMDAT

; 4660 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4661 : 	BYTE r = lpObj->m_Resistance[Resistance_Type];

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _Resistance_Type$[ebp]
  00009	53		 push	 ebx
  0000a	8a 9c 08 62 03
	00 00		 mov	 bl, BYTE PTR [eax+ecx+866]

; 4662 : 
; 4663 : 	if( r == 0xFF)

  00011	80 fb ff	 cmp	 bl, 255			; 000000ffH
  00014	75 08		 jne	 SHORT $LN5@retResista

; 4664 : 	{
; 4665 : 		return 1;

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	5b		 pop	 ebx

; 4679 : 	{
; 4680 : 		return 0;
; 4681 : 	}
; 4682 : 
; 4683 : 	return 1;
; 4684 : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN5@retResista:

; 4666 : 	}
; 4667 : 
; 4668 : 	if ( r > 0 && lpObj->m_iPotionSoulTime > 0 && (Resistance_Type == 2 || Resistance_Type == 0 ))

  0001e	84 db		 test	 bl, bl
  00020	74 2f		 je	 SHORT $LN9@retResista
  00022	83 b8 f8 14 00
	00 00		 cmp	 DWORD PTR [eax+5368], 0
  00029	7e 22		 jle	 SHORT $LN4@retResista
  0002b	83 f9 02	 cmp	 ecx, 2
  0002e	74 04		 je	 SHORT $LN3@retResista
  00030	85 c9		 test	 ecx, ecx
  00032	75 19		 jne	 SHORT $LN4@retResista
$LN3@retResista:

; 4669 : 	{
; 4670 : 		r += r * 50 / 100;

  00034	0f b6 cb	 movzx	 ecx, bl
  00037	6b c9 32	 imul	 ecx, 50			; 00000032H
  0003a	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0003f	f7 e9		 imul	 ecx
  00041	c1 fa 05	 sar	 edx, 5
  00044	8b c2		 mov	 eax, edx
  00046	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00049	03 c2		 add	 eax, edx
  0004b	02 d8		 add	 bl, al
$LN4@retResista:

; 4671 : 	}
; 4672 : 
; 4673 : 	if ( r  == 0 )

  0004d	84 db		 test	 bl, bl
  0004f	75 05		 jne	 SHORT $LN2@retResista
$LN9@retResista:

; 4674 : 	{
; 4675 : 		return 0;

  00051	33 c0		 xor	 eax, eax
  00053	5b		 pop	 ebx

; 4679 : 	{
; 4680 : 		return 0;
; 4681 : 	}
; 4682 : 
; 4683 : 	return 1;
; 4684 : }

  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
$LN2@retResista:

; 4676 : 	}
; 4677 : 
; 4678 : 	if (  (rand()%(r+1)) == 0 )

  00056	e8 00 00 00 00	 call	 _rand
  0005b	0f b6 cb	 movzx	 ecx, bl
  0005e	99		 cdq
  0005f	41		 inc	 ecx
  00060	f7 f9		 idiv	 ecx
  00062	5b		 pop	 ebx
  00063	8b c2		 mov	 eax, edx
  00065	f7 d8		 neg	 eax
  00067	1b c0		 sbb	 eax, eax
  00069	f7 d8		 neg	 eax

; 4679 : 	{
; 4680 : 		return 0;
; 4681 : 	}
; 4682 : 
; 4683 : 	return 1;
; 4684 : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z ENDP		; retResistance
_TEXT	ENDS
PUBLIC	?retCalcSkillResistance@@YAHPAUOBJECTSTRUCT@@H@Z ; retCalcSkillResistance
; Function compile flags: /Ogtp
;	COMDAT ?retCalcSkillResistance@@YAHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpTargetObj$ = 8					; size = 4
_isDouble$ = 12						; size = 4
?retCalcSkillResistance@@YAHPAUOBJECTSTRUCT@@H@Z PROC	; retCalcSkillResistance, COMDAT

; 4687 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4688 : 	if ( isDouble != FALSE )
; 4689 : 	{
; 4690 : 		if ( (rand()%100) < 45 )

  00003	e8 00 00 00 00	 call	 _rand
  00008	99		 cdq
  00009	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0000e	f7 f9		 idiv	 ecx
  00010	83 7d 0c 00	 cmp	 DWORD PTR _isDouble$[ebp], 0
  00014	74 0a		 je	 SHORT $LN4@retCalcSki
  00016	83 fa 2d	 cmp	 edx, 45			; 0000002dH
  00019	7d 11		 jge	 SHORT $LN1@retCalcSki

; 4691 : 		{
; 4692 : 			return TRUE;

  0001b	8d 41 9d	 lea	 eax, DWORD PTR [ecx-99]

; 4704 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
$LN4@retCalcSki:

; 4693 : 		}
; 4694 : 	}
; 4695 : 	else
; 4696 : 	{
; 4697 : 		if ( (rand()%100) < 40 )

  00020	83 fa 28	 cmp	 edx, 40			; 00000028H
  00023	7d 07		 jge	 SHORT $LN1@retCalcSki

; 4698 : 		{
; 4699 : 			return TRUE;

  00025	b8 01 00 00 00	 mov	 eax, 1

; 4704 : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN1@retCalcSki:

; 4700 : 		}
; 4701 : 	}
; 4702 : 
; 4703 : 	return FALSE;

  0002c	33 c0		 xor	 eax, eax

; 4704 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?retCalcSkillResistance@@YAHPAUOBJECTSTRUCT@@H@Z ENDP	; retCalcSkillResistance
_TEXT	ENDS
PUBLIC	?gObjAttackQ@@YAHPAUOBJECTSTRUCT@@@Z		; gObjAttackQ
EXTRN	?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z:PROC ; CBloodCastle::CheckBossKillSuccess
EXTRN	?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z:PROC ; CBloodCastle::CheckMonsterKillSuccess
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
; Function compile flags: /Ogtp
;	COMDAT ?gObjAttackQ@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjAttackQ@@YAHPAUOBJECTSTRUCT@@@Z PROC		; gObjAttackQ, COMDAT

; 4707 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4708 : 	if ( ATTRIBUTE_RANGE(lpObj->m_Attribute) )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	0f b7 86 26 03
	00 00		 movzx	 eax, WORD PTR [esi+806]
  0000e	66 83 f8 33	 cmp	 ax, 51			; 00000033H
  00012	7c 13		 jl	 SHORT $LN11@gObjAttack
  00014	33 c9		 xor	 ecx, ecx
  00016	66 83 f8 3a	 cmp	 ax, 58			; 0000003aH
  0001a	0f 9e c1	 setle	 cl
  0001d	8b c1		 mov	 eax, ecx
  0001f	85 c0		 test	 eax, eax

; 4709 : 	{
; 4710 : 		return FALSE;

  00021	0f 85 d7 00 00
	00		 jne	 $LN9@gObjAttack
$LN11@gObjAttack:

; 4711 : 	}
; 4712 : 
; 4713 : 	if ( lpObj->Class == 221 || lpObj->Class == 222 )

  00027	0f b7 96 98 00
	00 00		 movzx	 edx, WORD PTR [esi+152]
  0002e	b8 dd 00 00 00	 mov	 eax, 221		; 000000ddH
  00033	66 3b d0	 cmp	 dx, ax
  00036	0f 84 c2 00 00
	00		 je	 $LN9@gObjAttack
  0003c	b9 de 00 00 00	 mov	 ecx, 222		; 000000deH
  00041	66 3b d1	 cmp	 dx, cx
  00044	0f 84 b4 00 00
	00		 je	 $LN9@gObjAttack

; 4716 : 	}
; 4717 : 
; 4718 : #if GS_CASTLE == 1
; 4719 : 	if ( lpObj->Class == 277 || lpObj->Class == 283 )
; 4720 : 	{
; 4721 : 		if ( g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE )
; 4722 : 		{
; 4723 : 			return FALSE;
; 4724 : 		}
; 4725 : 	}
; 4726 : 
; 4727 : 	if ( lpObj->Class == 221 || lpObj->Class == 222 )
; 4728 : 	{
; 4729 : 		return FALSE;
; 4730 : 	}
; 4731 : 
; 4732 : 	if ( lpObj->Class == 277 && lpObj->m_btCsGateOpen == 1 )
; 4733 : 	{
; 4734 : 		return FALSE;
; 4735 : 	}
; 4736 : #endif
; 4737 : 
; 4738 : 	if ( BC_MAP_RANGE(lpObj->MapNumber) )

  0004a	8a 8e 09 01 00
	00		 mov	 cl, BYTE PTR [esi+265]
  00050	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00053	72 67		 jb	 SHORT $LN5@gObjAttack
  00055	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0005a	3a c1		 cmp	 al, cl
  0005c	1b c0		 sbb	 eax, eax
  0005e	40		 inc	 eax
  0005f	74 5b		 je	 SHORT $LN5@gObjAttack

; 4739 : 	{
; 4740 : 		if ( lpObj->Type >= OBJ_MONSTER )

  00061	66 83 7e 60 02	 cmp	 WORD PTR [esi+96], 2
  00066	72 54		 jb	 SHORT $LN5@gObjAttack

; 4741 : 		{
; 4742 : 			if ( lpObj->Class == 131 && g_BloodCastle.CheckMonsterKillSuccess(lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1) == false)

  00068	b8 83 00 00 00	 mov	 eax, 131		; 00000083H
  0006d	66 3b d0	 cmp	 dx, ax
  00070	75 15		 jne	 SHORT $LN6@gObjAttack
  00072	0f b6 c9	 movzx	 ecx, cl
  00075	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00078	51		 push	 ecx
  00079	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0007e	e8 00 00 00 00	 call	 ?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckMonsterKillSuccess
  00083	84 c0		 test	 al, al

; 4743 : 			{
; 4744 : 				return FALSE;

  00085	74 77		 je	 SHORT $LN9@gObjAttack
$LN6@gObjAttack:

; 4745 : 			}
; 4746 : 
; 4747 : 			if ( (((lpObj->Class - 132) < 0)?FALSE:((lpObj->Class-132) > 2)?FALSE:TRUE) !=FALSE && g_BloodCastle.CheckBossKillSuccess(lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1) == false )

  00087	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  0008e	05 7c ff ff ff	 add	 eax, -132		; ffffff7cH
  00093	78 27		 js	 SHORT $LN5@gObjAttack
  00095	33 d2		 xor	 edx, edx
  00097	83 f8 02	 cmp	 eax, 2
  0009a	0f 9e c2	 setle	 dl
  0009d	8b c2		 mov	 eax, edx
  0009f	85 c0		 test	 eax, eax
  000a1	74 19		 je	 SHORT $LN5@gObjAttack
  000a3	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  000aa	83 e8 0b	 sub	 eax, 11			; 0000000bH
  000ad	50		 push	 eax
  000ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  000b3	e8 00 00 00 00	 call	 ?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckBossKillSuccess
  000b8	84 c0		 test	 al, al

; 4748 : 			{
; 4749 : 				return FALSE;

  000ba	74 42		 je	 SHORT $LN9@gObjAttack
$LN5@gObjAttack:

; 4750 : 			}
; 4751 : 		}
; 4752 : 	}
; 4753 : 
; 4754 : 	if ( lpObj->Class != 247 && lpObj->Class != 249 && lpObj->Class  >= 100 && lpObj->Class <= 110 )

  000bc	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  000c3	b9 f7 00 00 00	 mov	 ecx, 247		; 000000f7H
  000c8	66 3b c1	 cmp	 ax, cx
  000cb	74 14		 je	 SHORT $LN4@gObjAttack
  000cd	ba f9 00 00 00	 mov	 edx, 249		; 000000f9H
  000d2	66 3b c2	 cmp	 ax, dx
  000d5	74 0a		 je	 SHORT $LN4@gObjAttack
  000d7	83 f8 64	 cmp	 eax, 100		; 00000064H
  000da	72 05		 jb	 SHORT $LN4@gObjAttack
  000dc	83 f8 6e	 cmp	 eax, 110		; 0000006eH

; 4755 : 	{
; 4756 : 		return FALSE;

  000df	76 1d		 jbe	 SHORT $LN9@gObjAttack
$LN4@gObjAttack:

; 4757 : 	}
; 4758 : 
; 4759 : 	if ( lpObj->m_State != 2 )

  000e1	83 be bc 01 00
	00 02		 cmp	 DWORD PTR [esi+444], 2

; 4760 : 	{
; 4761 : 		return FALSE;

  000e8	75 14		 jne	 SHORT $LN9@gObjAttack

; 4762 : 	}
; 4763 : 
; 4764 : 	if( lpObj->Live == false )
; 4765 : 	{
; 4766 : 		return false;

  000ea	33 c0		 xor	 eax, eax
  000ec	38 46 62	 cmp	 BYTE PTR [esi+98], al
  000ef	74 0f		 je	 SHORT $LN12@gObjAttack

; 4767 : 	}
; 4768 : 
; 4769 : 	if ( lpObj->Teleport == 1 )

  000f1	80 be 00 02 00
	00 01		 cmp	 BYTE PTR [esi+512], 1
  000f8	5e		 pop	 esi
  000f9	0f 95 c0	 setne	 al

; 4770 : 	{
; 4771 : 		return FALSE;
; 4772 : 	}
; 4773 : 
; 4774 : 	return TRUE;
; 4775 : }

  000fc	5d		 pop	 ebp
  000fd	c3		 ret	 0
$LN9@gObjAttack:

; 4714 : 	{
; 4715 : 		return FALSE;

  000fe	33 c0		 xor	 eax, eax
$LN12@gObjAttack:
  00100	5e		 pop	 esi

; 4770 : 	{
; 4771 : 		return FALSE;
; 4772 : 	}
; 4773 : 
; 4774 : 	return TRUE;
; 4775 : }

  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
?gObjAttackQ@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; gObjAttackQ
_TEXT	ENDS
PUBLIC	?gObjInterfaceTimeCheck@@YAXPAUOBJECTSTRUCT@@@Z	; gObjInterfaceTimeCheck
EXTRN	?GCResultSend@@YAXHEE@Z:PROC			; GCResultSend
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?CGTradeResult@@YAXHE@Z:PROC			; CGTradeResult
; Function compile flags: /Ogtp
;	COMDAT ?gObjInterfaceTimeCheck@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjInterfaceTimeCheck@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjInterfaceTimeCheck, COMDAT

; 5390 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5391 : 	int tObjNum;
; 5392 : 	BOOL TimeCheck = FALSE;
; 5393 : 
; 5394 : 	if ( lpObj->m_IfState.use == 0 )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	f6 86 84 0c 00
	00 03		 test	 BYTE PTR [esi+3204], 3
  0000e	0f 84 cc 00 00
	00		 je	 $LN1@gObjInterf

; 5395 : 	{
; 5396 : 		return;
; 5397 : 	}
; 5398 : 
; 5399 : 	if ( (GetTickCount() - lpObj->m_InterfaceTime) < 5000 )

  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0001a	2b 86 88 0c 00
	00		 sub	 eax, DWORD PTR [esi+3208]
  00020	3d 88 13 00 00	 cmp	 eax, 5000		; 00001388H
  00025	0f 82 b5 00 00
	00		 jb	 $LN1@gObjInterf

; 5400 : 	{
; 5401 : 		return;
; 5402 : 	}
; 5403 : 
; 5404 : 	if ( lpObj->m_IfState.state == 1 )

  0002b	8b 86 84 0c 00
	00		 mov	 eax, DWORD PTR [esi+3204]
  00031	8b c8		 mov	 ecx, eax
  00033	80 e1 3c	 and	 cl, 60			; 0000003cH
  00036	80 f9 04	 cmp	 cl, 4
  00039	0f 84 a1 00 00
	00		 je	 $LN1@gObjInterf

; 5405 : 	{
; 5406 : 		return;
; 5407 : 	}
; 5408 : 
; 5409 : 	tObjNum = lpObj->TargetNumber;

  0003f	57		 push	 edi
  00040	0f bf be d4 02
	00 00		 movsx	 edi, WORD PTR [esi+724]

; 5410 : 
; 5411 : 	if ( tObjNum < 0 )

  00047	85 ff		 test	 edi, edi
  00049	0f 88 90 00 00
	00		 js	 $LN12@gObjInterf

; 5412 : 	{
; 5413 : 		return;
; 5414 : 	}
; 5415 : 
; 5416 : 	if ( lpObj->m_IfState.type == 1 )

  0004f	c1 e8 06	 shr	 eax, 6
  00052	53		 push	 ebx
  00053	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00058	83 cb ff	 or	 ebx, -1
  0005b	83 f8 01	 cmp	 eax, 1
  0005e	75 2f		 jne	 SHORT $LN4@gObjInterf

; 5417 : 	{
; 5418 : 		CGTradeResult(lpObj->m_Index, 3);

  00060	8b 16		 mov	 edx, DWORD PTR [esi]
  00062	6a 03		 push	 3
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult

; 5419 : 		CGTradeResult(tObjNum, 3);

  0006a	6a 03		 push	 3
  0006c	57		 push	 edi
  0006d	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  00072	83 c4 10	 add	 esp, 16			; 00000010H

; 5420 : 
; 5421 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 114)), tObjNum, 1);

  00075	6a 01		 push	 1
  00077	57		 push	 edi
  00078	68 72 04 00 00	 push	 1138			; 00000472H
  0007d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00082	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 5422 : 		TimeCheck = TRUE;
; 5423 : 	}
; 5424 : 	else

  0008d	eb 23		 jmp	 SHORT $LN14@gObjInterf
$LN4@gObjInterf:

; 5425 : 	{
; 5426 : 		if ( lpObj->m_IfState.type == 2 )

  0008f	83 f8 02	 cmp	 eax, 2
  00092	75 4a		 jne	 SHORT $LN13@gObjInterf

; 5427 : 		{
; 5428 : 			lpObj->PartyTargetUser = -1;
; 5429 : 			gObj[tObjNum].PartyTargetUser = -1;

  00094	8b c7		 mov	 eax, edi
  00096	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 5430 : 			GCResultSend(tObjNum, 0x41, FALSE );

  0009c	6a 00		 push	 0
  0009e	6a 41		 push	 65			; 00000041H
  000a0	89 9e ac 02 00
	00		 mov	 DWORD PTR [esi+684], ebx
  000a6	57		 push	 edi
  000a7	89 98 ac 02 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+684], ebx
  000ad	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
$LN14@gObjInterf:

; 5431 : 			TimeCheck = TRUE;
; 5432 : 		}
; 5433 : 	}
; 5434 : 
; 5435 : 	if ( TimeCheck != FALSE )
; 5436 : 	{
; 5437 : 		lpObj->m_IfState.use = 0;
; 5438 : 		lpObj->TargetNumber = -1;
; 5439 : 		gObj[tObjNum].m_IfState.use = 0;

  000b2	8b c7		 mov	 eax, edi
  000b4	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000ba	b9 fc ff ff ff	 mov	 ecx, -4			; fffffffcH
  000bf	21 8e 84 0c 00
	00		 and	 DWORD PTR [esi+3204], ecx
  000c5	8b d3		 mov	 edx, ebx
  000c7	66 89 96 d4 02
	00 00		 mov	 WORD PTR [esi+724], dx
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d1	21 88 84 0c 00
	00		 and	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3204], ecx

; 5440 : 		gObj[tObjNum].TargetNumber = -1;

  000d7	66 89 98 d4 02
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+724], bx
$LN13@gObjInterf:
  000de	5b		 pop	 ebx
$LN12@gObjInterf:
  000df	5f		 pop	 edi
$LN1@gObjInterf:
  000e0	5e		 pop	 esi

; 5441 : 	}
; 5442 : 
; 5443 : }

  000e1	5d		 pop	 ebp
  000e2	c3		 ret	 0
?gObjInterfaceTimeCheck@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjInterfaceTimeCheck
_TEXT	ENDS
PUBLIC	?gObjPkDownTimeCheck@@YAXPAUOBJECTSTRUCT@@H@Z	; gObjPkDownTimeCheck
EXTRN	?GCPkLevelSend@@YAXHE@Z:PROC			; GCPkLevelSend
EXTRN	?gPkTime@@3HA:DWORD				; gPkTime
; Function compile flags: /Ogtp
;	COMDAT ?gObjPkDownTimeCheck@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_TargetLevel$ = 12					; size = 4
?gObjPkDownTimeCheck@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; gObjPkDownTimeCheck, COMDAT

; 5446 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5447 : 
; 5448 : 	if(lpObj->m_PK_Level == 3)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	80 be fd 00 00
	00 03		 cmp	 BYTE PTR [esi+253], 3
  0000e	0f 84 ab 01 00
	00		 je	 $LN1@gObjPkDown

; 5449 : 	{
; 5450 : 		return;
; 5451 : 	}
; 5452 : 
; 5453 : 	unsigned int dwtime = ((GetTickCount() - lpObj->m_dwPKTimer) / 1000) * gPkTime;

  00014	53		 push	 ebx
  00015	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  0001b	57		 push	 edi
  0001c	ff d3		 call	 ebx
  0001e	8b c8		 mov	 ecx, eax
  00020	2b 4e 54	 sub	 ecx, DWORD PTR [esi+84]
  00023	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00028	f7 e1		 mul	 ecx
  0002a	c1 ea 06	 shr	 edx, 6
  0002d	8b fa		 mov	 edi, edx
  0002f	0f af 3d 00 00
	00 00		 imul	 edi, DWORD PTR ?gPkTime@@3HA ; gPkTime

; 5454 : 
; 5455 : 	if(dwtime > 5)

  00036	83 ff 05	 cmp	 edi, 5
  00039	76 0c		 jbe	 SHORT $LN27@gObjPkDown

; 5456 : 	{
; 5457 : 		dwtime = 2;

  0003b	bf 02 00 00 00	 mov	 edi, 2

; 5458 : 		lpObj->m_dwPKTimer = GetTickCount();

  00040	ff d3		 call	 ebx
  00042	89 46 54	 mov	 DWORD PTR [esi+84], eax

; 5459 : 	}
; 5460 : 	else

  00045	eb 0b		 jmp	 SHORT $LN26@gObjPkDown
$LN27@gObjPkDown:

; 5461 : 	{
; 5462 : 		lpObj->m_dwPKTimer = dwtime * 1000;

  00047	8b d7		 mov	 edx, edi
  00049	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  0004f	89 56 54	 mov	 DWORD PTR [esi+84], edx
$LN26@gObjPkDown:

; 5463 : 	}
; 5464 : 
; 5465 : 	if(TargetLevel < 2)

  00052	8b 45 0c	 mov	 eax, DWORD PTR _TargetLevel$[ebp]
  00055	83 f8 02	 cmp	 eax, 2
  00058	7d 08		 jge	 SHORT $LN25@gObjPkDown

; 5466 : 	{
; 5467 : 		lpObj->m_PK_Time += dwtime;

  0005a	01 be 00 01 00
	00		 add	 DWORD PTR [esi+256], edi

; 5468 : 	}
; 5469 : 	else

  00060	eb 06		 jmp	 SHORT $LN24@gObjPkDown
$LN25@gObjPkDown:

; 5470 : 	{
; 5471 : 		lpObj->m_PK_Time += TargetLevel;

  00062	01 86 00 01 00
	00		 add	 DWORD PTR [esi+256], eax
$LN24@gObjPkDown:

; 5472 : 	}
; 5473 : 
; 5474 : 	if(lpObj->m_PK_Level < 3)

  00068	8a 86 fd 00 00
	00		 mov	 al, BYTE PTR [esi+253]
  0006e	3c 03		 cmp	 al, 3
  00070	7d 49		 jge	 SHORT $LN32@gObjPkDown

; 5475 : 	{
; 5476 : 		if(lpObj->m_PK_Time > 3600)

  00072	81 be 00 01 00
	00 10 0e 00 00	 cmp	 DWORD PTR [esi+256], 3600 ; 00000e10H
  0007c	0f 8e 3b 01 00
	00		 jle	 $LN31@gObjPkDown

; 5477 : 		{
; 5478 : 			lpObj->m_PK_Time = 0;
; 5479 : 			lpObj->m_PK_Count += 1;

  00082	fe 86 fc 00 00
	00		 inc	 BYTE PTR [esi+252]

; 5480 : 
; 5481 : 			if(lpObj->m_PK_Count > 100)

  00088	80 be fc 00 00
	00 64		 cmp	 BYTE PTR [esi+252], 100	; 00000064H
  0008f	c7 86 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+256], 0
  00099	7e 07		 jle	 SHORT $LN21@gObjPkDown

; 5482 : 			{
; 5483 : 				lpObj->m_PK_Count = 100;

  0009b	c6 86 fc 00 00
	00 64		 mov	 BYTE PTR [esi+252], 100	; 00000064H
$LN21@gObjPkDown:

; 5484 : 			}
; 5485 : 
; 5486 : 			lpObj->m_PK_Level += 1;

  000a2	fe c0		 inc	 al
  000a4	88 86 fd 00 00
	00		 mov	 BYTE PTR [esi+253], al

; 5487 : 
; 5488 : 			GCPkLevelSend(lpObj->m_Index,lpObj->m_PK_Level);

  000aa	50		 push	 eax
  000ab	8b 06		 mov	 eax, DWORD PTR [esi]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ?GCPkLevelSend@@YAXHE@Z	; GCPkLevelSend
  000b3	83 c4 08	 add	 esp, 8
  000b6	5f		 pop	 edi
  000b7	5b		 pop	 ebx
  000b8	5e		 pop	 esi

; 5552 : 			}
; 5553 : 		}
; 5554 : 	}
; 5555 : }

  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
$LN32@gObjPkDown:

; 5489 : 		}
; 5490 : 	}
; 5491 : 	else if(lpObj->m_PK_Level > 3)

  000bb	0f 8e fc 00 00
	00		 jle	 $LN31@gObjPkDown

; 5492 : 	{
; 5493 : 		if(lpObj->m_PK_Count > 3)

  000c1	8a 86 fc 00 00
	00		 mov	 al, BYTE PTR [esi+252]
  000c7	3c 03		 cmp	 al, 3
  000c9	7e 72		 jle	 SHORT $LN18@gObjPkDown

; 5494 : 		{
; 5495 : 			if(lpObj->m_PK_Time > 3600)

  000cb	81 be 00 01 00
	00 10 0e 00 00	 cmp	 DWORD PTR [esi+256], 3600 ; 00000e10H
  000d5	0f 8e e2 00 00
	00		 jle	 $LN31@gObjPkDown

; 5496 : 			{
; 5497 : 				lpObj->m_PK_Time = 0;

  000db	33 c9		 xor	 ecx, ecx

; 5498 : 				lpObj->m_PK_Count -= 1;

  000dd	fe c8		 dec	 al
  000df	89 8e 00 01 00
	00		 mov	 DWORD PTR [esi+256], ecx
  000e5	88 86 fc 00 00
	00		 mov	 BYTE PTR [esi+252], al

; 5499 : 
; 5500 : 				if(lpObj->m_PK_Count <= 0)

  000eb	b3 04		 mov	 bl, 4
  000ed	3a c1		 cmp	 al, cl
  000ef	7f 0b		 jg	 SHORT $LN16@gObjPkDown

; 5501 : 				{
; 5502 : 					lpObj->m_PK_Count = 0;

  000f1	66 c7 86 fc 00
	00 00 00 03	 mov	 WORD PTR [esi+252], 768	; 00000300H

; 5503 : 					lpObj->m_PK_Level = 3;

  000fa	eb 17		 jmp	 SHORT $LN12@gObjPkDown
$LN16@gObjPkDown:

; 5504 : 				}
; 5505 : 				else if(lpObj->m_PK_Count == 2)

  000fc	3c 02		 cmp	 al, 2
  000fe	75 09		 jne	 SHORT $LN14@gObjPkDown

; 5506 : 				{
; 5507 : 					lpObj->m_PK_Level = 5;

  00100	c6 86 fd 00 00
	00 05		 mov	 BYTE PTR [esi+253], 5
  00107	eb 0a		 jmp	 SHORT $LN12@gObjPkDown
$LN14@gObjPkDown:

; 5508 : 				}
; 5509 : 				else if(lpObj->m_PK_Count == 1)

  00109	3c 01		 cmp	 al, 1
  0010b	75 06		 jne	 SHORT $LN12@gObjPkDown

; 5510 : 				{
; 5511 : 					lpObj->m_PK_Level = 4;

  0010d	88 9e fd 00 00
	00		 mov	 BYTE PTR [esi+253], bl
$LN12@gObjPkDown:

; 5512 : 				}
; 5513 : 
; 5514 : 				if(lpObj->m_PK_Level <= 5)

  00113	0f b6 86 fd 00
	00 00		 movzx	 eax, BYTE PTR [esi+253]
  0011a	3c 05		 cmp	 al, 5
  0011c	7f 0c		 jg	 SHORT $LN11@gObjPkDown

; 5515 : 				{
; 5516 : 					GCPkLevelSend(lpObj->m_Index,lpObj->m_PK_Level);

  0011e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00120	50		 push	 eax
  00121	51		 push	 ecx
  00122	e8 00 00 00 00	 call	 ?GCPkLevelSend@@YAXHE@Z	; GCPkLevelSend
  00127	83 c4 08	 add	 esp, 8
$LN11@gObjPkDown:

; 5517 : 				}
; 5518 : 
; 5519 : 				if(lpObj->m_PK_Level == 4)

  0012a	38 9e fd 00 00
	00		 cmp	 BYTE PTR [esi+253], bl
  00130	0f 85 87 00 00
	00		 jne	 $LN31@gObjPkDown

; 5520 : 				{
; 5521 : 					GCServerMsgStringSend(lMsg.Get(1137),lpObj->m_Index,1);

  00136	8b 16		 mov	 edx, DWORD PTR [esi]
  00138	6a 01		 push	 1
  0013a	52		 push	 edx

; 5522 : 				}
; 5523 : 			}
; 5524 : 		}

  0013b	eb 68		 jmp	 SHORT $LN33@gObjPkDown
$LN18@gObjPkDown:

; 5525 : 		else if(lpObj->m_PK_Time > 10800)

  0013d	81 be 00 01 00
	00 30 2a 00 00	 cmp	 DWORD PTR [esi+256], 10800 ; 00002a30H
  00147	7e 74		 jle	 SHORT $LN31@gObjPkDown

; 5526 : 		{
; 5527 : 			lpObj->m_PK_Time = 0;

  00149	33 c9		 xor	 ecx, ecx

; 5528 : 			lpObj->m_PK_Count -= 1;

  0014b	fe c8		 dec	 al
  0014d	89 8e 00 01 00
	00		 mov	 DWORD PTR [esi+256], ecx
  00153	88 86 fc 00 00
	00		 mov	 BYTE PTR [esi+252], al

; 5529 : 
; 5530 : 			if(lpObj->m_PK_Count <= 0)

  00159	b3 04		 mov	 bl, 4
  0015b	3a c1		 cmp	 al, cl
  0015d	7f 0b		 jg	 SHORT $LN7@gObjPkDown

; 5531 : 			{
; 5532 : 				lpObj->m_PK_Count = 0;

  0015f	66 c7 86 fc 00
	00 00 00 03	 mov	 WORD PTR [esi+252], 768	; 00000300H

; 5533 : 				lpObj->m_PK_Level = 3;

  00168	eb 17		 jmp	 SHORT $LN3@gObjPkDown
$LN7@gObjPkDown:

; 5534 : 			}
; 5535 : 			else if(lpObj->m_PK_Count == 2)

  0016a	3c 02		 cmp	 al, 2
  0016c	75 09		 jne	 SHORT $LN5@gObjPkDown

; 5536 : 			{
; 5537 : 				lpObj->m_PK_Level = 5;

  0016e	c6 86 fd 00 00
	00 05		 mov	 BYTE PTR [esi+253], 5
  00175	eb 0a		 jmp	 SHORT $LN3@gObjPkDown
$LN5@gObjPkDown:

; 5538 : 			}
; 5539 : 			else if(lpObj->m_PK_Count == 1)

  00177	3c 01		 cmp	 al, 1
  00179	75 06		 jne	 SHORT $LN3@gObjPkDown

; 5540 : 			{
; 5541 : 				lpObj->m_PK_Level = 4;

  0017b	88 9e fd 00 00
	00		 mov	 BYTE PTR [esi+253], bl
$LN3@gObjPkDown:

; 5542 : 			}
; 5543 : 
; 5544 : 			if(lpObj->m_PK_Level <= 5)

  00181	0f b6 86 fd 00
	00 00		 movzx	 eax, BYTE PTR [esi+253]
  00188	3c 05		 cmp	 al, 5
  0018a	7f 0c		 jg	 SHORT $LN2@gObjPkDown

; 5545 : 			{
; 5546 : 				GCPkLevelSend(lpObj->m_Index,lpObj->m_PK_Level);

  0018c	50		 push	 eax
  0018d	8b 06		 mov	 eax, DWORD PTR [esi]
  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 ?GCPkLevelSend@@YAXHE@Z	; GCPkLevelSend
  00195	83 c4 08	 add	 esp, 8
$LN2@gObjPkDown:

; 5547 : 			}
; 5548 : 
; 5549 : 			if(lpObj->m_PK_Level == 4)

  00198	38 9e fd 00 00
	00		 cmp	 BYTE PTR [esi+253], bl
  0019e	75 1d		 jne	 SHORT $LN31@gObjPkDown

; 5550 : 			{
; 5551 : 				GCServerMsgStringSend(lMsg.Get(1137),lpObj->m_Index,1);

  001a0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001a2	6a 01		 push	 1
  001a4	51		 push	 ecx
$LN33@gObjPkDown:
  001a5	68 71 04 00 00	 push	 1137			; 00000471H
  001aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001af	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001b4	50		 push	 eax
  001b5	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001ba	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN31@gObjPkDown:
  001bd	5f		 pop	 edi
  001be	5b		 pop	 ebx
$LN1@gObjPkDown:
  001bf	5e		 pop	 esi

; 5552 : 			}
; 5553 : 		}
; 5554 : 	}
; 5555 : }

  001c0	5d		 pop	 ebp
  001c1	c3		 ret	 0
?gObjPkDownTimeCheck@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; gObjPkDownTimeCheck
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?gObjAngelSprite@@YAHPAUOBJECTSTRUCT@@@Z	; gObjAngelSprite
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjAngelSprite@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjAngelSprite@@YAHPAUOBJECTSTRUCT@@@Z PROC		; gObjAngelSprite, COMDAT

; 5558 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5559 : 	if ( lpObj->Type != OBJ_USER )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1

; 5560 : 	{
; 5561 : 		return FALSE;

  0000c	75 40		 jne	 SHORT $LN1@gObjAngelS

; 5562 : 	}
; 5563 : 
; 5564 : 	if ( lpObj->pInventory[8].IsItem() == FALSE )

  0000e	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00014	81 c1 40 05 00
	00		 add	 ecx, 1344		; 00000540H
  0001a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0001f	85 c0		 test	 eax, eax

; 5565 : 	{
; 5566 : 		return FALSE;

  00021	74 2b		 je	 SHORT $LN1@gObjAngelS

; 5567 : 	}
; 5568 : 
; 5569 : 	CItem * Angel = &lpObj->pInventory[8];

  00023	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]

; 5570 : 
; 5571 : 	if ( Angel->m_Type == ITEMGET(13,0) && Angel->m_Durability > 0.0f )

  00029	b9 00 1a 00 00	 mov	 ecx, 6656		; 00001a00H
  0002e	66 39 88 46 05
	00 00		 cmp	 WORD PTR [eax+1350], cx
  00035	75 17		 jne	 SHORT $LN1@gObjAngelS
  00037	d9 ee		 fldz
  00039	d8 98 64 05 00
	00		 fcomp	 DWORD PTR [eax+1380]
  0003f	df e0		 fnstsw	 ax
  00041	f6 c4 05	 test	 ah, 5
  00044	7a 08		 jp	 SHORT $LN1@gObjAngelS

; 5572 : 	{
; 5573 : 		return TRUE;

  00046	b8 01 00 00 00	 mov	 eax, 1
  0004b	5e		 pop	 esi

; 5577 : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN1@gObjAngelS:

; 5574 : 	}
; 5575 : 
; 5576 : 	return FALSE;

  0004e	33 c0		 xor	 eax, eax
  00050	5e		 pop	 esi

; 5577 : }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?gObjAngelSprite@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; gObjAngelSprite
_TEXT	ENDS
PUBLIC	?gObjSatanSprite@@YAHPAUOBJECTSTRUCT@@@Z	; gObjSatanSprite
; Function compile flags: /Ogtp
;	COMDAT ?gObjSatanSprite@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjSatanSprite@@YAHPAUOBJECTSTRUCT@@@Z PROC		; gObjSatanSprite, COMDAT

; 5585 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5586 : 	if ( lpObj->Type != OBJ_USER )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1

; 5587 : 	{
; 5588 : 		return FALSE;

  0000c	75 40		 jne	 SHORT $LN1@gObjSatanS

; 5589 : 	}
; 5590 : 
; 5591 : 	if ( lpObj->pInventory[8].IsItem() == FALSE )

  0000e	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00014	81 c1 40 05 00
	00		 add	 ecx, 1344		; 00000540H
  0001a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0001f	85 c0		 test	 eax, eax

; 5592 : 	{
; 5593 : 		return FALSE;

  00021	74 2b		 je	 SHORT $LN1@gObjSatanS

; 5594 : 	}
; 5595 : 
; 5596 : 	CItem * Satan = &lpObj->pInventory[8];

  00023	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]

; 5597 : 
; 5598 : 	if ( Satan->m_Type == ITEMGET(13,1) && Satan->m_Durability > 0.0f )

  00029	b9 01 1a 00 00	 mov	 ecx, 6657		; 00001a01H
  0002e	66 39 88 46 05
	00 00		 cmp	 WORD PTR [eax+1350], cx
  00035	75 17		 jne	 SHORT $LN1@gObjSatanS
  00037	d9 ee		 fldz
  00039	d8 98 64 05 00
	00		 fcomp	 DWORD PTR [eax+1380]
  0003f	df e0		 fnstsw	 ax
  00041	f6 c4 05	 test	 ah, 5
  00044	7a 08		 jp	 SHORT $LN1@gObjSatanS

; 5599 : 	{
; 5600 : 		return TRUE;

  00046	b8 01 00 00 00	 mov	 eax, 1
  0004b	5e		 pop	 esi

; 5604 : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN1@gObjSatanS:

; 5601 : 	}
; 5602 : 
; 5603 : 	return FALSE;

  0004e	33 c0		 xor	 eax, eax
  00050	5e		 pop	 esi

; 5604 : }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?gObjSatanSprite@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; gObjSatanSprite
_TEXT	ENDS
PUBLIC	?gObjWingSprite@@YAHPAUOBJECTSTRUCT@@@Z		; gObjWingSprite
; Function compile flags: /Ogtp
;	COMDAT ?gObjWingSprite@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjWingSprite@@YAHPAUOBJECTSTRUCT@@@Z PROC		; gObjWingSprite, COMDAT

; 5612 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5613 : 	if ( lpObj->Type != OBJ_USER )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1

; 5614 : 	{
; 5615 : 		return FALSE;

  0000c	75 76		 jne	 SHORT $LN1@gObjWingSp

; 5616 : 	}
; 5617 : 
; 5618 : 	if ( lpObj->pInventory[7].IsItem() == FALSE )

  0000e	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00014	81 c1 98 04 00
	00		 add	 ecx, 1176		; 00000498H
  0001a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0001f	85 c0		 test	 eax, eax

; 5619 : 	{
; 5620 : 		return FALSE;

  00021	74 61		 je	 SHORT $LN1@gObjWingSp

; 5621 : 	}
; 5622 : 
; 5623 : 	CItem * Wing = &lpObj->pInventory[7];

  00023	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]

; 5624 : 
; 5625 : 	if ( (Wing->m_Type >= ITEMGET(12,0) && Wing->m_Type <= ITEMGET(12,6)) || Wing->m_Type <= ITEMGET(13,30) || NEWWINGS(Wing->m_Type))

  00029	0f b7 88 9e 04
	00 00		 movzx	 ecx, WORD PTR [eax+1182]
  00030	ba 00 18 00 00	 mov	 edx, 6144		; 00001800H
  00035	66 3b ca	 cmp	 cx, dx
  00038	7c 0a		 jl	 SHORT $LN2@gObjWingSp
  0003a	ba 06 18 00 00	 mov	 edx, 6150		; 00001806H
  0003f	66 3b ca	 cmp	 cx, dx
  00042	7e 29		 jle	 SHORT $LN3@gObjWingSp
$LN2@gObjWingSp:
  00044	ba 1e 1a 00 00	 mov	 edx, 6686		; 00001a1eH
  00049	66 3b ca	 cmp	 cx, dx
  0004c	7e 1f		 jle	 SHORT $LN3@gObjWingSp
  0004e	ba 64 18 00 00	 mov	 edx, 6244		; 00001864H
  00053	66 3b ca	 cmp	 cx, dx
  00056	7c 2c		 jl	 SHORT $LN1@gObjWingSp
  00058	53		 push	 ebx
  00059	33 db		 xor	 ebx, ebx
  0005b	ba 7d 18 00 00	 mov	 edx, 6269		; 0000187dH
  00060	66 3b ca	 cmp	 cx, dx
  00063	0f 9e c3	 setle	 bl
  00066	8b cb		 mov	 ecx, ebx
  00068	5b		 pop	 ebx
  00069	85 c9		 test	 ecx, ecx
  0006b	74 17		 je	 SHORT $LN1@gObjWingSp
$LN3@gObjWingSp:

; 5626 : 	{
; 5627 : 		if ( Wing->m_Durability > 0.0f )

  0006d	d9 ee		 fldz
  0006f	d8 98 bc 04 00
	00		 fcomp	 DWORD PTR [eax+1212]
  00075	df e0		 fnstsw	 ax
  00077	f6 c4 05	 test	 ah, 5
  0007a	7a 08		 jp	 SHORT $LN1@gObjWingSp

; 5628 : 		{
; 5629 : 			return TRUE;

  0007c	b8 01 00 00 00	 mov	 eax, 1
  00081	5e		 pop	 esi

; 5634 : }

  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
$LN1@gObjWingSp:

; 5630 : 		}
; 5631 : 	}
; 5632 : 	
; 5633 : 	return FALSE;

  00084	33 c0		 xor	 eax, eax
  00086	5e		 pop	 esi

; 5634 : }

  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?gObjWingSprite@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; gObjWingSprite
_TEXT	ENDS
PUBLIC	?gObjUniriaSprite@@YAHPAUOBJECTSTRUCT@@@Z	; gObjUniriaSprite
; Function compile flags: /Ogtp
;	COMDAT ?gObjUniriaSprite@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjUniriaSprite@@YAHPAUOBJECTSTRUCT@@@Z PROC		; gObjUniriaSprite, COMDAT

; 5637 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5638 : 	if ( lpObj->pInventory[8].IsItem() == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0000d	81 c1 40 05 00
	00		 add	 ecx, 1344		; 00000540H
  00013	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00018	85 c0		 test	 eax, eax

; 5639 : 	{
; 5640 : 		return FALSE;

  0001a	74 2b		 je	 SHORT $LN1@gObjUniria

; 5641 : 	}
; 5642 : 
; 5643 : 	CItem * Uniria = &lpObj->pInventory[8];

  0001c	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]

; 5644 : 
; 5645 : 	if ( Uniria->m_Type == ITEMGET(13,2) && Uniria->m_Durability > 0.0f )

  00022	b9 02 1a 00 00	 mov	 ecx, 6658		; 00001a02H
  00027	66 39 88 46 05
	00 00		 cmp	 WORD PTR [eax+1350], cx
  0002e	75 17		 jne	 SHORT $LN1@gObjUniria
  00030	d9 ee		 fldz
  00032	d8 98 64 05 00
	00		 fcomp	 DWORD PTR [eax+1380]
  00038	df e0		 fnstsw	 ax
  0003a	f6 c4 05	 test	 ah, 5
  0003d	7a 08		 jp	 SHORT $LN1@gObjUniria

; 5646 : 	{
; 5647 : 		return TRUE;

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	5e		 pop	 esi

; 5651 : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN1@gObjUniria:

; 5648 : 	}
; 5649 : 
; 5650 : 	return FALSE;

  00047	33 c0		 xor	 eax, eax
  00049	5e		 pop	 esi

; 5651 : }

  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?gObjUniriaSprite@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; gObjUniriaSprite
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@3f947ae140000000
PUBLIC	?gObjChangeDurProc@@YAXPAUOBJECTSTRUCT@@@Z	; gObjChangeDurProc
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:BYTE		; gObjUseSkill
EXTRN	?GCItemDurSend@@YAXHEEE@Z:PROC			; GCItemDurSend
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f947ae140000000
CONST	SEGMENT
__real@3f947ae140000000 DQ 03f947ae140000000r	; 0.02
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjChangeDurProc@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv523 = -4						; size = 4
tv521 = -4						; size = 4
tv489 = -4						; size = 4
tv487 = -4						; size = 4
tv455 = -4						; size = 4
tv453 = -4						; size = 4
tv328 = -4						; size = 4
tv70 = -4						; size = 4
_dur$163755 = 8						; size = 1
_dur$163746 = 8						; size = 1
_dur$163728 = 8						; size = 1
_lpObj$ = 8						; size = 4
tv527 = 10						; size = 2
tv492 = 10						; size = 2
tv458 = 10						; size = 2
tv332 = 10						; size = 2
?gObjChangeDurProc@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjChangeDurProc, COMDAT

; 5980 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 5981 : 	if(lpObj->pInventory[10].IsItem() == 1 && lpObj->pInventory[10].m_Type == ITEMGET(13,10))

  00006	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00009	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0000f	57		 push	 edi
  00010	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
  00016	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0001b	83 f8 01	 cmp	 eax, 1
  0001e	0f 85 26 01 00
	00		 jne	 $LN19@gObjChange
  00024	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0002a	b9 0a 1a 00 00	 mov	 ecx, 6666		; 00001a0aH
  0002f	66 39 88 96 06
	00 00		 cmp	 WORD PTR [eax+1686], cx
  00036	0f 85 0e 01 00
	00		 jne	 $LN19@gObjChange

; 5982 : 	{
; 5983 : 		int m_Durability = lpObj->pInventory[10].m_Durability;

  0003c	8b f8		 mov	 edi, eax
  0003e	d9 87 b4 06 00
	00		 fld	 DWORD PTR [edi+1716]
  00044	e8 00 00 00 00	 call	 __ftol2_sse

; 5984 : 
; 5985 : 		lpObj->pInventory[10].m_Durability -= (float)0.02;

  00049	d9 87 b4 06 00
	00		 fld	 DWORD PTR [edi+1716]
  0004f	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3f947ae140000000
  00055	8b d8		 mov	 ebx, eax
  00057	d9 9f b4 06 00
	00		 fstp	 DWORD PTR [edi+1716]

; 5986 : 
; 5987 : 		if(m_Durability > (int)lpObj->pInventory[10].m_Durability)

  0005d	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00063	d9 82 b4 06 00
	00		 fld	 DWORD PTR [edx+1716]
  00069	e8 00 00 00 00	 call	 __ftol2_sse
  0006e	3b d8		 cmp	 ebx, eax
  00070	0f 8e 94 03 00
	00		 jle	 $LN1@gObjChange

; 5988 : 		{
; 5989 : 			if(lpObj->pInventory[10].m_Durability < 1)

  00076	d9 e8		 fld1
  00078	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0007e	d8 99 b4 06 00
	00		 fcomp	 DWORD PTR [ecx+1716]
  00084	df e0		 fnstsw	 ax
  00086	f6 c4 41	 test	 ah, 65			; 00000041H
  00089	75 08		 jne	 SHORT $LN17@gObjChange

; 5990 : 			{
; 5991 : 				lpObj->pInventory[10].m_Durability = 0;

  0008b	d9 ee		 fldz
  0008d	d9 99 b4 06 00
	00		 fstp	 DWORD PTR [ecx+1716]
$LN17@gObjChange:

; 5992 : 			}
; 5993 : 
; 5994 : 			BYTE dur = lpObj->pInventory[10].m_Durability;

  00093	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00099	d9 7d 0a	 fnstcw	 WORD PTR tv527[ebp]
  0009c	d9 80 b4 06 00
	00		 fld	 DWORD PTR [eax+1716]

; 5995 : 
; 5996 : 			GCItemDurSend(lpObj->m_Index,10,dur,0);

  000a2	8b 16		 mov	 edx, DWORD PTR [esi]
  000a4	0f b7 45 0a	 movzx	 eax, WORD PTR tv527[ebp]
  000a8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000ad	89 45 fc	 mov	 DWORD PTR tv523[ebp], eax
  000b0	6a 00		 push	 0
  000b2	d9 6d fc	 fldcw	 WORD PTR tv523[ebp]
  000b5	db 5d fc	 fistp	 DWORD PTR tv521[ebp]
  000b8	8a 5d fc	 mov	 bl, BYTE PTR tv521[ebp]
  000bb	88 5d 08	 mov	 BYTE PTR _dur$163728[ebp], bl
  000be	8b 4d 08	 mov	 ecx, DWORD PTR _dur$163728[ebp]
  000c1	d9 6d 0a	 fldcw	 WORD PTR tv527[ebp]
  000c4	51		 push	 ecx
  000c5	6a 0a		 push	 10			; 0000000aH
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  000cd	83 c4 10	 add	 esp, 16			; 00000010H

; 5997 : 
; 5998 : 			if(dur == 0)

  000d0	84 db		 test	 bl, bl
  000d2	0f 85 32 03 00
	00		 jne	 $LN1@gObjChange

; 5999 : 			{
; 6000 : 				gObjUseSkill.SkillChangeUse(lpObj->m_Index);

  000d8	8b 06		 mov	 eax, DWORD PTR [esi]
  000da	50		 push	 eax
$LN26@gObjChange:
  000db	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000e0	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 6001 : 				LogAdd(LOG_BLACK, lMsg.Get(544),lpObj->AccountID,lpObj->Name,lpObj->pInventory[10].GetName(),lpObj->pInventory[10].m_Level,dur);

  000e5	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  000eb	0f bf 88 98 06
	00 00		 movsx	 ecx, WORD PTR [eax+1688]
  000f2	6a 00		 push	 0
  000f4	51		 push	 ecx
  000f5	8d 88 90 06 00
	00		 lea	 ecx, DWORD PTR [eax+1680]
  000fb	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00100	50		 push	 eax
  00101	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  00104	52		 push	 edx
  00105	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  00108	50		 push	 eax
  00109	68 20 02 00 00	 push	 544			; 00000220H
  0010e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00113	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00118	50		 push	 eax
  00119	6a 00		 push	 0
  0011b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 6002 : 				lpObj->pInventory[10].Clear();

  00120	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00126	83 c4 1c	 add	 esp, 28			; 0000001cH
  00129	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
  0012f	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 6081 : 				GCInventoryItemDeleteSend(lpObj->m_Index,11,0);

  00134	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00136	6a 00		 push	 0
  00138	6a 0a		 push	 10			; 0000000aH
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH
  00143	5f		 pop	 edi
  00144	5e		 pop	 esi
  00145	5b		 pop	 ebx

; 6082 : 			}
; 6083 : 		}
; 6084 : 	}
; 6085 : }

  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c3		 ret	 0
$LN19@gObjChange:

; 6003 : 				GCInventoryItemDeleteSend(lpObj->m_Index,10,0);
; 6004 : 			}
; 6005 : 		}
; 6006 : 	}
; 6007 : 	else if(lpObj->pInventory[11].IsItem() == 1 && lpObj->pInventory[11].m_Type == ITEMGET(13,10))

  0014a	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00150	81 c1 38 07 00
	00		 add	 ecx, 1848		; 00000738H
  00156	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0015b	83 f8 01	 cmp	 eax, 1
  0015e	0f 85 9b 00 00
	00		 jne	 $LN14@gObjChange
  00164	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  0016a	b8 0a 1a 00 00	 mov	 eax, 6666		; 00001a0aH
  0016f	66 39 82 3e 07
	00 00		 cmp	 WORD PTR [edx+1854], ax
  00176	0f 85 83 00 00
	00		 jne	 $LN14@gObjChange

; 6008 : 	{
; 6009 : 		int m_Durability = lpObj->pInventory[11].m_Durability;

  0017c	8b fa		 mov	 edi, edx
  0017e	d9 87 5c 07 00
	00		 fld	 DWORD PTR [edi+1884]
  00184	e8 00 00 00 00	 call	 __ftol2_sse

; 6010 : 
; 6011 : 		lpObj->pInventory[11].m_Durability -= (float)0.02;

  00189	d9 87 5c 07 00
	00		 fld	 DWORD PTR [edi+1884]
  0018f	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3f947ae140000000
  00195	8b d8		 mov	 ebx, eax
  00197	d9 9f 5c 07 00
	00		 fstp	 DWORD PTR [edi+1884]

; 6012 : 
; 6013 : 		if(m_Durability > (int)lpObj->pInventory[11].m_Durability)

  0019d	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  001a3	d9 81 5c 07 00
	00		 fld	 DWORD PTR [ecx+1884]
  001a9	e8 00 00 00 00	 call	 __ftol2_sse
  001ae	3b d8		 cmp	 ebx, eax
  001b0	0f 8e 54 02 00
	00		 jle	 $LN1@gObjChange

; 6014 : 		{
; 6015 : 			if(lpObj->pInventory[11].m_Durability < 1)

  001b6	d9 e8		 fld1
  001b8	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  001be	d8 99 5c 07 00
	00		 fcomp	 DWORD PTR [ecx+1884]
  001c4	df e0		 fnstsw	 ax
  001c6	f6 c4 41	 test	 ah, 65			; 00000041H
  001c9	75 08		 jne	 SHORT $LN12@gObjChange

; 6016 : 			{
; 6017 : 				lpObj->pInventory[11].m_Durability = 0;

  001cb	d9 ee		 fldz
  001cd	d9 99 5c 07 00
	00		 fstp	 DWORD PTR [ecx+1884]
$LN12@gObjChange:

; 6018 : 			}
; 6019 : 
; 6020 : 			BYTE dur = lpObj->pInventory[11].m_Durability;

  001d3	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  001d9	d9 7d 0a	 fnstcw	 WORD PTR tv492[ebp]
  001dc	0f b7 45 0a	 movzx	 eax, WORD PTR tv492[ebp]
  001e0	d9 82 5c 07 00
	00		 fld	 DWORD PTR [edx+1884]
  001e6	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  001eb	89 45 fc	 mov	 DWORD PTR tv489[ebp], eax
  001ee	d9 6d fc	 fldcw	 WORD PTR tv489[ebp]
  001f1	db 5d fc	 fistp	 DWORD PTR tv487[ebp]
  001f4	8a 5d fc	 mov	 bl, BYTE PTR tv487[ebp]
  001f7	d9 6d 0a	 fldcw	 WORD PTR tv492[ebp]

; 6021 : 
; 6022 : 			GCItemDurSend(lpObj->m_Index,11,dur,0);
; 6023 : 
; 6024 : 			if(dur == 0)
; 6025 : 			{
; 6026 : 				gObjUseSkill.SkillChangeUse(lpObj->m_Index);
; 6027 : 				LogAdd(LOG_BLACK, lMsg.Get(544),lpObj->AccountID,lpObj->Name,lpObj->pInventory[10].GetName(),lpObj->pInventory[11].m_Level,dur);
; 6028 : 				lpObj->pInventory[11].Clear();
; 6029 : 				GCInventoryItemDeleteSend(lpObj->m_Index,11,0);
; 6030 : 			}
; 6031 : 		}
; 6032 : 	}

  001fa	e9 86 01 00 00	 jmp	 $LN25@gObjChange
$LN14@gObjChange:

; 6033 : 	else if(lpObj->pInventory[10].IsItem() == 1 && lpObj->pInventory[10].m_Type == ITEMGET(13,39))

  001ff	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00205	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
  0020b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00210	83 f8 01	 cmp	 eax, 1
  00213	0f 85 bc 00 00
	00		 jne	 $LN9@gObjChange
  00219	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  0021f	b8 27 1a 00 00	 mov	 eax, 6695		; 00001a27H
  00224	66 39 82 96 06
	00 00		 cmp	 WORD PTR [edx+1686], ax
  0022b	0f 85 a4 00 00
	00		 jne	 $LN9@gObjChange

; 6034 : 	{
; 6035 : 		int m_Durability = lpObj->pInventory[10].m_Durability;

  00231	8b fa		 mov	 edi, edx
  00233	d9 87 b4 06 00
	00		 fld	 DWORD PTR [edi+1716]
  00239	e8 00 00 00 00	 call	 __ftol2_sse

; 6036 : 
; 6037 : 		lpObj->pInventory[10].m_Durability -= (float)0.02;

  0023e	d9 87 b4 06 00
	00		 fld	 DWORD PTR [edi+1716]
  00244	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3f947ae140000000
  0024a	8b d8		 mov	 ebx, eax
  0024c	d9 9f b4 06 00
	00		 fstp	 DWORD PTR [edi+1716]

; 6038 : 
; 6039 : 		if(m_Durability > (int)lpObj->pInventory[10].m_Durability)

  00252	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00258	d9 81 b4 06 00
	00		 fld	 DWORD PTR [ecx+1716]
  0025e	e8 00 00 00 00	 call	 __ftol2_sse
  00263	3b d8		 cmp	 ebx, eax
  00265	0f 8e 9f 01 00
	00		 jle	 $LN1@gObjChange

; 6040 : 		{
; 6041 : 			if(lpObj->pInventory[10].m_Durability < 1)

  0026b	d9 e8		 fld1
  0026d	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00273	d8 99 b4 06 00
	00		 fcomp	 DWORD PTR [ecx+1716]
  00279	df e0		 fnstsw	 ax
  0027b	f6 c4 41	 test	 ah, 65			; 00000041H
  0027e	75 08		 jne	 SHORT $LN7@gObjChange

; 6042 : 			{
; 6043 : 				lpObj->pInventory[10].m_Durability = 0;

  00280	d9 ee		 fldz
  00282	d9 99 b4 06 00
	00		 fstp	 DWORD PTR [ecx+1716]
$LN7@gObjChange:

; 6044 : 			}
; 6045 : 
; 6046 : 			BYTE dur = lpObj->pInventory[10].m_Durability;

  00288	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  0028e	d9 7d 0a	 fnstcw	 WORD PTR tv458[ebp]
  00291	0f b7 45 0a	 movzx	 eax, WORD PTR tv458[ebp]
  00295	d9 82 b4 06 00
	00		 fld	 DWORD PTR [edx+1716]

; 6047 : 
; 6048 : 			GCItemDurSend(lpObj->m_Index,10,dur,0);

  0029b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0029d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002a2	89 45 fc	 mov	 DWORD PTR tv455[ebp], eax
  002a5	6a 00		 push	 0
  002a7	d9 6d fc	 fldcw	 WORD PTR tv455[ebp]
  002aa	db 5d fc	 fistp	 DWORD PTR tv453[ebp]
  002ad	8a 5d fc	 mov	 bl, BYTE PTR tv453[ebp]
  002b0	88 5d 08	 mov	 BYTE PTR _dur$163746[ebp], bl
  002b3	8b 45 08	 mov	 eax, DWORD PTR _dur$163746[ebp]
  002b6	d9 6d 0a	 fldcw	 WORD PTR tv458[ebp]
  002b9	50		 push	 eax
  002ba	6a 0a		 push	 10			; 0000000aH
  002bc	51		 push	 ecx
  002bd	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  002c2	83 c4 10	 add	 esp, 16			; 00000010H

; 6049 : 
; 6050 : 			if(dur == 0)

  002c5	84 db		 test	 bl, bl
  002c7	0f 85 3d 01 00
	00		 jne	 $LN1@gObjChange

; 6051 : 			{
; 6052 : 				gObjUseSkill.SkillChangeUse(lpObj->m_Index);

  002cd	8b 16		 mov	 edx, DWORD PTR [esi]
  002cf	52		 push	 edx

; 6053 : 				LogAdd(LOG_BLACK, lMsg.Get(544),lpObj->AccountID,lpObj->Name,lpObj->pInventory[10].GetName(),lpObj->pInventory[10].m_Level,dur);
; 6054 : 				lpObj->pInventory[10].Clear();
; 6055 : 				GCInventoryItemDeleteSend(lpObj->m_Index,10,0);
; 6056 : 			}
; 6057 : 		}
; 6058 : 	}

  002d0	e9 06 fe ff ff	 jmp	 $LN26@gObjChange
$LN9@gObjChange:

; 6059 : 	else if(lpObj->pInventory[11].IsItem() == 1 && lpObj->pInventory[11].m_Type == ITEMGET(13,39))

  002d5	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  002db	81 c1 38 07 00
	00		 add	 ecx, 1848		; 00000738H
  002e1	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002e6	83 f8 01	 cmp	 eax, 1
  002e9	0f 85 1b 01 00
	00		 jne	 $LN1@gObjChange
  002ef	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  002f5	b8 27 1a 00 00	 mov	 eax, 6695		; 00001a27H
  002fa	66 39 82 3e 07
	00 00		 cmp	 WORD PTR [edx+1854], ax
  00301	0f 85 03 01 00
	00		 jne	 $LN1@gObjChange

; 6060 : 	{
; 6061 : 		int m_Durability = lpObj->pInventory[11].m_Durability;

  00307	8b fa		 mov	 edi, edx
  00309	d9 87 5c 07 00
	00		 fld	 DWORD PTR [edi+1884]
  0030f	e8 00 00 00 00	 call	 __ftol2_sse

; 6062 : 
; 6063 : 		lpObj->pInventory[11].m_Durability -= (float)0.02;

  00314	d9 87 5c 07 00
	00		 fld	 DWORD PTR [edi+1884]
  0031a	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3f947ae140000000
  00320	8b d8		 mov	 ebx, eax
  00322	d9 9f 5c 07 00
	00		 fstp	 DWORD PTR [edi+1884]

; 6064 : 
; 6065 : 		if(m_Durability > (int)lpObj->pInventory[11].m_Durability)

  00328	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0032e	d9 81 5c 07 00
	00		 fld	 DWORD PTR [ecx+1884]
  00334	e8 00 00 00 00	 call	 __ftol2_sse
  00339	3b d8		 cmp	 ebx, eax
  0033b	0f 8e c9 00 00
	00		 jle	 $LN1@gObjChange

; 6066 : 		{
; 6067 : 			if(lpObj->pInventory[11].m_Durability < 1)

  00341	d9 e8		 fld1
  00343	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00349	d8 99 5c 07 00
	00		 fcomp	 DWORD PTR [ecx+1884]
  0034f	df e0		 fnstsw	 ax
  00351	f6 c4 41	 test	 ah, 65			; 00000041H
  00354	75 08		 jne	 SHORT $LN2@gObjChange

; 6068 : 			{
; 6069 : 				lpObj->pInventory[11].m_Durability = 0;

  00356	d9 ee		 fldz
  00358	d9 99 5c 07 00
	00		 fstp	 DWORD PTR [ecx+1884]
$LN2@gObjChange:

; 6070 : 			}
; 6071 : 
; 6072 : 			BYTE dur = lpObj->pInventory[11].m_Durability;

  0035e	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00364	d9 7d 0a	 fnstcw	 WORD PTR tv332[ebp]
  00367	0f b7 45 0a	 movzx	 eax, WORD PTR tv332[ebp]
  0036b	d9 82 5c 07 00
	00		 fld	 DWORD PTR [edx+1884]
  00371	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00376	89 45 fc	 mov	 DWORD PTR tv328[ebp], eax
  00379	d9 6d fc	 fldcw	 WORD PTR tv328[ebp]
  0037c	db 5d fc	 fistp	 DWORD PTR tv70[ebp]
  0037f	8a 5d fc	 mov	 bl, BYTE PTR tv70[ebp]
  00382	d9 6d 0a	 fldcw	 WORD PTR tv332[ebp]
$LN25@gObjChange:

; 6073 : 
; 6074 : 			GCItemDurSend(lpObj->m_Index,11,dur,0);

  00385	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00387	88 5d 08	 mov	 BYTE PTR _dur$163755[ebp], bl
  0038a	8b 45 08	 mov	 eax, DWORD PTR _dur$163755[ebp]
  0038d	6a 00		 push	 0
  0038f	50		 push	 eax
  00390	6a 0b		 push	 11			; 0000000bH
  00392	51		 push	 ecx
  00393	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00398	83 c4 10	 add	 esp, 16			; 00000010H

; 6075 : 
; 6076 : 			if(dur == 0)

  0039b	84 db		 test	 bl, bl
  0039d	75 6b		 jne	 SHORT $LN1@gObjChange

; 6077 : 			{
; 6078 : 				gObjUseSkill.SkillChangeUse(lpObj->m_Index);

  0039f	8b 16		 mov	 edx, DWORD PTR [esi]
  003a1	52		 push	 edx
  003a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  003a7	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 6079 : 				LogAdd(LOG_BLACK, lMsg.Get(544),lpObj->AccountID,lpObj->Name,lpObj->pInventory[10].GetName(),lpObj->pInventory[11].m_Level,dur);

  003ac	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  003b2	0f bf 88 40 07
	00 00		 movsx	 ecx, WORD PTR [eax+1856]
  003b9	6a 00		 push	 0
  003bb	51		 push	 ecx
  003bc	8d 88 90 06 00
	00		 lea	 ecx, DWORD PTR [eax+1680]
  003c2	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  003c7	50		 push	 eax
  003c8	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  003cb	52		 push	 edx
  003cc	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  003cf	50		 push	 eax
  003d0	68 20 02 00 00	 push	 544			; 00000220H
  003d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003da	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003df	50		 push	 eax
  003e0	6a 00		 push	 0
  003e2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 6080 : 				lpObj->pInventory[11].Clear();

  003e7	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  003ed	83 c4 1c	 add	 esp, 28			; 0000001cH
  003f0	81 c1 38 07 00
	00		 add	 ecx, 1848		; 00000738H
  003f6	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 6081 : 				GCInventoryItemDeleteSend(lpObj->m_Index,11,0);

  003fb	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003fd	6a 00		 push	 0
  003ff	6a 0b		 push	 11			; 0000000bH
  00401	51		 push	 ecx
  00402	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00407	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjChange:
  0040a	5f		 pop	 edi
  0040b	5e		 pop	 esi
  0040c	5b		 pop	 ebx

; 6082 : 			}
; 6083 : 		}
; 6084 : 	}
; 6085 : }

  0040d	8b e5		 mov	 esp, ebp
  0040f	5d		 pop	 ebp
  00410	c3		 ret	 0
?gObjChangeDurProc@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjChangeDurProc
_TEXT	ENDS
PUBLIC	?gObjWingDurProc@@YAXPAUOBJECTSTRUCT@@@Z	; gObjWingDurProc
; Function compile flags: /Ogtp
;	COMDAT ?gObjWingDurProc@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjWingDurProc@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjWingDurProc, COMDAT

; 6094 : 	BYTE send_dur=0; // HERE GOES A MACRO
; 6095 : 	{
; 6096 : 		int dur;
; 6097 : 	}
; 6098 : }

  00000	c3		 ret	 0
?gObjWingDurProc@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjWingDurProc
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjPenaltyDurDown@@YAXPAUOBJECTSTRUCT@@0@Z	; gObjPenaltyDurDown
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?GCItemDurSend2@@YAXHEEE@Z:PROC			; GCItemDurSend2
EXTRN	?DurabilityDown2@CItem@@QAEHHH@Z:PROC		; CItem::DurabilityDown2
; Function compile flags: /Ogtp
;	COMDAT ?gObjPenaltyDurDown@@YAXPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_reCalCharacter$ = -52					; size = 4
tv336 = -48						; size = 4
tv306 = -48						; size = 4
tv304 = -48						; size = 4
tv290 = -48						; size = 4
tv293 = -44						; size = 4
_ret$ = -44						; size = 4
tv279 = -40						; size = 4
tv277 = -40						; size = 4
tv265 = -40						; size = 4
tv259 = -40						; size = 4
tv203 = -40						; size = 4
tv71 = -40						; size = 4
tv309 = -34						; size = 2
tv282 = -34						; size = 2
tv268 = -34						; size = 2
tv215 = -34						; size = 2
_item_num$ = -32					; size = 28
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjPenaltyDurDown@@YAXPAUOBJECTSTRUCT@@0@Z PROC	; gObjPenaltyDurDown, COMDAT

; 6106 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _lpTargetObj$[ebp]
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00018	57		 push	 edi

; 6107 : 	int ret = 0;
; 6108 : 	int reCalCharacter = 0;

  00019	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 0

; 6109 : 
; 6110 : 	int irand = rand()%2;

  00020	e8 00 00 00 00	 call	 _rand
  00025	8b f8		 mov	 edi, eax
  00027	81 e7 01 00 00
	80		 and	 edi, -2147483647	; 80000001H
  0002d	79 05		 jns	 SHORT $LN35@gObjPenalt
  0002f	4f		 dec	 edi
  00030	83 cf fe	 or	 edi, -2			; fffffffeH
  00033	47		 inc	 edi
$LN35@gObjPenalt:

; 6111 : 
; 6112 : 	CItem * Weapon = &lpObj->pInventory[irand];

  00034	8b c7		 mov	 eax, edi
  00036	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  0003c	89 45 d0	 mov	 DWORD PTR tv290[ebp], eax
  0003f	03 86 8c 0c 00
	00		 add	 eax, DWORD PTR [esi+3212]

; 6113 : 	int decdur = 1;

  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	89 45 d4	 mov	 DWORD PTR tv293[ebp], eax

; 6114 : 
; 6115 : 	switch(lpObj->Class)

  0004d	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00054	83 f8 04	 cmp	 eax, 4
  00057	77 61		 ja	 SHORT $LN32@gObjPenalt
  00059	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN40@gObjPenalt[eax*4]
$LN24@gObjPenalt:

; 6116 : 	{
; 6117 : 	case 0:
; 6118 : 		decdur = lpObj->Level - (lpTargetObj->Level * 38) / 20;

  00060	0f bf 8b 9c 00
	00 00		 movsx	 ecx, WORD PTR [ebx+156]
  00067	6b c9 26	 imul	 ecx, 38			; 00000026H

; 6119 : 		break;
; 6120 : 	case 1:
; 6121 : 		decdur = lpObj->Level - (lpTargetObj->Level * 37) / 20;
; 6122 : 		break;

  0006a	eb 0e		 jmp	 SHORT $LN36@gObjPenalt
$LN22@gObjPenalt:

; 6123 : 	case 2:
; 6124 : 		decdur = lpObj->Level - (lpTargetObj->Level * 36) / 20;

  0006c	0f bf 8b 9c 00
	00 00		 movsx	 ecx, WORD PTR [ebx+156]
  00073	8d 0c c9	 lea	 ecx, DWORD PTR [ecx+ecx*8]
  00076	03 c9		 add	 ecx, ecx
  00078	03 c9		 add	 ecx, ecx
$LN36@gObjPenalt:
  0007a	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0007f	f7 e9		 imul	 ecx
  00081	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR [esi+156]
  00088	c1 fa 03	 sar	 edx, 3
  0008b	8b c2		 mov	 eax, edx
  0008d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00090	03 c2		 add	 eax, edx
  00092	2b c8		 sub	 ecx, eax

; 6125 : 		break;

  00094	eb 24		 jmp	 SHORT $LN32@gObjPenalt
$LN21@gObjPenalt:

; 6126 : 	case 3:
; 6127 : 	case 4:
; 6128 : 		decdur = lpObj->Level - (lpTargetObj->Level * 37) / 20;

  00096	0f bf 8b 9c 00
	00 00		 movsx	 ecx, WORD PTR [ebx+156]
  0009d	6b c9 25	 imul	 ecx, 37			; 00000025H
  000a0	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  000a5	f7 e9		 imul	 ecx
  000a7	c1 fa 03	 sar	 edx, 3
  000aa	8b ca		 mov	 ecx, edx
  000ac	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000af	03 d1		 add	 edx, ecx
  000b1	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR [esi+156]
  000b8	2b ca		 sub	 ecx, edx
$LN32@gObjPenalt:

; 6129 : 		break;
; 6130 : 	default : break;
; 6131 : 	}
; 6132 : 
; 6133 : 	decdur /= 10;

  000ba	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  000bf	f7 e9		 imul	 ecx

; 6134 : 
; 6135 : 	if(Weapon->m_Type != ITEMGET(4,7) && Weapon->m_Type != ITEMGET(4,15))

  000c1	8b 4d d4	 mov	 ecx, DWORD PTR tv293[ebp]
  000c4	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  000c8	c1 fa 02	 sar	 edx, 2
  000cb	8b da		 mov	 ebx, edx
  000cd	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  000d0	03 da		 add	 ebx, edx
  000d2	ba 07 08 00 00	 mov	 edx, 2055		; 00000807H
  000d7	66 3b c2	 cmp	 ax, dx
  000da	0f 84 93 00 00
	00		 je	 $LN30@gObjPenalt
  000e0	ba 0f 08 00 00	 mov	 edx, 2063		; 0000080fH
  000e5	66 3b c2	 cmp	 ax, dx
  000e8	0f 84 85 00 00
	00		 je	 $LN30@gObjPenalt

; 6136 : 	{
; 6137 : 		if(Weapon->m_Type < ITEMGET(6,0) && Weapon->m_Type >= ITEMGET(7,0) )

  000ee	ba 00 0c 00 00	 mov	 edx, 3072		; 00000c00H
  000f3	66 3b c2	 cmp	 ax, dx
  000f6	7d 18		 jge	 SHORT $LN18@gObjPenalt
  000f8	ba 00 0e 00 00	 mov	 edx, 3584		; 00000e00H
  000fd	66 3b c2	 cmp	 ax, dx
  00100	7c 0e		 jl	 SHORT $LN18@gObjPenalt

; 6138 : 		{
; 6139 : 			if ( Weapon->IsItem() )

  00102	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00107	85 c0		 test	 eax, eax
  00109	74 68		 je	 SHORT $LN30@gObjPenalt

; 6140 : 			{
; 6141 : 				ret = Weapon->DurabilityDown2(decdur,lpObj->m_Index);

  0010b	8b 06		 mov	 eax, DWORD PTR [esi]
  0010d	50		 push	 eax

; 6142 : 			}
; 6143 : 		}
; 6144 : 		else

  0010e	eb 0c		 jmp	 SHORT $LN37@gObjPenalt
$LN18@gObjPenalt:

; 6145 : 		{
; 6146 : 			CItem * Weapon = &lpObj->pInventory[irand];
; 6147 : 
; 6148 : 			if(Weapon->IsItem())

  00110	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00115	85 c0		 test	 eax, eax
  00117	74 5a		 je	 SHORT $LN30@gObjPenalt

; 6149 : 			{
; 6150 : 				ret = Weapon->DurabilityDown2(decdur,lpObj->m_Index);

  00119	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0011b	51		 push	 ecx
$LN37@gObjPenalt:
  0011c	8b 4d d4	 mov	 ecx, DWORD PTR tv293[ebp]
  0011f	53		 push	 ebx
  00120	e8 00 00 00 00	 call	 ?DurabilityDown2@CItem@@QAEHHH@Z ; CItem::DurabilityDown2
  00125	89 45 d4	 mov	 DWORD PTR _ret$[ebp], eax

; 6151 : 			}
; 6152 : 		}
; 6153 : 	}
; 6154 : 
; 6155 : 	if(ret != 0)

  00128	85 c0		 test	 eax, eax
  0012a	74 3a		 je	 SHORT $LN14@gObjPenalt

; 6156 : 	{
; 6157 : 		GCItemDurSend2(lpObj->m_Index,irand,lpObj->pInventory[irand].m_Durability,0);

  0012c	8b 45 d0	 mov	 eax, DWORD PTR tv290[ebp]
  0012f	d9 7d de	 fnstcw	 WORD PTR tv309[ebp]
  00132	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00138	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  0013c	0f b7 45 de	 movzx	 eax, WORD PTR tv309[ebp]
  00140	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00145	89 45 d0	 mov	 DWORD PTR tv306[ebp], eax
  00148	8b 06		 mov	 eax, DWORD PTR [esi]
  0014a	6a 00		 push	 0
  0014c	d9 6d d0	 fldcw	 WORD PTR tv306[ebp]
  0014f	db 5d d0	 fistp	 DWORD PTR tv304[ebp]
  00152	8a 4d d0	 mov	 cl, BYTE PTR tv304[ebp]
  00155	0f b6 d1	 movzx	 edx, cl
  00158	52		 push	 edx
  00159	d9 6d de	 fldcw	 WORD PTR tv309[ebp]
  0015c	57		 push	 edi
  0015d	50		 push	 eax
  0015e	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  00163	83 c4 10	 add	 esp, 16			; 00000010H
$LN14@gObjPenalt:

; 6158 : 	}
; 6159 : 
; 6160 : 	if(ret == 2)

  00166	83 7d d4 02	 cmp	 DWORD PTR _ret$[ebp], 2
  0016a	75 07		 jne	 SHORT $LN30@gObjPenalt

; 6161 : 	{
; 6162 : 		reCalCharacter = 1;

  0016c	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN30@gObjPenalt:

; 6163 : 	}
; 6164 : 
; 6165 : 	int item_num[7] = {0,1,2,3,4,5,6};

  00173	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _item_num$[ebp], 0
  0017a	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+4], 1
  00181	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+8], 2
  00188	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+12], 3
  0018f	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+16], 4
  00196	c7 45 f4 05 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+20], 5
  0019d	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+24], 6

; 6166 : 	int item_pos = rand()%7;

  001a4	e8 00 00 00 00	 call	 _rand
  001a9	99		 cdq
  001aa	b9 07 00 00 00	 mov	 ecx, 7
  001af	f7 f9		 idiv	 ecx

; 6167 : 
; 6168 : 	CItem * DurItem = &lpObj->pInventory[item_num[item_pos]];

  001b1	8b 7c 95 e0	 mov	 edi, DWORD PTR _item_num$[ebp+edx*4]
  001b5	69 ff a8 00 00
	00		 imul	 edi, 168		; 000000a8H
  001bb	03 be 8c 0c 00
	00		 add	 edi, DWORD PTR [esi+3212]

; 6169 : 
; 6170 : 	if(DurItem->m_Type != ITEMGET(4,7) && DurItem->m_Type != ITEMGET(4,15))

  001c1	b9 07 08 00 00	 mov	 ecx, 2055		; 00000807H
  001c6	8d 44 95 e0	 lea	 eax, DWORD PTR _item_num$[ebp+edx*4]
  001ca	89 45 d0	 mov	 DWORD PTR tv336[ebp], eax
  001cd	0f b7 47 06	 movzx	 eax, WORD PTR [edi+6]
  001d1	66 3b c1	 cmp	 ax, cx
  001d4	0f 84 b6 00 00
	00		 je	 $LN5@gObjPenalt
  001da	b9 0f 08 00 00	 mov	 ecx, 2063		; 0000080fH
  001df	66 3b c1	 cmp	 ax, cx
  001e2	0f 84 a8 00 00
	00		 je	 $LN5@gObjPenalt

; 6171 : 	{
; 6172 : 		if(item_pos < 2)

  001e8	83 fa 02	 cmp	 edx, 2
  001eb	7d 4e		 jge	 SHORT $LN11@gObjPenalt

; 6173 : 		{
; 6174 : 			if(DurItem->m_Type >= ITEMGET(6,0) && DurItem->m_Type < ITEMGET(7,0))

  001ed	ba 00 0c 00 00	 mov	 edx, 3072		; 00000c00H
  001f2	66 3b c2	 cmp	 ax, dx
  001f5	0f 8c 95 00 00
	00		 jl	 $LN5@gObjPenalt
  001fb	b9 00 0e 00 00	 mov	 ecx, 3584		; 00000e00H
  00200	66 3b c1	 cmp	 ax, cx
  00203	0f 8d 87 00 00
	00		 jge	 $LN5@gObjPenalt

; 6175 : 			{
; 6176 : 				ret = DurItem->DurabilityDown2(decdur,lpObj->m_Index);

  00209	8b 16		 mov	 edx, DWORD PTR [esi]
  0020b	52		 push	 edx
  0020c	53		 push	 ebx
  0020d	8b cf		 mov	 ecx, edi
  0020f	e8 00 00 00 00	 call	 ?DurabilityDown2@CItem@@QAEHHH@Z ; CItem::DurabilityDown2
  00214	89 45 d4	 mov	 DWORD PTR _ret$[ebp], eax

; 6177 : 	
; 6178 : 				if(ret != 0)

  00217	85 c0		 test	 eax, eax
  00219	74 75		 je	 SHORT $LN5@gObjPenalt

; 6179 : 				{
; 6180 : 					GCItemDurSend2(lpObj->m_Index,item_num[item_pos],DurItem->m_Durability,0);

  0021b	d9 47 24	 fld	 DWORD PTR [edi+36]
  0021e	d9 7d de	 fnstcw	 WORD PTR tv282[ebp]
  00221	0f b7 45 de	 movzx	 eax, WORD PTR tv282[ebp]
  00225	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0022a	89 45 d8	 mov	 DWORD PTR tv279[ebp], eax
  0022d	d9 6d d8	 fldcw	 WORD PTR tv279[ebp]
  00230	db 5d d8	 fistp	 DWORD PTR tv277[ebp]
  00233	8a 45 d8	 mov	 al, BYTE PTR tv277[ebp]
  00236	d9 6d de	 fldcw	 WORD PTR tv282[ebp]

; 6181 : 	
; 6182 : 					if(ret == 2)
; 6183 : 					{
; 6184 : 						reCalCharacter = 1;
; 6185 : 					}
; 6186 : 				}
; 6187 : 			}
; 6188 : 		}
; 6189 : 		else

  00239	eb 30		 jmp	 SHORT $LN39@gObjPenalt
$LN11@gObjPenalt:

; 6190 : 		{
; 6191 : 			ret = DurItem->DurabilityDown2(decdur,lpObj->m_Index);

  0023b	8b 16		 mov	 edx, DWORD PTR [esi]
  0023d	52		 push	 edx
  0023e	53		 push	 ebx
  0023f	8b cf		 mov	 ecx, edi
  00241	e8 00 00 00 00	 call	 ?DurabilityDown2@CItem@@QAEHHH@Z ; CItem::DurabilityDown2
  00246	89 45 d4	 mov	 DWORD PTR _ret$[ebp], eax

; 6192 : 
; 6193 : 			if(ret != 0)

  00249	85 c0		 test	 eax, eax
  0024b	74 43		 je	 SHORT $LN5@gObjPenalt

; 6194 : 			{
; 6195 : 				GCItemDurSend2(lpObj->m_Index,item_num[item_pos],DurItem->m_Durability,0);

  0024d	d9 47 24	 fld	 DWORD PTR [edi+36]
  00250	d9 7d de	 fnstcw	 WORD PTR tv268[ebp]
  00253	0f b7 45 de	 movzx	 eax, WORD PTR tv268[ebp]
  00257	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0025c	89 45 d8	 mov	 DWORD PTR tv265[ebp], eax
  0025f	d9 6d d8	 fldcw	 WORD PTR tv265[ebp]
  00262	db 5d d8	 fistp	 DWORD PTR tv259[ebp]
  00265	8a 45 d8	 mov	 al, BYTE PTR tv259[ebp]
  00268	d9 6d de	 fldcw	 WORD PTR tv268[ebp]
$LN39@gObjPenalt:
  0026b	8b 55 d0	 mov	 edx, DWORD PTR tv336[ebp]
  0026e	0f b6 c8	 movzx	 ecx, al
  00271	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00274	6a 00		 push	 0
  00276	51		 push	 ecx
  00277	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00279	50		 push	 eax
  0027a	51		 push	 ecx
  0027b	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  00280	83 c4 10	 add	 esp, 16			; 00000010H

; 6196 : 
; 6197 : 				if(ret == 2)

  00283	83 7d d4 02	 cmp	 DWORD PTR _ret$[ebp], 2
  00287	75 07		 jne	 SHORT $LN5@gObjPenalt

; 6198 : 				{
; 6199 : 					reCalCharacter = 1;

  00289	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN5@gObjPenalt:

; 6200 : 				}
; 6201 : 			}
; 6202 : 		}
; 6203 : 	}
; 6204 : 
; 6205 : 	CItem * Wing = &lpObj->pInventory[7];

  00290	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00296	81 c1 98 04 00
	00		 add	 ecx, 1176		; 00000498H

; 6206 : 
; 6207 : 	if(Wing->IsItem())

  0029c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002a1	85 c0		 test	 eax, eax
  002a3	74 4c		 je	 SHORT $LN31@gObjPenalt

; 6208 : 	{
; 6209 : 		ret = DurItem->DurabilityDown2(decdur,lpObj->m_Index);

  002a5	8b 16		 mov	 edx, DWORD PTR [esi]
  002a7	52		 push	 edx
  002a8	53		 push	 ebx
  002a9	8b cf		 mov	 ecx, edi
  002ab	e8 00 00 00 00	 call	 ?DurabilityDown2@CItem@@QAEHHH@Z ; CItem::DurabilityDown2
  002b0	8b d8		 mov	 ebx, eax

; 6210 : 
; 6211 : 		if(ret != 0)

  002b2	85 db		 test	 ebx, ebx
  002b4	74 3b		 je	 SHORT $LN31@gObjPenalt

; 6212 : 		{
; 6213 : 			GCItemDurSend2(lpObj->m_Index,item_num[item_pos],DurItem->m_Durability,0);

  002b6	d9 47 24	 fld	 DWORD PTR [edi+36]
  002b9	8b 55 d0	 mov	 edx, DWORD PTR tv336[ebp]
  002bc	d9 7d de	 fnstcw	 WORD PTR tv215[ebp]
  002bf	6a 00		 push	 0
  002c1	0f b7 45 de	 movzx	 eax, WORD PTR tv215[ebp]
  002c5	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002ca	89 45 d8	 mov	 DWORD PTR tv203[ebp], eax
  002cd	d9 6d d8	 fldcw	 WORD PTR tv203[ebp]
  002d0	db 5d d8	 fistp	 DWORD PTR tv71[ebp]
  002d3	8a 45 d8	 mov	 al, BYTE PTR tv71[ebp]
  002d6	0f b6 c8	 movzx	 ecx, al
  002d9	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  002dc	d9 6d de	 fldcw	 WORD PTR tv215[ebp]
  002df	51		 push	 ecx
  002e0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002e2	50		 push	 eax
  002e3	51		 push	 ecx
  002e4	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  002e9	83 c4 10	 add	 esp, 16			; 00000010H

; 6214 : 
; 6215 : 			if(ret == 2)

  002ec	83 fb 02	 cmp	 ebx, 2

; 6216 : 			{
; 6217 : 				reCalCharacter = 1;
; 6218 : 			}
; 6219 : 		}
; 6220 : 	}
; 6221 : 
; 6222 : 	if(reCalCharacter != 0)

  002ef	74 06		 je	 SHORT $LN29@gObjPenalt
$LN31@gObjPenalt:
  002f1	83 7d cc 00	 cmp	 DWORD PTR _reCalCharacter$[ebp], 0
  002f5	74 0b		 je	 SHORT $LN1@gObjPenalt
$LN29@gObjPenalt:

; 6223 : 	{
; 6224 : 		gObjCalCharacter(lpObj->m_Index);

  002f7	8b 16		 mov	 edx, DWORD PTR [esi]
  002f9	52		 push	 edx
  002fa	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  002ff	83 c4 04	 add	 esp, 4
$LN1@gObjPenalt:

; 6225 : 	}
; 6226 : }

  00302	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00305	5f		 pop	 edi
  00306	5e		 pop	 esi
  00307	33 cd		 xor	 ecx, ebp
  00309	5b		 pop	 ebx
  0030a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030f	8b e5		 mov	 esp, ebp
  00311	5d		 pop	 ebp
  00312	c3		 ret	 0
  00313	90		 npad	 1
$LN40@gObjPenalt:
  00314	00 00 00 00	 DD	 $LN24@gObjPenalt
  00318	00 00 00 00	 DD	 $LN21@gObjPenalt
  0031c	00 00 00 00	 DD	 $LN22@gObjPenalt
  00320	00 00 00 00	 DD	 $LN21@gObjPenalt
  00324	00 00 00 00	 DD	 $LN21@gObjPenalt
?gObjPenaltyDurDown@@YAXPAUOBJECTSTRUCT@@0@Z ENDP	; gObjPenaltyDurDown
_TEXT	ENDS
PUBLIC	?gObjWeaponDurDown@@YAXPAUOBJECTSTRUCT@@0H@Z	; gObjWeaponDurDown
EXTRN	?StaffWeaponDurabilityDown@CItem@@QAEHHH@Z:PROC	; CItem::StaffWeaponDurabilityDown
EXTRN	?BowWeaponDurabilityDown@CItem@@QAEHHH@Z:PROC	; CItem::BowWeaponDurabilityDown
EXTRN	?NormalWeaponDurabilityDown@CItem@@QAEHHH@Z:PROC ; CItem::NormalWeaponDurabilityDown
; Function compile flags: /Ogtp
;	COMDAT ?gObjWeaponDurDown@@YAXPAUOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
tv364 = -4						; size = 4
tv362 = -4						; size = 4
tv351 = -4						; size = 4
tv348 = -4						; size = 4
tv335 = -4						; size = 4
tv333 = -4						; size = 4
tv320 = -4						; size = 4
tv309 = -4						; size = 4
tv298 = -4						; size = 4
tv296 = -4						; size = 4
tv276 = -4						; size = 4
tv212 = -4						; size = 4
tv153 = -4						; size = 4
tv152 = -4						; size = 4
_Left$ = 8						; size = 4
_lpObj$ = 8						; size = 4
tv367 = 10						; size = 2
tv354 = 10						; size = 2
tv338 = 10						; size = 2
tv324 = 10						; size = 2
tv288 = 10						; size = 2
tv250 = 10						; size = 2
tv159 = 10						; size = 2
_lpTargetObj$ = 12					; size = 4
_type$ = 16						; size = 4
?gObjWeaponDurDown@@YAXPAUOBJECTSTRUCT@@0H@Z PROC	; gObjWeaponDurDown, COMDAT

; 6234 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 6235 : 	if(lpObj->Type == OBJ_MONSTER || lpObj->Type == OBJ_NPC)

  00005	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00008	0f b7 46 60	 movzx	 eax, WORD PTR [esi+96]
  0000c	83 f8 02	 cmp	 eax, 2
  0000f	0f 84 fb 03 00
	00		 je	 $LN36@gObjWeapon
  00015	83 f8 03	 cmp	 eax, 3
  00018	0f 84 f2 03 00
	00		 je	 $LN36@gObjWeapon

; 6236 : 	{
; 6237 : 		return;
; 6238 : 	}
; 6239 : 
; 6240 : 	int itargetdefence = 0;
; 6241 : 	CItem * Right = &lpObj->pInventory[0];
; 6242 : 	CItem * Left = &lpObj->pInventory[1];
; 6243 : 	int ret = 0;
; 6244 : 
; 6245 : 	if(type == 0)

  0001e	83 7d 10 00	 cmp	 DWORD PTR _type$[ebp], 0
  00022	53		 push	 ebx
  00023	57		 push	 edi
  00024	8b be 8c 0c 00
	00		 mov	 edi, DWORD PTR [esi+3212]
  0002a	8d 8f a8 00 00
	00		 lea	 ecx, DWORD PTR [edi+168]
  00030	89 4d 08	 mov	 DWORD PTR _Left$[ebp], ecx
  00033	0f 85 46 03 00
	00		 jne	 $LN35@gObjWeapon

; 6246 : 	{
; 6247 : 
; 6248 : 		itargetdefence = lpTargetObj->m_Defense;
; 6249 : 		itargetdefence += lpTargetObj->m_iSkillNPCDefense;

  00039	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0003c	8b 98 28 15 00
	00		 mov	 ebx, DWORD PTR [eax+5416]
  00042	03 98 10 03 00
	00		 add	 ebx, DWORD PTR [eax+784]

; 6250 : 
; 6251 : 		if((lpObj->Class == 1 || lpObj->Class == 3 || lpObj->Class == 4)
; 6252 : 			&& (Right->m_Type >= 0 && Right->m_Type < ITEMGET(4,0) 
; 6253 : 				&& Left->m_Type >= 0 && Left->m_Type < ITEMGET(4,0)))

  00048	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  0004f	83 f8 01	 cmp	 eax, 1
  00052	74 0e		 je	 SHORT $LN33@gObjWeapon
  00054	83 f8 03	 cmp	 eax, 3
  00057	74 09		 je	 SHORT $LN33@gObjWeapon
  00059	83 f8 04	 cmp	 eax, 4
  0005c	0f 85 09 01 00
	00		 jne	 $LN34@gObjWeapon
$LN33@gObjWeapon:
  00062	0f b7 47 06	 movzx	 eax, WORD PTR [edi+6]
  00066	66 85 c0	 test	 ax, ax
  00069	0f 88 fc 00 00
	00		 js	 $LN34@gObjWeapon
  0006f	ba 00 08 00 00	 mov	 edx, 2048		; 00000800H
  00074	66 3b c2	 cmp	 ax, dx
  00077	0f 8d ee 00 00
	00		 jge	 $LN34@gObjWeapon
  0007d	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00081	66 85 c0	 test	 ax, ax
  00084	0f 88 e1 00 00
	00		 js	 $LN34@gObjWeapon
  0008a	66 3b c2	 cmp	 ax, dx
  0008d	0f 8d d8 00 00
	00		 jge	 $LN34@gObjWeapon

; 6254 : 		{
; 6255 : 			if(rand()%2==0)

  00093	e8 00 00 00 00	 call	 _rand
  00098	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0009d	79 05		 jns	 SHORT $LN42@gObjWeapon
  0009f	48		 dec	 eax
  000a0	83 c8 fe	 or	 eax, -2			; fffffffeH
  000a3	40		 inc	 eax
$LN42@gObjWeapon:
  000a4	75 64		 jne	 SHORT $LN32@gObjWeapon

; 6256 : 			{
; 6257 : 				ret = Left->NormalWeaponDurabilityDown(itargetdefence,lpObj->m_Index);

  000a6	8b 06		 mov	 eax, DWORD PTR [esi]
  000a8	50		 push	 eax
  000a9	53		 push	 ebx
  000aa	8b 5d 08	 mov	 ebx, DWORD PTR _Left$[ebp]
  000ad	8b cb		 mov	 ecx, ebx
  000af	e8 00 00 00 00	 call	 ?NormalWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::NormalWeaponDurabilityDown
  000b4	8b f8		 mov	 edi, eax

; 6258 : 				
; 6259 : 				if(ret != 0)

  000b6	85 ff		 test	 edi, edi
  000b8	0f 84 50 03 00
	00		 je	 $LN40@gObjWeapon

; 6260 : 				{
; 6261 : 					GCItemDurSend(lpObj->m_Index,1,Left->m_Durability,0);

  000be	d9 43 24	 fld	 DWORD PTR [ebx+36]
  000c1	6a 00		 push	 0
  000c3	d9 7d 0a	 fnstcw	 WORD PTR tv367[ebp]
  000c6	0f b7 45 0a	 movzx	 eax, WORD PTR tv367[ebp]
  000ca	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000cf	89 45 fc	 mov	 DWORD PTR tv364[ebp], eax
  000d2	8b 06		 mov	 eax, DWORD PTR [esi]
  000d4	d9 6d fc	 fldcw	 WORD PTR tv364[ebp]
  000d7	db 5d fc	 fistp	 DWORD PTR tv362[ebp]
  000da	8a 4d fc	 mov	 cl, BYTE PTR tv362[ebp]
  000dd	0f b6 d1	 movzx	 edx, cl
  000e0	52		 push	 edx
  000e1	d9 6d 0a	 fldcw	 WORD PTR tv367[ebp]
  000e4	6a 01		 push	 1
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  000ec	83 c4 10	 add	 esp, 16			; 00000010H

; 6262 : 					if(ret == 2)

  000ef	83 ff 02	 cmp	 edi, 2
  000f2	0f 85 16 03 00
	00		 jne	 $LN40@gObjWeapon

; 6263 : 					{
; 6264 : 						gObjCalCharacter(lpObj->m_Index);

  000f8	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000fa	51		 push	 ecx

; 6357 : 			{
; 6358 : 				gObjCalCharacter(lpObj->m_Index);

  000fb	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00100	83 c4 04	 add	 esp, 4
  00103	5f		 pop	 edi
  00104	5b		 pop	 ebx
  00105	5e		 pop	 esi

; 6359 : 			}
; 6360 : 		}
; 6361 : 	}
; 6362 : }

  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c3		 ret	 0
$LN32@gObjWeapon:

; 6265 : 					}
; 6266 : 				}
; 6267 : 			}
; 6268 : 			else
; 6269 : 			{
; 6270 : 				ret = Right->NormalWeaponDurabilityDown(itargetdefence,lpObj->m_Index);

  0010a	8b 16		 mov	 edx, DWORD PTR [esi]
  0010c	52		 push	 edx
  0010d	53		 push	 ebx
  0010e	8b cf		 mov	 ecx, edi
  00110	e8 00 00 00 00	 call	 ?NormalWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::NormalWeaponDurabilityDown
  00115	8b d8		 mov	 ebx, eax

; 6271 : 				if(ret != 0)

  00117	85 db		 test	 ebx, ebx
  00119	0f 84 ef 02 00
	00		 je	 $LN40@gObjWeapon

; 6272 : 				{
; 6273 : 					GCItemDurSend(lpObj->m_Index,0,Right->m_Durability,0);

  0011f	d9 47 24	 fld	 DWORD PTR [edi+36]
  00122	8b 16		 mov	 edx, DWORD PTR [esi]
  00124	d9 7d 0a	 fnstcw	 WORD PTR tv354[ebp]
  00127	6a 00		 push	 0
  00129	0f b7 45 0a	 movzx	 eax, WORD PTR tv354[ebp]
  0012d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00132	89 45 fc	 mov	 DWORD PTR tv351[ebp], eax
  00135	d9 6d fc	 fldcw	 WORD PTR tv351[ebp]
  00138	db 5d fc	 fistp	 DWORD PTR tv348[ebp]
  0013b	8a 45 fc	 mov	 al, BYTE PTR tv348[ebp]
  0013e	0f b6 c8	 movzx	 ecx, al
  00141	51		 push	 ecx
  00142	d9 6d 0a	 fldcw	 WORD PTR tv354[ebp]
  00145	6a 00		 push	 0
  00147	52		 push	 edx
  00148	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  0014d	83 c4 10	 add	 esp, 16			; 00000010H

; 6274 : 					if(ret==2)

  00150	83 fb 02	 cmp	 ebx, 2
  00153	0f 85 b5 02 00
	00		 jne	 $LN40@gObjWeapon

; 6275 : 					{
; 6276 : 						gObjCalCharacter(lpObj->m_Index);

  00159	8b 06		 mov	 eax, DWORD PTR [esi]
  0015b	50		 push	 eax

; 6357 : 			{
; 6358 : 				gObjCalCharacter(lpObj->m_Index);

  0015c	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00161	83 c4 04	 add	 esp, 4
  00164	5f		 pop	 edi
  00165	5b		 pop	 ebx
  00166	5e		 pop	 esi

; 6359 : 			}
; 6360 : 		}
; 6361 : 	}
; 6362 : }

  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN34@gObjWeapon:

; 6277 : 					}
; 6278 : 				}
; 6279 : 			}
; 6280 : 
; 6281 : 			return;
; 6282 : 		}
; 6283 : 		else if(Left->m_Type >= ITEMGET(4,0) && Left->m_Type < ITEMGET(4,7) || Left->m_Type == ITEMGET(4,20) || Left->m_Type == ITEMGET(4,21))

  0016b	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  0016f	ba 00 08 00 00	 mov	 edx, 2048		; 00000800H
  00174	66 3b c2	 cmp	 ax, dx
  00177	7c 0e		 jl	 SHORT $LN23@gObjWeapon
  00179	ba 07 08 00 00	 mov	 edx, 2055		; 00000807H
  0017e	66 3b c2	 cmp	 ax, dx
  00181	0f 8c 96 01 00
	00		 jl	 $LN24@gObjWeapon
$LN23@gObjWeapon:
  00187	ba 14 08 00 00	 mov	 edx, 2068		; 00000814H
  0018c	66 3b c2	 cmp	 ax, dx
  0018f	0f 84 88 01 00
	00		 je	 $LN24@gObjWeapon
  00195	ba 15 08 00 00	 mov	 edx, 2069		; 00000815H
  0019a	66 3b c2	 cmp	 ax, dx
  0019d	0f 84 7a 01 00
	00		 je	 $LN24@gObjWeapon

; 6293 : 				}
; 6294 : 			}
; 6295 : 		}
; 6296 : 		else if(Right->m_Type >= ITEMGET(4,8) && Right->m_Type < ITEMGET(4,15) || Right->m_Type >= ITEMGET(4,16) && Right->m_Type < ITEMGET(5,0))

  001a3	0f b7 47 06	 movzx	 eax, WORD PTR [edi+6]
  001a7	b9 08 08 00 00	 mov	 ecx, 2056		; 00000808H
  001ac	66 3b c1	 cmp	 ax, cx
  001af	7c 0a		 jl	 SHORT $LN17@gObjWeapon
  001b1	ba 0f 08 00 00	 mov	 edx, 2063		; 0000080fH
  001b6	66 3b c2	 cmp	 ax, dx
  001b9	7c 14		 jl	 SHORT $LN18@gObjWeapon
$LN17@gObjWeapon:
  001bb	b9 10 08 00 00	 mov	 ecx, 2064		; 00000810H
  001c0	66 3b c1	 cmp	 ax, cx
  001c3	7c 6b		 jl	 SHORT $LN19@gObjWeapon
  001c5	ba 00 0a 00 00	 mov	 edx, 2560		; 00000a00H
  001ca	66 3b c2	 cmp	 ax, dx
  001cd	7d 61		 jge	 SHORT $LN19@gObjWeapon
$LN18@gObjWeapon:

; 6297 : 		{
; 6298 : 			ret = Right->BowWeaponDurabilityDown(itargetdefence,lpObj->m_Index);

  001cf	8b 06		 mov	 eax, DWORD PTR [esi]
  001d1	50		 push	 eax
  001d2	53		 push	 ebx
  001d3	8b cf		 mov	 ecx, edi
  001d5	e8 00 00 00 00	 call	 ?BowWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::BowWeaponDurabilityDown
  001da	8b d8		 mov	 ebx, eax

; 6299 : 
; 6300 : 			if(ret != 0)

  001dc	85 db		 test	 ebx, ebx
  001de	0f 84 2a 02 00
	00		 je	 $LN40@gObjWeapon

; 6301 : 			{
; 6302 : 				GCItemDurSend(lpObj->m_Index,0,Right->m_Durability,0);

  001e4	d9 47 24	 fld	 DWORD PTR [edi+36]
  001e7	6a 00		 push	 0
  001e9	d9 7d 0a	 fnstcw	 WORD PTR tv338[ebp]
  001ec	0f b7 45 0a	 movzx	 eax, WORD PTR tv338[ebp]
  001f0	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  001f5	89 45 fc	 mov	 DWORD PTR tv335[ebp], eax
  001f8	8b 06		 mov	 eax, DWORD PTR [esi]
  001fa	d9 6d fc	 fldcw	 WORD PTR tv335[ebp]
  001fd	db 5d fc	 fistp	 DWORD PTR tv333[ebp]
  00200	8a 4d fc	 mov	 cl, BYTE PTR tv333[ebp]
  00203	0f b6 d1	 movzx	 edx, cl
  00206	52		 push	 edx
  00207	d9 6d 0a	 fldcw	 WORD PTR tv338[ebp]
  0020a	6a 00		 push	 0
  0020c	50		 push	 eax
  0020d	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00212	83 c4 10	 add	 esp, 16			; 00000010H

; 6303 : 				if(ret==2)

  00215	83 fb 02	 cmp	 ebx, 2
  00218	0f 85 f0 01 00
	00		 jne	 $LN40@gObjWeapon

; 6304 : 				{
; 6305 : 					gObjCalCharacter(lpObj->m_Index);

  0021e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00220	51		 push	 ecx

; 6357 : 			{
; 6358 : 				gObjCalCharacter(lpObj->m_Index);

  00221	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00226	83 c4 04	 add	 esp, 4
  00229	5f		 pop	 edi
  0022a	5b		 pop	 ebx
  0022b	5e		 pop	 esi

; 6359 : 			}
; 6360 : 		}
; 6361 : 	}
; 6362 : }

  0022c	8b e5		 mov	 esp, ebp
  0022e	5d		 pop	 ebp
  0022f	c3		 ret	 0
$LN19@gObjWeapon:

; 6306 : 				}
; 6307 : 			}
; 6308 : 		}
; 6309 : 		else if(Right->m_Type >= ITEMGET(0,0) && Right->m_Type < ITEMGET(4,0))

  00230	66 85 c0	 test	 ax, ax
  00233	78 6b		 js	 SHORT $LN13@gObjWeapon
  00235	ba 00 08 00 00	 mov	 edx, 2048		; 00000800H
  0023a	66 3b c2	 cmp	 ax, dx
  0023d	7d 61		 jge	 SHORT $LN13@gObjWeapon

; 6310 : 		{
; 6311 : 			ret = Right->NormalWeaponDurabilityDown(itargetdefence,lpObj->m_Index);

  0023f	8b 06		 mov	 eax, DWORD PTR [esi]
  00241	50		 push	 eax
  00242	53		 push	 ebx
  00243	8b cf		 mov	 ecx, edi
  00245	e8 00 00 00 00	 call	 ?NormalWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::NormalWeaponDurabilityDown
  0024a	8b d8		 mov	 ebx, eax

; 6312 : 
; 6313 : 			if(ret != 0)

  0024c	85 db		 test	 ebx, ebx
  0024e	0f 84 ba 01 00
	00		 je	 $LN40@gObjWeapon

; 6314 : 			{
; 6315 : 				GCItemDurSend(lpObj->m_Index,0,Right->m_Durability,0);

  00254	d9 47 24	 fld	 DWORD PTR [edi+36]
  00257	6a 00		 push	 0
  00259	d9 7d 0a	 fnstcw	 WORD PTR tv324[ebp]
  0025c	0f b7 45 0a	 movzx	 eax, WORD PTR tv324[ebp]
  00260	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00265	89 45 fc	 mov	 DWORD PTR tv320[ebp], eax
  00268	8b 06		 mov	 eax, DWORD PTR [esi]
  0026a	d9 6d fc	 fldcw	 WORD PTR tv320[ebp]
  0026d	db 5d fc	 fistp	 DWORD PTR tv309[ebp]
  00270	8a 4d fc	 mov	 cl, BYTE PTR tv309[ebp]
  00273	0f b6 d1	 movzx	 edx, cl
  00276	52		 push	 edx
  00277	d9 6d 0a	 fldcw	 WORD PTR tv324[ebp]
  0027a	6a 00		 push	 0
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00282	83 c4 10	 add	 esp, 16			; 00000010H

; 6316 : 				if(ret==2)

  00285	83 fb 02	 cmp	 ebx, 2
  00288	0f 85 80 01 00
	00		 jne	 $LN40@gObjWeapon

; 6317 : 				{
; 6318 : 					gObjCalCharacter(lpObj->m_Index);

  0028e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00290	51		 push	 ecx

; 6357 : 			{
; 6358 : 				gObjCalCharacter(lpObj->m_Index);

  00291	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00296	83 c4 04	 add	 esp, 4
  00299	5f		 pop	 edi
  0029a	5b		 pop	 ebx
  0029b	5e		 pop	 esi

; 6359 : 			}
; 6360 : 		}
; 6361 : 	}
; 6362 : }

  0029c	8b e5		 mov	 esp, ebp
  0029e	5d		 pop	 ebp
  0029f	c3		 ret	 0
$LN13@gObjWeapon:

; 6319 : 				}
; 6320 : 			}
; 6321 : 		}
; 6322 : 		else if(Right->m_Type >= ITEMGET(5,0) && Right->m_Type < ITEMGET(6,0))

  002a0	ba 00 0a 00 00	 mov	 edx, 2560		; 00000a00H
  002a5	66 3b c2	 cmp	 ax, dx
  002a8	0f 8c 60 01 00
	00		 jl	 $LN40@gObjWeapon
  002ae	b9 00 0c 00 00	 mov	 ecx, 3072		; 00000c00H
  002b3	66 3b c1	 cmp	 ax, cx
  002b6	0f 8d 52 01 00
	00		 jge	 $LN40@gObjWeapon

; 6323 : 		{
; 6324 : 			ret = Right->StaffWeaponDurabilityDown(itargetdefence,lpObj->m_Index);

  002bc	8b 16		 mov	 edx, DWORD PTR [esi]
  002be	52		 push	 edx
  002bf	53		 push	 ebx
  002c0	8b cf		 mov	 ecx, edi
  002c2	e8 00 00 00 00	 call	 ?StaffWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::StaffWeaponDurabilityDown
  002c7	8b d8		 mov	 ebx, eax

; 6325 : 
; 6326 : 			if(ret != 0)

  002c9	85 db		 test	 ebx, ebx
  002cb	0f 84 3d 01 00
	00		 je	 $LN40@gObjWeapon

; 6327 : 			{
; 6328 : 				GCItemDurSend(lpObj->m_Index,0,Right->m_Durability,0);

  002d1	d9 47 24	 fld	 DWORD PTR [edi+36]
  002d4	8b 16		 mov	 edx, DWORD PTR [esi]
  002d6	d9 7d 0a	 fnstcw	 WORD PTR tv250[ebp]
  002d9	6a 00		 push	 0
  002db	0f b7 45 0a	 movzx	 eax, WORD PTR tv250[ebp]
  002df	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002e4	89 45 fc	 mov	 DWORD PTR tv298[ebp], eax
  002e7	d9 6d fc	 fldcw	 WORD PTR tv298[ebp]
  002ea	db 5d fc	 fistp	 DWORD PTR tv296[ebp]
  002ed	8a 45 fc	 mov	 al, BYTE PTR tv296[ebp]
  002f0	0f b6 c8	 movzx	 ecx, al
  002f3	51		 push	 ecx
  002f4	d9 6d 0a	 fldcw	 WORD PTR tv250[ebp]
  002f7	6a 00		 push	 0
  002f9	52		 push	 edx
  002fa	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  002ff	83 c4 10	 add	 esp, 16			; 00000010H

; 6329 : 				if(ret==2)

  00302	83 fb 02	 cmp	 ebx, 2
  00305	0f 85 03 01 00
	00		 jne	 $LN40@gObjWeapon

; 6330 : 				{
; 6331 : 					gObjCalCharacter(lpObj->m_Index);

  0030b	8b 06		 mov	 eax, DWORD PTR [esi]
  0030d	50		 push	 eax

; 6357 : 			{
; 6358 : 				gObjCalCharacter(lpObj->m_Index);

  0030e	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00313	83 c4 04	 add	 esp, 4
  00316	5f		 pop	 edi
  00317	5b		 pop	 ebx
  00318	5e		 pop	 esi

; 6359 : 			}
; 6360 : 		}
; 6361 : 	}
; 6362 : }

  00319	8b e5		 mov	 esp, ebp
  0031b	5d		 pop	 ebp
  0031c	c3		 ret	 0
$LN24@gObjWeapon:

; 6284 : 		{
; 6285 : 			ret = Left->BowWeaponDurabilityDown(itargetdefence,lpObj->m_Index);

  0031d	8b 16		 mov	 edx, DWORD PTR [esi]
  0031f	52		 push	 edx
  00320	53		 push	 ebx
  00321	e8 00 00 00 00	 call	 ?BowWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::BowWeaponDurabilityDown
  00326	8b f8		 mov	 edi, eax

; 6286 : 
; 6287 : 			if(ret != 0)

  00328	85 ff		 test	 edi, edi
  0032a	0f 84 de 00 00
	00		 je	 $LN40@gObjWeapon

; 6288 : 			{
; 6289 : 				GCItemDurSend(lpObj->m_Index,1,Left->m_Durability,0);

  00330	8b 45 08	 mov	 eax, DWORD PTR _Left$[ebp]
  00333	d9 7d 0a	 fnstcw	 WORD PTR tv288[ebp]
  00336	d9 40 24	 fld	 DWORD PTR [eax+36]
  00339	6a 00		 push	 0
  0033b	0f b7 45 0a	 movzx	 eax, WORD PTR tv288[ebp]
  0033f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00344	89 45 fc	 mov	 DWORD PTR tv212[ebp], eax
  00347	8b 06		 mov	 eax, DWORD PTR [esi]
  00349	d9 6d fc	 fldcw	 WORD PTR tv212[ebp]
  0034c	db 5d fc	 fistp	 DWORD PTR tv276[ebp]
  0034f	8a 4d fc	 mov	 cl, BYTE PTR tv276[ebp]
  00352	0f b6 d1	 movzx	 edx, cl
  00355	52		 push	 edx
  00356	d9 6d 0a	 fldcw	 WORD PTR tv288[ebp]
  00359	6a 01		 push	 1
  0035b	50		 push	 eax
  0035c	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00361	83 c4 10	 add	 esp, 16			; 00000010H

; 6290 : 				if(ret==2)

  00364	83 ff 02	 cmp	 edi, 2
  00367	0f 85 a1 00 00
	00		 jne	 $LN40@gObjWeapon

; 6291 : 				{
; 6292 : 					gObjCalCharacter(lpObj->m_Index);

  0036d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0036f	51		 push	 ecx

; 6357 : 			{
; 6358 : 				gObjCalCharacter(lpObj->m_Index);

  00370	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00375	83 c4 04	 add	 esp, 4
  00378	5f		 pop	 edi
  00379	5b		 pop	 ebx
  0037a	5e		 pop	 esi

; 6359 : 			}
; 6360 : 		}
; 6361 : 	}
; 6362 : }

  0037b	8b e5		 mov	 esp, ebp
  0037d	5d		 pop	 ebp
  0037e	c3		 ret	 0
$LN35@gObjWeapon:

; 6332 : 				}
; 6333 : 			}
; 6334 : 		}
; 6335 : 	return;
; 6336 : 	}
; 6337 : 
; 6338 : 
; 6339 : 	if(lpTargetObj->Type == OBJ_MONSTER || lpTargetObj->Type == OBJ_NPC)

  0037f	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00382	0f b7 41 60	 movzx	 eax, WORD PTR [ecx+96]
  00386	83 f8 02	 cmp	 eax, 2
  00389	74 0d		 je	 SHORT $LN5@gObjWeapon
  0038b	83 f8 03	 cmp	 eax, 3
  0038e	74 08		 je	 SHORT $LN5@gObjWeapon

; 6342 : 	}
; 6343 : 	else
; 6344 : 	{
; 6345 : 		itargetdefence = lpTargetObj->m_Defense;

  00390	8b 81 10 03 00
	00		 mov	 eax, DWORD PTR [ecx+784]
  00396	eb 06		 jmp	 SHORT $LN4@gObjWeapon
$LN5@gObjWeapon:

; 6340 : 	{
; 6341 : 		itargetdefence = lpTargetObj->m_MagicDefense;

  00398	8b 81 14 03 00
	00		 mov	 eax, DWORD PTR [ecx+788]
$LN4@gObjWeapon:

; 6346 : 	}
; 6347 : 
; 6348 : 	itargetdefence += lpTargetObj->m_iSkillNPCDefense;

  0039e	03 81 28 15 00
	00		 add	 eax, DWORD PTR [ecx+5416]

; 6349 : 
; 6350 : 	if(Right->m_Type >= ITEMGET(5,0) && Right->m_Type < ITEMGET(6,0))

  003a4	0f b7 4f 06	 movzx	 ecx, WORD PTR [edi+6]
  003a8	ba 00 0a 00 00	 mov	 edx, 2560		; 00000a00H
  003ad	66 3b ca	 cmp	 cx, dx
  003b0	7c 5c		 jl	 SHORT $LN40@gObjWeapon
  003b2	ba 00 0c 00 00	 mov	 edx, 3072		; 00000c00H
  003b7	66 3b ca	 cmp	 cx, dx
  003ba	7d 52		 jge	 SHORT $LN40@gObjWeapon

; 6351 : 	{
; 6352 : 		ret = Right->StaffWeaponDurabilityDown(itargetdefence,lpObj->m_Index);

  003bc	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003be	51		 push	 ecx
  003bf	50		 push	 eax
  003c0	8b cf		 mov	 ecx, edi
  003c2	e8 00 00 00 00	 call	 ?StaffWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::StaffWeaponDurabilityDown
  003c7	8b d8		 mov	 ebx, eax

; 6353 : 		if(ret != 0)

  003c9	85 db		 test	 ebx, ebx
  003cb	74 41		 je	 SHORT $LN40@gObjWeapon

; 6354 : 		{
; 6355 : 			GCItemDurSend(lpObj->m_Index,0,Right->m_Durability,0);

  003cd	d9 47 24	 fld	 DWORD PTR [edi+36]
  003d0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003d2	d9 7d 0a	 fnstcw	 WORD PTR tv159[ebp]
  003d5	6a 00		 push	 0
  003d7	0f b7 45 0a	 movzx	 eax, WORD PTR tv159[ebp]
  003db	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  003e0	89 45 fc	 mov	 DWORD PTR tv153[ebp], eax
  003e3	d9 6d fc	 fldcw	 WORD PTR tv153[ebp]
  003e6	db 5d fc	 fistp	 DWORD PTR tv152[ebp]
  003e9	8a 55 fc	 mov	 dl, BYTE PTR tv152[ebp]
  003ec	0f b6 c2	 movzx	 eax, dl
  003ef	50		 push	 eax
  003f0	d9 6d 0a	 fldcw	 WORD PTR tv159[ebp]
  003f3	6a 00		 push	 0
  003f5	51		 push	 ecx
  003f6	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  003fb	83 c4 10	 add	 esp, 16			; 00000010H

; 6356 : 			if(ret==2)

  003fe	83 fb 02	 cmp	 ebx, 2
  00401	75 0b		 jne	 SHORT $LN40@gObjWeapon

; 6357 : 			{
; 6358 : 				gObjCalCharacter(lpObj->m_Index);

  00403	8b 16		 mov	 edx, DWORD PTR [esi]
  00405	52		 push	 edx
  00406	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  0040b	83 c4 04	 add	 esp, 4
$LN40@gObjWeapon:
  0040e	5f		 pop	 edi
  0040f	5b		 pop	 ebx
$LN36@gObjWeapon:
  00410	5e		 pop	 esi

; 6359 : 			}
; 6360 : 		}
; 6361 : 	}
; 6362 : }

  00411	8b e5		 mov	 esp, ebp
  00413	5d		 pop	 ebp
  00414	c3		 ret	 0
?gObjWeaponDurDown@@YAXPAUOBJECTSTRUCT@@0H@Z ENDP	; gObjWeaponDurDown
_TEXT	ENDS
PUBLIC	_lpAttackObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjArmorRandomDurDown@@YAXPAUOBJECTSTRUCT@@0@Z ; gObjArmorRandomDurDown
EXTRN	?ArmorDurabilityDown@CItem@@QAEHHH@Z:PROC	; CItem::ArmorDurabilityDown
; Function compile flags: /Ogtp
;	COMDAT ?gObjArmorRandomDurDown@@YAXPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpAttackObj$GSCopy$ = -44				; size = 4
_ret$ = -44						; size = 4
tv224 = -40						; size = 4
tv222 = -40						; size = 4
tv208 = -40						; size = 4
tv206 = -40						; size = 4
tv227 = -34						; size = 2
tv211 = -34						; size = 2
_item_num$ = -32					; size = 28
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpAttackObj$ = 12					; size = 4
?gObjArmorRandomDurDown@@YAXPAUOBJECTSTRUCT@@0@Z PROC	; gObjArmorRandomDurDown, COMDAT

; 6370 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _lpAttackObj$[ebp]
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]

; 6371 : 	int item_num[7] = {0,1,2,3,4,5,6};

  00018	be 01 00 00 00	 mov	 esi, 1

; 6407 : 			{
; 6408 : 				GCItemDurSend(lpObj->m_Index,item_num[item_pos],DurItem->m_Durability,0);

  0001d	89 45 d4	 mov	 DWORD PTR _lpAttackObj$GSCopy$[ebp], eax
  00020	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _item_num$[ebp], 0
  00027	89 75 e4	 mov	 DWORD PTR _item_num$[ebp+4], esi
  0002a	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+8], 2
  00031	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+12], 3
  00038	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+16], 4
  0003f	c7 45 f4 05 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+20], 5
  00046	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+24], 6
  0004d	e8 00 00 00 00	 call	 _rand
  00052	99		 cdq
  00053	b9 07 00 00 00	 mov	 ecx, 7
  00058	f7 f9		 idiv	 ecx
  0005a	66 39 77 60	 cmp	 WORD PTR [edi+96], si
  0005e	0f 85 e4 00 00
	00		 jne	 $LN1@gObjArmorR

; 6372 : 	int item_pos = rand()%7;
; 6373 : 
; 6374 : 	if(lpObj->Type != OBJ_USER)
; 6375 : 	{
; 6376 : 		return;
; 6377 : 	}
; 6378 : 
; 6379 : 	CItem * DurItem = &lpObj->pInventory[item_num[item_pos]];
; 6380 : 	int damagemin = lpAttackObj->m_AttackDamageMin;

  00064	8b 74 95 e0	 mov	 esi, DWORD PTR _item_num$[ebp+edx*4]
  00068	8b 45 d4	 mov	 eax, DWORD PTR _lpAttackObj$GSCopy$[ebp]
  0006b	69 f6 a8 00 00
	00		 imul	 esi, 168		; 000000a8H
  00071	03 b7 8c 0c 00
	00		 add	 esi, DWORD PTR [edi+3212]
  00077	8b 80 dc 02 00
	00		 mov	 eax, DWORD PTR [eax+732]

; 6381 : 	int ret;
; 6382 : 
; 6383 : 	if(item_pos < 2)
; 6384 : 	{
; 6385 : 		if(DurItem->m_Type >= ITEMGET(6,0) && DurItem->m_Type < ITEMGET(7,0))

  0007d	0f b7 4e 06	 movzx	 ecx, WORD PTR [esi+6]
  00081	53		 push	 ebx
  00082	8d 5c 95 e0	 lea	 ebx, DWORD PTR _item_num$[ebp+edx*4]
  00086	83 fa 02	 cmp	 edx, 2
  00089	7d 52		 jge	 SHORT $LN8@gObjArmorR
  0008b	ba 00 0c 00 00	 mov	 edx, 3072		; 00000c00H
  00090	66 3b ca	 cmp	 cx, dx
  00093	0f 8c ae 00 00
	00		 jl	 $LN12@gObjArmorR
  00099	ba 00 0e 00 00	 mov	 edx, 3584		; 00000e00H
  0009e	66 3b ca	 cmp	 cx, dx
  000a1	0f 8d a0 00 00
	00		 jge	 $LN12@gObjArmorR

; 6386 : 		{
; 6387 : 			ret = DurItem->ArmorDurabilityDown(damagemin,lpObj->m_Index);

  000a7	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000a9	51		 push	 ecx
  000aa	50		 push	 eax
  000ab	8b ce		 mov	 ecx, esi
  000ad	e8 00 00 00 00	 call	 ?ArmorDurabilityDown@CItem@@QAEHHH@Z ; CItem::ArmorDurabilityDown
  000b2	89 45 d4	 mov	 DWORD PTR _ret$[ebp], eax

; 6388 : 
; 6389 : 			if(ret != 0)

  000b5	85 c0		 test	 eax, eax
  000b7	0f 84 8a 00 00
	00		 je	 $LN12@gObjArmorR

; 6390 : 			{
; 6391 : 				GCItemDurSend(lpObj->m_Index,item_num[item_pos],DurItem->m_Durability,0);

  000bd	d9 46 24	 fld	 DWORD PTR [esi+36]
  000c0	d9 7d de	 fnstcw	 WORD PTR tv227[ebp]
  000c3	0f b7 45 de	 movzx	 eax, WORD PTR tv227[ebp]
  000c7	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000cc	89 45 d8	 mov	 DWORD PTR tv224[ebp], eax
  000cf	d9 6d d8	 fldcw	 WORD PTR tv224[ebp]
  000d2	db 5d d8	 fistp	 DWORD PTR tv222[ebp]
  000d5	8a 55 d8	 mov	 dl, BYTE PTR tv222[ebp]
  000d8	d9 6d de	 fldcw	 WORD PTR tv227[ebp]

; 6392 : 				if(ret == 2)
; 6393 : 				{
; 6394 : 					gObjCalCharacter(lpObj->m_Index);
; 6395 : 				}
; 6396 : 			}
; 6397 : 			return;

  000db	eb 44		 jmp	 SHORT $LN14@gObjArmorR
$LN8@gObjArmorR:

; 6398 : 		}
; 6399 : 	}
; 6400 : 	else
; 6401 : 	{
; 6402 : 		if(DurItem->m_Type != ITEMGET(4,7) && DurItem->m_Type != ITEMGET(4,15))

  000dd	ba 07 08 00 00	 mov	 edx, 2055		; 00000807H
  000e2	66 3b ca	 cmp	 cx, dx
  000e5	74 60		 je	 SHORT $LN12@gObjArmorR
  000e7	ba 0f 08 00 00	 mov	 edx, 2063		; 0000080fH
  000ec	66 3b ca	 cmp	 cx, dx
  000ef	74 56		 je	 SHORT $LN12@gObjArmorR

; 6403 : 		{
; 6404 : 			ret = DurItem->ArmorDurabilityDown(damagemin,lpObj->m_Index);

  000f1	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000f3	51		 push	 ecx
  000f4	50		 push	 eax
  000f5	8b ce		 mov	 ecx, esi
  000f7	e8 00 00 00 00	 call	 ?ArmorDurabilityDown@CItem@@QAEHHH@Z ; CItem::ArmorDurabilityDown
  000fc	89 45 d4	 mov	 DWORD PTR _ret$[ebp], eax

; 6405 : 
; 6406 : 			if(ret != 0)

  000ff	85 c0		 test	 eax, eax
  00101	74 44		 je	 SHORT $LN12@gObjArmorR

; 6407 : 			{
; 6408 : 				GCItemDurSend(lpObj->m_Index,item_num[item_pos],DurItem->m_Durability,0);

  00103	d9 46 24	 fld	 DWORD PTR [esi+36]
  00106	d9 7d de	 fnstcw	 WORD PTR tv211[ebp]
  00109	0f b7 45 de	 movzx	 eax, WORD PTR tv211[ebp]
  0010d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00112	89 45 d8	 mov	 DWORD PTR tv208[ebp], eax
  00115	d9 6d d8	 fldcw	 WORD PTR tv208[ebp]
  00118	db 5d d8	 fistp	 DWORD PTR tv206[ebp]
  0011b	8a 55 d8	 mov	 dl, BYTE PTR tv206[ebp]
  0011e	d9 6d de	 fldcw	 WORD PTR tv211[ebp]
$LN14@gObjArmorR:
  00121	0f b6 0b	 movzx	 ecx, BYTE PTR [ebx]
  00124	0f b6 c2	 movzx	 eax, dl
  00127	8b 17		 mov	 edx, DWORD PTR [edi]
  00129	6a 00		 push	 0
  0012b	50		 push	 eax
  0012c	51		 push	 ecx
  0012d	52		 push	 edx
  0012e	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00133	83 c4 10	 add	 esp, 16			; 00000010H

; 6409 : 				if(ret == 2)

  00136	83 7d d4 02	 cmp	 DWORD PTR _ret$[ebp], 2
  0013a	75 0b		 jne	 SHORT $LN12@gObjArmorR

; 6410 : 				{
; 6411 : 					gObjCalCharacter(lpObj->m_Index);

  0013c	8b 07		 mov	 eax, DWORD PTR [edi]
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00144	83 c4 04	 add	 esp, 4
$LN12@gObjArmorR:
  00147	5b		 pop	 ebx
$LN1@gObjArmorR:

; 6412 : 				}
; 6413 : 			}
; 6414 : 		}
; 6415 : 	}
; 6416 : }

  00148	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014b	5f		 pop	 edi
  0014c	33 cd		 xor	 ecx, ebp
  0014e	5e		 pop	 esi
  0014f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c3		 ret	 0
?gObjArmorRandomDurDown@@YAXPAUOBJECTSTRUCT@@0@Z ENDP	; gObjArmorRandomDurDown
_TEXT	ENDS
PUBLIC	?gObjIsSelfDefense@@YA_NPAUOBJECTSTRUCT@@H@Z	; gObjIsSelfDefense
; Function compile flags: /Ogtp
;	COMDAT ?gObjIsSelfDefense@@YA_NPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
?gObjIsSelfDefense@@YA_NPAUOBJECTSTRUCT@@H@Z PROC	; gObjIsSelfDefense, COMDAT

; 6424 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 6425 : 	if ( !OBJMAX_RANGE(aTargetIndex) )

  00004	8b 75 0c	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 2d		 js	 SHORT $LN3@gObjIsSelf
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax

; 6426 : 	{
; 6427 : 		return false;

  00018	74 1e		 je	 SHORT $LN3@gObjIsSelf

; 6428 : 	}
; 6429 : 
; 6430 : 	for ( int n=0;n<MAX_SELF_DEFENSE;n++)

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0001d	33 c0		 xor	 eax, eax
  0001f	81 c1 48 02 00
	00		 add	 ecx, 584		; 00000248H
$LL5@gObjIsSelf:

; 6431 : 	{
; 6432 : 		if ( lpObj->SelfDefense[n] >= 0 )

  00025	8b 11		 mov	 edx, DWORD PTR [ecx]
  00027	85 d2		 test	 edx, edx
  00029	78 04		 js	 SHORT $LN4@gObjIsSelf

; 6433 : 		{
; 6434 : 			if ( lpObj->SelfDefense[n] == aTargetIndex )

  0002b	3b d6		 cmp	 edx, esi
  0002d	74 0e		 je	 SHORT $LN12@gObjIsSelf
$LN4@gObjIsSelf:

; 6428 : 	}
; 6429 : 
; 6430 : 	for ( int n=0;n<MAX_SELF_DEFENSE;n++)

  0002f	40		 inc	 eax
  00030	83 c1 04	 add	 ecx, 4
  00033	83 f8 05	 cmp	 eax, 5
  00036	7c ed		 jl	 SHORT $LL5@gObjIsSelf
$LN3@gObjIsSelf:

; 6437 : 			}
; 6438 : 		}
; 6439 : 	}
; 6440 : 
; 6441 : 	return false;

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 6442 : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN12@gObjIsSelf:

; 6435 : 			{
; 6436 : 				return true;

  0003d	b0 01		 mov	 al, 1
  0003f	5e		 pop	 esi

; 6442 : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?gObjIsSelfDefense@@YA_NPAUOBJECTSTRUCT@@H@Z ENDP	; gObjIsSelfDefense
_TEXT	ENDS
PUBLIC	??_C@_0CC@IPHFNLBG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5SelfDefence?5?$FL?$CFs?$FN?$FL?$CFs@ ; `string'
PUBLIC	_aTargetIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@H@Z	; gObjCheckSelfDefense
EXTRN	__imp__wsprintfA:PROC
;	COMDAT ??_C@_0CC@IPHFNLBG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5SelfDefence?5?$FL?$CFs?$FN?$FL?$CFs@
CONST	SEGMENT
??_C@_0CC@IPHFNLBG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5SelfDefence?5?$FL?$CFs?$FN?$FL?$CFs@ DB '['
	DB	'%s][%s] Set SelfDefence [%s][%s]', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_aTargetIndex$GSCopy$ = -76				; size = 4
tv227 = -72						; size = 4
_szTemp$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
?gObjCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; gObjCheckSelfDefense, COMDAT

; 6450 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 0c	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 6493 : 		return;
; 6494 : 	}
; 6495 : 
; 6496 : 	lpObj->MySelfDefenseTime = GetTickCount();

  00017	89 55 b4	 mov	 DWORD PTR _aTargetIndex$GSCopy$[ebp], edx
  0001a	85 d2		 test	 edx, edx
  0001c	0f 88 51 01 00
	00		 js	 $LN15@gObjCheckS

; 6451 : 	if(!OBJMAX_RANGE(aTargetIndex))

  00022	33 c0		 xor	 eax, eax
  00024	81 fa e7 1c 00
	00		 cmp	 edx, 7399		; 00001ce7H
  0002a	0f 9e c0	 setle	 al
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 3e 01 00
	00		 je	 $LN15@gObjCheckS

; 6452 : 	{
; 6453 : 		return;
; 6454 : 	}
; 6455 : 
; 6456 : 	if(gObj[aTargetIndex].m_PK_Level > 4)

  00035	8b ca		 mov	 ecx, edx
  00037	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0003d	80 b9 fd 00 00
	00 04		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+253], 4
  00044	89 4d b8	 mov	 DWORD PTR tv227[ebp], ecx
  00047	0f 8f 26 01 00
	00		 jg	 $LN15@gObjCheckS

; 6457 : 	{
; 6458 : 		return;
; 6459 : 	}
; 6460 : 
; 6461 : 	for(int n = 0; n < MAX_SELF_DEFENSE;n++)

  0004d	33 c0		 xor	 eax, eax
  0004f	8d 89 48 02 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+584]
  00055	57		 push	 edi
$LL12@gObjCheckS:

; 6462 : 	{
; 6463 : 		if(gObj[aTargetIndex].SelfDefense[n] >= 0)

  00056	8b 39		 mov	 edi, DWORD PTR [ecx]
  00058	85 ff		 test	 edi, edi
  0005a	78 08		 js	 SHORT $LN11@gObjCheckS

; 6464 : 		{
; 6465 : 			if(gObj[aTargetIndex].SelfDefense[n]==lpObj->m_Index)

  0005c	3b 3e		 cmp	 edi, DWORD PTR [esi]
  0005e	0f 84 0e 01 00
	00		 je	 $LN25@gObjCheckS
$LN11@gObjCheckS:

; 6457 : 	{
; 6458 : 		return;
; 6459 : 	}
; 6460 : 
; 6461 : 	for(int n = 0; n < MAX_SELF_DEFENSE;n++)

  00064	40		 inc	 eax
  00065	83 c1 04	 add	 ecx, 4
  00068	83 f8 05	 cmp	 eax, 5
  0006b	7c e9		 jl	 SHORT $LL12@gObjCheckS

; 6466 : 			{
; 6467 : 				return;
; 6468 : 			}
; 6469 : 		}
; 6470 : 	}
; 6471 : 
; 6472 : 	int blank = -1;

  0006d	53		 push	 ebx
  0006e	83 cf ff	 or	 edi, -1

; 6473 : 
; 6474 : 	for(int n = 0; n < MAX_SELF_DEFENSE;n++)

  00071	33 db		 xor	 ebx, ebx
  00073	8d 86 48 02 00
	00		 lea	 eax, DWORD PTR [esi+584]
  00079	8d a4 24 00 00
	00 00		 npad	 7
$LL7@gObjCheckS:

; 6475 : 	{
; 6476 : 		if(lpObj->SelfDefense[n] >= 0)

  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	85 c9		 test	 ecx, ecx
  00084	78 27		 js	 SHORT $LN4@gObjCheckS

; 6477 : 		{
; 6478 : 			if(lpObj->SelfDefense[n] == aTargetIndex)

  00086	3b ca		 cmp	 ecx, edx
  00088	75 25		 jne	 SHORT $LN6@gObjCheckS

; 6479 : 			{
; 6480 : 				lpObj->SelfDefenseTime[n] = GetTickCount()+30000;

  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00090	05 30 75 00 00	 add	 eax, 30000		; 00007530H
  00095	89 84 9e 5c 02
	00 00		 mov	 DWORD PTR [esi+ebx*4+604], eax
  0009c	5b		 pop	 ebx
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi

; 6508 : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN4@gObjCheckS:

; 6481 : 				return;
; 6482 : 			}
; 6483 : 		}
; 6484 : 		else
; 6485 : 		{
; 6486 : 			blank = n;

  000ad	8b fb		 mov	 edi, ebx
$LN6@gObjCheckS:

; 6473 : 
; 6474 : 	for(int n = 0; n < MAX_SELF_DEFENSE;n++)

  000af	43		 inc	 ebx
  000b0	83 c0 04	 add	 eax, 4
  000b3	83 fb 05	 cmp	 ebx, 5
  000b6	7c c8		 jl	 SHORT $LL7@gObjCheckS

; 6487 : 		}
; 6488 : 	}
; 6489 : 
; 6490 : 	if(blank < 0)

  000b8	85 ff		 test	 edi, edi
  000ba	79 2b		 jns	 SHORT $LN1@gObjCheckS

; 6491 : 	{
; 6492 : 		LogAdd(LOG_BLACK, lMsg.Get(523));

  000bc	68 0b 02 00 00	 push	 523			; 0000020bH
  000c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000c6	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000cb	50		 push	 eax
  000cc	6a 00		 push	 0
  000ce	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000d3	83 c4 08	 add	 esp, 8
  000d6	5b		 pop	 ebx
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi

; 6508 : }

  000d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dc	33 cd		 xor	 ecx, ebp
  000de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
$LN1@gObjCheckS:

; 6493 : 		return;
; 6494 : 	}
; 6495 : 
; 6496 : 	lpObj->MySelfDefenseTime = GetTickCount();

  000e7	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  000ed	ff d3		 call	 ebx
  000ef	89 86 70 02 00
	00		 mov	 DWORD PTR [esi+624], eax

; 6497 : 	lpObj->SelfDefense[blank] = aTargetIndex;

  000f5	8b 45 b4	 mov	 eax, DWORD PTR _aTargetIndex$GSCopy$[ebp]
  000f8	89 84 be 48 02
	00 00		 mov	 DWORD PTR [esi+edi*4+584], eax

; 6498 : 	lpObj->SelfDefenseTime[blank] = GetTickCount() + 30000;

  000ff	ff d3		 call	 ebx
  00101	05 30 75 00 00	 add	 eax, 30000		; 00007530H
  00106	89 84 be 5c 02
	00 00		 mov	 DWORD PTR [esi+edi*4+604], eax

; 6499 : 
; 6500 : 	char szTemp[64];
; 6501 : 
; 6502 : 	wsprintf(szTemp,lMsg.Get(1114),lpObj->Name,gObj[aTargetIndex].Name);

  0010d	8b 7d b8	 mov	 edi, DWORD PTR tv227[ebp]
  00110	8d bf 6f 00 00
	00		 lea	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+111]
  00116	57		 push	 edi
  00117	8d 5e 6f	 lea	 ebx, DWORD PTR [esi+111]
  0011a	53		 push	 ebx
  0011b	68 5a 04 00 00	 push	 1114			; 0000045aH
  00120	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00125	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0012a	50		 push	 eax
  0012b	8d 4d bc	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0012e	51		 push	 ecx
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 6503 : 
; 6504 : 	GCServerMsgStringSend(szTemp,lpObj->m_Index,1);

  00135	8b 16		 mov	 edx, DWORD PTR [esi]
  00137	6a 01		 push	 1
  00139	52		 push	 edx
  0013a	8d 45 bc	 lea	 eax, DWORD PTR _szTemp$[ebp]
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 6505 : 	GCServerMsgStringSend(szTemp,aTargetIndex,1);

  00143	8b 4d b4	 mov	 ecx, DWORD PTR _aTargetIndex$GSCopy$[ebp]
  00146	6a 01		 push	 1
  00148	51		 push	 ecx
  00149	8d 55 bc	 lea	 edx, DWORD PTR _szTemp$[ebp]
  0014c	52		 push	 edx
  0014d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 6506 : 
; 6507 : 	LogAdd(LOG_BLACK, "[%s][%s] Set SelfDefence [%s][%s]",lpObj->AccountID,lpObj->Name,gObj[aTargetIndex].AccountID,gObj[aTargetIndex].Name);

  00152	8b 45 b8	 mov	 eax, DWORD PTR tv227[ebp]
  00155	57		 push	 edi
  00156	8d 88 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  0015c	51		 push	 ecx
  0015d	53		 push	 ebx
  0015e	83 c6 64	 add	 esi, 100		; 00000064H
  00161	56		 push	 esi
  00162	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@IPHFNLBG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5SelfDefence?5?$FL?$CFs?$FN?$FL?$CFs@
  00167	6a 00		 push	 0
  00169	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0016e	83 c4 40	 add	 esp, 64			; 00000040H
  00171	5b		 pop	 ebx
$LN25@gObjCheckS:
  00172	5f		 pop	 edi
$LN15@gObjCheckS:

; 6508 : }

  00173	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00176	33 cd		 xor	 ecx, ebp
  00178	5e		 pop	 esi
  00179	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
?gObjCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; gObjCheckSelfDefense
_TEXT	ENDS
PUBLIC	??_C@_0CE@HGMOIFIK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ReSet?5SelfDefence?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?gObjTimeCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@@Z ; gObjTimeCheckSelfDefense
;	COMDAT ??_C@_0CE@HGMOIFIK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ReSet?5SelfDefence?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0CE@HGMOIFIK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ReSet?5SelfDefence?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'%s][%s] ReSet SelfDefence [%s][%s]', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjTimeCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv147 = -72						; size = 4
_szTemp$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjTimeCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjTimeCheckSelfDefense, COMDAT

; 6516 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]

; 6520 : 	{
; 6521 : 		if ( lpObj->SelfDefense[n] >= 0 )

  00016	8d 9f 48 02 00
	00		 lea	 ebx, DWORD PTR [edi+584]
  0001c	c7 45 b8 05 00
	00 00		 mov	 DWORD PTR tv147[ebp], 5
$LL5@gObjTimeCh:
  00023	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00026	7c 76		 jl	 SHORT $LN4@gObjTimeCh

; 6522 : 		{
; 6523 : 			if ( GetTickCount() > lpObj->SelfDefenseTime[n] )

  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002e	3b 43 14	 cmp	 eax, DWORD PTR [ebx+20]
  00031	76 6b		 jbe	 SHORT $LN4@gObjTimeCh

; 6524 : 			{
; 6525 : 				wsprintf(szTemp, lMsg.Get(MSGGET(4, 91)), lpObj->Name);

  00033	8d 77 6f	 lea	 esi, DWORD PTR [edi+111]
  00036	56		 push	 esi
  00037	68 5b 04 00 00	 push	 1115			; 0000045bH
  0003c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00041	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00046	50		 push	 eax
  00047	8d 45 bc	 lea	 eax, DWORD PTR _szTemp$[ebp]
  0004a	50		 push	 eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 6526 : 				GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  00051	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00053	6a 01		 push	 1
  00055	51		 push	 ecx
  00056	8d 55 bc	 lea	 edx, DWORD PTR _szTemp$[ebp]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 6527 : 				GCServerMsgStringSend(szTemp, lpObj->SelfDefense[n], 1);

  0005f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00061	6a 01		 push	 1
  00063	50		 push	 eax
  00064	8d 4d bc	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 6528 : 				lpObj->SelfDefense[n] = -1;
; 6529 : 				
; 6530 : 				LogAdd(LOG_BLACK, "[%s][%s] ReSet SelfDefence [%s][%s]",
; 6531 : 					lpObj->AccountID, lpObj->Name,
; 6532 : 					gObj[lpObj->SelfDefense[n]].AccountID, gObj[lpObj->SelfDefense[n]].Name);

  0006d	ba 6f 00 00 00	 mov	 edx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+111
  00072	81 ea 64 15 00
	00		 sub	 edx, 5476		; 00001564H
  00078	52		 push	 edx
  00079	b8 64 00 00 00	 mov	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+100
  0007e	2d 64 15 00 00	 sub	 eax, 5476		; 00001564H
  00083	50		 push	 eax
  00084	56		 push	 esi
  00085	8d 4f 64	 lea	 ecx, DWORD PTR [edi+100]
  00088	51		 push	 ecx
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HGMOIFIK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ReSet?5SelfDefence?5?$FL?$CFs?$FN?$FL@
  0008e	6a 00		 push	 0
  00090	c7 03 ff ff ff
	ff		 mov	 DWORD PTR [ebx], -1
  00096	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0009b	83 c4 3c	 add	 esp, 60			; 0000003cH
$LN4@gObjTimeCh:

; 6517 : 	char szTemp[64];
; 6518 : 
; 6519 : 	for ( int n=0;n<MAX_SELF_DEFENSE;n++)

  0009e	83 c3 04	 add	 ebx, 4
  000a1	ff 4d b8	 dec	 DWORD PTR tv147[ebp]
  000a4	0f 85 79 ff ff
	ff		 jne	 $LL5@gObjTimeCh

; 6533 : 			}
; 6534 : 		}
; 6535 : 	}
; 6536 : }

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	33 cd		 xor	 ecx, ebp
  000b1	5b		 pop	 ebx
  000b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
?gObjTimeCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjTimeCheckSelfDefense
_TEXT	ENDS
PUBLIC	?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
EXTRN	?Attack@CObjAttack@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z:PROC ; CObjAttack::Attack
EXTRN	?gclassObjAttack@@3VCObjAttack@@A:BYTE		; gclassObjAttack
; Function compile flags: /Ogtp
;	COMDAT ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
_magicsend$ = 20					; size = 4
_MSBFlag$ = 24						; size = 1
_AttackDamage$ = 28					; size = 4
_bCombo$ = 32						; size = 4
?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z PROC ; gObjAttack, COMDAT

; 6539 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6540 : 	return gclassObjAttack.Attack(lpObj, lpTargetObj, lpMagic, magicsend, MSBFlag, AttackDamage, bCombo);

  00003	8b 45 20	 mov	 eax, DWORD PTR _bCombo$[ebp]
  00006	8b 4d 1c	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  00009	8b 55 18	 mov	 edx, DWORD PTR _MSBFlag$[ebp]
  0000c	50		 push	 eax
  0000d	8b 45 14	 mov	 eax, DWORD PTR _magicsend$[ebp]
  00010	51		 push	 ecx
  00011	8b 4d 10	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  00014	52		 push	 edx
  00015	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00018	50		 push	 eax
  00019	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	51		 push	 ecx
  0001d	52		 push	 edx
  0001e	50		 push	 eax
  0001f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gclassObjAttack@@3VCObjAttack@@A ; gclassObjAttack
  00024	e8 00 00 00 00	 call	 ?Attack@CObjAttack@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; CObjAttack::Attack

; 6541 : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ENDP ; gObjAttack
_TEXT	ENDS
PUBLIC	__real@3fc0000000000000
PUBLIC	?gObjMonsterDieLifePlus@@YAXPAUOBJECTSTRUCT@@0@Z ; gObjMonsterDieLifePlus
EXTRN	?GCManaSend@@YAXHHEEH@Z:PROC			; GCManaSend
EXTRN	?GCReFillSend@@YAXHHEE@Z:PROC			; GCReFillSend
;	COMDAT __real@3fc0000000000000
CONST	SEGMENT
__real@3fc0000000000000 DQ 03fc0000000000000r	; 0.125
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjMonsterDieLifePlus@@YAXPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
tv315 = 12						; size = 4
tv309 = 12						; size = 4
tv303 = 12						; size = 4
tv268 = 12						; size = 4
_lpTartObj$ = 12					; size = 4
?gObjMonsterDieLifePlus@@YAXPAUOBJECTSTRUCT@@0@Z PROC	; gObjMonsterDieLifePlus, COMDAT

; 6894 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6895 : 	if(lpTartObj->Level < 0 || lpTartObj->Level > 255)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _lpTartObj$[ebp]
  00006	0f b7 80 9c 00
	00 00		 movzx	 eax, WORD PTR [eax+156]
  0000d	66 85 c0	 test	 ax, ax
  00010	0f 88 2e 01 00
	00		 js	 $LN6@gObjMonste
  00016	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  0001b	66 3b c1	 cmp	 ax, cx
  0001e	0f 8f 20 01 00
	00		 jg	 $LN6@gObjMonste

; 6896 : 	{
; 6897 : 		return;
; 6898 : 	}
; 6899 : 
; 6900 : 	lpObj->Life += lpTartObj->Level;

  00024	0f bf d0	 movsx	 edx, ax
  00027	89 55 0c	 mov	 DWORD PTR tv315[ebp], edx
  0002a	56		 push	 esi
  0002b	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0002e	db 45 0c	 fild	 DWORD PTR tv315[ebp]

; 6901 : 
; 6902 : 	if(lpObj->MonsterDieGetLife != 0)

  00031	8a 86 18 01 00
	00		 mov	 al, BYTE PTR [esi+280]
  00037	d8 86 bc 00 00
	00		 fadd	 DWORD PTR [esi+188]
  0003d	d9 5d 0c	 fstp	 DWORD PTR tv268[ebp]
  00040	d9 45 0c	 fld	 DWORD PTR tv268[ebp]
  00043	d9 96 bc 00 00
	00		 fst	 DWORD PTR [esi+188]
  00049	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fc0000000000000
  0004f	84 c0		 test	 al, al
  00051	74 25		 je	 SHORT $LN12@gObjMonste

; 6903 : 	{
; 6904 : 		lpObj->Life = lpObj->Life + ((lpObj->MaxLife + lpObj->AddLife)/8.0f) * lpObj->MonsterDieGetLife;

  00053	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  00059	0f b6 c0	 movzx	 eax, al
  0005c	89 45 0c	 mov	 DWORD PTR tv309[ebp], eax
  0005f	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  00065	d8 c9		 fmul	 ST(0), ST(1)
  00067	db 45 0c	 fild	 DWORD PTR tv309[ebp]
  0006a	de c9		 fmulp	 ST(1), ST(0)
  0006c	de c2		 faddp	 ST(2), ST(0)
  0006e	d9 c9		 fxch	 ST(1)
  00070	d9 9e bc 00 00
	00		 fstp	 DWORD PTR [esi+188]
  00076	eb 02		 jmp	 SHORT $LN5@gObjMonste
$LN12@gObjMonste:
  00078	dd d9		 fstp	 ST(1)
$LN5@gObjMonste:

; 6905 : 	}
; 6906 : 
; 6907 : 	if(lpObj->MonsterDieGetMana != 0)

  0007a	8a 86 19 01 00
	00		 mov	 al, BYTE PTR [esi+281]
  00080	84 c0		 test	 al, al
  00082	74 27		 je	 SHORT $LN15@gObjMonste

; 6908 : 	{
; 6909 : 		lpObj->Mana = lpObj->Mana + ((lpObj->MaxMana + lpObj->AddMana)/8.0f) * lpObj->MonsterDieGetMana;

  00084	db 86 10 01 00
	00		 fild	 DWORD PTR [esi+272]
  0008a	0f b6 c8	 movzx	 ecx, al
  0008d	89 4d 0c	 mov	 DWORD PTR tv303[ebp], ecx
  00090	d8 86 d4 00 00
	00		 fadd	 DWORD PTR [esi+212]
  00096	de c9		 fmulp	 ST(1), ST(0)
  00098	db 45 0c	 fild	 DWORD PTR tv303[ebp]
  0009b	de c9		 fmulp	 ST(1), ST(0)
  0009d	d8 86 d0 00 00
	00		 fadd	 DWORD PTR [esi+208]
  000a3	d9 9e d0 00 00
	00		 fstp	 DWORD PTR [esi+208]
  000a9	eb 02		 jmp	 SHORT $LN4@gObjMonste
$LN15@gObjMonste:
  000ab	dd d8		 fstp	 ST(0)
$LN4@gObjMonste:

; 6910 : 	}
; 6911 : 
; 6912 : 	if(lpObj->Life > (lpObj->MaxLife + lpObj->AddLife))

  000ad	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  000b3	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  000b9	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  000bf	d8 d9		 fcomp	 ST(1)
  000c1	df e0		 fnstsw	 ax
  000c3	f6 c4 41	 test	 ah, 65			; 00000041H
  000c6	75 08		 jne	 SHORT $LN18@gObjMonste

; 6913 : 	{
; 6914 : 		lpObj->Life = lpObj->MaxLife + lpObj->AddLife;

  000c8	d9 9e bc 00 00
	00		 fstp	 DWORD PTR [esi+188]
  000ce	eb 02		 jmp	 SHORT $LN3@gObjMonste
$LN18@gObjMonste:
  000d0	dd d8		 fstp	 ST(0)
$LN3@gObjMonste:

; 6915 : 	}
; 6916 : 
; 6917 : 	GCReFillSend(lpObj->m_Index,lpObj->Life,255,0);

  000d2	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  000d8	6a 00		 push	 0
  000da	68 ff 00 00 00	 push	 255			; 000000ffH
  000df	e8 00 00 00 00	 call	 __ftol2_sse
  000e4	8b 16		 mov	 edx, DWORD PTR [esi]
  000e6	50		 push	 eax
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend
  000ed	83 c4 10	 add	 esp, 16			; 00000010H

; 6918 : 
; 6919 : 	if(lpObj->MonsterDieGetMana != 0)

  000f0	80 be 19 01 00
	00 00		 cmp	 BYTE PTR [esi+281], 0
  000f7	74 4a		 je	 SHORT $LN10@gObjMonste

; 6920 : 	{
; 6921 : 		if(lpObj->Mana > (lpObj->MaxMana + lpObj->AddMana))

  000f9	db 86 10 01 00
	00		 fild	 DWORD PTR [esi+272]
  000ff	d8 86 d4 00 00
	00		 fadd	 DWORD PTR [esi+212]
  00105	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  0010b	d8 d9		 fcomp	 ST(1)
  0010d	df e0		 fnstsw	 ax
  0010f	f6 c4 41	 test	 ah, 65			; 00000041H
  00112	75 08		 jne	 SHORT $LN21@gObjMonste

; 6922 : 		{
; 6923 : 			lpObj->Mana = lpObj->MaxMana + lpObj->AddMana;

  00114	d9 9e d0 00 00
	00		 fstp	 DWORD PTR [esi+208]
  0011a	eb 02		 jmp	 SHORT $LN1@gObjMonste
$LN21@gObjMonste:
  0011c	dd d8		 fstp	 ST(0)
$LN1@gObjMonste:

; 6924 : 		}
; 6925 : 
; 6926 : 		GCManaSend(lpObj->m_Index,lpObj->Mana,255,0,lpObj->BP);

  0011e	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR [esi+232]
  00124	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  0012a	50		 push	 eax
  0012b	6a 00		 push	 0
  0012d	68 ff 00 00 00	 push	 255			; 000000ffH
  00132	e8 00 00 00 00	 call	 __ftol2_sse
  00137	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00139	50		 push	 eax
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  00140	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@gObjMonste:
  00143	5e		 pop	 esi
$LN6@gObjMonste:

; 6927 : 	}
; 6928 : }

  00144	5d		 pop	 ebp
  00145	c3		 ret	 0
?gObjMonsterDieLifePlus@@YAXPAUOBJECTSTRUCT@@0@Z ENDP	; gObjMonsterDieLifePlus
_TEXT	ENDS
PUBLIC	??_C@_0BC@PKOGNFCH@Trade?5Commit?5?$CI?$CFs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CN@FHLLPNOD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransaction@ ; `string'
PUBLIC	??_C@_0DK@NFIOKOGL@error?5?3?5gObjInventoryCommit?$CI?$CJ?5?9?5@ ; `string'
PUBLIC	?gObjInventoryCommit@@YAHH@Z			; gObjInventoryCommit
;	COMDAT ??_C@_0BC@PKOGNFCH@Trade?5Commit?5?$CI?$CFs?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@PKOGNFCH@Trade?5Commit?5?$CI?$CFs?$CJ?$AA@ DB 'Trade Commit (%s'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FHLLPNOD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransaction@
CONST	SEGMENT
??_C@_0CN@FHLLPNOD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransaction@ DB '['
	DB	'%s][%s] error-L3 : pTransaction(%d) status2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@NFIOKOGL@error?5?3?5gObjInventoryCommit?$CI?$CJ?5?9?5@
CONST	SEGMENT
??_C@_0DK@NFIOKOGL@error?5?3?5gObjInventoryCommit?$CI?$CJ?5?9?5@ DB 'erro'
	DB	'r : gObjInventoryCommit() - aIndex out of bound %s %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjInventoryCommit@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjInventoryCommit@@YAHH@Z PROC			; gObjInventoryCommit, COMDAT

; 7407 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 7408 : 	if(!OBJMAX_RANGE(aIndex))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	78 0f		 js	 SHORT $LN13@gObjInvent
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 1e		 jne	 SHORT $LN5@gObjInvent
$LN13@gObjInvent:

; 7409 : 	{
; 7410 : 		LogAdd(LOG_BLACK, "error : gObjInventoryCommit() - aIndex out of bound %s %d",__FILE__,__LINE__);

  0001a	68 f2 1c 00 00	 push	 7410			; 00001cf2H
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@NFIOKOGL@error?5?3?5gObjInventoryCommit?$CI?$CJ?5?9?5@
  00029	6a 00		 push	 0
  0002b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00030	83 c4 10	 add	 esp, 16			; 00000010H

; 7411 : 		return false;

  00033	33 c0		 xor	 eax, eax
  00035	5b		 pop	 ebx

; 7436 : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN5@gObjInvent:

; 7412 : 	}
; 7413 : 
; 7414 : 	if(gObj[aIndex].pTransaction != 1)

  00038	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  0003e	8a 83 98 0c 00
	00		 mov	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3224]
  00044	3c 01		 cmp	 al, 1
  00046	74 26		 je	 SHORT $LN4@gObjInvent

; 7415 : 	{
; 7416 : 		LogAdd(LOG_BLACK, "[%s][%s] error-L3 : pTransaction(%d) status2",gObj[aIndex].AccountID,gObj[aIndex].Name,gObj[aIndex].pTransaction);

  00048	0f be c0	 movsx	 eax, al
  0004b	50		 push	 eax
  0004c	8d 8b 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+111]
  00052	51		 push	 ecx
  00053	8d 93 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+100]
  00059	52		 push	 edx
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@FHLLPNOD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransaction@
  0005f	6a 00		 push	 0
  00061	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00066	83 c4 14	 add	 esp, 20			; 00000014H

; 7417 : 		return false;

  00069	33 c0		 xor	 eax, eax
  0006b	5b		 pop	 ebx

; 7436 : }

  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN4@gObjInvent:
  0006e	56		 push	 esi

; 7418 : 	}
; 7419 : 
; 7420 : 	for(int n = 0; n < MAIN_INVENTORY_SIZE; n++)

  0006f	33 c0		 xor	 eax, eax
  00071	57		 push	 edi
$LL3@gObjInvent:

; 7421 : 	{
; 7422 : 		gObj[aIndex].Inventory1[n] = gObj[aIndex].Inventory2[n];

  00072	8b b3 a8 0c 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3240]
  00078	8b bb 9c 0c 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3228]
  0007e	03 f0		 add	 esi, eax
  00080	03 f8		 add	 edi, eax
  00082	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00087	f3 a5		 rep movsd
  00089	8b 8b a8 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3240]
  0008f	8b 93 9c 0c 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3228]
  00095	8d b4 08 a8 00
	00 00		 lea	 esi, DWORD PTR [eax+ecx+168]
  0009c	8d bc 10 a8 00
	00 00		 lea	 edi, DWORD PTR [eax+edx+168]
  000a3	8d 90 f8 01 00
	00		 lea	 edx, DWORD PTR [eax+504]
  000a9	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000ae	f3 a5		 rep movsd
  000b0	8b b3 a8 0c 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3240]
  000b6	8b bb 9c 0c 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3228]
  000bc	8d 8a 58 ff ff
	ff		 lea	 ecx, DWORD PTR [edx-168]
  000c2	03 f1		 add	 esi, ecx
  000c4	03 f9		 add	 edi, ecx
  000c6	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000cb	f3 a5		 rep movsd
  000cd	8b b3 a8 0c 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3240]
  000d3	8b bb 9c 0c 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3228]
  000d9	03 f2		 add	 esi, edx
  000db	03 fa		 add	 edi, edx
  000dd	05 a0 02 00 00	 add	 eax, 672		; 000002a0H
  000e2	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000e7	f3 a5		 rep movsd
  000e9	3d e0 31 00 00	 cmp	 eax, 12768		; 000031e0H
  000ee	7c 82		 jl	 SHORT $LL3@gObjInvent

; 7423 : 	}
; 7424 : 
; 7425 : 	memcpy(gObj[aIndex].InventoryMap1,gObj[aIndex].InventoryMap2,64);

  000f0	8b b3 ac 0c 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3244]
  000f6	8b bb a0 0c 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3232]
  000fc	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00101	f3 a5		 rep movsd

; 7426 : 
; 7427 : 	gObj[aIndex].InventoryCount1 = gObj[aIndex].InventoryCount2;

  00103	8a 83 b0 0c 00
	00		 mov	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3248]

; 7428 : 
; 7429 : 	gObjSetInventory1Pointer(&gObj[aIndex]);

  00109	8d 8b 00 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx]
  0010f	51		 push	 ecx
  00110	88 83 a4 0c 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3236], al
  00116	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer

; 7430 : 
; 7431 : 	gObj[aIndex].pTransaction = 2;
; 7432 : 
; 7433 : 	LogAdd(LOG_BLACK, "Trade Commit (%s)",gObj[aIndex].Name);

  0011b	8d 93 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+111]
  00121	52		 push	 edx
  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PKOGNFCH@Trade?5Commit?5?$CI?$CFs?$CJ?$AA@
  00127	6a 00		 push	 0
  00129	c6 83 98 0c 00
	00 02		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3224], 2
  00130	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00135	83 c4 10	 add	 esp, 16			; 00000010H
  00138	5f		 pop	 edi
  00139	5e		 pop	 esi

; 7434 : 
; 7435 : 	return true;

  0013a	b8 01 00 00 00	 mov	 eax, 1
  0013f	5b		 pop	 ebx

; 7436 : }

  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
?gObjInventoryCommit@@YAHH@Z ENDP			; gObjInventoryCommit
_TEXT	ENDS
PUBLIC	?gObjInventoryItemBoxSet@@YAXHHHHE@Z		; gObjInventoryItemBoxSet
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventoryItemBoxSet@@YAXHHHHE@Z
_TEXT	SEGMENT
_itemposy$ = -8						; size = 4
_y$164233 = -4						; size = 4
_aIndex$ = 8						; size = 4
tv220 = 12						; size = 4
_itempos$ = 12						; size = 4
_xl$ = 16						; size = 4
_yl$ = 20						; size = 4
_set_byte$ = 24						; size = 1
?gObjInventoryItemBoxSet@@YAXHHHHE@Z PROC		; gObjInventoryItemBoxSet, COMDAT

; 7494 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 7495 : 	int itemposx = (itempos - INVETORY_WEAR_SIZE)%8;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	53		 push	 ebx
  0000a	83 c0 f4	 add	 eax, -12		; fffffff4H
  0000d	56		 push	 esi
  0000e	8b f0		 mov	 esi, eax
  00010	81 e6 07 00 00
	80		 and	 esi, -2147483641	; 80000007H
  00016	79 05		 jns	 SHORT $LN17@gObjInvent@2
  00018	4e		 dec	 esi
  00019	83 ce f8	 or	 esi, -8			; fffffff8H
  0001c	46		 inc	 esi
$LN17@gObjInvent@2:

; 7496 : 	int itemposy = (itempos - INVETORY_WEAR_SIZE)/8;

  0001d	99		 cdq
  0001e	83 e2 07	 and	 edx, 7
  00021	03 c2		 add	 eax, edx

; 7497 : 
; 7498 : 	int xx,yy;
; 7499 : 
; 7500 : 	for(int y = 0; y < yl; y ++)

  00023	33 db		 xor	 ebx, ebx
  00025	c1 f8 03	 sar	 eax, 3
  00028	89 45 f8	 mov	 DWORD PTR _itemposy$[ebp], eax
  0002b	89 5d fc	 mov	 DWORD PTR _y$164233[ebp], ebx
  0002e	39 5d 14	 cmp	 DWORD PTR _yl$[ebp], ebx
  00031	0f 8e 82 00 00
	00		 jle	 $LN6@gObjInvent@2

; 7495 : 	int itemposx = (itempos - INVETORY_WEAR_SIZE)%8;

  00037	8b 55 10	 mov	 edx, DWORD PTR _xl$[ebp]
  0003a	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00041	89 4d 0c	 mov	 DWORD PTR tv220[ebp], ecx
  00044	57		 push	 edi
$LL8@gObjInvent@2:

; 7501 : 	{
; 7502 : 		yy = itemposy + y;
; 7503 : 
; 7504 : 		for(int x = 0; x < xl; x++)

  00045	33 c9		 xor	 ecx, ecx
  00047	8d 3c 03	 lea	 edi, DWORD PTR [ebx+eax]
  0004a	85 d2		 test	 edx, edx
  0004c	7e 3d		 jle	 SHORT $LN7@gObjInvent@2
  0004e	8b ff		 npad	 2
$LL15@gObjInvent@2:

; 7505 : 		{
; 7506 : 			xx = itemposx + x;
; 7507 : 
; 7508 : 			if(ExtentCheck(xx,yy,8,12)==1)

  00050	6a 0c		 push	 12			; 0000000cH
  00052	6a 08		 push	 8
  00054	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  00057	57		 push	 edi
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	83 f8 01	 cmp	 eax, 1
  00064	75 39		 jne	 SHORT $LN2@gObjInvent@2

; 7509 : 			{
; 7510 : 				*(BYTE*)(gObj[aIndex].pInventoryMap + (itemposy + y)*8+(itemposx + x)) = set_byte;

  00066	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00069	8a 5d 18	 mov	 bl, BYTE PTR _set_byte$[ebp]
  0006c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00072	8b 80 90 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3216]
  00078	03 45 0c	 add	 eax, DWORD PTR tv220[ebp]
  0007b	03 c1		 add	 eax, ecx
  0007d	41		 inc	 ecx
  0007e	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  00081	3b ca		 cmp	 ecx, edx
  00083	7c cb		 jl	 SHORT $LL15@gObjInvent@2

; 7501 : 	{
; 7502 : 		yy = itemposy + y;
; 7503 : 
; 7504 : 		for(int x = 0; x < xl; x++)

  00085	8b 45 f8	 mov	 eax, DWORD PTR _itemposy$[ebp]
  00088	8b 5d fc	 mov	 ebx, DWORD PTR _y$164233[ebp]
$LN7@gObjInvent@2:

; 7497 : 
; 7498 : 	int xx,yy;
; 7499 : 
; 7500 : 	for(int y = 0; y < yl; y ++)

  0008b	83 45 0c 08	 add	 DWORD PTR tv220[ebp], 8
  0008f	43		 inc	 ebx
  00090	89 5d fc	 mov	 DWORD PTR _y$164233[ebp], ebx
  00093	3b 5d 14	 cmp	 ebx, DWORD PTR _yl$[ebp]
  00096	7c ad		 jl	 SHORT $LL8@gObjInvent@2
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx

; 7515 : 				return;
; 7516 : 			}
; 7517 : 		}
; 7518 : 	}
; 7519 : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
$LN2@gObjInvent@2:

; 7511 : 			}
; 7512 : 			else
; 7513 : 			{
; 7514 : 				LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  0009f	68 5a 1d 00 00	 push	 7514			; 00001d5aH
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  000ae	6a 00		 push	 0
  000b0	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000b5	83 c4 10	 add	 esp, 16			; 00000010H
  000b8	5f		 pop	 edi
$LN6@gObjInvent@2:
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx

; 7515 : 				return;
; 7516 : 			}
; 7517 : 		}
; 7518 : 	}
; 7519 : }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
?gObjInventoryItemBoxSet@@YAXHHHHE@Z ENDP		; gObjInventoryItemBoxSet
_TEXT	ENDS
PUBLIC	??_C@_0DF@DPJDFIHG@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invento@ ; `string'
PUBLIC	??_C@_0DB@GPLONBA@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invento@ ; `string'
PUBLIC	??_C@_0EB@NEEGDNDB@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Transac@ ; `string'
PUBLIC	??_C@_0CG@KONHFAKK@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5disconn@ ; `string'
PUBLIC	?gObjFixInventoryPointer@@YA_NH@Z		; gObjFixInventoryPointer
;	COMDAT ??_C@_0DF@DPJDFIHG@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invento@
CONST	SEGMENT
??_C@_0DF@DPJDFIHG@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invento@ DB '['
	DB	'Fix Inv.Ptr] [%s][%s] - Inventory Pointer was Wrong', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GPLONBA@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invento@
CONST	SEGMENT
??_C@_0DB@GPLONBA@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invento@ DB '['
	DB	'Fix Inv.Ptr] [%s][%s] - Inventory Pointer was 2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@NEEGDNDB@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Transac@
CONST	SEGMENT
??_C@_0EB@NEEGDNDB@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Transac@ DB '['
	DB	'Fix Inv.Ptr] [%s][%s] - Transaction == 1, Do not change Point'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KONHFAKK@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5disconn@
CONST	SEGMENT
??_C@_0CG@KONHFAKK@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5disconn@ DB '['
	DB	'Fix Inv.Ptr] [%s][%s] - disconnected', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjFixInventoryPointer@@YA_NH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjFixInventoryPointer@@YA_NH@Z PROC			; gObjFixInventoryPointer, COMDAT

; 7522 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 7523 : 
; 7524 : 	if(gObjIsConnected(aIndex)==0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 2a		 jne	 SHORT $LN9@gObjFixInv

; 7525 : 	{
; 7526 : 		LogAdd(LOG_BLACK, "[Fix Inv.Ptr] [%s][%s] - disconnected",gObj[aIndex].AccountID,gObj[aIndex].Name);

  00014	8b c6		 mov	 eax, esi
  00016	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0001c	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  00022	51		 push	 ecx
  00023	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00029	52		 push	 edx
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KONHFAKK@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5disconn@
  0002f	6a 00		 push	 0
  00031	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00036	83 c4 10	 add	 esp, 16			; 00000010H

; 7559 : 
; 7560 : 	return false;

  00039	32 c0		 xor	 al, al
  0003b	5e		 pop	 esi

; 7561 : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN9@gObjFixInv:

; 7527 : 		return false;
; 7528 : 	}
; 7529 : 
; 7530 : 
; 7531 : 	if(gObj[aIndex].pInventory == gObj[aIndex].Inventory1)

  0003e	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00044	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  0004a	3b 86 9c 0c 00
	00		 cmp	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3228]
  00050	75 05		 jne	 SHORT $LN8@gObjFixInv

; 7532 : 	{
; 7533 : 		return true;

  00052	b0 01		 mov	 al, 1
  00054	5e		 pop	 esi

; 7561 : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN8@gObjFixInv:

; 7534 : 	}
; 7535 : 
; 7536 : 	if(gObj[aIndex].pInventory == gObj[aIndex].Inventory2)

  00057	3b 86 a8 0c 00
	00		 cmp	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3240]
  0005d	0f 85 7d 00 00
	00		 jne	 $LN7@gObjFixInv

; 7537 : 	{
; 7538 : 		if(gObj[aIndex].pTransaction == 1)

  00063	80 be 98 0c 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3224], 1
  0006a	75 22		 jne	 SHORT $LN6@gObjFixInv

; 7539 : 		{
; 7540 : 			LogAdd(LOG_BLACK, "[Fix Inv.Ptr] [%s][%s] - Transaction == 1, Do not change Pointer",gObj[aIndex].AccountID,gObj[aIndex].Name);

  0006c	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00072	50		 push	 eax
  00073	8d 8e 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  00079	51		 push	 ecx
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@NEEGDNDB@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Transac@
  0007f	6a 00		 push	 0
  00081	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00086	83 c4 10	 add	 esp, 16			; 00000010H

; 7559 : 
; 7560 : 	return false;

  00089	32 c0		 xor	 al, al
  0008b	5e		 pop	 esi

; 7561 : }

  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
$LN6@gObjFixInv:
  0008e	57		 push	 edi

; 7541 : 			return false;
; 7542 : 		}
; 7543 : 		else
; 7544 : 		{
; 7545 : 			LogAdd(LOG_BLACK, "[Fix Inv.Ptr] [%s][%s] - Inventory Pointer was 2",gObj[aIndex].AccountID,gObj[aIndex].Name);

  0008f	8d 96 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00095	52		 push	 edx
  00096	8d 86 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  0009c	50		 push	 eax
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@GPLONBA@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invento@
  000a2	6a 00		 push	 0
  000a4	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000a9	83 c4 10	 add	 esp, 16			; 00000010H
  000ac	33 ff		 xor	 edi, edi
  000ae	8b ff		 npad	 2
$LL4@gObjFixInv:

; 7546 : 
; 7547 : 			for(int n = 0; n < INVENTORY_SIZE; n++)
; 7548 : 			{
; 7549 : 				gObj[aIndex].Inventory2[n].Clear();

  000b0	8b 8e a8 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3240]
  000b6	03 cf		 add	 ecx, edi
  000b8	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  000bd	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  000c3	81 ff e0 46 00
	00		 cmp	 edi, 18144		; 000046e0H
  000c9	7c e5		 jl	 SHORT $LL4@gObjFixInv

; 7556 : 	}
; 7557 : 
; 7558 : 	gObjSetInventory1Pointer(&gObj[aIndex]);

  000cb	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000d1	5f		 pop	 edi
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer
  000d8	83 c4 04	 add	 esp, 4

; 7559 : 
; 7560 : 	return false;

  000db	32 c0		 xor	 al, al
  000dd	5e		 pop	 esi

; 7561 : }

  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN7@gObjFixInv:

; 7550 : 			}
; 7551 : 		}
; 7552 : 	}
; 7553 : 	else
; 7554 : 	{
; 7555 : 		LogAdd(LOG_BLACK, "[Fix Inv.Ptr] [%s][%s] - Inventory Pointer was Wrong",gObj[aIndex].AccountID,gObj[aIndex].Name);

  000e0	8d 8e 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  000e6	51		 push	 ecx
  000e7	8d 96 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  000ed	52		 push	 edx
  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@DPJDFIHG@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invento@
  000f3	6a 00		 push	 0
  000f5	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 7556 : 	}
; 7557 : 
; 7558 : 	gObjSetInventory1Pointer(&gObj[aIndex]);

  000fa	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00100	83 c4 10	 add	 esp, 16			; 00000010H
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer
  00109	83 c4 04	 add	 esp, 4

; 7559 : 
; 7560 : 	return false;

  0010c	32 c0		 xor	 al, al
  0010e	5e		 pop	 esi

; 7561 : }

  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
?gObjFixInventoryPointer@@YA_NH@Z ENDP			; gObjFixInventoryPointer
_TEXT	ENDS
PUBLIC	?gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z	; gObjInventoryItemBoxSet_PShop
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z
_TEXT	SEGMENT
_itemposy$ = -8						; size = 4
_y$164285 = -4						; size = 4
_aIndex$ = 8						; size = 4
tv220 = 12						; size = 4
_itempos$ = 12						; size = 4
_xl$ = 16						; size = 4
_yl$ = 20						; size = 4
_set_byte$ = 24						; size = 1
?gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z PROC		; gObjInventoryItemBoxSet_PShop, COMDAT

; 7586 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 7587 : 	int itemposx = (itempos - INVETORY_WEAR_SIZE)%8;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	53		 push	 ebx
  0000a	83 c0 f4	 add	 eax, -12		; fffffff4H
  0000d	56		 push	 esi
  0000e	8b f0		 mov	 esi, eax
  00010	81 e6 07 00 00
	80		 and	 esi, -2147483641	; 80000007H
  00016	79 05		 jns	 SHORT $LN17@gObjInvent@3
  00018	4e		 dec	 esi
  00019	83 ce f8	 or	 esi, -8			; fffffff8H
  0001c	46		 inc	 esi
$LN17@gObjInvent@3:

; 7588 : 	int itemposy = (itempos - INVETORY_WEAR_SIZE)/8;

  0001d	99		 cdq
  0001e	83 e2 07	 and	 edx, 7
  00021	03 c2		 add	 eax, edx

; 7589 : 
; 7590 : 	int xx,yy;
; 7591 : 
; 7592 : 	for(int y = 0; y < yl; y ++)

  00023	33 db		 xor	 ebx, ebx
  00025	c1 f8 03	 sar	 eax, 3
  00028	89 45 f8	 mov	 DWORD PTR _itemposy$[ebp], eax
  0002b	89 5d fc	 mov	 DWORD PTR _y$164285[ebp], ebx
  0002e	39 5d 14	 cmp	 DWORD PTR _yl$[ebp], ebx
  00031	0f 8e 82 00 00
	00		 jle	 $LN6@gObjInvent@3

; 7587 : 	int itemposx = (itempos - INVETORY_WEAR_SIZE)%8;

  00037	8b 55 10	 mov	 edx, DWORD PTR _xl$[ebp]
  0003a	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00041	89 4d 0c	 mov	 DWORD PTR tv220[ebp], ecx
  00044	57		 push	 edi
$LL8@gObjInvent@3:

; 7593 : 	{
; 7594 : 		yy = itemposy + y;
; 7595 : 
; 7596 : 		for(int x = 0; x < xl; x++)

  00045	33 c9		 xor	 ecx, ecx
  00047	8d 3c 03	 lea	 edi, DWORD PTR [ebx+eax]
  0004a	85 d2		 test	 edx, edx
  0004c	7e 3d		 jle	 SHORT $LN7@gObjInvent@3
  0004e	8b ff		 npad	 2
$LL15@gObjInvent@3:

; 7597 : 		{
; 7598 : 			xx = itemposx + x;
; 7599 : 
; 7600 : 			if(ExtentCheck(xx,yy,8,12)==1)

  00050	6a 0c		 push	 12			; 0000000cH
  00052	6a 08		 push	 8
  00054	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  00057	57		 push	 edi
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	83 f8 01	 cmp	 eax, 1
  00064	75 39		 jne	 SHORT $LN2@gObjInvent@3

; 7601 : 			{
; 7602 : 				*(BYTE*)(gObj[aIndex].InventoryMap1 + (itemposy + y)*8+(itemposx + x)) = set_byte;

  00066	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00069	8a 5d 18	 mov	 bl, BYTE PTR _set_byte$[ebp]
  0006c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00072	8b 80 a0 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3232]
  00078	03 45 0c	 add	 eax, DWORD PTR tv220[ebp]
  0007b	03 c1		 add	 eax, ecx
  0007d	41		 inc	 ecx
  0007e	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  00081	3b ca		 cmp	 ecx, edx
  00083	7c cb		 jl	 SHORT $LL15@gObjInvent@3

; 7593 : 	{
; 7594 : 		yy = itemposy + y;
; 7595 : 
; 7596 : 		for(int x = 0; x < xl; x++)

  00085	8b 45 f8	 mov	 eax, DWORD PTR _itemposy$[ebp]
  00088	8b 5d fc	 mov	 ebx, DWORD PTR _y$164285[ebp]
$LN7@gObjInvent@3:

; 7589 : 
; 7590 : 	int xx,yy;
; 7591 : 
; 7592 : 	for(int y = 0; y < yl; y ++)

  0008b	83 45 0c 08	 add	 DWORD PTR tv220[ebp], 8
  0008f	43		 inc	 ebx
  00090	89 5d fc	 mov	 DWORD PTR _y$164285[ebp], ebx
  00093	3b 5d 14	 cmp	 ebx, DWORD PTR _yl$[ebp]
  00096	7c ad		 jl	 SHORT $LL8@gObjInvent@3
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx

; 7607 : 				return;
; 7608 : 			}
; 7609 : 		}
; 7610 : 	}
; 7611 : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
$LN2@gObjInvent@3:

; 7603 : 			}
; 7604 : 			else
; 7605 : 			{
; 7606 : 				LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  0009f	68 b6 1d 00 00	 push	 7606			; 00001db6H
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  000ae	6a 00		 push	 0
  000b0	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000b5	83 c4 10	 add	 esp, 16			; 00000010H
  000b8	5f		 pop	 edi
$LN6@gObjInvent@3:
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx

; 7607 : 				return;
; 7608 : 			}
; 7609 : 		}
; 7610 : 	}
; 7611 : }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
?gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z ENDP		; gObjInventoryItemBoxSet_PShop
_TEXT	ENDS
PUBLIC	?gGetItemNumber@@YAKXZ				; gGetItemNumber
EXTRN	?gItemNumberCount@@3HA:DWORD			; gItemNumberCount
; Function compile flags: /Ogtp
;	COMDAT ?gGetItemNumber@@YAKXZ
_TEXT	SEGMENT
?gGetItemNumber@@YAKXZ PROC				; gGetItemNumber, COMDAT

; 7701 : 	return gItemNumberCount;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gItemNumberCount@@3HA ; gItemNumberCount

; 7702 : }

  00005	c3		 ret	 0
?gGetItemNumber@@YAKXZ ENDP				; gGetItemNumber
_TEXT	ENDS
PUBLIC	?gPlusItemNumber@@YAXXZ				; gPlusItemNumber
; Function compile flags: /Ogtp
;	COMDAT ?gPlusItemNumber@@YAXXZ
_TEXT	SEGMENT
?gPlusItemNumber@@YAXXZ PROC				; gPlusItemNumber, COMDAT

; 7706 : 	return;	// Maybe here Apply deathway fix (gItemNumberCount++)
; 7707 : }

  00000	c3		 ret	 0
?gPlusItemNumber@@YAXXZ ENDP				; gPlusItemNumber
_TEXT	ENDS
PUBLIC	?gObjSearchItem@@YAHPAUOBJECTSTRUCT@@HHH@Z	; gObjSearchItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjSearchItem@@YAHPAUOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
tv252 = -8						; size = 4
tv250 = -8						; size = 4
tv255 = -2						; size = 2
_lpObj$ = 8						; size = 4
_item_type$ = 12					; size = 4
_add_dur$ = 16						; size = 4
_nLevel$ = 20						; size = 4
?gObjSearchItem@@YAHPAUOBJECTSTRUCT@@HHH@Z PROC		; gObjSearchItem, COMDAT

; 7859 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7860 : 	for(int n = INVETORY_WEAR_SIZE; n < MAIN_INVENTORY_SIZE; n++)

  00009	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0000c	bb 0c 00 00 00	 mov	 ebx, 12			; 0000000cH
  00011	be e0 07 00 00	 mov	 esi, 2016		; 000007e0H
  00016	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL7@gObjSearch:

; 7861 : 	{
; 7862 : 		if(lpObj->pInventory[n].IsItem() == 1)

  00020	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3212]
  00026	03 ce		 add	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	75 2b		 jne	 SHORT $LN6@gObjSearch

; 7863 : 		{
; 7864 : 			if(lpObj->pInventory[n].m_Type == item_type)

  00032	8b 87 8c 0c 00
	00		 mov	 eax, DWORD PTR [edi+3212]
  00038	0f bf 4c 30 06	 movsx	 ecx, WORD PTR [eax+esi+6]
  0003d	3b 4d 0c	 cmp	 ecx, DWORD PTR _item_type$[ebp]
  00040	75 1b		 jne	 SHORT $LN6@gObjSearch

; 7865 : 			{
; 7866 : 				if(lpObj->pInventory[n].m_Level == nLevel)

  00042	0f bf 54 30 08	 movsx	 edx, WORD PTR [eax+esi+8]
  00047	3b 55 14	 cmp	 edx, DWORD PTR _nLevel$[ebp]
  0004a	75 11		 jne	 SHORT $LN6@gObjSearch

; 7867 : 				{
; 7868 : 					if((int)lpObj->pInventory[n].m_Durability + add_dur <= 3)

  0004c	d9 44 30 24	 fld	 DWORD PTR [eax+esi+36]
  00050	e8 00 00 00 00	 call	 __ftol2_sse
  00055	03 45 10	 add	 eax, DWORD PTR _add_dur$[ebp]
  00058	83 f8 03	 cmp	 eax, 3
  0005b	7e 18		 jle	 SHORT $LN11@gObjSearch
$LN6@gObjSearch:

; 7860 : 	for(int n = INVETORY_WEAR_SIZE; n < MAIN_INVENTORY_SIZE; n++)

  0005d	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00063	43		 inc	 ebx
  00064	81 fe e0 31 00
	00		 cmp	 esi, 12768		; 000031e0H
  0006a	7c b4		 jl	 SHORT $LL7@gObjSearch

; 7873 : 					}
; 7874 : 				}
; 7875 : 			}
; 7876 : 		}
; 7877 : 	}
; 7878 : 	return false;

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	33 c0		 xor	 eax, eax
  00070	5b		 pop	 ebx

; 7879 : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN11@gObjSearch:

; 7869 : 					{
; 7870 : 						lpObj->pInventory[n].m_Durability += add_dur;

  00075	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3212]
  0007b	db 45 10	 fild	 DWORD PTR _add_dur$[ebp]
  0007e	8b c3		 mov	 eax, ebx

; 7871 : 						GCItemDurSend(lpObj->m_Index,n,lpObj->pInventory[n].m_Durability,0);

  00080	d9 7d fe	 fnstcw	 WORD PTR tv255[ebp]
  00083	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00089	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  0008d	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  00091	8b 97 8c 0c 00
	00		 mov	 edx, DWORD PTR [edi+3212]
  00097	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  0009b	6a 00		 push	 0
  0009d	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  000a1	0f b7 45 fe	 movzx	 eax, WORD PTR tv255[ebp]
  000a5	8b 17		 mov	 edx, DWORD PTR [edi]
  000a7	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000ac	89 45 f8	 mov	 DWORD PTR tv252[ebp], eax
  000af	d9 6d f8	 fldcw	 WORD PTR tv252[ebp]
  000b2	db 5d f8	 fistp	 DWORD PTR tv250[ebp]
  000b5	8a 45 f8	 mov	 al, BYTE PTR tv250[ebp]
  000b8	0f b6 c8	 movzx	 ecx, al
  000bb	51		 push	 ecx
  000bc	d9 6d fe	 fldcw	 WORD PTR tv255[ebp]
  000bf	53		 push	 ebx
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  000c6	83 c4 10	 add	 esp, 16			; 00000010H
  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi

; 7872 : 						return true;

  000cb	b8 01 00 00 00	 mov	 eax, 1
  000d0	5b		 pop	 ebx

; 7879 : }

  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
?gObjSearchItem@@YAHPAUOBJECTSTRUCT@@HHH@Z ENDP		; gObjSearchItem
_TEXT	ENDS
PUBLIC	??_C@_0BB@FDAFLGGN@error?9L4?5?3?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z	; gObjSearchItemMinus
;	COMDAT ??_C@_0BB@FDAFLGGN@error?9L4?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@FDAFLGGN@error?9L4?5?3?5?$CFs?5?$CFd?$AA@ DB 'error-L4 : %s %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
tv208 = -4						; size = 4
tv206 = -4						; size = 4
_lpObj$ = 8						; size = 4
_pos$ = 12						; size = 4
tv211 = 14						; size = 2
_m_dur$ = 16						; size = 4
?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z PROC	; gObjSearchItemMinus, COMDAT

; 7887 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 7888 : 	int n = pos;
; 7889 : 	if(n < 0 || n > (MAIN_INVENTORY_SIZE-1))

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR _pos$[ebp]
  00008	85 db		 test	 ebx, ebx
  0000a	0f 88 9d 00 00
	00		 js	 $LN3@gObjSearch@2
  00010	83 fb 4b	 cmp	 ebx, 75			; 0000004bH
  00013	0f 8f 94 00 00
	00		 jg	 $LN3@gObjSearch@2

; 7893 : 	}
; 7894 : 
; 7895 : 	if(lpObj->pInventory[n].IsItem() == 1)

  00019	56		 push	 esi
  0001a	8b f3		 mov	 esi, ebx
  0001c	69 f6 a8 00 00
	00		 imul	 esi, 168		; 000000a8H
  00022	57		 push	 edi
  00023	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00026	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3212]
  0002c	03 ce		 add	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00033	83 f8 01	 cmp	 eax, 1
  00036	75 6c		 jne	 SHORT $LN1@gObjSearch@2

; 7896 : 	{
; 7897 : 		if((int)lpObj->pInventory[n].m_Durability - m_dur > 0)

  00038	8b 87 8c 0c 00
	00		 mov	 eax, DWORD PTR [edi+3212]
  0003e	d9 44 30 24	 fld	 DWORD PTR [eax+esi+36]
  00042	e8 00 00 00 00	 call	 __ftol2_sse
  00047	2b 45 10	 sub	 eax, DWORD PTR _m_dur$[ebp]
  0004a	85 c0		 test	 eax, eax
  0004c	7e 56		 jle	 SHORT $LN1@gObjSearch@2

; 7898 : 		{
; 7899 : 			lpObj->pInventory[n].m_Durability -= m_dur;

  0004e	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3212]

; 7900 : 			GCItemDurSend(lpObj->m_Index,n,lpObj->pInventory[n].m_Durability,1);

  00054	d9 7d 0e	 fnstcw	 WORD PTR tv211[ebp]
  00057	d9 44 31 24	 fld	 DWORD PTR [ecx+esi+36]
  0005b	8d 44 31 24	 lea	 eax, DWORD PTR [ecx+esi+36]
  0005f	da 65 10	 fisub	 DWORD PTR _m_dur$[ebp]
  00062	6a 01		 push	 1
  00064	d9 18		 fstp	 DWORD PTR [eax]
  00066	0f b7 45 0e	 movzx	 eax, WORD PTR tv211[ebp]
  0006a	8b 97 8c 0c 00
	00		 mov	 edx, DWORD PTR [edi+3212]
  00070	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00075	89 45 fc	 mov	 DWORD PTR tv208[ebp], eax
  00078	d9 44 32 24	 fld	 DWORD PTR [edx+esi+36]
  0007c	8b 17		 mov	 edx, DWORD PTR [edi]
  0007e	d9 6d fc	 fldcw	 WORD PTR tv208[ebp]
  00081	db 5d fc	 fistp	 DWORD PTR tv206[ebp]
  00084	8a 45 fc	 mov	 al, BYTE PTR tv206[ebp]
  00087	0f b6 c8	 movzx	 ecx, al
  0008a	51		 push	 ecx
  0008b	d9 6d 0e	 fldcw	 WORD PTR tv211[ebp]
  0008e	53		 push	 ebx
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00095	83 c4 10	 add	 esp, 16			; 00000010H
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi

; 7901 : 			return 1;

  0009a	b8 01 00 00 00	 mov	 eax, 1
  0009f	5b		 pop	 ebx

; 7905 : }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
$LN1@gObjSearch@2:
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi

; 7902 : 		}
; 7903 : 	}
; 7904 : 	return 0;

  000a6	33 c0		 xor	 eax, eax
  000a8	5b		 pop	 ebx

; 7905 : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN3@gObjSearch@2:

; 7890 : 	{
; 7891 : 		LogAdd(LOG_BLACK, "error-L4 : %s %d",__FILE__,__LINE__);

  000ad	68 d3 1e 00 00	 push	 7891			; 00001ed3H
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FDAFLGGN@error?9L4?5?3?5?$CFs?5?$CFd?$AA@
  000bc	6a 00		 push	 0
  000be	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000c3	83 c4 10	 add	 esp, 16			; 00000010H

; 7892 : 		return 1;

  000c6	b8 01 00 00 00	 mov	 eax, 1
  000cb	5b		 pop	 ebx

; 7905 : }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ENDP	; gObjSearchItemMinus
_TEXT	ENDS
PUBLIC	?gObjInventoryRectCheck@@YAEHHHHH@Z		; gObjInventoryRectCheck
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventoryRectCheck@@YAEHHHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
?gObjInventoryRectCheck@@YAEHHHHH@Z PROC		; gObjInventoryRectCheck, COMDAT

; 8192 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8193 : 	int x,y;
; 8194 : 	int blank = 0;
; 8195 : 
; 8196 : 	if(sx + width > 8)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _sx$[ebp]
  00006	8b 45 14	 mov	 eax, DWORD PTR _width$[ebp]
  00009	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  0000c	83 f9 08	 cmp	 ecx, 8
  0000f	7e 04		 jle	 SHORT $LN12@gObjInvent@4

; 8197 : 	{
; 8198 : 		return -1;

  00011	0c ff		 or	 al, 255			; 000000ffH

; 8236 : 	}
; 8237 : 	return  -1;
; 8238 : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
$LN12@gObjInvent@4:

; 8199 : 	}
; 8200 : 
; 8201 : 	if(sy + height > 12)

  00015	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00018	8b 4d 18	 mov	 ecx, DWORD PTR _height$[ebp]
  0001b	56		 push	 esi
  0001c	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  0001f	83 fe 0c	 cmp	 esi, 12			; 0000000cH
  00022	7e 05		 jle	 SHORT $LN11@gObjInvent@4

; 8202 : 	{
; 8203 : 		return -2;

  00024	b0 fe		 mov	 al, 254			; 000000feH
  00026	5e		 pop	 esi

; 8236 : 	}
; 8237 : 	return  -1;
; 8238 : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN11@gObjInvent@4:
  00029	53		 push	 ebx

; 8204 : 	}
; 8205 : 
; 8206 : 	int xx,yy;
; 8207 : 
; 8208 : 	for(y = 0; y < height; y ++)

  0002a	33 db		 xor	 ebx, ebx
  0002c	57		 push	 edi
  0002d	85 c9		 test	 ecx, ecx
  0002f	7e 52		 jle	 SHORT $LN20@gObjInvent@4
  00031	8d 3c c5 00 00
	00 00		 lea	 edi, DWORD PTR [eax*8]
$LL10@gObjInvent@4:

; 8209 : 	{
; 8210 : 
; 8211 : 		yy = sy+y;
; 8212 : 
; 8213 : 		for(x = 0; x < width; x++)

  00038	33 c9		 xor	 ecx, ecx
  0003a	8d 34 03	 lea	 esi, DWORD PTR [ebx+eax]
  0003d	39 4d 14	 cmp	 DWORD PTR _width$[ebp], ecx
  00040	7e 35		 jle	 SHORT $LN9@gObjInvent@4
$LL7@gObjInvent@4:

; 8214 : 		{
; 8215 : 			xx = sx + x;
; 8216 : 
; 8217 : 			if(ExtentCheck(xx,yy,8,12)==1)

  00042	6a 0c		 push	 12			; 0000000cH
  00044	6a 08		 push	 8
  00046	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00049	56		 push	 esi
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  00050	83 c4 10	 add	 esp, 16			; 00000010H
  00053	83 f8 01	 cmp	 eax, 1
  00056	75 34		 jne	 SHORT $LN4@gObjInvent@4

; 8218 : 			{
; 8219 : 				if(*(BYTE*)(gObj[aIndex].pInventoryMap+(sy+y)*8+(sx+x)) != 255)

  00058	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0005b	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00061	8b 80 90 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3216]
  00067	03 c7		 add	 eax, edi
  00069	03 c1		 add	 eax, ecx
  0006b	80 3c 10 ff	 cmp	 BYTE PTR [eax+edx], 255	; 000000ffH
  0006f	75 34		 jne	 SHORT $LN17@gObjInvent@4

; 8209 : 	{
; 8210 : 
; 8211 : 		yy = sy+y;
; 8212 : 
; 8213 : 		for(x = 0; x < width; x++)

  00071	41		 inc	 ecx
  00072	3b 4d 14	 cmp	 ecx, DWORD PTR _width$[ebp]
  00075	7c cb		 jl	 SHORT $LL7@gObjInvent@4
$LN9@gObjInvent@4:

; 8218 : 			{
; 8219 : 				if(*(BYTE*)(gObj[aIndex].pInventoryMap+(sy+y)*8+(sx+x)) != 255)

  00077	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  0007a	43		 inc	 ebx
  0007b	83 c7 08	 add	 edi, 8
  0007e	3b 5d 18	 cmp	 ebx, DWORD PTR _height$[ebp]
  00081	7c b5		 jl	 SHORT $LL10@gObjInvent@4
$LN20@gObjInvent@4:
  00083	5f		 pop	 edi
  00084	5b		 pop	 ebx

; 8229 : 			}
; 8230 : 		}
; 8231 : 	}
; 8232 : 
; 8233 : 	if(blank == 0)
; 8234 : 	{
; 8235 : 		return sx+sy*8+12;

  00085	8d 44 c2 0c	 lea	 eax, DWORD PTR [edx+eax*8+12]
  00089	5e		 pop	 esi

; 8236 : 	}
; 8237 : 	return  -1;
; 8238 : }

  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
$LN4@gObjInvent@4:

; 8220 : 				{
; 8221 : 					blank += 1;
; 8222 : 					return -1;
; 8223 : 				}
; 8224 : 			}
; 8225 : 			else
; 8226 : 			{
; 8227 : 				LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  0008c	68 23 20 00 00	 push	 8227			; 00002023H
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  0009b	6a 00		 push	 0
  0009d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000a2	83 c4 10	 add	 esp, 16			; 00000010H
$LN17@gObjInvent@4:

; 8228 : 				return -1;

  000a5	5f		 pop	 edi
  000a6	5b		 pop	 ebx
  000a7	0c ff		 or	 al, 255			; 000000ffH
  000a9	5e		 pop	 esi

; 8236 : 	}
; 8237 : 	return  -1;
; 8238 : }

  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
?gObjInventoryRectCheck@@YAEHHHHH@Z ENDP		; gObjInventoryRectCheck
_TEXT	ENDS
PUBLIC	?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z		; gObjOnlyInventoryRectCheck
; Function compile flags: /Ogtp
;	COMDAT ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z PROC		; gObjOnlyInventoryRectCheck, COMDAT

; 8241 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8242 : 	int x,y;
; 8243 : 	int blank = 0;
; 8244 : 
; 8245 : 	if(sx + width > 8)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _sx$[ebp]
  00006	8b 45 14	 mov	 eax, DWORD PTR _width$[ebp]
  00009	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  0000c	83 f9 08	 cmp	 ecx, 8
  0000f	7e 04		 jle	 SHORT $LN12@gObjOnlyIn

; 8246 : 	{
; 8247 : 		return -1;

  00011	0c ff		 or	 al, 255			; 000000ffH

; 8285 : 	}
; 8286 : 	return  -1;
; 8287 : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
$LN12@gObjOnlyIn:

; 8248 : 	}
; 8249 : 
; 8250 : 	if(sy + height > 8)

  00015	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00018	8b 4d 18	 mov	 ecx, DWORD PTR _height$[ebp]
  0001b	56		 push	 esi
  0001c	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  0001f	83 fe 08	 cmp	 esi, 8
  00022	7e 05		 jle	 SHORT $LN11@gObjOnlyIn

; 8251 : 	{
; 8252 : 		return -2;

  00024	b0 fe		 mov	 al, 254			; 000000feH
  00026	5e		 pop	 esi

; 8285 : 	}
; 8286 : 	return  -1;
; 8287 : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN11@gObjOnlyIn:
  00029	53		 push	 ebx

; 8253 : 	}
; 8254 : 
; 8255 : 	int xx,yy;
; 8256 : 
; 8257 : 	for(y = 0; y < height; y ++)

  0002a	33 db		 xor	 ebx, ebx
  0002c	57		 push	 edi
  0002d	85 c9		 test	 ecx, ecx
  0002f	7e 52		 jle	 SHORT $LN20@gObjOnlyIn
  00031	8d 3c c5 00 00
	00 00		 lea	 edi, DWORD PTR [eax*8]
$LL10@gObjOnlyIn:

; 8258 : 	{
; 8259 : 
; 8260 : 		yy = sy+y;
; 8261 : 
; 8262 : 		for(x = 0; x < width; x++)

  00038	33 c9		 xor	 ecx, ecx
  0003a	8d 34 03	 lea	 esi, DWORD PTR [ebx+eax]
  0003d	39 4d 14	 cmp	 DWORD PTR _width$[ebp], ecx
  00040	7e 35		 jle	 SHORT $LN9@gObjOnlyIn
$LL7@gObjOnlyIn:

; 8263 : 		{
; 8264 : 			xx = sx + x;
; 8265 : 
; 8266 : 			if(ExtentCheck(xx,yy,8,8)==1)

  00042	6a 08		 push	 8
  00044	6a 08		 push	 8
  00046	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00049	56		 push	 esi
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  00050	83 c4 10	 add	 esp, 16			; 00000010H
  00053	83 f8 01	 cmp	 eax, 1
  00056	75 34		 jne	 SHORT $LN4@gObjOnlyIn

; 8267 : 			{
; 8268 : 				if(*(BYTE*)(gObj[aIndex].pInventoryMap+(sy+y)*8+(sx+x)) != 255)

  00058	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0005b	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00061	8b 80 90 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3216]
  00067	03 c7		 add	 eax, edi
  00069	03 c1		 add	 eax, ecx
  0006b	80 3c 10 ff	 cmp	 BYTE PTR [eax+edx], 255	; 000000ffH
  0006f	75 34		 jne	 SHORT $LN17@gObjOnlyIn

; 8258 : 	{
; 8259 : 
; 8260 : 		yy = sy+y;
; 8261 : 
; 8262 : 		for(x = 0; x < width; x++)

  00071	41		 inc	 ecx
  00072	3b 4d 14	 cmp	 ecx, DWORD PTR _width$[ebp]
  00075	7c cb		 jl	 SHORT $LL7@gObjOnlyIn
$LN9@gObjOnlyIn:

; 8267 : 			{
; 8268 : 				if(*(BYTE*)(gObj[aIndex].pInventoryMap+(sy+y)*8+(sx+x)) != 255)

  00077	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  0007a	43		 inc	 ebx
  0007b	83 c7 08	 add	 edi, 8
  0007e	3b 5d 18	 cmp	 ebx, DWORD PTR _height$[ebp]
  00081	7c b5		 jl	 SHORT $LL10@gObjOnlyIn
$LN20@gObjOnlyIn:
  00083	5f		 pop	 edi
  00084	5b		 pop	 ebx

; 8278 : 			}
; 8279 : 		}
; 8280 : 	}
; 8281 : 
; 8282 : 	if(blank == 0)
; 8283 : 	{
; 8284 : 		return sx+sy*8+12;

  00085	8d 44 c2 0c	 lea	 eax, DWORD PTR [edx+eax*8+12]
  00089	5e		 pop	 esi

; 8285 : 	}
; 8286 : 	return  -1;
; 8287 : }

  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
$LN4@gObjOnlyIn:

; 8269 : 				{
; 8270 : 					blank += 1;
; 8271 : 					return -1;
; 8272 : 				}
; 8273 : 			}
; 8274 : 			else
; 8275 : 			{
; 8276 : 				LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  0008c	68 54 20 00 00	 push	 8276			; 00002054H
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  0009b	6a 00		 push	 0
  0009d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000a2	83 c4 10	 add	 esp, 16			; 00000010H
$LN17@gObjOnlyIn:

; 8277 : 				return -1;

  000a5	5f		 pop	 edi
  000a6	5b		 pop	 ebx
  000a7	0c ff		 or	 al, 255			; 000000ffH
  000a9	5e		 pop	 esi

; 8285 : 	}
; 8286 : 	return  -1;
; 8287 : }

  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ENDP		; gObjOnlyInventoryRectCheck
_TEXT	ENDS
PUBLIC	?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z ; CheckInventoryEmptySpace
; Function compile flags: /Ogtp
;	COMDAT ?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_iItemHeight$ = 12					; size = 4
_iItemWidth$ = 16					; size = 4
?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z PROC ; CheckInventoryEmptySpace, COMDAT

; 8291 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 8292 : 	int h=0;
; 8293 : 	int w=0;
; 8294 : 	BYTE blank = 0;
; 8295 : 	
; 8296 : 	for(h=0;h<8;h++)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	eb 03 8d 49 00	 npad	 5
$LL18@CheckInven:

; 8297 : 	{
; 8298 : 		for(w=0;w<8;w++)

  00010	33 f6		 xor	 esi, esi
  00012	eb 0c 8d a4 24
	00 00 00 00 eb
	03 8d 49 00	 npad	 14
$LL6@CheckInven:

; 8299 : 		{
; 8300 : 			if(*(BYTE*)(lpObj->pInventoryMap+(h)*8+(w)) == 255)

  00020	8b 8b 90 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3216]
  00026	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  0002d	03 c8		 add	 ecx, eax
  0002f	80 3c 31 ff	 cmp	 BYTE PTR [ecx+esi], 255	; 000000ffH
  00033	75 1d		 jne	 SHORT $LN5@CheckInven

; 8301 : 			{
; 8302 : 				blank = gObjOnlyInventoryRectCheck(lpObj->m_Index, w, h, iItemWidth, iItemHeight);

  00035	8b 55 0c	 mov	 edx, DWORD PTR _iItemHeight$[ebp]
  00038	8b 45 10	 mov	 eax, DWORD PTR _iItemWidth$[ebp]
  0003b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0003d	52		 push	 edx
  0003e	50		 push	 eax
  0003f	57		 push	 edi
  00040	56		 push	 esi
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ; gObjOnlyInventoryRectCheck
  00047	83 c4 14	 add	 esp, 20			; 00000014H

; 8303 : 
; 8304 : 				if ( blank == 0xFE )

  0004a	3c fe		 cmp	 al, 254			; 000000feH
  0004c	74 10		 je	 SHORT $LN7@CheckInven

; 8305 : 					return FALSE;
; 8306 : 
; 8307 : 				if ( blank != 0xFF )

  0004e	3c ff		 cmp	 al, 255			; 000000ffH
  00050	75 13		 jne	 SHORT $LN15@CheckInven
$LN5@CheckInven:

; 8297 : 	{
; 8298 : 		for(w=0;w<8;w++)

  00052	46		 inc	 esi
  00053	83 fe 08	 cmp	 esi, 8
  00056	7c c8		 jl	 SHORT $LL6@CheckInven

; 8292 : 	int h=0;
; 8293 : 	int w=0;
; 8294 : 	BYTE blank = 0;
; 8295 : 	
; 8296 : 	for(h=0;h<8;h++)

  00058	47		 inc	 edi
  00059	83 ff 08	 cmp	 edi, 8
  0005c	7c b2		 jl	 SHORT $LL18@CheckInven
$LN7@CheckInven:
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 8309 : 			}
; 8310 : 		}
; 8311 : 	}
; 8312 : 
; 8313 : 	return FALSE;

  00060	33 c0		 xor	 eax, eax
  00062	5b		 pop	 ebx

; 8314 : }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN15@CheckInven:
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 8308 : 					return TRUE;

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	5b		 pop	 ebx

; 8314 : }

  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z ENDP ; CheckInventoryEmptySpace
_TEXT	ENDS
PUBLIC	?gObjWerehouseRectCheck@@YAEHHHHH@Z		; gObjWerehouseRectCheck
; Function compile flags: /Ogtp
;	COMDAT ?gObjWerehouseRectCheck@@YAEHHHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
?gObjWerehouseRectCheck@@YAEHHHHH@Z PROC		; gObjWerehouseRectCheck, COMDAT

; 8585 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8586 : 	int x,y;
; 8587 : 	int blank = 0;
; 8588 : 
; 8589 : 	if(sx + width > 8)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _sx$[ebp]
  00006	8b 45 14	 mov	 eax, DWORD PTR _width$[ebp]
  00009	03 c2		 add	 eax, edx
  0000b	83 f8 08	 cmp	 eax, 8
  0000e	7e 04		 jle	 SHORT $LN14@gObjWereho
$LN28@gObjWereho:

; 8590 : 	{
; 8591 : 		return -1;

  00010	0c ff		 or	 al, 255			; 000000ffH

; 8641 : 	}
; 8642 : 	return  -1;
; 8643 : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
$LN14@gObjWereho:

; 8592 : 	}
; 8593 : 
; 8594 : 	if(sx + width < 0)

  00014	85 c0		 test	 eax, eax

; 8595 : 	{
; 8596 : 		return -1;

  00016	78 f8		 js	 SHORT $LN28@gObjWereho

; 8597 : 	}
; 8598 : 
; 8599 : 	if(sy + height > 15)

  00018	8b 4d 10	 mov	 ecx, DWORD PTR _sy$[ebp]
  0001b	56		 push	 esi
  0001c	8b 75 18	 mov	 esi, DWORD PTR _height$[ebp]
  0001f	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  00022	83 f8 0f	 cmp	 eax, 15			; 0000000fH

; 8600 : 	{
; 8601 : 		return -1;

  00025	7f 04		 jg	 SHORT $LN27@gObjWereho

; 8602 : 	}
; 8603 : 
; 8604 : 	if(sy + height < 0)

  00027	85 c0		 test	 eax, eax
  00029	79 05		 jns	 SHORT $LN11@gObjWereho
$LN27@gObjWereho:

; 8605 : 	{
; 8606 : 		return -1;

  0002b	0c ff		 or	 al, 255			; 000000ffH
  0002d	5e		 pop	 esi

; 8641 : 	}
; 8642 : 	return  -1;
; 8643 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN11@gObjWereho:
  00030	53		 push	 ebx

; 8607 : 	}
; 8608 : 
; 8609 : 	int xx,yy;
; 8610 : 
; 8611 : 	LPOBJ lpObj = &gObj[aIndex];
; 8612 : 
; 8613 : 	for(y = 0; y < height; y ++)

  00031	33 db		 xor	 ebx, ebx
  00033	57		 push	 edi
  00034	85 f6		 test	 esi, esi
  00036	7e 59		 jle	 SHORT $LN22@gObjWereho
  00038	8d 3c cd 00 00
	00 00		 lea	 edi, DWORD PTR [ecx*8]
  0003f	90		 npad	 1
$LL10@gObjWereho:

; 8614 : 	{
; 8615 : 
; 8616 : 		yy = sy+y;

  00040	8d 34 0b	 lea	 esi, DWORD PTR [ebx+ecx]

; 8617 : 
; 8618 : 		for(x = 0; x < width; x++)

  00043	33 c9		 xor	 ecx, ecx
  00045	39 4d 14	 cmp	 DWORD PTR _width$[ebp], ecx
  00048	7e 3b		 jle	 SHORT $LN9@gObjWereho
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL7@gObjWereho:

; 8619 : 		{
; 8620 : 			xx = sx + x;
; 8621 : 
; 8622 : 			if(ExtentCheck(xx,yy,8,15)==1)

  00050	6a 0f		 push	 15			; 0000000fH
  00052	6a 08		 push	 8
  00054	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00057	56		 push	 esi
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	83 f8 01	 cmp	 eax, 1
  00064	75 33		 jne	 SHORT $LN4@gObjWereho

; 8623 : 			{
; 8624 : 				if(*(BYTE*)(gObj[aIndex].pWarehouseMap+(sy+y)*8+(sx+x)) != 255)

  00066	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00069	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0006f	8b 80 c8 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3272]
  00075	03 c7		 add	 eax, edi
  00077	03 c1		 add	 eax, ecx
  00079	80 3c 10 ff	 cmp	 BYTE PTR [eax+edx], 255	; 000000ffH
  0007d	75 33		 jne	 SHORT $LN19@gObjWereho

; 8617 : 
; 8618 : 		for(x = 0; x < width; x++)

  0007f	41		 inc	 ecx
  00080	3b 4d 14	 cmp	 ecx, DWORD PTR _width$[ebp]
  00083	7c cb		 jl	 SHORT $LL7@gObjWereho
$LN9@gObjWereho:

; 8623 : 			{
; 8624 : 				if(*(BYTE*)(gObj[aIndex].pWarehouseMap+(sy+y)*8+(sx+x)) != 255)

  00085	8b 4d 10	 mov	 ecx, DWORD PTR _sy$[ebp]
  00088	43		 inc	 ebx
  00089	83 c7 08	 add	 edi, 8
  0008c	3b 5d 18	 cmp	 ebx, DWORD PTR _height$[ebp]
  0008f	7c af		 jl	 SHORT $LL10@gObjWereho
$LN22@gObjWereho:
  00091	5f		 pop	 edi
  00092	5b		 pop	 ebx

; 8634 : 			}
; 8635 : 		}
; 8636 : 	}
; 8637 : 
; 8638 : 	if(blank == 0)
; 8639 : 	{
; 8640 : 		return sx+sy*8;

  00093	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  00096	5e		 pop	 esi

; 8641 : 	}
; 8642 : 	return  -1;
; 8643 : }

  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
$LN4@gObjWereho:

; 8625 : 				{
; 8626 : 					blank += 1;
; 8627 : 					return -1;
; 8628 : 				}
; 8629 : 			}
; 8630 : 			else
; 8631 : 			{
; 8632 : 				LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  00099	68 b8 21 00 00	 push	 8632			; 000021b8H
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  000a8	6a 00		 push	 0
  000aa	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000af	83 c4 10	 add	 esp, 16			; 00000010H
$LN19@gObjWereho:

; 8633 : 				return -1;

  000b2	5f		 pop	 edi
  000b3	5b		 pop	 ebx
  000b4	0c ff		 or	 al, 255			; 000000ffH
  000b6	5e		 pop	 esi

; 8641 : 	}
; 8642 : 	return  -1;
; 8643 : }

  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
?gObjWerehouseRectCheck@@YAEHHHHH@Z ENDP		; gObjWerehouseRectCheck
_TEXT	ENDS
PUBLIC	?gObjMapRectCheck@@YAEPAEHHHHHH@Z		; gObjMapRectCheck
; Function compile flags: /Ogtp
;	COMDAT ?gObjMapRectCheck@@YAEPAEHHHHHH@Z
_TEXT	SEGMENT
_lpMapBuf$ = 8						; size = 4
_y$ = 12						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_ex$ = 20						; size = 4
_ey$ = 24						; size = 4
_width$ = 28						; size = 4
_height$ = 32						; size = 4
?gObjMapRectCheck@@YAEPAEHHHHHH@Z PROC			; gObjMapRectCheck, COMDAT

; 8646 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8647 : 	int x,y;
; 8648 : 	int blank = 0;
; 8649 : 
; 8650 : 	if(sx + width > ex || sx + width < 0)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _sx$[ebp]
  00006	8b 45 1c	 mov	 eax, DWORD PTR _width$[ebp]
  00009	57		 push	 edi
  0000a	8b 7d 14	 mov	 edi, DWORD PTR _ex$[ebp]
  0000d	03 c2		 add	 eax, edx
  0000f	3b c7		 cmp	 eax, edi
  00011	0f 8f b3 00 00
	00		 jg	 $LN13@gObjMapRec
  00017	85 c0		 test	 eax, eax
  00019	0f 88 ab 00 00
	00		 js	 $LN13@gObjMapRec

; 8653 : 	}
; 8654 : 
; 8655 : 	if(sy + height > ey || sy + height < 0)

  0001f	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00022	56		 push	 esi
  00023	8b 75 20	 mov	 esi, DWORD PTR _height$[ebp]
  00026	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00029	3b 4d 18	 cmp	 ecx, DWORD PTR _ey$[ebp]
  0002c	0f 8f 92 00 00
	00		 jg	 $LN11@gObjMapRec
  00032	85 c9		 test	 ecx, ecx
  00034	0f 88 8a 00 00
	00		 js	 $LN11@gObjMapRec

; 8658 : 	}
; 8659 : 
; 8660 : 	int xx,yy;
; 8661 : 
; 8662 : 	for(y = 0; y < height; y++)

  0003a	53		 push	 ebx
  0003b	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00042	85 f6		 test	 esi, esi
  00044	7e 54		 jle	 SHORT $LN22@gObjMapRec
  00046	8b d8		 mov	 ebx, eax
  00048	0f af df	 imul	 ebx, edi
  0004b	eb 03 8d 49 00	 npad	 5
$LL10@gObjMapRec:

; 8663 : 	{
; 8664 : 		yy = sy + y;

  00050	8b 75 0c	 mov	 esi, DWORD PTR _y$[ebp]

; 8665 : 
; 8666 : 		for(x = 0; x < width; x++)

  00053	33 c9		 xor	 ecx, ecx
  00055	03 f0		 add	 esi, eax
  00057	39 4d 1c	 cmp	 DWORD PTR _width$[ebp], ecx
  0005a	7e 2d		 jle	 SHORT $LN9@gObjMapRec
  0005c	8d 64 24 00	 npad	 4
$LL23@gObjMapRec:

; 8667 : 		{
; 8668 : 			xx = sx + x;
; 8669 : 
; 8670 : 			if(ExtentCheck(xx,yy,ex,ey)==1)

  00060	8b 45 18	 mov	 eax, DWORD PTR _ey$[ebp]
  00063	50		 push	 eax
  00064	57		 push	 edi
  00065	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00068	56		 push	 esi
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  0006f	83 c4 10	 add	 esp, 16			; 00000010H
  00072	83 f8 01	 cmp	 eax, 1
  00075	75 2d		 jne	 SHORT $LN4@gObjMapRec

; 8671 : 			{
; 8672 : 				if(*(BYTE*)(lpMapBuf + (sy + y)*ex + (sx+x)) != 255)

  00077	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  0007a	03 45 08	 add	 eax, DWORD PTR _lpMapBuf$[ebp]
  0007d	80 3c 10 ff	 cmp	 BYTE PTR [eax+edx], 255	; 000000ffH
  00081	75 3a		 jne	 SHORT $LN19@gObjMapRec

; 8665 : 
; 8666 : 		for(x = 0; x < width; x++)

  00083	41		 inc	 ecx
  00084	3b 4d 1c	 cmp	 ecx, DWORD PTR _width$[ebp]
  00087	7c d7		 jl	 SHORT $LL23@gObjMapRec
$LN9@gObjMapRec:

; 8658 : 	}
; 8659 : 
; 8660 : 	int xx,yy;
; 8661 : 
; 8662 : 	for(y = 0; y < height; y++)

  00089	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0008c	40		 inc	 eax
  0008d	03 df		 add	 ebx, edi
  0008f	3b 45 20	 cmp	 eax, DWORD PTR _height$[ebp]
  00092	89 45 0c	 mov	 DWORD PTR _y$[ebp], eax

; 8671 : 			{
; 8672 : 				if(*(BYTE*)(lpMapBuf + (sy + y)*ex + (sx+x)) != 255)

  00095	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00098	7c b6		 jl	 SHORT $LL10@gObjMapRec
$LN22@gObjMapRec:

; 8682 : 			}
; 8683 : 		}
; 8684 : 	}
; 8685 : 
; 8686 : 	if(blank == 0)
; 8687 : 	{
; 8688 : 		return sy*ex+sx;

  0009a	0f af c7	 imul	 eax, edi
  0009d	5b		 pop	 ebx
  0009e	5e		 pop	 esi
  0009f	03 c2		 add	 eax, edx
  000a1	5f		 pop	 edi

; 8689 : 	}
; 8690 : 	return  -1;
; 8691 : 
; 8692 : 	return -1;
; 8693 : }

  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
$LN4@gObjMapRec:

; 8673 : 				{
; 8674 : 					blank += 1;
; 8675 : 					return -1;
; 8676 : 				}
; 8677 : 			}
; 8678 : 			else
; 8679 : 			{
; 8680 : 				LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  000a4	68 e8 21 00 00	 push	 8680			; 000021e8H
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  000b3	6a 00		 push	 0
  000b5	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000ba	83 c4 10	 add	 esp, 16			; 00000010H
$LN19@gObjMapRec:

; 8681 : 				return -1;

  000bd	5b		 pop	 ebx
  000be	5e		 pop	 esi
  000bf	0c ff		 or	 al, 255			; 000000ffH
  000c1	5f		 pop	 edi

; 8689 : 	}
; 8690 : 	return  -1;
; 8691 : 
; 8692 : 	return -1;
; 8693 : }

  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
$LN11@gObjMapRec:
  000c4	5e		 pop	 esi

; 8656 : 	{
; 8657 : 		return -1;

  000c5	0c ff		 or	 al, 255			; 000000ffH
  000c7	5f		 pop	 edi

; 8689 : 	}
; 8690 : 	return  -1;
; 8691 : 
; 8692 : 	return -1;
; 8693 : }

  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
$LN13@gObjMapRec:

; 8651 : 	{
; 8652 : 		return -1;

  000ca	0c ff		 or	 al, 255			; 000000ffH
  000cc	5f		 pop	 edi

; 8689 : 	}
; 8690 : 	return  -1;
; 8691 : 
; 8692 : 	return -1;
; 8693 : }

  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
?gObjMapRectCheck@@YAEPAEHHHHHH@Z ENDP			; gObjMapRectCheck
_TEXT	ENDS
PUBLIC	??_C@_0BF@PBCPKOJP@error?5?3?5?$CFd?1?$CFd?5?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	?gObjWarehouseItemBoxSet@@YAXHHHHE@Z		; gObjWarehouseItemBoxSet
;	COMDAT ??_C@_0BF@PBCPKOJP@error?5?3?5?$CFd?1?$CFd?5?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BF@PBCPKOJP@error?5?3?5?$CFd?1?$CFd?5?5?$CFs?5?$CFd?$AA@ DB 'error'
	DB	' : %d/%d  %s %d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjWarehouseItemBoxSet@@YAXHHHHE@Z
_TEXT	SEGMENT
_itemposy$ = -8						; size = 4
_y$164843 = -4						; size = 4
_aIndex$ = 8						; size = 4
tv223 = 12						; size = 4
_itempos$ = 12						; size = 4
_xl$ = 16						; size = 4
_yl$ = 20						; size = 4
_set_byte$ = 24						; size = 1
?gObjWarehouseItemBoxSet@@YAXHHHHE@Z PROC		; gObjWarehouseItemBoxSet, COMDAT

; 8696 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8697 : 	int itemposx = (itempos)%8;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f0		 mov	 esi, eax
  0000c	81 e6 07 00 00
	80		 and	 esi, -2147483641	; 80000007H
  00012	79 05		 jns	 SHORT $LN17@gObjWareho@2
  00014	4e		 dec	 esi
  00015	83 ce f8	 or	 esi, -8			; fffffff8H
  00018	46		 inc	 esi
$LN17@gObjWareho@2:

; 8698 : 	int itemposy = (itempos)/8;

  00019	99		 cdq
  0001a	83 e2 07	 and	 edx, 7
  0001d	03 c2		 add	 eax, edx

; 8699 : 
; 8700 : 	int xx,yy;
; 8701 : 
; 8702 : 	for(int y = 0; y < yl; y ++)

  0001f	33 d2		 xor	 edx, edx
  00021	c1 f8 03	 sar	 eax, 3
  00024	89 45 f8	 mov	 DWORD PTR _itemposy$[ebp], eax
  00027	89 55 fc	 mov	 DWORD PTR _y$164843[ebp], edx
  0002a	39 55 14	 cmp	 DWORD PTR _yl$[ebp], edx
  0002d	0f 8e 89 00 00
	00		 jle	 $LN6@gObjWareho@2

; 8697 : 	int itemposx = (itempos)%8;

  00033	53		 push	 ebx
  00034	8b 5d 10	 mov	 ebx, DWORD PTR _xl$[ebp]
  00037	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0003e	89 4d 0c	 mov	 DWORD PTR tv223[ebp], ecx
  00041	57		 push	 edi
$LL8@gObjWareho@2:

; 8703 : 	{
; 8704 : 		yy = itemposy + y;
; 8705 : 
; 8706 : 		for(int x = 0; x < xl; x++)

  00042	33 c9		 xor	 ecx, ecx
  00044	8d 3c 02	 lea	 edi, DWORD PTR [edx+eax]
  00047	85 db		 test	 ebx, ebx
  00049	7e 40		 jle	 SHORT $LN7@gObjWareho@2
  0004b	eb 03 8d 49 00	 npad	 5
$LL5@gObjWareho@2:

; 8707 : 		{
; 8708 : 			xx = itemposx + x;
; 8709 : 
; 8710 : 			if(ExtentCheck(xx,yy,8,15)==1)

  00050	6a 0f		 push	 15			; 0000000fH
  00052	6a 08		 push	 8
  00054	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]
  00057	57		 push	 edi
  00058	52		 push	 edx
  00059	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	83 f8 01	 cmp	 eax, 1
  00064	75 39		 jne	 SHORT $LN2@gObjWareho@2

; 8711 : 			{
; 8712 : 				*(BYTE*)(gObj[aIndex].pWarehouseMap + (itemposy + y)*8+(itemposx + x)) = set_byte;

  00066	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00069	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  0006f	8b 82 c8 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3272]
  00075	03 45 0c	 add	 eax, DWORD PTR tv223[ebp]
  00078	8a 55 18	 mov	 dl, BYTE PTR _set_byte$[ebp]
  0007b	03 c1		 add	 eax, ecx
  0007d	41		 inc	 ecx
  0007e	88 14 30	 mov	 BYTE PTR [eax+esi], dl
  00081	3b cb		 cmp	 ecx, ebx
  00083	7c cb		 jl	 SHORT $LL5@gObjWareho@2

; 8703 : 	{
; 8704 : 		yy = itemposy + y;
; 8705 : 
; 8706 : 		for(int x = 0; x < xl; x++)

  00085	8b 45 f8	 mov	 eax, DWORD PTR _itemposy$[ebp]
  00088	8b 55 fc	 mov	 edx, DWORD PTR _y$164843[ebp]
$LN7@gObjWareho@2:

; 8699 : 
; 8700 : 	int xx,yy;
; 8701 : 
; 8702 : 	for(int y = 0; y < yl; y ++)

  0008b	83 45 0c 08	 add	 DWORD PTR tv223[ebp], 8
  0008f	42		 inc	 edx
  00090	89 55 fc	 mov	 DWORD PTR _y$164843[ebp], edx
  00093	3b 55 14	 cmp	 edx, DWORD PTR _yl$[ebp]
  00096	7c aa		 jl	 SHORT $LL8@gObjWareho@2
  00098	5f		 pop	 edi
  00099	5b		 pop	 ebx
  0009a	5e		 pop	 esi

; 8717 : 				return;
; 8718 : 			}
; 8719 : 		}
; 8720 : 	}
; 8721 : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
$LN2@gObjWareho@2:

; 8713 : 			}
; 8714 : 			else
; 8715 : 			{
; 8716 : 				LogAdd(LOG_BLACK, "error : %d/%d  %s %d",xx,yy,__FILE__,__LINE__);

  0009f	68 0c 22 00 00	 push	 8716			; 0000220cH
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  000a9	57		 push	 edi
  000aa	52		 push	 edx
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PBCPKOJP@error?5?3?5?$CFd?1?$CFd?5?5?$CFs?5?$CFd?$AA@
  000b0	6a 00		 push	 0
  000b2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000b7	83 c4 18	 add	 esp, 24			; 00000018H
  000ba	5f		 pop	 edi
  000bb	5b		 pop	 ebx
$LN6@gObjWareho@2:
  000bc	5e		 pop	 esi

; 8717 : 				return;
; 8718 : 			}
; 8719 : 		}
; 8720 : 	}
; 8721 : }

  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
?gObjWarehouseItemBoxSet@@YAXHHHHE@Z ENDP		; gObjWarehouseItemBoxSet
_TEXT	ENDS
PUBLIC	?gObjWarehouseItemSet@@YAXHHE@Z			; gObjWarehouseItemSet
EXTRN	?GetSize@CItem@@QAEHAAH0@Z:PROC			; CItem::GetSize
; Function compile flags: /Ogtp
;	COMDAT ?gObjWarehouseItemSet@@YAXHHE@Z
_TEXT	SEGMENT
_width$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_height$ = 12						; size = 4
_itempos$ = 12						; size = 4
_set_byte$ = 16						; size = 1
?gObjWarehouseItemSet@@YAXHHE@Z PROC			; gObjWarehouseItemSet, COMDAT

; 8724 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 8725 : 	int width;
; 8726 : 	int height;
; 8727 : 	if(itempos < 0)

  00005	8b 75 0c	 mov	 esi, DWORD PTR _itempos$[ebp]
  00008	83 fe 77	 cmp	 esi, 119		; 00000077H
  0000b	77 6c		 ja	 SHORT $LN5@gObjWareho@3

; 8728 : 	{
; 8729 : 		return;
; 8730 : 	}
; 8731 : 	else if(itempos > (WAREHOUSE_SIZE-1))
; 8732 : 	{
; 8733 : 		return;
; 8734 : 	}
; 8735 : 
; 8736 : 	if(gObj[aIndex].pWarehouse[itempos].GetSize((int&)width,(int &)height)==0)

  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00011	8d 45 0c	 lea	 eax, DWORD PTR _height$[ebp]
  00014	50		 push	 eax
  00015	8d 4d fc	 lea	 ecx, DWORD PTR _width$[ebp]
  00018	51		 push	 ecx
  00019	8b d7		 mov	 edx, edi
  0001b	8b ce		 mov	 ecx, esi
  0001d	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00023	69 c9 a8 00 00
	00		 imul	 ecx, 168		; 000000a8H
  00029	03 8a c4 0c 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3268]
  0002f	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00034	85 c0		 test	 eax, eax
  00036	75 2a		 jne	 SHORT $LN1@gObjWareho@3

; 8737 : 	{
; 8738 : 		LogAdd(LOG_BLACK, lMsg.Get(527),__FILE__,__LINE__);

  00038	68 22 22 00 00	 push	 8738			; 00002222H
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00042	68 0f 02 00 00	 push	 527			; 0000020fH
  00047	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0004c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00051	50		 push	 eax
  00052	6a 00		 push	 0
  00054	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi

; 8743 : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$LN1@gObjWareho@3:

; 8739 : 		return;
; 8740 : 	}
; 8741 : 
; 8742 : 	gObjWarehouseItemBoxSet(aIndex,itempos,width,height,set_byte);

  00062	8b 45 10	 mov	 eax, DWORD PTR _set_byte$[ebp]
  00065	8b 4d 0c	 mov	 ecx, DWORD PTR _height$[ebp]
  00068	8b 55 fc	 mov	 edx, DWORD PTR _width$[ebp]
  0006b	50		 push	 eax
  0006c	51		 push	 ecx
  0006d	52		 push	 edx
  0006e	56		 push	 esi
  0006f	57		 push	 edi
  00070	e8 00 00 00 00	 call	 ?gObjWarehouseItemBoxSet@@YAXHHHHE@Z ; gObjWarehouseItemBoxSet
  00075	83 c4 14	 add	 esp, 20			; 00000014H
  00078	5f		 pop	 edi
$LN5@gObjWareho@3:
  00079	5e		 pop	 esi

; 8743 : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?gObjWarehouseItemSet@@YAXHHE@Z ENDP			; gObjWarehouseItemSet
_TEXT	ENDS
PUBLIC	?gObjChaosItemBoxSet@@YAXHHHHE@Z		; gObjChaosItemBoxSet
; Function compile flags: /Ogtp
;	COMDAT ?gObjChaosItemBoxSet@@YAXHHHHE@Z
_TEXT	SEGMENT
_itemposy$ = -8						; size = 4
_y$164879 = -4						; size = 4
_aIndex$ = 8						; size = 4
tv223 = 12						; size = 4
_itempos$ = 12						; size = 4
_xl$ = 16						; size = 4
_yl$ = 20						; size = 4
_set_byte$ = 24						; size = 1
?gObjChaosItemBoxSet@@YAXHHHHE@Z PROC			; gObjChaosItemBoxSet, COMDAT

; 8746 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8747 : 	int itemposx = (itempos)%8;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f0		 mov	 esi, eax
  0000c	81 e6 07 00 00
	80		 and	 esi, -2147483641	; 80000007H
  00012	79 05		 jns	 SHORT $LN17@gObjChaosI
  00014	4e		 dec	 esi
  00015	83 ce f8	 or	 esi, -8			; fffffff8H
  00018	46		 inc	 esi
$LN17@gObjChaosI:

; 8748 : 	int itemposy = (itempos)/8;

  00019	99		 cdq
  0001a	83 e2 07	 and	 edx, 7
  0001d	03 c2		 add	 eax, edx

; 8749 : 
; 8750 : 	int xx,yy;
; 8751 : 
; 8752 : 	for(int y = 0; y < yl; y ++)

  0001f	33 d2		 xor	 edx, edx
  00021	c1 f8 03	 sar	 eax, 3
  00024	89 45 f8	 mov	 DWORD PTR _itemposy$[ebp], eax
  00027	89 55 fc	 mov	 DWORD PTR _y$164879[ebp], edx
  0002a	39 55 14	 cmp	 DWORD PTR _yl$[ebp], edx
  0002d	0f 8e 89 00 00
	00		 jle	 $LN6@gObjChaosI

; 8747 : 	int itemposx = (itempos)%8;

  00033	53		 push	 ebx
  00034	8b 5d 10	 mov	 ebx, DWORD PTR _xl$[ebp]
  00037	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0003e	89 4d 0c	 mov	 DWORD PTR tv223[ebp], ecx
  00041	57		 push	 edi
$LL8@gObjChaosI:

; 8753 : 	{
; 8754 : 		yy = itemposy + y;
; 8755 : 
; 8756 : 		for(int x = 0; x < xl; x++)

  00042	33 c9		 xor	 ecx, ecx
  00044	8d 3c 02	 lea	 edi, DWORD PTR [edx+eax]
  00047	85 db		 test	 ebx, ebx
  00049	7e 40		 jle	 SHORT $LN7@gObjChaosI
  0004b	eb 03 8d 49 00	 npad	 5
$LL5@gObjChaosI:

; 8757 : 		{
; 8758 : 			xx = itemposx + x;
; 8759 : 
; 8760 : 			if(ExtentCheck(xx,yy,8,4)==1)

  00050	6a 04		 push	 4
  00052	6a 08		 push	 8
  00054	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]
  00057	57		 push	 edi
  00058	52		 push	 edx
  00059	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	83 f8 01	 cmp	 eax, 1
  00064	75 39		 jne	 SHORT $LN2@gObjChaosI

; 8761 : 			{
; 8762 : 				*(BYTE*)(gObj[aIndex].pChaosBoxMap + (itemposy + y)*8+(itemposx + x)) = set_byte;

  00066	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00069	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  0006f	8b 82 e0 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3296]
  00075	03 45 0c	 add	 eax, DWORD PTR tv223[ebp]
  00078	8a 55 18	 mov	 dl, BYTE PTR _set_byte$[ebp]
  0007b	03 c1		 add	 eax, ecx
  0007d	41		 inc	 ecx
  0007e	88 14 30	 mov	 BYTE PTR [eax+esi], dl
  00081	3b cb		 cmp	 ecx, ebx
  00083	7c cb		 jl	 SHORT $LL5@gObjChaosI

; 8753 : 	{
; 8754 : 		yy = itemposy + y;
; 8755 : 
; 8756 : 		for(int x = 0; x < xl; x++)

  00085	8b 45 f8	 mov	 eax, DWORD PTR _itemposy$[ebp]
  00088	8b 55 fc	 mov	 edx, DWORD PTR _y$164879[ebp]
$LN7@gObjChaosI:

; 8749 : 
; 8750 : 	int xx,yy;
; 8751 : 
; 8752 : 	for(int y = 0; y < yl; y ++)

  0008b	83 45 0c 08	 add	 DWORD PTR tv223[ebp], 8
  0008f	42		 inc	 edx
  00090	89 55 fc	 mov	 DWORD PTR _y$164879[ebp], edx
  00093	3b 55 14	 cmp	 edx, DWORD PTR _yl$[ebp]
  00096	7c aa		 jl	 SHORT $LL8@gObjChaosI
  00098	5f		 pop	 edi
  00099	5b		 pop	 ebx
  0009a	5e		 pop	 esi

; 8767 : 				return;
; 8768 : 			}
; 8769 : 		}
; 8770 : 	}
; 8771 : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
$LN2@gObjChaosI:

; 8763 : 			}
; 8764 : 			else
; 8765 : 			{
; 8766 : 				LogAdd(LOG_BLACK, "error : %d/%d  %s %d",xx,yy,__FILE__,__LINE__);

  0009f	68 3e 22 00 00	 push	 8766			; 0000223eH
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  000a9	57		 push	 edi
  000aa	52		 push	 edx
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PBCPKOJP@error?5?3?5?$CFd?1?$CFd?5?5?$CFs?5?$CFd?$AA@
  000b0	6a 00		 push	 0
  000b2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000b7	83 c4 18	 add	 esp, 24			; 00000018H
  000ba	5f		 pop	 edi
  000bb	5b		 pop	 ebx
$LN6@gObjChaosI:
  000bc	5e		 pop	 esi

; 8767 : 				return;
; 8768 : 			}
; 8769 : 		}
; 8770 : 	}
; 8771 : }

  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
?gObjChaosItemBoxSet@@YAXHHHHE@Z ENDP			; gObjChaosItemBoxSet
_TEXT	ENDS
PUBLIC	?gObjChaosItemSet@@YAXHHE@Z			; gObjChaosItemSet
; Function compile flags: /Ogtp
;	COMDAT ?gObjChaosItemSet@@YAXHHE@Z
_TEXT	SEGMENT
_width$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_height$ = 12						; size = 4
_itempos$ = 12						; size = 4
_set_byte$ = 16						; size = 1
?gObjChaosItemSet@@YAXHHE@Z PROC			; gObjChaosItemSet, COMDAT

; 8774 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 8775 : 	int width;
; 8776 : 	int height;
; 8777 : 	if(itempos < 0)

  00005	8b 75 0c	 mov	 esi, DWORD PTR _itempos$[ebp]
  00008	83 fe 1f	 cmp	 esi, 31			; 0000001fH
  0000b	77 6c		 ja	 SHORT $LN5@gObjChaosI@2

; 8778 : 	{
; 8779 : 		return;
; 8780 : 	}
; 8781 : 	else if(itempos > (CHAOS_BOX_SIZE-1))
; 8782 : 	{
; 8783 : 		return;
; 8784 : 	}
; 8785 : 
; 8786 : 	if(gObj[aIndex].pChaosBox[itempos].GetSize((int&)width,(int &)height)==0)

  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00011	8d 45 0c	 lea	 eax, DWORD PTR _height$[ebp]
  00014	50		 push	 eax
  00015	8d 4d fc	 lea	 ecx, DWORD PTR _width$[ebp]
  00018	51		 push	 ecx
  00019	8b d7		 mov	 edx, edi
  0001b	8b ce		 mov	 ecx, esi
  0001d	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00023	69 c9 a8 00 00
	00		 imul	 ecx, 168		; 000000a8H
  00029	03 8a dc 0c 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3292]
  0002f	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00034	85 c0		 test	 eax, eax
  00036	75 2a		 jne	 SHORT $LN1@gObjChaosI@2

; 8787 : 	{
; 8788 : 		LogAdd(LOG_BLACK, lMsg.Get(527),__FILE__,__LINE__);

  00038	68 54 22 00 00	 push	 8788			; 00002254H
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00042	68 0f 02 00 00	 push	 527			; 0000020fH
  00047	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0004c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00051	50		 push	 eax
  00052	6a 00		 push	 0
  00054	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi

; 8793 : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$LN1@gObjChaosI@2:

; 8789 : 		return;
; 8790 : 	}
; 8791 : 
; 8792 : 	gObjChaosItemBoxSet(aIndex,itempos,width,height,set_byte);

  00062	8b 45 10	 mov	 eax, DWORD PTR _set_byte$[ebp]
  00065	8b 4d 0c	 mov	 ecx, DWORD PTR _height$[ebp]
  00068	8b 55 fc	 mov	 edx, DWORD PTR _width$[ebp]
  0006b	50		 push	 eax
  0006c	51		 push	 ecx
  0006d	52		 push	 edx
  0006e	56		 push	 esi
  0006f	57		 push	 edi
  00070	e8 00 00 00 00	 call	 ?gObjChaosItemBoxSet@@YAXHHHHE@Z ; gObjChaosItemBoxSet
  00075	83 c4 14	 add	 esp, 20			; 00000014H
  00078	5f		 pop	 edi
$LN5@gObjChaosI@2:
  00079	5e		 pop	 esi

; 8793 : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?gObjChaosItemSet@@YAXHHE@Z ENDP			; gObjChaosItemSet
_TEXT	ENDS
PUBLIC	_pos$GSCopy$
PUBLIC	?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z	; gObjChaosBoxInsertItemPos
; Function compile flags: /Ogtp
;	COMDAT ?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z
_TEXT	SEGMENT
_TempMap$ = -56						; size = 32
tv197 = -24						; size = 4
_h$ = -20						; size = 4
_iheight$ = -16						; size = 4
_iwidth$ = -12						; size = 4
_lpObj$ = -8						; size = 4
_pos$GSCopy$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 168
_pos$ = 180						; size = 4
_source$ = 184						; size = 4
?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z PROC	; gObjChaosBoxInsertItemPos, COMDAT

; 8796 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00009	53		 push	 ebx
  0000a	8b 9d b4 00 00
	00		 mov	 ebx, DWORD PTR _pos$[ebp]

; 8847 : 	}
; 8848 : 
; 8849 : 	blank = gObjMapRectCheck(lpObj->pChaosBoxMap,w,h,8,4,iwidth,iheight);

  00010	89 5d fc	 mov	 DWORD PTR _pos$GSCopy$[ebp], ebx
  00013	83 fb 1f	 cmp	 ebx, 31			; 0000001fH
  00016	0f 87 46 01 00
	00		 ja	 $LN9@gObjChaosB

; 8808 : 	}
; 8809 : 
; 8810 : 	useClass = 0;
; 8811 : 
; 8812 : 	lpObj = &gObj[aIndex];

  0001c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00022	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00027	57		 push	 edi
  00028	8b f8		 mov	 edi, eax

; 8813 : 
; 8814 : 	if(lpObj->pChaosBox[pos].IsItem() == 1)

  0002a	8b 8f dc 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3292]
  00030	8b c3		 mov	 eax, ebx
  00032	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00038	03 c8		 add	 ecx, eax
  0003a	89 7d f8	 mov	 DWORD PTR _lpObj$[ebp], edi
  0003d	89 45 e8	 mov	 DWORD PTR tv197[ebp], eax
  00040	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00045	83 f8 01	 cmp	 eax, 1

; 8815 : 	{
; 8816 : 		return -1;

  00048	74 0c		 je	 SHORT $LN17@gObjChaosB

; 8817 : 	}
; 8818 : 
; 8819 : 	if(item.IsItem() == 0)

  0004a	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  0004d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00052	85 c0		 test	 eax, eax
  00054	75 08		 jne	 SHORT $LN7@gObjChaosB
$LN17@gObjChaosB:
  00056	5f		 pop	 edi

; 8820 : 	{
; 8821 : 		return -1;

  00057	0c ff		 or	 al, 255			; 000000ffH
  00059	5b		 pop	 ebx

; 8862 : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN7@gObjChaosB:

; 8822 : 	}
; 8823 : 
; 8824 : 	w = pos%8;

  0005e	81 e3 07 00 00
	80		 and	 ebx, -2147483641	; 80000007H
  00064	56		 push	 esi
  00065	79 05		 jns	 SHORT $LN15@gObjChaosB
  00067	4b		 dec	 ebx
  00068	83 cb f8	 or	 ebx, -8			; fffffff8H
  0006b	43		 inc	 ebx
$LN15@gObjChaosB:

; 8825 : 	h = pos/8;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _pos$GSCopy$[ebp]
  0006f	99		 cdq
  00070	83 e2 07	 and	 edx, 7

; 8826 : 
; 8827 : 	if(ExtentCheck(w,h,8,4) == 0)

  00073	6a 04		 push	 4
  00075	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]
  00078	c1 fe 03	 sar	 esi, 3
  0007b	6a 08		 push	 8
  0007d	56		 push	 esi
  0007e	53		 push	 ebx
  0007f	89 75 ec	 mov	 DWORD PTR _h$[ebp], esi
  00082	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  00087	83 c4 10	 add	 esp, 16			; 00000010H
  0008a	85 c0		 test	 eax, eax

; 8828 : 	{
; 8829 : 		return -1;

  0008c	74 71		 je	 SHORT $LN3@gObjChaosB

; 8830 : 	}
; 8831 : 
; 8832 : 	item.GetSize((int &)iwidth,(int &)iheight);

  0008e	8d 45 f0	 lea	 eax, DWORD PTR _iheight$[ebp]
  00091	50		 push	 eax
  00092	8d 4d f4	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00095	51		 push	 ecx
  00096	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  00099	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 8833 : 
; 8834 : 	if(source >= 0)

  0009e	8b 95 b8 00 00
	00		 mov	 edx, DWORD PTR _source$[ebp]
  000a4	85 d2		 test	 edx, edx
  000a6	78 38		 js	 SHORT $LN5@gObjChaosB

; 8835 : 	{
; 8836 : 		memcpy(TempMap,lpObj->pChaosBoxMap,CHAOS_BOX_MAP_SIZE);

  000a8	8b b7 e0 0c 00
	00		 mov	 esi, DWORD PTR [edi+3296]

; 8837 : 		gObjChaosItemBoxSet(lpObj->m_Index,source,iwidth,iheight,255);

  000ae	8b 45 f0	 mov	 eax, DWORD PTR _iheight$[ebp]
  000b1	68 ff 00 00 00	 push	 255			; 000000ffH
  000b6	50		 push	 eax
  000b7	b9 08 00 00 00	 mov	 ecx, 8
  000bc	8d 7d c8	 lea	 edi, DWORD PTR _TempMap$[ebp]
  000bf	f3 a5		 rep movsd
  000c1	8b 4d f4	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  000c4	51		 push	 ecx
  000c5	52		 push	 edx
  000c6	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000c9	8b 02		 mov	 eax, DWORD PTR [edx]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?gObjChaosItemBoxSet@@YAXHHHHE@Z ; gObjChaosItemBoxSet
  000d1	8b 75 ec	 mov	 esi, DWORD PTR _h$[ebp]
  000d4	8b 7d f8	 mov	 edi, DWORD PTR _lpObj$[ebp]
  000d7	8b 95 b8 00 00
	00		 mov	 edx, DWORD PTR _source$[ebp]
  000dd	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@gObjChaosB:

; 8838 : 	}
; 8839 : 
; 8840 : 	if(*(BYTE*)(lpObj->pChaosBoxMap + h * 8 + w) != 255)

  000e0	8b 87 e0 0c 00
	00		 mov	 eax, DWORD PTR [edi+3296]
  000e6	8d 0c f0	 lea	 ecx, DWORD PTR [eax+esi*8]
  000e9	80 3c 19 ff	 cmp	 BYTE PTR [ecx+ebx], 255	; 000000ffH
  000ed	74 19		 je	 SHORT $LN4@gObjChaosB

; 8841 : 	{
; 8842 : 		if(source >= 0)

  000ef	85 d2		 test	 edx, edx
  000f1	78 0c		 js	 SHORT $LN3@gObjChaosB

; 8843 : 		{
; 8844 : 			memcpy(lpObj->pChaosBoxMap,TempMap,CHAOS_BOX_MAP_SIZE);

  000f3	b9 08 00 00 00	 mov	 ecx, 8
  000f8	8d 75 c8	 lea	 esi, DWORD PTR _TempMap$[ebp]
  000fb	8b f8		 mov	 edi, eax
  000fd	f3 a5		 rep movsd
$LN3@gObjChaosB:

; 8845 : 		}
; 8846 : 		return -1;

  000ff	5e		 pop	 esi
  00100	5f		 pop	 edi
  00101	0c ff		 or	 al, 255			; 000000ffH
  00103	5b		 pop	 ebx

; 8862 : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
$LN4@gObjChaosB:

; 8847 : 	}
; 8848 : 
; 8849 : 	blank = gObjMapRectCheck(lpObj->pChaosBoxMap,w,h,8,4,iwidth,iheight);

  00108	8b 55 f0	 mov	 edx, DWORD PTR _iheight$[ebp]
  0010b	8b 4d f4	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  0010e	52		 push	 edx
  0010f	51		 push	 ecx
  00110	6a 04		 push	 4
  00112	6a 08		 push	 8
  00114	56		 push	 esi
  00115	53		 push	 ebx
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 ?gObjMapRectCheck@@YAEPAEHHHHHH@Z ; gObjMapRectCheck
  0011c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 8850 : 
; 8851 : 	if(blank == 255)

  0011f	3c ff		 cmp	 al, 255			; 000000ffH
  00121	75 22		 jne	 SHORT $LN2@gObjChaosB

; 8852 : 	{
; 8853 : 		if(source >= 0)

  00123	83 bd b8 00 00
	00 00		 cmp	 DWORD PTR _source$[ebp], 0
  0012a	7c d3		 jl	 SHORT $LN3@gObjChaosB

; 8854 : 		{
; 8855 : 			memcpy(lpObj->pChaosBoxMap,TempMap,CHAOS_BOX_MAP_SIZE);

  0012c	8b bf e0 0c 00
	00		 mov	 edi, DWORD PTR [edi+3296]
  00132	b9 08 00 00 00	 mov	 ecx, 8
  00137	8d 75 c8	 lea	 esi, DWORD PTR _TempMap$[ebp]
  0013a	f3 a5		 rep movsd
  0013c	5e		 pop	 esi
  0013d	5f		 pop	 edi
  0013e	0a c0		 or	 al, al
  00140	5b		 pop	 ebx

; 8862 : }

  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
$LN2@gObjChaosB:

; 8856 : 		}
; 8857 : 		return -1;
; 8858 : 	}
; 8859 : 
; 8860 : 	lpObj->pChaosBox[pos] = item;

  00145	8b bf dc 0c 00
	00		 mov	 edi, DWORD PTR [edi+3292]
  0014b	03 7d e8	 add	 edi, DWORD PTR tv197[ebp]

; 8861 : 	return pos;

  0014e	8a 45 fc	 mov	 al, BYTE PTR _pos$GSCopy$[ebp]
  00151	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00156	8d 75 0c	 lea	 esi, DWORD PTR _item$[ebp]
  00159	f3 a5		 rep movsd
  0015b	5e		 pop	 esi
  0015c	5f		 pop	 edi
  0015d	5b		 pop	 ebx

; 8862 : }

  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c3		 ret	 0
$LN9@gObjChaosB:

; 8797 : 
; 8798 : 	LPOBJ lpObj;
; 8799 : 	BYTE TempMap[CHAOS_BOX_MAP_SIZE];
; 8800 : 
; 8801 : 	int w,h,iwidth,iheight;
; 8802 : 
; 8803 : 	int blank,useClass;
; 8804 : 
; 8805 : 	if(pos < 0 || pos > (CHAOS_BOX_SIZE-1))
; 8806 : 	{
; 8807 : 		return -1;

  00162	0c ff		 or	 al, 255			; 000000ffH
  00164	5b		 pop	 ebx

; 8862 : }

  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z ENDP	; gObjChaosBoxInsertItemPos
_TEXT	ENDS
PUBLIC	_pos$GSCopy$
PUBLIC	?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z	; gObjWarehouseInsertItemPos
; Function compile flags: /Ogtp
;	COMDAT ?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z
_TEXT	SEGMENT
_TempMap$ = -144					; size = 120
_h$ = -24						; size = 4
tv197 = -20						; size = 4
_w$ = -16						; size = 4
_pos$GSCopy$ = -12					; size = 4
_iheight$ = -8						; size = 4
_iwidth$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 168
_pos$ = 180						; size = 4
_source$ = 184						; size = 4
?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z PROC	; gObjWarehouseInsertItemPos, COMDAT

; 8865 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	8b 85 b4 00 00
	00		 mov	 eax, DWORD PTR _pos$[ebp]
  0000f	53		 push	 ebx
  00010	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 8924 : 		}
; 8925 : 		return -1;
; 8926 : 	}
; 8927 : 
; 8928 : 	lpObj->pWarehouse[pos] = item;

  00013	89 45 f4	 mov	 DWORD PTR _pos$GSCopy$[ebp], eax
  00016	83 f8 77	 cmp	 eax, 119		; 00000077H
  00019	77 27		 ja	 SHORT $LN17@gObjWareho@4

; 8866 : 	LPOBJ lpObj;
; 8867 : 	BYTE TempMap[WAREHOUSE_SIZE];
; 8868 : 
; 8869 : 	int w,h,iwidth,iheight;
; 8870 : 
; 8871 : 	int blank,useClass;
; 8872 : 
; 8873 : 	if(pos < 0 || pos > (WAREHOUSE_SIZE-1))
; 8874 : 	{
; 8875 : 		return -1;
; 8876 : 	}
; 8877 : 
; 8878 : 	useClass = 0;
; 8879 : 
; 8880 : 	lpObj = &gObj[aIndex];
; 8881 : 
; 8882 : 	if(lpObj->pWarehouse[pos].IsItem() == 1)

  0001b	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  00021	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00027	81 c3 00 00 00
	00		 add	 ebx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002d	8b 8b c4 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3268]
  00033	03 c8		 add	 ecx, eax
  00035	89 45 ec	 mov	 DWORD PTR tv197[ebp], eax
  00038	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0003d	83 f8 01	 cmp	 eax, 1
  00040	75 07		 jne	 SHORT $LN8@gObjWareho@4
$LN17@gObjWareho@4:

; 8883 : 	{
; 8884 : 		return -1;

  00042	0c ff		 or	 al, 255			; 000000ffH
  00044	5b		 pop	 ebx

; 8930 : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN8@gObjWareho@4:

; 8885 : 	}
; 8886 : 
; 8887 : 	if(item.IsItem() == 0)

  00049	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  0004c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00051	85 c0		 test	 eax, eax

; 8888 : 	{
; 8889 : 		return -1;

  00053	74 ed		 je	 SHORT $LN17@gObjWareho@4

; 8890 : 	}
; 8891 : 
; 8892 : 	w = pos%8;

  00055	8b 45 f4	 mov	 eax, DWORD PTR _pos$GSCopy$[ebp]
  00058	56		 push	 esi
  00059	57		 push	 edi
  0005a	8b f8		 mov	 edi, eax
  0005c	81 e7 07 00 00
	80		 and	 edi, -2147483641	; 80000007H
  00062	79 05		 jns	 SHORT $LN15@gObjWareho@4
  00064	4f		 dec	 edi
  00065	83 cf f8	 or	 edi, -8			; fffffff8H
  00068	47		 inc	 edi
$LN15@gObjWareho@4:

; 8893 : 	h = pos/8;

  00069	99		 cdq
  0006a	83 e2 07	 and	 edx, 7

; 8894 : 
; 8895 : 	if(ExtentCheck(w,h,8,15) == 0)

  0006d	6a 0f		 push	 15			; 0000000fH
  0006f	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]
  00072	c1 fe 03	 sar	 esi, 3
  00075	6a 08		 push	 8
  00077	56		 push	 esi
  00078	57		 push	 edi
  00079	89 7d f0	 mov	 DWORD PTR _w$[ebp], edi
  0007c	89 75 e8	 mov	 DWORD PTR _h$[ebp], esi
  0007f	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  00084	83 c4 10	 add	 esp, 16			; 00000010H
  00087	85 c0		 test	 eax, eax

; 8896 : 	{
; 8897 : 		return -1;

  00089	74 74		 je	 SHORT $LN3@gObjWareho@4

; 8898 : 	}
; 8899 : 
; 8900 : 	item.GetSize((int &)iwidth,(int &)iheight);

  0008b	8d 45 f8	 lea	 eax, DWORD PTR _iheight$[ebp]
  0008e	50		 push	 eax
  0008f	8d 4d fc	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00092	51		 push	 ecx
  00093	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  00096	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 8901 : 
; 8902 : 	if(source >= 0)

  0009b	8b 95 b8 00 00
	00		 mov	 edx, DWORD PTR _source$[ebp]
  000a1	85 d2		 test	 edx, edx
  000a3	78 38		 js	 SHORT $LN5@gObjWareho@4

; 8903 : 	{
; 8904 : 		memcpy(TempMap,lpObj->pWarehouseMap,WAREHOUSE_SIZE);

  000a5	8b b3 c8 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3272]

; 8905 : 		gObjWarehouseItemBoxSet(lpObj->m_Index,source,iwidth,iheight,255);

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _iheight$[ebp]
  000ae	68 ff 00 00 00	 push	 255			; 000000ffH
  000b3	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  000b8	8d bd 70 ff ff
	ff		 lea	 edi, DWORD PTR _TempMap$[ebp]
  000be	50		 push	 eax
  000bf	f3 a5		 rep movsd
  000c1	8b 4d fc	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  000c4	51		 push	 ecx
  000c5	52		 push	 edx
  000c6	8b 13		 mov	 edx, DWORD PTR [ebx]
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 ?gObjWarehouseItemBoxSet@@YAXHHHHE@Z ; gObjWarehouseItemBoxSet
  000ce	8b 7d f0	 mov	 edi, DWORD PTR _w$[ebp]
  000d1	8b 95 b8 00 00
	00		 mov	 edx, DWORD PTR _source$[ebp]
  000d7	8b 75 e8	 mov	 esi, DWORD PTR _h$[ebp]
  000da	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@gObjWareho@4:

; 8906 : 	}
; 8907 : 
; 8908 : 	if(*(BYTE*)(lpObj->pWarehouseMap + h * 8 + w) != 255)

  000dd	8b 83 c8 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3272]
  000e3	8d 0c f0	 lea	 ecx, DWORD PTR [eax+esi*8]
  000e6	80 3c 39 ff	 cmp	 BYTE PTR [ecx+edi], 255	; 000000ffH
  000ea	74 1c		 je	 SHORT $LN4@gObjWareho@4

; 8909 : 	{
; 8910 : 		if(source >= 0)

  000ec	85 d2		 test	 edx, edx
  000ee	78 0f		 js	 SHORT $LN3@gObjWareho@4

; 8911 : 		{
; 8912 : 			memcpy(lpObj->pWarehouseMap,TempMap,WAREHOUSE_SIZE);

  000f0	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  000f5	8d b5 70 ff ff
	ff		 lea	 esi, DWORD PTR _TempMap$[ebp]
  000fb	8b f8		 mov	 edi, eax
  000fd	f3 a5		 rep movsd
$LN3@gObjWareho@4:

; 8913 : 		}
; 8914 : 		return -1;

  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	0c ff		 or	 al, 255			; 000000ffH
  00103	5b		 pop	 ebx

; 8930 : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
$LN4@gObjWareho@4:

; 8915 : 	}
; 8916 : 
; 8917 : 	blank = gObjWerehouseRectCheck(lpObj->m_Index,w,h,iwidth,iheight);

  00108	8b 55 f8	 mov	 edx, DWORD PTR _iheight$[ebp]
  0010b	8b 45 fc	 mov	 eax, DWORD PTR _iwidth$[ebp]
  0010e	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00110	52		 push	 edx
  00111	50		 push	 eax
  00112	56		 push	 esi
  00113	57		 push	 edi
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ?gObjWerehouseRectCheck@@YAEHHHHH@Z ; gObjWerehouseRectCheck
  0011a	83 c4 14	 add	 esp, 20			; 00000014H

; 8918 : 
; 8919 : 	if(blank == 255)

  0011d	3c ff		 cmp	 al, 255			; 000000ffH
  0011f	75 25		 jne	 SHORT $LN2@gObjWareho@4

; 8920 : 	{
; 8921 : 		if(source >= 0)

  00121	83 bd b8 00 00
	00 00		 cmp	 DWORD PTR _source$[ebp], 0
  00128	7c d5		 jl	 SHORT $LN3@gObjWareho@4

; 8922 : 		{
; 8923 : 			memcpy(lpObj->pWarehouseMap,TempMap,WAREHOUSE_SIZE);

  0012a	8b bb c8 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3272]
  00130	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  00135	8d b5 70 ff ff
	ff		 lea	 esi, DWORD PTR _TempMap$[ebp]
  0013b	f3 a5		 rep movsd
  0013d	5f		 pop	 edi
  0013e	5e		 pop	 esi
  0013f	0a c0		 or	 al, al
  00141	5b		 pop	 ebx

; 8930 : }

  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c3		 ret	 0
$LN2@gObjWareho@4:

; 8924 : 		}
; 8925 : 		return -1;
; 8926 : 	}
; 8927 : 
; 8928 : 	lpObj->pWarehouse[pos] = item;

  00146	8b bb c4 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3268]
  0014c	03 7d ec	 add	 edi, DWORD PTR tv197[ebp]

; 8929 : 	return pos;

  0014f	8a 45 f4	 mov	 al, BYTE PTR _pos$GSCopy$[ebp]
  00152	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00157	8d 75 0c	 lea	 esi, DWORD PTR _item$[ebp]
  0015a	f3 a5		 rep movsd
  0015c	5f		 pop	 edi
  0015d	5e		 pop	 esi
  0015e	5b		 pop	 ebx

; 8930 : }

  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c3		 ret	 0
?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z ENDP	; gObjWarehouseInsertItemPos
_TEXT	ENDS
PUBLIC	?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
EXTRN	?GetNumber@CItem@@QAEKXZ:PROC			; CItem::GetNumber
EXTRN	?gItemSerialCheck@@3HA:DWORD			; gItemSerialCheck
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_serial$ = 12						; size = 4
?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z PROC ; gObjInventorySearchSerialNumber, COMDAT

; 9029 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 9030 : 	int s_num;
; 9031 : 	int count = 0;

  00005	33 ff		 xor	 edi, edi
  00007	89 7d fc	 mov	 DWORD PTR _count$[ebp], edi

; 9032 : 
; 9033 : 	if(gItemSerialCheck == 0)

  0000a	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?gItemSerialCheck@@3HA, edi ; gItemSerialCheck
  00010	75 08		 jne	 SHORT $LN11@gObjInvent@5

; 9034 : 	{
; 9035 : 		return true;

  00012	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00015	5f		 pop	 edi

; 9071 : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN11@gObjInvent@5:
  0001a	53		 push	 ebx

; 9036 : 	}
; 9037 : 
; 9038 : 	if(serial == 0)

  0001b	8b 5d 0c	 mov	 ebx, DWORD PTR _serial$[ebp]
  0001e	3b df		 cmp	 ebx, edi
  00020	75 0b		 jne	 SHORT $LN10@gObjInvent@5

; 9039 : 	{
; 9040 : 		return true;

  00022	5b		 pop	 ebx
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	5f		 pop	 edi

; 9071 : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN10@gObjInvent@5:
  0002d	56		 push	 esi

; 9039 : 	{
; 9040 : 		return true;

  0002e	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
$LL9@gObjInvent@5:

; 9044 : 	{
; 9045 : 		s_num = lpObj->pInventory[n].GetNumber();

  00031	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00037	03 cf		 add	 ecx, edi
  00039	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 9046 : 
; 9047 : 		if(s_num != 0 && s_num == serial)

  0003e	85 c0		 test	 eax, eax
  00040	74 07		 je	 SHORT $LN8@gObjInvent@5
  00042	3b c3		 cmp	 eax, ebx
  00044	75 03		 jne	 SHORT $LN8@gObjInvent@5

; 9048 : 		{
; 9049 : 			count++;

  00046	ff 45 fc	 inc	 DWORD PTR _count$[ebp]
$LN8@gObjInvent@5:

; 9041 : 	}
; 9042 : 
; 9043 : 	for(int n = 0; n < INVENTORY_SIZE; n++)

  00049	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  0004f	81 ff e0 46 00
	00		 cmp	 edi, 18144		; 000046e0H
  00055	7c da		 jl	 SHORT $LL9@gObjInvent@5

; 9050 : 		}
; 9051 : 	}
; 9052 : 
; 9053 : 	if(count <= 1)

  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	39 45 fc	 cmp	 DWORD PTR _count$[ebp], eax

; 9054 : 	{
; 9055 : 		return true;

  0005f	0f 8e 89 00 00
	00		 jle	 $LN19@gObjInvent@5

; 9056 : 	}
; 9057 : 
; 9058 : 	for(int n = 0; n < INVENTORY_SIZE; n++)

  00065	33 db		 xor	 ebx, ebx
  00067	33 ff		 xor	 edi, edi
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL4@gObjInvent@5:

; 9059 : 	{
; 9060 : 		s_num = lpObj->pInventory[n].GetNumber();

  00070	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00076	03 cf		 add	 ecx, edi
  00078	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 9061 : 
; 9062 : 		if(s_num != 0 && s_num == serial)

  0007d	85 c0		 test	 eax, eax
  0007f	74 5c		 je	 SHORT $LN3@gObjInvent@5
  00081	3b 45 0c	 cmp	 eax, DWORD PTR _serial$[ebp]
  00084	75 57		 jne	 SHORT $LN3@gObjInvent@5

; 9063 : 		{
; 9064 : 			LogAdd(LOG_BLACK, lMsg.Get(529),lpObj->AccountID,lpObj->Name,lpObj->pInventory[n].GetName(),n,s_num);

  00086	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0008c	50		 push	 eax
  0008d	53		 push	 ebx
  0008e	03 cf		 add	 ecx, edi
  00090	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00095	50		 push	 eax
  00096	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00099	50		 push	 eax
  0009a	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  0009d	51		 push	 ecx
  0009e	68 11 02 00 00	 push	 529			; 00000211H
  000a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000a8	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000ad	50		 push	 eax
  000ae	6a 00		 push	 0
  000b0	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 9065 : 			GCServerMsgStringSend(lMsg.Get(1102),lpObj->m_Index,1);

  000b5	8b 16		 mov	 edx, DWORD PTR [esi]
  000b7	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ba	6a 01		 push	 1
  000bc	52		 push	 edx
  000bd	68 4e 04 00 00	 push	 1102			; 0000044eH
  000c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000c7	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 9066 : 			gObjUserKill(lpObj->m_Index);

  000d2	8b 06		 mov	 eax, DWORD PTR [esi]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?gObjUserKill@@YAXH@Z	; gObjUserKill
  000da	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@gObjInvent@5:

; 9056 : 	}
; 9057 : 
; 9058 : 	for(int n = 0; n < INVENTORY_SIZE; n++)

  000dd	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  000e3	43		 inc	 ebx
  000e4	81 ff e0 46 00
	00		 cmp	 edi, 18144		; 000046e0H
  000ea	7c 84		 jl	 SHORT $LL4@gObjInvent@5

; 9067 : 		}
; 9068 : 	}
; 9069 : 
; 9070 : 	return false;

  000ec	33 c0		 xor	 eax, eax
$LN19@gObjInvent@5:
  000ee	5e		 pop	 esi
  000ef	5b		 pop	 ebx
  000f0	5f		 pop	 edi

; 9071 : }

  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ENDP ; gObjInventorySearchSerialNumber
_TEXT	ENDS
PUBLIC	?gObjWarehouseSearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjWarehouseSearchSerialNumber
; Function compile flags: /Ogtp
;	COMDAT ?gObjWarehouseSearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_sirial$ = 12						; size = 4
?gObjWarehouseSearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z PROC ; gObjWarehouseSearchSerialNumber, COMDAT

; 9074 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 9075 : int s_num;
; 9076 : 	int count = 0;

  00005	33 ff		 xor	 edi, edi
  00007	89 7d fc	 mov	 DWORD PTR _count$[ebp], edi

; 9077 : 
; 9078 : 	if(gItemSerialCheck == 0)

  0000a	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?gItemSerialCheck@@3HA, edi ; gItemSerialCheck
  00010	75 08		 jne	 SHORT $LN11@gObjWareho@5

; 9079 : 	{
; 9080 : 		return true;

  00012	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00015	5f		 pop	 edi

; 9116 : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN11@gObjWareho@5:
  0001a	53		 push	 ebx

; 9081 : 	}
; 9082 : 
; 9083 : 	if(sirial == 0)

  0001b	8b 5d 0c	 mov	 ebx, DWORD PTR _sirial$[ebp]
  0001e	3b df		 cmp	 ebx, edi
  00020	75 0b		 jne	 SHORT $LN10@gObjWareho@5

; 9084 : 	{
; 9085 : 		return true;

  00022	5b		 pop	 ebx
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	5f		 pop	 edi

; 9116 : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN10@gObjWareho@5:
  0002d	56		 push	 esi

; 9084 : 	{
; 9085 : 		return true;

  0002e	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
$LL9@gObjWareho@5:

; 9089 : 	{
; 9090 : 		s_num = lpObj->pWarehouse[n].GetNumber();

  00031	8b 8e c4 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3268]
  00037	03 cf		 add	 ecx, edi
  00039	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 9091 : 
; 9092 : 		if(s_num != 0 && s_num == sirial)

  0003e	85 c0		 test	 eax, eax
  00040	74 07		 je	 SHORT $LN8@gObjWareho@5
  00042	3b c3		 cmp	 eax, ebx
  00044	75 03		 jne	 SHORT $LN8@gObjWareho@5

; 9093 : 		{
; 9094 : 			count++;

  00046	ff 45 fc	 inc	 DWORD PTR _count$[ebp]
$LN8@gObjWareho@5:

; 9086 : 	}
; 9087 : 
; 9088 : 	for(int n = 0; n < WAREHOUSE_SIZE; n++)

  00049	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  0004f	81 ff c0 4e 00
	00		 cmp	 edi, 20160		; 00004ec0H
  00055	7c da		 jl	 SHORT $LL9@gObjWareho@5

; 9095 : 		}
; 9096 : 	}
; 9097 : 
; 9098 : 	if(count <= 1)

  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	39 45 fc	 cmp	 DWORD PTR _count$[ebp], eax

; 9099 : 	{
; 9100 : 		return true;

  0005f	0f 8e 89 00 00
	00		 jle	 $LN19@gObjWareho@5

; 9101 : 	}
; 9102 : 
; 9103 : 	for(int n = 0; n < WAREHOUSE_SIZE; n++)

  00065	33 db		 xor	 ebx, ebx
  00067	33 ff		 xor	 edi, edi
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL4@gObjWareho@5:

; 9104 : 	{
; 9105 : 		s_num = lpObj->pWarehouse[n].GetNumber();

  00070	8b 8e c4 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3268]
  00076	03 cf		 add	 ecx, edi
  00078	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 9106 : 
; 9107 : 		if(s_num != 0 && s_num == sirial)

  0007d	85 c0		 test	 eax, eax
  0007f	74 5c		 je	 SHORT $LN3@gObjWareho@5
  00081	3b 45 0c	 cmp	 eax, DWORD PTR _sirial$[ebp]
  00084	75 57		 jne	 SHORT $LN3@gObjWareho@5

; 9108 : 		{
; 9109 : 			LogAdd(LOG_BLACK, lMsg.Get(530),lpObj->AccountID,lpObj->Name,lpObj->pWarehouse[n].GetName(),n,s_num);

  00086	8b 8e c4 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3268]
  0008c	50		 push	 eax
  0008d	53		 push	 ebx
  0008e	03 cf		 add	 ecx, edi
  00090	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00095	50		 push	 eax
  00096	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00099	50		 push	 eax
  0009a	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  0009d	51		 push	 ecx
  0009e	68 12 02 00 00	 push	 530			; 00000212H
  000a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000a8	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000ad	50		 push	 eax
  000ae	6a 00		 push	 0
  000b0	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 9110 : 			GCServerMsgStringSend(lMsg.Get(1102),lpObj->m_Index,1);

  000b5	8b 16		 mov	 edx, DWORD PTR [esi]
  000b7	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ba	6a 01		 push	 1
  000bc	52		 push	 edx
  000bd	68 4e 04 00 00	 push	 1102			; 0000044eH
  000c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000c7	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 9111 : 			gObjUserKill(lpObj->m_Index);

  000d2	8b 06		 mov	 eax, DWORD PTR [esi]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?gObjUserKill@@YAXH@Z	; gObjUserKill
  000da	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@gObjWareho@5:

; 9101 : 	}
; 9102 : 
; 9103 : 	for(int n = 0; n < WAREHOUSE_SIZE; n++)

  000dd	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  000e3	43		 inc	 ebx
  000e4	81 ff c0 4e 00
	00		 cmp	 edi, 20160		; 00004ec0H
  000ea	7c 84		 jl	 SHORT $LL4@gObjWareho@5

; 9112 : 		}
; 9113 : 	}
; 9114 : 
; 9115 : 	return false;

  000ec	33 c0		 xor	 eax, eax
$LN19@gObjWareho@5:
  000ee	5e		 pop	 esi
  000ef	5b		 pop	 ebx
  000f0	5f		 pop	 edi

; 9116 : }

  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
?gObjWarehouseSearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ENDP ; gObjWarehouseSearchSerialNumber
_TEXT	ENDS
PUBLIC	?gObjTradeRectCheck@@YAEHHHHH@Z			; gObjTradeRectCheck
; Function compile flags: /Ogtp
;	COMDAT ?gObjTradeRectCheck@@YAEHHHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
?gObjTradeRectCheck@@YAEHHHHH@Z PROC			; gObjTradeRectCheck, COMDAT

; 10011: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10012: 	int x;
; 10013: 	int y;
; 10014: 	int blank = 0;
; 10015: 	int xx;
; 10016: 	int yy;
; 10017: 
; 10018: 	if ( ( sx + width) > 8 )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  00006	57		 push	 edi
  00007	8b 7d 14	 mov	 edi, DWORD PTR _width$[ebp]
  0000a	03 c7		 add	 eax, edi
  0000c	83 f8 08	 cmp	 eax, 8
  0000f	7e 05		 jle	 SHORT $LN12@gObjTradeR
$LN24@gObjTradeR:

; 10019: 	{
; 10020: 		return -1;

  00011	0c ff		 or	 al, 255			; 000000ffH
  00013	5f		 pop	 edi

; 10055: 	}
; 10056: 
; 10057: 	return -1;
; 10058: }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN12@gObjTradeR:

; 10021: 	}
; 10022: 
; 10023: 	if ( (sy + height) > 4 )

  00016	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00019	8b 4d 18	 mov	 ecx, DWORD PTR _height$[ebp]
  0001c	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  0001f	83 fa 04	 cmp	 edx, 4

; 10024: 	{
; 10025: 		return -1;

  00022	7f ed		 jg	 SHORT $LN24@gObjTradeR

; 10026: 	}
; 10027: 
; 10028: 	for ( y=0;y<height;y++)

  00024	53		 push	 ebx
  00025	33 db		 xor	 ebx, ebx
  00027	56		 push	 esi
  00028	85 c9		 test	 ecx, ecx
  0002a	7e 50		 jle	 SHORT $LN20@gObjTradeR
  0002c	8d 64 24 00	 npad	 4
$LL10@gObjTradeR:

; 10031: 		
; 10032: 		for ( x=0;x<width;x++)

  00030	33 f6		 xor	 esi, esi
  00032	8d 14 03	 lea	 edx, DWORD PTR [ebx+eax]
  00035	85 ff		 test	 edi, edi
  00037	7e 3e		 jle	 SHORT $LN9@gObjTradeR

; 10029: 	{
; 10030: 		yy = sy + y;

  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _sx$[ebp]
  0003c	8d 64 24 00	 npad	 4
$LL21@gObjTradeR:

; 10033: 		{
; 10034: 			xx = sx + x;
; 10035: 
; 10036: 			if ( ::ExtentCheck(xx, yy, 8, 4) == TRUE )

  00040	6a 04		 push	 4
  00042	6a 08		 push	 8
  00044	52		 push	 edx
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  0004b	83 c4 10	 add	 esp, 16			; 00000010H
  0004e	83 f8 01	 cmp	 eax, 1
  00051	75 34		 jne	 SHORT $LN4@gObjTradeR

; 10037: 			{
; 10038: 				if ( *(BYTE*)(gObj[aIndex].TradeMap + yy * 8 + xx) != (BYTE)-1)

  00053	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00056	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0005c	8b 80 b8 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3256]
  00062	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
  00065	80 3c 08 ff	 cmp	 BYTE PTR [eax+ecx], 255	; 000000ffH
  00069	75 35		 jne	 SHORT $LN17@gObjTradeR

; 10031: 		
; 10032: 		for ( x=0;x<width;x++)

  0006b	46		 inc	 esi
  0006c	41		 inc	 ecx
  0006d	3b f7		 cmp	 esi, edi
  0006f	7c cf		 jl	 SHORT $LL21@gObjTradeR
  00071	8b 4d 18	 mov	 ecx, DWORD PTR _height$[ebp]
  00074	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
$LN9@gObjTradeR:

; 10026: 	}
; 10027: 
; 10028: 	for ( y=0;y<height;y++)

  00077	43		 inc	 ebx
  00078	3b d9		 cmp	 ebx, ecx
  0007a	7c b4		 jl	 SHORT $LL10@gObjTradeR
$LN20@gObjTradeR:

; 10048: 			}
; 10049: 		}
; 10050: 	}
; 10051: 
; 10052: 	if ( blank == 0 )
; 10053: 	{
; 10054: 		return (sy * 8 + sx);

  0007c	8b 4d 0c	 mov	 ecx, DWORD PTR _sx$[ebp]
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00084	5f		 pop	 edi

; 10055: 	}
; 10056: 
; 10057: 	return -1;
; 10058: }

  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
$LN4@gObjTradeR:

; 10039: 				{
; 10040: 					blank++;
; 10041: 					return -1;
; 10042: 				}
; 10043: 			}
; 10044: 			else
; 10045: 			{
; 10046: 				LogAdd(LOG_BLACK, "error : %s %d", __FILE__ ,__LINE__);

  00087	68 3e 27 00 00	 push	 10046			; 0000273eH
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00096	6a 00		 push	 0
  00098	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0009d	83 c4 10	 add	 esp, 16			; 00000010H
$LN17@gObjTradeR:

; 10047: 				return -1;

  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	0c ff		 or	 al, 255			; 000000ffH
  000a4	5f		 pop	 edi

; 10055: 	}
; 10056: 
; 10057: 	return -1;
; 10058: }

  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
?gObjTradeRectCheck@@YAEHHHHH@Z ENDP			; gObjTradeRectCheck
_TEXT	ENDS
PUBLIC	?gObjTradeItemBoxSet@@YAHHHHHE@Z		; gObjTradeItemBoxSet
; Function compile flags: /Ogtp
;	COMDAT ?gObjTradeItemBoxSet@@YAHHHHHE@Z
_TEXT	SEGMENT
_itemposy$ = -8						; size = 4
_itemposx$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_y$165372 = 12						; size = 4
_itempos$ = 12						; size = 4
_xl$ = 16						; size = 4
_yl$ = 20						; size = 4
_set_byte$ = 24						; size = 1
?gObjTradeItemBoxSet@@YAHHHHHE@Z PROC			; gObjTradeItemBoxSet, COMDAT

; 10061: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10062: 	int itemposx = (itempos)%8;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	53		 push	 ebx
  0000a	8b d8		 mov	 ebx, eax
  0000c	81 e3 07 00 00
	80		 and	 ebx, -2147483641	; 80000007H
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	79 05		 jns	 SHORT $LN16@gObjTradeI
  00016	4b		 dec	 ebx
  00017	83 cb f8	 or	 ebx, -8			; fffffff8H
  0001a	43		 inc	 ebx
$LN16@gObjTradeI:

; 10063: 	int itemposy = (itempos)/8;

  0001b	99		 cdq
  0001c	83 e2 07	 and	 edx, 7
  0001f	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]

; 10064: 
; 10065: 	int xx,yy;
; 10066: 
; 10067: 	for(int y = 0; y < yl; y ++)

  00022	33 c0		 xor	 eax, eax
  00024	c1 f9 03	 sar	 ecx, 3
  00027	89 5d fc	 mov	 DWORD PTR _itemposx$[ebp], ebx
  0002a	89 4d f8	 mov	 DWORD PTR _itemposy$[ebp], ecx
  0002d	89 45 0c	 mov	 DWORD PTR _y$165372[ebp], eax
  00030	39 45 14	 cmp	 DWORD PTR _yl$[ebp], eax
  00033	7e 51		 jle	 SHORT $LN6@gObjTradeI
  00035	8b 7d 10	 mov	 edi, DWORD PTR _xl$[ebp]
$LL8@gObjTradeI:

; 10070: 
; 10071: 		for(int x = 0; x < xl; x++)

  00038	33 f6		 xor	 esi, esi
  0003a	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  0003d	85 ff		 test	 edi, edi
  0003f	7e 3c		 jle	 SHORT $LN7@gObjTradeI

; 10068: 	{
; 10069: 		yy = itemposy + y;

  00041	8b cb		 mov	 ecx, ebx
$LL15@gObjTradeI:

; 10072: 		{
; 10073: 			xx = itemposx + x;
; 10074: 
; 10075: 			if(ExtentCheck(xx,yy,8,4)==1)

  00043	6a 04		 push	 4
  00045	6a 08		 push	 8
  00047	52		 push	 edx
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	83 f8 01	 cmp	 eax, 1
  00054	75 3c		 jne	 SHORT $LN2@gObjTradeI

; 10076: 			{
; 10077: 				*(BYTE*)(gObj[aIndex].TradeMap + yy*8+xx) = set_byte;

  00056	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00059	8a 5d 18	 mov	 bl, BYTE PTR _set_byte$[ebp]
  0005c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00062	8b 80 b8 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3256]
  00068	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
  0006b	88 1c 08	 mov	 BYTE PTR [eax+ecx], bl
  0006e	46		 inc	 esi
  0006f	41		 inc	 ecx
  00070	3b f7		 cmp	 esi, edi
  00072	7c cf		 jl	 SHORT $LL15@gObjTradeI

; 10070: 
; 10071: 		for(int x = 0; x < xl; x++)

  00074	8b 5d fc	 mov	 ebx, DWORD PTR _itemposx$[ebp]
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _itemposy$[ebp]
  0007a	8b 45 0c	 mov	 eax, DWORD PTR _y$165372[ebp]
$LN7@gObjTradeI:

; 10064: 
; 10065: 	int xx,yy;
; 10066: 
; 10067: 	for(int y = 0; y < yl; y ++)

  0007d	40		 inc	 eax
  0007e	89 45 0c	 mov	 DWORD PTR _y$165372[ebp], eax
  00081	3b 45 14	 cmp	 eax, DWORD PTR _yl$[ebp]
  00084	7c b2		 jl	 SHORT $LL8@gObjTradeI
$LN6@gObjTradeI:
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi

; 10083: 			}
; 10084: 		}
; 10085: 	}
; 10086: 	return true;

  00088	b8 01 00 00 00	 mov	 eax, 1
  0008d	5b		 pop	 ebx

; 10087: }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
$LN2@gObjTradeI:

; 10078: 			}
; 10079: 			else
; 10080: 			{
; 10081: 				LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  00092	68 61 27 00 00	 push	 10081			; 00002761H
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  000a1	6a 00		 push	 0
  000a3	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000a8	83 c4 10	 add	 esp, 16			; 00000010H
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi

; 10082: 				return false;

  000ad	33 c0		 xor	 eax, eax
  000af	5b		 pop	 ebx

; 10087: }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
?gObjTradeItemBoxSet@@YAHHHHHE@Z ENDP			; gObjTradeItemBoxSet
_TEXT	ENDS
PUBLIC	_target$GSCopy$
PUBLIC	_source$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjTradeTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z	; gObjTradeTradeMove
EXTRN	?GCTradeOtherAdd@@YAHHEPAE@Z:PROC		; GCTradeOtherAdd
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?GCTradeOtherDel@@YAHHE@Z:PROC			; GCTradeOtherDel
; Function compile flags: /Ogtp
;	COMDAT ?gObjTradeTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_TempTradeMap$ = -72					; size = 32
tv259 = -40						; size = 4
_source$GSCopy$ = -36					; size = 1
_iwidth$ = -32						; size = 4
_iheight$ = -28						; size = 4
tv302 = -24						; size = 4
tv265 = -24						; size = 4
tv258 = -20						; size = 4
_blank$ = -20						; size = 4
_target$GSCopy$ = -13					; size = 1
_itembuf$165472 = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_source$ = 12						; size = 1
_target$ = 16						; size = 1
?gObjTradeTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z PROC	; gObjTradeTradeMove, COMDAT

; 10307: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8a 45 0c	 mov	 al, BYTE PTR _source$[ebp]
  00013	8a 4d 10	 mov	 cl, BYTE PTR _target$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  0001a	56		 push	 esi
  0001b	57		 push	 edi

; 10308: 	int h,w;
; 10309: 	int iwidth,iheight;
; 10310: 	BYTE TempTradeMap[TRADE_BOX_MAP_SIZE];
; 10311: 	int blank;
; 10312: 
; 10313: 	if(source > TRADE_BOX_SIZE)

  0001c	88 45 dc	 mov	 BYTE PTR _source$GSCopy$[ebp], al

; 10361: 			return -1;
; 10362: 		}
; 10363: 
; 10364: 		lpObj->Trade[blank] = lpObj->Trade[source];

  0001f	88 4d f3	 mov	 BYTE PTR _target$GSCopy$[ebp], cl
  00022	3c 20		 cmp	 al, 32			; 00000020H
  00024	76 2c		 jbe	 SHORT $LN10@gObjTradeT

; 10314: 	{
; 10315: 		LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  00026	68 4b 28 00 00	 push	 10315			; 0000284bH
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00035	6a 00		 push	 0
  00037	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0003c	83 c4 10	 add	 esp, 16			; 00000010H

; 10336: 	{
; 10337: 		return -1;

  0003f	0c ff		 or	 al, 255			; 000000ffH

; 10374: 	return -1;
; 10375: }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00047	33 cd		 xor	 ecx, ebp
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN10@gObjTradeT:

; 10316: 		return -1;
; 10317: 	}
; 10318: 	if(source == target)

  00052	3a c1		 cmp	 al, cl
  00054	75 2c		 jne	 SHORT $LN9@gObjTradeT

; 10319: 	{
; 10320: 		LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  00056	68 50 28 00 00	 push	 10320			; 00002850H
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00065	6a 00		 push	 0
  00067	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0006c	83 c4 10	 add	 esp, 16			; 00000010H

; 10336: 	{
; 10337: 		return -1;

  0006f	0c ff		 or	 al, 255			; 000000ffH

; 10374: 	return -1;
; 10375: }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00077	33 cd		 xor	 ecx, ebp
  00079	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
$LN9@gObjTradeT:

; 10321: 		return -1;
; 10322: 	}
; 10323: 	if(lpObj->Trade[source].IsItem() == 0)

  00082	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3252]
  00088	0f b6 f0	 movzx	 esi, al
  0008b	89 75 ec	 mov	 DWORD PTR tv258[ebp], esi
  0008e	69 f6 a8 00 00
	00		 imul	 esi, 168		; 000000a8H
  00094	03 ce		 add	 ecx, esi
  00096	89 75 d8	 mov	 DWORD PTR tv259[ebp], esi
  00099	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0009e	85 c0		 test	 eax, eax

; 10324: 	{
; 10325: 		return -1;

  000a0	0f 84 f3 00 00
	00		 je	 $LN4@gObjTradeT

; 10326: 	}
; 10327: 	if(lpObj->Trade[target].IsItem() == 1)

  000a6	0f b6 4d f3	 movzx	 ecx, BYTE PTR _target$GSCopy$[ebp]
  000aa	89 4d e8	 mov	 DWORD PTR tv265[ebp], ecx
  000ad	69 c9 a8 00 00
	00		 imul	 ecx, 168		; 000000a8H
  000b3	03 8b b4 0c 00
	00		 add	 ecx, DWORD PTR [ebx+3252]
  000b9	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000be	83 f8 01	 cmp	 eax, 1

; 10328: 	{
; 10329: 		return -1;

  000c1	0f 84 d2 00 00
	00		 je	 $LN4@gObjTradeT

; 10330: 	}
; 10331: 	if(lpObj->TargetNumber < 0)

  000c7	66 83 bb d4 02
	00 00 00	 cmp	 WORD PTR [ebx+724], 0

; 10332: 	{
; 10333: 		return -1;

  000cf	0f 8c c4 00 00
	00		 jl	 $LN4@gObjTradeT

; 10334: 	}
; 10335: 	if(lpObj->m_IfState.use == 0 || lpObj->m_IfState.type != 1)

  000d5	8b 83 84 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3204]
  000db	a8 03		 test	 al, 3
  000dd	0f 84 b6 00 00
	00		 je	 $LN4@gObjTradeT
  000e3	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000e8	83 f8 40	 cmp	 eax, 64			; 00000040H
  000eb	0f 85 a8 00 00
	00		 jne	 $LN4@gObjTradeT

; 10338: 	}
; 10339: 
; 10340: 	lpObj->Trade[source].GetSize((int &)iwidth,(int &)iheight);

  000f1	8d 45 e4	 lea	 eax, DWORD PTR _iheight$[ebp]
  000f4	50		 push	 eax
  000f5	8d 4d e0	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  000f8	51		 push	 ecx
  000f9	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3252]
  000ff	03 ce		 add	 ecx, esi
  00101	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 10341: 	memcpy(TempTradeMap,lpObj->TradeMap,TRADE_BOX_MAP_SIZE);
; 10342: 	gObjTradeItemBoxSet(lpObj->m_Index,source,iwidth,iheight,255);

  00106	8b 55 e4	 mov	 edx, DWORD PTR _iheight$[ebp]
  00109	8b b3 b8 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3256]
  0010f	8b 45 e0	 mov	 eax, DWORD PTR _iwidth$[ebp]
  00112	68 ff 00 00 00	 push	 255			; 000000ffH
  00117	52		 push	 edx
  00118	8b 13		 mov	 edx, DWORD PTR [ebx]
  0011a	b9 08 00 00 00	 mov	 ecx, 8
  0011f	8d 7d b8	 lea	 edi, DWORD PTR _TempTradeMap$[ebp]
  00122	f3 a5		 rep movsd
  00124	8b 4d ec	 mov	 ecx, DWORD PTR tv258[ebp]
  00127	50		 push	 eax
  00128	51		 push	 ecx
  00129	52		 push	 edx
  0012a	e8 00 00 00 00	 call	 ?gObjTradeItemBoxSet@@YAHHHHHE@Z ; gObjTradeItemBoxSet

; 10343: 
; 10344: 	w = target % 8;

  0012f	8b 45 e8	 mov	 eax, DWORD PTR tv265[ebp]
  00132	8b c8		 mov	 ecx, eax
  00134	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H
  0013a	79 05		 jns	 SHORT $LN13@gObjTradeT
  0013c	49		 dec	 ecx
  0013d	83 c9 f8	 or	 ecx, -8			; fffffff8H
  00140	41		 inc	 ecx
$LN13@gObjTradeT:

; 10345: 	h = target / 8;
; 10346: 
; 10347: 	if(ExtentCheck(w,h,8,4) == 0)

  00141	6a 04		 push	 4
  00143	c1 e8 03	 shr	 eax, 3
  00146	8b d0		 mov	 edx, eax
  00148	6a 08		 push	 8
  0014a	52		 push	 edx
  0014b	51		 push	 ecx
  0014c	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck

; 10348: 	{
; 10349: 		memcpy(lpObj->TradeMap,TempTradeMap,TRADE_BOX_MAP_SIZE);

  00151	8b bb b8 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3256]
  00157	83 c4 24	 add	 esp, 36			; 00000024H
  0015a	85 c0		 test	 eax, eax

; 10350: 		return -1;

  0015c	74 31		 je	 SHORT $LN2@gObjTradeT

; 10351: 	}
; 10352: 
; 10353: 	if(*(BYTE*)(lpObj->TradeMap + h * 8 + w) == 255)

  0015e	8d 04 d7	 lea	 eax, DWORD PTR [edi+edx*8]
  00161	80 3c 08 ff	 cmp	 BYTE PTR [eax+ecx], 255	; 000000ffH
  00165	75 28		 jne	 SHORT $LN2@gObjTradeT

; 10354: 	{
; 10355: 		BYTE itembuf[8];
; 10356: 		blank = gObjTradeRectCheck(lpObj->m_Index,w,h,iwidth,iheight);

  00167	8b 45 e4	 mov	 eax, DWORD PTR _iheight$[ebp]
  0016a	50		 push	 eax
  0016b	8b 45 e0	 mov	 eax, DWORD PTR _iwidth$[ebp]
  0016e	50		 push	 eax
  0016f	52		 push	 edx
  00170	51		 push	 ecx
  00171	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00173	51		 push	 ecx
  00174	e8 00 00 00 00	 call	 ?gObjTradeRectCheck@@YAEHHHHH@Z ; gObjTradeRectCheck
  00179	0f b6 c0	 movzx	 eax, al
  0017c	83 c4 14	 add	 esp, 20			; 00000014H
  0017f	89 45 ec	 mov	 DWORD PTR _blank$[ebp], eax

; 10357: 
; 10358: 		if(blank == 255)

  00182	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00187	75 23		 jne	 SHORT $LN1@gObjTradeT

; 10359: 		{
; 10360: 			memcpy(lpObj->TradeMap,TempTradeMap,TRADE_BOX_MAP_SIZE);

  00189	8b bb b8 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3256]
$LN2@gObjTradeT:

; 10370: 		return true;
; 10371: 	}
; 10372: 
; 10373: 	memcpy(lpObj->TradeMap,TempTradeMap,TRADE_BOX_MAP_SIZE);

  0018f	b9 08 00 00 00	 mov	 ecx, 8
  00194	8d 75 b8	 lea	 esi, DWORD PTR _TempTradeMap$[ebp]
  00197	f3 a5		 rep movsd
$LN4@gObjTradeT:

; 10336: 	{
; 10337: 		return -1;

  00199	0c ff		 or	 al, 255			; 000000ffH

; 10374: 	return -1;
; 10375: }

  0019b	5f		 pop	 edi
  0019c	5e		 pop	 esi
  0019d	5b		 pop	 ebx
  0019e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a1	33 cd		 xor	 ecx, ebp
  001a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c3		 ret	 0
$LN1@gObjTradeT:

; 10361: 			return -1;
; 10362: 		}
; 10363: 
; 10364: 		lpObj->Trade[blank] = lpObj->Trade[source];

  001ac	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3252]
  001b2	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  001b8	8b 55 d8	 mov	 edx, DWORD PTR tv259[ebp]
  001bb	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  001be	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  001c1	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  001c6	f3 a5		 rep movsd

; 10365: 		lpObj->Trade[source].Clear();

  001c8	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3252]
  001ce	03 ca		 add	 ecx, edx
  001d0	89 45 e8	 mov	 DWORD PTR tv302[ebp], eax
  001d3	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 10366: 		GCTradeOtherDel(lpObj->TargetNumber,source);

  001d8	8b 55 dc	 mov	 edx, DWORD PTR _source$GSCopy$[ebp]
  001db	0f bf 83 d4 02
	00 00		 movsx	 eax, WORD PTR [ebx+724]
  001e2	52		 push	 edx
  001e3	50		 push	 eax
  001e4	e8 00 00 00 00	 call	 ?GCTradeOtherDel@@YAHHE@Z ; GCTradeOtherDel

; 10367: 		gObjTradeItemBoxSet(lpObj->m_Index,blank,iwidth,iheight,lpObj->Trade[blank].m_Type);

  001e9	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3252]
  001ef	8b 7d e8	 mov	 edi, DWORD PTR tv302[ebp]
  001f2	0f b6 54 0f 06	 movzx	 edx, BYTE PTR [edi+ecx+6]
  001f7	8b 45 e4	 mov	 eax, DWORD PTR _iheight$[ebp]
  001fa	8b 4d e0	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  001fd	52		 push	 edx
  001fe	8b 55 ec	 mov	 edx, DWORD PTR _blank$[ebp]
  00201	50		 push	 eax
  00202	8b 03		 mov	 eax, DWORD PTR [ebx]
  00204	51		 push	 ecx
  00205	52		 push	 edx
  00206	50		 push	 eax
  00207	e8 00 00 00 00	 call	 ?gObjTradeItemBoxSet@@YAHHHHHE@Z ; gObjTradeItemBoxSet

; 10368: 		ItemByteConvert(itembuf,lpObj->Trade[blank]);

  0020c	8b b3 b4 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3252]
  00212	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00218	03 f7		 add	 esi, edi
  0021a	8b fc		 mov	 edi, esp
  0021c	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00221	f3 a5		 rep movsd
  00223	8d 4d f4	 lea	 ecx, DWORD PTR _itembuf$165472[ebp]
  00226	51		 push	 ecx
  00227	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 10369: 		GCTradeOtherAdd(lpObj->TargetNumber,blank,itembuf);

  0022c	8b 45 ec	 mov	 eax, DWORD PTR _blank$[ebp]
  0022f	0f bf 8b d4 02
	00 00		 movsx	 ecx, WORD PTR [ebx+724]
  00236	8d 55 f4	 lea	 edx, DWORD PTR _itembuf$165472[ebp]
  00239	52		 push	 edx
  0023a	50		 push	 eax
  0023b	51		 push	 ecx
  0023c	e8 00 00 00 00	 call	 ?GCTradeOtherAdd@@YAHHEPAE@Z ; GCTradeOtherAdd

; 10374: 	return -1;
; 10375: }

  00241	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00244	81 c4 b8 00 00
	00		 add	 esp, 184		; 000000b8H
  0024a	5f		 pop	 edi
  0024b	5e		 pop	 esi
  0024c	33 cd		 xor	 ecx, ebp
  0024e	b0 01		 mov	 al, 1
  00250	5b		 pop	 ebx
  00251	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00256	8b e5		 mov	 esp, ebp
  00258	5d		 pop	 ebp
  00259	c3		 ret	 0
?gObjTradeTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z ENDP	; gObjTradeTradeMove
_TEXT	ENDS
PUBLIC	?gObjTempInventoryItemBoxSet@@YAXPAEHHHE@Z	; gObjTempInventoryItemBoxSet
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?gObjTempInventoryItemBoxSet@@YAXPAEHHHE@Z
_TEXT	SEGMENT
_TempMap$ = 8						; size = 4
_itempos$ = 12						; size = 4
_xl$ = 16						; size = 4
_yl$ = 20						; size = 4
_set_byte$ = 24						; size = 1
?gObjTempInventoryItemBoxSet@@YAXPAEHHHE@Z PROC		; gObjTempInventoryItemBoxSet, COMDAT

; 10419: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10420: 	int itemposx = (itempos - INVETORY_WEAR_SIZE) % 8;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  00006	83 c0 f4	 add	 eax, -12		; fffffff4H
  00009	8b c8		 mov	 ecx, eax
  0000b	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H
  00011	79 05		 jns	 SHORT $LN13@gObjTempIn
  00013	49		 dec	 ecx
  00014	83 c9 f8	 or	 ecx, -8			; fffffff8H
  00017	41		 inc	 ecx
$LN13@gObjTempIn:

; 10421: 	int itemposy = (itempos - INVETORY_WEAR_SIZE) / 8;

  00018	99		 cdq
  00019	83 e2 07	 and	 edx, 7
  0001c	03 c2		 add	 eax, edx

; 10422: 
; 10423: 	for(int y = 0 ; y < yl ; y++)

  0001e	8b 55 14	 mov	 edx, DWORD PTR _yl$[ebp]
  00021	c1 f8 03	 sar	 eax, 3
  00024	85 d2		 test	 edx, edx
  00026	7e 29		 jle	 SHORT $LN4@gObjTempIn

; 10420: 	int itemposx = (itempos - INVETORY_WEAR_SIZE) % 8;

  00028	53		 push	 ebx
  00029	8b 5d 10	 mov	 ebx, DWORD PTR _xl$[ebp]
  0002c	56		 push	 esi
  0002d	8d 34 c1	 lea	 esi, DWORD PTR [ecx+eax*8]
  00030	03 75 08	 add	 esi, DWORD PTR _TempMap$[ebp]
  00033	57		 push	 edi
  00034	8b fa		 mov	 edi, edx
$LL6@gObjTempIn:

; 10424: 	{
; 10425: 		for(int x = 0; x < xl; x++)

  00036	85 db		 test	 ebx, ebx
  00038	7e 0e		 jle	 SHORT $LN5@gObjTempIn
  0003a	8b 45 18	 mov	 eax, DWORD PTR _set_byte$[ebp]
  0003d	53		 push	 ebx
  0003e	50		 push	 eax
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 _memset
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@gObjTempIn:

; 10422: 
; 10423: 	for(int y = 0 ; y < yl ; y++)

  00048	83 c6 08	 add	 esi, 8
  0004b	4f		 dec	 edi
  0004c	75 e8		 jne	 SHORT $LL6@gObjTempIn
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
$LN4@gObjTempIn:

; 10426: 		{
; 10427: 			*(BYTE*)(TempMap + (itemposy +y) * 8 + (itemposx + x)) = set_byte;
; 10428: 		}
; 10429: 	}
; 10430: }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?gObjTempInventoryItemBoxSet@@YAXPAEHHHE@Z ENDP		; gObjTempInventoryItemBoxSet
_TEXT	ENDS
PUBLIC	?gObjTempInventoryRectCheck@@YAEPAEHHHH@Z	; gObjTempInventoryRectCheck
; Function compile flags: /Ogtp
;	COMDAT ?gObjTempInventoryRectCheck@@YAEPAEHHHH@Z
_TEXT	SEGMENT
_TempMap$ = 8						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
?gObjTempInventoryRectCheck@@YAEPAEHHHH@Z PROC		; gObjTempInventoryRectCheck, COMDAT

; 10433: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10434: 	int x,y,blank = 0;
; 10435: 
; 10436: 	if(sx + width > 8)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  00006	56		 push	 esi
  00007	8b 75 14	 mov	 esi, DWORD PTR _width$[ebp]
  0000a	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0000d	83 f9 08	 cmp	 ecx, 8
  00010	7e 05		 jle	 SHORT $LN10@gObjTempIn@2

; 10437: 	{
; 10438: 		return -1;

  00012	0c ff		 or	 al, 255			; 000000ffH
  00014	5e		 pop	 esi

; 10459: 	}
; 10460: 	return -1;
; 10461: }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
$LN10@gObjTempIn@2:
  00017	53		 push	 ebx

; 10439: 	}
; 10440: 	if(sy + height > 8)

  00018	8b 5d 10	 mov	 ebx, DWORD PTR _sy$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 18	 mov	 edi, DWORD PTR _height$[ebp]
  0001f	8d 14 3b	 lea	 edx, DWORD PTR [ebx+edi]
  00022	83 fa 08	 cmp	 edx, 8
  00025	7e 07		 jle	 SHORT $LN9@gObjTempIn@2

; 10441: 	{
; 10442: 		return -2;

  00027	5f		 pop	 edi
  00028	5b		 pop	 ebx
  00029	b0 fe		 mov	 al, 254			; 000000feH
  0002b	5e		 pop	 esi

; 10459: 	}
; 10460: 	return -1;
; 10461: }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN9@gObjTempIn@2:

; 10443: 	}
; 10444: 
; 10445: 	for(y = 0; y < height; y++)

  0002e	33 d2		 xor	 edx, edx
  00030	85 ff		 test	 edi, edi
  00032	7e 28		 jle	 SHORT $LN18@gObjTempIn@2
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _TempMap$[ebp]
  00037	8d 0c d9	 lea	 ecx, DWORD PTR [ecx+ebx*8]
  0003a	03 c8		 add	 ecx, eax
  0003c	8d 64 24 00	 npad	 4
$LL8@gObjTempIn@2:

; 10446: 	{
; 10447: 		for(x = 0; x < width; x++)

  00040	33 c0		 xor	 eax, eax
  00042	85 f6		 test	 esi, esi
  00044	7e 0b		 jle	 SHORT $LN7@gObjTempIn@2
$LL5@gObjTempIn@2:

; 10448: 		{
; 10449: 			if(*(BYTE*)(TempMap + (sy+y)*8 + (sx+x))!= 255)

  00046	80 3c 01 ff	 cmp	 BYTE PTR [ecx+eax], 255	; 000000ffH
  0004a	75 19		 jne	 SHORT $LN15@gObjTempIn@2

; 10446: 	{
; 10447: 		for(x = 0; x < width; x++)

  0004c	40		 inc	 eax
  0004d	3b c6		 cmp	 eax, esi
  0004f	7c f5		 jl	 SHORT $LL5@gObjTempIn@2
$LN7@gObjTempIn@2:

; 10443: 	}
; 10444: 
; 10445: 	for(y = 0; y < height; y++)

  00051	42		 inc	 edx
  00052	83 c1 08	 add	 ecx, 8
  00055	3b d7		 cmp	 edx, edi
  00057	7c e7		 jl	 SHORT $LL8@gObjTempIn@2

; 10448: 		{
; 10449: 			if(*(BYTE*)(TempMap + (sy+y)*8 + (sx+x))!= 255)

  00059	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
$LN18@gObjTempIn@2:
  0005c	5f		 pop	 edi

; 10453: 			}
; 10454: 		}
; 10455: 	}
; 10456: 	if(blank == 0)
; 10457: 	{
; 10458: 		return sx+sy*8+INVETORY_WEAR_SIZE;

  0005d	8d 44 d8 0c	 lea	 eax, DWORD PTR [eax+ebx*8+12]
  00061	5b		 pop	 ebx
  00062	5e		 pop	 esi

; 10459: 	}
; 10460: 	return -1;
; 10461: }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN15@gObjTempIn@2:
  00065	5f		 pop	 edi
  00066	5b		 pop	 ebx

; 10450: 			{
; 10451: 				blank += 1;
; 10452: 				return -1;

  00067	0c ff		 or	 al, 255			; 000000ffH
  00069	5e		 pop	 esi

; 10459: 	}
; 10460: 	return -1;
; 10461: }

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?gObjTempInventoryRectCheck@@YAEPAEHHHH@Z ENDP		; gObjTempInventoryRectCheck
_TEXT	ENDS
PUBLIC	_TempMap$GSCopy$
PUBLIC	?gObjTempInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@VCItem@@PAE@Z ; gObjTempInventoryInsertItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjTempInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@VCItem@@PAE@Z
_TEXT	SEGMENT
_TempMap$GSCopy$ = -16					; size = 4
_iwidth$ = -12						; size = 4
_iheight$ = -8						; size = 4
tv201 = -4						; size = 4
_lpObj$ = 8						; size = 4
_item$ = 12						; size = 168
_TempMap$ = 180						; size = 4
?gObjTempInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@VCItem@@PAE@Z PROC ; gObjTempInventoryInsertItem, COMDAT

; 10464: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b 9d b4 00 00
	00		 mov	 ebx, DWORD PTR _TempMap$[ebp]

; 10465: 	int w,h,iwidth,iheight;
; 10466: 	BYTE blank = 0;
; 10467: 
; 10468: 	if(item.GetSize(iwidth,iheight) == 0)

  0000d	8d 45 f8	 lea	 eax, DWORD PTR _iheight$[ebp]
  00010	50		 push	 eax
  00011	8d 4d f4	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00014	51		 push	 ecx
  00015	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]

; 10472: 	}
; 10473: 	for(h = 0; h < 8; h++)

  00018	89 5d f0	 mov	 DWORD PTR _TempMap$GSCopy$[ebp], ebx
  0001b	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00020	85 c0		 test	 eax, eax
  00022	75 30		 jne	 SHORT $LN11@gObjTempIn@3

; 10469: 	{
; 10470: 		LogAdd(LOG_BLACK, lMsg.Get(532),__FILE__,__LINE__,item.m_Type);

  00024	0f bf 55 12	 movsx	 edx, WORD PTR _item$[ebp+6]
  00028	52		 push	 edx
  00029	68 e6 28 00 00	 push	 10470			; 000028e6H
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00033	68 14 02 00 00	 push	 532			; 00000214H
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0003d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00042	50		 push	 eax
  00043	6a 00		 push	 0
  00045	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0004a	83 c4 14	 add	 esp, 20			; 00000014H

; 10471: 		return -1;

  0004d	0c ff		 or	 al, 255			; 000000ffH
  0004f	5b		 pop	 ebx

; 10495: }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN11@gObjTempIn@3:
  00054	57		 push	 edi

; 10472: 	}
; 10473: 	for(h = 0; h < 8; h++)

  00055	33 ff		 xor	 edi, edi
  00057	89 5d fc	 mov	 DWORD PTR tv201[ebp], ebx
  0005a	56		 push	 esi
  0005b	eb 03 8d 49 00	 npad	 5
$LL21@gObjTempIn@3:

; 10474: 	{
; 10475: 		for(w = 0; w < 8; w++)

  00060	33 f6		 xor	 esi, esi
$LL20@gObjTempIn@3:

; 10476: 		{
; 10477: 			if(*(BYTE*)(TempMap + h * 8 + w) == 255)

  00062	8b 45 fc	 mov	 eax, DWORD PTR tv201[ebp]
  00065	80 3c 30 ff	 cmp	 BYTE PTR [eax+esi], 255	; 000000ffH
  00069	75 22		 jne	 SHORT $LN6@gObjTempIn@3

; 10478: 			{
; 10479: 				blank = gObjTempInventoryRectCheck(TempMap,w,h,iwidth,iheight);

  0006b	8b 4d f8	 mov	 ecx, DWORD PTR _iheight$[ebp]
  0006e	8b 55 f4	 mov	 edx, DWORD PTR _iwidth$[ebp]
  00071	51		 push	 ecx
  00072	52		 push	 edx
  00073	57		 push	 edi
  00074	56		 push	 esi
  00075	53		 push	 ebx
  00076	e8 00 00 00 00	 call	 ?gObjTempInventoryRectCheck@@YAEPAEHHHH@Z ; gObjTempInventoryRectCheck
  0007b	8a d8		 mov	 bl, al
  0007d	83 c4 14	 add	 esp, 20			; 00000014H

; 10480: 
; 10481: 				if(blank == 254)

  00080	80 fb fe	 cmp	 bl, 254			; 000000feH
  00083	74 18		 je	 SHORT $GOTO_EndFunc$165543

; 10482: 				{
; 10483: 					goto GOTO_EndFunc;
; 10484: 				}
; 10485: 				if(blank != 255)

  00085	80 fb ff	 cmp	 bl, 255			; 000000ffH
  00088	75 1c		 jne	 SHORT $LN17@gObjTempIn@3
  0008a	8b 5d f0	 mov	 ebx, DWORD PTR _TempMap$GSCopy$[ebp]
$LN6@gObjTempIn@3:

; 10474: 	{
; 10475: 		for(w = 0; w < 8; w++)

  0008d	46		 inc	 esi
  0008e	83 fe 08	 cmp	 esi, 8
  00091	7c cf		 jl	 SHORT $LL20@gObjTempIn@3

; 10472: 	}
; 10473: 	for(h = 0; h < 8; h++)

  00093	83 45 fc 08	 add	 DWORD PTR tv201[ebp], 8
  00097	47		 inc	 edi
  00098	83 ff 08	 cmp	 edi, 8
  0009b	7c c3		 jl	 SHORT $LL21@gObjTempIn@3
$GOTO_EndFunc$165543:
  0009d	5e		 pop	 esi
  0009e	5f		 pop	 edi

; 10489: 				}
; 10490: 			}
; 10491: 		}
; 10492: 	}
; 10493: GOTO_EndFunc:
; 10494: 	return -1;

  0009f	0c ff		 or	 al, 255			; 000000ffH
  000a1	5b		 pop	 ebx

; 10495: }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN17@gObjTempIn@3:

; 10486: 				{
; 10487: 					gObjTempInventoryItemBoxSet(TempMap,blank,iwidth,iheight,item.m_Type);

  000a6	8b 45 12	 mov	 eax, DWORD PTR _item$[ebp+6]
  000a9	8b 4d f8	 mov	 ecx, DWORD PTR _iheight$[ebp]
  000ac	8b 55 f4	 mov	 edx, DWORD PTR _iwidth$[ebp]
  000af	50		 push	 eax
  000b0	51		 push	 ecx
  000b1	8b 4d f0	 mov	 ecx, DWORD PTR _TempMap$GSCopy$[ebp]
  000b4	0f b6 c3	 movzx	 eax, bl
  000b7	52		 push	 edx
  000b8	50		 push	 eax
  000b9	51		 push	 ecx
  000ba	e8 00 00 00 00	 call	 ?gObjTempInventoryItemBoxSet@@YAXPAEHHHE@Z ; gObjTempInventoryItemBoxSet
  000bf	83 c4 14	 add	 esp, 20			; 00000014H
  000c2	5e		 pop	 esi
  000c3	5f		 pop	 edi

; 10488: 					return blank;

  000c4	8a c3		 mov	 al, bl
  000c6	5b		 pop	 ebx

; 10495: }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
?gObjTempInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@VCItem@@PAE@Z ENDP ; gObjTempInventoryInsertItem
_TEXT	ENDS
PUBLIC	_sqrtf
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?TradeItemInventoryPutTest@@YAHH@Z		; TradeItemInventoryPutTest
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
;	COMDAT ?TradeItemInventoryPutTest@@YAHH@Z
_TEXT	SEGMENT
tv160 = -76						; size = 4
tv173 = -72						; size = 4
_TempInventoryMap$ = -68				; size = 64
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?TradeItemInventoryPutTest@@YAHH@Z PROC			; TradeItemInventoryPutTest, COMDAT

; 10498: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 10499: 	BYTE TempInventoryMap[64];
; 10500: 	int number,result = 1;
; 10501: 	number = gObj[aIndex].TargetNumber;

  00015	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0001b	0f bf 96 d4 02
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+724]
  00022	57		 push	 edi

; 10502: 
; 10503: 	if(gObjIsConnected(number) == 0)

  00023	52		 push	 edx
  00024	89 75 b4	 mov	 DWORD PTR tv160[ebp], esi
  00027	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002c	83 c4 04	 add	 esp, 4
  0002f	85 c0		 test	 eax, eax
  00031	75 13		 jne	 SHORT $LN7@TradeItemI
$LN11@TradeItemI:

; 10504: 	{
; 10505: 		return false;

  00033	33 c0		 xor	 eax, eax

; 10514: 			{
; 10515: 				return false;
; 10516: 			}
; 10517: 			result = 1;
; 10518: 		}
; 10519: 	}
; 10520: 	if(result == 1)
; 10521: 	{
; 10522: 		return true;
; 10523: 	}
; 10524: 	return false;
; 10525: }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003b	33 cd		 xor	 ecx, ebp
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN7@TradeItemI:

; 10506: 	}
; 10507: 	memcpy(TempInventoryMap,gObj[aIndex].pInventoryMap,64);

  00046	8b b6 90 0c 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3216]
  0004c	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00052	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00057	8d 7d bc	 lea	 edi, DWORD PTR _TempInventoryMap$[ebp]
  0005a	f3 a5		 rep movsd
  0005c	8d b2 b4 0c 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3252]
  00062	89 75 b8	 mov	 DWORD PTR tv173[ebp], esi
  00065	33 db		 xor	 ebx, ebx
$LL6@TradeItemI:

; 10510: 	{
; 10511: 		if(gObj[number].Trade[n].IsItem() == 1)

  00067	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00069	03 cb		 add	 ecx, ebx
  0006b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00070	83 f8 01	 cmp	 eax, 1
  00073	75 33		 jne	 SHORT $LN5@TradeItemI

; 10512: 		{
; 10513: 			if(gObjTempInventoryInsertItem(&gObj[aIndex],gObj[number].Trade[n],TempInventoryMap) == 255)

  00075	8b 36		 mov	 esi, DWORD PTR [esi]
  00077	8d 45 bc	 lea	 eax, DWORD PTR _TempInventoryMap$[ebp]
  0007a	50		 push	 eax
  0007b	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00081	8b fc		 mov	 edi, esp
  00083	03 f3		 add	 esi, ebx
  00085	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0008a	f3 a5		 rep movsd
  0008c	8b 4d b4	 mov	 ecx, DWORD PTR tv160[ebp]
  0008f	8d 91 00 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx]
  00095	52		 push	 edx
  00096	e8 00 00 00 00	 call	 ?gObjTempInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@VCItem@@PAE@Z ; gObjTempInventoryInsertItem
  0009b	81 c4 b0 00 00
	00		 add	 esp, 176		; 000000b0H
  000a1	3c ff		 cmp	 al, 255			; 000000ffH
  000a3	74 8e		 je	 SHORT $LN11@TradeItemI
  000a5	8b 75 b8	 mov	 esi, DWORD PTR tv173[ebp]
$LN5@TradeItemI:

; 10508: 
; 10509: 	for(int n = 0; n < TRADE_BOX_SIZE; n++)

  000a8	81 c3 a8 00 00
	00		 add	 ebx, 168		; 000000a8H
  000ae	81 fb 00 15 00
	00		 cmp	 ebx, 5376		; 00001500H
  000b4	7c b1		 jl	 SHORT $LL6@TradeItemI

; 10514: 			{
; 10515: 				return false;
; 10516: 			}
; 10517: 			result = 1;
; 10518: 		}
; 10519: 	}
; 10520: 	if(result == 1)
; 10521: 	{
; 10522: 		return true;
; 10523: 	}
; 10524: 	return false;
; 10525: }

  000b6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	33 cd		 xor	 ecx, ebp
  000bd	b8 01 00 00 00	 mov	 eax, 1
  000c2	5b		 pop	 ebx
  000c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
?TradeItemInventoryPutTest@@YAHH@Z ENDP			; TradeItemInventoryPutTest
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 542  :         {return (sqrtf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
PUBLIC	?LevelSmallConvert@@YAEHH@Z			; LevelSmallConvert
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
;	COMDAT ?LevelSmallConvert@@YAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_inventoryindex$ = 12					; size = 4
?LevelSmallConvert@@YAEHH@Z PROC			; LevelSmallConvert, COMDAT

; 10700: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10701: 	int level = gObj[aIndex].pInventory[inventoryindex].m_Level;

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _inventoryindex$[ebp]
  00009	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0000f	8b 90 8c 0c 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3212]
  00015	69 c9 a8 00 00
	00		 imul	 ecx, 168		; 000000a8H
  0001b	0f bf 44 0a 08	 movsx	 eax, WORD PTR [edx+ecx+8]

; 10702: 
; 10703: 	if(level >= 15)

  00020	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00023	7c 04		 jl	 SHORT $LN7@LevelSmall

; 10704: 	{
; 10705: 		return 7;

  00025	b0 07		 mov	 al, 7

; 10734: 	{
; 10735: 		return 1;
; 10736: 	}
; 10737: 	
; 10738: 	return 0;
; 10739: }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN7@LevelSmall:

; 10706: 	}
; 10707: 
; 10708: 	if(level >= 13 && level <= 14)

  00029	8d 48 f3	 lea	 ecx, DWORD PTR [eax-13]
  0002c	83 f9 01	 cmp	 ecx, 1
  0002f	77 04		 ja	 SHORT $LN6@LevelSmall

; 10709: 	{
; 10710: 		return 6;

  00031	b0 06		 mov	 al, 6

; 10734: 	{
; 10735: 		return 1;
; 10736: 	}
; 10737: 	
; 10738: 	return 0;
; 10739: }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN6@LevelSmall:

; 10711: 	}
; 10712: 
; 10713: 	if(level >= 11 && level <= 12)

  00035	8d 50 f5	 lea	 edx, DWORD PTR [eax-11]
  00038	83 fa 01	 cmp	 edx, 1
  0003b	77 04		 ja	 SHORT $LN5@LevelSmall

; 10714: 	{
; 10715: 		return 5;

  0003d	b0 05		 mov	 al, 5

; 10734: 	{
; 10735: 		return 1;
; 10736: 	}
; 10737: 	
; 10738: 	return 0;
; 10739: }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN5@LevelSmall:

; 10716: 	}
; 10717: 
; 10718: 	if(level >= 9 && level <= 10)

  00041	8d 48 f7	 lea	 ecx, DWORD PTR [eax-9]
  00044	83 f9 01	 cmp	 ecx, 1
  00047	77 04		 ja	 SHORT $LN4@LevelSmall

; 10719: 	{
; 10720: 		return 4;

  00049	b0 04		 mov	 al, 4

; 10734: 	{
; 10735: 		return 1;
; 10736: 	}
; 10737: 	
; 10738: 	return 0;
; 10739: }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN4@LevelSmall:

; 10721: 	}
; 10722: 
; 10723: 	if(level >= 7 && level <= 8)

  0004d	8d 50 f9	 lea	 edx, DWORD PTR [eax-7]
  00050	83 fa 01	 cmp	 edx, 1
  00053	77 04		 ja	 SHORT $LN3@LevelSmall

; 10724: 	{
; 10725: 		return 3;

  00055	b0 03		 mov	 al, 3

; 10734: 	{
; 10735: 		return 1;
; 10736: 	}
; 10737: 	
; 10738: 	return 0;
; 10739: }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN3@LevelSmall:

; 10726: 	}
; 10727: 
; 10728: 	if(level >= 5 && level <= 6)

  00059	8d 48 fb	 lea	 ecx, DWORD PTR [eax-5]
  0005c	83 f9 01	 cmp	 ecx, 1
  0005f	77 04		 ja	 SHORT $LN2@LevelSmall

; 10729: 	{
; 10730: 		return 2;

  00061	b0 02		 mov	 al, 2

; 10734: 	{
; 10735: 		return 1;
; 10736: 	}
; 10737: 	
; 10738: 	return 0;
; 10739: }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN2@LevelSmall:

; 10731: 	}
; 10732: 
; 10733: 	if(level >= 3 && level <= 4)

  00065	83 c0 fd	 add	 eax, -3			; fffffffdH
  00068	83 f8 01	 cmp	 eax, 1
  0006b	0f 96 c0	 setbe	 al

; 10734: 	{
; 10735: 		return 1;
; 10736: 	}
; 10737: 	
; 10738: 	return 0;
; 10739: }

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?LevelSmallConvert@@YAEHH@Z ENDP			; LevelSmallConvert
_TEXT	ENDS
PUBLIC	?LevelSmallConvert@@YAEH@Z			; LevelSmallConvert
; Function compile flags: /Ogtp
;	COMDAT ?LevelSmallConvert@@YAEH@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
?LevelSmallConvert@@YAEH@Z PROC				; LevelSmallConvert, COMDAT

; 10742: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10743: 	if(level >= 15) //max item lvl

  00003	8b 45 08	 mov	 eax, DWORD PTR _level$[ebp]
  00006	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00009	7c 04		 jl	 SHORT $LN7@LevelSmall@2

; 10744: 	{
; 10745: 		return 7;

  0000b	b0 07		 mov	 al, 7

; 10774: 	{
; 10775: 		return 1;
; 10776: 	}
; 10777: 	
; 10778: 	return 0;
; 10779: }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN7@LevelSmall@2:

; 10746: 	}
; 10747: 	
; 10748: 	if(level >= 13 && level <= 14)

  0000f	8d 48 f3	 lea	 ecx, DWORD PTR [eax-13]
  00012	83 f9 01	 cmp	 ecx, 1
  00015	77 04		 ja	 SHORT $LN6@LevelSmall@2

; 10749: 	{
; 10750: 		return 6;

  00017	b0 06		 mov	 al, 6

; 10774: 	{
; 10775: 		return 1;
; 10776: 	}
; 10777: 	
; 10778: 	return 0;
; 10779: }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN6@LevelSmall@2:

; 10751: 	}
; 10752: 
; 10753: 	if(level >= 11 && level <=12)

  0001b	8d 50 f5	 lea	 edx, DWORD PTR [eax-11]
  0001e	83 fa 01	 cmp	 edx, 1
  00021	77 04		 ja	 SHORT $LN5@LevelSmall@2

; 10754: 	{
; 10755: 		return 5;

  00023	b0 05		 mov	 al, 5

; 10774: 	{
; 10775: 		return 1;
; 10776: 	}
; 10777: 	
; 10778: 	return 0;
; 10779: }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN5@LevelSmall@2:

; 10756: 	}
; 10757: 
; 10758: 	if(level >= 9 && level <= 10)

  00027	8d 48 f7	 lea	 ecx, DWORD PTR [eax-9]
  0002a	83 f9 01	 cmp	 ecx, 1
  0002d	77 04		 ja	 SHORT $LN4@LevelSmall@2

; 10759: 	{
; 10760: 		return 4;

  0002f	b0 04		 mov	 al, 4

; 10774: 	{
; 10775: 		return 1;
; 10776: 	}
; 10777: 	
; 10778: 	return 0;
; 10779: }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN4@LevelSmall@2:

; 10761: 	}
; 10762: 
; 10763: 	if(level >= 7 && level <= 8)

  00033	8d 50 f9	 lea	 edx, DWORD PTR [eax-7]
  00036	83 fa 01	 cmp	 edx, 1
  00039	77 04		 ja	 SHORT $LN3@LevelSmall@2

; 10764: 	{
; 10765: 		return 3;

  0003b	b0 03		 mov	 al, 3

; 10774: 	{
; 10775: 		return 1;
; 10776: 	}
; 10777: 	
; 10778: 	return 0;
; 10779: }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN3@LevelSmall@2:

; 10766: 	}
; 10767: 
; 10768: 	if(level >= 5 && level <= 6)

  0003f	8d 48 fb	 lea	 ecx, DWORD PTR [eax-5]
  00042	83 f9 01	 cmp	 ecx, 1
  00045	77 04		 ja	 SHORT $LN2@LevelSmall@2

; 10769: 	{
; 10770: 		return 2;

  00047	b0 02		 mov	 al, 2

; 10774: 	{
; 10775: 		return 1;
; 10776: 	}
; 10777: 	
; 10778: 	return 0;
; 10779: }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN2@LevelSmall@2:

; 10771: 	}
; 10772: 
; 10773: 	if(level >= 3 && level <= 4)

  0004b	83 c0 fd	 add	 eax, -3			; fffffffdH
  0004e	83 f8 01	 cmp	 eax, 1
  00051	0f 96 c0	 setbe	 al

; 10774: 	{
; 10775: 		return 1;
; 10776: 	}
; 10777: 	
; 10778: 	return 0;
; 10779: }

  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?LevelSmallConvert@@YAEH@Z ENDP				; LevelSmallConvert
_TEXT	ENDS
PUBLIC	?gObjAttackDamageCalc@@YAXH@Z			; gObjAttackDamageCalc
; Function compile flags: /Ogtp
;	COMDAT ?gObjAttackDamageCalc@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjAttackDamageCalc@@YAXH@Z PROC			; gObjAttackDamageCalc, COMDAT

; 10783: 	return;	// Here goes a Macro
; 10784: }

  00000	c3		 ret	 0
?gObjAttackDamageCalc@@YAXH@Z ENDP			; gObjAttackDamageCalc
_TEXT	ENDS
PUBLIC	??_C@_0CF@NBKOABOE@?$FLMAKE?5PREVIEW?5CHARSET?$FN?5Error?5?3?5?$CF@ ; `string'
PUBLIC	?gObjMakePreviewCharSet@@YAXH@Z			; gObjMakePreviewCharSet
EXTRN	?IsSetItem@CItem@@QAEHXZ:PROC			; CItem::IsSetItem
EXTRN	?IsExtItem@CItem@@QAEHXZ:PROC			; CItem::IsExtItem
;	COMDAT ??_C@_0CF@NBKOABOE@?$FLMAKE?5PREVIEW?5CHARSET?$FN?5Error?5?3?5?$CF@
CONST	SEGMENT
??_C@_0CF@NBKOABOE@?$FLMAKE?5PREVIEW?5CHARSET?$FN?5Error?5?3?5?$CF@ DB '['
	DB	'MAKE PREVIEW CHARSET] Error : %s %d', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjMakePreviewCharSet@@YAXH@Z
_TEXT	SEGMENT
tv1314 = -1						; size = 1
_aIndex$ = 8						; size = 4
?gObjMakePreviewCharSet@@YAXH@Z PROC			; gObjMakePreviewCharSet, COMDAT

; 10787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 10788: 	if(!OBJMAX_RANGE(aIndex))

  00004	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00007	85 d2		 test	 edx, edx
  00009	78 0f		 js	 SHORT $LN54@gObjMakePr
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fa e7 1c 00
	00		 cmp	 edx, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 1d		 jne	 SHORT $LN49@gObjMakePr
$LN54@gObjMakePr:

; 10789: 	{
; 10790: 		LogAdd(LOG_RED, "[MAKE PREVIEW CHARSET] Error : %s %d", __FILE__, __LINE__);

  0001a	68 26 2a 00 00	 push	 10790			; 00002a26H
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NBKOABOE@?$FLMAKE?5PREVIEW?5CHARSET?$FN?5Error?5?3?5?$CF@
  00029	6a 01		 push	 1
  0002b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00030	83 c4 10	 add	 esp, 16			; 00000010H

; 11058: 	}
; 11059: }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
$LN49@gObjMakePr:
  00037	56		 push	 esi

; 10791: 		return;
; 10792: 	}
; 10793: 	// ---
; 10794: 	BYTE index;
; 10795: 	// ---
; 10796: 	LPOBJ lpObj = &gObj[aIndex];

  00038	8b f2		 mov	 esi, edx
  0003a	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00040	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 10797: 	// ---
; 10798: 	memset(lpObj->CharSet, 0, sizeof(lpObj->CharSet));

  00046	33 c0		 xor	 eax, eax
  00048	89 86 50 03 00
	00		 mov	 DWORD PTR [esi+848], eax
  0004e	89 86 54 03 00
	00		 mov	 DWORD PTR [esi+852], eax
  00054	89 86 58 03 00
	00		 mov	 DWORD PTR [esi+856], eax
  0005a	89 86 5c 03 00
	00		 mov	 DWORD PTR [esi+860], eax
  00060	66 89 86 60 03
	00 00		 mov	 WORD PTR [esi+864], ax

; 10799: 	// ---
; 10800: 	lpObj->CharSet[CS_CLASS] = CS_SET_CLASS(lpObj->Class);

  00067	0f b6 8e 98 00
	00 00		 movzx	 ecx, BYTE PTR [esi+152]

; 10801: 	lpObj->CharSet[CS_CLASS] |= CS_SET_CHANGEUP(lpObj->ChangeUP);

  0006e	8a 86 9b 00 00
	00		 mov	 al, BYTE PTR [esi+155]
  00074	24 01		 and	 al, 1
  00076	02 c9		 add	 cl, cl
  00078	0a c1		 or	 al, cl

; 10802: 	// ---
; 10803: 	if ( lpObj->m_ActionNumber == 0x80 )

  0007a	8a 8e b8 01 00
	00		 mov	 cl, BYTE PTR [esi+440]
  00080	c0 e0 04	 shl	 al, 4
  00083	88 86 50 03 00
	00		 mov	 BYTE PTR [esi+848], al
  00089	80 f9 80	 cmp	 cl, 128			; 00000080H
  0008c	75 04		 jne	 SHORT $LN48@gObjMakePr

; 10804: 	{
; 10805: 		lpObj->CharSet[CS_CLASS] |= 2;

  0008e	0c 02		 or	 al, 2
  00090	eb 07		 jmp	 SHORT $LN46@gObjMakePr
$LN48@gObjMakePr:

; 10806: 	}
; 10807: 	else if ( lpObj->m_ActionNumber == 0x81 )

  00092	80 f9 81	 cmp	 cl, 129			; 00000081H
  00095	75 02		 jne	 SHORT $LN46@gObjMakePr

; 10808: 	{
; 10809: 		lpObj->CharSet[CS_CLASS] |= 3;

  00097	0c 03		 or	 al, 3
$LN46@gObjMakePr:
  00099	53		 push	 ebx
  0009a	57		 push	 edi

; 10810: 	}
; 10811: 	else
; 10812: 	{
; 10813: 		lpObj->CharSet[CS_CLASS] = lpObj->CharSet[CS_CLASS];
; 10814: 	}
; 10815: 	// ---
; 10816: 	if(lpObj->pInventory[0].m_Type < ITEMGET(0,0))

  0009b	8b be 8c 0c 00
	00		 mov	 edi, DWORD PTR [esi+3212]
  000a1	88 86 50 03 00
	00		 mov	 BYTE PTR [esi+848], al
  000a7	66 83 7f 06 00	 cmp	 WORD PTR [edi+6], 0
  000ac	b0 ff		 mov	 al, 255			; 000000ffH

; 10817: 	{
; 10818: 		lpObj->CharSet[CS_WEAPON1_DATA] |= (BYTE)DBI_GET_TYPE(-1);

  000ae	b1 f0		 mov	 cl, 240			; 000000f0H
  000b0	7d 0e		 jge	 SHORT $LN44@gObjMakePr
  000b2	08 8e 5c 03 00
	00		 or	 BYTE PTR [esi+860], cl

; 10819: 		lpObj->CharSet[CS_WEAPON1_TYPE] = (BYTE)DBI_GET_INDEX(-1);

  000b8	88 86 51 03 00
	00		 mov	 BYTE PTR [esi+849], al

; 10820: 	}
; 10821: 	else

  000be	eb 19		 jmp	 SHORT $LN43@gObjMakePr
$LN44@gObjMakePr:

; 10822: 	{
; 10823: 		lpObj->CharSet[CS_WEAPON1_DATA] |= DBI_GET_TYPE(lpObj->pInventory[0].m_Type);

  000c0	66 8b 5f 06	 mov	 bx, WORD PTR [edi+6]
  000c4	66 c1 fb 04	 sar	 bx, 4
  000c8	22 d9		 and	 bl, cl
  000ca	08 9e 5c 03 00
	00		 or	 BYTE PTR [esi+860], bl

; 10824: 		lpObj->CharSet[CS_WEAPON1_TYPE] = DBI_GET_INDEX(lpObj->pInventory[0].m_Type);

  000d0	8a 5f 06	 mov	 bl, BYTE PTR [edi+6]
  000d3	88 9e 51 03 00
	00		 mov	 BYTE PTR [esi+849], bl
$LN43@gObjMakePr:

; 10825: 	}
; 10826: 	// ---
; 10827: 	if(lpObj->pInventory[1].m_Type < ITEMGET(0,0))

  000d9	66 83 bf ae 00
	00 00 00	 cmp	 WORD PTR [edi+174], 0
  000e1	7d 08		 jge	 SHORT $LN42@gObjMakePr

; 10828: 	{
; 10829: 		lpObj->CharSet[CS_WEAPON2_DATA] |= (BYTE)DBI_GET_TYPE(-1);

  000e3	08 8e 5d 03 00
	00		 or	 BYTE PTR [esi+861], cl

; 10830: 		lpObj->CharSet[CS_WEAPON2_TYPE] = (BYTE)DBI_GET_INDEX(-1);
; 10831: 	}
; 10832: 	else

  000e9	eb 19		 jmp	 SHORT $LN56@gObjMakePr
$LN42@gObjMakePr:

; 10833: 	{
; 10834: 		lpObj->CharSet[CS_WEAPON2_DATA] |= DBI_GET_TYPE(lpObj->pInventory[1].m_Type);

  000eb	66 8b 87 ae 00
	00 00		 mov	 ax, WORD PTR [edi+174]
  000f2	66 c1 f8 04	 sar	 ax, 4
  000f6	22 c1		 and	 al, cl
  000f8	08 86 5d 03 00
	00		 or	 BYTE PTR [esi+861], al

; 10835: 		lpObj->CharSet[CS_WEAPON2_TYPE] = DBI_GET_INDEX(lpObj->pInventory[1].m_Type);

  000fe	8a 87 ae 00 00
	00		 mov	 al, BYTE PTR [edi+174]
$LN56@gObjMakePr:
  00104	88 86 52 03 00
	00		 mov	 BYTE PTR [esi+850], al

; 10836: 	}
; 10837: 	// ---
; 10838: 	if(lpObj->pInventory[2].m_Type < ITEMGET(0,0))

  0010a	66 83 bf 56 01
	00 00 00	 cmp	 WORD PTR [edi+342], 0

; 10839: 	{
; 10840: 		lpObj->CharSet[13] |= CS_SET_HELMET1(-1);

  00112	b0 0f		 mov	 al, 15			; 0000000fH
  00114	7d 15		 jge	 SHORT $LN40@gObjMakePr
  00116	08 86 5d 03 00
	00		 or	 BYTE PTR [esi+861], al

; 10841: 		lpObj->CharSet[9]  |= CS_SET_HELMET2(-1);

  0011c	80 8e 59 03 00
	00 80		 or	 BYTE PTR [esi+857], 128	; 00000080H

; 10842: 		lpObj->CharSet[3]  |= CS_SET_HELMET3(-1);

  00123	08 8e 53 03 00
	00		 or	 BYTE PTR [esi+851], cl

; 10843: 	}
; 10844: 	else

  00129	eb 38		 jmp	 SHORT $LN39@gObjMakePr
$LN40@gObjMakePr:

; 10845: 	{
; 10846: 		lpObj->CharSet[13] |= CS_SET_HELMET1(lpObj->pInventory[2].m_Type);

  0012b	66 8b 9f 56 01
	00 00		 mov	 bx, WORD PTR [edi+342]
  00132	66 c1 fb 05	 sar	 bx, 5
  00136	22 d8		 and	 bl, al
  00138	08 9e 5d 03 00
	00		 or	 BYTE PTR [esi+861], bl

; 10847: 		lpObj->CharSet[9]  |= CS_SET_HELMET2(lpObj->pInventory[2].m_Type);

  0013e	0f b6 9f 56 01
	00 00		 movzx	 ebx, BYTE PTR [edi+342]
  00145	22 d9		 and	 bl, cl
  00147	02 db		 add	 bl, bl
  00149	02 db		 add	 bl, bl
  0014b	02 db		 add	 bl, bl
  0014d	08 9e 59 03 00
	00		 or	 BYTE PTR [esi+857], bl

; 10848: 		lpObj->CharSet[3]  |= CS_SET_HELMET3(lpObj->pInventory[2].m_Type);

  00153	0f b6 9f 56 01
	00 00		 movzx	 ebx, BYTE PTR [edi+342]
  0015a	c0 e3 04	 shl	 bl, 4
  0015d	08 9e 53 03 00
	00		 or	 BYTE PTR [esi+851], bl
$LN39@gObjMakePr:

; 10849: 	}
; 10850: 	// ---
; 10851: 	if(lpObj->pInventory[3].m_Type < ITEMGET(0,0))

  00163	66 83 bf fe 01
	00 00 00	 cmp	 WORD PTR [edi+510], 0
  0016b	7d 15		 jge	 SHORT $LN38@gObjMakePr

; 10852: 	{
; 10853: 		lpObj->CharSet[14] |= CS_SET_ARMOR1(-1);

  0016d	08 8e 5e 03 00
	00		 or	 BYTE PTR [esi+862], cl

; 10854: 		lpObj->CharSet[9]  |= CS_SET_ARMOR2(-1);

  00173	80 8e 59 03 00
	00 40		 or	 BYTE PTR [esi+857], 64	; 00000040H

; 10855: 		lpObj->CharSet[3]  |= CS_SET_ARMOR3(-1);

  0017a	08 86 53 03 00
	00		 or	 BYTE PTR [esi+851], al

; 10856: 	}
; 10857: 	else

  00180	eb 35		 jmp	 SHORT $LN37@gObjMakePr
$LN38@gObjMakePr:

; 10858: 	{
; 10859: 		lpObj->CharSet[14] |= CS_SET_ARMOR1(lpObj->pInventory[3].m_Type);

  00182	66 8b 9f fe 01
	00 00		 mov	 bx, WORD PTR [edi+510]
  00189	66 d1 fb	 sar	 bx, 1
  0018c	22 d9		 and	 bl, cl
  0018e	08 9e 5e 03 00
	00		 or	 BYTE PTR [esi+862], bl

; 10860: 		lpObj->CharSet[9]  |= CS_SET_ARMOR2(lpObj->pInventory[3].m_Type);

  00194	0f b6 9f fe 01
	00 00		 movzx	 ebx, BYTE PTR [edi+510]
  0019b	80 e3 10	 and	 bl, 16			; 00000010H
  0019e	02 db		 add	 bl, bl
  001a0	02 db		 add	 bl, bl
  001a2	08 9e 59 03 00
	00		 or	 BYTE PTR [esi+857], bl

; 10861: 		lpObj->CharSet[3]  |= CS_SET_ARMOR3(lpObj->pInventory[3].m_Type);

  001a8	0f b6 9f fe 01
	00 00		 movzx	 ebx, BYTE PTR [edi+510]
  001af	22 d8		 and	 bl, al
  001b1	08 9e 53 03 00
	00		 or	 BYTE PTR [esi+851], bl
$LN37@gObjMakePr:

; 10862: 	}
; 10863: 	// ---
; 10864: 	if(lpObj->pInventory[4].m_Type < ITEMGET(0,0))

  001b7	66 83 bf a6 02
	00 00 00	 cmp	 WORD PTR [edi+678], 0
  001bf	7d 15		 jge	 SHORT $LN36@gObjMakePr

; 10865: 	{
; 10866: 		lpObj->CharSet[14] |= CS_SET_PANTS1(-1);

  001c1	08 86 5e 03 00
	00		 or	 BYTE PTR [esi+862], al

; 10867: 		lpObj->CharSet[9]  |= CS_SET_PANTS2(-1);

  001c7	80 8e 59 03 00
	00 20		 or	 BYTE PTR [esi+857], 32	; 00000020H

; 10868: 		lpObj->CharSet[4]  |= CS_SET_PANTS3(-1);

  001ce	08 8e 54 03 00
	00		 or	 BYTE PTR [esi+852], cl

; 10869: 	}
; 10870: 	else

  001d4	eb 35		 jmp	 SHORT $LN35@gObjMakePr
$LN36@gObjMakePr:

; 10871: 	{
; 10872: 		lpObj->CharSet[14] |= CS_SET_PANTS1(lpObj->pInventory[4].m_Type);

  001d6	66 8b 9f a6 02
	00 00		 mov	 bx, WORD PTR [edi+678]
  001dd	66 c1 fb 05	 sar	 bx, 5
  001e1	22 d8		 and	 bl, al
  001e3	08 9e 5e 03 00
	00		 or	 BYTE PTR [esi+862], bl

; 10873: 		lpObj->CharSet[9]  |= CS_SET_PANTS2(lpObj->pInventory[4].m_Type);

  001e9	0f b6 9f a6 02
	00 00		 movzx	 ebx, BYTE PTR [edi+678]
  001f0	80 e3 10	 and	 bl, 16			; 00000010H
  001f3	02 db		 add	 bl, bl
  001f5	08 9e 59 03 00
	00		 or	 BYTE PTR [esi+857], bl

; 10874: 		lpObj->CharSet[4]  |= CS_SET_PANTS3(lpObj->pInventory[4].m_Type);

  001fb	0f b6 9f a6 02
	00 00		 movzx	 ebx, BYTE PTR [edi+678]
  00202	c0 e3 04	 shl	 bl, 4
  00205	08 9e 54 03 00
	00		 or	 BYTE PTR [esi+852], bl
$LN35@gObjMakePr:

; 10875: 	}
; 10876: 	// ---
; 10877: 	if(lpObj->pInventory[5].m_Type < ITEMGET(0,0))

  0020b	66 83 bf 4e 03
	00 00 00	 cmp	 WORD PTR [edi+846], 0
  00213	7d 15		 jge	 SHORT $LN34@gObjMakePr

; 10878: 	{
; 10879: 		lpObj->CharSet[15] |= CS_SET_GLOVES1(-1);

  00215	08 8e 5f 03 00
	00		 or	 BYTE PTR [esi+863], cl

; 10880: 		lpObj->CharSet[9]  |= CS_SET_GLOVES2(-1);

  0021b	80 8e 59 03 00
	00 10		 or	 BYTE PTR [esi+857], 16	; 00000010H

; 10881: 		lpObj->CharSet[4]  |= CS_SET_GLOVES3(-1);

  00222	08 86 54 03 00
	00		 or	 BYTE PTR [esi+852], al

; 10882: 	}
; 10883: 	else

  00228	eb 31		 jmp	 SHORT $LN33@gObjMakePr
$LN34@gObjMakePr:

; 10884: 	{
; 10885: 		lpObj->CharSet[15] |= CS_SET_GLOVES1(lpObj->pInventory[5].m_Type);

  0022a	66 8b 9f 4e 03
	00 00		 mov	 bx, WORD PTR [edi+846]
  00231	66 d1 fb	 sar	 bx, 1
  00234	22 d9		 and	 bl, cl
  00236	08 9e 5f 03 00
	00		 or	 BYTE PTR [esi+863], bl

; 10886: 		lpObj->CharSet[9]  |= CS_SET_GLOVES2(lpObj->pInventory[5].m_Type);

  0023c	0f b6 9f 4e 03
	00 00		 movzx	 ebx, BYTE PTR [edi+846]
  00243	80 e3 10	 and	 bl, 16			; 00000010H
  00246	08 9e 59 03 00
	00		 or	 BYTE PTR [esi+857], bl

; 10887: 		lpObj->CharSet[4]  |= CS_SET_GLOVES3(lpObj->pInventory[5].m_Type);

  0024c	0f b6 9f 4e 03
	00 00		 movzx	 ebx, BYTE PTR [edi+846]
  00253	22 d8		 and	 bl, al
  00255	08 9e 54 03 00
	00		 or	 BYTE PTR [esi+852], bl
$LN33@gObjMakePr:

; 10888: 	}
; 10889: 	// ---
; 10890: 	if(lpObj->pInventory[6].m_Type < ITEMGET(0,0))

  0025b	66 83 bf f6 03
	00 00 00	 cmp	 WORD PTR [edi+1014], 0
  00263	7d 0f		 jge	 SHORT $LN32@gObjMakePr

; 10891: 	{
; 10892: 		lpObj->CharSet[15] |= CS_SET_BOOTS1(-1);

  00265	08 86 5f 03 00
	00		 or	 BYTE PTR [esi+863], al

; 10893: 		lpObj->CharSet[9]  |= CS_SET_BOOTS2(-1);

  0026b	80 8e 59 03 00
	00 08		 or	 BYTE PTR [esi+857], 8

; 10894: 		lpObj->CharSet[5]  |= CS_SET_BOOTS3(-1);
; 10895: 	}
; 10896: 	else

  00272	eb 2c		 jmp	 SHORT $LN57@gObjMakePr
$LN32@gObjMakePr:

; 10897: 	{
; 10898: 		lpObj->CharSet[15] |= CS_SET_BOOTS1(lpObj->pInventory[6].m_Type);

  00274	66 8b 8f f6 03
	00 00		 mov	 cx, WORD PTR [edi+1014]
  0027b	66 c1 f9 05	 sar	 cx, 5
  0027f	22 c8		 and	 cl, al
  00281	08 8e 5f 03 00
	00		 or	 BYTE PTR [esi+863], cl

; 10899: 		lpObj->CharSet[9]  |= CS_SET_BOOTS2(lpObj->pInventory[6].m_Type);

  00287	8a 87 f6 03 00
	00		 mov	 al, BYTE PTR [edi+1014]
  0028d	d0 f8		 sar	 al, 1
  0028f	24 08		 and	 al, 8
  00291	08 86 59 03 00
	00		 or	 BYTE PTR [esi+857], al

; 10900: 		lpObj->CharSet[5]  |= CS_SET_BOOTS3(lpObj->pInventory[6].m_Type);

  00297	8a 8f f6 03 00
	00		 mov	 cl, BYTE PTR [edi+1014]
  0029d	c0 e1 04	 shl	 cl, 4
$LN57@gObjMakePr:
  002a0	08 8e 55 03 00
	00		 or	 BYTE PTR [esi+853], cl

; 10901: 	}
; 10902: 	// ---
; 10903: 	index = 0;
; 10904: 	// ---
; 10905: 	if(lpObj->pInventory[7].m_Type < ITEMGET(0,0))

  002a6	66 83 bf 9e 04
	00 00 00	 cmp	 WORD PTR [edi+1182], 0
  002ae	7d 04		 jge	 SHORT $LN30@gObjMakePr

; 10906: 	{
; 10907: 		index |= CS_SET_WING1(-1);

  002b0	b0 0c		 mov	 al, 12			; 0000000cH

; 10908: 	}
; 10909: 	else

  002b2	eb 0c		 jmp	 SHORT $LN29@gObjMakePr
$LN30@gObjMakePr:

; 10910: 	{
; 10911: 		index |= CS_SET_WING1(lpObj->pInventory[7].m_Type);

  002b4	8a 87 9e 04 00
	00		 mov	 al, BYTE PTR [edi+1182]
  002ba	24 03		 and	 al, 3
  002bc	02 c0		 add	 al, al
  002be	02 c0		 add	 al, al
$LN29@gObjMakePr:

; 10912: 	}
; 10913: 	// ---
; 10914: 	if(lpObj->pInventory[8].m_Type != ITEMGET(13,4))

  002c0	0f b7 8f 46 05
	00 00		 movzx	 ecx, WORD PTR [edi+1350]
  002c7	bb 04 1a 00 00	 mov	 ebx, 6660		; 00001a04H
  002cc	66 3b cb	 cmp	 cx, bx
  002cf	74 12		 je	 SHORT $LN28@gObjMakePr

; 10915: 	{
; 10916: 		if ( lpObj->pInventory[8].m_Type < ITEMGET(0,0) )

  002d1	66 85 c9	 test	 cx, cx

; 10917: 		{
; 10918: 			index |= CS_SET_HELPER(-1);
; 10919: 		}
; 10920: 		else

  002d4	78 0d		 js	 SHORT $LN28@gObjMakePr

; 10921: 		{
; 10922: 			index |= CS_SET_HELPER(lpObj->pInventory[8].m_Type);

  002d6	8a 8f 46 05 00
	00		 mov	 cl, BYTE PTR [edi+1350]
  002dc	80 e1 03	 and	 cl, 3
  002df	0a c1		 or	 al, cl

; 10923: 		}
; 10924: 	}
; 10925: 	else

  002e1	eb 02		 jmp	 SHORT $LN25@gObjMakePr
$LN28@gObjMakePr:

; 10926: 	{
; 10927: 		index |= CS_SET_HELPER(-1);

  002e3	0c 03		 or	 al, 3
$LN25@gObjMakePr:

; 10928: 	}
; 10929: 	// ---
; 10930: 	lpObj->CharSet[5] |= index;

  002e5	08 86 55 03 00
	00		 or	 BYTE PTR [esi+853], al

; 10931: 	// ---
; 10932: 	int iLevelIndex;
; 10933: 	// ---
; 10934: 	iLevelIndex = CS_SET_SMALLLEVEL_RH(LevelSmallConvert(aIndex, 0));
; 10935: 	iLevelIndex |= CS_SET_SMALLLEVEL_LH(LevelSmallConvert(aIndex, 1));
; 10936: 	iLevelIndex |= CS_SET_SMALLLEVEL_HELMET(LevelSmallConvert(aIndex, 2));
; 10937: 	iLevelIndex |= CS_SET_SMALLLEVEL_ARMOR(LevelSmallConvert(aIndex, 3));
; 10938: 	iLevelIndex |= CS_SET_SMALLLEVEL_PANTS(LevelSmallConvert(aIndex, 4));
; 10939: 	iLevelIndex |= CS_SET_SMALLLEVEL_GLOVES(LevelSmallConvert(aIndex, 5));
; 10940: 	iLevelIndex |= CS_SET_SMALLLEVEL_BOOTS(LevelSmallConvert(aIndex, 6));

  002eb	6a 06		 push	 6
  002ed	52		 push	 edx
  002ee	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  002f3	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  002f6	0f b6 d8	 movzx	 ebx, al
  002f9	03 db		 add	 ebx, ebx
  002fb	6a 05		 push	 5
  002fd	03 db		 add	 ebx, ebx
  002ff	51		 push	 ecx
  00300	03 db		 add	 ebx, ebx
  00302	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  00307	0f b6 d0	 movzx	 edx, al
  0030a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0030d	0b da		 or	 ebx, edx
  0030f	03 db		 add	 ebx, ebx
  00311	6a 04		 push	 4
  00313	03 db		 add	 ebx, ebx
  00315	50		 push	 eax
  00316	03 db		 add	 ebx, ebx
  00318	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  0031d	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00320	0f b6 c8	 movzx	 ecx, al
  00323	0b d9		 or	 ebx, ecx
  00325	03 db		 add	 ebx, ebx
  00327	6a 03		 push	 3
  00329	03 db		 add	 ebx, ebx
  0032b	52		 push	 edx
  0032c	03 db		 add	 ebx, ebx
  0032e	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  00333	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00336	0f b6 c0	 movzx	 eax, al
  00339	0b d8		 or	 ebx, eax
  0033b	03 db		 add	 ebx, ebx
  0033d	6a 02		 push	 2
  0033f	03 db		 add	 ebx, ebx
  00341	51		 push	 ecx
  00342	03 db		 add	 ebx, ebx
  00344	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  00349	0f b6 d0	 movzx	 edx, al
  0034c	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0034f	0b da		 or	 ebx, edx
  00351	03 db		 add	 ebx, ebx
  00353	6a 01		 push	 1
  00355	03 db		 add	 ebx, ebx
  00357	50		 push	 eax
  00358	03 db		 add	 ebx, ebx
  0035a	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  0035f	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00362	0f b6 c8	 movzx	 ecx, al
  00365	0b d9		 or	 ebx, ecx
  00367	03 db		 add	 ebx, ebx
  00369	6a 00		 push	 0
  0036b	03 db		 add	 ebx, ebx
  0036d	52		 push	 edx
  0036e	03 db		 add	 ebx, ebx
  00370	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  00375	0f b6 c0	 movzx	 eax, al
  00378	0b d8		 or	 ebx, eax

; 10941: 	// ---
; 10942: 	lpObj->CharSet[6] = CS_SET_SMALLLEVEL1(iLevelIndex);

  0037a	8b cb		 mov	 ecx, ebx
  0037c	c1 f9 10	 sar	 ecx, 16			; 00000010H

; 10943: 	lpObj->CharSet[7] = CS_SET_SMALLLEVEL2(iLevelIndex);

  0037f	8b d3		 mov	 edx, ebx
  00381	c1 fa 08	 sar	 edx, 8
  00384	88 8e 56 03 00
	00		 mov	 BYTE PTR [esi+854], cl
  0038a	88 96 57 03 00
	00		 mov	 BYTE PTR [esi+855], dl

; 10944: 	lpObj->CharSet[8] = CS_SET_SMALLLEVEL3(iLevelIndex);

  00390	88 9e 58 03 00
	00		 mov	 BYTE PTR [esi+856], bl

; 10945: 	// ---
; 10946: 	if((lpObj->pInventory[7].m_Type >= ITEMGET(12,3) && lpObj->pInventory[7].m_Type <= ITEMGET(12,6)) || lpObj->pInventory[7].m_Type == ITEMGET(13,30))

  00396	0f b7 87 9e 04
	00 00		 movzx	 eax, WORD PTR [edi+1182]
  0039d	b9 03 18 00 00	 mov	 ecx, 6147		; 00001803H
  003a2	83 c4 38	 add	 esp, 56			; 00000038H
  003a5	66 3b c1	 cmp	 ax, cx
  003a8	7c 0a		 jl	 SHORT $LN22@gObjMakePr
  003aa	ba 06 18 00 00	 mov	 edx, 6150		; 00001806H
  003af	66 3b c2	 cmp	 ax, dx
  003b2	7e 0a		 jle	 SHORT $LN23@gObjMakePr
$LN22@gObjMakePr:
  003b4	b9 1e 1a 00 00	 mov	 ecx, 6686		; 00001a1eH
  003b9	66 3b c1	 cmp	 ax, cx
  003bc	75 35		 jne	 SHORT $LN20@gObjMakePr
$LN23@gObjMakePr:

; 10947: 	{
; 10948: 		lpObj->CharSet[5] |= CS_SET_WING1(-1);

  003be	8a 86 55 03 00
	00		 mov	 al, BYTE PTR [esi+853]
  003c4	0c 0c		 or	 al, 12			; 0000000cH

; 10949: 		
; 10950: 		if ( lpObj->pInventory[7].m_Type == ITEMGET(13,30) )

  003c6	ba 1e 1a 00 00	 mov	 edx, 6686		; 00001a1eH
  003cb	88 86 55 03 00
	00		 mov	 BYTE PTR [esi+853], al
  003d1	66 39 97 9e 04
	00 00		 cmp	 WORD PTR [edi+1182], dx
  003d8	75 09		 jne	 SHORT $LN21@gObjMakePr

; 10951: 		{
; 10952: 			lpObj->CharSet[9] |= 5;

  003da	80 8e 59 03 00
	00 05		 or	 BYTE PTR [esi+857], 5

; 10953: 		}
; 10954: 		else

  003e1	eb 10		 jmp	 SHORT $LN20@gObjMakePr
$LN21@gObjMakePr:

; 10955: 		{
; 10956: 			lpObj->CharSet[9] |= (lpObj->pInventory[7].m_Type - 2) & 0x07;

  003e3	8a 87 9e 04 00
	00		 mov	 al, BYTE PTR [edi+1182]
  003e9	2c 02		 sub	 al, 2
  003eb	24 07		 and	 al, 7
  003ed	08 86 59 03 00
	00		 or	 BYTE PTR [esi+857], al
$LN20@gObjMakePr:

; 10957: 		}
; 10958: 	}
; 10959: 	// ---
; 10960: 	if((lpObj->pInventory[7].m_Type >= ITEMGET(12, 100) && lpObj->pInventory[7].m_Type <= ITEMGET(12, 120)))

  003f3	0f b7 87 9e 04
	00 00		 movzx	 eax, WORD PTR [edi+1182]
  003fa	b9 64 18 00 00	 mov	 ecx, 6244		; 00001864H
  003ff	66 3b c1	 cmp	 ax, cx
  00402	7c 23		 jl	 SHORT $LN19@gObjMakePr
  00404	ba 78 18 00 00	 mov	 edx, 6264		; 00001878H
  00409	66 3b c2	 cmp	 ax, dx
  0040c	7f 19		 jg	 SHORT $LN19@gObjMakePr

; 10961: 	{
; 10962: 		lpObj->CharSet[5] |= CS_SET_WING1(3);

  0040e	80 8e 55 03 00
	00 0c		 or	 BYTE PTR [esi+853], 12	; 0000000cH

; 10963: 		lpObj->CharSet[17] |= ((lpObj->pInventory[7].m_Type - 100) + 1 << 2);

  00415	8a 87 9e 04 00
	00		 mov	 al, BYTE PTR [edi+1182]
  0041b	04 1d		 add	 al, 29			; 0000001dH
  0041d	02 c0		 add	 al, al
  0041f	02 c0		 add	 al, al
  00421	08 86 61 03 00
	00		 or	 BYTE PTR [esi+865], al
$LN19@gObjMakePr:

; 10964: 	}
; 10965: 	// ---
; 10966: 	lpObj->CharSet[10] = 0;
; 10967: 	// ---
; 10968: 	if(lpObj->pInventory[2].IsExtItem() != 0)

  00427	8d 8f 50 01 00
	00		 lea	 ecx, DWORD PTR [edi+336]
  0042d	c6 86 5a 03 00
	00 00		 mov	 BYTE PTR [esi+858], 0
  00434	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  00439	5f		 pop	 edi
  0043a	5b		 pop	 ebx
  0043b	85 c0		 test	 eax, eax
  0043d	74 07		 je	 SHORT $LN18@gObjMakePr

; 10969: 	{
; 10970: 		lpObj->CharSet[10] = (char)0x80;

  0043f	c6 86 5a 03 00
	00 80		 mov	 BYTE PTR [esi+858], 128	; 00000080H
$LN18@gObjMakePr:

; 10971: 	}
; 10972: 	// ---
; 10973: 	if(lpObj->pInventory[3].IsExtItem() != 0)

  00446	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0044c	81 c1 f8 01 00
	00		 add	 ecx, 504		; 000001f8H
  00452	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  00457	85 c0		 test	 eax, eax
  00459	74 07		 je	 SHORT $LN17@gObjMakePr

; 10974: 	{
; 10975: 		lpObj->CharSet[10] |= 0x40;

  0045b	80 8e 5a 03 00
	00 40		 or	 BYTE PTR [esi+858], 64	; 00000040H
$LN17@gObjMakePr:

; 10976: 	}
; 10977: 	// ---
; 10978: 	if(lpObj->pInventory[4].IsExtItem() != 0)

  00462	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00468	81 c1 a0 02 00
	00		 add	 ecx, 672		; 000002a0H
  0046e	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  00473	85 c0		 test	 eax, eax
  00475	74 07		 je	 SHORT $LN16@gObjMakePr

; 10979: 	{
; 10980: 		lpObj->CharSet[10] |= 0x20;

  00477	80 8e 5a 03 00
	00 20		 or	 BYTE PTR [esi+858], 32	; 00000020H
$LN16@gObjMakePr:

; 10981: 	}
; 10982: 	// ---
; 10983: 	if(lpObj->pInventory[5].IsExtItem() != 0)

  0047e	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00484	81 c1 48 03 00
	00		 add	 ecx, 840		; 00000348H
  0048a	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  0048f	85 c0		 test	 eax, eax
  00491	74 07		 je	 SHORT $LN15@gObjMakePr

; 10984: 	{
; 10985: 		lpObj->CharSet[10] |= 0x10;

  00493	80 8e 5a 03 00
	00 10		 or	 BYTE PTR [esi+858], 16	; 00000010H
$LN15@gObjMakePr:

; 10986: 	}
; 10987: 	// ---
; 10988: 	if(lpObj->pInventory[6].IsExtItem() != 0)

  0049a	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  004a0	81 c1 f0 03 00
	00		 add	 ecx, 1008		; 000003f0H
  004a6	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  004ab	85 c0		 test	 eax, eax
  004ad	74 07		 je	 SHORT $LN14@gObjMakePr

; 10989: 	{
; 10990: 		lpObj->CharSet[10] |= 0x8;

  004af	80 8e 5a 03 00
	00 08		 or	 BYTE PTR [esi+858], 8
$LN14@gObjMakePr:

; 10991: 	}
; 10992: 	// ---
; 10993: 	if(lpObj->pInventory[0].IsExtItem() != 0)

  004b6	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  004bc	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  004c1	85 c0		 test	 eax, eax
  004c3	74 07		 je	 SHORT $LN13@gObjMakePr

; 10994: 	{
; 10995: 		lpObj->CharSet[10] |= 0x04;

  004c5	80 8e 5a 03 00
	00 04		 or	 BYTE PTR [esi+858], 4
$LN13@gObjMakePr:

; 10996: 	}
; 10997: 	// ---
; 10998: 	if(lpObj->pInventory[1].IsExtItem() != 0)

  004cc	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  004d2	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  004d8	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  004dd	85 c0		 test	 eax, eax
  004df	74 07		 je	 SHORT $LN12@gObjMakePr

; 10999: 	{
; 11000: 		lpObj->CharSet[10] |= 0x02;

  004e1	80 8e 5a 03 00
	00 02		 or	 BYTE PTR [esi+858], 2
$LN12@gObjMakePr:

; 11001: 	}
; 11002: 	// ---
; 11003: 	lpObj->CharSet[11] = 0;
; 11004: 	// ---
; 11005: 	if(lpObj->pInventory[2].IsSetItem() != 0)

  004e8	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  004ee	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  004f4	c6 86 5b 03 00
	00 00		 mov	 BYTE PTR [esi+859], 0
  004fb	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00500	85 c0		 test	 eax, eax
  00502	74 07		 je	 SHORT $LN11@gObjMakePr

; 11006: 	{
; 11007: 		lpObj->CharSet[11] = (char)0x80;

  00504	c6 86 5b 03 00
	00 80		 mov	 BYTE PTR [esi+859], 128	; 00000080H
$LN11@gObjMakePr:

; 11008: 	}
; 11009: 	// ---
; 11010: 	if(lpObj->pInventory[3].IsSetItem() != 0)

  0050b	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00511	81 c1 f8 01 00
	00		 add	 ecx, 504		; 000001f8H
  00517	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  0051c	85 c0		 test	 eax, eax
  0051e	74 07		 je	 SHORT $LN10@gObjMakePr

; 11011: 	{
; 11012: 		lpObj->CharSet[11] |= 0x40;

  00520	80 8e 5b 03 00
	00 40		 or	 BYTE PTR [esi+859], 64	; 00000040H
$LN10@gObjMakePr:

; 11013: 	}
; 11014: 	// ---
; 11015: 	if(lpObj->pInventory[4].IsSetItem() != 0)

  00527	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0052d	81 c1 a0 02 00
	00		 add	 ecx, 672		; 000002a0H
  00533	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00538	85 c0		 test	 eax, eax
  0053a	74 07		 je	 SHORT $LN9@gObjMakePr

; 11016: 	{
; 11017: 		lpObj->CharSet[11] |= 0x20;

  0053c	80 8e 5b 03 00
	00 20		 or	 BYTE PTR [esi+859], 32	; 00000020H
$LN9@gObjMakePr:

; 11018: 	}
; 11019: 	// ---
; 11020: 	if(lpObj->pInventory[5].IsSetItem() != 0)

  00543	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00549	81 c1 48 03 00
	00		 add	 ecx, 840		; 00000348H
  0054f	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00554	85 c0		 test	 eax, eax
  00556	74 07		 je	 SHORT $LN8@gObjMakePr

; 11021: 	{
; 11022: 		lpObj->CharSet[11] |= 0x10;

  00558	80 8e 5b 03 00
	00 10		 or	 BYTE PTR [esi+859], 16	; 00000010H
$LN8@gObjMakePr:

; 11023: 	}
; 11024: 	// ---
; 11025: 	if(lpObj->pInventory[6].IsSetItem() != 0)

  0055f	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00565	81 c1 f0 03 00
	00		 add	 ecx, 1008		; 000003f0H
  0056b	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00570	85 c0		 test	 eax, eax
  00572	74 07		 je	 SHORT $LN7@gObjMakePr

; 11026: 	{
; 11027: 		lpObj->CharSet[11] |= 0x8;

  00574	80 8e 5b 03 00
	00 08		 or	 BYTE PTR [esi+859], 8
$LN7@gObjMakePr:

; 11028: 	}
; 11029: 	// ---
; 11030: 	if(lpObj->pInventory[0].IsSetItem() != 0)

  0057b	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00581	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00586	85 c0		 test	 eax, eax
  00588	74 07		 je	 SHORT $LN6@gObjMakePr

; 11031: 	{
; 11032: 		lpObj->CharSet[11] |= 0x04;

  0058a	80 8e 5b 03 00
	00 04		 or	 BYTE PTR [esi+859], 4
$LN6@gObjMakePr:

; 11033: 	}
; 11034: 	// ---
; 11035: 	if(lpObj->pInventory[1].IsSetItem() != 0)

  00591	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00597	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  0059d	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  005a2	85 c0		 test	 eax, eax
  005a4	74 07		 je	 SHORT $LN5@gObjMakePr

; 11036: 	{
; 11037: 		lpObj->CharSet[11] |= 0x02;

  005a6	80 8e 5b 03 00
	00 02		 or	 BYTE PTR [esi+859], 2
$LN5@gObjMakePr:

; 11038: 	}
; 11039: 	// ---
; 11040: 	gObjCalCharacter(aIndex);

  005ad	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  005b0	51		 push	 ecx
  005b1	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  005b6	83 c4 04	 add	 esp, 4

; 11041: 	// ---
; 11042: 	if(lpObj->IsFullSetItem != false)

  005b9	80 be 82 0f 00
	00 00		 cmp	 BYTE PTR [esi+3970], 0
  005c0	74 07		 je	 SHORT $LN4@gObjMakePr

; 11043: 	{
; 11044: 		lpObj->CharSet[11] |= 0x01;

  005c2	80 8e 5b 03 00
	00 01		 or	 BYTE PTR [esi+859], 1
$LN4@gObjMakePr:

; 11045: 	}
; 11046: 	// ---
; 11047: 	if((lpObj->pInventory[8].m_Type & 0x03) != 0)

  005c9	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  005cf	0f b7 81 46 05
	00 00		 movzx	 eax, WORD PTR [ecx+1350]
  005d6	a8 03		 test	 al, 3
  005d8	74 0c		 je	 SHORT $LN2@gObjMakePr

; 11048: 	{
; 11049: 		if(lpObj->pInventory[8].m_Type > 0)

  005da	66 85 c0	 test	 ax, ax
  005dd	7e 07		 jle	 SHORT $LN2@gObjMakePr

; 11050: 		{
; 11051: 			lpObj->CharSet[10] |= 0x01;

  005df	80 8e 5a 03 00
	00 01		 or	 BYTE PTR [esi+858], 1
$LN2@gObjMakePr:

; 11052: 		}
; 11053: 	}
; 11054: 	// ---
; 11055: 	if(lpObj->pInventory[8].m_Type == ITEMGET(13,4))

  005e6	ba 04 1a 00 00	 mov	 edx, 6660		; 00001a04H
  005eb	66 39 91 46 05
	00 00		 cmp	 WORD PTR [ecx+1350], dx
  005f2	75 07		 jne	 SHORT $LN55@gObjMakePr

; 11056: 	{
; 11057: 		lpObj->CharSet[12] |= 0x01;

  005f4	80 8e 5c 03 00
	00 01		 or	 BYTE PTR [esi+860], 1
$LN55@gObjMakePr:
  005fb	5e		 pop	 esi

; 11058: 	}
; 11059: }

  005fc	8b e5		 mov	 esp, ebp
  005fe	5d		 pop	 ebp
  005ff	c3		 ret	 0
?gObjMakePreviewCharSet@@YAXH@Z ENDP			; gObjMakePreviewCharSet
_TEXT	ENDS
PUBLIC	__real@3f847ae140000000
PUBLIC	__real@42340000
PUBLIC	__real@c4098000
PUBLIC	__real@c44bfffe
PUBLIC	__real@44098000
PUBLIC	__real@4494c000
PUBLIC	__real@448d0001
PUBLIC	__real@c494c000
PUBLIC	__$ArrayPad$
PUBLIC	?InitFrustrum@@YAXXZ				; InitFrustrum
EXTRN	?VectorRotate@@YAXQBM0QAM@Z:PROC		; VectorRotate
EXTRN	?AngleMatrix@@YAXPBMPAY03M@Z:PROC		; AngleMatrix
_BSS	SEGMENT
_FrustrumY DD	04H DUP (?)
_FrustrumX DD	04H DUP (?)
_BSS	ENDS
;	COMDAT __real@3f847ae140000000
CONST	SEGMENT
__real@3f847ae140000000 DQ 03f847ae140000000r	; 0.01
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@c4098000
CONST	SEGMENT
__real@c4098000 DD 0c4098000r			; -550
CONST	ENDS
;	COMDAT __real@c44bfffe
CONST	SEGMENT
__real@c44bfffe DD 0c44bfffer			; -816
CONST	ENDS
;	COMDAT __real@44098000
CONST	SEGMENT
__real@44098000 DD 044098000r			; 550
CONST	ENDS
;	COMDAT __real@4494c000
CONST	SEGMENT
__real@4494c000 DD 04494c000r			; 1190
CONST	ENDS
;	COMDAT __real@448d0001
CONST	SEGMENT
__real@448d0001 DD 0448d0001r			; 1128
CONST	ENDS
;	COMDAT __real@c494c000
CONST	SEGMENT
__real@c494c000 DD 0c494c000r			; -1190
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?InitFrustrum@@YAXXZ
_TEXT	SEGMENT
_Frustrum$ = -160					; size = 48
_Matrix$ = -112						; size = 48
_p$ = -64						; size = 48
_Angle$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?InitFrustrum@@YAXXZ PROC				; InitFrustrum, COMDAT

; 11065: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 11066: 	float CameraViewFar = 2400.0;
; 11067: 	float CameraViewNear = CameraViewFar * 0.19f;
; 11068: 	float CameraViewTarget = CameraViewFar * 0.53f;
; 11069: 	float WidthFar = 1190.0;
; 11070: 	float WidthNear =  550.0;
; 11071: 
; 11072: 	float p[4][3];
; 11073: 
; 11074: 	p[0][0] = -WidthFar;

  00013	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c494c000
  00019	53		 push	 ebx
  0001a	d9 5d c0	 fstp	 DWORD PTR _p$[ebp]
  0001d	56		 push	 esi

; 11075: 	p[0][1] = CameraViewFar-CameraViewTarget;

  0001e	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@448d0001
  00024	57		 push	 edi
  00025	d9 55 c4	 fst	 DWORD PTR _p$[ebp+4]

; 11076: 	p[0][2] = 0;
; 11077: 	p[1][0] = WidthFar;
; 11078: 	p[1][1] = CameraViewFar-CameraViewTarget;
; 11079: 	p[1][2] = 0;
; 11080: 	p[2][0] = WidthNear;
; 11081: 	p[2][1] = CameraViewNear - CameraViewTarget;
; 11082: 	p[2][2] = 0;
; 11083: 	p[3][0]= -WidthNear;
; 11084: 	p[3][1] = CameraViewNear - CameraViewTarget;
; 11085: 	p[3][2] = 0;
; 11086: 
; 11087: 	float Angle[3];
; 11088: 	Angle[0] = 0;
; 11089: 	Angle[1] = 0;
; 11090: 	Angle[2] = 45.0f;
; 11091: 
; 11092: 	float Matrix[3][4];
; 11093: 	float Frustrum[4][3];
; 11094: 
; 11095: 	AngleMatrix(Angle,Matrix);

  00028	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  0002b	d9 ee		 fldz
  0002d	50		 push	 eax
  0002e	d9 55 c8	 fst	 DWORD PTR _p$[ebp+8]
  00031	8d 4d f0	 lea	 ecx, DWORD PTR _Angle$[ebp]
  00034	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@4494c000
  0003a	51		 push	 ecx
  0003b	d9 5d cc	 fstp	 DWORD PTR _p$[ebp+12]
  0003e	d9 c9		 fxch	 ST(1)
  00040	d9 5d d0	 fstp	 DWORD PTR _p$[ebp+16]
  00043	d9 55 d4	 fst	 DWORD PTR _p$[ebp+20]
  00046	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@44098000
  0004c	d9 5d d8	 fstp	 DWORD PTR _p$[ebp+24]
  0004f	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c44bfffe
  00055	d9 55 dc	 fst	 DWORD PTR _p$[ebp+28]
  00058	d9 c9		 fxch	 ST(1)
  0005a	d9 55 e0	 fst	 DWORD PTR _p$[ebp+32]
  0005d	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c4098000
  00063	d9 5d e4	 fstp	 DWORD PTR _p$[ebp+36]
  00066	d9 c9		 fxch	 ST(1)
  00068	d9 5d e8	 fstp	 DWORD PTR _p$[ebp+40]
  0006b	d9 55 ec	 fst	 DWORD PTR _p$[ebp+44]
  0006e	d9 55 f0	 fst	 DWORD PTR _Angle$[ebp]
  00071	d9 5d f4	 fstp	 DWORD PTR _Angle$[ebp+4]
  00074	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@42340000
  0007a	d9 5d f8	 fstp	 DWORD PTR _Angle$[ebp+8]
  0007d	e8 00 00 00 00	 call	 ?AngleMatrix@@YAXPBMPAY03M@Z ; AngleMatrix
  00082	83 c4 08	 add	 esp, 8

; 11096: 
; 11097: 	for(int i = 0; i < MAX_ARRAY_FRUSTRUM;i++)

  00085	33 f6		 xor	 esi, esi
  00087	33 ff		 xor	 edi, edi
  00089	8d a4 24 00 00
	00 00		 npad	 7
$LL3@InitFrustr:

; 11098: 	{
; 11099: 		VectorRotate((const float *)&p[i],(const float *)&Matrix[0],(float *)&Frustrum[i]);

  00090	8d 9c 35 60 ff
	ff ff		 lea	 ebx, DWORD PTR _Frustrum$[ebp+esi]
  00097	53		 push	 ebx
  00098	8d 55 90	 lea	 edx, DWORD PTR _Matrix$[ebp]
  0009b	52		 push	 edx
  0009c	8d 44 35 c0	 lea	 eax, DWORD PTR _p$[ebp+esi]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ?VectorRotate@@YAXQBM0QAM@Z ; VectorRotate

; 11100: 		FrustrumX[i] = Frustrum[i][0]*0.01f;

  000a6	d9 03		 fld	 DWORD PTR [ebx]
  000a8	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3f847ae140000000
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	dc c9		 fmul	 ST(1), ST(0)
  000b3	d9 c9		 fxch	 ST(1)
  000b5	e8 00 00 00 00	 call	 __ftol2_sse

; 11101: 		FrustrumY[i] = Frustrum[i][1]*0.01f;

  000ba	d8 8c 35 64 ff
	ff ff		 fmul	 DWORD PTR _Frustrum$[ebp+esi+4]
  000c1	89 87 00 00 00
	00		 mov	 DWORD PTR _FrustrumX[edi], eax
  000c7	e8 00 00 00 00	 call	 __ftol2_sse
  000cc	89 87 00 00 00
	00		 mov	 DWORD PTR _FrustrumY[edi], eax
  000d2	83 c6 0c	 add	 esi, 12			; 0000000cH
  000d5	83 c7 04	 add	 edi, 4
  000d8	83 fe 30	 cmp	 esi, 48			; 00000030H
  000db	7c b3		 jl	 SHORT $LL3@InitFrustr

; 11102: 
; 11103: 	}
; 11104: }

  000dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	33 cd		 xor	 ecx, ebp
  000e4	5b		 pop	 ebx
  000e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
?InitFrustrum@@YAXXZ ENDP				; InitFrustrum
_TEXT	ENDS
PUBLIC	?CreateFrustrum@@YAXHHH@Z			; CreateFrustrum
; Function compile flags: /Ogtp
;	COMDAT ?CreateFrustrum@@YAXHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_aIndex$ = 16						; size = 4
?CreateFrustrum@@YAXHHH@Z PROC				; CreateFrustrum, COMDAT

; 11107: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11108: 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 11109: 
; 11110: 	for ( int i=0;i<MAX_ARRAY_FRUSTRUM;i++)
; 11111: 	{
; 11112: 		lpObj->FrustrumX[i] = FrustrumX[i] + x;

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00009	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0000f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _FrustrumX
  00015	56		 push	 esi

; 11113: 		lpObj->FrustrumY[i] = FrustrumY[i] + y;

  00016	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _FrustrumY
  0001c	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00021	03 d1		 add	 edx, ecx
  00023	89 90 70 03 00
	00		 mov	 DWORD PTR [eax+880], edx
  00029	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  0002c	03 f2		 add	 esi, edx
  0002e	89 b0 80 03 00
	00		 mov	 DWORD PTR [eax+896], esi
  00034	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _FrustrumX+4
  0003a	03 f1		 add	 esi, ecx
  0003c	89 b0 74 03 00
	00		 mov	 DWORD PTR [eax+884], esi
  00042	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _FrustrumY+4
  00048	03 f2		 add	 esi, edx
  0004a	89 b0 84 03 00
	00		 mov	 DWORD PTR [eax+900], esi
  00050	8b 35 08 00 00
	00		 mov	 esi, DWORD PTR _FrustrumX+8
  00056	03 f1		 add	 esi, ecx
  00058	89 b0 78 03 00
	00		 mov	 DWORD PTR [eax+888], esi
  0005e	8b 35 08 00 00
	00		 mov	 esi, DWORD PTR _FrustrumY+8
  00064	03 f2		 add	 esi, edx
  00066	89 b0 88 03 00
	00		 mov	 DWORD PTR [eax+904], esi
  0006c	8b 35 0c 00 00
	00		 mov	 esi, DWORD PTR _FrustrumX+12
  00072	03 f1		 add	 esi, ecx
  00074	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _FrustrumY+12
  0007a	03 ca		 add	 ecx, edx
  0007c	89 b0 7c 03 00
	00		 mov	 DWORD PTR [eax+892], esi
  00082	89 88 8c 03 00
	00		 mov	 DWORD PTR [eax+908], ecx
  00088	5e		 pop	 esi

; 11114: 	}
; 11115: }

  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?CreateFrustrum@@YAXHHH@Z ENDP				; CreateFrustrum
_TEXT	ENDS
PUBLIC	?TestFrustrum2@@YA_NHHH@Z			; TestFrustrum2
; Function compile flags: /Ogtp
;	COMDAT ?TestFrustrum2@@YA_NHHH@Z
_TEXT	SEGMENT
tv310 = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
tv318 = 16						; size = 4
_aIndex$ = 16						; size = 4
?TestFrustrum2@@YA_NHHH@Z PROC				; TestFrustrum2, COMDAT

; 11118: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 11119: 	int j = 3;
; 11120: 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 55 10	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00007	d9 ee		 fldz
  00009	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	81 c2 00 00 00
	00		 add	 edx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11121: 
; 11122: 	for(int i = 0; i < MAX_ARRAY_FRUSTRUM;j = i,i++)

  00018	33 f6		 xor	 esi, esi
  0001a	bf 90 fc ff ff	 mov	 edi, -880		; fffffc90H
  0001f	2b fa		 sub	 edi, edx
  00021	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00024	8d 8a 70 03 00
	00		 lea	 ecx, DWORD PTR [edx+880]
  0002a	89 7d fc	 mov	 DWORD PTR tv310[ebp], edi
$LN10@TestFrustr:

; 11123: 	{
; 11124: 		if((lpObj->FrustrumX[i]- x) * (lpObj->FrustrumY[j]-y) - (lpObj->FrustrumX[j]-x) * (lpObj->FrustrumY[i]-y) < 0.0f)

  0002d	8b bc 10 70 03
	00 00		 mov	 edi, DWORD PTR [eax+edx+880]
  00034	8b 59 10	 mov	 ebx, DWORD PTR [ecx+16]
  00037	2b 5d 0c	 sub	 ebx, DWORD PTR _y$[ebp]
  0003a	2b 7d 08	 sub	 edi, DWORD PTR _x$[ebp]
  0003d	8b 84 10 80 03
	00 00		 mov	 eax, DWORD PTR [eax+edx+896]
  00044	2b 45 0c	 sub	 eax, DWORD PTR _y$[ebp]
  00047	0f af fb	 imul	 edi, ebx
  0004a	8b 19		 mov	 ebx, DWORD PTR [ecx]
  0004c	2b 5d 08	 sub	 ebx, DWORD PTR _x$[ebp]
  0004f	0f af c3	 imul	 eax, ebx
  00052	2b c7		 sub	 eax, edi
  00054	89 45 10	 mov	 DWORD PTR tv318[ebp], eax
  00057	db 45 10	 fild	 DWORD PTR tv318[ebp]
  0005a	d8 d9		 fcomp	 ST(1)
  0005c	df e0		 fnstsw	 ax
  0005e	f6 c4 05	 test	 ah, 5
  00061	7b 19		 jnp	 SHORT $LN13@TestFrustr

; 11121: 
; 11122: 	for(int i = 0; i < MAX_ARRAY_FRUSTRUM;j = i,i++)

  00063	8b 45 fc	 mov	 eax, DWORD PTR tv310[ebp]
  00066	03 c1		 add	 eax, ecx
  00068	46		 inc	 esi
  00069	83 c1 04	 add	 ecx, 4
  0006c	83 fe 04	 cmp	 esi, 4
  0006f	7c bc		 jl	 SHORT $LN10@TestFrustr
  00071	5f		 pop	 edi
  00072	dd d8		 fstp	 ST(0)
  00074	5e		 pop	 esi

; 11127: 		}
; 11128: 	}
; 11129: 	return true;

  00075	b0 01		 mov	 al, 1
  00077	5b		 pop	 ebx

; 11130: }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN13@TestFrustr:
  0007c	5f		 pop	 edi

; 11123: 	{
; 11124: 		if((lpObj->FrustrumX[i]- x) * (lpObj->FrustrumY[j]-y) - (lpObj->FrustrumX[j]-x) * (lpObj->FrustrumY[i]-y) < 0.0f)

  0007d	dd d8		 fstp	 ST(0)
  0007f	5e		 pop	 esi

; 11125: 		{
; 11126: 			return false;

  00080	32 c0		 xor	 al, al
  00082	5b		 pop	 ebx

; 11130: }

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
?TestFrustrum2@@YA_NHHH@Z ENDP				; TestFrustrum2
_TEXT	ENDS
PUBLIC	?gObjCheckViewport@@YAHHHH@Z			; gObjCheckViewport
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckViewport@@YAHHHH@Z
_TEXT	SEGMENT
tv357 = 8						; size = 4
_aIndex$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?gObjCheckViewport@@YAHHHH@Z PROC			; gObjCheckViewport, COMDAT

; 11133: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11134: 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0000c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11135: 
; 11136: 	if(x < lpObj->X - 15  || x > lpObj->X + 15 || y < lpObj->Y - 15 || y > lpObj->Y + 15)

  00012	0f bf 81 04 01
	00 00		 movsx	 eax, WORD PTR [ecx+260]
  00019	53		 push	 ebx
  0001a	8b 5d 0c	 mov	 ebx, DWORD PTR _x$[ebp]
  0001d	8d 50 f1	 lea	 edx, DWORD PTR [eax-15]
  00020	56		 push	 esi
  00021	3b da		 cmp	 ebx, edx
  00023	0f 8c 81 00 00
	00		 jl	 $LN5@gObjCheckV
  00029	83 c0 0f	 add	 eax, 15			; 0000000fH
  0002c	3b d8		 cmp	 ebx, eax
  0002e	7f 7a		 jg	 SHORT $LN5@gObjCheckV
  00030	0f bf 81 06 01
	00 00		 movsx	 eax, WORD PTR [ecx+262]
  00037	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0003a	8d 70 f1	 lea	 esi, DWORD PTR [eax-15]
  0003d	3b d6		 cmp	 edx, esi
  0003f	7c 69		 jl	 SHORT $LN5@gObjCheckV
  00041	83 c0 0f	 add	 eax, 15			; 0000000fH
  00044	3b d0		 cmp	 edx, eax
  00046	7f 62		 jg	 SHORT $LN5@gObjCheckV

; 11142: 
; 11143: 	for(int i = 0; i < MAX_ARRAY_FRUSTRUM; j = i, i++)

  00048	57		 push	 edi
  00049	33 f6		 xor	 esi, esi
  0004b	bf 90 fc ff ff	 mov	 edi, -880		; fffffc90H
  00050	2b f9		 sub	 edi, ecx
  00052	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00055	8d 81 70 03 00
	00		 lea	 eax, DWORD PTR [ecx+880]
  0005b	89 7d 08	 mov	 DWORD PTR tv357[ebp], edi
  0005e	eb 03		 jmp	 SHORT $LN4@gObjCheckV
$LL12@gObjCheckV:

; 11139: 	}
; 11140: 
; 11141: 	int j = 3;

  00060	8b 5d 0c	 mov	 ebx, DWORD PTR _x$[ebp]
$LN4@gObjCheckV:

; 11144: 	{
; 11145: 		int frustrum = (lpObj->FrustrumX[i]- x) * (lpObj->FrustrumY[j]-y) - (lpObj->FrustrumX[j]-x) * (lpObj->FrustrumY[i]-y);

  00063	8b bc 0a 70 03
	00 00		 mov	 edi, DWORD PTR [edx+ecx+880]
  0006a	8b 94 0a 80 03
	00 00		 mov	 edx, DWORD PTR [edx+ecx+896]
  00071	2b 55 10	 sub	 edx, DWORD PTR _y$[ebp]
  00074	2b fb		 sub	 edi, ebx
  00076	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  00079	2b 5d 10	 sub	 ebx, DWORD PTR _y$[ebp]
  0007c	0f af fb	 imul	 edi, ebx
  0007f	8b 18		 mov	 ebx, DWORD PTR [eax]
  00081	2b 5d 0c	 sub	 ebx, DWORD PTR _x$[ebp]
  00084	0f af d3	 imul	 edx, ebx
  00087	2b d7		 sub	 edx, edi

; 11146: 		if(frustrum < 0)

  00089	78 18		 js	 SHORT $LN10@gObjCheckV

; 11142: 
; 11143: 	for(int i = 0; i < MAX_ARRAY_FRUSTRUM; j = i, i++)

  0008b	8b 55 08	 mov	 edx, DWORD PTR tv357[ebp]
  0008e	03 d0		 add	 edx, eax
  00090	46		 inc	 esi
  00091	83 c0 04	 add	 eax, 4
  00094	83 fe 04	 cmp	 esi, 4
  00097	7c c7		 jl	 SHORT $LL12@gObjCheckV

; 11149: 		}
; 11150: 	}
; 11151: 	return true;

  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	b8 01 00 00 00	 mov	 eax, 1
  000a0	5b		 pop	 ebx

; 11152: }

  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
$LN10@gObjCheckV:
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi

; 11147: 		{
; 11148: 			return false;

  000a5	33 c0		 xor	 eax, eax
  000a7	5b		 pop	 ebx

; 11152: }

  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
$LN5@gObjCheckV:
  000aa	5e		 pop	 esi

; 11137: 	{
; 11138: 		return false;

  000ab	33 c0		 xor	 eax, eax
  000ad	5b		 pop	 ebx

; 11152: }

  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?gObjCheckViewport@@YAHHHH@Z ENDP			; gObjCheckViewport
_TEXT	ENDS
PUBLIC	?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z	; gObjViewportClose
; Function compile flags: /Ogtp
;	COMDAT ?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv213 = -8						; size = 4
_MVL$ = -4						; size = 4
tv496 = 8						; size = 4
_lpObj$ = 8						; size = 4
?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjViewportClose, COMDAT

; 11155: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi

; 11156: 	int tObjNum,i;
; 11157: 	int MVL = MAX_VIEWPORT;
; 11158: 
; 11159: 	if(lpObj->Type == OBJ_MONSTER)

  00007	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0000a	66 83 7f 60 02	 cmp	 WORD PTR [edi+96], 2
  0000f	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00014	89 4d fc	 mov	 DWORD PTR _MVL$[ebp], ecx
  00017	75 08		 jne	 SHORT $LN19@gObjViewpo

; 11160: 	{
; 11161: 		MVL = MAX_VIEWPORT_MONSTER;

  00019	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0001e	89 4d fc	 mov	 DWORD PTR _MVL$[ebp], ecx
$LN19@gObjViewpo:

; 11162: 	}
; 11163: 
; 11164: 	if(lpObj->Connected == PLAYER_PLAYING)

  00021	80 7f 04 03	 cmp	 BYTE PTR [edi+4], 3
  00025	0f 85 ab 00 00
	00		 jne	 $LN15@gObjViewpo

; 11165: 	{
; 11166: 		for(int n = 0; n < MVL; n++)

  0002b	85 c9		 test	 ecx, ecx
  0002d	0f 8e a3 00 00
	00		 jle	 $LN15@gObjViewpo
  00033	8d 87 18 07 00
	00		 lea	 eax, DWORD PTR [edi+1816]
  00039	53		 push	 ebx
  0003a	89 45 08	 mov	 DWORD PTR tv496[ebp], eax
  0003d	89 4d f8	 mov	 DWORD PTR tv213[ebp], ecx
  00040	56		 push	 esi
$LL32@gObjViewpo:

; 11167: 		{
; 11168: 			if(lpObj->VpPlayer2[n].state != 0)

  00041	80 78 fc 00	 cmp	 BYTE PTR [eax-4], 0
  00045	0f 84 7a 00 00
	00		 je	 $LN16@gObjViewpo

; 11169: 			{
; 11170: 				if(lpObj->VpPlayer2[n].type != 5)

  0004b	80 38 05	 cmp	 BYTE PTR [eax], 5
  0004e	74 75		 je	 SHORT $LN16@gObjViewpo

; 11171: 				{
; 11172: 					tObjNum = lpObj->VpPlayer2[n].number;

  00050	0f bf 40 fe	 movsx	 eax, WORD PTR [eax-2]
  00054	8b 37		 mov	 esi, DWORD PTR [edi]

; 11173: 
; 11174: 					i = 0;

  00056	33 c9		 xor	 ecx, ecx
  00058	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0005e	8d 90 94 03 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+916]
$LL12@gObjViewpo:

; 11175: 
; 11176: 					while( true )
; 11177: 					{
; 11178: 						if(gObj[tObjNum].VpPlayer[i].number == lpObj->m_Index)

  00064	0f bf 5a fe	 movsx	 ebx, WORD PTR [edx-2]
  00068	3b de		 cmp	 ebx, esi
  0006a	75 09		 jne	 SHORT $LN28@gObjViewpo

; 11179: 						{
; 11180: 							if(gObj[tObjNum].VpPlayer[i].type == lpObj->Type)

  0006c	0f b6 1a	 movzx	 ebx, BYTE PTR [edx]
  0006f	66 3b 5f 60	 cmp	 bx, WORD PTR [edi+96]
  00073	74 0e		 je	 SHORT $LN25@gObjViewpo
$LN28@gObjViewpo:

; 11183: 								break;
; 11184: 							}
; 11185: 						}
; 11186: 
; 11187: 						if(i < MVL-1)

  00075	8b 5d fc	 mov	 ebx, DWORD PTR _MVL$[ebp]
  00078	4b		 dec	 ebx
  00079	3b cb		 cmp	 ecx, ebx
  0007b	7d 11		 jge	 SHORT $LN29@gObjViewpo

; 11188: 						{
; 11189: 							i++;

  0007d	41		 inc	 ecx
  0007e	83 c2 0c	 add	 edx, 12			; 0000000cH

; 11190: 						}
; 11191: 						else
; 11192: 						{
; 11193: 							break;
; 11194: 						}
; 11195: 					}

  00081	eb e1		 jmp	 SHORT $LL12@gObjViewpo
$LN25@gObjViewpo:

; 11181: 							{
; 11182: 								gObj[tObjNum].VpPlayer[i].state = 3;

  00083	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00086	c6 84 88 90 03
	00 00 03	 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+ecx*4+912], 3
$LN29@gObjViewpo:

; 11196: 
; 11197: 					i = 0;

  0008e	8b 37		 mov	 esi, DWORD PTR [edi]
  00090	33 c9		 xor	 ecx, ecx
  00092	8d 90 18 07 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+1816]
$LL6@gObjViewpo:

; 11198: 
; 11199: 					while( true )
; 11200: 					{
; 11201: 						if(gObj[tObjNum].VpPlayer2[i].number == lpObj->m_Index)

  00098	0f bf 5a fe	 movsx	 ebx, WORD PTR [edx-2]
  0009c	3b de		 cmp	 ebx, esi
  0009e	75 09		 jne	 SHORT $LN30@gObjViewpo

; 11202: 						{
; 11203: 							if(gObj[tObjNum].VpPlayer2[i].type == lpObj->Type)

  000a0	0f b6 1a	 movzx	 ebx, BYTE PTR [edx]
  000a3	66 3b 5f 60	 cmp	 bx, WORD PTR [edi+96]
  000a7	74 0e		 je	 SHORT $LN26@gObjViewpo
$LN30@gObjViewpo:

; 11206: 								break;
; 11207: 							}
; 11208: 						}
; 11209: 
; 11210: 						if(i < MVL-1)

  000a9	8b 5d fc	 mov	 ebx, DWORD PTR _MVL$[ebp]
  000ac	4b		 dec	 ebx
  000ad	3b cb		 cmp	 ecx, ebx
  000af	7d 11		 jge	 SHORT $LN31@gObjViewpo

; 11211: 						{
; 11212: 							i++;

  000b1	41		 inc	 ecx
  000b2	83 c2 0c	 add	 edx, 12			; 0000000cH

; 11213: 						}
; 11214: 						else
; 11215: 						{
; 11216: 							break;
; 11217: 						}
; 11218: 					}

  000b5	eb e1		 jmp	 SHORT $LL6@gObjViewpo
$LN26@gObjViewpo:

; 11204: 							{
; 11205: 								gObj[tObjNum].VpPlayer2[i].state = 0;

  000b7	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  000ba	c6 84 90 14 07
	00 00 00	 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+edx*4+1812], 0
$LN31@gObjViewpo:
  000c2	8b 45 08	 mov	 eax, DWORD PTR tv496[ebp]
$LN16@gObjViewpo:

; 11165: 	{
; 11166: 		for(int n = 0; n < MVL; n++)

  000c5	83 c0 0c	 add	 eax, 12			; 0000000cH
  000c8	ff 4d f8	 dec	 DWORD PTR tv213[ebp]
  000cb	89 45 08	 mov	 DWORD PTR tv496[ebp], eax
  000ce	0f 85 6d ff ff
	ff		 jne	 $LL32@gObjViewpo
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
$LN15@gObjViewpo:

; 11219: 				}
; 11220: 			}
; 11221: 		}
; 11222: 	}
; 11223: 	gObjClearViewport(lpObj);

  000d6	57		 push	 edi
  000d7	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport
  000dc	83 c4 04	 add	 esp, 4
  000df	5f		 pop	 edi

; 11224: }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjViewportClose
_TEXT	ENDS
PUBLIC	?ViewportAdd@@YAHHHH@Z				; ViewportAdd
; Function compile flags: /Ogtp
;	COMDAT ?ViewportAdd@@YAHHHH@Z
_TEXT	SEGMENT
_MVL$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_aAddIndex$ = 12					; size = 4
_aType$ = 16						; size = 4
?ViewportAdd@@YAHHHH@Z PROC				; ViewportAdd, COMDAT

; 11340: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11341: 	int blank = -1;
; 11342: 	int count = 0;
; 11343: 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0000c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	83 c8 ff	 or	 eax, -1

; 11344: 	int MVL = MAX_VIEWPORT;
; 11345: 
; 11346: 	if(lpObj->Type == OBJ_MONSTER)

  00015	66 83 79 60 02	 cmp	 WORD PTR [ecx+96], 2
  0001a	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  0001f	89 55 08	 mov	 DWORD PTR _MVL$[ebp], edx
  00022	75 08		 jne	 SHORT $LN10@ViewportAd

; 11347: 	{
; 11348: 		MVL = MAX_VIEWPORT_MONSTER;

  00024	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  00029	89 55 08	 mov	 DWORD PTR _MVL$[ebp], edx
$LN10@ViewportAd:

; 11349: 	}
; 11350: 
; 11351: 	for(int n = 0; n < MVL; n++)

  0002c	56		 push	 esi
  0002d	57		 push	 edi
  0002e	33 ff		 xor	 edi, edi
  00030	85 d2		 test	 edx, edx
  00032	7e 23		 jle	 SHORT $LN14@ViewportAd
  00034	8d b1 92 03 00
	00		 lea	 esi, DWORD PTR [ecx+914]
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL18@ViewportAd:

; 11352: 	{
; 11353: 		if(lpObj->VpPlayer[n].state != 0)

  00040	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  00044	74 18		 je	 SHORT $LN6@ViewportAd

; 11354: 		{
; 11355: 			if(lpObj->VpPlayer[n].number == aAddIndex)

  00046	0f bf 16	 movsx	 edx, WORD PTR [esi]
  00049	3b 55 0c	 cmp	 edx, DWORD PTR _aAddIndex$[ebp]
  0004c	75 16		 jne	 SHORT $LN8@ViewportAd

; 11356: 			{
; 11357: 				if(lpObj->VpPlayer[n].type == aType)

  0004e	0f b6 56 02	 movzx	 edx, BYTE PTR [esi+2]
  00052	3b 55 10	 cmp	 edx, DWORD PTR _aType$[ebp]
  00055	75 0d		 jne	 SHORT $LN8@ViewportAd
$LN14@ViewportAd:
  00057	5f		 pop	 edi

; 11358: 				{
; 11359: 					return -1;

  00058	83 c8 ff	 or	 eax, -1
  0005b	5e		 pop	 esi

; 11382: 
; 11383: 	return blank;
; 11384: }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN6@ViewportAd:

; 11360: 				}
; 11361: 			}
; 11362: 		}
; 11363: 		else
; 11364: 		{
; 11365: 			if(blank < 0)

  0005e	85 c0		 test	 eax, eax
  00060	79 02		 jns	 SHORT $LN8@ViewportAd

; 11366: 			{
; 11367: 				blank = n;

  00062	8b c7		 mov	 eax, edi
$LN8@ViewportAd:

; 11349: 	}
; 11350: 
; 11351: 	for(int n = 0; n < MVL; n++)

  00064	47		 inc	 edi
  00065	83 c6 0c	 add	 esi, 12			; 0000000cH
  00068	3b 7d 08	 cmp	 edi, DWORD PTR _MVL$[ebp]
  0006b	7c d3		 jl	 SHORT $LL18@ViewportAd

; 11368: 			}
; 11369: 		}
; 11370: 	}
; 11371: 
; 11372: 	if(blank < 0)

  0006d	85 c0		 test	 eax, eax

; 11373: 	{
; 11374: 		return -1;

  0006f	78 e6		 js	 SHORT $LN14@ViewportAd

; 11375: 	}
; 11376: 
; 11377: 
; 11378: 	lpObj->VpPlayer[blank].state = 1;

  00071	8d 94 40 e4 00
	00 00		 lea	 edx, DWORD PTR [eax+eax*2+228]
  00078	c6 04 91 01	 mov	 BYTE PTR [ecx+edx*4], 1

; 11379: 	lpObj->VpPlayer[blank].number = aAddIndex;

  0007c	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0007f	8d 34 91	 lea	 esi, DWORD PTR [ecx+edx*4]
  00082	66 8b 55 0c	 mov	 dx, WORD PTR _aAddIndex$[ebp]
  00086	66 89 96 92 03
	00 00		 mov	 WORD PTR [esi+914], dx

; 11380: 	lpObj->VpPlayer[blank].type = aType;

  0008d	8a 55 10	 mov	 dl, BYTE PTR _aType$[ebp]
  00090	88 96 94 03 00
	00		 mov	 BYTE PTR [esi+916], dl

; 11381: 	lpObj->VPCount ++;

  00096	ff 81 98 0a 00
	00		 inc	 DWORD PTR [ecx+2712]
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi

; 11382: 
; 11383: 	return blank;
; 11384: }

  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
?ViewportAdd@@YAHHHH@Z ENDP				; ViewportAdd
_TEXT	ENDS
PUBLIC	?ViewportAdd2@@YAHHHH@Z				; ViewportAdd2
; Function compile flags: /Ogtp
;	COMDAT ?ViewportAdd2@@YAHHHH@Z
_TEXT	SEGMENT
_MVL$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_aAddIndex$ = 12					; size = 4
_aType$ = 16						; size = 4
?ViewportAdd2@@YAHHHH@Z PROC				; ViewportAdd2, COMDAT

; 11387: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11388: 	int blank = -1;
; 11389: 	int count = 0;
; 11390: 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0000c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	83 c8 ff	 or	 eax, -1

; 11391: 	int MVL = MAX_VIEWPORT;
; 11392: 
; 11393: 	if(lpObj->Type == OBJ_MONSTER)

  00015	66 83 79 60 02	 cmp	 WORD PTR [ecx+96], 2
  0001a	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  0001f	89 55 08	 mov	 DWORD PTR _MVL$[ebp], edx
  00022	75 08		 jne	 SHORT $LN10@ViewportAd@2

; 11394: 	{
; 11395: 		MVL = MAX_VIEWPORT_MONSTER;

  00024	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  00029	89 55 08	 mov	 DWORD PTR _MVL$[ebp], edx
$LN10@ViewportAd@2:

; 11396: 	}
; 11397: 
; 11398: 	for(int n = 0; n < MVL; n++)

  0002c	56		 push	 esi
  0002d	57		 push	 edi
  0002e	33 ff		 xor	 edi, edi
  00030	85 d2		 test	 edx, edx
  00032	7e 23		 jle	 SHORT $LN14@ViewportAd@2
  00034	8d b1 16 07 00
	00		 lea	 esi, DWORD PTR [ecx+1814]
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL18@ViewportAd@2:

; 11399: 	{
; 11400: 		if(lpObj->VpPlayer2[n].state != 0)

  00040	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  00044	74 18		 je	 SHORT $LN6@ViewportAd@2

; 11401: 		{
; 11402: 			if(lpObj->VpPlayer2[n].number == aAddIndex)

  00046	0f bf 16	 movsx	 edx, WORD PTR [esi]
  00049	3b 55 0c	 cmp	 edx, DWORD PTR _aAddIndex$[ebp]
  0004c	75 16		 jne	 SHORT $LN8@ViewportAd@2

; 11403: 			{
; 11404: 				if(lpObj->VpPlayer2[n].type == aType)

  0004e	0f b6 56 02	 movzx	 edx, BYTE PTR [esi+2]
  00052	3b 55 10	 cmp	 edx, DWORD PTR _aType$[ebp]
  00055	75 0d		 jne	 SHORT $LN8@ViewportAd@2
$LN14@ViewportAd@2:
  00057	5f		 pop	 edi

; 11405: 				{
; 11406: 					return -1;

  00058	83 c8 ff	 or	 eax, -1
  0005b	5e		 pop	 esi

; 11428: 
; 11429: 	return blank;
; 11430: }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN6@ViewportAd@2:

; 11407: 				}
; 11408: 			}
; 11409: 		}
; 11410: 		else
; 11411: 		{
; 11412: 			if(blank < 0)

  0005e	85 c0		 test	 eax, eax
  00060	79 02		 jns	 SHORT $LN8@ViewportAd@2

; 11413: 			{
; 11414: 				blank = n;

  00062	8b c7		 mov	 eax, edi
$LN8@ViewportAd@2:

; 11396: 	}
; 11397: 
; 11398: 	for(int n = 0; n < MVL; n++)

  00064	47		 inc	 edi
  00065	83 c6 0c	 add	 esi, 12			; 0000000cH
  00068	3b 7d 08	 cmp	 edi, DWORD PTR _MVL$[ebp]
  0006b	7c d3		 jl	 SHORT $LL18@ViewportAd@2

; 11415: 			}
; 11416: 		}
; 11417: 	}
; 11418: 
; 11419: 	if(blank < 0)

  0006d	85 c0		 test	 eax, eax

; 11420: 	{
; 11421: 		return -1;

  0006f	78 e6		 js	 SHORT $LN14@ViewportAd@2

; 11422: 	}
; 11423: 
; 11424: 	lpObj->VpPlayer2[blank].state = 1;

  00071	8d 94 40 c5 01
	00 00		 lea	 edx, DWORD PTR [eax+eax*2+453]
  00078	c6 04 91 01	 mov	 BYTE PTR [ecx+edx*4], 1

; 11425: 	lpObj->VpPlayer2[blank].number = aAddIndex;

  0007c	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0007f	8d 34 91	 lea	 esi, DWORD PTR [ecx+edx*4]
  00082	66 8b 55 0c	 mov	 dx, WORD PTR _aAddIndex$[ebp]
  00086	66 89 96 16 07
	00 00		 mov	 WORD PTR [esi+1814], dx

; 11426: 	lpObj->VpPlayer2[blank].type = aType;

  0008d	8a 55 10	 mov	 dl, BYTE PTR _aType$[ebp]
  00090	88 96 18 07 00
	00		 mov	 BYTE PTR [esi+1816], dl

; 11427: 	lpObj->VPCount2 ++;

  00096	ff 81 9c 0a 00
	00		 inc	 DWORD PTR [ecx+2716]
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi

; 11428: 
; 11429: 	return blank;
; 11430: }

  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
?ViewportAdd2@@YAHHHH@Z ENDP				; ViewportAdd2
_TEXT	ENDS
PUBLIC	?ViewportDel@@YAXFH@Z				; ViewportDel
; Function compile flags: /Ogtp
;	COMDAT ?ViewportDel@@YAXFH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 2
_aDelIndex$ = 12					; size = 4
?ViewportDel@@YAXFH@Z PROC				; ViewportDel, COMDAT

; 11433: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11434: 	if(gObjIsConnected(aIndex) == 0)

  00003	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 68		 je	 SHORT $LN4@ViewportDe

; 11435: 	{
; 11436: 		return;
; 11437: 	}
; 11438: 
; 11439: 	if(gObjIsConnected(aDelIndex) == 0)

  00014	53		 push	 ebx
  00015	8b 5d 0c	 mov	 ebx, DWORD PTR _aDelIndex$[ebp]
  00018	53		 push	 ebx
  00019	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	74 56		 je	 SHORT $LN15@ViewportDe

; 11440: 	{
; 11441: 		return;
; 11442: 	}
; 11443: 
; 11444: 	LPOBJ lpObj = &gObj[aIndex];

  00025	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0002b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11445: 	int MVL = MAX_VIEWPORT;
; 11446: 
; 11447: 	if(lpObj->Type == OBJ_MONSTER)

  00031	66 83 79 60 02	 cmp	 WORD PTR [ecx+96], 2
  00036	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  0003b	75 05		 jne	 SHORT $LN7@ViewportDe

; 11448: 	{
; 11449: 		MVL = MAX_VIEWPORT_MONSTER;

  0003d	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
$LN7@ViewportDe:

; 11450: 	}
; 11451: 
; 11452: 	for(int n = 0; n < MVL; n++)

  00042	85 d2		 test	 edx, edx
  00044	7e 35		 jle	 SHORT $LN15@ViewportDe
  00046	56		 push	 esi
  00047	8d 81 90 03 00
	00		 lea	 eax, DWORD PTR [ecx+912]
  0004d	8b f2		 mov	 esi, edx
  0004f	90		 npad	 1
$LL6@ViewportDe:

; 11453: 	{
; 11454: 		if(lpObj->VpPlayer[n].state == 1 || lpObj->VpPlayer[n].state == 2)

  00050	8a 10		 mov	 dl, BYTE PTR [eax]
  00052	80 fa 01	 cmp	 dl, 1
  00055	74 05		 je	 SHORT $LN2@ViewportDe
  00057	80 fa 02	 cmp	 dl, 2
  0005a	75 18		 jne	 SHORT $LN5@ViewportDe
$LN2@ViewportDe:

; 11455: 		{
; 11456: 			if(lpObj->VpPlayer[n].number == aDelIndex)

  0005c	0f bf 50 02	 movsx	 edx, WORD PTR [eax+2]
  00060	3b d3		 cmp	 edx, ebx
  00062	75 10		 jne	 SHORT $LN5@ViewportDe

; 11457: 			{
; 11458: 				lpObj->VpPlayer[n].state = 0;
; 11459: 				lpObj->VpPlayer[n].number = -1;

  00064	83 ca ff	 or	 edx, -1
  00067	c6 00 00	 mov	 BYTE PTR [eax], 0
  0006a	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 11460: 				lpObj->VPCount --;

  0006e	ff 89 98 0a 00
	00		 dec	 DWORD PTR [ecx+2712]
$LN5@ViewportDe:

; 11450: 	}
; 11451: 
; 11452: 	for(int n = 0; n < MVL; n++)

  00074	83 c0 0c	 add	 eax, 12			; 0000000cH
  00077	4e		 dec	 esi
  00078	75 d6		 jne	 SHORT $LL6@ViewportDe
  0007a	5e		 pop	 esi
$LN15@ViewportDe:
  0007b	5b		 pop	 ebx
$LN4@ViewportDe:

; 11461: 			}
; 11462: 		}
; 11463: 	}
; 11464: }

  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?ViewportDel@@YAXFH@Z ENDP				; ViewportDel
_TEXT	ENDS
PUBLIC	?Viewport2Del@@YAXFH@Z				; Viewport2Del
; Function compile flags: /Ogtp
;	COMDAT ?Viewport2Del@@YAXFH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 2
_aDelIndex$ = 12					; size = 4
?Viewport2Del@@YAXFH@Z PROC				; Viewport2Del, COMDAT

; 11467: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11468: 	if(gObjIsConnected(aIndex) == 0)

  00003	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 68		 je	 SHORT $LN4@Viewport2D

; 11469: 	{
; 11470: 		return;
; 11471: 	}
; 11472: 
; 11473: 	if(gObjIsConnected(aDelIndex) == 0)

  00014	53		 push	 ebx
  00015	8b 5d 0c	 mov	 ebx, DWORD PTR _aDelIndex$[ebp]
  00018	53		 push	 ebx
  00019	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	74 56		 je	 SHORT $LN15@Viewport2D

; 11474: 	{
; 11475: 		return;
; 11476: 	}
; 11477: 
; 11478: 	LPOBJ lpObj = &gObj[aIndex];

  00025	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0002b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11479: 	int MVL = MAX_VIEWPORT;
; 11480: 
; 11481: 	if(lpObj->Type == OBJ_MONSTER)

  00031	66 83 79 60 02	 cmp	 WORD PTR [ecx+96], 2
  00036	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  0003b	75 05		 jne	 SHORT $LN7@Viewport2D

; 11482: 	{
; 11483: 		MVL = MAX_VIEWPORT_MONSTER;

  0003d	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
$LN7@Viewport2D:

; 11484: 	}
; 11485: 
; 11486: 	for(int n = 0; n < MVL; n++)

  00042	85 d2		 test	 edx, edx
  00044	7e 35		 jle	 SHORT $LN15@Viewport2D
  00046	56		 push	 esi
  00047	8d 81 14 07 00
	00		 lea	 eax, DWORD PTR [ecx+1812]
  0004d	8b f2		 mov	 esi, edx
  0004f	90		 npad	 1
$LL6@Viewport2D:

; 11487: 	{
; 11488: 		if(lpObj->VpPlayer2[n].state == 1 || lpObj->VpPlayer2[n].state == 2)

  00050	8a 10		 mov	 dl, BYTE PTR [eax]
  00052	80 fa 01	 cmp	 dl, 1
  00055	74 05		 je	 SHORT $LN2@Viewport2D
  00057	80 fa 02	 cmp	 dl, 2
  0005a	75 18		 jne	 SHORT $LN5@Viewport2D
$LN2@Viewport2D:

; 11489: 		{
; 11490: 			if(lpObj->VpPlayer2[n].number == aDelIndex)

  0005c	0f bf 50 02	 movsx	 edx, WORD PTR [eax+2]
  00060	3b d3		 cmp	 edx, ebx
  00062	75 10		 jne	 SHORT $LN5@Viewport2D

; 11491: 			{
; 11492: 				lpObj->VpPlayer2[n].state = 0;
; 11493: 				lpObj->VpPlayer2[n].number = -1;

  00064	83 ca ff	 or	 edx, -1
  00067	c6 00 00	 mov	 BYTE PTR [eax], 0
  0006a	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 11494: 				lpObj->VPCount2 --;

  0006e	ff 89 9c 0a 00
	00		 dec	 DWORD PTR [ecx+2716]
$LN5@Viewport2D:

; 11484: 	}
; 11485: 
; 11486: 	for(int n = 0; n < MVL; n++)

  00074	83 c0 0c	 add	 eax, 12			; 0000000cH
  00077	4e		 dec	 esi
  00078	75 d6		 jne	 SHORT $LL6@Viewport2D
  0007a	5e		 pop	 esi
$LN15@Viewport2D:
  0007b	5b		 pop	 ebx
$LN4@Viewport2D:

; 11495: 			}
; 11496: 		}
; 11497: 	}
; 11498: }

  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?Viewport2Del@@YAXFH@Z ENDP				; Viewport2Del
_TEXT	ENDS
PUBLIC	?gObjViewportAllDel@@YAXF@Z			; gObjViewportAllDel
; Function compile flags: /Ogtp
;	COMDAT ?gObjViewportAllDel@@YAXF@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 2
?gObjViewportAllDel@@YAXF@Z PROC			; gObjViewportAllDel, COMDAT

; 11501: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 11502: 	if(gObjIsConnected(aIndex) == 0)

  00004	0f bf 5d 08	 movsx	 ebx, WORD PTR _aIndex$[ebp]
  00008	53		 push	 ebx
  00009	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000e	83 c4 04	 add	 esp, 4
  00011	85 c0		 test	 eax, eax
  00013	74 6b		 je	 SHORT $LN5@gObjViewpo@2

; 11503: 	{
; 11504: 		return;
; 11505: 	}
; 11506: 
; 11507: 	LPOBJ lpObj = &gObj[aIndex];

  00015	8b c3		 mov	 eax, ebx
  00017	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0001d	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11508: 	int MVL = MAX_VIEWPORT;
; 11509: 
; 11510: 	if(lpObj->Type == OBJ_MONSTER)

  00022	66 83 78 60 02	 cmp	 WORD PTR [eax+96], 2
  00027	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  0002c	75 05		 jne	 SHORT $LN8@gObjViewpo@2

; 11511: 	{
; 11512: 		MVL = MAX_VIEWPORT_MONSTER;

  0002e	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
$LN8@gObjViewpo@2:

; 11513: 	}
; 11514: 
; 11515: 	for(int n = 0; n < MVL; n++)

  00033	85 c9		 test	 ecx, ecx
  00035	7e 49		 jle	 SHORT $LN5@gObjViewpo@2
  00037	56		 push	 esi
  00038	57		 push	 edi
  00039	8d b0 90 03 00
	00		 lea	 esi, DWORD PTR [eax+912]
  0003f	8b f9		 mov	 edi, ecx
$LL7@gObjViewpo@2:

; 11516: 	{
; 11517: 		if(lpObj->VpPlayer[n].state == 1 || lpObj->VpPlayer[n].state == 2)

  00041	8a 06		 mov	 al, BYTE PTR [esi]
  00043	3c 01		 cmp	 al, 1
  00045	74 04		 je	 SHORT $LN3@gObjViewpo@2
  00047	3c 02		 cmp	 al, 2
  00049	75 0e		 jne	 SHORT $LN4@gObjViewpo@2
$LN3@gObjViewpo@2:

; 11518: 		{
; 11519: 			Viewport2Del(lpObj->VpPlayer[n].number,aIndex);

  0004b	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  0004f	53		 push	 ebx
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?Viewport2Del@@YAXFH@Z	; Viewport2Del
  00056	83 c4 08	 add	 esp, 8
$LN4@gObjViewpo@2:

; 11520: 		}
; 11521: 
; 11522: 		if(lpObj->VpPlayer2[n].state == 1 || lpObj->VpPlayer2[n].state == 2)

  00059	8a 86 84 03 00
	00		 mov	 al, BYTE PTR [esi+900]
  0005f	3c 01		 cmp	 al, 1
  00061	74 04		 je	 SHORT $LN1@gObjViewpo@2
  00063	3c 02		 cmp	 al, 2
  00065	75 11		 jne	 SHORT $LN6@gObjViewpo@2
$LN1@gObjViewpo@2:

; 11523: 		{
; 11524: 			ViewportDel(lpObj->VpPlayer2[n].number,aIndex);

  00067	0f b7 8e 86 03
	00 00		 movzx	 ecx, WORD PTR [esi+902]
  0006e	53		 push	 ebx
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 ?ViewportDel@@YAXFH@Z	; ViewportDel
  00075	83 c4 08	 add	 esp, 8
$LN6@gObjViewpo@2:

; 11513: 	}
; 11514: 
; 11515: 	for(int n = 0; n < MVL; n++)

  00078	83 c6 0c	 add	 esi, 12			; 0000000cH
  0007b	4f		 dec	 edi
  0007c	75 c3		 jne	 SHORT $LL7@gObjViewpo@2
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
$LN5@gObjViewpo@2:
  00080	5b		 pop	 ebx

; 11525: 		}
; 11526: 	}
; 11527: }

  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?gObjViewportAllDel@@YAXF@Z ENDP			; gObjViewportAllDel
_TEXT	ENDS
PUBLIC	?gObjViewportListDestroy@@YAXF@Z		; gObjViewportListDestroy
; Function compile flags: /Ogtp
;	COMDAT ?gObjViewportListDestroy@@YAXF@Z
_TEXT	SEGMENT
tv246 = -4						; size = 4
tv387 = 8						; size = 4
_aIndex$ = 8						; size = 2
?gObjViewportListDestroy@@YAXF@Z PROC			; gObjViewportListDestroy, COMDAT

; 11530: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 11531: 	short tObjNum;
; 11532: 	int n;
; 11533: 	LPOBJ lpObj;
; 11534: 	int MVL;
; 11535: 
; 11536: 	if(OBJMAX_RANGE(aIndex) == 0)

  00004	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  00008	66 85 c0	 test	 ax, ax
  0000b	0f 88 8b 01 00
	00		 js	 $LN26@gObjViewpo@3
  00011	33 d2		 xor	 edx, edx
  00013	b9 e7 1c 00 00	 mov	 ecx, 7399		; 00001ce7H
  00018	66 3b c1	 cmp	 ax, cx
  0001b	0f 9e c2	 setle	 dl
  0001e	8b ca		 mov	 ecx, edx
  00020	85 c9		 test	 ecx, ecx
  00022	0f 84 74 01 00
	00		 je	 $LN26@gObjViewpo@3

; 11537: 	{
; 11538: 		return;
; 11539: 	}
; 11540: 
; 11541: 	if(gObj[aIndex].Connected < PLAYER_PLAYING)

  00028	0f bf d0	 movsx	 edx, ax
  0002b	53		 push	 ebx
  0002c	8b da		 mov	 ebx, edx
  0002e	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  00034	80 bb 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+4], 3
  0003b	89 55 08	 mov	 DWORD PTR tv387[ebp], edx
  0003e	0f 82 57 01 00
	00		 jb	 $LN41@gObjViewpo@3

; 11542: 	{
; 11543: 		return;
; 11544: 	}
; 11545: 
; 11546: 	lpObj = &gObj[aIndex];
; 11547: 	MVL = MAX_VIEWPORT;
; 11548: 
; 11549: 	if(lpObj->Type == OBJ_MONSTER)

  00044	66 83 bb 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+96], 2
  0004c	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  00051	75 05		 jne	 SHORT $LN29@gObjViewpo@3

; 11550: 	{
; 11551: 		MVL = MAX_VIEWPORT_MONSTER;

  00053	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
$LN29@gObjViewpo@3:

; 11552: 	}
; 11553: 
; 11554: 	for(n = 0; n < MVL; n++)

  00058	85 c0		 test	 eax, eax
  0005a	0f 8e 3b 01 00
	00		 jle	 $LN41@gObjViewpo@3
  00060	56		 push	 esi
  00061	57		 push	 edi
  00062	8d b3 90 03 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+912]
  00068	89 45 fc	 mov	 DWORD PTR tv246[ebp], eax
  0006b	eb 06		 jmp	 SHORT $LN28@gObjViewpo@3
  0006d	8d 49 00	 npad	 3
$LL40@gObjViewpo@3:
  00070	8b 55 08	 mov	 edx, DWORD PTR tv387[ebp]
$LN28@gObjViewpo@3:

; 11555: 	{
; 11556: 		int mapnum;
; 11557: 		if(lpObj->VpPlayer[n].state == 1 || lpObj->VpPlayer[n].state == 2)

  00073	8a 06		 mov	 al, BYTE PTR [esi]
  00075	3c 01		 cmp	 al, 1
  00077	74 08		 je	 SHORT $LN24@gObjViewpo@3
  00079	3c 02		 cmp	 al, 2
  0007b	0f 85 b1 00 00
	00		 jne	 $LN38@gObjViewpo@3
$LN24@gObjViewpo@3:

; 11558: 		{
; 11559: 			tObjNum = lpObj->VpPlayer[n].number;
; 11560: 
; 11561: 			switch(lpObj->VpPlayer[n].type)

  00081	80 7e 04 05	 cmp	 BYTE PTR [esi+4], 5
  00085	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  00089	74 53		 je	 SHORT $LN21@gObjViewpo@3

; 11585: 					}
; 11586: 					else
; 11587: 					{
; 11588: 						lpObj->VpPlayer[n].state = 3;
; 11589: 					}
; 11590: 				}
; 11591: 				break;
; 11592: 			default : 
; 11593: 				if(gObj[tObjNum].m_State == 1)

  0008b	0f bf c1	 movsx	 eax, cx
  0008e	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00094	83 b8 bc 01 00
	00 01		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+444], 1
  0009b	75 0c		 jne	 SHORT $LN10@gObjViewpo@3

; 11594: 				{
; 11595: 					if(gObj[tObjNum].Live == 0)

  0009d	80 b8 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+98], 0
  000a4	75 03		 jne	 SHORT $LN10@gObjViewpo@3

; 11596: 					{
; 11597: 						lpObj->VpPlayer[n].state = 3;

  000a6	c6 06 03	 mov	 BYTE PTR [esi], 3
$LN10@gObjViewpo@3:

; 11598: 					}
; 11599: 				}
; 11600: 
; 11601: 				if(gObj[tObjNum].Connected  == PLAYER_EMPTY ||
; 11602: 					gObj[tObjNum].m_State == 8 ||
; 11603: 					gObj[tObjNum].Teleport != 0 ||
; 11604: 					gObj[tObjNum].m_State == 32)

  000a9	80 b8 04 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 0
  000b0	74 7d		 je	 SHORT $LN14@gObjViewpo@3
  000b2	8b 88 bc 01 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+444]
  000b8	83 f9 08	 cmp	 ecx, 8
  000bb	74 72		 je	 SHORT $LN14@gObjViewpo@3
  000bd	80 b8 00 02 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+512], 0
  000c4	75 69		 jne	 SHORT $LN14@gObjViewpo@3
  000c6	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000c9	74 64		 je	 SHORT $LN14@gObjViewpo@3

; 11605: 				{
; 11606: 					lpObj->VpPlayer[n].state = 3;
; 11607: 				}
; 11608: 				else
; 11609: 				{
; 11610: 					if(gObjCheckViewport(aIndex,gObj[tObjNum].X,gObj[tObjNum].Y) == 0)

  000cb	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  000d2	0f bf 80 04 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  000d9	51		 push	 ecx
  000da	50		 push	 eax
  000db	52		 push	 edx

; 11611: 					{
; 11612: 						lpObj->VpPlayer[n].state = 3;

  000dc	eb 45		 jmp	 SHORT $LN45@gObjViewpo@3
$LN21@gObjViewpo@3:

; 11562: 			{
; 11563: 			case 5:
; 11564: 				mapnum = lpObj->MapNumber;

  000de	0f b6 83 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+265]

; 11565: 
; 11566: 				if(MapC[mapnum].m_cItem[tObjNum].IsItem() == 1)

  000e5	0f bf f9	 movsx	 edi, cx
  000e8	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  000ee	69 ff 48 04 00
	00		 imul	 edi, 1096		; 00000448H
  000f4	03 f8		 add	 edi, eax
  000f6	8d 8f 24 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[edi+36]
  000fc	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00101	83 f8 01	 cmp	 eax, 1
  00104	75 29		 jne	 SHORT $LN14@gObjViewpo@3

; 11567: 				{
; 11568: 					if(MapC[mapnum].m_cItem[tObjNum].m_State == 8)

  00106	83 bf d0 00 00
	00 08		 cmp	 DWORD PTR ?MapC@@3PAVMapClass@@A[edi+208], 8

; 11569: 					{
; 11570: 						lpObj->VpPlayer[n].state = 3;
; 11571: 					}
; 11572: 					else

  0010d	74 20		 je	 SHORT $LN14@gObjViewpo@3

; 11573: 					{
; 11574: 						if(gObjCheckViewport(aIndex,MapC[mapnum].m_cItem[tObjNum].px,MapC[mapnum].m_cItem[tObjNum].py) == 0)

  0010f	0f b6 97 cd 00
	00 00		 movzx	 edx, BYTE PTR ?MapC@@3PAVMapClass@@A[edi+205]
  00116	0f b6 87 cc 00
	00 00		 movzx	 eax, BYTE PTR ?MapC@@3PAVMapClass@@A[edi+204]
  0011d	8b 4d 08	 mov	 ecx, DWORD PTR tv387[ebp]
  00120	52		 push	 edx
  00121	50		 push	 eax
  00122	51		 push	 ecx
$LN45@gObjViewpo@3:
  00123	e8 00 00 00 00	 call	 ?gObjCheckViewport@@YAHHHH@Z ; gObjCheckViewport
  00128	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012b	85 c0		 test	 eax, eax
  0012d	75 03		 jne	 SHORT $LN38@gObjViewpo@3
$LN14@gObjViewpo@3:

; 11575: 						{
; 11576: 							lpObj->VpPlayer[n].state = 3;
; 11577: 						}
; 11578: 					}
; 11579: 				}
; 11580: 				else
; 11581: 				{
; 11582: 					if(MapC[mapnum].m_cItem[tObjNum].live == 0 || MapC[mapnum].m_cItem[tObjNum].Give == 0)
; 11583: 					{
; 11584: 						lpObj->VpPlayer[n].state = 3;

  0012f	c6 06 03	 mov	 BYTE PTR [esi], 3
$LN38@gObjViewpo@3:

; 11613: 					}
; 11614: 				}
; 11615: 				break;
; 11616: 			}
; 11617: 		}
; 11618: 
; 11619: 		if(lpObj->VpPlayer2[n].state == 1 || lpObj->VpPlayer2[n].state == 2)

  00132	8a 86 84 03 00
	00		 mov	 al, BYTE PTR [esi+900]
  00138	3c 01		 cmp	 al, 1
  0013a	74 04		 je	 SHORT $LN4@gObjViewpo@3
  0013c	3c 02		 cmp	 al, 2
  0013e	75 4d		 jne	 SHORT $LN27@gObjViewpo@3
$LN4@gObjViewpo@3:

; 11620: 		{
; 11621: 			tObjNum = lpObj->VpPlayer2[n].number;

  00140	0f b7 86 86 03
	00 00		 movzx	 eax, WORD PTR [esi+902]

; 11622: 
; 11623: 			if(gObj[tObjNum].Connected < PLAYER_PLAYING)

  00147	98		 cwde
  00148	8b d0		 mov	 edx, eax
  0014a	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00150	80 ba 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+4], 3

; 11624: 			{
; 11625: 				lpObj->VpPlayer2[n].state = 0;
; 11626: 				lpObj->VpPlayer2[n].number = -1;
; 11627: 				lpObj->VPCount2 --;
; 11628: 			}
; 11629: 			else

  00157	72 1d		 jb	 SHORT $LN43@gObjViewpo@3

; 11630: 			{
; 11631: 				if(gObjCheckViewport(tObjNum,lpObj->X,lpObj->Y) == 0)

  00159	0f bf 8b 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+262]
  00160	0f bf 93 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+260]
  00167	51		 push	 ecx
  00168	52		 push	 edx
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 ?gObjCheckViewport@@YAHHHH@Z ; gObjCheckViewport
  0016f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00172	85 c0		 test	 eax, eax
  00174	75 17		 jne	 SHORT $LN27@gObjViewpo@3
$LN43@gObjViewpo@3:

; 11632: 				{
; 11633: 					lpObj->VpPlayer2[n].state = 0;
; 11634: 					lpObj->VpPlayer2[n].number = -1;

  00176	83 c8 ff	 or	 eax, -1
  00179	c6 86 84 03 00
	00 00		 mov	 BYTE PTR [esi+900], 0
  00180	66 89 86 86 03
	00 00		 mov	 WORD PTR [esi+902], ax

; 11635: 					lpObj->VPCount2 --;

  00187	ff 8b 9c 0a 00
	00		 dec	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+2716]
$LN27@gObjViewpo@3:

; 11552: 	}
; 11553: 
; 11554: 	for(n = 0; n < MVL; n++)

  0018d	83 c6 0c	 add	 esi, 12			; 0000000cH
  00190	ff 4d fc	 dec	 DWORD PTR tv246[ebp]
  00193	0f 85 d7 fe ff
	ff		 jne	 $LL40@gObjViewpo@3
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
$LN41@gObjViewpo@3:
  0019b	5b		 pop	 ebx
$LN26@gObjViewpo@3:

; 11636: 				}
; 11637: 			}
; 11638: 		}
; 11639: 	}
; 11640: }

  0019c	8b e5		 mov	 esp, ebp
  0019e	5d		 pop	 ebp
  0019f	c3		 ret	 0
?gObjViewportListDestroy@@YAXF@Z ENDP			; gObjViewportListDestroy
_TEXT	ENDS
PUBLIC	??_C@_0DA@GGNIPOJP@?$FLPShop?$FN?5ERROR?5?3?5iVpAddCount?5is?5O@ ; `string'
PUBLIC	??_C@_0DB@CHPPJFL@?$FLPShop?$FN?5ERROR?5?3?5iVpOpenCount?5is?5@ ; `string'
PUBLIC	??_C@_0EC@MINIMHLG@?$FLPShop?$FN?5ERROR?5?3?5lpObj?9?$DOm_wVpPSho@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?PShop_ViewportListRegenarate@@YAXF@Z		; PShop_ViewportListRegenarate
EXTRN	?CGPShopAnsDealerClosedShop@@YAXHH@Z:PROC	; CGPShopAnsDealerClosedShop
EXTRN	?CGPShopAnsBuyList@@YAXHHE_N@Z:PROC		; CGPShopAnsBuyList
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?PHeadSubSetW@@YAXPAEEEH@Z:PROC			; PHeadSubSetW
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_0DA@GGNIPOJP@?$FLPShop?$FN?5ERROR?5?3?5iVpAddCount?5is?5O@
CONST	SEGMENT
??_C@_0DA@GGNIPOJP@?$FLPShop?$FN?5ERROR?5?3?5iVpAddCount?5is?5O@ DB '[PSh'
	DB	'op] ERROR : iVpAddCount is OUT of BOUND: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CHPPJFL@?$FLPShop?$FN?5ERROR?5?3?5iVpOpenCount?5is?5@
CONST	SEGMENT
??_C@_0DB@CHPPJFL@?$FLPShop?$FN?5ERROR?5?3?5iVpOpenCount?5is?5@ DB '[PSho'
	DB	'p] ERROR : iVpOpenCount is OUT of BOUND: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@MINIMHLG@?$FLPShop?$FN?5ERROR?5?3?5lpObj?9?$DOm_wVpPSho@
CONST	SEGMENT
??_C@_0EC@MINIMHLG@?$FLPShop?$FN?5ERROR?5?3?5lpObj?9?$DOm_wVpPSho@ DB '[P'
	DB	'Shop] ERROR : lpObj->m_wVpPShopPlayerCount is OUT of BOUND : '
	DB	'%d', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?PShop_ViewportListRegenarate@@YAXF@Z
_TEXT	SEGMENT
tv829 = -6348						; size = 4
_i$165989 = -6344					; size = 4
tv999 = -6340						; size = 4
tv313 = -6336						; size = 4
tv976 = -6332						; size = 4
tv912 = -6328						; size = 4
tv1096 = -6324						; size = 4
tv544 = -6320						; size = 4
tv978 = -6316						; size = 4
_iVpOpenCount$ = -6312					; size = 4
_iVpAddCount$ = -6308					; size = 4
_iPShopOpenIndex$ = -6304				; size = 300
_cBUFFER$ = -6004					; size = 6000
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 2
?PShop_ViewportListRegenarate@@YAXF@Z PROC		; PShop_ViewportListRegenarate, COMDAT

; 11654: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 cc 18 00 00	 mov	 eax, 6348		; 000018ccH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	0f b7 45 08	 movzx	 eax, WORD PTR _aIndex$[ebp]
  0001b	53		 push	 ebx

; 11655: 	if(gObjIsConnected(aIndex) == 0)

  0001c	0f bf d8	 movsx	 ebx, ax
  0001f	53		 push	 ebx
  00020	89 9d 50 e7 ff
	ff		 mov	 DWORD PTR tv544[ebp], ebx
  00026	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002b	83 c4 04	 add	 esp, 4
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 af 03 00
	00		 je	 $LN1@PShop_View

; 11656: 	{
; 11657: 		return ;
; 11658: 	}
; 11659: 
; 11660: 	LPOBJ lpObj = &gObj[aIndex];

  00036	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H

; 11661: 
; 11662: 	if(lpObj->Type != OBJ_USER)

  0003c	66 83 bb 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+96], 1
  00044	0f 85 9b 03 00
	00		 jne	 $LN1@PShop_View

; 11663: 	{
; 11664: 		return;
; 11665: 	}
; 11666: 
; 11667: 	if(lpObj->RegenOk > 0)

  0004a	80 bb 03 02 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+515], 0
  00051	0f 8f 8e 03 00
	00		 jg	 $LN1@PShop_View

; 11668: 	{
; 11669: 		return;
; 11670: 	}
; 11671: 
; 11672: 	if(lpObj->CloseCount > -1)

  00057	80 bb 07 00 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+7], -1
  0005e	0f 8f 81 03 00
	00		 jg	 $LN1@PShop_View

; 11673: 	{
; 11674: 		return;
; 11675: 	}
; 11676: 
; 11677: 	BYTE cBUFFER[6000];
; 11678: 	int iVpOpenCount = 0;

  00064	33 c0		 xor	 eax, eax
  00066	89 85 58 e7 ff
	ff		 mov	 DWORD PTR _iVpOpenCount$[ebp], eax

; 11679: 	int iVpAddCount = 0;

  0006c	89 85 5c e7 ff
	ff		 mov	 DWORD PTR _iVpAddCount$[ebp], eax

; 11680: 
; 11681: 	PMSG_ANS_PSHOP_VIEWPORT_NOTIFY * lpMsg = (PMSG_ANS_PSHOP_VIEWPORT_NOTIFY *)&cBUFFER;
; 11682: 	PMSG_PSHOP_VIEWPORT_NOTIFY * lpMsgBody = (PMSG_PSHOP_VIEWPORT_NOTIFY *)&cBUFFER[6];
; 11683: 
; 11684: 	int iPShopOpenIndex[MAX_VIEWPORT];
; 11685: 
; 11686: 	if(lpObj->m_bPShopRedrawAbs != 0)

  00072	38 83 2b 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3371], al
  00078	74 24		 je	 SHORT $LN49@PShop_View

; 11687: 	{
; 11688: 		memset(lpObj->m_iVpPShopPlayer,0x00,sizeof(lpObj->m_iVpPShopPlayer));

  0007a	68 2c 01 00 00	 push	 300			; 0000012cH
  0007f	50		 push	 eax
  00080	8d 83 7c 0d 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3452]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _memset
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11689: 		lpObj->m_wVpPShopPlayerCount = 0;

  0008f	33 c9		 xor	 ecx, ecx
  00091	66 89 8b a8 0e
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3752], cx

; 11690: 		lpObj->m_bPShopRedrawAbs = 0;

  00098	88 8b 2b 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3371], cl
$LN49@PShop_View:

; 11691: 	}
; 11692: 
; 11693: 	for(int n = 0; n < MAX_VIEWPORT; n++)

  0009e	56		 push	 esi
  0009f	8d 85 92 e8 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp+6]
  000a5	8d 95 94 e8 ff
	ff		 lea	 edx, DWORD PTR _cBUFFER$[ebp+8]
  000ab	8d b3 92 03 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+914]
  000b1	57		 push	 edi
  000b2	89 85 48 e7 ff
	ff		 mov	 DWORD PTR tv912[ebp], eax
  000b8	89 95 44 e7 ff
	ff		 mov	 DWORD PTR tv976[ebp], edx
  000be	89 b5 54 e7 ff
	ff		 mov	 DWORD PTR tv978[ebp], esi
  000c4	c7 85 40 e7 ff
	ff 4b 00 00 00	 mov	 DWORD PTR tv313[ebp], 75 ; 0000004bH
  000ce	8b ff		 npad	 2
$LL33@PShop_View:

; 11694: 	{
; 11695: 		if(lpObj->VpPlayer[n].state == 2 && lpObj->VpPlayer[n].type == OBJ_USER && gObj[lpObj->VpPlayer[n].number].m_bPShopOpen == 1)

  000d0	80 7e fe 02	 cmp	 BYTE PTR [esi-2], 2
  000d4	0f 85 12 01 00
	00		 jne	 $LN32@PShop_View
  000da	80 7e 02 01	 cmp	 BYTE PTR [esi+2], 1
  000de	0f 85 08 01 00
	00		 jne	 $LN32@PShop_View
  000e4	0f b7 0e	 movzx	 ecx, WORD PTR [esi]
  000e7	0f bf f9	 movsx	 edi, cx
  000ea	89 8d 4c e7 ff
	ff		 mov	 DWORD PTR tv1096[ebp], ecx
  000f0	8b cf		 mov	 ecx, edi
  000f2	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000f8	80 b9 28 0d 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3368], 1
  000ff	89 8d 3c e7 ff
	ff		 mov	 DWORD PTR tv999[ebp], ecx
  00105	0f 85 e1 00 00
	00		 jne	 $LN32@PShop_View

; 11696: 		{
; 11697: 			iPShopOpenIndex[iVpOpenCount] = lpObj->VpPlayer[n].number;

  0010b	8b 8d 58 e7 ff
	ff		 mov	 ecx, DWORD PTR _iVpOpenCount$[ebp]
  00111	89 bc 8d 60 e7
	ff ff		 mov	 DWORD PTR _iPShopOpenIndex$[ebp+ecx*4], edi

; 11698: 			iVpOpenCount++;

  00118	41		 inc	 ecx
  00119	89 8d 58 e7 ff
	ff		 mov	 DWORD PTR _iVpOpenCount$[ebp], ecx

; 11699: 
; 11700: 			if(lpObj->m_wVpPShopPlayerCount > 0 && lpObj->m_wVpPShopPlayerCount <= MAX_VIEWPORT)

  0011f	0f b7 8b a8 0e
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3752]
  00126	66 85 c9	 test	 cx, cx
  00129	74 5b		 je	 SHORT $LN48@PShop_View
  0012b	83 f9 4b	 cmp	 ecx, 75			; 0000004bH
  0012e	0f 87 91 00 00
	00		 ja	 $LN29@PShop_View

; 11701: 			{
; 11702: 				int found = 0;
; 11703: 
; 11704: 				for(int i = 0; i < lpObj->m_wVpPShopPlayerCount; i++)

  00134	33 ff		 xor	 edi, edi
  00136	c7 85 38 e7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$165989[ebp], 0
  00140	66 3b f9	 cmp	 di, cx
  00143	73 41		 jae	 SHORT $LN48@PShop_View
  00145	8d bb 7c 0d 00
	00		 lea	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3452]
  0014b	eb 09		 jmp	 SHORT $LN28@PShop_View
  0014d	8d 49 00	 npad	 3
$LL50@PShop_View:
  00150	8b bd 34 e7 ff
	ff		 mov	 edi, DWORD PTR tv829[ebp]
$LN28@PShop_View:

; 11705: 				{
; 11706: 					if(lpObj->m_iVpPShopPlayer[i] == lpObj->VpPlayer[n].number)

  00156	0f bf 8d 4c e7
	ff ff		 movsx	 ecx, WORD PTR tv1096[ebp]
  0015d	39 0f		 cmp	 DWORD PTR [edi], ecx
  0015f	0f 84 87 00 00
	00		 je	 $LN32@PShop_View

; 11701: 			{
; 11702: 				int found = 0;
; 11703: 
; 11704: 				for(int i = 0; i < lpObj->m_wVpPShopPlayerCount; i++)

  00165	8b 8d 38 e7 ff
	ff		 mov	 ecx, DWORD PTR _i$165989[ebp]
  0016b	83 c7 04	 add	 edi, 4
  0016e	89 bd 34 e7 ff
	ff		 mov	 DWORD PTR tv829[ebp], edi
  00174	0f b7 bb a8 0e
	00 00		 movzx	 edi, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3752]
  0017b	41		 inc	 ecx
  0017c	89 8d 38 e7 ff
	ff		 mov	 DWORD PTR _i$165989[ebp], ecx
  00182	3b cf		 cmp	 ecx, edi
  00184	7c ca		 jl	 SHORT $LL50@PShop_View
$LN48@PShop_View:

; 11707: 					{
; 11708: 						found = 1;
; 11709: 						break;
; 11710: 					}
; 11711: 				}
; 11712: 
; 11713: 				if(found == 0)
; 11714: 				{
; 11715: 					lpMsgBody[iVpAddCount].btNumberL = SET_NUMBERL(WORD(lpObj->VpPlayer[n].number));

  00186	8a 0e		 mov	 cl, BYTE PTR [esi]

; 11716: 					lpMsgBody[iVpAddCount].btNumberH = SET_NUMBERH(WORD(lpObj->VpPlayer[n].number));
; 11717: 					memcpy(lpMsgBody[iVpAddCount].szPShopText,gObj[lpObj->VpPlayer[n].number].m_szPShopText,sizeof(gObj[lpObj->VpPlayer[n].number].m_szPShopText));

  00188	8b b5 3c e7 ff
	ff		 mov	 esi, DWORD PTR tv999[ebp]

; 11718: 					iVpAddCount++;

  0018e	ff 85 5c e7 ff
	ff		 inc	 DWORD PTR _iVpAddCount$[ebp]
  00194	88 48 01	 mov	 BYTE PTR [eax+1], cl
  00197	8b 8d 4c e7 ff
	ff		 mov	 ecx, DWORD PTR tv1096[ebp]
  0019d	c1 e9 08	 shr	 ecx, 8
  001a0	88 08		 mov	 BYTE PTR [eax], cl
  001a2	8b fa		 mov	 edi, edx
  001a4	83 c0 26	 add	 eax, 38			; 00000026H
  001a7	8d b6 2c 0d 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3372]
  001ad	b9 09 00 00 00	 mov	 ecx, 9
  001b2	83 c2 26	 add	 edx, 38			; 00000026H
  001b5	f3 a5		 rep movsd
  001b7	89 85 48 e7 ff
	ff		 mov	 DWORD PTR tv912[ebp], eax
  001bd	89 95 44 e7 ff
	ff		 mov	 DWORD PTR tv976[ebp], edx

; 11719: 				}
; 11720: 			}

  001c3	eb 21		 jmp	 SHORT $LN57@PShop_View
$LN29@PShop_View:

; 11721: 			else if(lpObj->m_wVpPShopPlayerCount == 0)

  001c5	66 85 c9	 test	 cx, cx

; 11722: 			{
; 11723: 				lpMsgBody[iVpAddCount].btNumberL = SET_NUMBERL(WORD(lpObj->VpPlayer[n].number));
; 11724: 				lpMsgBody[iVpAddCount].btNumberH = SET_NUMBERH(WORD(lpObj->VpPlayer[n].number));
; 11725: 				memcpy(lpMsgBody[iVpAddCount].szPShopText,gObj[lpObj->VpPlayer[n].number].m_szPShopText,sizeof(gObj[lpObj->VpPlayer[n].number].m_szPShopText));
; 11726: 				iVpAddCount++;
; 11727: 			}
; 11728: 			else

  001c8	74 bc		 je	 SHORT $LN48@PShop_View

; 11729: 			{
; 11730: 				LogAdd(LOG_BLACK, "[PShop] ERROR : lpObj->m_wVpPShopPlayerCount is OUT of BOUND : %d",lpObj->m_wVpPShopPlayerCount);

  001ca	51		 push	 ecx
  001cb	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@MINIMHLG@?$FLPShop?$FN?5ERROR?5?3?5lpObj?9?$DOm_wVpPSho@
  001d0	6a 00		 push	 0
  001d2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001d7	8b 95 44 e7 ff
	ff		 mov	 edx, DWORD PTR tv976[ebp]
  001dd	8b 85 48 e7 ff
	ff		 mov	 eax, DWORD PTR tv912[ebp]
  001e3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@PShop_View:
  001e6	8b b5 54 e7 ff
	ff		 mov	 esi, DWORD PTR tv978[ebp]
$LN32@PShop_View:

; 11691: 	}
; 11692: 
; 11693: 	for(int n = 0; n < MAX_VIEWPORT; n++)

  001ec	83 c6 0c	 add	 esi, 12			; 0000000cH
  001ef	ff 8d 40 e7 ff
	ff		 dec	 DWORD PTR tv313[ebp]
  001f5	89 b5 54 e7 ff
	ff		 mov	 DWORD PTR tv978[ebp], esi
  001fb	0f 85 cf fe ff
	ff		 jne	 $LL33@PShop_View

; 11731: 			}
; 11732: 		}
; 11733: 	}
; 11734: 
; 11735: 	memset(lpObj->m_iVpPShopPlayer,0x00,sizeof(lpObj->m_iVpPShopPlayer));

  00201	68 2c 01 00 00	 push	 300			; 0000012cH
  00206	8d bb 7c 0d 00
	00		 lea	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3452]
  0020c	6a 00		 push	 0
  0020e	57		 push	 edi
  0020f	e8 00 00 00 00	 call	 _memset

; 11736: 	lpObj->m_wVpPShopPlayerCount = 0;
; 11737: 
; 11738: 	if(iVpOpenCount > 0 && iVpOpenCount <= MAX_VIEWPORT)

  00214	8b 8d 58 e7 ff
	ff		 mov	 ecx, DWORD PTR _iVpOpenCount$[ebp]
  0021a	33 c0		 xor	 eax, eax
  0021c	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  0021f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00222	66 89 83 a8 0e
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3752], ax
  00229	83 fa 4a	 cmp	 edx, 74			; 0000004aH
  0022c	77 1b		 ja	 SHORT $LN20@PShop_View

; 11739: 	{
; 11740: 		for(int n = 0; n < iVpOpenCount; n++)

  0022e	85 c9		 test	 ecx, ecx
  00230	7e 0e		 jle	 SHORT $LN19@PShop_View
  00232	8d b5 60 e7 ff
	ff		 lea	 esi, DWORD PTR _iPShopOpenIndex$[ebp]
  00238	f3 a5		 rep movsd
  0023a	8b 8d 58 e7 ff
	ff		 mov	 ecx, DWORD PTR _iVpOpenCount$[ebp]
$LN19@PShop_View:

; 11741: 		{
; 11742: 			lpObj->m_iVpPShopPlayer[n] = iPShopOpenIndex[n];
; 11743: 		}
; 11744: 		lpObj->m_wVpPShopPlayerCount = iVpOpenCount;

  00240	66 89 8b a8 0e
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3752], cx
  00247	eb 14		 jmp	 SHORT $LN15@PShop_View
$LN20@PShop_View:

; 11745: 	}
; 11746: 	else if(iVpOpenCount != 0)

  00249	85 c9		 test	 ecx, ecx
  0024b	74 10		 je	 SHORT $LN15@PShop_View

; 11747: 	{
; 11748: 		LogAdd(LOG_BLACK, "[PShop] ERROR : iVpOpenCount is OUT of BOUND: %d",iVpOpenCount);

  0024d	51		 push	 ecx
  0024e	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@CHPPJFL@?$FLPShop?$FN?5ERROR?5?3?5iVpOpenCount?5is?5@
  00253	6a 00		 push	 0
  00255	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0025a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@PShop_View:

; 11749: 	}
; 11750: 
; 11751: 	if(iVpAddCount > 0 && iVpAddCount <= MAX_VIEWPORT)

  0025d	8b 85 5c e7 ff
	ff		 mov	 eax, DWORD PTR _iVpAddCount$[ebp]
  00263	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00266	83 f9 4a	 cmp	 ecx, 74			; 0000004aH
  00269	77 49		 ja	 SHORT $LN14@PShop_View

; 11752: 	{
; 11753: 		lpMsg->btCount = iVpAddCount;

  0026b	88 85 91 e8 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+5], al

; 11754: 		PHeadSubSetW((unsigned char *)lpMsg,0x3F,0,sizeof(PMSG_ANS_PSHOP_VIEWPORT_NOTIFY)+sizeof(PMSG_PSHOP_VIEWPORT_NOTIFY)*iVpAddCount);

  00271	6b c0 26	 imul	 eax, 38			; 00000026H
  00274	83 c0 06	 add	 eax, 6
  00277	50		 push	 eax
  00278	6a 00		 push	 0
  0027a	8d 95 8c e8 ff
	ff		 lea	 edx, DWORD PTR _cBUFFER$[ebp]
  00280	6a 3f		 push	 63			; 0000003fH
  00282	52		 push	 edx
  00283	e8 00 00 00 00	 call	 ?PHeadSubSetW@@YAXPAEEEH@Z ; PHeadSubSetW

; 11755: 		DataSend(aIndex,(unsigned char *)lpMsg,((lpMsg->h.sizeL & 0xFF)& 0xFF | ((lpMsg->h.sizeH & 0xFF) & 0xFF) << 8) & 0xFFFF);

  00288	0f b6 85 8d e8
	ff ff		 movzx	 eax, BYTE PTR _cBUFFER$[ebp+1]
  0028f	0f b6 8d 8e e8
	ff ff		 movzx	 ecx, BYTE PTR _cBUFFER$[ebp+2]
  00296	8b b5 50 e7 ff
	ff		 mov	 esi, DWORD PTR tv544[ebp]
  0029c	c1 e0 08	 shl	 eax, 8
  0029f	0b c1		 or	 eax, ecx
  002a1	50		 push	 eax
  002a2	8d 95 8c e8 ff
	ff		 lea	 edx, DWORD PTR _cBUFFER$[ebp]
  002a8	52		 push	 edx
  002a9	56		 push	 esi
  002aa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002af	83 c4 1c	 add	 esp, 28			; 0000001cH
  002b2	eb 1a		 jmp	 SHORT $LN12@PShop_View
$LN14@PShop_View:

; 11756: 	}
; 11757: 	else if(iVpAddCount != 0)

  002b4	85 c0		 test	 eax, eax
  002b6	74 10		 je	 SHORT $LN53@PShop_View

; 11758: 	{
; 11759: 		LogAdd(LOG_BLACK, "[PShop] ERROR : iVpAddCount is OUT of BOUND: %d",iVpAddCount);

  002b8	50		 push	 eax
  002b9	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@GGNIPOJP@?$FLPShop?$FN?5ERROR?5?3?5iVpAddCount?5is?5O@
  002be	6a 00		 push	 0
  002c0	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  002c5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN53@PShop_View:
  002c8	8b b5 50 e7 ff
	ff		 mov	 esi, DWORD PTR tv544[ebp]
$LN12@PShop_View:

; 11760: 	}
; 11761: 
; 11762: 	if(gObj[aIndex].m_bPShopWantDeal == 1)

  002ce	80 bb 50 0d 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3408], 1
  002d5	0f 85 08 01 00
	00		 jne	 $LN54@PShop_View

; 11763: 	{
; 11764: 		if(gObjIsConnected(gObj[aIndex].m_iPShopDealerIndex) != 0)

  002db	8b 8b 54 0d 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3412]
  002e1	51		 push	 ecx
  002e2	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  002e7	83 c4 04	 add	 esp, 4
  002ea	85 c0		 test	 eax, eax
  002ec	0f 84 bb 00 00
	00		 je	 $LN10@PShop_View

; 11765: 		{
; 11766: 			if(gObj[gObj[aIndex].m_iPShopDealerIndex].Type == OBJ_USER)

  002f2	8b c1		 mov	 eax, ecx
  002f4	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  002fa	66 83 b8 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 1
  00302	75 7a		 jne	 SHORT $LN9@PShop_View

; 11767: 			{
; 11768: 				if(gObj[gObj[aIndex].m_iPShopDealerIndex].m_bPShopOpen == 0)

  00304	80 b8 28 0d 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3368], 0

; 11769: 				{
; 11770: 					gObj[aIndex].m_bPShopWantDeal = 0;
; 11771: 					gObj[aIndex].m_iPShopDealerIndex = -1;
; 11772: 					memset(gObj[aIndex].m_szPShopDealerName,0,sizeof(gObj[aIndex].m_szPShopDealerName));
; 11773: 
; 11774: 					CGPShopAnsDealerClosedShop(aIndex,gObj[aIndex].m_iPShopDealerIndex);

  0030b	0f 84 9c 00 00
	00		 je	 $LN10@PShop_View

; 11775: 				}
; 11776: 				else if(gObj[gObj[aIndex].m_iPShopDealerIndex].CloseCount >= 0 || gObj[aIndex].CloseCount >= 0)

  00311	80 b8 07 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+7], 0
  00318	7d 35		 jge	 SHORT $LN5@PShop_View
  0031a	80 bb 07 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+7], 0
  00321	7d 2c		 jge	 SHORT $LN5@PShop_View

; 11783: 				}
; 11784: 				else if(gObj[gObj[aIndex].m_iPShopDealerIndex].m_bPShopItemChange == 1)

  00323	80 b8 2a 0d 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3370], 1
  0032a	0f 85 b3 00 00
	00		 jne	 $LN54@PShop_View

; 11785: 				{
; 11786: 					CGPShopAnsBuyList(aIndex,gObj[aIndex].m_iPShopDealerIndex,1,1);

  00330	6a 01		 push	 1
  00332	6a 01		 push	 1
  00334	51		 push	 ecx
  00335	56		 push	 esi
  00336	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  0033b	83 c4 10	 add	 esp, 16			; 00000010H
  0033e	5f		 pop	 edi
  0033f	5e		 pop	 esi
  00340	5b		 pop	 ebx

; 11805: 		}
; 11806: 	}
; 11807: }

  00341	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00344	33 cd		 xor	 ecx, ebp
  00346	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034b	8b e5		 mov	 esp, ebp
  0034d	5d		 pop	 ebp
  0034e	c3		 ret	 0
$LN5@PShop_View:

; 11777: 				{
; 11778: 					gObj[aIndex].m_bPShopWantDeal = 0;
; 11779: 					gObj[aIndex].m_iPShopDealerIndex = -1;

  0034f	c7 83 54 0d 00
	00 ff ff ff ff	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3412], -1

; 11780: 					memset(gObj[aIndex].m_szPShopDealerName,0,sizeof(gObj[aIndex].m_szPShopDealerName));

  00359	33 c0		 xor	 eax, eax
  0035b	c6 83 50 0d 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3408], 0
  00362	89 83 58 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3416], eax
  00368	89 83 5c 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3420], eax
  0036e	66 89 83 60 0d
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3424], ax

; 11781: 
; 11782: 					CGPShopAnsDealerClosedShop(aIndex,gObj[aIndex].m_iPShopDealerIndex);

  00375	8b 8b 54 0d 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3412]
  0037b	51		 push	 ecx

; 11787: 				}
; 11788: 			}
; 11789: 			else

  0037c	eb 5c		 jmp	 SHORT $LN58@PShop_View
$LN9@PShop_View:

; 11790: 			{
; 11791: 				gObj[aIndex].m_bPShopWantDeal = 0;
; 11792: 				gObj[aIndex].m_iPShopDealerIndex = -1;

  0037e	c7 83 54 0d 00
	00 ff ff ff ff	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3412], -1

; 11793: 				memset(gObj[aIndex].m_szPShopDealerName,0,sizeof(gObj[aIndex].m_szPShopDealerName));

  00388	33 c0		 xor	 eax, eax
  0038a	c6 83 50 0d 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3408], 0
  00391	89 83 58 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3416], eax
  00397	89 83 5c 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3420], eax
  0039d	66 89 83 60 0d
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3424], ax

; 11794: 
; 11795: 				CGPShopAnsDealerClosedShop(aIndex,gObj[aIndex].m_iPShopDealerIndex);

  003a4	8b 93 54 0d 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3412]
  003aa	52		 push	 edx

; 11796: 			}
; 11797: 		}
; 11798: 		else

  003ab	eb 2d		 jmp	 SHORT $LN58@PShop_View
$LN10@PShop_View:

; 11799: 		{
; 11800: 			gObj[aIndex].m_bPShopWantDeal = 0;
; 11801: 			gObj[aIndex].m_iPShopDealerIndex = -1;
; 11802: 			memset(gObj[aIndex].m_szPShopDealerName,0,sizeof(gObj[aIndex].m_szPShopDealerName));

  003ad	33 c0		 xor	 eax, eax
  003af	c7 83 54 0d 00
	00 ff ff ff ff	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3412], -1
  003b9	c6 83 50 0d 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3408], 0
  003c0	89 83 58 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3416], eax
  003c6	89 83 5c 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3420], eax
  003cc	66 89 83 60 0d
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3424], ax

; 11803: 
; 11804: 			CGPShopAnsDealerClosedShop(aIndex,gObj[aIndex].m_iPShopDealerIndex);

  003d3	8b 83 54 0d 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3412]
  003d9	50		 push	 eax
$LN58@PShop_View:
  003da	56		 push	 esi
  003db	e8 00 00 00 00	 call	 ?CGPShopAnsDealerClosedShop@@YAXHH@Z ; CGPShopAnsDealerClosedShop
  003e0	83 c4 08	 add	 esp, 8
$LN54@PShop_View:
  003e3	5f		 pop	 edi
  003e4	5e		 pop	 esi
$LN1@PShop_View:

; 11805: 		}
; 11806: 	}
; 11807: }

  003e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003e8	33 cd		 xor	 ecx, ebp
  003ea	5b		 pop	 ebx
  003eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f0	8b e5		 mov	 esp, ebp
  003f2	5d		 pop	 ebp
  003f3	c3		 ret	 0
?PShop_ViewportListRegenarate@@YAXF@Z ENDP		; PShop_ViewportListRegenarate
_TEXT	ENDS
PUBLIC	?PShop_CheckInventoryEmpty@@YA_NF@Z		; PShop_CheckInventoryEmpty
; Function compile flags: /Ogtp
;	COMDAT ?PShop_CheckInventoryEmpty@@YA_NF@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 2
?PShop_CheckInventoryEmpty@@YA_NF@Z PROC		; PShop_CheckInventoryEmpty, COMDAT

; 11810: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 11811: 	LPOBJ lpObj = &gObj[aIndex];

  00005	0f bf 7d 08	 movsx	 edi, WORD PTR _aIndex$[ebp]
  00009	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0000f	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	be e0 31 00 00	 mov	 esi, 12768		; 000031e0H
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL4@PShop_Chec:

; 11814: 	{
; 11815: 		if(lpObj->Inventory1[i].IsItem() == 1)

  00020	8b 8f 9c 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3228]
  00026	03 ce		 add	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	74 14		 je	 SHORT $LN8@PShop_Chec

; 11812: 
; 11813: 	for(int i = MAIN_INVENTORY_SIZE; i < INVENTORY_SIZE; i++)

  00032	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00038	81 fe e0 46 00
	00		 cmp	 esi, 18144		; 000046e0H
  0003e	7c e0		 jl	 SHORT $LL4@PShop_Chec

; 11818: 		}
; 11819: 	}
; 11820: 	return true;

  00040	5f		 pop	 edi
  00041	b0 01		 mov	 al, 1
  00043	5e		 pop	 esi

; 11821: }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN8@PShop_Chec:
  00046	5f		 pop	 edi

; 11816: 		{
; 11817: 			return false;

  00047	32 c0		 xor	 al, al
  00049	5e		 pop	 esi

; 11821: }

  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?PShop_CheckInventoryEmpty@@YA_NF@Z ENDP		; PShop_CheckInventoryEmpty
_TEXT	ENDS
PUBLIC	__real@3fa2f1aa00000000
PUBLIC	?gObjManaPotionFill@@YAXPAUOBJECTSTRUCT@@@Z	; gObjManaPotionFill
;	COMDAT __real@3fa2f1aa00000000
CONST	SEGMENT
__real@3fa2f1aa00000000 DQ 03fa2f1aa00000000r	; 0.037
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjManaPotionFill@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_tmana$ = 8						; size = 4
_lpObj$ = 8						; size = 4
?gObjManaPotionFill@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjManaPotionFill, COMDAT

; 12755: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 12756: 	lpObj->m_ManaFillCount++;

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	fe 86 45 02 00
	00		 inc	 BYTE PTR [esi+581]

; 12757: 
; 12758: 	float tmana;
; 12759: 	int ChangeMana = 0;

  0000d	33 c9		 xor	 ecx, ecx

; 12760: 
; 12761: 	if(lpObj->m_ManaFillCount > 2)

  0000f	80 be 45 02 00
	00 02		 cmp	 BYTE PTR [esi+581], 2
  00016	0f 8e 38 01 00
	00		 jle	 $LN1@gObjManaPo

; 12762: 	{
; 12763: 		lpObj->m_ManaFillCount = 0;
; 12764: 
; 12765: 		int BP,AddBP;
; 12766: 		BYTE MapAttr;
; 12767: 		int rBP,CurBP;
; 12768: 
; 12769: 		if(lpObj->MaxMana + lpObj->AddMana > lpObj->Mana)

  0001c	db 86 10 01 00
	00		 fild	 DWORD PTR [esi+272]
  00022	88 8e 45 02 00
	00		 mov	 BYTE PTR [esi+581], cl
  00028	d8 86 d4 00 00
	00		 fadd	 DWORD PTR [esi+212]
  0002e	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  00034	d8 d9		 fcomp	 ST(1)
  00036	df e0		 fnstsw	 ax
  00038	f6 c4 05	 test	 ah, 5
  0003b	7a 42		 jp	 SHORT $LN17@gObjManaPo

; 12770: 		{
; 12771: 			tmana = lpObj->Mana;
; 12772: 			tmana += (lpObj->MaxMana + lpObj->AddMana)*0.037f;

  0003d	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fa2f1aa00000000
  00043	d8 c9		 fmul	 ST(0), ST(1)
  00045	d8 86 d0 00 00
	00		 fadd	 DWORD PTR [esi+208]
  0004b	d9 5d 08	 fstp	 DWORD PTR _tmana$[ebp]

; 12773: 
; 12774: 			if(lpObj->MaxMana + lpObj->AddMana < tmana)

  0004e	d9 45 08	 fld	 DWORD PTR _tmana$[ebp]
  00051	d8 d9		 fcomp	 ST(1)
  00053	df e0		 fnstsw	 ax
  00055	f6 c4 41	 test	 ah, 65			; 00000041H
  00058	75 13		 jne	 SHORT $LN20@gObjManaPo

; 12775: 			{
; 12776: 				tmana = lpObj->MaxMana + lpObj->AddMana;

  0005a	d9 5d 08	 fstp	 DWORD PTR _tmana$[ebp]

; 12777: 			}
; 12778: 
; 12779: 			lpObj->Mana = tmana;
; 12780: 			ChangeMana = 1;

  0005d	b9 01 00 00 00	 mov	 ecx, 1
  00062	d9 45 08	 fld	 DWORD PTR _tmana$[ebp]
  00065	d9 9e d0 00 00
	00		 fstp	 DWORD PTR [esi+208]
  0006b	eb 14		 jmp	 SHORT $LN10@gObjManaPo
$LN20@gObjManaPo:

; 12775: 			{
; 12776: 				tmana = lpObj->MaxMana + lpObj->AddMana;

  0006d	dd d8		 fstp	 ST(0)

; 12777: 			}
; 12778: 
; 12779: 			lpObj->Mana = tmana;
; 12780: 			ChangeMana = 1;

  0006f	b9 01 00 00 00	 mov	 ecx, 1
  00074	d9 45 08	 fld	 DWORD PTR _tmana$[ebp]
  00077	d9 9e d0 00 00
	00		 fstp	 DWORD PTR [esi+208]
  0007d	eb 02		 jmp	 SHORT $LN10@gObjManaPo
$LN17@gObjManaPo:
  0007f	dd d8		 fstp	 ST(0)
$LN10@gObjManaPo:
  00081	57		 push	 edi

; 12781: 		}
; 12782: 
; 12783: 		BP = lpObj->MaxBP + lpObj->AddBP;

  00082	8b be f0 00 00
	00		 mov	 edi, DWORD PTR [esi+240]
  00088	03 be ec 00 00
	00		 add	 edi, DWORD PTR [esi+236]

; 12784: 
; 12785: 		if(lpObj->BP < BP)

  0008e	39 be e8 00 00
	00		 cmp	 DWORD PTR [esi+232], edi
  00094	0f 8d 90 00 00
	00		 jge	 $LN8@gObjManaPo

; 12786: 		{
; 12787: 			MapAttr = MapC[lpObj->MapNumber].GetAttr((short &)lpObj->X,(short &)lpObj->Y);
; 12788: 			rBP = 2;
; 12789: 
; 12790: 			if((MapAttr & 1) != 0)

  0009a	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  000a1	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  000a8	53		 push	 ebx
  000a9	50		 push	 eax
  000aa	51		 push	 ecx
  000ab	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  000b2	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  000b8	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000be	bb 02 00 00 00	 mov	 ebx, 2
  000c3	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000c8	a8 01		 test	 al, 1
  000ca	74 05		 je	 SHORT $LN7@gObjManaPo

; 12791: 			{
; 12792: 				rBP = 5;

  000cc	bb 05 00 00 00	 mov	 ebx, 5
$LN7@gObjManaPo:

; 12793: 			}
; 12794: 
; 12795: 			if(lpObj->Class == CLASS_KNIGHT)

  000d1	66 83 be 98 00
	00 00 01	 cmp	 WORD PTR [esi+152], 1

; 12796: 			{
; 12797: 				AddBP = rBP +(BP * 5 / 100);

  000d9	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000de	8d 0c bf	 lea	 ecx, DWORD PTR [edi+edi*4]
  000e1	74 03		 je	 SHORT $LN22@gObjManaPo

; 12798: 			}
; 12799: 			else
; 12800: 			{
; 12801: 				AddBP = rBP +(BP * 3 / 100);

  000e3	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
$LN22@gObjManaPo:
  000e6	f7 e9		 imul	 ecx
  000e8	c1 fa 05	 sar	 edx, 5
  000eb	8b c2		 mov	 eax, edx
  000ed	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000f0	03 c2		 add	 eax, edx
  000f2	03 c3		 add	 eax, ebx

; 12802: 			}
; 12803: 
; 12804: 			if(lpObj->m_iPotionSoulTime > 0)

  000f4	83 be f8 14 00
	00 00		 cmp	 DWORD PTR [esi+5368], 0
  000fb	5b		 pop	 ebx
  000fc	7e 03		 jle	 SHORT $LN4@gObjManaPo

; 12805: 			{
; 12806: 				AddBP += 8;

  000fe	83 c0 08	 add	 eax, 8
$LN4@gObjManaPo:

; 12807: 			}
; 12808: 
; 12809: 			AddBP += lpObj->SetOpIncAGValue;

  00101	0f bf 96 6a 0f
	00 00		 movsx	 edx, WORD PTR [esi+3946]
  00108	03 c2		 add	 eax, edx

; 12810: 
; 12811: 			if(AddBP < 1)

  0010a	83 f8 01	 cmp	 eax, 1
  0010d	7d 05		 jge	 SHORT $LN3@gObjManaPo

; 12812: 			{
; 12813: 				AddBP = 1;

  0010f	b8 01 00 00 00	 mov	 eax, 1
$LN3@gObjManaPo:

; 12814: 			}
; 12815: 
; 12816: 			CurBP = lpObj->BP;
; 12817: 			CurBP += AddBP;

  00114	8b 8e e8 00 00
	00		 mov	 ecx, DWORD PTR [esi+232]
  0011a	03 c8		 add	 ecx, eax

; 12818: 
; 12819: 			if(CurBP > BP)

  0011c	3b cf		 cmp	 ecx, edi
  0011e	7e 02		 jle	 SHORT $LN2@gObjManaPo

; 12820: 			{
; 12821: 				CurBP = BP;

  00120	8b cf		 mov	 ecx, edi
$LN2@gObjManaPo:

; 12822: 			}
; 12823: 
; 12824: 			lpObj->BP = CurBP;

  00122	89 8e e8 00 00
	00		 mov	 DWORD PTR [esi+232], ecx

; 12825: 
; 12826: 			ChangeMana = 1;
; 12827: 		}
; 12828: 
; 12829: 		if(ChangeMana != 0)

  00128	eb 04		 jmp	 SHORT $LN14@gObjManaPo
$LN8@gObjManaPo:
  0012a	85 c9		 test	 ecx, ecx
  0012c	74 25		 je	 SHORT $LN15@gObjManaPo
$LN14@gObjManaPo:

; 12830: 		{
; 12831: 			GCManaSend(lpObj->m_Index,lpObj->Mana,255,0,lpObj->BP);

  0012e	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR [esi+232]
  00134	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  0013a	50		 push	 eax
  0013b	6a 00		 push	 0
  0013d	68 ff 00 00 00	 push	 255			; 000000ffH
  00142	e8 00 00 00 00	 call	 __ftol2_sse
  00147	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00149	50		 push	 eax
  0014a	51		 push	 ecx
  0014b	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  00150	83 c4 14	 add	 esp, 20			; 00000014H
$LN15@gObjManaPo:
  00153	5f		 pop	 edi
$LN1@gObjManaPo:
  00154	5e		 pop	 esi

; 12832: 		}
; 12833: 	}
; 12834: }

  00155	5d		 pop	 ebp
  00156	c3		 ret	 0
?gObjManaPotionFill@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjManaPotionFill
_TEXT	ENDS
PUBLIC	__real@4039000000000000
PUBLIC	__real@404b000000000000
PUBLIC	__real@4041000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@4059000000000000
PUBLIC	?gObjRestPotionFill@@YAXPAUOBJECTSTRUCT@@@Z	; gObjRestPotionFill
;	COMDAT __real@4039000000000000
CONST	SEGMENT
__real@4039000000000000 DQ 04039000000000000r	; 25
CONST	ENDS
;	COMDAT __real@404b000000000000
CONST	SEGMENT
__real@404b000000000000 DQ 0404b000000000000r	; 54
CONST	ENDS
;	COMDAT __real@4041000000000000
CONST	SEGMENT
__real@4041000000000000 DQ 04041000000000000r	; 34
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjRestPotionFill@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_percent$166323 = -4					; size = 4
tv756 = 8						; size = 4
tv754 = 8						; size = 4
tv653 = 8						; size = 4
_cur$166350 = 8						; size = 4
_tlife$166337 = 8					; size = 4
_percent$166336 = 8					; size = 4
_tmana$166322 = 8					; size = 4
_tlife$166321 = 8					; size = 4
_lpObj$ = 8						; size = 4
?gObjRestPotionFill@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjRestPotionFill, COMDAT

; 12837: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 12838: 	if(lpObj->m_Rest != 0)

  00004	d9 ee		 fldz
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000a	80 be c1 01 00
	00 00		 cmp	 BYTE PTR [esi+449], 0
  00011	0f 84 8f 01 00
	00		 je	 $LN38@gObjRestPo

; 12839: 	{
; 12840: 		float tlife;
; 12841: 		float tmana;
; 12842: 		int percent = 3;
; 12843: 		lpObj->m_LifeFillCount++;

  00017	fe 86 46 02 00
	00		 inc	 BYTE PTR [esi+582]

; 12844: 
; 12845: 		if(lpObj->m_LifeFillCount > 4)

  0001d	80 be 46 02 00
	00 04		 cmp	 BYTE PTR [esi+582], 4
  00024	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _percent$166323[ebp], 3
  0002b	0f 8e 27 03 00
	00		 jle	 $LN35@gObjRestPo

; 12846: 		{
; 12847: 			lpObj->m_LifeFillCount = 0;
; 12848: 
; 12849: 			tlife = lpObj->Life;
; 12850: 
; 12851: 			if(lpObj->pInventory[10].IsItem() == 1)

  00031	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00037	dd d8		 fstp	 ST(0)
  00039	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  0003f	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
  00045	d9 5d 08	 fstp	 DWORD PTR _tlife$166321[ebp]
  00048	c6 86 46 02 00
	00 00		 mov	 BYTE PTR [esi+582], 0
  0004f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem

; 12852: 			{
; 12853: 				if(lpObj->pInventory[10].m_Option3 != 0 && lpObj->pInventory[10].m_Type != ITEMGET(13,24))

  00054	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0005a	83 f8 01	 cmp	 eax, 1
  0005d	75 18		 jne	 SHORT $LN29@gObjRestPo
  0005f	8a 81 0a 07 00
	00		 mov	 al, BYTE PTR [ecx+1802]
  00065	84 c0		 test	 al, al
  00067	74 73		 je	 SHORT $LN22@gObjRestPo
  00069	ba 18 1a 00 00	 mov	 edx, 6680		; 00001a18H
  0006e	66 39 91 96 06
	00 00		 cmp	 WORD PTR [ecx+1686], dx

; 12854: 				{
; 12855: 					percent += lpObj->pInventory[10].m_Option3;
; 12856: 				}
; 12857: 			}

  00075	eb 5a		 jmp	 SHORT $LN77@gObjRestPo
$LN29@gObjRestPo:

; 12858: 			else if(lpObj->pInventory[11].IsItem() == 1)

  00077	81 c1 38 07 00
	00		 add	 ecx, 1848		; 00000738H
  0007d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem

; 12859: 			{
; 12860: 				if(lpObj->pInventory[11].m_Option3 != 0 && lpObj->pInventory[11].m_Type != ITEMGET(13,24))

  00082	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00088	83 f8 01	 cmp	 eax, 1
  0008b	75 18		 jne	 SHORT $LN26@gObjRestPo
  0008d	8a 81 b2 07 00
	00		 mov	 al, BYTE PTR [ecx+1970]
  00093	84 c0		 test	 al, al
  00095	74 45		 je	 SHORT $LN22@gObjRestPo
  00097	ba 18 1a 00 00	 mov	 edx, 6680		; 00001a18H
  0009c	66 39 91 3e 07
	00 00		 cmp	 WORD PTR [ecx+1854], dx

; 12861: 				{
; 12862: 					percent += lpObj->pInventory[11].m_Option3;
; 12863: 				}
; 12864: 			}

  000a3	eb 2c		 jmp	 SHORT $LN77@gObjRestPo
$LN26@gObjRestPo:

; 12865: 			else if(lpObj->pInventory[9].IsItem() == 1)

  000a5	81 c1 e8 05 00
	00		 add	 ecx, 1512		; 000005e8H
  000ab	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000b0	83 f8 01	 cmp	 eax, 1
  000b3	75 27		 jne	 SHORT $LN22@gObjRestPo

; 12866: 			{
; 12867: 				if(lpObj->pInventory[9].m_Option3 != 0 && lpObj->pInventory[9].m_Type != ITEMGET(13,28))

  000b5	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  000bb	8a 81 62 06 00
	00		 mov	 al, BYTE PTR [ecx+1634]
  000c1	84 c0		 test	 al, al
  000c3	74 17		 je	 SHORT $LN22@gObjRestPo
  000c5	ba 1c 1a 00 00	 mov	 edx, 6684		; 00001a1cH
  000ca	66 39 91 ee 05
	00 00		 cmp	 WORD PTR [ecx+1518], dx
$LN77@gObjRestPo:
  000d1	74 09		 je	 SHORT $LN22@gObjRestPo

; 12868: 				{
; 12869: 					percent += lpObj->pInventory[9].m_Option3;

  000d3	0f b6 c0	 movzx	 eax, al
  000d6	83 c0 03	 add	 eax, 3
  000d9	89 45 fc	 mov	 DWORD PTR _percent$166323[ebp], eax
$LN22@gObjRestPo:

; 12870: 				}
; 12871: 			}
; 12872: 
; 12873: 			tlife += (lpObj->MaxLife + lpObj->AddLife)*percent / 100.0f;

  000dc	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  000e2	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  000e8	db 45 fc	 fild	 DWORD PTR _percent$166323[ebp]
  000eb	d8 c9		 fmul	 ST(0), ST(1)
  000ed	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  000f3	d8 45 08	 fadd	 DWORD PTR _tlife$166321[ebp]
  000f6	d9 5d 08	 fstp	 DWORD PTR _tlife$166321[ebp]

; 12874: 			
; 12875: 			if((lpObj->MaxLife + lpObj->AddLife) < tlife)

  000f9	d9 45 08	 fld	 DWORD PTR _tlife$166321[ebp]
  000fc	d8 d1		 fcom	 ST(1)
  000fe	df e0		 fnstsw	 ax
  00100	f6 c4 41	 test	 ah, 65			; 00000041H
  00103	75 0a		 jne	 SHORT $LN62@gObjRestPo

; 12876: 			{
; 12877: 				tlife = lpObj->MaxLife + lpObj->AddLife;

  00105	dd d8		 fstp	 ST(0)
  00107	d9 5d 08	 fstp	 DWORD PTR _tlife$166321[ebp]
  0010a	d9 45 08	 fld	 DWORD PTR _tlife$166321[ebp]
  0010d	eb 02		 jmp	 SHORT $LN21@gObjRestPo
$LN62@gObjRestPo:
  0010f	dd d9		 fstp	 ST(1)
$LN21@gObjRestPo:

; 12878: 			}
; 12879: 
; 12880: 		lpObj->Life = tlife;
; 12881: 
; 12882: 		GCReFillSend(lpObj->m_Index,lpObj->Life,255,0);

  00111	6a 00		 push	 0
  00113	d9 96 bc 00 00
	00		 fst	 DWORD PTR [esi+188]
  00119	68 ff 00 00 00	 push	 255			; 000000ffH
  0011e	e8 00 00 00 00	 call	 __ftol2_sse
  00123	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00125	50		 push	 eax
  00126	51		 push	 ecx
  00127	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend

; 12883: 
; 12884: 		tmana = lpObj->Mana + lpObj->AddMana;
; 12885: 		tmana += (lpObj->MaxMana + lpObj->AddMana) * 3.0f / 100.0f;

  0012c	db 86 10 01 00
	00		 fild	 DWORD PTR [esi+272]
  00132	83 c4 10	 add	 esp, 16			; 00000010H
  00135	d9 5d 08	 fstp	 DWORD PTR tv653[ebp]
  00138	d9 86 d4 00 00
	00		 fld	 DWORD PTR [esi+212]
  0013e	d9 45 08	 fld	 DWORD PTR tv653[ebp]
  00141	d9 c0		 fld	 ST(0)
  00143	de c2		 faddp	 ST(2), ST(0)
  00145	d8 86 d0 00 00
	00		 fadd	 DWORD PTR [esi+208]
  0014b	d9 5d 08	 fstp	 DWORD PTR tv754[ebp]
  0014e	d9 45 08	 fld	 DWORD PTR tv754[ebp]
  00151	d9 c1		 fld	 ST(1)
  00153	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4008000000000000
  00159	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  0015f	de c1		 faddp	 ST(1), ST(0)
  00161	d9 5d 08	 fstp	 DWORD PTR _tmana$166322[ebp]

; 12886: 		
; 12887: 		if((lpObj->MaxMana + lpObj->AddMana) < tmana)

  00164	d9 45 08	 fld	 DWORD PTR _tmana$166322[ebp]
  00167	d8 d1		 fcom	 ST(1)
  00169	df e0		 fnstsw	 ax
  0016b	f6 c4 41	 test	 ah, 65			; 00000041H
  0016e	75 0a		 jne	 SHORT $LN65@gObjRestPo

; 12888: 		{
; 12889: 			tmana = lpObj->MaxMana + lpObj->AddMana;

  00170	dd d8		 fstp	 ST(0)
  00172	d9 5d 08	 fstp	 DWORD PTR _tmana$166322[ebp]
  00175	d9 45 08	 fld	 DWORD PTR _tmana$166322[ebp]
  00178	eb 02		 jmp	 SHORT $LN20@gObjRestPo
$LN65@gObjRestPo:
  0017a	dd d9		 fstp	 ST(1)
$LN20@gObjRestPo:

; 12890: 		}
; 12891: 
; 12892: 		lpObj->Mana = tmana;
; 12893: 
; 12894: 		GCManaSend(lpObj->m_Index,lpObj->Mana,255,0,lpObj->BP);

  0017c	8b 96 e8 00 00
	00		 mov	 edx, DWORD PTR [esi+232]
  00182	d9 96 d0 00 00
	00		 fst	 DWORD PTR [esi+208]
  00188	52		 push	 edx
  00189	6a 00		 push	 0
  0018b	68 ff 00 00 00	 push	 255			; 000000ffH
  00190	e8 00 00 00 00	 call	 __ftol2_sse
  00195	50		 push	 eax
  00196	8b 06		 mov	 eax, DWORD PTR [esi]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  0019e	83 c4 14	 add	 esp, 20			; 00000014H

; 12895: 		}
; 12896: 	}
; 12897: 	else

  001a1	e9 b0 01 00 00	 jmp	 $LN78@gObjRestPo
$LN38@gObjRestPo:

; 12898: 	{
; 12899: 		int percent = 0;
; 12900: 		float tlife;
; 12901: 		if(lpObj->pInventory[10].IsItem() == 1)

  001a6	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  001ac	dd d8		 fstp	 ST(0)
  001ae	57		 push	 edi
  001af	33 ff		 xor	 edi, edi
  001b1	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
  001b7	89 7d 08	 mov	 DWORD PTR _percent$166336[ebp], edi
  001ba	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  001bf	83 f8 01	 cmp	 eax, 1
  001c2	75 35		 jne	 SHORT $LN17@gObjRestPo

; 12902: 		{
; 12903: 			if(lpObj->pInventory[10].m_Option3 != 0 && lpObj->pInventory[10].m_Durability != 0.0f && lpObj->pInventory[10].m_Type != ITEMGET(13,24))

  001c4	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  001ca	8a 91 0a 07 00
	00		 mov	 dl, BYTE PTR [ecx+1802]
  001d0	84 d2		 test	 dl, dl
  001d2	74 25		 je	 SHORT $LN17@gObjRestPo
  001d4	d9 81 b4 06 00
	00		 fld	 DWORD PTR [ecx+1716]
  001da	d9 ee		 fldz
  001dc	da e9		 fucompp
  001de	df e0		 fnstsw	 ax
  001e0	f6 c4 44	 test	 ah, 68			; 00000044H
  001e3	7b 14		 jnp	 SHORT $LN17@gObjRestPo
  001e5	b8 18 1a 00 00	 mov	 eax, 6680		; 00001a18H
  001ea	66 39 81 96 06
	00 00		 cmp	 WORD PTR [ecx+1686], ax
  001f1	74 06		 je	 SHORT $LN17@gObjRestPo

; 12904: 			{
; 12905: 				percent += lpObj->pInventory[10].m_Option3;

  001f3	0f b6 fa	 movzx	 edi, dl
  001f6	89 7d 08	 mov	 DWORD PTR _percent$166336[ebp], edi
$LN17@gObjRestPo:

; 12906: 			}
; 12907: 		}
; 12908: 
; 12909: 		if(lpObj->pInventory[11].IsItem() == 1)

  001f9	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  001ff	81 c1 38 07 00
	00		 add	 ecx, 1848		; 00000738H
  00205	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0020a	83 f8 01	 cmp	 eax, 1
  0020d	75 37		 jne	 SHORT $LN15@gObjRestPo

; 12910: 		{
; 12911: 			if(lpObj->pInventory[11].m_Option3 != 0 && lpObj->pInventory[11].m_Durability != 0.0f && lpObj->pInventory[11].m_Type != ITEMGET(13,24))

  0020f	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00215	8a 91 b2 07 00
	00		 mov	 dl, BYTE PTR [ecx+1970]
  0021b	84 d2		 test	 dl, dl
  0021d	74 27		 je	 SHORT $LN15@gObjRestPo
  0021f	d9 81 5c 07 00
	00		 fld	 DWORD PTR [ecx+1884]
  00225	d9 ee		 fldz
  00227	da e9		 fucompp
  00229	df e0		 fnstsw	 ax
  0022b	f6 c4 44	 test	 ah, 68			; 00000044H
  0022e	7b 16		 jnp	 SHORT $LN15@gObjRestPo
  00230	b8 18 1a 00 00	 mov	 eax, 6680		; 00001a18H
  00235	66 39 81 3e 07
	00 00		 cmp	 WORD PTR [ecx+1854], ax
  0023c	74 08		 je	 SHORT $LN15@gObjRestPo

; 12912: 			{
; 12913: 				percent += lpObj->pInventory[11].m_Option3;

  0023e	0f b6 ca	 movzx	 ecx, dl
  00241	03 f9		 add	 edi, ecx
  00243	89 7d 08	 mov	 DWORD PTR _percent$166336[ebp], edi
$LN15@gObjRestPo:

; 12914: 			}
; 12915: 		}
; 12916: 
; 12917: 		if(lpObj->pInventory[9].IsItem() == 1)

  00246	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0024c	81 c1 e8 05 00
	00		 add	 ecx, 1512		; 000005e8H
  00252	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00257	83 f8 01	 cmp	 eax, 1
  0025a	75 37		 jne	 SHORT $LN13@gObjRestPo

; 12918: 		{
; 12919: 			if(lpObj->pInventory[9].m_Option3 != 0 && lpObj->pInventory[9].m_Durability != 0.0f && lpObj->pInventory[9].m_Type != ITEMGET(13,28))

  0025c	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00262	8a 91 62 06 00
	00		 mov	 dl, BYTE PTR [ecx+1634]
  00268	84 d2		 test	 dl, dl
  0026a	74 27		 je	 SHORT $LN13@gObjRestPo
  0026c	d9 81 0c 06 00
	00		 fld	 DWORD PTR [ecx+1548]
  00272	d9 ee		 fldz
  00274	da e9		 fucompp
  00276	df e0		 fnstsw	 ax
  00278	f6 c4 44	 test	 ah, 68			; 00000044H
  0027b	7b 16		 jnp	 SHORT $LN13@gObjRestPo
  0027d	b8 1c 1a 00 00	 mov	 eax, 6684		; 00001a1cH
  00282	66 39 81 ee 05
	00 00		 cmp	 WORD PTR [ecx+1518], ax
  00289	74 08		 je	 SHORT $LN13@gObjRestPo

; 12920: 			{
; 12921: 				percent += lpObj->pInventory[9].m_Option3;

  0028b	0f b6 ca	 movzx	 ecx, dl
  0028e	03 f9		 add	 edi, ecx
  00290	89 7d 08	 mov	 DWORD PTR _percent$166336[ebp], edi
$LN13@gObjRestPo:

; 12922: 			}
; 12923: 		}
; 12924: 
; 12925: 		if(lpObj->pInventory[7].IsItem() == 1)

  00293	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00299	81 c1 98 04 00
	00		 add	 ecx, 1176		; 00000498H
  0029f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002a4	83 f8 01	 cmp	 eax, 1
  002a7	75 38		 jne	 SHORT $LN34@gObjRestPo

; 12926: 		{
; 12927: 			if(lpObj->pInventory[7].m_Option3 != 0 && lpObj->pInventory[7].m_Special[2] == 85 && lpObj->pInventory[7].m_Durability != 0.0f)

  002a9	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  002af	8a 88 12 05 00
	00		 mov	 cl, BYTE PTR [eax+1298]
  002b5	84 c9		 test	 cl, cl
  002b7	74 28		 je	 SHORT $LN34@gObjRestPo
  002b9	80 b8 cb 04 00
	00 55		 cmp	 BYTE PTR [eax+1227], 85	; 00000055H
  002c0	75 1f		 jne	 SHORT $LN34@gObjRestPo
  002c2	d9 80 bc 04 00
	00		 fld	 DWORD PTR [eax+1212]
  002c8	d9 ee		 fldz
  002ca	d9 c0		 fld	 ST(0)
  002cc	dd ea		 fucomp	 ST(2)
  002ce	df e0		 fnstsw	 ax
  002d0	dd d9		 fstp	 ST(1)
  002d2	f6 c4 44	 test	 ah, 68			; 00000044H
  002d5	7b 0c		 jnp	 SHORT $LN11@gObjRestPo

; 12928: 			{
; 12929: 				percent += lpObj->pInventory[7].m_Option3;

  002d7	0f b6 d1	 movzx	 edx, cl
  002da	03 fa		 add	 edi, edx
  002dc	89 7d 08	 mov	 DWORD PTR _percent$166336[ebp], edi
  002df	eb 02		 jmp	 SHORT $LN11@gObjRestPo
$LN34@gObjRestPo:
  002e1	d9 ee		 fldz
$LN11@gObjRestPo:

; 12930: 			}
; 12931: 		}
; 12932: 
; 12933: 		if(percent != 0)

  002e3	85 ff		 test	 edi, edi
  002e5	5f		 pop	 edi
  002e6	74 70		 je	 SHORT $LN35@gObjRestPo

; 12934: 		{
; 12935: 			lpObj->m_LifeFillCount++;

  002e8	fe 86 46 02 00
	00		 inc	 BYTE PTR [esi+582]

; 12936: 
; 12937: 			if(lpObj->m_LifeFillCount > 6)

  002ee	80 be 46 02 00
	00 06		 cmp	 BYTE PTR [esi+582], 6
  002f5	7e 61		 jle	 SHORT $LN35@gObjRestPo
  002f7	dd d8		 fstp	 ST(0)

; 12938: 			{
; 12939: 				lpObj->m_LifeFillCount = 0;

  002f9	c6 86 46 02 00
	00 00		 mov	 BYTE PTR [esi+582], 0

; 12940: 				tlife = lpObj->Life;
; 12941: 
; 12942: 				tlife += (lpObj->MaxLife +lpObj->AddLife) * percent / 100.f;

  00300	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  00306	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  0030c	db 45 08	 fild	 DWORD PTR _percent$166336[ebp]
  0030f	d8 c9		 fmul	 ST(0), ST(1)
  00311	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  00317	d8 86 bc 00 00
	00		 fadd	 DWORD PTR [esi+188]
  0031d	d9 5d 08	 fstp	 DWORD PTR _tlife$166337[ebp]

; 12943: 				
; 12944: 				if((lpObj->MaxLife + lpObj->AddLife) < tlife)

  00320	d9 45 08	 fld	 DWORD PTR _tlife$166337[ebp]
  00323	d8 d1		 fcom	 ST(1)
  00325	df e0		 fnstsw	 ax
  00327	f6 c4 41	 test	 ah, 65			; 00000041H
  0032a	75 0a		 jne	 SHORT $LN75@gObjRestPo

; 12945: 				{
; 12946: 					tlife = lpObj->MaxLife + lpObj->AddLife;

  0032c	dd d8		 fstp	 ST(0)
  0032e	d9 5d 08	 fstp	 DWORD PTR _tlife$166337[ebp]
  00331	d9 45 08	 fld	 DWORD PTR _tlife$166337[ebp]
  00334	eb 02		 jmp	 SHORT $LN8@gObjRestPo
$LN75@gObjRestPo:
  00336	dd d9		 fstp	 ST(1)
$LN8@gObjRestPo:

; 12947: 				}
; 12948: 
; 12949: 				lpObj->Life = tlife;
; 12950: 
; 12951: 				GCReFillSend(lpObj->m_Index,lpObj->Life,255,0);

  00338	6a 00		 push	 0
  0033a	d9 96 bc 00 00
	00		 fst	 DWORD PTR [esi+188]
  00340	68 ff 00 00 00	 push	 255			; 000000ffH
  00345	e8 00 00 00 00	 call	 __ftol2_sse
  0034a	50		 push	 eax
  0034b	8b 06		 mov	 eax, DWORD PTR [esi]
  0034d	50		 push	 eax
  0034e	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend
  00353	83 c4 10	 add	 esp, 16			; 00000010H
$LN78@gObjRestPo:
  00356	d9 ee		 fldz
$LN35@gObjRestPo:

; 12952: 			}
; 12953: 		}
; 12954: 	}
; 12955: 
; 12956: 	if(lpObj->FillLife > 0)

  00358	d8 96 c8 00 00
	00		 fcom	 DWORD PTR [esi+200]
  0035e	df e0		 fnstsw	 ax
  00360	f6 c4 05	 test	 ah, 5
  00363	0f 8a f4 00 00
	00		 jp	 $LN44@gObjRestPo

; 12957: 	{
; 12958: 		float cur = lpObj->FillLifeMax * 34.0f / 100.0f;

  00369	d9 86 cc 00 00
	00		 fld	 DWORD PTR [esi+204]

; 12959: 
; 12960: 		if(lpObj->FillLifeCount == 2)

  0036f	8a 86 df 00 00
	00		 mov	 al, BYTE PTR [esi+223]
  00375	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4041000000000000
  0037b	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4059000000000000
  00381	dc f9		 fdiv	 ST(1), ST(0)
  00383	d9 c9		 fxch	 ST(1)
  00385	d9 5d 08	 fstp	 DWORD PTR _cur$166350[ebp]
  00388	3c 02		 cmp	 al, 2
  0038a	75 11		 jne	 SHORT $LN6@gObjRestPo

; 12961: 		{
; 12962: 			cur = lpObj->FillLifeMax * 54.0f / 100.0f;

  0038c	d9 86 cc 00 00
	00		 fld	 DWORD PTR [esi+204]
  00392	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@404b000000000000
  00398	d8 f1		 fdiv	 ST(0), ST(1)
  0039a	d9 5d 08	 fstp	 DWORD PTR _cur$166350[ebp]
$LN6@gObjRestPo:

; 12963: 		}
; 12964: 
; 12965: 		if(lpObj->FillLifeCount == 4)

  0039d	3c 04		 cmp	 al, 4
  0039f	75 13		 jne	 SHORT $LN50@gObjRestPo

; 12966: 		{
; 12967: 			cur = lpObj->FillLifeMax * 25.0f / 100.0f;

  003a1	d9 86 cc 00 00
	00		 fld	 DWORD PTR [esi+204]
  003a7	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4039000000000000
  003ad	de f1		 fdivrp	 ST(1), ST(0)
  003af	d9 5d 08	 fstp	 DWORD PTR _cur$166350[ebp]
  003b2	eb 02		 jmp	 SHORT $LN5@gObjRestPo
$LN50@gObjRestPo:
  003b4	dd d8		 fstp	 ST(0)
$LN5@gObjRestPo:

; 12968: 		}
; 12969: 
; 12970: 		if(lpObj->FillLife < cur)

  003b6	d9 86 c8 00 00
	00		 fld	 DWORD PTR [esi+200]
  003bc	d9 45 08	 fld	 DWORD PTR _cur$166350[ebp]
  003bf	d8 d1		 fcom	 ST(1)
  003c1	df e0		 fnstsw	 ax
  003c3	dd d9		 fstp	 ST(1)
  003c5	f6 c4 41	 test	 ah, 65			; 00000041H
  003c8	75 27		 jne	 SHORT $LN4@gObjRestPo
  003ca	dd d8		 fstp	 ST(0)

; 12971: 		{
; 12972: 			cur = lpObj->FillLife;

  003cc	d9 86 c8 00 00
	00		 fld	 DWORD PTR [esi+200]
  003d2	d9 5d 08	 fstp	 DWORD PTR _cur$166350[ebp]

; 12973: 			lpObj->FillLife = 0;

  003d5	d9 96 c8 00 00
	00		 fst	 DWORD PTR [esi+200]

; 12974: 
; 12975: 			if(cur < 0)

  003db	d9 45 08	 fld	 DWORD PTR _cur$166350[ebp]
  003de	d8 d1		 fcom	 ST(1)
  003e0	df e0		 fnstsw	 ax
  003e2	f6 c4 05	 test	 ah, 5
  003e5	7a 18		 jp	 SHORT $LN2@gObjRestPo

; 12976: 			{
; 12977: 				cur = 0;
; 12978: 			}
; 12979: 		}
; 12980: 		else
; 12981: 		{
; 12982: 			lpObj->FillLife -= cur;

  003e7	dd d8		 fstp	 ST(0)
  003e9	d9 55 08	 fst	 DWORD PTR _cur$166350[ebp]
  003ec	d9 45 08	 fld	 DWORD PTR _cur$166350[ebp]
  003ef	eb 0e		 jmp	 SHORT $LN2@gObjRestPo
$LN4@gObjRestPo:
  003f1	d9 86 c8 00 00
	00		 fld	 DWORD PTR [esi+200]
  003f7	d8 e1		 fsub	 ST(0), ST(1)
  003f9	d9 9e c8 00 00
	00		 fstp	 DWORD PTR [esi+200]
$LN2@gObjRestPo:

; 12983: 		}
; 12984: 
; 12985: 		lpObj->Life += cur;

  003ff	d8 86 bc 00 00
	00		 fadd	 DWORD PTR [esi+188]
  00405	d9 5d 08	 fstp	 DWORD PTR tv756[ebp]
  00408	d9 45 08	 fld	 DWORD PTR tv756[ebp]
  0040b	d9 96 bc 00 00
	00		 fst	 DWORD PTR [esi+188]

; 12986: 
; 12987: 		if((lpObj->MaxLife + lpObj->AddLife) < lpObj->Life)

  00411	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  00417	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  0041d	d8 d1		 fcom	 ST(1)
  0041f	df e0		 fnstsw	 ax
  00421	dd d9		 fstp	 ST(1)
  00423	f6 c4 05	 test	 ah, 5
  00426	7a 0e		 jp	 SHORT $LN59@gObjRestPo

; 12988: 		{
; 12989: 			lpObj->Life = lpObj->MaxLife + lpObj->AddLife;

  00428	d9 9e bc 00 00
	00		 fstp	 DWORD PTR [esi+188]

; 12990: 			lpObj->FillLife = 0;

  0042e	d9 9e c8 00 00
	00		 fstp	 DWORD PTR [esi+200]
  00434	eb 04		 jmp	 SHORT $LN1@gObjRestPo
$LN59@gObjRestPo:
  00436	dd d8		 fstp	 ST(0)
  00438	dd d8		 fstp	 ST(0)
$LN1@gObjRestPo:

; 12991: 		}
; 12992: 
; 12993: 		GCReFillSend(lpObj->m_Index,lpObj->Life,255,0);

  0043a	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  00440	6a 00		 push	 0
  00442	68 ff 00 00 00	 push	 255			; 000000ffH
  00447	e8 00 00 00 00	 call	 __ftol2_sse
  0044c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0044e	50		 push	 eax
  0044f	51		 push	 ecx
  00450	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend
  00455	83 c4 10	 add	 esp, 16			; 00000010H
  00458	5e		 pop	 esi

; 12994: 	}
; 12995: }

  00459	8b e5		 mov	 esp, ebp
  0045b	5d		 pop	 ebp
  0045c	c3		 ret	 0
$LN44@gObjRestPo:

; 12952: 			}
; 12953: 		}
; 12954: 	}
; 12955: 
; 12956: 	if(lpObj->FillLife > 0)

  0045d	dd d8		 fstp	 ST(0)
  0045f	5e		 pop	 esi

; 12994: 	}
; 12995: }

  00460	8b e5		 mov	 esp, ebp
  00462	5d		 pop	 ebp
  00463	c3		 ret	 0
?gObjRestPotionFill@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjRestPotionFill
_TEXT	ENDS
PUBLIC	?gObjUseDrink@@YAXPAUOBJECTSTRUCT@@H@Z		; gObjUseDrink
EXTRN	?GCItemUseSpecialTimeSend@@YAXHEH@Z:PROC	; GCItemUseSpecialTimeSend
; Function compile flags: /Ogtp
;	COMDAT ?gObjUseDrink@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_level$ = 12						; size = 4
?gObjUseDrink@@YAXPAUOBJECTSTRUCT@@H@Z PROC		; gObjUseDrink, COMDAT

; 12998: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 12999: 	int time;
; 13000: 
; 13001: 	if ( level == 2 )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _level$[ebp]
  00006	83 f8 02	 cmp	 eax, 2
  00009	75 27		 jne	 SHORT $LN6@gObjUseDri

; 13002: 	{
; 13003: 		time = 90;
; 13004: 		GCItemUseSpecialTimeSend(lpObj->m_Index, 1, time);

  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000f	8b 06		 mov	 eax, DWORD PTR [esi]
  00011	6a 5a		 push	 90			; 0000005aH
  00013	6a 01		 push	 1
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?GCItemUseSpecialTimeSend@@YAXHEH@Z ; GCItemUseSpecialTimeSend
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13005: 		lpObj->m_SkillAttack2 = 1;

  0001e	c7 86 88 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+648], 1

; 13006: 		lpObj->m_SkillAttackTime2 = 90;

  00028	c6 86 8c 02 00
	00 5a		 mov	 BYTE PTR [esi+652], 90	; 0000005aH
  0002f	5e		 pop	 esi

; 13022: 	}
; 13023: }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN6@gObjUseDri:

; 13007: 	}
; 13008: 	else if ( level == 1 )

  00032	83 f8 01	 cmp	 eax, 1
  00035	75 17		 jne	 SHORT $LN4@gObjUseDri

; 13009: 	{
; 13010: 		time = 180;
; 13011: 		GCItemUseSpecialTimeSend(lpObj->m_Index, 0, time);

  00037	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0003a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003c	68 b4 00 00 00	 push	 180			; 000000b4H
  00041	6a 00		 push	 0
  00043	52		 push	 edx

; 13017: 	}
; 13018: 	else
; 13019: 	{
; 13020: 		time = 80;
; 13021: 		GCItemUseSpecialTimeSend(lpObj->m_Index, 0, time);

  00044	e8 00 00 00 00	 call	 ?GCItemUseSpecialTimeSend@@YAXHEH@Z ; GCItemUseSpecialTimeSend
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13022: 	}
; 13023: }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN4@gObjUseDri:

; 13012: 	}
; 13013: 	else if ( level == 0x4D )

  0004e	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00051	75 14		 jne	 SHORT $LN2@gObjUseDri

; 13014: 	{
; 13015: 		time = 60;
; 13016: 		GCItemUseSpecialTimeSend(lpObj->m_Index, 2, time);

  00053	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	6a 3c		 push	 60			; 0000003cH
  0005a	6a 02		 push	 2
  0005c	51		 push	 ecx

; 13017: 	}
; 13018: 	else
; 13019: 	{
; 13020: 		time = 80;
; 13021: 		GCItemUseSpecialTimeSend(lpObj->m_Index, 0, time);

  0005d	e8 00 00 00 00	 call	 ?GCItemUseSpecialTimeSend@@YAXHEH@Z ; GCItemUseSpecialTimeSend
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13022: 	}
; 13023: }

  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
$LN2@gObjUseDri:

; 13017: 	}
; 13018: 	else
; 13019: 	{
; 13020: 		time = 80;
; 13021: 		GCItemUseSpecialTimeSend(lpObj->m_Index, 0, time);

  00067	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0006a	8b 02		 mov	 eax, DWORD PTR [edx]
  0006c	6a 50		 push	 80			; 00000050H
  0006e	6a 00		 push	 0
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?GCItemUseSpecialTimeSend@@YAXHEH@Z ; GCItemUseSpecialTimeSend
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13022: 	}
; 13023: }

  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?gObjUseDrink@@YAXPAUOBJECTSTRUCT@@H@Z ENDP		; gObjUseDrink
_TEXT	ENDS
PUBLIC	?gObjCurMoveMake@@YAHQAEPAUOBJECTSTRUCT@@@Z	; gObjCurMoveMake
; Function compile flags: /Ogtp
;	COMDAT ?gObjCurMoveMake@@YAHQAEPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_path$ = 8						; size = 4
_lpObj$ = 12						; size = 4
?gObjCurMoveMake@@YAHQAEPAUOBJECTSTRUCT@@@Z PROC	; gObjCurMoveMake, COMDAT

; 13032: 	// Lacking Full Code Here
; 13033: 	return 0;

  00000	33 c0		 xor	 eax, eax

; 13034: }

  00002	c3		 ret	 0
?gObjCurMoveMake@@YAHQAEPAUOBJECTSTRUCT@@@Z ENDP	; gObjCurMoveMake
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
; Function compile flags: /Ogtp
;	COMDAT ?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pCount$ = -5008					; size = 4
_sendBuf$ = -5004					; size = 5000
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z PROC ; gObjViewportListProtocolDestroy, COMDAT

; 13037: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 90 13 00 00	 mov	 eax, 5008		; 00001390H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]

; 13038: 	BYTE sendBuf[5000];
; 13039: 	int lOfs, count;
; 13040: 	count = 0;
; 13041: 	lOfs = 4;
; 13042: 
; 13043: 	PBMSG_COUNT pCount;
; 13044: 
; 13045: 	pViewportDestroy.NumberH = SET_NUMBERH(lpObj->m_Index);

  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	c1 e9 08	 shr	 ecx, 8
  0001f	88 0d 00 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, cl

; 13046: 	pViewportDestroy.NumberL = SET_NUMBERL(lpObj->m_Index);

  00025	8a 10		 mov	 dl, BYTE PTR [eax]
  00027	88 15 01 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, dl

; 13047: 
; 13048: 	memcpy(&sendBuf[lOfs], &pViewportDestroy, 2);

  0002d	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pViewportDestroy
  00034	66 89 8d 78 ec
	ff ff		 mov	 WORD PTR _sendBuf$[ebp+4], cx

; 13049: 
; 13050: 	lOfs += 2;
; 13051: 	count += 1;
; 13052: 
; 13053: 	pCount.h.c = 0xC1;
; 13054: 	pCount.h.headcode = 0x14;
; 13055: 	pCount.h.size = lOfs;
; 13056: 	pCount.count = count;
; 13057: 
; 13058: 	memcpy(sendBuf, &pCount, sizeof(pCount));
; 13059: 
; 13060: 	if (count < 1)
; 13061: 	{
; 13062: 		return;
; 13063: 	}
; 13064: 
; 13065: 	MsgSendV2(lpObj, sendBuf, lOfs);

  0003b	6a 06		 push	 6
  0003d	8d 8d 74 ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  00043	51		 push	 ecx
  00044	c6 85 70 ec ff
	ff c1		 mov	 BYTE PTR _pCount$[ebp], 193 ; 000000c1H
  0004b	66 c7 85 71 ec
	ff ff 06 14	 mov	 WORD PTR _pCount$[ebp+1], 5126 ; 00001406H
  00054	c6 85 73 ec ff
	ff 01		 mov	 BYTE PTR _pCount$[ebp+3], 1
  0005b	8b 95 70 ec ff
	ff		 mov	 edx, DWORD PTR _pCount$[ebp]
  00061	50		 push	 eax
  00062	89 95 74 ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp], edx
  00068	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 13066: }

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	33 cd		 xor	 ecx, ebp
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z ENDP ; gObjViewportListProtocolDestroy
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
; Function compile flags: /Ogtp
;	COMDAT ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pGuild$166426 = -5032					; size = 12
_MVL$ = -5020						; size = 4
_lOfs$ = -5016						; size = 4
_pwCount$166482 = -5012					; size = 5
_pwCount$166475 = -5012					; size = 5
_pwCount$166433 = -5012					; size = 5
_pwCount$ = -5012					; size = 5
_sendBuf$ = -5004					; size = 5000
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z PROC ; gObjViewportListProtocolCreate, COMDAT

; 13069: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 a8 13 00 00	 mov	 eax, 5032		; 000013a8H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]

; 13070: 	int n, tObjNum;
; 13071: 	BYTE sendBuf[5000];
; 13072: 	int lOfs, count, moncount;
; 13073: 	PWMSG_COUNT pwCount;
; 13074: 
; 13075: 	count = 0;
; 13076: 	moncount = 0;
; 13077: 	lOfs = sizeof(pwCount);
; 13078: 
; 13079: 	int MVL = MAX_VIEWPORT;
; 13080: 
; 13081: 	if (lpObj->Type == OBJ_MONSTER)

  0001b	0f b7 43 60	 movzx	 eax, WORD PTR [ebx+96]
  0001f	c7 85 64 ec ff
	ff 4b 00 00 00	 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH
  00029	83 f8 02	 cmp	 eax, 2
  0002c	75 0a		 jne	 SHORT $LN28@gObjViewpo@4

; 13082: 	{
; 13083: 		MVL = MAX_VIEWPORT_MONSTER;

  0002e	c7 85 64 ec ff
	ff 14 00 00 00	 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN28@gObjViewpo@4:

; 13084: 	}
; 13085: 
; 13086: 	if (lpObj->Type == OBJ_USER)

  00038	b9 01 00 00 00	 mov	 ecx, 1
  0003d	66 3b c1	 cmp	 ax, cx
  00040	0f 85 dc 03 00
	00		 jne	 $LN27@gObjViewpo@4

; 13087: 	{
; 13088: 		if (lpObj->m_Change >= 0)
; 13089: 		{
; 13090: 			pViewportCreateChange.NumberH = SET_NUMBERH(lpObj->m_Index);

  00046	8b 03		 mov	 eax, DWORD PTR [ebx]
  00048	56		 push	 esi
  00049	33 f6		 xor	 esi, esi
  0004b	c1 e8 08	 shr	 eax, 8
  0004e	57		 push	 edi
  0004f	39 b3 d0 02 00
	00		 cmp	 DWORD PTR [ebx+720], esi
  00055	0f 8c eb 00 00
	00		 jl	 $LN26@gObjViewpo@4
  0005b	a2 00 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A, al

; 13091: 			pViewportCreateChange.NumberL = SET_NUMBERL(lpObj->m_Index);

  00060	0f b6 0b	 movzx	 ecx, BYTE PTR [ebx]
  00063	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+1, cl

; 13092: 
; 13093: 			pViewportCreateChange.NumberH |= 0x80;

  00069	0c 80		 or	 al, 128			; 00000080H
  0006b	a2 00 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A, al

; 13094: 
; 13095: 			pViewportCreateChange.X = lpObj->X;

  00070	0f b6 93 04 01
	00 00		 movzx	 edx, BYTE PTR [ebx+260]
  00077	88 15 02 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+2, dl

; 13096: 			pViewportCreateChange.Y = lpObj->Y;

  0007d	0f b6 83 06 01
	00 00		 movzx	 eax, BYTE PTR [ebx+262]
  00084	a2 03 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+3, al

; 13097: 
; 13098: 			pViewportCreateChange.TX = lpObj->TX;

  00089	0f b6 8b 20 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+288]
  00090	88 0d 16 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+22, cl

; 13099: 			pViewportCreateChange.TY = lpObj->TY;

  00096	0f b6 93 22 01
	00 00		 movzx	 edx, BYTE PTR [ebx+290]
  0009d	88 15 17 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+23, dl

; 13100: 
; 13101: 			pViewportCreateChange.SkinH = SET_NUMBERH((lpObj->m_Change & 0xFFFF) & 0xFFFF);

  000a3	0f b6 83 d1 02
	00 00		 movzx	 eax, BYTE PTR [ebx+721]
  000aa	a2 04 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+4, al

; 13102: 			pViewportCreateChange.SkinL = SET_NUMBERL((lpObj->m_Change & 0xFFFF) & 0xFFFF);

  000af	0f b6 8b d0 02
	00 00		 movzx	 ecx, BYTE PTR [ebx+720]
  000b6	88 0d 05 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+5, cl

; 13103: 
; 13104: 			pViewportCreateChange.ViewSkillState = lpObj->m_ViewSkillState;

  000bc	8b 93 c4 01 00
	00		 mov	 edx, DWORD PTR [ebx+452]
  000c2	89 15 08 00 00
	00		 mov	 DWORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+8, edx

; 13105: 			pViewportCreateChange.DirAndPkLevel = lpObj->Dir << 4;

  000c8	8a 83 08 01 00
	00		 mov	 al, BYTE PTR [ebx+264]
  000ce	c0 e0 04	 shl	 al, 4
  000d1	a2 18 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+24, al

; 13106: 			pViewportCreateChange.DirAndPkLevel |= lpObj->m_PK_Level & 0x0F;

  000d6	0f b6 8b fd 00
	00 00		 movzx	 ecx, BYTE PTR [ebx+253]
  000dd	80 e1 0f	 and	 cl, 15			; 0000000fH
  000e0	0a c1		 or	 al, cl
  000e2	a2 18 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+24, al

; 13107: 
; 13108: 			if (CC_MAP_RANGE(lpObj->MapNumber))

  000e7	0f b6 83 09 01
	00 00		 movzx	 eax, BYTE PTR [ebx+265]
  000ee	3c 12		 cmp	 al, 18			; 00000012H
  000f0	72 11		 jb	 SHORT $LN25@gObjViewpo@4
  000f2	b2 17		 mov	 dl, 23			; 00000017H
  000f4	3a d0		 cmp	 dl, al
  000f6	1b c0		 sbb	 eax, eax
  000f8	40		 inc	 eax
  000f9	3b c6		 cmp	 eax, esi
  000fb	74 06		 je	 SHORT $LN25@gObjViewpo@4

; 13109: 			{
; 13110: 				pViewportCreateChange.ViewSkillState = 0;

  000fd	89 35 08 00 00
	00		 mov	 DWORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+8, esi
$LN25@gObjViewpo@4:

; 13111: 			}
; 13112: 
; 13113: 			memcpy(pViewportCreateChange.Id, lpObj->Name, sizeof(pViewportCreateChange.Id));

  00103	8b 43 6f	 mov	 eax, DWORD PTR [ebx+111]
  00106	a3 0c 00 00 00	 mov	 DWORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+12, eax
  0010b	8b 4b 73	 mov	 ecx, DWORD PTR [ebx+115]
  0010e	89 0d 10 00 00
	00		 mov	 DWORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+16, ecx
  00114	66 8b 53 77	 mov	 dx, WORD PTR [ebx+119]

; 13114: 			memcpy(&sendBuf[lOfs], &pViewportCreateChange, sizeof(pViewportCreateChange));
; 13115: 
; 13116: 			lOfs += sizeof(pViewportCreateChange);

  00118	b8 21 00 00 00	 mov	 eax, 33			; 00000021H
  0011d	66 89 15 14 00
	00 00		 mov	 WORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+20, dx
  00124	b9 07 00 00 00	 mov	 ecx, 7
  00129	be 00 00 00 00	 mov	 esi, OFFSET ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A ; pViewportCreateChange
  0012e	8d bd 79 ec ff
	ff		 lea	 edi, DWORD PTR _sendBuf$[ebp+5]
  00134	89 85 68 ec ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 13117: 			count += 1;
; 13118: 
; 13119: 			if (count < 1)
; 13120: 			{
; 13121: 				return;
; 13122: 			}
; 13123: 
; 13124: 			pwCount.h.headcode = 0x45;

  0013a	c6 85 6f ec ff
	ff 45		 mov	 BYTE PTR _pwCount$[ebp+3], 69 ; 00000045H

; 13125: 		}
; 13126: 		else

  00141	e9 34 01 00 00	 jmp	 $LN48@gObjViewpo@4
$LN26@gObjViewpo@4:

; 13127: 		{
; 13128: 			pViewportCreate.NumberH = SET_NUMBERH(lpObj->m_Index);

  00146	a2 00 00 00 00	 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A, al

; 13129: 			pViewportCreate.NumberL = SET_NUMBERL(lpObj->m_Index);

  0014b	8a 13		 mov	 dl, BYTE PTR [ebx]
  0014d	88 15 01 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+1, dl

; 13130: 
; 13131: 			lpObj->CharSet[0] &= 0xF0;

  00153	80 a3 50 03 00
	00 f0		 and	 BYTE PTR [ebx+848], 240	; 000000f0H

; 13132: 
; 13133: 			if (lpObj->m_State == 1 && lpObj->Teleport == 0)

  0015a	39 8b bc 01 00
	00		 cmp	 DWORD PTR [ebx+444], ecx
  00160	75 10		 jne	 SHORT $LN22@gObjViewpo@4
  00162	80 bb 00 02 00
	00 00		 cmp	 BYTE PTR [ebx+512], 0
  00169	75 07		 jne	 SHORT $LN22@gObjViewpo@4

; 13134: 			{
; 13135: 				pViewportCreate.NumberH |= 0x80;

  0016b	80 0d 00 00 00
	00 80		 or	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A, 128 ; 00000080H
$LN22@gObjViewpo@4:

; 13136: 			}
; 13137: 
; 13138: 			pViewportCreate.ViewSkillState = lpObj->m_ViewSkillState;

  00172	8b 83 c4 01 00
	00		 mov	 eax, DWORD PTR [ebx+452]
  00178	a3 18 00 00 00	 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+24, eax

; 13139: 
; 13140: 			lpObj->CharSet[0] |= lpObj->m_ViewState & 0x0F;

  0017d	0f b6 8b c2 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+450]

; 13141: 
; 13142: 			pViewportCreate.X = lpObj->X;

  00184	0f b6 93 04 01
	00 00		 movzx	 edx, BYTE PTR [ebx+260]
  0018b	80 e1 0f	 and	 cl, 15			; 0000000fH
  0018e	08 8b 50 03 00
	00		 or	 BYTE PTR [ebx+848], cl
  00194	88 15 02 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+2, dl

; 13143: 			pViewportCreate.Y = lpObj->Y;

  0019a	0f b6 83 06 01
	00 00		 movzx	 eax, BYTE PTR [ebx+262]
  001a1	a2 03 00 00 00	 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+3, al

; 13144: 			pViewportCreate.TX = lpObj->TX;

  001a6	0f b6 8b 20 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+288]
  001ad	88 0d 26 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+38, cl

; 13145: 			pViewportCreate.TY = lpObj->TY;

  001b3	0f b6 93 22 01
	00 00		 movzx	 edx, BYTE PTR [ebx+290]
  001ba	88 15 27 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+39, dl

; 13146: 
; 13147: 			pViewportCreate.DirAndPkLevel = lpObj->Dir << 4;

  001c0	8a 83 08 01 00
	00		 mov	 al, BYTE PTR [ebx+264]
  001c6	c0 e0 04	 shl	 al, 4
  001c9	a2 28 00 00 00	 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+40, al

; 13148: 			pViewportCreate.DirAndPkLevel |= lpObj->m_PK_Level & 0x0F;

  001ce	0f b6 8b fd 00
	00 00		 movzx	 ecx, BYTE PTR [ebx+253]
  001d5	80 e1 0f	 and	 cl, 15			; 0000000fH
  001d8	0a c1		 or	 al, cl
  001da	a2 28 00 00 00	 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+40, al

; 13149: 
; 13150: 			if (CC_MAP_RANGE(lpObj->MapNumber))

  001df	0f b6 83 09 01
	00 00		 movzx	 eax, BYTE PTR [ebx+265]
  001e6	3c 12		 cmp	 al, 18			; 00000012H
  001e8	72 11		 jb	 SHORT $LN21@gObjViewpo@4
  001ea	b2 17		 mov	 dl, 23			; 00000017H
  001ec	3a d0		 cmp	 dl, al
  001ee	1b c0		 sbb	 eax, eax
  001f0	40		 inc	 eax
  001f1	3b c6		 cmp	 eax, esi
  001f3	74 06		 je	 SHORT $LN21@gObjViewpo@4

; 13151: 			{
; 13152: 				pViewportCreate.ViewSkillState = 0;

  001f5	89 35 18 00 00
	00		 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+24, esi
$LN21@gObjViewpo@4:

; 13153: 			}
; 13154: 
; 13155: 			memcpy(pViewportCreate.CharSet, lpObj->CharSet, sizeof(pViewportCreate.CharSet));

  001fb	8b 83 50 03 00
	00		 mov	 eax, DWORD PTR [ebx+848]
  00201	a3 04 00 00 00	 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+4, eax
  00206	8b 8b 54 03 00
	00		 mov	 ecx, DWORD PTR [ebx+852]
  0020c	89 0d 08 00 00
	00		 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+8, ecx
  00212	8b 93 58 03 00
	00		 mov	 edx, DWORD PTR [ebx+856]
  00218	89 15 0c 00 00
	00		 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+12, edx
  0021e	8b 83 5c 03 00
	00		 mov	 eax, DWORD PTR [ebx+860]
  00224	a3 10 00 00 00	 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+16, eax
  00229	0f b7 8b 60 03
	00 00		 movzx	 ecx, WORD PTR [ebx+864]
  00230	66 89 0d 14 00
	00 00		 mov	 WORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+20, cx

; 13156: 			memcpy(pViewportCreate.Id, lpObj->Name, sizeof(pViewportCreate.Id));

  00237	8b 53 6f	 mov	 edx, DWORD PTR [ebx+111]
  0023a	89 15 1c 00 00
	00		 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+28, edx
  00240	8b 43 73	 mov	 eax, DWORD PTR [ebx+115]
  00243	a3 20 00 00 00	 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+32, eax
  00248	0f b7 4b 77	 movzx	 ecx, WORD PTR [ebx+119]

; 13157: 			memcpy(&sendBuf[lOfs], &pViewportCreate, sizeof(pViewportCreate));
; 13158: 
; 13159: 			lOfs += sizeof(pViewportCreate);

  0024c	c7 85 68 ec ff
	ff 31 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 49 ; 00000031H

; 13160: 			count += 1;
; 13161: 
; 13162: 			if (count < 1)
; 13163: 			{
; 13164: 				return;
; 13165: 			}
; 13166: 
; 13167: 			pwCount.h.headcode = 0x12;

  00256	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0025c	66 89 0d 24 00
	00 00		 mov	 WORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+36, cx
  00263	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00268	be 00 00 00 00	 mov	 esi, OFFSET ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A ; pViewportCreate
  0026d	8d bd 79 ec ff
	ff		 lea	 edi, DWORD PTR _sendBuf$[ebp+5]
  00273	c6 85 6f ec ff
	ff 12		 mov	 BYTE PTR _pwCount$[ebp+3], 18 ; 00000012H
$LN48@gObjViewpo@4:

; 13168: 		}
; 13169: 
; 13170: 		pwCount.h.c = 0xC2;
; 13171: 		pwCount.h.sizeH = SET_NUMBERH(lOfs);

  0027a	f3 a5		 rep movsd
  0027c	8b d0		 mov	 edx, eax

; 13172: 		pwCount.h.sizeL = SET_NUMBERL(lOfs);
; 13173: 		pwCount.count = count;
; 13174: 
; 13175: 		memcpy(sendBuf, &pwCount, sizeof(pwCount));
; 13176: 
; 13177: 		DataSend(lpObj->m_Index, sendBuf, lOfs);

  0027e	50		 push	 eax
  0027f	88 85 6e ec ff
	ff		 mov	 BYTE PTR _pwCount$[ebp+2], al
  00285	c1 ea 08	 shr	 edx, 8
  00288	b1 01		 mov	 cl, 1
  0028a	8d 85 74 ec ff
	ff		 lea	 eax, DWORD PTR _sendBuf$[ebp]
  00290	88 8d 78 ec ff
	ff		 mov	 BYTE PTR _sendBuf$[ebp+4], cl
  00296	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00298	88 95 6d ec ff
	ff		 mov	 BYTE PTR _pwCount$[ebp+1], dl
  0029e	50		 push	 eax
  0029f	c6 85 6c ec ff
	ff c2		 mov	 BYTE PTR _pwCount$[ebp], 194 ; 000000c2H
  002a6	8b 95 6c ec ff
	ff		 mov	 edx, DWORD PTR _pwCount$[ebp]
  002ac	51		 push	 ecx
  002ad	89 95 74 ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp], edx
  002b3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13178: 
; 13179: 		if (lpObj->GuildNumber != 0)

  002bb	83 bb b0 02 00
	00 00		 cmp	 DWORD PTR [ebx+688], 0
  002c2	0f 84 cc 00 00
	00		 je	 $LN43@gObjViewpo@4

; 13180: 		{
; 13181: 			GuildInfoOfs = 0;
; 13182: 			GuildInfoOfs = 5;

  002c8	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?GuildInfoOfs@@3HA, 5 ; GuildInfoOfs

; 13183: 
; 13184: 			PMSG_SIMPLE_GUILDVIEWPORT pGuild;
; 13185: 
; 13186: 			pGuild.GuildNumber = lpObj->lpGuild->Number;
; 13187: 			pGuild.NumberH = SET_NUMBERH(lpObj->m_Index) & 0x7F;

  002d2	8b 03		 mov	 eax, DWORD PTR [ebx]
  002d4	8b 93 b4 02 00
	00		 mov	 edx, DWORD PTR [ebx+692]

; 13188: 			pGuild.NumberL = SET_NUMBERL(lpObj->m_Index);

  002da	8a 0b		 mov	 cl, BYTE PTR [ebx]
  002dc	8b 3a		 mov	 edi, DWORD PTR [edx]
  002de	c1 e8 08	 shr	 eax, 8
  002e1	24 7f		 and	 al, 127			; 0000007fH
  002e3	88 85 5f ec ff
	ff		 mov	 BYTE PTR _pGuild$166426[ebp+7], al
  002e9	88 8d 60 ec ff
	ff		 mov	 BYTE PTR _pGuild$166426[ebp+8], cl

; 13189: 
; 13190: 			if (strcmp(lpObj->lpGuild->Names[0], lpObj->Name) == 0)

  002ef	8d 73 6f	 lea	 esi, DWORD PTR [ebx+111]
  002f2	8d 42 2f	 lea	 eax, DWORD PTR [edx+47]
$LL39@gObjViewpo@4:
  002f5	8a 08		 mov	 cl, BYTE PTR [eax]
  002f7	3a 0e		 cmp	 cl, BYTE PTR [esi]
  002f9	75 1a		 jne	 SHORT $LN40@gObjViewpo@4
  002fb	84 c9		 test	 cl, cl
  002fd	74 12		 je	 SHORT $LN41@gObjViewpo@4
  002ff	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00302	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00305	75 0e		 jne	 SHORT $LN40@gObjViewpo@4
  00307	83 c0 02	 add	 eax, 2
  0030a	83 c6 02	 add	 esi, 2
  0030d	84 c9		 test	 cl, cl
  0030f	75 e4		 jne	 SHORT $LL39@gObjViewpo@4
$LN41@gObjViewpo@4:
  00311	33 c0		 xor	 eax, eax
  00313	eb 05		 jmp	 SHORT $LN42@gObjViewpo@4
$LN40@gObjViewpo@4:
  00315	1b c0		 sbb	 eax, eax
  00317	83 d8 ff	 sbb	 eax, -1
$LN42@gObjViewpo@4:
  0031a	85 c0		 test	 eax, eax
  0031c	75 07		 jne	 SHORT $LN18@gObjViewpo@4

; 13191: 			{
; 13192: 				pGuild.NumberH |= 0x80;

  0031e	80 8d 5f ec ff
	ff 80		 or	 BYTE PTR _pGuild$166426[ebp+7], 128 ; 00000080H
$LN18@gObjViewpo@4:

; 13193: 			}
; 13194: 
; 13195: 			pGuild.btGuildType = lpObj->lpGuild->btGuildType;

  00325	8a 92 18 07 00
	00		 mov	 dl, BYTE PTR [edx+1816]

; 13196: 			pGuild.btGuildStatus = lpObj->GuildStatus;

  0032b	8a 83 c4 02 00
	00		 mov	 al, BYTE PTR [ebx+708]
  00331	88 95 5d ec ff
	ff		 mov	 BYTE PTR _pGuild$166426[ebp+5], dl

; 13197: 
; 13198: 			memcpy(&GuildInfoBuf[GuildInfoOfs], &pGuild, sizeof(pGuild));

  00337	8b 95 60 ec ff
	ff		 mov	 edx, DWORD PTR _pGuild$166426[ebp+8]
  0033d	88 85 5c ec ff
	ff		 mov	 BYTE PTR _pGuild$166426[ebp+4], al
  00343	8b 8d 5c ec ff
	ff		 mov	 ecx, DWORD PTR _pGuild$166426[ebp+4]
  00349	89 0d 09 00 00
	00		 mov	 DWORD PTR ?GuildInfoBuf@@3PAEA+9, ecx
  0034f	89 15 0d 00 00
	00		 mov	 DWORD PTR ?GuildInfoBuf@@3PAEA+13, edx

; 13199: 
; 13200: 			GuildInfoOfs += sizeof(pGuild);

  00355	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H

; 13201: 
; 13202: 			PMSG_SIMPLE_GUILDVIEWPORT_COUNT pwCount;
; 13203: 
; 13204: 			pwCount.h.c = 0xC2;

  0035a	c7 85 6c ec ff
	ff c2 00 11 65	 mov	 DWORD PTR _pwCount$166433[ebp], 1695613122 ; 651100c2H

; 13205: 			pwCount.h.headcode = 0x65;
; 13206: 			pwCount.h.sizeH = SET_NUMBERH(GuildInfoOfs);
; 13207: 			pwCount.h.sizeL = SET_NUMBERL(GuildInfoOfs);
; 13208: 			pwCount.Count = 1;
; 13209: 
; 13210: 			memcpy(GuildInfoBuf, &pwCount, sizeof(pwCount));

  00364	8b 95 6c ec ff
	ff		 mov	 edx, DWORD PTR _pwCount$166433[ebp]
  0036a	b0 01		 mov	 al, 1

; 13211: 
; 13212: 			DataSend(lpObj->m_Index, GuildInfoBuf, GuildInfoOfs);

  0036c	51		 push	 ecx
  0036d	89 3d 05 00 00
	00		 mov	 DWORD PTR ?GuildInfoBuf@@3PAEA+5, edi
  00373	89 0d 00 00 00
	00		 mov	 DWORD PTR ?GuildInfoOfs@@3HA, ecx ; GuildInfoOfs
  00379	89 15 00 00 00
	00		 mov	 DWORD PTR ?GuildInfoBuf@@3PAEA, edx
  0037f	a2 04 00 00 00	 mov	 BYTE PTR ?GuildInfoBuf@@3PAEA+4, al
  00384	8b 03		 mov	 eax, DWORD PTR [ebx]
  00386	68 00 00 00 00	 push	 OFFSET ?GuildInfoBuf@@3PAEA ; GuildInfoBuf
  0038b	50		 push	 eax
  0038c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00391	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN43@gObjViewpo@4:

; 13213: 		}
; 13214: 
; 13215: 		for (n = 0; n < MVL; n++)

  00394	8b 85 64 ec ff
	ff		 mov	 eax, DWORD PTR _MVL$[ebp]
  0039a	85 c0		 test	 eax, eax
  0039c	7e 73		 jle	 SHORT $LN46@gObjViewpo@4
  0039e	81 c3 16 07 00
	00		 add	 ebx, 1814		; 00000716H
  003a4	8b f8		 mov	 edi, eax
$LL45@gObjViewpo@4:

; 13216: 		{
; 13217: 			if (lpObj->VpPlayer2[n].state != 0)

  003a6	80 7b fe 00	 cmp	 BYTE PTR [ebx-2], 0
  003aa	74 5f		 je	 SHORT $LN16@gObjViewpo@4

; 13218: 			{
; 13219: 				tObjNum = lpObj->VpPlayer2[n].number;

  003ac	0f bf 33	 movsx	 esi, WORD PTR [ebx]

; 13220: 
; 13221: 				if (tObjNum >= 0)

  003af	85 f6		 test	 esi, esi
  003b1	78 58		 js	 SHORT $LN16@gObjViewpo@4

; 13222: 				{
; 13223: 					if (lpObj->VpPlayer2[n].type == OBJ_USER)

  003b3	80 7b 02 01	 cmp	 BYTE PTR [ebx+2], 1
  003b7	75 52		 jne	 SHORT $LN16@gObjViewpo@4

; 13224: 					{
; 13225: 						DataSend(tObjNum, sendBuf, lOfs);

  003b9	8b 8d 68 ec ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  003bf	51		 push	 ecx
  003c0	8d 95 74 ec ff
	ff		 lea	 edx, DWORD PTR _sendBuf$[ebp]
  003c6	52		 push	 edx
  003c7	56		 push	 esi
  003c8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13226: 
; 13227: 						if (GuildInfoCount != 0)

  003d0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GuildInfoCount@@3HA, 0 ; GuildInfoCount
  003d7	74 14		 je	 SHORT $LN11@gObjViewpo@4

; 13228: 						{
; 13229: 							DataSend(tObjNum, GuildInfoBuf, GuildInfoOfs);

  003d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildInfoOfs@@3HA ; GuildInfoOfs
  003de	50		 push	 eax
  003df	68 00 00 00 00	 push	 OFFSET ?GuildInfoBuf@@3PAEA ; GuildInfoBuf
  003e4	56		 push	 esi
  003e5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003ea	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@gObjViewpo@4:

; 13230: 						}
; 13231: 
; 13232: 						if (GuildUserCount != 0)

  003ed	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GuildUserCount@@3HA, 0 ; GuildUserCount
  003f4	74 15		 je	 SHORT $LN16@gObjViewpo@4

; 13233: 						{
; 13234: 							DataSend(tObjNum, GuildUserBuf, GuildUserOfs);

  003f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GuildUserOfs@@3HA ; GuildUserOfs
  003fc	51		 push	 ecx
  003fd	68 00 00 00 00	 push	 OFFSET ?GuildUserBuf@@3PAEA ; GuildUserBuf
  00402	56		 push	 esi
  00403	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00408	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@gObjViewpo@4:

; 13213: 		}
; 13214: 
; 13215: 		for (n = 0; n < MVL; n++)

  0040b	83 c3 0c	 add	 ebx, 12			; 0000000cH
  0040e	4f		 dec	 edi
  0040f	75 95		 jne	 SHORT $LL45@gObjViewpo@4
$LN46@gObjViewpo@4:
  00411	5f		 pop	 edi
  00412	5e		 pop	 esi
  00413	5b		 pop	 ebx

; 13334: 		}
; 13335: 	}
; 13336: }

  00414	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00417	33 cd		 xor	 ecx, ebp
  00419	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0041e	8b e5		 mov	 esp, ebp
  00420	5d		 pop	 ebp
  00421	c3		 ret	 0
$LN27@gObjViewpo@4:

; 13235: 						}
; 13236: 					}
; 13237: 				}
; 13238: 			}
; 13239: 		}
; 13240: 	}
; 13241: 	else
; 13242: 	{
; 13243: 		count = 0;
; 13244: 
; 13245: 		if (lpObj->m_RecallMon >= 0)
; 13246: 		{
; 13247: 			pCallMonsterViewportCreate.NumberH = SET_NUMBERH(lpObj->m_Index);

  00422	8b 13		 mov	 edx, DWORD PTR [ebx]
  00424	c1 ea 08	 shr	 edx, 8
  00427	83 bb cc 02 00
	00 00		 cmp	 DWORD PTR [ebx+716], 0
  0042e	0f 8c 46 01 00
	00		 jl	 $LN8@gObjViewpo@4
  00434	88 15 00 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A, dl

; 13248: 			pCallMonsterViewportCreate.NumberL = SET_NUMBERL(lpObj->m_Index);

  0043a	8a 03		 mov	 al, BYTE PTR [ebx]
  0043c	a2 01 00 00 00	 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+1, al

; 13249: 
; 13250: 			if (lpObj->m_State == 1)

  00441	39 8b bc 01 00
	00		 cmp	 DWORD PTR [ebx+444], ecx
  00447	75 07		 jne	 SHORT $LN7@gObjViewpo@4

; 13251: 			{
; 13252: 				pCallMonsterViewportCreate.NumberH |= 0x80;

  00449	80 0d 00 00 00
	00 80		 or	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A, 128 ; 00000080H
$LN7@gObjViewpo@4:

; 13253: 			}
; 13254: 
; 13255: 			pCallMonsterViewportCreate.Type_HI = SET_NUMBERH(lpObj->Class);

  00450	8a 8b 99 00 00
	00		 mov	 cl, BYTE PTR [ebx+153]
  00456	88 0d 02 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+2, cl

; 13256: 			pCallMonsterViewportCreate.Type_LO = SET_NUMBERL(lpObj->Class);

  0045c	0f b6 93 98 00
	00 00		 movzx	 edx, BYTE PTR [ebx+152]
  00463	88 15 03 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+3, dl

; 13257: 			pCallMonsterViewportCreate.ViewState = lpObj->m_ViewSkillState;

  00469	8b 8b c4 01 00
	00		 mov	 ecx, DWORD PTR [ebx+452]
  0046f	89 0d 04 00 00
	00		 mov	 DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+4, ecx

; 13258: 
; 13259: 			pCallMonsterViewportCreate.X = lpObj->X;

  00475	0f b6 83 04 01
	00 00		 movzx	 eax, BYTE PTR [ebx+260]
  0047c	a2 08 00 00 00	 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+8, al

; 13260: 			pCallMonsterViewportCreate.Y = lpObj->Y;

  00481	0f b6 93 06 01
	00 00		 movzx	 edx, BYTE PTR [ebx+262]
  00488	88 15 09 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+9, dl

; 13261: 
; 13262: 			pCallMonsterViewportCreate.TX = lpObj->TX;

  0048e	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00495	a2 0a 00 00 00	 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+10, al

; 13263: 			pCallMonsterViewportCreate.TY = lpObj->TY;

  0049a	0f b6 93 22 01
	00 00		 movzx	 edx, BYTE PTR [ebx+290]
  004a1	88 15 0b 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+11, dl

; 13264: 
; 13265: 			pCallMonsterViewportCreate.Path = lpObj->Dir << 4;

  004a7	0f b6 83 08 01
	00 00		 movzx	 eax, BYTE PTR [ebx+264]
  004ae	c0 e0 04	 shl	 al, 4
  004b1	a2 0c 00 00 00	 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+12, al

; 13266: 
; 13267: 			if (lpObj->m_RecallMon >= 0 && lpObj->m_RecallMon < OBJMAX - 1)

  004b6	8b 83 cc 02 00
	00		 mov	 eax, DWORD PTR [ebx+716]
  004bc	85 c0		 test	 eax, eax
  004be	78 29		 js	 SHORT $LN6@gObjViewpo@4
  004c0	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  004c5	7d 22		 jge	 SHORT $LN6@gObjViewpo@4

; 13268: 			{
; 13269: 				memcpy(pCallMonsterViewportCreate.Id, gObj[lpObj->m_RecallMon].Name, sizeof(pCallMonsterViewportCreate.Id));

  004c7	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  004cd	05 6f 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+111
  004d2	8b 10		 mov	 edx, DWORD PTR [eax]
  004d4	89 15 0d 00 00
	00		 mov	 DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+13, edx
  004da	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  004dd	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]
  004e1	89 15 11 00 00
	00		 mov	 DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+17, edx

; 13270: 			}
; 13271: 			else

  004e7	eb 0c		 jmp	 SHORT $LN49@gObjViewpo@4
$LN6@gObjViewpo@4:

; 13272: 			{
; 13273: 				memset(pCallMonsterViewportCreate.Id, 0x00, sizeof(pCallMonsterViewportCreate.Id));

  004e9	33 c0		 xor	 eax, eax
  004eb	a3 0d 00 00 00	 mov	 DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+13, eax
  004f0	a3 11 00 00 00	 mov	 DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+17, eax
$LN49@gObjViewpo@4:

; 13274: 			}
; 13275: 
; 13276: 			memcpy(&sendBuf[lOfs], &pCallMonsterViewportCreate, sizeof(pCallMonsterViewportCreate));

  004f5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A
  004fb	66 a3 15 00 00
	00		 mov	 WORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+21, ax
  00501	a1 08 00 00 00	 mov	 eax, DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+8
  00506	89 85 81 ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp+13], eax
  0050c	a1 14 00 00 00	 mov	 eax, DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+20
  00511	89 85 8d ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp+25], eax

; 13304: 			lOfs += sizeof(pMonsterViewportCreate);
; 13305: 			moncount += 1;
; 13306: 		}
; 13307: 
; 13308: 		if (count > 0)
; 13309: 		{
; 13310: 			PWMSG_COUNT pwCount;
; 13311: 
; 13312: 			pwCount.h.c = 0xC2;
; 13313: 			pwCount.h.headcode = 0x1F;
; 13314: 			pwCount.h.sizeH = SET_NUMBERH(lOfs);
; 13315: 			pwCount.h.sizeL = SET_NUMBERL(lOfs);
; 13316: 			pwCount.count = count;

  00517	b0 01		 mov	 al, 1
  00519	89 95 79 ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp+5], edx
  0051f	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+16

; 13317: 
; 13318: 			memcpy(sendBuf, &pwCount, sizeof(pwCount));

  00525	88 85 78 ec ff
	ff		 mov	 BYTE PTR _sendBuf$[ebp+4], al

; 13319: 			MsgSendV2(lpObj, sendBuf, lOfs);

  0052b	6a 1d		 push	 29			; 0000001dH
  0052d	8d 85 74 ec ff
	ff		 lea	 eax, DWORD PTR _sendBuf$[ebp]
  00533	89 8d 7d ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp+9], ecx
  00539	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+12
  0053f	89 95 89 ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp+21], edx
  00545	50		 push	 eax
  00546	c7 85 6c ec ff
	ff c2 00 1d 1f	 mov	 DWORD PTR _pwCount$166475[ebp], 521994434 ; 1f1d00c2H
  00550	8b 95 6c ec ff
	ff		 mov	 edx, DWORD PTR _pwCount$166475[ebp]
  00556	53		 push	 ebx
  00557	89 8d 85 ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp+17], ecx
  0055d	89 95 74 ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp], edx
  00563	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00568	83 c4 0c	 add	 esp, 12			; 0000000cH
  0056b	5b		 pop	 ebx

; 13334: 		}
; 13335: 	}
; 13336: }

  0056c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0056f	33 cd		 xor	 ecx, ebp
  00571	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00576	8b e5		 mov	 esp, ebp
  00578	5d		 pop	 ebp
  00579	c3		 ret	 0
$LN8@gObjViewpo@4:

; 13277: 
; 13278: 			lOfs += sizeof(pCallMonsterViewportCreate);
; 13279: 			count += 1;
; 13280: 		}
; 13281: 		else
; 13282: 		{
; 13283: 			pMonsterViewportCreate.NumberH = SET_NUMBERH(lpObj->m_Index);

  0057a	88 15 00 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A, dl

; 13284: 			pMonsterViewportCreate.NumberL = SET_NUMBERL(lpObj->m_Index);

  00580	8a 03		 mov	 al, BYTE PTR [ebx]
  00582	a2 01 00 00 00	 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+1, al

; 13285: 
; 13286: 			if (lpObj->m_State == 1 && lpObj->Teleport == 0)

  00587	39 8b bc 01 00
	00		 cmp	 DWORD PTR [ebx+444], ecx
  0058d	75 10		 jne	 SHORT $LN3@gObjViewpo@4
  0058f	80 bb 00 02 00
	00 00		 cmp	 BYTE PTR [ebx+512], 0
  00596	75 07		 jne	 SHORT $LN3@gObjViewpo@4

; 13287: 			{
; 13288: 				pMonsterViewportCreate.NumberH |= 0x80;
; 13289: 				pMonsterViewportCreate.NumberH |= 0x40;

  00598	80 0d 00 00 00
	00 c0		 or	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A, 192 ; 000000c0H
$LN3@gObjViewpo@4:

; 13290: 			}
; 13291: 
; 13292: 			pMonsterViewportCreate.Type_HI = SET_NUMBERH(lpObj->Class);

  0059f	0f b6 8b 99 00
	00 00		 movzx	 ecx, BYTE PTR [ebx+153]
  005a6	88 0d 02 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+2, cl

; 13293: 			pMonsterViewportCreate.Type_LO = SET_NUMBERL(lpObj->Class);

  005ac	0f b6 93 98 00
	00 00		 movzx	 edx, BYTE PTR [ebx+152]
  005b3	88 15 03 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+3, dl

; 13294: 
; 13295: 			pMonsterViewportCreate.ViewState = lpObj->m_ViewSkillState;

  005b9	8b 83 c4 01 00
	00		 mov	 eax, DWORD PTR [ebx+452]
  005bf	a3 04 00 00 00	 mov	 DWORD PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+4, eax

; 13296: 			pMonsterViewportCreate.X = lpObj->X;

  005c4	0f b6 8b 04 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+260]
  005cb	88 0d 08 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+8, cl

; 13297: 			pMonsterViewportCreate.Y = lpObj->Y;

  005d1	0f b6 93 06 01
	00 00		 movzx	 edx, BYTE PTR [ebx+262]
  005d8	88 15 09 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+9, dl

; 13298: 			pMonsterViewportCreate.TX = lpObj->TX;

  005de	0f b6 8b 20 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+288]
  005e5	88 0d 0a 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+10, cl

; 13299: 			pMonsterViewportCreate.TY = lpObj->TY;

  005eb	0f b6 93 22 01
	00 00		 movzx	 edx, BYTE PTR [ebx+290]
  005f2	88 15 0b 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+11, dl

; 13300: 
; 13301: 			pMonsterViewportCreate.Path = lpObj->Dir << 4;

  005f8	0f b6 8b 08 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+264]

; 13302: 
; 13303: 			memcpy(&sendBuf[lOfs], &pMonsterViewportCreate, sizeof(pMonsterViewportCreate));

  005ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A
  00605	c0 e1 04	 shl	 cl, 4
  00608	88 0d 0c 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+12, cl
  0060e	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+12
  00614	89 85 7d ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp+9], eax
  0061a	a1 08 00 00 00	 mov	 eax, DWORD PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+8
  0061f	89 95 79 ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp+5], edx

; 13320: 		}
; 13321: 
; 13322: 		if (moncount > 0)
; 13323: 		{
; 13324: 			PWMSG_COUNT pwCount;
; 13325: 
; 13326: 			pwCount.h.c = 0xC2;
; 13327: 			pwCount.h.headcode = 0x13;
; 13328: 			pwCount.h.sizeH = SET_NUMBERH(lOfs);
; 13329: 			pwCount.h.sizeL = SET_NUMBERL(lOfs);
; 13330: 			pwCount.count = moncount;
; 13331: 
; 13332: 			memcpy(sendBuf, &pwCount, sizeof(pwCount));
; 13333: 			MsgSendV2(lpObj, sendBuf, lOfs);

  00625	6a 15		 push	 21			; 00000015H
  00627	8d 95 74 ec ff
	ff		 lea	 edx, DWORD PTR _sendBuf$[ebp]
  0062d	89 85 81 ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp+13], eax
  00633	89 8d 85 ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp+17], ecx
  00639	52		 push	 edx
  0063a	c7 85 6c ec ff
	ff c2 00 15 13	 mov	 DWORD PTR _pwCount$166482[ebp], 320143554 ; 131500c2H
  00644	8b 8d 6c ec ff
	ff		 mov	 ecx, DWORD PTR _pwCount$166482[ebp]
  0064a	b0 01		 mov	 al, 1
  0064c	53		 push	 ebx
  0064d	89 8d 74 ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp], ecx
  00653	88 85 78 ec ff
	ff		 mov	 BYTE PTR _sendBuf$[ebp+4], al
  00659	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 13334: 		}
; 13335: 	}
; 13336: }

  0065e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00661	83 c4 0c	 add	 esp, 12			; 0000000cH
  00664	33 cd		 xor	 ecx, ebp
  00666	5b		 pop	 ebx
  00667	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0066c	8b e5		 mov	 esp, ebp
  0066e	5d		 pop	 ebp
  0066f	c3		 ret	 0
?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ENDP ; gObjViewportListProtocolCreate
_TEXT	ENDS
PUBLIC	?gObjTeleportMagicUse@@YAXHEE@Z			; gObjTeleportMagicUse
; Function compile flags: /Ogtp
;	COMDAT ?gObjTeleportMagicUse@@YAXHEE@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_x$ = 12						; size = 1
_y$ = 16						; size = 1
?gObjTeleportMagicUse@@YAXHEE@Z PROC			; gObjTeleportMagicUse, COMDAT

; 14415: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 14416: 
; 14417: 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0000d	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 14418: 
; 14419: 	if(lpObj->Teleport != 0)

  00013	80 be 00 02 00
	00 00		 cmp	 BYTE PTR [esi+512], 0
  0001a	0f 85 c3 00 00
	00		 jne	 $LN2@gObjTelepo

; 14420: 	{
; 14421: 		return;
; 14422: 	}
; 14423: 
; 14424: 	lpObj->TeleportTime = GetTickCount();

  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 14425: 	lpObj->PathCount = 0;
; 14426: 	lpObj->Teleport = 1;
; 14427: 	lpObj->m_StateSub = 1;
; 14428: 	lpObj->m_ViewState = 1;
; 14429: 
; 14430: 	lpObj->X = x;
; 14431: 	lpObj->Y = y;

  00026	0f b6 4d 10	 movzx	 ecx, BYTE PTR _y$[ebp]
  0002a	89 86 fc 01 00
	00		 mov	 DWORD PTR [esi+508], eax
  00030	b0 01		 mov	 al, 1
  00032	88 86 00 02 00
	00		 mov	 BYTE PTR [esi+512], al
  00038	88 86 c0 01 00
	00		 mov	 BYTE PTR [esi+448], al
  0003e	88 86 c2 01 00
	00		 mov	 BYTE PTR [esi+450], al
  00044	0f b6 45 0c	 movzx	 eax, BYTE PTR _x$[ebp]
  00048	66 89 8e 06 01
	00 00		 mov	 WORD PTR [esi+262], cx

; 14432: 	lpObj->TX = x;
; 14433: 	lpObj->TY = y;

  0004f	66 89 8e 22 01
	00 00		 mov	 WORD PTR [esi+290], cx

; 14434: 
; 14435: 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX,lpObj->m_OldY);

  00056	0f bf 8e 1c 01
	00 00		 movsx	 ecx, WORD PTR [esi+284]
  0005d	66 89 86 04 01
	00 00		 mov	 WORD PTR [esi+260], ax
  00064	66 89 86 20 01
	00 00		 mov	 WORD PTR [esi+288], ax
  0006b	0f bf 86 1e 01
	00 00		 movsx	 eax, WORD PTR [esi+286]
  00072	50		 push	 eax
  00073	51		 push	 ecx
  00074	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  0007b	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00081	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00087	c7 86 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+296], 0
  00091	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 14436: 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->TX,lpObj->TY);

  00096	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  0009d	0f bf 96 22 01
	00 00		 movsx	 edx, WORD PTR [esi+290]
  000a4	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  000aa	0f bf 86 20 01
	00 00		 movsx	 eax, WORD PTR [esi+288]
  000b1	52		 push	 edx
  000b2	50		 push	 eax
  000b3	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000b9	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 14437: 
; 14438: 	lpObj->m_OldX = lpObj->TX;

  000be	0f b7 8e 20 01
	00 00		 movzx	 ecx, WORD PTR [esi+288]

; 14439: 	lpObj->m_OldY = lpObj->TY;

  000c5	66 8b 96 22 01
	00 00		 mov	 dx, WORD PTR [esi+290]

; 14440: 
; 14441: 	gObjViewportListProtocolDestroy(lpObj);

  000cc	56		 push	 esi
  000cd	66 89 8e 1c 01
	00 00		 mov	 WORD PTR [esi+284], cx
  000d4	66 89 96 1e 01
	00 00		 mov	 WORD PTR [esi+286], dx
  000db	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy
  000e0	83 c4 04	 add	 esp, 4
$LN2@gObjTelepo:
  000e3	5e		 pop	 esi

; 14442: }

  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
?gObjTeleportMagicUse@@YAXHEE@Z ENDP			; gObjTeleportMagicUse
_TEXT	ENDS
PUBLIC	??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@ ; `string'
PUBLIC	??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@ ; `string'
PUBLIC	??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	?gObjTeleport@@YAXHHHH@Z			; gObjTeleport
EXTRN	?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z:PROC ; GCTeleportSend
EXTRN	?CGWarehouseUseEnd@@YAXH@Z:PROC			; CGWarehouseUseEnd
EXTRN	?CGTradeCancelButtonRecv@@YAXH@Z:PROC		; CGTradeCancelButtonRecv
EXTRN	?GJReqMapSvrMove@@YAXHGGEE@Z:PROC		; GJReqMapSvrMove
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?CheckMoveMapSvr@CMapServerManager@@QAEFHHF@Z:PROC ; CMapServerManager::CheckMoveMapSvr
EXTRN	?g_MapServerManager@@3VCMapServerManager@@A:BYTE ; g_MapServerManager
EXTRN	?MapNumberCheck@@YAHH@Z:PROC			; MapNumberCheck
;	COMDAT ??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@
CONST	SEGMENT
??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@ DB '[MapSe'
	DB	'rverMng] Request to Move Map Server : (%d) - [%s][%s] (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@
CONST	SEGMENT
??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@ DB '[MapSe'
	DB	'rverMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s]['
	DB	'%s] (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ DB 'error-L3 : %s %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjTeleport@@YAXHHHH@Z
_TEXT	SEGMENT
_sSvrCode$166914 = 8					; size = 2
_aIndex$ = 8						; size = 4
_map$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?gObjTeleport@@YAXHHHH@Z PROC				; gObjTeleport, COMDAT

; 14980: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 14981: 
; 14982: 	if(aIndex < 0 || aIndex > OBJMAX - 1)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  0000d	0f 87 b6 01 00
	00		 ja	 $LN8@gObjTelepo@2

; 14983: 	{
; 14984: 		return;
; 14985: 	}
; 14986: 
; 14987: 	LPOBJ lpObj = &gObj[aIndex];

  00013	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00019	53		 push	 ebx

; 14988: 	
; 14989: 	if(MapNumberCheck(map)==0)

  0001a	8b 5d 0c	 mov	 ebx, DWORD PTR _map$[ebp]
  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	8d be 00 00 00
	00		 lea	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00025	e8 00 00 00 00	 call	 ?MapNumberCheck@@YAHH@Z	; MapNumberCheck
  0002a	83 c4 04	 add	 esp, 4
  0002d	85 c0		 test	 eax, eax
  0002f	75 1d		 jne	 SHORT $LN7@gObjTelepo@2

; 14990: 	{
; 14991: 		LogAdd(LOG_BLACK, "error-L3 : %s %d",__FILE__,__LINE__);

  00031	68 8f 3a 00 00	 push	 14991			; 00003a8fH
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00046	83 c4 10	 add	 esp, 16			; 00000010H
  00049	5f		 pop	 edi
  0004a	5b		 pop	 ebx
  0004b	5e		 pop	 esi

; 15047: }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN7@gObjTelepo@2:

; 14992: 		return;
; 14993: 	}
; 14994: 
; 14995: 	if(gObj[aIndex].MapNumber != map)

  0004e	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]
  00055	3b c3		 cmp	 eax, ebx
  00057	0f 84 80 00 00
	00		 je	 $LN5@gObjTelepo@2

; 14996: 	{
; 14997: 		short sSvrCode = g_MapServerManager.CheckMoveMapSvr(lpObj->m_Index,map,lpObj->m_sPrevMapSvrCode);

  0005d	0f b7 8f cc 14
	00 00		 movzx	 ecx, WORD PTR [edi+5324]
  00064	8b 17		 mov	 edx, DWORD PTR [edi]
  00066	51		 push	 ecx
  00067	53		 push	 ebx
  00068	52		 push	 edx
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  0006e	e8 00 00 00 00	 call	 ?CheckMoveMapSvr@CMapServerManager@@QAEFHHF@Z ; CMapServerManager::CheckMoveMapSvr
  00073	0f b7 c0	 movzx	 eax, ax
  00076	89 45 08	 mov	 DWORD PTR _sSvrCode$166914[ebp], eax

; 14998: 
; 14999: 		if(sSvrCode != gGameServerCode)

  00079	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00080	74 5b		 je	 SHORT $LN5@gObjTelepo@2

; 15000: 		{
; 15001: 			if(sSvrCode == -1)

  00082	66 83 f8 ff	 cmp	 ax, -1
  00086	75 1f		 jne	 SHORT $LN4@gObjTelepo@2

; 15002: 			{
; 15003: 				LogAdd(LOG_RED, "[MapServerMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s][%s] (%d)",lpObj->AccountID,lpObj->Name,lpObj->m_Index);

  00088	8b 07		 mov	 eax, DWORD PTR [edi]
  0008a	50		 push	 eax
  0008b	8d 4f 6f	 lea	 ecx, DWORD PTR [edi+111]
  0008e	51		 push	 ecx
  0008f	83 c7 64	 add	 edi, 100		; 00000064H
  00092	57		 push	 edi
  00093	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@
  00098	6a 01		 push	 1
  0009a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0009f	83 c4 14	 add	 esp, 20			; 00000014H
  000a2	5f		 pop	 edi
  000a3	5b		 pop	 ebx
  000a4	5e		 pop	 esi

; 15047: }

  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
$LN4@gObjTelepo@2:

; 15004: 				return;
; 15005: 			}
; 15006: 
; 15007: 			GJReqMapSvrMove(lpObj->m_Index,sSvrCode,map,x,y);

  000a7	8b 55 14	 mov	 edx, DWORD PTR _y$[ebp]
  000aa	8b 4d 10	 mov	 ecx, DWORD PTR _x$[ebp]
  000ad	52		 push	 edx
  000ae	8b 17		 mov	 edx, DWORD PTR [edi]
  000b0	51		 push	 ecx
  000b1	53		 push	 ebx
  000b2	50		 push	 eax
  000b3	52		 push	 edx
  000b4	e8 00 00 00 00	 call	 ?GJReqMapSvrMove@@YAXHGGEE@Z ; GJReqMapSvrMove

; 15008: 			LogAdd(LOG_BLACK, "[MapServerMng] Request to Move Map Server : (%d) - [%s][%s] (%d)",sSvrCode,lpObj->AccountID,lpObj->Name,lpObj->m_Index);

  000b9	8b 07		 mov	 eax, DWORD PTR [edi]
  000bb	0f bf 55 08	 movsx	 edx, WORD PTR _sSvrCode$166914[ebp]
  000bf	50		 push	 eax
  000c0	8d 4f 6f	 lea	 ecx, DWORD PTR [edi+111]
  000c3	51		 push	 ecx
  000c4	83 c7 64	 add	 edi, 100		; 00000064H
  000c7	57		 push	 edi
  000c8	52		 push	 edx
  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@
  000ce	6a 00		 push	 0
  000d0	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000d5	83 c4 2c	 add	 esp, 44			; 0000002cH
  000d8	5f		 pop	 edi
  000d9	5b		 pop	 ebx
  000da	5e		 pop	 esi

; 15047: }

  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
$LN5@gObjTelepo@2:

; 15009: 			return;
; 15010: 		}
; 15011: 	}
; 15012: 
; 15013: 	if(lpObj->m_IfState.use == 1 && lpObj->m_IfState.type == 1)

  000dd	8b 87 84 0c 00
	00		 mov	 eax, DWORD PTR [edi+3204]
  000e3	8b c8		 mov	 ecx, eax
  000e5	80 e1 03	 and	 cl, 3
  000e8	80 f9 01	 cmp	 cl, 1
  000eb	75 15		 jne	 SHORT $LN12@gObjTelepo@2
  000ed	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000f2	83 f8 40	 cmp	 eax, 64			; 00000040H
  000f5	75 0b		 jne	 SHORT $LN12@gObjTelepo@2

; 15014: 	{
; 15015: 		CGTradeCancelButtonRecv(lpObj->m_Index);

  000f7	8b 17		 mov	 edx, DWORD PTR [edi]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv
  000ff	83 c4 04	 add	 esp, 4
$LN12@gObjTelepo@2:

; 15016: 	}
; 15017: 
; 15018: 	if(lpObj->m_IfState.use == 1 && lpObj->m_IfState.type == 6)

  00102	8b 87 84 0c 00
	00		 mov	 eax, DWORD PTR [edi+3204]
  00108	8b c8		 mov	 ecx, eax
  0010a	80 e1 03	 and	 cl, 3
  0010d	80 f9 01	 cmp	 cl, 1
  00110	75 17		 jne	 SHORT $LN2@gObjTelepo@2
  00112	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00117	3d 80 01 00 00	 cmp	 eax, 384		; 00000180H
  0011c	75 0b		 jne	 SHORT $LN2@gObjTelepo@2

; 15019: 	{
; 15020: 		CGWarehouseUseEnd(lpObj->m_Index);

  0011e	8b 17		 mov	 edx, DWORD PTR [edi]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 ?CGWarehouseUseEnd@@YAXH@Z ; CGWarehouseUseEnd
  00126	83 c4 04	 add	 esp, 4
$LN2@gObjTelepo@2:

; 15021: 	}
; 15022: 
; 15023: 	lpObj->m_State = 32;
; 15024: 	gObj[aIndex].X = x;

  00129	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]

; 15025: 	gObj[aIndex].Y = y;

  0012c	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  0012f	c7 87 bc 01 00
	00 20 00 00 00	 mov	 DWORD PTR [edi+444], 32	; 00000020H

; 15026: 
; 15027: 	gObj[aIndex].TX = x;
; 15028: 	gObj[aIndex].TY = y;
; 15029: 
; 15030: 	gObj[aIndex].MapNumber = map;
; 15031: 	gObj[aIndex].PathCount = 0;
; 15032: 	gObj[aIndex].Teleport = 0;
; 15033: 
; 15034: 	gObjClearViewport(&gObj[aIndex]);

  00139	57		 push	 edi
  0013a	66 89 86 04 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260], ax
  00141	66 89 8e 06 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262], cx
  00148	66 89 86 20 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+288], ax
  0014f	66 89 8e 22 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+290], cx
  00156	88 9e 09 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265], bl
  0015c	c7 86 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+296], 0
  00166	c6 86 00 02 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+512], 0
  0016d	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport

; 15035: 
; 15036: 	GCTeleportSend(&gObj[aIndex],1,map,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);

  00172	0f b6 86 08 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+264]
  00179	0f b6 8e 06 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  00180	0f b6 96 04 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  00187	50		 push	 eax
  00188	51		 push	 ecx
  00189	52		 push	 edx
  0018a	53		 push	 ebx
  0018b	6a 01		 push	 1
  0018d	57		 push	 edi
  0018e	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend
  00193	83 c4 1c	 add	 esp, 28			; 0000001cH

; 15037: 
; 15038: 	if(lpObj->m_Change >= 0)

  00196	83 bf d0 02 00
	00 00		 cmp	 DWORD PTR [edi+720], 0
  0019d	7c 09		 jl	 SHORT $LN1@gObjTelepo@2

; 15039: 	{
; 15040: 		gObjViewportListProtocolCreate(&gObj[aIndex]);

  0019f	57		 push	 edi
  001a0	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  001a5	83 c4 04	 add	 esp, 4
$LN1@gObjTelepo@2:

; 15041: 	}
; 15042: 
; 15043: 	gObj[aIndex].RegenMapNumber = map;
; 15044: 	gObj[aIndex].RegenMapX = x;

  001a8	8a 45 10	 mov	 al, BYTE PTR _x$[ebp]

; 15045: 	gObj[aIndex].RegenMapY = y;

  001ab	8a 4d 14	 mov	 cl, BYTE PTR _y$[ebp]
  001ae	5f		 pop	 edi
  001af	88 9e 04 02 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+516], bl
  001b5	88 86 05 02 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+517], al
  001bb	88 8e 06 02 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+518], cl

; 15046: 	gObj[aIndex].RegenOk = 1;

  001c1	c6 86 03 02 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+515], 1
  001c8	5b		 pop	 ebx
$LN8@gObjTelepo@2:
  001c9	5e		 pop	 esi

; 15047: }

  001ca	5d		 pop	 ebp
  001cb	c3		 ret	 0
?gObjTeleport@@YAXHHHH@Z ENDP				; gObjTeleport
_TEXT	ENDS
PUBLIC	?gObjMoveDataLoadingOK@@YAXH@Z			; gObjMoveDataLoadingOK
; Function compile flags: /Ogtp
;	COMDAT ?gObjMoveDataLoadingOK@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjMoveDataLoadingOK@@YAXH@Z PROC			; gObjMoveDataLoadingOK, COMDAT

; 15050: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15051: 	if(gObj[aIndex].RegenOk == 1)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0000c	80 b8 03 02 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+515], 1
  00013	8d 80 03 02 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+515]
  00019	75 03		 jne	 SHORT $LN1@gObjMoveDa

; 15052: 	{
; 15053: 		gObj[aIndex].RegenOk = 2;

  0001b	c6 00 02	 mov	 BYTE PTR [eax], 2
$LN1@gObjMoveDa:

; 15054: 	}
; 15055: }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?gObjMoveDataLoadingOK@@YAXH@Z ENDP			; gObjMoveDataLoadingOK
_TEXT	ENDS
PUBLIC	?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_mIndex$ = 12						; size = 4
?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z PROC ; gObjGetMagic, COMDAT

; 15058: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15059: 	if ( mIndex < 0 || mIndex > MAX_MAGIC-1 )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _mIndex$[ebp]
  00006	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00009	77 2b		 ja	 SHORT $LN2@gObjGetMag

; 15063: 	}
; 15064: 
; 15065: 	if ( lpObj->Magic[mIndex].IsMagic() == FALSE )

  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00010	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  00016	c1 e0 04	 shl	 eax, 4
  00019	8b f0		 mov	 esi, eax
  0001b	03 ce		 add	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  00022	85 c0		 test	 eax, eax
  00024	75 04		 jne	 SHORT $LN1@gObjGetMag
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 15071: }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
$LN1@gObjGetMag:

; 15066: 	{
; 15067: 		return NULL;
; 15068: 	}
; 15069: 
; 15070: 	return &lpObj->Magic[mIndex];

  0002a	8b 87 38 03 00
	00		 mov	 eax, DWORD PTR [edi+824]
  00030	5f		 pop	 edi
  00031	03 c6		 add	 eax, esi
  00033	5e		 pop	 esi

; 15071: }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN2@gObjGetMag:

; 15060: 	{
; 15061: 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2, 34)), __FILE__, __LINE__);

  00036	68 d5 3a 00 00	 push	 15061			; 00003ad5H
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00040	68 22 02 00 00	 push	 546			; 00000222H
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0004a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0004f	50		 push	 eax
  00050	6a 00		 push	 0
  00052	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00057	83 c4 10	 add	 esp, 16			; 00000010H

; 15062: 		return NULL;

  0005a	33 c0		 xor	 eax, eax

; 15071: }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ENDP ; gObjGetMagic
_TEXT	ENDS
PUBLIC	?gObjMagicManaUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicManaUse
EXTRN	?SkillGetMana@CMagicDamage@@QAEHH@Z:PROC	; CMagicDamage::SkillGetMana
EXTRN	?MagicDamageC@@3VCMagicDamage@@A:BYTE		; MagicDamageC
; Function compile flags: /Ogtp
;	COMDAT ?gObjMagicManaUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z
_TEXT	SEGMENT
tv130 = -8						; size = 8
tv144 = 8						; size = 4
_mana$ = 8						; size = 4
_lpObj$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?gObjMagicManaUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z PROC ; gObjMagicManaUse, COMDAT

; 15103: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 15104: 	float mana = lpObj->Mana;

  00006	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]

; 15105: 
; 15106: 	if(lpObj->Type != OBJ_USER)

  00009	66 83 78 60 01	 cmp	 WORD PTR [eax+96], 1
  0000e	d9 80 d0 00 00
	00		 fld	 DWORD PTR [eax+208]
  00014	d9 5d 08	 fstp	 DWORD PTR _mana$[ebp]
  00017	74 06		 je	 SHORT $LN3@gObjMagicM
$LN9@gObjMagicM:

; 15107: 	{
; 15108: 		return false;

  00019	33 c0		 xor	 eax, eax

; 15123: }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN3@gObjMagicM:

; 15109: 	}
; 15110: 
; 15111: 	if(lpMagic == 0)

  0001f	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00022	85 c0		 test	 eax, eax

; 15112: 	{
; 15113: 		return false;

  00024	74 f3		 je	 SHORT $LN9@gObjMagicM

; 15114: 	}
; 15115: 	mana -= MagicDamageC.SkillGetMana(lpMagic->m_Skill);

  00026	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  0002a	d9 45 08	 fld	 DWORD PTR _mana$[ebp]
  0002d	50		 push	 eax
  0002e	dd 5d f8	 fstp	 QWORD PTR tv130[ebp]
  00031	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00036	e8 00 00 00 00	 call	 ?SkillGetMana@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetMana
  0003b	89 45 08	 mov	 DWORD PTR tv144[ebp], eax
  0003e	db 45 08	 fild	 DWORD PTR tv144[ebp]
  00041	dc 6d f8	 fsubr	 QWORD PTR tv130[ebp]
  00044	d9 5d 08	 fstp	 DWORD PTR _mana$[ebp]

; 15116: 
; 15117: 	if(mana < 0)

  00047	d9 ee		 fldz
  00049	d9 45 08	 fld	 DWORD PTR _mana$[ebp]
  0004c	d8 d1		 fcom	 ST(1)
  0004e	df e0		 fnstsw	 ax
  00050	dd d9		 fstp	 ST(1)
  00052	f6 c4 05	 test	 ah, 5
  00055	7a 09		 jp	 SHORT $LN1@gObjMagicM
  00057	dd d8		 fstp	 ST(0)

; 15118: 	{
; 15119: 		return -1;

  00059	83 c8 ff	 or	 eax, -1

; 15123: }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN1@gObjMagicM:

; 15120: 	}
; 15121: 
; 15122: 	return mana;

  00060	e8 00 00 00 00	 call	 __ftol2_sse

; 15123: }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?gObjMagicManaUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ENDP ; gObjMagicManaUse
_TEXT	ENDS
PUBLIC	?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicBPUse
EXTRN	?SkillGetBP@CMagicDamage@@QAEHH@Z:PROC		; CMagicDamage::SkillGetBP
; Function compile flags: /Ogtp
;	COMDAT ?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z PROC ; gObjMagicBPUse, COMDAT

; 15126: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15127: 	int bp = lpObj->BP;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]

; 15128: 
; 15129: 	if(lpObj->Type != OBJ_USER)

  00006	66 83 78 60 01	 cmp	 WORD PTR [eax+96], 1
  0000b	56		 push	 esi
  0000c	8b b0 e8 00 00
	00		 mov	 esi, DWORD PTR [eax+232]
  00012	74 05		 je	 SHORT $LN3@gObjMagicB
$LN6@gObjMagicB:

; 15130: 	{
; 15131: 		return false;

  00014	33 c0		 xor	 eax, eax
  00016	5e		 pop	 esi

; 15147: }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN3@gObjMagicB:

; 15132: 	}
; 15133: 
; 15134: 	if(lpMagic == 0)

  00019	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0001c	85 c0		 test	 eax, eax

; 15135: 	{
; 15136: 		return false;

  0001e	74 f4		 je	 SHORT $LN6@gObjMagicB

; 15137: 	}
; 15138: 
; 15139: 	bp -= MagicDamageC.SkillGetBP(lpMagic->m_Skill);

  00020	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  00024	50		 push	 eax
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0002a	e8 00 00 00 00	 call	 ?SkillGetBP@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetBP
  0002f	2b f0		 sub	 esi, eax

; 15140: 
; 15141: 	if(bp < 0)

  00031	79 06		 jns	 SHORT $LN1@gObjMagicB

; 15142: 	{
; 15143: 		return -1;

  00033	83 c8 ff	 or	 eax, -1
  00036	5e		 pop	 esi

; 15147: }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN1@gObjMagicB:

; 15144: 	}
; 15145: 
; 15146: 	return bp;

  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi

; 15147: }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ENDP ; gObjMagicBPUse
_TEXT	ENDS
PUBLIC	_lpMagic$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjPosMagicAttack@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@EE@Z ; gObjPosMagicAttack
; Function compile flags: /Ogtp
;	COMDAT ?gObjPosMagicAttack@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@EE@Z
_TEXT	SEGMENT
_lpMagic$GSCopy$ = -300					; size = 4
_n$ = -296						; size = 4
tv424 = -292						; size = 4
_MVL$ = -288						; size = 4
tv427 = -284						; size = 4
_tx$ = -284						; size = 4
_lOfs$ = -280						; size = 4
_pResult$ = -276					; size = 2
_pCount$ = -272						; size = 9
_sbuf$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
?gObjPosMagicAttack@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@EE@Z PROC ; gObjPosMagicAttack, COMDAT

; 15172: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]

; 15173: 	int tObjNum;
; 15174: 	int dis;
; 15175: 	int tx;
; 15176: 	int ty;
; 15177: 	int MagicDistance;
; 15178: 	unsigned char sbuf[256];
; 15179: 	int lOfs;
; 15180: 	unsigned char MagicNumber;
; 15181: 	PMSG_POSMAGIC_COUNT pCount;
; 15182: 	PMSG_POSMAGIC_RESULT pResult;
; 15183: 	int MVL;
; 15184: 	int n;
; 15185: 
; 15186: 	MagicDistance = 3;
; 15187: 	lOfs = 0;
; 15188: 	MagicNumber = lpMagic->m_Skill;
; 15189: 
; 15190: 	switch(MagicNumber)
; 15191: 	{
; 15192: 	case 9: MagicDistance = 3;
; 15193: 		break;
; 15194: 	default: MagicDistance = 3;
; 15195: 		break;
; 15196: 	}
; 15197: 
; 15198: 	lOfs = sizeof(pCount);
; 15199: 	pCount.h.c = 0xC1;
; 15200: 	pCount.h.headcode = 0x1A;
; 15201: 	pCount.h.size = 0;
; 15202: 
; 15203: 	pCount.MapX = x;

  00016	8a 4d 10	 mov	 cl, BYTE PTR _x$[ebp]

; 15204: 	pCount.MapY = y;

  00019	8a 55 14	 mov	 dl, BYTE PTR _y$[ebp]
  0001c	53		 push	 ebx
  0001d	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _lpMagic$GSCopy$[ebp], eax
  00023	8a 40 05	 mov	 al, BYTE PTR [eax+5]
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]

; 15205: 	pCount.MagicNumber = MagicNumber;

  0002b	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], al

; 15206: 	pCount.NumberH = SET_NUMBERH(lpObj->m_Index);

  00031	8b 07		 mov	 eax, DWORD PTR [edi]
  00033	88 8d f6 fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+6], cl

; 15207: 	pCount.NumberL = SET_NUMBERL(lpObj->m_Index);

  00039	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0003c	c1 e8 08	 shr	 eax, 8

; 15208: 	pCount.Count = 0;
; 15209: 
; 15210: 	MVL = MAX_VIEWPORT;
; 15211: 
; 15212: 	if(lpObj->Type == OBJ_MONSTER)

  0003f	66 83 7f 60 02	 cmp	 WORD PTR [edi+96], 2
  00044	bb 09 00 00 00	 mov	 ebx, 9
  00049	89 9d e8 fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], ebx
  0004f	c6 85 f0 fe ff
	ff c1		 mov	 BYTE PTR _pCount$[ebp], 193 ; 000000c1H
  00056	66 c7 85 f1 fe
	ff ff 00 1a	 mov	 WORD PTR _pCount$[ebp+1], 6656 ; 00001a00H
  0005f	88 95 f7 fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+7], dl
  00065	88 85 f3 fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+3], al
  0006b	88 8d f4 fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+4], cl
  00071	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR _pCount$[ebp+8], 0
  00078	c7 85 e0 fe ff
	ff 4b 00 00 00	 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH
  00082	75 0a		 jne	 SHORT $LN11@gObjPosMag

; 15213: 	{
; 15214: 		MVL = MAX_VIEWPORT_MONSTER;

  00084	c7 85 e0 fe ff
	ff 14 00 00 00	 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN11@gObjPosMag:

; 15215: 	}
; 15216: 
; 15217: 	for(n = 0; n < MVL; n++)

  0008e	83 bd e0 fe ff
	ff 00		 cmp	 DWORD PTR _MVL$[ebp], 0
  00095	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  0009f	0f 8e 18 01 00
	00		 jle	 $LN8@gObjPosMag
  000a5	8d 87 92 03 00
	00		 lea	 eax, DWORD PTR [edi+914]
  000ab	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv424[ebp], eax
$LL26@gObjPosMag:

; 15218: 	{
; 15219: 		if(lpObj->VpPlayer[n].state)

  000b1	80 78 fe 00	 cmp	 BYTE PTR [eax-2], 0
  000b5	0f 84 d4 00 00
	00		 je	 $LN9@gObjPosMag

; 15220: 		{
; 15221: 			tObjNum = lpObj->VpPlayer[n].number;

  000bb	0f bf 18	 movsx	 ebx, WORD PTR [eax]

; 15222: 
; 15223: 			if(tObjNum >= 0)

  000be	85 db		 test	 ebx, ebx
  000c0	0f 88 c9 00 00
	00		 js	 $LN9@gObjPosMag

; 15224: 			{
; 15225: 				if(gObj[tObjNum].Live)

  000c6	8b f3		 mov	 esi, ebx
  000c8	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000ce	80 be 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+98], 0
  000d5	0f 84 b4 00 00
	00		 je	 $LN9@gObjPosMag

; 15226: 				{
; 15227: 					tx = lpObj->X - gObj[tObjNum].X;

  000db	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  000e2	0f bf 87 04 01
	00 00		 movsx	 eax, WORD PTR [edi+260]

; 15228: 					ty = lpObj->Y - gObj[tObjNum].Y;

  000e9	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  000f0	2b c2		 sub	 eax, edx
  000f2	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _tx$[ebp], eax
  000f8	0f bf 87 06 01
	00 00		 movsx	 eax, WORD PTR [edi+262]
  000ff	db 85 e4 fe ff
	ff		 fild	 DWORD PTR _tx$[ebp]
  00105	2b c1		 sub	 eax, ecx

; 15229: 
; 15230: 					dis = sqrt((double)tx*tx + ty*ty);

  00107	0f af c0	 imul	 eax, eax

; 15231: 
; 15232: 					if(dis <= MagicDistance)

  0010a	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv427[ebp], eax
  00110	db 85 e4 fe ff
	ff		 fild	 DWORD PTR tv427[ebp]
  00116	d9 c1		 fld	 ST(1)
  00118	de ca		 fmulp	 ST(2), ST(0)
  0011a	de c1		 faddp	 ST(1), ST(0)
  0011c	e8 00 00 00 00	 call	 __CIsqrt
  00121	e8 00 00 00 00	 call	 __ftol2_sse
  00126	83 f8 03	 cmp	 eax, 3
  00129	7f 64		 jg	 SHORT $LN9@gObjPosMag

; 15233: 					{
; 15234: 						if(gObjAttack(lpObj,&gObj[tObjNum],lpMagic,0,0,0,0) == 1)

  0012b	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMagic$GSCopy$[ebp]
  00131	6a 00		 push	 0
  00133	6a 00		 push	 0
  00135	6a 00		 push	 0
  00137	6a 00		 push	 0
  00139	52		 push	 edx
  0013a	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00140	50		 push	 eax
  00141	57		 push	 edi
  00142	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  00147	83 c4 1c	 add	 esp, 28			; 0000001cH
  0014a	83 f8 01	 cmp	 eax, 1
  0014d	75 40		 jne	 SHORT $LN9@gObjPosMag

; 15235: 						{
; 15236: 							pResult.NumberH = SET_NUMBERH(tObjNum);
; 15237: 							pResult.NumberL = SET_NUMBERL(tObjNum);
; 15238: 
; 15239: 							memcpy(&sbuf[lOfs],&pResult,sizeof(pResult));

  0014f	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]

; 15240: 							pCount.Count++;

  00155	fe 85 f8 fe ff
	ff		 inc	 BYTE PTR _pCount$[ebp+8]
  0015b	8b cb		 mov	 ecx, ebx
  0015d	c1 e9 08	 shr	 ecx, 8
  00160	88 8d ec fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp], cl
  00166	88 9d ed fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], bl
  0016c	66 8b 95 ec fe
	ff ff		 mov	 dx, WORD PTR _pResult$[ebp]
  00173	66 89 94 05 fc
	fe ff ff	 mov	 WORD PTR _sbuf$[ebp+eax], dx

; 15241: 							lOfs+=sizeof(pResult);

  0017b	83 c0 02	 add	 eax, 2
  0017e	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 15242: 
; 15243: 							if(lOfs > 250)

  00184	3d fa 00 00 00	 cmp	 eax, 250		; 000000faH
  00189	0f 8f 99 00 00
	00		 jg	 $LN19@gObjPosMag
$LN9@gObjPosMag:

; 15215: 	}
; 15216: 
; 15217: 	for(n = 0; n < MVL; n++)

  0018f	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  00195	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv424[ebp]
  0019b	41		 inc	 ecx
  0019c	83 c0 0c	 add	 eax, 12			; 0000000cH
  0019f	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], ecx
  001a5	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv424[ebp], eax
  001ab	3b 8d e0 fe ff
	ff		 cmp	 ecx, DWORD PTR _MVL$[ebp]
  001b1	0f 8c fa fe ff
	ff		 jl	 $LL26@gObjPosMag

; 15242: 
; 15243: 							if(lOfs > 250)

  001b7	8b 9d e8 fe ff
	ff		 mov	 ebx, DWORD PTR _lOfs$[ebp]
$LN8@gObjPosMag:

; 15246: 								return false;
; 15247: 							}
; 15248: 						}
; 15249: 					}
; 15250: 				}
; 15251: 			}
; 15252: 		}
; 15253: 	}
; 15254: 
; 15255: 	pCount.h.size = lOfs;
; 15256: 
; 15257: 	memcpy(sbuf,&pCount,sizeof(pCount));
; 15258: 
; 15259: 	if(lpObj->Type == OBJ_USER)

  001bd	66 83 7f 60 01	 cmp	 WORD PTR [edi+96], 1
  001c2	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _pCount$[ebp+4]
  001c8	8a 95 f8 fe ff
	ff		 mov	 dl, BYTE PTR _pCount$[ebp+8]
  001ce	88 9d f1 fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], bl
  001d4	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _pCount$[ebp]
  001da	89 85 fc fe ff
	ff		 mov	 DWORD PTR _sbuf$[ebp], eax
  001e0	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _sbuf$[ebp+4], ecx
  001e6	88 95 04 ff ff
	ff		 mov	 BYTE PTR _sbuf$[ebp+8], dl
  001ec	75 13		 jne	 SHORT $LN1@gObjPosMag

; 15260: 	{
; 15261: 		DataSend(lpObj->m_Index,sbuf,lOfs);

  001ee	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001f0	53		 push	 ebx
  001f1	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _sbuf$[ebp]
  001f7	50		 push	 eax
  001f8	51		 push	 ecx
  001f9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001fe	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjPosMag:

; 15262: 	}
; 15263: 
; 15264: 	MsgSendV2(lpObj,sbuf,lOfs);

  00201	53		 push	 ebx
  00202	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _sbuf$[ebp]
  00208	52		 push	 edx
  00209	57		 push	 edi
  0020a	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0020f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00212	5f		 pop	 edi
  00213	5e		 pop	 esi

; 15265: 	return true;

  00214	b8 01 00 00 00	 mov	 eax, 1
  00219	5b		 pop	 ebx

; 15266: }

  0021a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021d	33 cd		 xor	 ecx, ebp
  0021f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00224	8b e5		 mov	 esp, ebp
  00226	5d		 pop	 ebp
  00227	c3		 ret	 0
$LN19@gObjPosMag:

; 15244: 							{
; 15245: 								LogAdd(LOG_BLACK, lMsg.Get(547),__FILE__,__LINE__);

  00228	68 8d 3b 00 00	 push	 15245			; 00003b8dH
  0022d	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00232	68 23 02 00 00	 push	 547			; 00000223H
  00237	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0023c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00241	50		 push	 eax
  00242	6a 00		 push	 0
  00244	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 15266: }

  00249	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024c	83 c4 10	 add	 esp, 16			; 00000010H
  0024f	5f		 pop	 edi
  00250	5e		 pop	 esi
  00251	33 cd		 xor	 ecx, ebp
  00253	33 c0		 xor	 eax, eax
  00255	5b		 pop	 ebx
  00256	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025b	8b e5		 mov	 esp, ebp
  0025d	5d		 pop	 ebp
  0025e	c3		 ret	 0
?gObjPosMagicAttack@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@EE@Z ENDP ; gObjPosMagicAttack
_TEXT	ENDS
PUBLIC	?gObjMagicAddEnergyCheckOnOff@@YAXH@Z		; gObjMagicAddEnergyCheckOnOff
; Function compile flags: /Ogtp
;	COMDAT ?gObjMagicAddEnergyCheckOnOff@@YAXH@Z
_TEXT	SEGMENT
_flag$ = 8						; size = 4
?gObjMagicAddEnergyCheckOnOff@@YAXH@Z PROC		; gObjMagicAddEnergyCheckOnOff, COMDAT

; 15269: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15270: 	g_EnergyCheckOff=flag;

  00003	8b 45 08	 mov	 eax, DWORD PTR _flag$[ebp]
  00006	a3 00 00 00 00	 mov	 DWORD PTR ?g_EnergyCheckOff@@3HA, eax ; g_EnergyCheckOff

; 15271: }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?gObjMagicAddEnergyCheckOnOff@@YAXH@Z ENDP		; gObjMagicAddEnergyCheckOnOff
_TEXT	ENDS
PUBLIC	??_C@_0CG@HFCELOAC@error?9L2?3?5Skill?5Leadership?5not?5e@ ; `string'
PUBLIC	?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EEEAAE@Z	; gObjMagicAdd
EXTRN	?Set@CMagicInf@@QAEHEEE@Z:PROC			; CMagicInf::Set
EXTRN	?SkillGetRequireClass@CMagicDamage@@QAEHHHH@Z:PROC ; CMagicDamage::SkillGetRequireClass
EXTRN	?GetskillRequireLeadership@CMagicDamage@@QAEHH@Z:PROC ; CMagicDamage::GetskillRequireLeadership
EXTRN	?SkillGetRequireEnergy@CMagicDamage@@QAEHH@Z:PROC ; CMagicDamage::SkillGetRequireEnergy
EXTRN	?GetSkillNumberInex@@YAHHHH@Z:PROC		; GetSkillNumberInex
;	COMDAT ??_C@_0CG@HFCELOAC@error?9L2?3?5Skill?5Leadership?5not?5e@
CONST	SEGMENT
??_C@_0CG@HFCELOAC@error?9L2?3?5Skill?5Leadership?5not?5e@ DB 'error-L2: '
	DB	'Skill Leadership not enough', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EEEAAE@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_Type$ = 12						; size = 1
_Index$ = 16						; size = 1
_Level$ = 20						; size = 1
_SkillNumber$ = 24					; size = 4
?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EEEAAE@Z PROC	; gObjMagicAdd, COMDAT

; 15274: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15275: 	int skill = -1,n,reqeng,reqleadership;
; 15276: 
; 15277: 	skill = GetSkillNumberInex(Type,Index,Level);

  00003	0f b6 45 10	 movzx	 eax, BYTE PTR _Index$[ebp]
  00007	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _Type$[ebp]
  0000b	53		 push	 ebx
  0000c	0f b6 5d 14	 movzx	 ebx, BYTE PTR _Level$[ebp]
  00010	56		 push	 esi
  00011	53		 push	 ebx
  00012	50		 push	 eax
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ?GetSkillNumberInex@@YAHHHH@Z ; GetSkillNumberInex
  00019	8b f0		 mov	 esi, eax
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15278: 
; 15279: 	if(skill < 0)

  0001e	85 f6		 test	 esi, esi
  00020	79 21		 jns	 SHORT $LN19@gObjMagicA

; 15280: 	{
; 15281: 		LogAdd(LOG_BLACK, lMsg.Get(548));

  00022	68 24 02 00 00	 push	 548			; 00000224H
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0002c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00031	50		 push	 eax
  00032	6a 00		 push	 0
  00034	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00039	83 c4 08	 add	 esp, 8
  0003c	5e		 pop	 esi

; 15282: 		return -1;

  0003d	83 c8 ff	 or	 eax, -1
  00040	5b		 pop	 ebx

; 15365: }

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN19@gObjMagicA:

; 15283: 	}
; 15284: 
; 15285: 	if(g_EnergyCheckOff == 1)

  00043	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_EnergyCheckOff@@3HA, 1 ; g_EnergyCheckOff
  0004a	57		 push	 edi
  0004b	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0004e	75 45		 jne	 SHORT $LN16@gObjMagicA

; 15286: 	{
; 15287: 		reqeng = MagicDamageC.SkillGetRequireEnergy(skill);

  00050	56		 push	 esi
  00051	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00056	e8 00 00 00 00	 call	 ?SkillGetRequireEnergy@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetRequireEnergy

; 15288: 
; 15289: 		if(reqeng < 0)

  0005b	85 c0		 test	 eax, eax
  0005d	79 22		 jns	 SHORT $LN17@gObjMagicA
$LN32@gObjMagicA:

; 15290: 		{
; 15291: 			LogAdd(LOG_BLACK, lMsg.Get(549));

  0005f	68 25 02 00 00	 push	 549			; 00000225H
$LN33@gObjMagicA:
  00064	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00069	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0006e	50		 push	 eax
  0006f	6a 00		 push	 0
  00071	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00076	83 c4 08	 add	 esp, 8
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi

; 15364: 	return -1;

  0007b	83 c8 ff	 or	 eax, -1
  0007e	5b		 pop	 ebx

; 15365: }

  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
$LN17@gObjMagicA:

; 15292: 			return -1;
; 15293: 		}
; 15294: 
; 15295: 		if((lpObj->Energy + lpObj->AddEnergy) < reqeng)

  00081	0f bf 8f e6 00
	00 00		 movsx	 ecx, WORD PTR [edi+230]
  00088	0f b7 97 ba 00
	00 00		 movzx	 edx, WORD PTR [edi+186]
  0008f	03 ca		 add	 ecx, edx
  00091	3b c8		 cmp	 ecx, eax

; 15296: 		{
; 15297: 			LogAdd(LOG_BLACK, lMsg.Get(549));
; 15298: 			return -1;

  00093	7c ca		 jl	 SHORT $LN32@gObjMagicA
$LN16@gObjMagicA:

; 15299: 		}
; 15300: 	}
; 15301: 
; 15302: 	reqleadership = MagicDamageC.GetskillRequireLeadership(skill);

  00095	56		 push	 esi
  00096	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0009b	e8 00 00 00 00	 call	 ?GetskillRequireLeadership@CMagicDamage@@QAEHH@Z ; CMagicDamage::GetskillRequireLeadership

; 15303: 
; 15304: 	if(reqleadership < 0)

  000a0	85 c0		 test	 eax, eax
  000a2	79 17		 jns	 SHORT $LN15@gObjMagicA
$LN34@gObjMagicA:

; 15305: 	{
; 15306: 		LogAdd(LOG_BLACK, "error-L2: Skill Leadership not enough");

  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HFCELOAC@error?9L2?3?5Skill?5Leadership?5not?5e@
  000a9	6a 00		 push	 0
  000ab	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000b0	83 c4 08	 add	 esp, 8
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi

; 15364: 	return -1;

  000b5	83 c8 ff	 or	 eax, -1
  000b8	5b		 pop	 ebx

; 15365: }

  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
$LN15@gObjMagicA:

; 15307: 		return -1;
; 15308: 	}
; 15309: 
; 15310: 	if((lpObj->Leadership + lpObj->AddLeadership) < reqleadership)

  000bb	0f b7 8f da 00
	00 00		 movzx	 ecx, WORD PTR [edi+218]
  000c2	0f b7 97 d8 00
	00 00		 movzx	 edx, WORD PTR [edi+216]
  000c9	03 ca		 add	 ecx, edx
  000cb	3b c8		 cmp	 ecx, eax

; 15311: 	{
; 15312: 		LogAdd(LOG_BLACK, "error-L2: Skill Leadership not enough");
; 15313: 		return -1;

  000cd	7c d5		 jl	 SHORT $LN34@gObjMagicA

; 15314: 	}
; 15315: 
; 15316: 	if(MagicDamageC.SkillGetRequireClass(lpObj->Class,lpObj->ChangeUP,skill) < 1)

  000cf	0f b6 87 9b 00
	00 00		 movzx	 eax, BYTE PTR [edi+155]
  000d6	0f b7 8f 98 00
	00 00		 movzx	 ecx, WORD PTR [edi+152]
  000dd	56		 push	 esi
  000de	50		 push	 eax
  000df	51		 push	 ecx
  000e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  000e5	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHH@Z ; CMagicDamage::SkillGetRequireClass
  000ea	83 f8 01	 cmp	 eax, 1
  000ed	7d 0a		 jge	 SHORT $LN13@gObjMagicA

; 15317: 	{
; 15318: 		LogAdd(LOG_BLACK, lMsg.Get(550));

  000ef	68 26 02 00 00	 push	 550			; 00000226H

; 15319: 		return -1;

  000f4	e9 6b ff ff ff	 jmp	 $LN33@gObjMagicA
$LN13@gObjMagicA:

; 15320: 	}
; 15321: 
; 15322: 	for(n = 0; n < MAGIC_SIZE; n++)

  000f9	33 f6		 xor	 esi, esi
  000fb	eb 03 8d 49 00	 npad	 5
$LL12@gObjMagicA:

; 15323: 	{
; 15324: 		if(lpObj->Magic[n].IsMagic() == 1)

  00100	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  00106	03 ce		 add	 ecx, esi
  00108	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0010d	83 f8 01	 cmp	 eax, 1
  00110	75 26		 jne	 SHORT $LN11@gObjMagicA

; 15325: 		{
; 15326: 			skill = GetSkillNumberInex(Type,Index,Level);

  00112	0f b6 45 10	 movzx	 eax, BYTE PTR _Index$[ebp]
  00116	53		 push	 ebx
  00117	50		 push	 eax
  00118	0f b6 45 0c	 movzx	 eax, BYTE PTR _Type$[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?GetSkillNumberInex@@YAHHHH@Z ; GetSkillNumberInex
  00122	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15327: 
; 15328: 			if(skill < 0)

  00125	85 c0		 test	 eax, eax
  00127	78 70		 js	 SHORT $LN24@gObjMagicA

; 15332: 			}
; 15333: 
; 15334: 			if(lpObj->Magic[n].m_Skill == skill)

  00129	8b 97 38 03 00
	00		 mov	 edx, DWORD PTR [edi+824]
  0012f	0f b6 4c 16 05	 movzx	 ecx, BYTE PTR [esi+edx+5]
  00134	3b c8		 cmp	 ecx, eax
  00136	74 72		 je	 SHORT $LN25@gObjMagicA
$LN11@gObjMagicA:

; 15320: 	}
; 15321: 
; 15322: 	for(n = 0; n < MAGIC_SIZE; n++)

  00138	83 c6 10	 add	 esi, 16			; 00000010H
  0013b	81 fe c0 03 00
	00		 cmp	 esi, 960		; 000003c0H
  00141	7c bd		 jl	 SHORT $LL12@gObjMagicA

; 15338: 			}
; 15339: 		}
; 15340: 	}
; 15341: 
; 15342: 	skill = -1;
; 15343: 
; 15344: 	for(n = 0; n < MAGIC_SIZE; n++)

  00143	33 db		 xor	 ebx, ebx
  00145	33 f6		 xor	 esi, esi
  00147	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL6@gObjMagicA:
  00150	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  00156	03 ce		 add	 ecx, esi

; 15345: 	{
; 15346: 		if(lpObj->Magic[n].IsMagic() == 0)

  00158	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0015d	85 c0		 test	 eax, eax
  0015f	74 53		 je	 SHORT $LN26@gObjMagicA

; 15338: 			}
; 15339: 		}
; 15340: 	}
; 15341: 
; 15342: 	skill = -1;
; 15343: 
; 15344: 	for(n = 0; n < MAGIC_SIZE; n++)

  00161	83 c6 10	 add	 esi, 16			; 00000010H
  00164	43		 inc	 ebx
  00165	81 fe c0 03 00
	00		 cmp	 esi, 960		; 000003c0H
  0016b	7c e3		 jl	 SHORT $LL6@gObjMagicA

; 15359: 			}
; 15360: 		}
; 15361: 	}
; 15362: 
; 15363: 	LogAdd(LOG_BLACK, lMsg.Get(554),__FILE__,__LINE__);

  0016d	68 03 3c 00 00	 push	 15363			; 00003c03H
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00177	68 2a 02 00 00	 push	 554			; 0000022aH
$LN31@gObjMagicA:
  0017c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00181	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00186	50		 push	 eax
  00187	6a 00		 push	 0
  00189	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0018e	83 c4 10	 add	 esp, 16			; 00000010H
  00191	5f		 pop	 edi
  00192	5e		 pop	 esi

; 15364: 	return -1;

  00193	83 c8 ff	 or	 eax, -1
  00196	5b		 pop	 ebx

; 15365: }

  00197	5d		 pop	 ebp
  00198	c3		 ret	 0
$LN24@gObjMagicA:

; 15329: 			{
; 15330: 				LogAdd(LOG_BLACK, lMsg.Get(551),__FILE__,__LINE__);

  00199	68 e2 3b 00 00	 push	 15330			; 00003be2H
  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  001a3	68 27 02 00 00	 push	 551			; 00000227H

; 15331: 				return -1;

  001a8	eb d2		 jmp	 SHORT $LN31@gObjMagicA
$LN25@gObjMagicA:

; 15335: 			{
; 15336: 				LogAdd(LOG_BLACK, lMsg.Get(552));

  001aa	68 28 02 00 00	 push	 552			; 00000228H

; 15337: 				return -1;

  001af	e9 b0 fe ff ff	 jmp	 $LN33@gObjMagicA
$LN26@gObjMagicA:

; 15347: 		{
; 15348: 			skill = lpObj->Magic[n].Set(Type,Index,Level);

  001b4	8b 55 14	 mov	 edx, DWORD PTR _Level$[ebp]
  001b7	8b 45 10	 mov	 eax, DWORD PTR _Index$[ebp]
  001ba	8b 4d 0c	 mov	 ecx, DWORD PTR _Type$[ebp]
  001bd	52		 push	 edx
  001be	50		 push	 eax
  001bf	51		 push	 ecx
  001c0	8b cb		 mov	 ecx, ebx
  001c2	c1 e1 04	 shl	 ecx, 4
  001c5	03 8f 38 03 00
	00		 add	 ecx, DWORD PTR [edi+824]
  001cb	e8 00 00 00 00	 call	 ?Set@CMagicInf@@QAEHEEE@Z ; CMagicInf::Set

; 15349: 			if(skill < 0)

  001d0	85 c0		 test	 eax, eax
  001d2	79 11		 jns	 SHORT $LN2@gObjMagicA

; 15350: 			{
; 15351: 				LogAdd(LOG_BLACK, lMsg.Get(553),__FILE__,__LINE__);

  001d4	68 f7 3b 00 00	 push	 15351			; 00003bf7H
  001d9	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  001de	68 29 02 00 00	 push	 553			; 00000229H

; 15352: 				return -1;

  001e3	eb 97		 jmp	 SHORT $LN31@gObjMagicA
$LN2@gObjMagicA:

; 15353: 			}
; 15354: 			else
; 15355: 			{
; 15356: 				lpObj->MagicCount++;

  001e5	fe 87 3c 03 00
	00		 inc	 BYTE PTR [edi+828]

; 15357: 				SkillNumber = skill;

  001eb	8b 55 18	 mov	 edx, DWORD PTR _SkillNumber$[ebp]
  001ee	5f		 pop	 edi
  001ef	88 02		 mov	 BYTE PTR [edx], al
  001f1	5e		 pop	 esi

; 15358: 				return n;

  001f2	8b c3		 mov	 eax, ebx
  001f4	5b		 pop	 ebx

; 15365: }

  001f5	5d		 pop	 ebp
  001f6	c3		 ret	 0
?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EEEAAE@Z ENDP	; gObjMagicAdd
_TEXT	ENDS
PUBLIC	?gObjMagicDel@@YAHPAUOBJECTSTRUCT@@EE@Z		; gObjMagicDel
EXTRN	?Clear@CMagicInf@@QAEXXZ:PROC			; CMagicInf::Clear
; Function compile flags: /Ogtp
;	COMDAT ?gObjMagicDel@@YAHPAUOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_aSkill$ = 12						; size = 1
_Level$ = 16						; size = 1
?gObjMagicDel@@YAHPAUOBJECTSTRUCT@@EE@Z PROC		; gObjMagicDel, COMDAT

; 15368: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 15369: 
; 15370: 	for(int n = 0; n < MAGIC_SIZE; n++)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	33 f6		 xor	 esi, esi
  0000d	8d 49 00	 npad	 3
$LL5@gObjMagicD:

; 15371: 	{
; 15372: 		if(lpObj->Magic[n].IsMagic() == 1)

  00010	8b 8b 38 03 00
	00		 mov	 ecx, DWORD PTR [ebx+824]
  00016	03 ce		 add	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 0f		 jne	 SHORT $LN4@gObjMagicD

; 15373: 		{
; 15374: 			if(lpObj->Magic[n].m_Skill == aSkill)

  00022	8b 83 38 03 00
	00		 mov	 eax, DWORD PTR [ebx+824]
  00028	8a 4d 0c	 mov	 cl, BYTE PTR _aSkill$[ebp]
  0002b	38 4c 30 05	 cmp	 BYTE PTR [eax+esi+5], cl
  0002f	74 14		 je	 SHORT $LN9@gObjMagicD
$LN4@gObjMagicD:

; 15369: 
; 15370: 	for(int n = 0; n < MAGIC_SIZE; n++)

  00031	83 c6 10	 add	 esi, 16			; 00000010H
  00034	47		 inc	 edi
  00035	81 fe c0 03 00
	00		 cmp	 esi, 960		; 000003c0H
  0003b	7c d3		 jl	 SHORT $LL5@gObjMagicD

; 15378: 			}
; 15379: 		}
; 15380: 	}
; 15381: 	return -1;

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	83 c8 ff	 or	 eax, -1
  00042	5b		 pop	 ebx

; 15382: }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
$LN9@gObjMagicD:

; 15375: 			{
; 15376: 				lpObj->Magic[n].Clear();

  00045	8b cf		 mov	 ecx, edi
  00047	c1 e1 04	 shl	 ecx, 4
  0004a	03 c8		 add	 ecx, eax
  0004c	e8 00 00 00 00	 call	 ?Clear@CMagicInf@@QAEXXZ ; CMagicInf::Clear

; 15377: 				return n;

  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 15382: }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?gObjMagicDel@@YAHPAUOBJECTSTRUCT@@EE@Z ENDP		; gObjMagicDel
_TEXT	ENDS
PUBLIC	?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z		; gObjMagicAdd
EXTRN	?Set@CMagicInf@@QAEHEE@Z:PROC			; CMagicInf::Set
; Function compile flags: /Ogtp
;	COMDAT ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
tv225 = -4						; size = 4
_lpObj$ = 8						; size = 4
_aSkill$ = 12						; size = 1
_Level$ = 16						; size = 1
?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z PROC		; gObjMagicAdd, COMDAT

; 15385: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 15386: 	int skill = -1,n,reqeng;
; 15387: 
; 15388: 	skill = -1;
; 15389: 
; 15390: 	if(g_EnergyCheckOff == 1)

  00004	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_EnergyCheckOff@@3HA, 1 ; g_EnergyCheckOff
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0000f	75 49		 jne	 SHORT $LN24@gObjMagicA@2

; 15391: 	{
; 15392: 		reqeng = MagicDamageC.SkillGetRequireEnergy(aSkill);

  00011	0f b6 45 0c	 movzx	 eax, BYTE PTR _aSkill$[ebp]
  00015	50		 push	 eax
  00016	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0001b	e8 00 00 00 00	 call	 ?SkillGetRequireEnergy@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetRequireEnergy

; 15393: 
; 15394: 		if(reqeng < 0)

  00020	85 c0		 test	 eax, eax
  00022	79 22		 jns	 SHORT $LN14@gObjMagicA@2
$LN28@gObjMagicA@2:

; 15395: 		{
; 15396: 			LogAdd(LOG_BLACK, lMsg.Get(549));

  00024	68 25 02 00 00	 push	 549			; 00000225H
$LN29@gObjMagicA@2:
  00029	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0002e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00033	50		 push	 eax
  00034	6a 00		 push	 0
  00036	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0003b	83 c4 08	 add	 esp, 8

; 15397: 			return -1;

  0003e	83 c8 ff	 or	 eax, -1
  00041	5f		 pop	 edi

; 15445: }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN14@gObjMagicA@2:

; 15398: 		}
; 15399: 
; 15400: 		if((lpObj->Energy + lpObj->AddEnergy) < reqeng)

  00046	0f bf 8f e6 00
	00 00		 movsx	 ecx, WORD PTR [edi+230]
  0004d	0f b7 97 ba 00
	00 00		 movzx	 edx, WORD PTR [edi+186]
  00054	03 ca		 add	 ecx, edx
  00056	3b c8		 cmp	 ecx, eax

; 15401: 		{
; 15402: 			LogAdd(LOG_BLACK, lMsg.Get(549));
; 15403: 			return -1;

  00058	7c ca		 jl	 SHORT $LN28@gObjMagicA@2
$LN24@gObjMagicA@2:

; 15404: 		}
; 15405: 	}
; 15406: 
; 15407: 	if(MagicDamageC.SkillGetRequireClass(lpObj->Class,lpObj->ChangeUP,aSkill) < 1)

  0005a	0f b6 45 0c	 movzx	 eax, BYTE PTR _aSkill$[ebp]
  0005e	0f b7 8f 98 00
	00 00		 movzx	 ecx, WORD PTR [edi+152]
  00065	50		 push	 eax
  00066	89 45 fc	 mov	 DWORD PTR tv225[ebp], eax
  00069	0f b6 87 9b 00
	00 00		 movzx	 eax, BYTE PTR [edi+155]
  00070	50		 push	 eax
  00071	51		 push	 ecx
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00077	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHH@Z ; CMagicDamage::SkillGetRequireClass
  0007c	83 f8 01	 cmp	 eax, 1
  0007f	7d 07		 jge	 SHORT $LN12@gObjMagicA@2

; 15408: 	{
; 15409: 		LogAdd(LOG_BLACK, lMsg.Get(550));

  00081	68 26 02 00 00	 push	 550			; 00000226H

; 15410: 		return -1;

  00086	eb a1		 jmp	 SHORT $LN29@gObjMagicA@2
$LN12@gObjMagicA@2:
  00088	53		 push	 ebx
  00089	56		 push	 esi

; 15411: 	}
; 15412: 
; 15413: 	for(n = 0; n < MAGIC_SIZE; n++)

  0008a	33 db		 xor	 ebx, ebx
  0008c	33 f6		 xor	 esi, esi
  0008e	8b ff		 npad	 2
$LL11@gObjMagicA@2:

; 15414: 	{
; 15415: 		if(lpObj->Magic[n].IsMagic() == 1)

  00090	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  00096	03 ce		 add	 ecx, esi
  00098	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0009d	83 f8 01	 cmp	 eax, 1
  000a0	75 0f		 jne	 SHORT $LN10@gObjMagicA@2

; 15416: 		{
; 15417: 			if(lpObj->Magic[n].m_Skill == aSkill)

  000a2	8b 97 38 03 00
	00		 mov	 edx, DWORD PTR [edi+824]
  000a8	8a 45 0c	 mov	 al, BYTE PTR _aSkill$[ebp]
  000ab	38 44 32 05	 cmp	 BYTE PTR [edx+esi+5], al
  000af	74 5b		 je	 SHORT $LN20@gObjMagicA@2
$LN10@gObjMagicA@2:

; 15411: 	}
; 15412: 
; 15413: 	for(n = 0; n < MAGIC_SIZE; n++)

  000b1	83 c6 10	 add	 esi, 16			; 00000010H
  000b4	43		 inc	 ebx
  000b5	81 fe c0 03 00
	00		 cmp	 esi, 960		; 000003c0H
  000bb	7c d3		 jl	 SHORT $LL11@gObjMagicA@2

; 15421: 			}
; 15422: 		}
; 15423: 	}
; 15424: 
; 15425: 	for(n = 0; n < MAGIC_SIZE; n++)

  000bd	33 db		 xor	 ebx, ebx
  000bf	33 f6		 xor	 esi, esi
$LL6@gObjMagicA@2:
  000c1	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  000c7	03 ce		 add	 ecx, esi

; 15426: 	{
; 15427: 		if(lpObj->Magic[n].IsMagic() == 0)

  000c9	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  000ce	85 c0		 test	 eax, eax
  000d0	74 4d		 je	 SHORT $LN21@gObjMagicA@2

; 15421: 			}
; 15422: 		}
; 15423: 	}
; 15424: 
; 15425: 	for(n = 0; n < MAGIC_SIZE; n++)

  000d2	83 c6 10	 add	 esi, 16			; 00000010H
  000d5	43		 inc	 ebx
  000d6	81 fe c0 03 00
	00		 cmp	 esi, 960		; 000003c0H
  000dc	7c e3		 jl	 SHORT $LL6@gObjMagicA@2

; 15439: 			}
; 15440: 		}
; 15441: 	}
; 15442: 
; 15443: 	LogAdd(LOG_BLACK, lMsg.Get(554),__FILE__,__LINE__);

  000de	68 53 3c 00 00	 push	 15443			; 00003c53H
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  000e8	68 2a 02 00 00	 push	 554			; 0000022aH
$LN27@gObjMagicA@2:
  000ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000f2	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000f7	50		 push	 eax
  000f8	6a 00		 push	 0
  000fa	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000ff	83 c4 10	 add	 esp, 16			; 00000010H
  00102	5e		 pop	 esi
  00103	5b		 pop	 ebx

; 15444: 	return -1;

  00104	83 c8 ff	 or	 eax, -1
  00107	5f		 pop	 edi

; 15445: }

  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
$LN20@gObjMagicA@2:

; 15418: 			{
; 15419: 				LogAdd(LOG_BLACK, lMsg.Get(555),lpObj->Magic[n].m_Skill,aSkill);

  0010c	8b 4d fc	 mov	 ecx, DWORD PTR tv225[ebp]
  0010f	03 db		 add	 ebx, ebx
  00111	0f b6 44 da 05	 movzx	 eax, BYTE PTR [edx+ebx*8+5]
  00116	51		 push	 ecx
  00117	50		 push	 eax
  00118	68 2b 02 00 00	 push	 555			; 0000022bH

; 15420: 				return -1;

  0011d	eb ce		 jmp	 SHORT $LN27@gObjMagicA@2
$LN21@gObjMagicA@2:

; 15428: 		{
; 15429: 			skill = lpObj->Magic[n].Set(aSkill,Level);

  0011f	8b 4d 10	 mov	 ecx, DWORD PTR _Level$[ebp]
  00122	8b 55 0c	 mov	 edx, DWORD PTR _aSkill$[ebp]
  00125	51		 push	 ecx
  00126	8b cb		 mov	 ecx, ebx
  00128	c1 e1 04	 shl	 ecx, 4
  0012b	03 8f 38 03 00
	00		 add	 ecx, DWORD PTR [edi+824]
  00131	52		 push	 edx
  00132	e8 00 00 00 00	 call	 ?Set@CMagicInf@@QAEHEE@Z ; CMagicInf::Set

; 15430: 			if(skill < 0)

  00137	85 c0		 test	 eax, eax
  00139	79 11		 jns	 SHORT $LN2@gObjMagicA@2

; 15431: 			{
; 15432: 				LogAdd(LOG_BLACK, lMsg.Get(553),__FILE__,__LINE__);

  0013b	68 48 3c 00 00	 push	 15432			; 00003c48H
  00140	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00145	68 29 02 00 00	 push	 553			; 00000229H

; 15433: 				return -1;

  0014a	eb a1		 jmp	 SHORT $LN27@gObjMagicA@2
$LN2@gObjMagicA@2:

; 15434: 			}
; 15435: 			else
; 15436: 			{
; 15437: 				lpObj->MagicCount++;

  0014c	fe 87 3c 03 00
	00		 inc	 BYTE PTR [edi+828]
  00152	5e		 pop	 esi

; 15438: 				return n;

  00153	8b c3		 mov	 eax, ebx
  00155	5b		 pop	 ebx
  00156	5f		 pop	 edi

; 15445: }

  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c3		 ret	 0
?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ENDP		; gObjMagicAdd
_TEXT	ENDS
PUBLIC	?gObjWeaponMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z	; gObjWeaponMagicAdd
; Function compile flags: /Ogtp
;	COMDAT ?gObjWeaponMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_aSkill$ = 12						; size = 1
_Level$ = 16						; size = 1
?gObjWeaponMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z PROC	; gObjWeaponMagicAdd, COMDAT

; 15453: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15454: 	int skill = -1,n;
; 15455: 	skill = -1;
; 15456: 
; 15457: 	if(MagicDamageC.SkillGetRequireClass(lpObj->Class,lpObj->ChangeUP,aSkill) < 1)

  00003	0f b6 45 0c	 movzx	 eax, BYTE PTR _aSkill$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  0000b	0f b6 8b 9b 00
	00 00		 movzx	 ecx, BYTE PTR [ebx+155]
  00012	0f b7 93 98 00
	00 00		 movzx	 edx, WORD PTR [ebx+152]
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	52		 push	 edx
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00021	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHH@Z ; CMagicDamage::SkillGetRequireClass
  00026	83 f8 01	 cmp	 eax, 1
  00029	7d 06		 jge	 SHORT $LN7@gObjWeapon@2

; 15458: 	{
; 15459: 		return -1;

  0002b	83 c8 ff	 or	 eax, -1
  0002e	5b		 pop	 ebx

; 15480: }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN7@gObjWeapon@2:
  00031	56		 push	 esi
  00032	57		 push	 edi

; 15460: 	}
; 15461: 	for(int n = 0; n < MAGIC_SIZE; n++)

  00033	33 ff		 xor	 edi, edi
  00035	33 f6		 xor	 esi, esi
  00037	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL6@gObjWeapon@2:
  00040	8b 8b 38 03 00
	00		 mov	 ecx, DWORD PTR [ebx+824]
  00046	03 ce		 add	 ecx, esi

; 15462: 	{
; 15463: 		if(lpObj->Magic[n].IsMagic() == 0)

  00048	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0004d	85 c0		 test	 eax, eax
  0004f	74 38		 je	 SHORT $LN11@gObjWeapon@2

; 15460: 	}
; 15461: 	for(int n = 0; n < MAGIC_SIZE; n++)

  00051	83 c6 10	 add	 esi, 16			; 00000010H
  00054	47		 inc	 edi
  00055	81 fe c0 03 00
	00		 cmp	 esi, 960		; 000003c0H
  0005b	7c e3		 jl	 SHORT $LL6@gObjWeapon@2

; 15475: 			}
; 15476: 		}
; 15477: 	}
; 15478: 	LogAdd(LOG_BLACK, lMsg.Get(554),__FILE__,__LINE__);

  0005d	68 76 3c 00 00	 push	 15478			; 00003c76H
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00067	68 2a 02 00 00	 push	 554			; 0000022aH
$LN15@gObjWeapon@2:
  0006c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00071	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00076	50		 push	 eax
  00077	6a 00		 push	 0
  00079	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0007e	83 c4 10	 add	 esp, 16			; 00000010H
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi

; 15479: 	return -1;

  00083	83 c8 ff	 or	 eax, -1
  00086	5b		 pop	 ebx

; 15480: }

  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
$LN11@gObjWeapon@2:

; 15464: 		{
; 15465: 			skill = lpObj->Magic[n].Set(aSkill,Level);

  00089	8b 45 10	 mov	 eax, DWORD PTR _Level$[ebp]
  0008c	8b 4d 0c	 mov	 ecx, DWORD PTR _aSkill$[ebp]
  0008f	50		 push	 eax
  00090	51		 push	 ecx
  00091	8b cf		 mov	 ecx, edi
  00093	c1 e1 04	 shl	 ecx, 4
  00096	03 8b 38 03 00
	00		 add	 ecx, DWORD PTR [ebx+824]
  0009c	e8 00 00 00 00	 call	 ?Set@CMagicInf@@QAEHEE@Z ; CMagicInf::Set

; 15466: 			if(skill < 0)

  000a1	85 c0		 test	 eax, eax
  000a3	79 11		 jns	 SHORT $LN2@gObjWeapon@2

; 15467: 			{
; 15468: 				LogAdd(LOG_BLACK, lMsg.Get(553),__FILE__,__LINE__);

  000a5	68 6c 3c 00 00	 push	 15468			; 00003c6cH
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  000af	68 29 02 00 00	 push	 553			; 00000229H

; 15469: 				return -1;

  000b4	eb b6		 jmp	 SHORT $LN15@gObjWeapon@2
$LN2@gObjWeapon@2:

; 15470: 			}
; 15471: 			else
; 15472: 			{
; 15473: 				lpObj->MagicCount++;

  000b6	fe 83 3c 03 00
	00		 inc	 BYTE PTR [ebx+828]

; 15474: 				return n;

  000bc	8b c7		 mov	 eax, edi
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx

; 15480: }

  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
?gObjWeaponMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ENDP	; gObjWeaponMagicAdd
_TEXT	ENDS
PUBLIC	?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z	; gObjMonsterMagicAdd
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_aSkill$ = 12						; size = 1
_Level$ = 16						; size = 1
?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z PROC	; gObjMonsterMagicAdd, COMDAT

; 15483: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 15484: 	int skill = -1;
; 15485: 
; 15486: 	for (int n=0; n<MAGIC_SIZE ; n++)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	33 f6		 xor	 esi, esi
  0000d	8d 49 00	 npad	 3
$LL5@gObjMonste@2:
  00010	8b 8b 38 03 00
	00		 mov	 ecx, DWORD PTR [ebx+824]
  00016	03 ce		 add	 ecx, esi

; 15487: 	{
; 15488: 		if ( lpObj->Magic[n].IsMagic() == FALSE )

  00018	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0001d	85 c0		 test	 eax, eax
  0001f	74 38		 je	 SHORT $LN9@gObjMonste@2

; 15484: 	int skill = -1;
; 15485: 
; 15486: 	for (int n=0; n<MAGIC_SIZE ; n++)

  00021	83 c6 10	 add	 esi, 16			; 00000010H
  00024	47		 inc	 edi
  00025	81 fe c0 03 00
	00		 cmp	 esi, 960		; 000003c0H
  0002b	7c e3		 jl	 SHORT $LL5@gObjMonste@2

; 15500: 		}
; 15501: 	}
; 15502: 
; 15503: 	LogAdd(LOG_BLACK, lMsg.Get( MSGGET(2, 42)), __FILE__, __LINE__);

  0002d	68 8f 3c 00 00	 push	 15503			; 00003c8fH
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00037	68 2a 02 00 00	 push	 554			; 0000022aH
$LN11@gObjMonste@2:
  0003c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00041	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00046	50		 push	 eax
  00047	6a 00		 push	 0
  00049	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 15504: 	return -1;

  00053	83 c8 ff	 or	 eax, -1
  00056	5b		 pop	 ebx

; 15505: }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN9@gObjMonste@2:

; 15489: 		{
; 15490: 			skill = lpObj->Magic[n].Set(aSkill, Level);

  00059	8b 45 10	 mov	 eax, DWORD PTR _Level$[ebp]
  0005c	8b 4d 0c	 mov	 ecx, DWORD PTR _aSkill$[ebp]
  0005f	50		 push	 eax
  00060	51		 push	 ecx
  00061	8b cf		 mov	 ecx, edi
  00063	c1 e1 04	 shl	 ecx, 4
  00066	03 8b 38 03 00
	00		 add	 ecx, DWORD PTR [ebx+824]
  0006c	e8 00 00 00 00	 call	 ?Set@CMagicInf@@QAEHEE@Z ; CMagicInf::Set

; 15491: 
; 15492: 			if ( skill < 0 )

  00071	85 c0		 test	 eax, eax
  00073	79 11		 jns	 SHORT $LN1@gObjMonste@2

; 15493: 			{
; 15494: 				LogAdd(LOG_BLACK, lMsg.Get( MSGGET(2, 41)),__FILE__, __LINE__);

  00075	68 86 3c 00 00	 push	 15494			; 00003c86H
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0007f	68 29 02 00 00	 push	 553			; 00000229H

; 15495: 				return -1;

  00084	eb b6		 jmp	 SHORT $LN11@gObjMonste@2
$LN1@gObjMonste@2:

; 15496: 			}
; 15497: 
; 15498: 			lpObj->MagicCount++;

  00086	fe 83 3c 03 00
	00		 inc	 BYTE PTR [ebx+828]

; 15499: 			return n;

  0008c	8b c7		 mov	 eax, edi
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx

; 15505: }

  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ENDP	; gObjMonsterMagicAdd
_TEXT	ENDS
PUBLIC	?gObjMagicEnergyCheck@@YAHPAUOBJECTSTRUCT@@E@Z	; gObjMagicEnergyCheck
EXTRN	?SkillGetRequireLevel@CMagicDamage@@QAEHH@Z:PROC ; CMagicDamage::SkillGetRequireLevel
EXTRN	?gServerInfo@@3VCServerInfo@@A:BYTE		; gServerInfo
; Function compile flags: /Ogtp
;	COMDAT ?gObjMagicEnergyCheck@@YAHPAUOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_aSkill$ = 12						; size = 1
?gObjMagicEnergyCheck@@YAHPAUOBJECTSTRUCT@@E@Z PROC	; gObjMagicEnergyCheck, COMDAT

; 15508: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 15509: 	int reqeng,reqlevel;
; 15510: 
; 15511: 	reqeng = MagicDamageC.SkillGetRequireEnergy(aSkill);

  00004	0f b6 75 0c	 movzx	 esi, BYTE PTR _aSkill$[ebp]
  00008	56		 push	 esi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0000e	e8 00 00 00 00	 call	 ?SkillGetRequireEnergy@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetRequireEnergy

; 15512: 
; 15513: 	if(reqeng < 0)

  00013	85 c0		 test	 eax, eax
  00015	79 05		 jns	 SHORT $LN4@gObjMagicE

; 15514: 	{
; 15515: 		return false;

  00017	33 c0		 xor	 eax, eax
  00019	5e		 pop	 esi

; 15534: }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
$LN4@gObjMagicE:
  0001c	57		 push	 edi

; 15516: 	}
; 15517: 
; 15518: 	if((lpObj->Energy + lpObj->AddEnergy) < reqeng)

  0001d	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00020	0f bf 8f e6 00
	00 00		 movsx	 ecx, WORD PTR [edi+230]
  00027	0f b7 97 ba 00
	00 00		 movzx	 edx, WORD PTR [edi+186]
  0002e	03 ca		 add	 ecx, edx
  00030	3b c8		 cmp	 ecx, eax

; 15519: 	{
; 15520: 		return false;

  00032	7c 1f		 jl	 SHORT $LN8@gObjMagicE

; 15521: 	}
; 15522: 
; 15523: 	if(gServerInfo.m_Data.iSkillNotLevel == 0)

  00034	83 3d 74 00 00
	00 00		 cmp	 DWORD PTR ?gServerInfo@@3VCServerInfo@@A+116, 0
  0003b	75 1c		 jne	 SHORT $LN1@gObjMagicE

; 15524: 	{
; 15525: 		reqlevel = MagicDamageC.SkillGetRequireLevel(aSkill);

  0003d	56		 push	 esi
  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00043	e8 00 00 00 00	 call	 ?SkillGetRequireLevel@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetRequireLevel

; 15526: 
; 15527: 		if(lpObj->Level < reqlevel)

  00048	0f bf 8f 9c 00
	00 00		 movsx	 ecx, WORD PTR [edi+156]
  0004f	3b c8		 cmp	 ecx, eax
  00051	7d 06		 jge	 SHORT $LN1@gObjMagicE
$LN8@gObjMagicE:
  00053	5f		 pop	 edi

; 15528: 		{
; 15529: 			return false;

  00054	33 c0		 xor	 eax, eax
  00056	5e		 pop	 esi

; 15534: }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN1@gObjMagicE:
  00059	5f		 pop	 edi

; 15530: 		}
; 15531: 	}
; 15532: 
; 15533: 	return true;

  0005a	b8 01 00 00 00	 mov	 eax, 1
  0005f	5e		 pop	 esi

; 15534: }

  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?gObjMagicEnergyCheck@@YAHPAUOBJECTSTRUCT@@E@Z ENDP	; gObjMagicEnergyCheck
_TEXT	ENDS
PUBLIC	?gObjItemLevelUp@@YAHPAUOBJECTSTRUCT@@HH@Z	; gObjItemLevelUp
EXTRN	?ItemGetDurability@@YAHHHHH@Z:PROC		; ItemGetDurability
; Function compile flags: /Ogtp
;	COMDAT ?gObjItemLevelUp@@YAHPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
tv381 = -12						; size = 4
tv357 = -8						; size = 4
tv406 = -4						; size = 4
_levelitemdur$ = -4					; size = 4
_lpObj$ = 8						; size = 4
tv382 = 12						; size = 4
_source$ = 12						; size = 4
_target$ = 16						; size = 4
?gObjItemLevelUp@@YAHPAUOBJECTSTRUCT@@HH@Z PROC		; gObjItemLevelUp, COMDAT

; 15537: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15538: 	if(source < 0 || source > MAIN_INVENTORY_SIZE -1)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  0000c	0f 87 e6 01 00
	00		 ja	 $LN9@gObjItemLe

; 15541: 	}
; 15542: 
; 15543: 	if(target < 0 || target > MAIN_INVENTORY_SIZE -1)

  00012	57		 push	 edi
  00013	8b 7d 10	 mov	 edi, DWORD PTR _target$[ebp]
  00016	83 ff 4b	 cmp	 edi, 75			; 0000004bH
  00019	0f 87 d2 01 00
	00		 ja	 $LN7@gObjItemLe

; 15546: 	}
; 15547: 
; 15548: 	if(lpObj->pInventory[source].IsItem() == 0)

  0001f	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00025	56		 push	 esi
  00026	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00029	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0002f	03 c8		 add	 ecx, eax
  00031	89 45 f8	 mov	 DWORD PTR tv357[ebp], eax
  00034	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00039	85 c0		 test	 eax, eax

; 15549: 	{
; 15550: 		return false;

  0003b	0f 84 a8 01 00
	00		 je	 $LN3@gObjItemLe

; 15551: 	}
; 15552: 
; 15553: 	if(lpObj->pInventory[target].IsItem() == 0)

  00041	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00047	69 ff a8 00 00
	00		 imul	 edi, 168		; 000000a8H
  0004d	03 cf		 add	 ecx, edi
  0004f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00054	85 c0		 test	 eax, eax

; 15554: 	{
; 15555: 		return false;

  00056	0f 84 8d 01 00
	00		 je	 $LN3@gObjItemLe

; 15556: 	}
; 15557: 
; 15558: 	if(!(lpObj->pInventory[target].m_Type < ITEMGET(12,7)
; 15559: 		|| lpObj->pInventory[target].m_Type == ITEMGET(13,30))
; 15560: 		|| lpObj->pInventory[target].m_Type == ITEMGET(4,7)
; 15561: 		|| lpObj->pInventory[target].m_Type == ITEMGET(4,15))

  0005c	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00062	0f b7 44 07 06	 movzx	 eax, WORD PTR [edi+eax+6]
  00067	b9 07 18 00 00	 mov	 ecx, 6151		; 00001807H
  0006c	66 3b c1	 cmp	 ax, cx
  0006f	7c 0e		 jl	 SHORT $LN2@gObjItemLe
  00071	ba 1e 1a 00 00	 mov	 edx, 6686		; 00001a1eH
  00076	66 3b c2	 cmp	 ax, dx
  00079	0f 85 6a 01 00
	00		 jne	 $LN3@gObjItemLe
$LN2@gObjItemLe:
  0007f	b9 07 08 00 00	 mov	 ecx, 2055		; 00000807H
  00084	66 3b c1	 cmp	 ax, cx
  00087	0f 84 5c 01 00
	00		 je	 $LN3@gObjItemLe
  0008d	ba 0f 08 00 00	 mov	 edx, 2063		; 0000080fH
  00092	66 3b c2	 cmp	 ax, dx
  00095	0f 84 4e 01 00
	00		 je	 $LN3@gObjItemLe

; 15564: 	}
; 15565: 
; 15566: 	LogAdd(LOG_BLACK, lMsg.Get(556),lpObj->AccountID,lpObj->Name,lpObj->pInventory[target].GetName(),lpObj->pInventory[target].m_Number,lpObj->pInventory[target].m_Level);

  0009b	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  000a1	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  000a4	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  000a8	53		 push	 ebx
  000a9	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  000ac	89 55 0c	 mov	 DWORD PTR tv382[ebp], edx
  000af	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b1	50		 push	 eax
  000b2	8d 5e 6f	 lea	 ebx, DWORD PTR [esi+111]
  000b5	52		 push	 edx
  000b6	89 5d f4	 mov	 DWORD PTR tv381[ebp], ebx
  000b9	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000be	50		 push	 eax
  000bf	8b 45 0c	 mov	 eax, DWORD PTR tv382[ebp]
  000c2	53		 push	 ebx
  000c3	50		 push	 eax
  000c4	68 2c 02 00 00	 push	 556			; 0000022cH
  000c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ce	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000d3	50		 push	 eax
  000d4	6a 00		 push	 0
  000d6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 15567: 
; 15568: 	lpObj->pInventory[target].m_Level++;

  000db	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  000e1	66 ff 44 0f 08	 inc	 WORD PTR [edi+ecx+8]

; 15569: 
; 15570: 	if(lpObj->pInventory[target].m_Level > 6)

  000e6	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  000ec	8d 44 0f 08	 lea	 eax, DWORD PTR [edi+ecx+8]
  000f0	83 c4 1c	 add	 esp, 28			; 0000001cH
  000f3	66 83 7c 17 08
	06		 cmp	 WORD PTR [edi+edx+8], 6
  000f9	7e 0c		 jle	 SHORT $LN1@gObjItemLe

; 15571: 	{
; 15572: 		lpObj->pInventory[target].m_Level = 6;

  000fb	8b c2		 mov	 eax, edx
  000fd	b9 06 00 00 00	 mov	 ecx, 6
  00102	66 89 4c 07 08	 mov	 WORD PTR [edi+eax+8], cx
$LN1@gObjItemLe:

; 15573: 	}
; 15574: 
; 15575: 	gObjMakePreviewCharSet(lpObj->m_Index);

  00107	8b 16		 mov	 edx, DWORD PTR [esi]
  00109	52		 push	 edx
  0010a	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 15576: 
; 15577: 	float levelitemdur = ItemGetDurability(lpObj->pInventory[target].m_Type,lpObj->pInventory[target].m_Level,lpObj->pInventory[target].IsExtItem(),lpObj->pInventory[target].IsSetItem());

  0010f	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00115	83 c4 04	 add	 esp, 4
  00118	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0011b	8d 1c 07	 lea	 ebx, DWORD PTR [edi+eax]
  0011e	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00123	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00129	50		 push	 eax
  0012a	03 cf		 add	 ecx, edi
  0012c	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  00131	0f bf 4b 08	 movsx	 ecx, WORD PTR [ebx+8]
  00135	0f bf 53 06	 movsx	 edx, WORD PTR [ebx+6]
  00139	50		 push	 eax
  0013a	51		 push	 ecx
  0013b	52		 push	 edx
  0013c	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  00141	89 45 fc	 mov	 DWORD PTR tv406[ebp], eax

; 15578: 
; 15579: 	lpObj->pInventory[target].m_Durability = levelitemdur * lpObj->pInventory[target].m_Durability / lpObj->pInventory[target].m_BaseDurability;

  00144	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0014a	db 45 fc	 fild	 DWORD PTR tv406[ebp]
  0014d	83 c4 10	 add	 esp, 16			; 00000010H

; 15580: 
; 15581: 	lpObj->pInventory[target].Convert(
; 15582: 			lpObj->pInventory[target].m_Type,
; 15583: 			lpObj->pInventory[target].m_Option1,
; 15584: 			lpObj->pInventory[target].m_Option2,
; 15585: 			lpObj->pInventory[target].m_Option3,
; 15586: 			lpObj->pInventory[target].m_NewOption,
; 15587: 			lpObj->pInventory[target].m_SetOption, 0, CURRENT_DB_VERSION);

  00150	6a 03		 push	 3
  00152	6a 00		 push	 0
  00154	d9 5d fc	 fstp	 DWORD PTR _levelitemdur$[ebp]
  00157	d9 45 fc	 fld	 DWORD PTR _levelitemdur$[ebp]
  0015a	d8 4c 38 24	 fmul	 DWORD PTR [eax+edi+36]
  0015e	d8 74 38 2c	 fdiv	 DWORD PTR [eax+edi+44]
  00162	d9 5c 38 24	 fstp	 DWORD PTR [eax+edi+36]
  00166	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0016c	0f b6 94 39 92
	00 00 00	 movzx	 edx, BYTE PTR [ecx+edi+146]
  00174	0f b6 44 39 7b	 movzx	 eax, BYTE PTR [ecx+edi+123]
  00179	03 cf		 add	 ecx, edi
  0017b	52		 push	 edx
  0017c	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  00180	50		 push	 eax
  00181	0f b6 41 79	 movzx	 eax, BYTE PTR [ecx+121]
  00185	52		 push	 edx
  00186	0f b6 51 78	 movzx	 edx, BYTE PTR [ecx+120]
  0018a	50		 push	 eax
  0018b	0f bf 41 06	 movsx	 eax, WORD PTR [ecx+6]
  0018f	52		 push	 edx
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEE@Z ; CItem::Convert

; 15588: 
; 15589: 	LogAdd(LOG_BLACK, lMsg.Get(557),lpObj->AccountID,lpObj->Name,lpObj->pInventory[source].m_Number,
; 15590: 			lpObj->pInventory[target].GetName(),lpObj->pInventory[target].m_Number,lpObj->pInventory[target].m_Level);

  00196	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0019c	0f bf 54 39 08	 movsx	 edx, WORD PTR [ecx+edi+8]
  001a1	8b 04 39	 mov	 eax, DWORD PTR [ecx+edi]
  001a4	03 cf		 add	 ecx, edi
  001a6	52		 push	 edx
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  001ad	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  001b3	8b 55 f8	 mov	 edx, DWORD PTR tv357[ebp]
  001b6	50		 push	 eax
  001b7	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  001ba	8b 4d f4	 mov	 ecx, DWORD PTR tv381[ebp]
  001bd	8b 55 0c	 mov	 edx, DWORD PTR tv382[ebp]
  001c0	50		 push	 eax
  001c1	51		 push	 ecx
  001c2	52		 push	 edx
  001c3	68 2d 02 00 00	 push	 557			; 0000022dH
  001c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001cd	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001d2	50		 push	 eax
  001d3	6a 00		 push	 0
  001d5	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001da	83 c4 20	 add	 esp, 32			; 00000020H
  001dd	5b		 pop	 ebx
  001de	5e		 pop	 esi

; 15591: 	return true;

  001df	b8 01 00 00 00	 mov	 eax, 1
  001e4	5f		 pop	 edi

; 15592: }

  001e5	8b e5		 mov	 esp, ebp
  001e7	5d		 pop	 ebp
  001e8	c3		 ret	 0
$LN3@gObjItemLe:
  001e9	5e		 pop	 esi

; 15562: 	{
; 15563: 		return false;

  001ea	33 c0		 xor	 eax, eax
  001ec	5f		 pop	 edi

; 15592: }

  001ed	8b e5		 mov	 esp, ebp
  001ef	5d		 pop	 ebp
  001f0	c3		 ret	 0
$LN7@gObjItemLe:

; 15544: 	{
; 15545: 		return false;

  001f1	33 c0		 xor	 eax, eax
  001f3	5f		 pop	 edi

; 15592: }

  001f4	8b e5		 mov	 esp, ebp
  001f6	5d		 pop	 ebp
  001f7	c3		 ret	 0
$LN9@gObjItemLe:

; 15539: 	{
; 15540: 		return false;

  001f8	33 c0		 xor	 eax, eax

; 15592: }

  001fa	8b e5		 mov	 esp, ebp
  001fc	5d		 pop	 ebp
  001fd	c3		 ret	 0
?gObjItemLevelUp@@YAHPAUOBJECTSTRUCT@@HH@Z ENDP		; gObjItemLevelUp
_TEXT	ENDS
PUBLIC	?gObjItemRandomLevelUp@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjItemRandomLevelUp
; Function compile flags: /Ogtp
;	COMDAT ?gObjItemRandomLevelUp@@YAHPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
tv481 = -12						; size = 4
tv453 = -8						; size = 4
tv519 = -4						; size = 4
_levelitemdur$ = -4					; size = 4
_lpObj$ = 8						; size = 4
tv482 = 12						; size = 4
_source$ = 12						; size = 4
_target$ = 16						; size = 4
?gObjItemRandomLevelUp@@YAHPAUOBJECTSTRUCT@@HH@Z PROC	; gObjItemRandomLevelUp, COMDAT

; 15595: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15596: 	if(source < 0 || source > MAIN_INVENTORY_SIZE -1)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  0000c	0f 87 92 02 00
	00		 ja	 $LN23@gObjItemRa

; 15599: 	}
; 15600: 
; 15601: 	if(target < 0 || target > MAIN_INVENTORY_SIZE -1)

  00012	57		 push	 edi
  00013	8b 7d 10	 mov	 edi, DWORD PTR _target$[ebp]
  00016	83 ff 4b	 cmp	 edi, 75			; 0000004bH
  00019	0f 87 7e 02 00
	00		 ja	 $LN21@gObjItemRa

; 15604: 	}
; 15605: 
; 15606: 	if(lpObj->pInventory[source].IsItem() == 0)

  0001f	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00025	56		 push	 esi
  00026	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00029	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0002f	03 c8		 add	 ecx, eax
  00031	89 45 f8	 mov	 DWORD PTR tv453[ebp], eax
  00034	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00039	85 c0		 test	 eax, eax

; 15607: 	{
; 15608: 		return false;

  0003b	0f 84 54 02 00
	00		 je	 $LN17@gObjItemRa

; 15609: 	}
; 15610: 
; 15611: 	if(lpObj->pInventory[target].IsItem() == 0)

  00041	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00047	69 ff a8 00 00
	00		 imul	 edi, 168		; 000000a8H
  0004d	03 cf		 add	 ecx, edi
  0004f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00054	85 c0		 test	 eax, eax

; 15612: 	{
; 15613: 		return false;

  00056	0f 84 39 02 00
	00		 je	 $LN17@gObjItemRa

; 15614: 	}
; 15615: 
; 15616: 	if(!(lpObj->pInventory[target].m_Type < ITEMGET(12,7)
; 15617: 		|| lpObj->pInventory[target].m_Type == ITEMGET(13,30))
; 15618: 		|| lpObj->pInventory[target].m_Type == ITEMGET(4,7)
; 15619: 		|| lpObj->pInventory[target].m_Type == ITEMGET(4,15))

  0005c	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00062	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00065	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00069	ba 07 18 00 00	 mov	 edx, 6151		; 00001807H
  0006e	66 3b c2	 cmp	 ax, dx
  00071	7c 0e		 jl	 SHORT $LN16@gObjItemRa
  00073	ba 1e 1a 00 00	 mov	 edx, 6686		; 00001a1eH
  00078	66 3b c2	 cmp	 ax, dx
  0007b	0f 85 14 02 00
	00		 jne	 $LN17@gObjItemRa
$LN16@gObjItemRa:
  00081	ba 07 08 00 00	 mov	 edx, 2055		; 00000807H
  00086	66 3b c2	 cmp	 ax, dx
  00089	0f 84 06 02 00
	00		 je	 $LN17@gObjItemRa
  0008f	ba 0f 08 00 00	 mov	 edx, 2063		; 0000080fH
  00094	66 3b c2	 cmp	 ax, dx
  00097	0f 84 f8 01 00
	00		 je	 $LN17@gObjItemRa

; 15622: 	}
; 15623: 
; 15624: 	if(lpObj->pInventory[target].m_Level >= 9)

  0009d	66 83 79 08 09	 cmp	 WORD PTR [ecx+8], 9

; 15625: 	{
; 15626: 		return false;

  000a2	0f 8d ed 01 00
	00		 jge	 $LN17@gObjItemRa

; 15627: 	}
; 15628: 
; 15629: 	LogAdd(LOG_BLACK, lMsg.Get(558),
; 15630: 		lpObj->AccountID,lpObj->Name,lpObj->pInventory[target].GetName(),
; 15631: 		lpObj->pInventory[target].m_Number,lpObj->pInventory[target].m_Level);

  000a8	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  000ae	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  000b1	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  000b5	53		 push	 ebx
  000b6	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  000b9	89 55 0c	 mov	 DWORD PTR tv482[ebp], edx
  000bc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000be	50		 push	 eax
  000bf	8d 5e 6f	 lea	 ebx, DWORD PTR [esi+111]
  000c2	52		 push	 edx
  000c3	89 5d f4	 mov	 DWORD PTR tv481[ebp], ebx
  000c6	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000cb	50		 push	 eax
  000cc	8b 45 0c	 mov	 eax, DWORD PTR tv482[ebp]
  000cf	53		 push	 ebx
  000d0	50		 push	 eax
  000d1	68 2e 02 00 00	 push	 558			; 0000022eH
  000d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000db	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000e0	50		 push	 eax
  000e1	6a 00		 push	 0
  000e3	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000e8	83 c4 1c	 add	 esp, 28			; 0000001cH

; 15632: 
; 15633: 	int _r = rand()%100;

  000eb	e8 00 00 00 00	 call	 _rand
  000f0	99		 cdq
  000f1	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000f6	f7 f9		 idiv	 ecx

; 15634: 
; 15635: 	if(lpObj->pInventory[target].m_Option2)

  000f8	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  000fe	03 c7		 add	 eax, edi
  00100	80 78 79 00	 cmp	 BYTE PTR [eax+121], 0
  00104	74 48		 je	 SHORT $LN14@gObjItemRa

; 15636: 	{
; 15637: 		if(_r < 70)

  00106	83 fa 46	 cmp	 edx, 70			; 00000046H
  00109	7d 0c		 jge	 SHORT $LN13@gObjItemRa

; 15638: 		{
; 15639: 			lpObj->pInventory[target].m_Level++;

  0010b	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00111	8d 44 0f 08	 lea	 eax, DWORD PTR [edi+ecx+8]

; 15640: 		}
; 15641: 		else

  00115	eb 7d		 jmp	 SHORT $LN29@gObjItemRa
$LN13@gObjItemRa:

; 15642: 		{
; 15643: 			if(lpObj->pInventory[target].m_Level >= 7)

  00117	66 83 78 08 07	 cmp	 WORD PTR [eax+8], 7
  0011c	7c 08		 jl	 SHORT $LN11@gObjItemRa

; 15644: 			{
; 15645: 				lpObj->pInventory[target].m_Level = 0;

  0011e	33 d2		 xor	 edx, edx
  00120	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 15646: 			}
; 15647: 			else

  00124	eb 71		 jmp	 SHORT $LN3@gObjItemRa
$LN11@gObjItemRa:

; 15648: 			{
; 15649: 				lpObj->pInventory[target].m_Level--;

  00126	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0012c	66 ff 4c 07 08	 dec	 WORD PTR [edi+eax+8]

; 15650: 
; 15651: 				if(lpObj->pInventory[target].m_Level < 0)

  00131	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00137	66 83 7c 0f 08
	00		 cmp	 WORD PTR [edi+ecx+8], 0
  0013d	8d 44 07 08	 lea	 eax, DWORD PTR [edi+eax+8]
  00141	7d 54		 jge	 SHORT $LN3@gObjItemRa

; 15652: 				{
; 15653: 					lpObj->pInventory[target].m_Level = 0;

  00143	8b d1		 mov	 edx, ecx
  00145	33 c0		 xor	 eax, eax
  00147	66 89 44 17 08	 mov	 WORD PTR [edi+edx+8], ax

; 15654: 				}
; 15655: 			}
; 15656: 		}
; 15657: 	}
; 15658: 	else

  0014c	eb 49		 jmp	 SHORT $LN3@gObjItemRa
$LN14@gObjItemRa:

; 15659: 	{
; 15660: 		if(_r < 55)

  0014e	83 fa 37	 cmp	 edx, 55			; 00000037H
  00151	7d 37		 jge	 SHORT $LN7@gObjItemRa

; 15661: 		{
; 15662: 			if(lpObj->pInventory[target].m_Level >= 7)

  00153	66 83 78 08 07	 cmp	 WORD PTR [eax+8], 7
  00158	7c 08		 jl	 SHORT $LN6@gObjItemRa

; 15663: 			{
; 15664: 				lpObj->pInventory[target].m_Level = 0;

  0015a	33 c9		 xor	 ecx, ecx
  0015c	66 89 48 08	 mov	 WORD PTR [eax+8], cx

; 15665: 			}
; 15666: 			else

  00160	eb 35		 jmp	 SHORT $LN3@gObjItemRa
$LN6@gObjItemRa:

; 15667: 			{
; 15668: 				lpObj->pInventory[target].m_Level--;

  00162	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00168	66 ff 4c 17 08	 dec	 WORD PTR [edi+edx+8]
  0016d	8d 44 17 08	 lea	 eax, DWORD PTR [edi+edx+8]

; 15669: 
; 15670: 				if(lpObj->pInventory[target].m_Level < 0)

  00171	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00177	66 83 7c 07 08
	00		 cmp	 WORD PTR [edi+eax+8], 0
  0017d	7d 18		 jge	 SHORT $LN3@gObjItemRa

; 15671: 				{
; 15672: 					lpObj->pInventory[target].m_Level = 0;

  0017f	8b c8		 mov	 ecx, eax
  00181	33 d2		 xor	 edx, edx
  00183	66 89 54 0f 08	 mov	 WORD PTR [edi+ecx+8], dx

; 15673: 				}
; 15674: 			}
; 15675: 		}
; 15676: 		else

  00188	eb 0d		 jmp	 SHORT $LN3@gObjItemRa
$LN7@gObjItemRa:

; 15677: 		{
; 15678: 			lpObj->pInventory[target].m_Level++;

  0018a	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00190	8d 44 07 08	 lea	 eax, DWORD PTR [edi+eax+8]
$LN29@gObjItemRa:
  00194	66 ff 00	 inc	 WORD PTR [eax]
$LN3@gObjItemRa:

; 15679: 		}
; 15680: 	}
; 15681: 
; 15682: 	if(lpObj->pInventory[target].m_Level > 9)

  00197	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0019d	66 83 7c 0f 08
	09		 cmp	 WORD PTR [edi+ecx+8], 9
  001a3	8d 44 0f 08	 lea	 eax, DWORD PTR [edi+ecx+8]
  001a7	7e 0a		 jle	 SHORT $LN2@gObjItemRa

; 15683: 	{
; 15684: 		lpObj->pInventory[target].m_Level = 9;

  001a9	ba 09 00 00 00	 mov	 edx, 9
  001ae	66 89 10	 mov	 WORD PTR [eax], dx

; 15685: 	}
; 15686: 	else

  001b1	eb 0b		 jmp	 SHORT $LN1@gObjItemRa
$LN2@gObjItemRa:

; 15687: 	{
; 15688: 		gObjMakePreviewCharSet(lpObj->m_Index);

  001b3	8b 06		 mov	 eax, DWORD PTR [esi]
  001b5	50		 push	 eax
  001b6	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  001bb	83 c4 04	 add	 esp, 4
$LN1@gObjItemRa:

; 15689: 	}
; 15690: 
; 15691: 	float levelitemdur = ItemGetDurability(lpObj->pInventory[target].m_Type,lpObj->pInventory[target].m_Level,lpObj->pInventory[target].IsExtItem(),lpObj->pInventory[target].IsSetItem());

  001be	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  001c4	8d 1c 0f	 lea	 ebx, DWORD PTR [edi+ecx]
  001c7	8d 0c 0f	 lea	 ecx, DWORD PTR [edi+ecx]
  001ca	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  001cf	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  001d5	50		 push	 eax
  001d6	03 cf		 add	 ecx, edi
  001d8	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  001dd	0f bf 53 08	 movsx	 edx, WORD PTR [ebx+8]
  001e1	50		 push	 eax
  001e2	0f bf 43 06	 movsx	 eax, WORD PTR [ebx+6]
  001e6	52		 push	 edx
  001e7	50		 push	 eax
  001e8	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability

; 15692: 
; 15693: 	lpObj->pInventory[target].m_Durability = levelitemdur * lpObj->pInventory[target].m_Durability / lpObj->pInventory[target].m_BaseDurability;

  001ed	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  001f3	89 45 fc	 mov	 DWORD PTR tv519[ebp], eax
  001f6	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  001f9	db 45 fc	 fild	 DWORD PTR tv519[ebp]
  001fc	83 c4 10	 add	 esp, 16			; 00000010H

; 15694: 
; 15695: 	lpObj->pInventory[target].Convert(
; 15696: 			lpObj->pInventory[target].m_Type,
; 15697: 			lpObj->pInventory[target].m_Option1,
; 15698: 			lpObj->pInventory[target].m_Option2,
; 15699: 			lpObj->pInventory[target].m_Option3,
; 15700: 			lpObj->pInventory[target].m_NewOption,
; 15701: 			lpObj->pInventory[target].m_SetOption, 0, CURRENT_DB_VERSION);

  001ff	6a 03		 push	 3
  00201	6a 00		 push	 0
  00203	d9 5d fc	 fstp	 DWORD PTR _levelitemdur$[ebp]
  00206	d9 40 24	 fld	 DWORD PTR [eax+36]
  00209	d8 4d fc	 fmul	 DWORD PTR _levelitemdur$[ebp]
  0020c	d8 70 2c	 fdiv	 DWORD PTR [eax+44]
  0020f	d9 58 24	 fstp	 DWORD PTR [eax+36]
  00212	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00218	0f b6 84 17 92
	00 00 00	 movzx	 eax, BYTE PTR [edi+edx+146]
  00220	8d 0c 17	 lea	 ecx, DWORD PTR [edi+edx]
  00223	0f b6 51 7b	 movzx	 edx, BYTE PTR [ecx+123]
  00227	50		 push	 eax
  00228	0f b6 41 7a	 movzx	 eax, BYTE PTR [ecx+122]
  0022c	52		 push	 edx
  0022d	0f b6 51 79	 movzx	 edx, BYTE PTR [ecx+121]
  00231	50		 push	 eax
  00232	0f b6 41 78	 movzx	 eax, BYTE PTR [ecx+120]
  00236	52		 push	 edx
  00237	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  0023b	50		 push	 eax
  0023c	52		 push	 edx
  0023d	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEE@Z ; CItem::Convert

; 15702: 
; 15703: 	LogAdd(LOG_BLACK, lMsg.Get(559),lpObj->AccountID,lpObj->Name,lpObj->pInventory[source].m_Number,
; 15704: 			lpObj->pInventory[target].GetName(),lpObj->pInventory[target].m_Number,lpObj->pInventory[target].m_Level);

  00242	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00248	0f bf 54 07 08	 movsx	 edx, WORD PTR [edi+eax+8]
  0024d	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00250	8b 01		 mov	 eax, DWORD PTR [ecx]
  00252	52		 push	 edx
  00253	50		 push	 eax
  00254	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00259	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0025f	8b 55 f8	 mov	 edx, DWORD PTR tv453[ebp]
  00262	50		 push	 eax
  00263	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00266	8b 4d f4	 mov	 ecx, DWORD PTR tv481[ebp]
  00269	8b 55 0c	 mov	 edx, DWORD PTR tv482[ebp]
  0026c	50		 push	 eax
  0026d	51		 push	 ecx
  0026e	52		 push	 edx
  0026f	68 2f 02 00 00	 push	 559			; 0000022fH
  00274	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00279	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0027e	50		 push	 eax
  0027f	6a 00		 push	 0
  00281	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00286	83 c4 20	 add	 esp, 32			; 00000020H
  00289	5b		 pop	 ebx
  0028a	5e		 pop	 esi

; 15705: 
; 15706: 	return true;

  0028b	b8 01 00 00 00	 mov	 eax, 1
  00290	5f		 pop	 edi

; 15707: }

  00291	8b e5		 mov	 esp, ebp
  00293	5d		 pop	 ebp
  00294	c3		 ret	 0
$LN17@gObjItemRa:
  00295	5e		 pop	 esi

; 15620: 	{
; 15621: 		return false;

  00296	33 c0		 xor	 eax, eax
  00298	5f		 pop	 edi

; 15707: }

  00299	8b e5		 mov	 esp, ebp
  0029b	5d		 pop	 ebp
  0029c	c3		 ret	 0
$LN21@gObjItemRa:

; 15602: 	{
; 15603: 		return false;

  0029d	33 c0		 xor	 eax, eax
  0029f	5f		 pop	 edi

; 15707: }

  002a0	8b e5		 mov	 esp, ebp
  002a2	5d		 pop	 ebp
  002a3	c3		 ret	 0
$LN23@gObjItemRa:

; 15597: 	{
; 15598: 		return false;

  002a4	33 c0		 xor	 eax, eax

; 15707: }

  002a6	8b e5		 mov	 esp, ebp
  002a8	5d		 pop	 ebp
  002a9	c3		 ret	 0
?gObjItemRandomLevelUp@@YAHPAUOBJECTSTRUCT@@HH@Z ENDP	; gObjItemRandomLevelUp
_TEXT	ENDS
PUBLIC	??_C@_0FO@HEPLMOKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5JewelofLife?5Result?5?$FL?$CFd?0@ ; `string'
PUBLIC	??_C@_0EJ@NOHGJCPC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5After?5using?5Jewel?5of?5Li@ ; `string'
PUBLIC	_target$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjItemRandomOption3Up@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjItemRandomOption3Up
;	COMDAT ??_C@_0FO@HEPLMOKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5JewelofLife?5Result?5?$FL?$CFd?0@
CONST	SEGMENT
??_C@_0FO@HEPLMOKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5JewelofLife?5Result?5?$FL?$CFd?0@ DB '['
	DB	'%s][%s] JewelofLife Result [%d,%s,%d,%d,%d,%d]serial:[%d] dur'
	DB	':[%d] Ex:[%d,%d,%d,%d,%d,%d,%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@NOHGJCPC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5After?5using?5Jewel?5of?5Li@
CONST	SEGMENT
??_C@_0EJ@NOHGJCPC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5After?5using?5Jewel?5of?5Li@ DB '['
	DB	'%s][%s] After using Jewel of Life -> target:%d item:%s serial'
	DB	':%d opt:%d', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjItemRandomOption3Up@@YAHPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
tv674 = -24						; size = 4
_target$GSCopy$ = -20					; size = 4
tv748 = -16						; size = 4
_levelitemdur$ = -16					; size = 4
tv728 = -14						; size = 2
_NewOption$ = -12					; size = 8
tv725 = -8						; size = 4
tv723 = -8						; size = 4
tv645 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_source$ = 12						; size = 4
_target$ = 16						; size = 4
?gObjItemRandomOption3Up@@YAHPAUOBJECTSTRUCT@@HH@Z PROC	; gObjItemRandomOption3Up, COMDAT

; 15710: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 10	 mov	 edi, DWORD PTR _target$[ebp]

; 15827: 		}
; 15828: 
; 15829: 	gObjMakePreviewCharSet(lpObj->m_Index);

  0001b	89 7d ec	 mov	 DWORD PTR _target$GSCopy$[ebp], edi
  0001e	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  00021	0f 87 d3 03 00
	00		 ja	 $LN28@gObjItemRa@2

; 15711: 	if(source < 0 || source > MAIN_INVENTORY_SIZE -1)
; 15712: 	{
; 15713: 		return false;
; 15714: 	}
; 15715: 
; 15716: 	if(target < 0 || target > MAIN_INVENTORY_SIZE -1)

  00027	83 ff 4b	 cmp	 edi, 75			; 0000004bH
  0002a	0f 87 ca 03 00
	00		 ja	 $LN28@gObjItemRa@2

; 15717: 	{
; 15718: 		return false;
; 15719: 	}
; 15720: 
; 15721: 	if(lpObj->pInventory[source].IsItem() == 0)

  00030	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00036	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  0003c	03 c8		 add	 ecx, eax
  0003e	89 45 f8	 mov	 DWORD PTR tv645[ebp], eax
  00041	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00046	85 c0		 test	 eax, eax

; 15722: 	{
; 15723: 		return false;

  00048	0f 84 ac 03 00
	00		 je	 $LN28@gObjItemRa@2

; 15724: 	}
; 15725: 
; 15726: 	if(lpObj->pInventory[target].IsItem() == 0)

  0004e	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00054	69 ff a8 00 00
	00		 imul	 edi, 168		; 000000a8H
  0005a	03 cf		 add	 ecx, edi
  0005c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00061	85 c0		 test	 eax, eax

; 15727: 	{
; 15728: 		return false;

  00063	0f 84 91 03 00
	00		 je	 $LN28@gObjItemRa@2

; 15729: 	}
; 15730: 
; 15731: 	if(!(lpObj->pInventory[target].m_Type < ITEMGET(12,7)
; 15732: 		|| lpObj->pInventory[target].m_Type == ITEMGET(13,30))
; 15733: 		|| lpObj->pInventory[target].m_Type == ITEMGET(4,7)
; 15734: 		|| lpObj->pInventory[target].m_Type == ITEMGET(4,15))

  00069	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0006f	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00072	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00076	ba 07 18 00 00	 mov	 edx, 6151		; 00001807H
  0007b	66 3b c2	 cmp	 ax, dx
  0007e	7c 0e		 jl	 SHORT $LN21@gObjItemRa@2
  00080	ba 1e 1a 00 00	 mov	 edx, 6686		; 00001a1eH
  00085	66 3b c2	 cmp	 ax, dx
  00088	0f 85 6c 03 00
	00		 jne	 $LN28@gObjItemRa@2
$LN21@gObjItemRa@2:
  0008e	ba 07 08 00 00	 mov	 edx, 2055		; 00000807H
  00093	66 3b c2	 cmp	 ax, dx
  00096	0f 84 5e 03 00
	00		 je	 $LN28@gObjItemRa@2
  0009c	ba 0f 08 00 00	 mov	 edx, 2063		; 0000080fH
  000a1	66 3b c2	 cmp	 ax, dx
  000a4	0f 84 50 03 00
	00		 je	 $LN28@gObjItemRa@2

; 15735: 	{
; 15736: 		return false;
; 15737: 	}
; 15738: //fix +28 limitador
; 15739: 	if (lpObj->pInventory[target].m_Option3 >= 7)

  000aa	80 79 7a 07	 cmp	 BYTE PTR [ecx+122], 7

; 15740: 	{
; 15741: 		return FALSE;

  000ae	0f 83 46 03 00
	00		 jae	 $LN28@gObjItemRa@2

; 15742: 	}
; 15743: 
; 15744: 	LogAdd(LOG_BLACK, lMsg.Get(576),
; 15745: 		lpObj->AccountID,lpObj->Name,
; 15746: 		lpObj->pInventory[target].GetName(),
; 15747: 		lpObj->pInventory[target].m_Number,
; 15748: 		lpObj->pInventory[target].m_Option3);

  000b4	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  000ba	0f b6 54 07 7a	 movzx	 edx, BYTE PTR [edi+eax+122]
  000bf	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  000c2	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c4	53		 push	 ebx
  000c5	52		 push	 edx
  000c6	50		 push	 eax
  000c7	8d 5e 6f	 lea	 ebx, DWORD PTR [esi+111]
  000ca	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000cf	50		 push	 eax
  000d0	53		 push	 ebx
  000d1	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  000d4	50		 push	 eax
  000d5	68 40 02 00 00	 push	 576			; 00000240H
  000da	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000df	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000e4	50		 push	 eax
  000e5	6a 00		 push	 0
  000e7	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000ec	83 c4 1c	 add	 esp, 28			; 0000001cH

; 15749: 
; 15750: 	int _r = rand()%100;

  000ef	e8 00 00 00 00	 call	 _rand
  000f4	99		 cdq
  000f5	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000fa	f7 f9		 idiv	 ecx
  000fc	8b da		 mov	 ebx, edx

; 15751: 	//int Rate	= rand()%100;
; 15752: 	//int Success = NN_LifeSucessRate;
; 15753: 
; 15754: 	int loc2;
; 15755: 	int loc3;
; 15756: 
; 15757: 	if(lpObj->pInventory[target].m_Option3 == 0)

  000fe	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00104	80 7c 17 7a 00	 cmp	 BYTE PTR [edi+edx+122], 0
  00109	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  0010c	75 49		 jne	 SHORT $LN32@gObjItemRa@2

; 15758: 	{
; 15759: 		if(lpObj->pInventory[target].m_Type >= ITEMGET(12,3) && lpObj->pInventory[target].m_Type <= ITEMGET(12,6))

  0010e	0f b7 40 06	 movzx	 eax, WORD PTR [eax+6]
  00112	b9 03 18 00 00	 mov	 ecx, 6147		; 00001803H
  00117	66 3b c1	 cmp	 ax, cx
  0011a	7c 3b		 jl	 SHORT $LN32@gObjItemRa@2
  0011c	ba 06 18 00 00	 mov	 edx, 6150		; 00001806H
  00121	66 3b c2	 cmp	 ax, dx
  00124	7f 31		 jg	 SHORT $LN32@gObjItemRa@2

; 15760: 		{
; 15761: 			lpObj->pInventory[target].m_NewOption &= 0xDF;

  00126	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0012c	80 64 07 7b df	 and	 BYTE PTR [edi+eax+123], 223 ; 000000dfH
  00131	8d 44 07 7b	 lea	 eax, DWORD PTR [edi+eax+123]

; 15762: 
; 15763: 			if(rand()%2)

  00135	e8 00 00 00 00	 call	 _rand
  0013a	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0013f	79 05		 jns	 SHORT $LN35@gObjItemRa@2
  00141	48		 dec	 eax
  00142	83 c8 fe	 or	 eax, -2			; fffffffeH
  00145	40		 inc	 eax
$LN35@gObjItemRa@2:
  00146	74 0f		 je	 SHORT $LN32@gObjItemRa@2

; 15764: 			{
; 15765: 				lpObj->pInventory[target].m_NewOption |= 0x20;

  00148	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0014e	80 4c 0f 7b 20	 or	 BYTE PTR [edi+ecx+123], 32 ; 00000020H
  00153	8d 44 0f 7b	 lea	 eax, DWORD PTR [edi+ecx+123]
$LN32@gObjItemRa@2:

; 15766: 			}
; 15767: 		}
; 15768: 	}
; 15769: 	//fix +28
; 15770: 	if (_r < 50) //jewel of life rate

  00157	83 fb 32	 cmp	 ebx, 50			; 00000032H
  0015a	7d 10		 jge	 SHORT $LN16@gObjItemRa@2

; 15771: 	{
; 15772: 		lpObj->pInventory[target].m_Option3 = 0;

  0015c	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00162	c6 44 17 7a 00	 mov	 BYTE PTR [edi+edx+122], 0

; 15773: 	}
; 15774: 	else

  00167	e9 15 01 00 00	 jmp	 $LN15@gObjItemRa@2
$LN16@gObjItemRa@2:

; 15775: 	{
; 15776: 		// mke wings option
; 15777: 		if ((lpObj->pInventory[target].m_Option3) == FALSE)

  0016c	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00172	80 7c 38 7a 00	 cmp	 BYTE PTR [eax+edi+122], 0
  00177	0f 85 f6 00 00
	00		 jne	 $LN3@gObjItemRa@2

; 15778: 		{
; 15779: 			//2lvl wings (random opt)
; 15780: 			if (
; 15781: 				(lpObj->pInventory[target].m_Type >= ITEMGET(12,3) && lpObj->pInventory[target].m_Type <= ITEMGET(12,6)) || 
; 15782: 				lpObj->pInventory[target].m_Type == ITEMGET(12,42))

  0017d	0f b7 44 38 06	 movzx	 eax, WORD PTR [eax+edi+6]
  00182	b9 03 18 00 00	 mov	 ecx, 6147		; 00001803H
  00187	66 3b c1	 cmp	 ax, cx
  0018a	7c 0a		 jl	 SHORT $LN11@gObjItemRa@2
  0018c	ba 06 18 00 00	 mov	 edx, 6150		; 00001806H
  00191	66 3b c2	 cmp	 ax, dx
  00194	7e 0a		 jle	 SHORT $LN12@gObjItemRa@2
$LN11@gObjItemRa@2:
  00196	b9 2a 18 00 00	 mov	 ecx, 6186		; 0000182aH
  0019b	66 3b c1	 cmp	 ax, cx
  0019e	75 31		 jne	 SHORT $LN10@gObjItemRa@2
$LN12@gObjItemRa@2:

; 15783: 			{
; 15784: 				lpObj->pInventory[target].m_NewOption &= 0xDF;

  001a0	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  001a6	80 64 17 7b df	 and	 BYTE PTR [edi+edx+123], 223 ; 000000dfH
  001ab	8d 44 17 7b	 lea	 eax, DWORD PTR [edi+edx+123]

; 15785: 
; 15786: 				if (rand()%2)

  001af	e8 00 00 00 00	 call	 _rand
  001b4	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  001b9	79 05		 jns	 SHORT $LN36@gObjItemRa@2
  001bb	48		 dec	 eax
  001bc	83 c8 fe	 or	 eax, -2			; fffffffeH
  001bf	40		 inc	 eax
$LN36@gObjItemRa@2:
  001c0	74 0f		 je	 SHORT $LN10@gObjItemRa@2

; 15787: 				{
; 15788: 					lpObj->pInventory[target].m_NewOption |= 0x20;

  001c2	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  001c8	80 4c 07 7b 20	 or	 BYTE PTR [edi+eax+123], 32 ; 00000020H
  001cd	8d 44 07 7b	 lea	 eax, DWORD PTR [edi+eax+123]
$LN10@gObjItemRa@2:

; 15789: 				}
; 15790: 			}
; 15791: 
; 15792: 			// 3lvl wings (random opt)
; 15793: 			if (
; 15794: 				(lpObj->pInventory[target].m_Type >= ITEMGET(12,36) && lpObj->pInventory[target].m_Type <= ITEMGET(12,40)) || 
; 15795: 				lpObj->pInventory[target].m_Type == ITEMGET(12,43) || 
; 15796: 				lpObj->pInventory[target].m_Type == ITEMGET(12,50)
; 15797: 			) {

  001d1	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  001d7	0f b7 44 0f 06	 movzx	 eax, WORD PTR [edi+ecx+6]
  001dc	ba 24 18 00 00	 mov	 edx, 6180		; 00001824H
  001e1	66 3b c2	 cmp	 ax, dx
  001e4	7c 0a		 jl	 SHORT $LN7@gObjItemRa@2
  001e6	b9 28 18 00 00	 mov	 ecx, 6184		; 00001828H
  001eb	66 3b c1	 cmp	 ax, cx
  001ee	7e 14		 jle	 SHORT $LN8@gObjItemRa@2
$LN7@gObjItemRa@2:
  001f0	ba 2b 18 00 00	 mov	 edx, 6187		; 0000182bH
  001f5	66 3b c2	 cmp	 ax, dx
  001f8	74 0a		 je	 SHORT $LN8@gObjItemRa@2
  001fa	b9 32 18 00 00	 mov	 ecx, 6194		; 00001832H
  001ff	66 3b c1	 cmp	 ax, cx
  00202	75 6f		 jne	 SHORT $LN3@gObjItemRa@2
$LN8@gObjItemRa@2:

; 15798: 				lpObj->pInventory[target].m_NewOption &= 0xEF;

  00204	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  0020a	80 64 17 7b ef	 and	 BYTE PTR [edi+edx+123], 239 ; 000000efH
  0020f	8d 44 17 7b	 lea	 eax, DWORD PTR [edi+edx+123]

; 15799: 				lpObj->pInventory[target].m_NewOption &= 0xDF;

  00213	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00219	80 64 07 7b df	 and	 BYTE PTR [edi+eax+123], 223 ; 000000dfH
  0021e	8d 44 07 7b	 lea	 eax, DWORD PTR [edi+eax+123]

; 15800: 					
; 15801: 					loc2 = rand()%2;

  00222	e8 00 00 00 00	 call	 _rand
  00227	8b d8		 mov	 ebx, eax
  00229	81 e3 01 00 00
	80		 and	 ebx, -2147483647	; 80000001H
  0022f	79 05		 jns	 SHORT $LN37@gObjItemRa@2
  00231	4b		 dec	 ebx
  00232	83 cb fe	 or	 ebx, -2			; fffffffeH
  00235	43		 inc	 ebx
$LN37@gObjItemRa@2:

; 15802: 					loc3 = rand()%1000;

  00236	e8 00 00 00 00	 call	 _rand
  0023b	99		 cdq
  0023c	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00241	f7 f9		 idiv	 ecx

; 15803: 
; 15804: 					switch(loc2)

  00243	83 eb 00	 sub	 ebx, 0
  00246	74 14		 je	 SHORT $LN4@gObjItemRa@2
  00248	4b		 dec	 ebx
  00249	75 28		 jne	 SHORT $LN3@gObjItemRa@2

; 15811: 							}
; 15812: 						}
; 15813: 						break;
; 15814: 						
; 15815: 						case 1:
; 15816: 						{
; 15817: 							if (loc2 < 300)
; 15818: 							{
; 15819: 								lpObj->pInventory[target].m_NewOption |= 0x20;

  0024b	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00251	80 4c 17 7b 20	 or	 BYTE PTR [edi+edx+123], 32 ; 00000020H
  00256	8d 44 17 7b	 lea	 eax, DWORD PTR [edi+edx+123]

; 15820: 							}
; 15821: 						}
; 15822: 						break;

  0025a	eb 17		 jmp	 SHORT $LN3@gObjItemRa@2
$LN4@gObjItemRa@2:

; 15805: 					{
; 15806: 						case 0:
; 15807: 						{
; 15808: 							if (loc3 < 400)

  0025c	81 fa 90 01 00
	00		 cmp	 edx, 400		; 00000190H
  00262	7d 0f		 jge	 SHORT $LN3@gObjItemRa@2

; 15809: 							{
; 15810: 								lpObj->pInventory[target].m_NewOption |= 0x10;

  00264	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0026a	80 4c 07 7b 10	 or	 BYTE PTR [edi+eax+123], 16 ; 00000010H
  0026f	8d 44 07 7b	 lea	 eax, DWORD PTR [edi+eax+123]
$LN3@gObjItemRa@2:

; 15823: 					}
; 15824: 				}
; 15825: 			}
; 15826: 			lpObj->pInventory[target].m_Option3++;

  00273	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00279	fe 44 0f 7a	 inc	 BYTE PTR [edi+ecx+122]
  0027d	8d 44 0f 7a	 lea	 eax, DWORD PTR [edi+ecx+122]
$LN15@gObjItemRa@2:

; 15827: 		}
; 15828: 
; 15829: 	gObjMakePreviewCharSet(lpObj->m_Index);

  00281	8b 16		 mov	 edx, DWORD PTR [esi]
  00283	52		 push	 edx
  00284	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 15830: 
; 15831: 	float levelitemdur = ItemGetDurability(lpObj->pInventory[target].m_Type,lpObj->pInventory[target].m_Level,lpObj->pInventory[target].IsExtItem(),lpObj->pInventory[target].IsSetItem());

  00289	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0028f	83 c4 04	 add	 esp, 4
  00292	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00295	8d 1c 07	 lea	 ebx, DWORD PTR [edi+eax]
  00298	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  0029d	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  002a3	50		 push	 eax
  002a4	03 cf		 add	 ecx, edi
  002a6	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  002ab	0f bf 4b 08	 movsx	 ecx, WORD PTR [ebx+8]
  002af	0f bf 53 06	 movsx	 edx, WORD PTR [ebx+6]
  002b3	50		 push	 eax
  002b4	51		 push	 ecx
  002b5	52		 push	 edx
  002b6	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  002bb	89 45 f0	 mov	 DWORD PTR tv748[ebp], eax

; 15832: 
; 15833: 	lpObj->pInventory[target].m_Durability = levelitemdur * lpObj->pInventory[target].m_Durability / lpObj->pInventory[target].m_BaseDurability;

  002be	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  002c4	db 45 f0	 fild	 DWORD PTR tv748[ebp]
  002c7	83 c4 10	 add	 esp, 16			; 00000010H

; 15834: 
; 15835: 	lpObj->pInventory[target].Convert(
; 15836: 			lpObj->pInventory[target].m_Type,
; 15837: 			lpObj->pInventory[target].m_Option1,
; 15838: 			lpObj->pInventory[target].m_Option2,
; 15839: 			lpObj->pInventory[target].m_Option3,
; 15840: 			lpObj->pInventory[target].m_NewOption,
; 15841: 			lpObj->pInventory[target].m_SetOption, 0, CURRENT_DB_VERSION);

  002ca	6a 03		 push	 3
  002cc	6a 00		 push	 0
  002ce	d9 5d f0	 fstp	 DWORD PTR _levelitemdur$[ebp]
  002d1	d9 44 38 24	 fld	 DWORD PTR [eax+edi+36]
  002d5	d8 4d f0	 fmul	 DWORD PTR _levelitemdur$[ebp]
  002d8	d8 74 38 2c	 fdiv	 DWORD PTR [eax+edi+44]
  002dc	d9 5c 38 24	 fstp	 DWORD PTR [eax+edi+36]
  002e0	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  002e6	0f b6 94 39 92
	00 00 00	 movzx	 edx, BYTE PTR [ecx+edi+146]
  002ee	0f b6 44 39 7b	 movzx	 eax, BYTE PTR [ecx+edi+123]
  002f3	03 cf		 add	 ecx, edi
  002f5	52		 push	 edx
  002f6	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  002fa	50		 push	 eax
  002fb	0f b6 41 79	 movzx	 eax, BYTE PTR [ecx+121]
  002ff	52		 push	 edx
  00300	0f b6 51 78	 movzx	 edx, BYTE PTR [ecx+120]
  00304	50		 push	 eax
  00305	0f bf 41 06	 movsx	 eax, WORD PTR [ecx+6]
  00309	52		 push	 edx
  0030a	50		 push	 eax
  0030b	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEE@Z ; CItem::Convert

; 15842: 
; 15843: 	LogAdd(LOG_BLACK, "[%s][%s] After using Jewel of Life -> target:%d item:%s serial:%d opt:%d", lpObj->AccountID, lpObj->Name, lpObj->pInventory[source].m_Number, 
; 15844:   lpObj->pInventory[target].GetName(),lpObj->pInventory[target].m_Number,lpObj->pInventory[target].m_Option3);

  00310	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00316	0f b6 54 39 7a	 movzx	 edx, BYTE PTR [ecx+edi+122]
  0031b	8b 04 39	 mov	 eax, DWORD PTR [ecx+edi]
  0031e	03 cf		 add	 ecx, edi
  00320	52		 push	 edx
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00327	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0032d	8b 55 f8	 mov	 edx, DWORD PTR tv645[ebp]
  00330	50		 push	 eax
  00331	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00334	50		 push	 eax
  00335	8d 5e 6f	 lea	 ebx, DWORD PTR [esi+111]
  00338	53		 push	 ebx
  00339	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  0033c	50		 push	 eax
  0033d	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@NOHGJCPC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5After?5using?5Jewel?5of?5Li@
  00342	6a 00		 push	 0
  00344	89 45 e8	 mov	 DWORD PTR tv674[ebp], eax
  00347	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 15845: 
; 15846: 	BYTE NewOption[8];
; 15847: 
; 15848: 	ItemIsBufExOption(NewOption,&lpObj->pInventory[target]);

  0034c	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00352	03 cf		 add	 ecx, edi
  00354	51		 push	 ecx
  00355	8d 55 f4	 lea	 edx, DWORD PTR _NewOption$[ebp]
  00358	52		 push	 edx
  00359	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 15849: 
; 15850: 	LogAdd(LOG_BLACK, "[%s][%s] JewelofLife Result [%d,%s,%d,%d,%d,%d]serial:[%d] dur:[%d] Ex:[%d,%d,%d,%d,%d,%d,%d]",
; 15851: 			lpObj->AccountID,lpObj->Name,target,lpObj->pInventory[target].GetName(),
; 15852: 			lpObj->pInventory[target].m_Level,lpObj->pInventory[target].m_Option1,lpObj->pInventory[target].m_Option2,
; 15853: 			lpObj->pInventory[target].m_Option3,lpObj->pInventory[target].m_Number,
; 15854: 			BYTE(lpObj->pInventory[target].m_Durability),NewOption[0],NewOption[1],NewOption[2],NewOption[3],
; 15855: 			NewOption[4],NewOption[5],NewOption[6]);

  0035e	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00364	0f b6 55 fa	 movzx	 edx, BYTE PTR _NewOption$[ebp+6]
  00368	83 c4 28	 add	 esp, 40			; 00000028H
  0036b	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0036e	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$[ebp+5]
  00372	52		 push	 edx
  00373	0f b6 55 f8	 movzx	 edx, BYTE PTR _NewOption$[ebp+4]
  00377	50		 push	 eax
  00378	0f b6 45 f7	 movzx	 eax, BYTE PTR _NewOption$[ebp+3]
  0037c	52		 push	 edx
  0037d	50		 push	 eax
  0037e	0f b6 55 f6	 movzx	 edx, BYTE PTR _NewOption$[ebp+2]
  00382	d9 41 24	 fld	 DWORD PTR [ecx+36]
  00385	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$[ebp+1]
  00389	d9 7d f2	 fnstcw	 WORD PTR tv728[ebp]
  0038c	52		 push	 edx
  0038d	0f b6 55 f4	 movzx	 edx, BYTE PTR _NewOption$[ebp]
  00391	50		 push	 eax
  00392	0f b7 45 f2	 movzx	 eax, WORD PTR tv728[ebp]
  00396	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0039b	89 45 f8	 mov	 DWORD PTR tv725[ebp], eax
  0039e	52		 push	 edx
  0039f	d9 6d f8	 fldcw	 WORD PTR tv725[ebp]
  003a2	db 5d f8	 fistp	 DWORD PTR tv723[ebp]
  003a5	8a 45 f8	 mov	 al, BYTE PTR tv723[ebp]
  003a8	0f b6 d0	 movzx	 edx, al
  003ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  003ad	52		 push	 edx
  003ae	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  003b2	d9 6d f2	 fldcw	 WORD PTR tv728[ebp]
  003b5	50		 push	 eax
  003b6	0f b6 41 79	 movzx	 eax, BYTE PTR [ecx+121]
  003ba	52		 push	 edx
  003bb	0f b6 51 78	 movzx	 edx, BYTE PTR [ecx+120]
  003bf	50		 push	 eax
  003c0	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  003c4	52		 push	 edx
  003c5	50		 push	 eax
  003c6	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  003cb	8b 4d ec	 mov	 ecx, DWORD PTR _target$GSCopy$[ebp]
  003ce	8b 55 e8	 mov	 edx, DWORD PTR tv674[ebp]
  003d1	50		 push	 eax
  003d2	51		 push	 ecx
  003d3	53		 push	 ebx
  003d4	52		 push	 edx
  003d5	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@HEPLMOKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5JewelofLife?5Result?5?$FL?$CFd?0@
  003da	6a 00		 push	 0
  003dc	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  003e1	83 c4 4c	 add	 esp, 76			; 0000004cH
  003e4	5b		 pop	 ebx
  003e5	5f		 pop	 edi

; 15856: 
; 15857: 	return true;

  003e6	b8 01 00 00 00	 mov	 eax, 1
  003eb	5e		 pop	 esi

; 15858: }

  003ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ef	33 cd		 xor	 ecx, ebp
  003f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f6	8b e5		 mov	 esp, ebp
  003f8	5d		 pop	 ebp
  003f9	c3		 ret	 0
$LN28@gObjItemRa@2:
  003fa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003fd	5f		 pop	 edi
  003fe	33 cd		 xor	 ecx, ebp
  00400	33 c0		 xor	 eax, eax
  00402	5e		 pop	 esi
  00403	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00408	8b e5		 mov	 esp, ebp
  0040a	5d		 pop	 ebp
  0040b	c3		 ret	 0
?gObjItemRandomOption3Up@@YAHPAUOBJECTSTRUCT@@HH@Z ENDP	; gObjItemRandomOption3Up
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	?gObjAbilityReSet@@YAXPAUOBJECTSTRUCT@@@Z	; gObjAbilityReSet
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjAbilityReSet@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv320 = 8						; size = 4
tv318 = 8						; size = 4
tv315 = 8						; size = 4
tv312 = 8						; size = 4
tv307 = 8						; size = 4
tv306 = 8						; size = 4
tv301 = 8						; size = 4
_lpObj$ = 8						; size = 4
?gObjAbilityReSet@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjAbilityReSet, COMDAT

; 15861: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15862: 	lpObj->LevelUpPoint = (lpObj->Level - 1) * 5;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	0f bf 90 9c 00
	00 00		 movsx	 edx, WORD PTR [eax+156]
  0000d	56		 push	 esi

; 15863: 
; 15864: 	lpObj->Strength = DCInfo.DefClass[lpObj->Class].Strength;

  0000e	0f b7 b0 98 00
	00 00		 movzx	 esi, WORD PTR [eax+152]
  00015	8d 4c 92 fb	 lea	 ecx, DWORD PTR [edx+edx*4-5]
  00019	89 88 a0 00 00
	00		 mov	 DWORD PTR [eax+160], ecx
  0001f	8b ce		 mov	 ecx, esi
  00021	69 c9 60 09 00
	00		 imul	 ecx, 2400		; 00000960H
  00027	57		 push	 edi
  00028	0f b7 b9 08 00
	00 00		 movzx	 edi, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+8]
  0002f	66 89 b8 b4 00
	00 00		 mov	 WORD PTR [eax+180], di

; 15865: 	lpObj->Dexterity = DCInfo.DefClass[lpObj->Class].Dexterity;

  00036	0f b7 b9 0a 00
	00 00		 movzx	 edi, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+10]
  0003d	66 89 b8 b6 00
	00 00		 mov	 WORD PTR [eax+182], di

; 15866: 	lpObj->Vitality = DCInfo.DefClass[lpObj->Class].Vitality;

  00044	0f b7 b9 0c 00
	00 00		 movzx	 edi, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+12]
  0004b	66 89 b8 b8 00
	00 00		 mov	 WORD PTR [eax+184], di

; 15867: 	lpObj->Energy = DCInfo.DefClass[lpObj->Class].Energy;

  00052	0f b7 b9 0e 00
	00 00		 movzx	 edi, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+14]
  00059	66 89 b8 ba 00
	00 00		 mov	 WORD PTR [eax+186], di
  00060	5f		 pop	 edi

; 15868: 
; 15869: 	lpObj->MaxLife = DCInfo.DefClass[lpObj->Class].MaxLife;

  00061	d9 81 18 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+24]

; 15870: 	lpObj->MaxMana = DCInfo.DefClass[lpObj->Class].MaxMana;
; 15871: 
; 15872: 	if(lpObj->Class == CLASS_WIZARD)

  00067	66 85 f6	 test	 si, si
  0006a	d9 98 c0 00 00
	00		 fstp	 DWORD PTR [eax+192]
  00070	5e		 pop	 esi
  00071	d9 81 24 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+36]
  00077	d9 98 d4 00 00
	00		 fstp	 DWORD PTR [eax+212]
  0007d	75 39		 jne	 SHORT $LN2@gObjAbilit

; 15873: 	{
; 15874: 		lpObj->MaxLife += (lpObj->Level -1)*0.5f;

  0007f	4a		 dec	 edx
  00080	89 55 08	 mov	 DWORD PTR tv315[ebp], edx
  00083	db 45 08	 fild	 DWORD PTR tv315[ebp]
  00086	d9 5d 08	 fstp	 DWORD PTR tv301[ebp]
  00089	d9 45 08	 fld	 DWORD PTR tv301[ebp]
  0008c	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fe0000000000000
  00092	d8 c9		 fmul	 ST(0), ST(1)
  00094	d8 80 c0 00 00
	00		 fadd	 DWORD PTR [eax+192]
  0009a	d9 5d 08	 fstp	 DWORD PTR tv307[ebp]
  0009d	d9 45 08	 fld	 DWORD PTR tv307[ebp]
  000a0	d9 90 c0 00 00
	00		 fst	 DWORD PTR [eax+192]

; 15875: 		lpObj->MaxMana += 2.0f * (lpObj->Level -1);

  000a6	d9 c9		 fxch	 ST(1)
  000a8	dc c0		 fadd	 ST(0), ST(0)
  000aa	d8 80 d4 00 00
	00		 fadd	 DWORD PTR [eax+212]
  000b0	d9 5d 08	 fstp	 DWORD PTR tv312[ebp]
  000b3	d9 45 08	 fld	 DWORD PTR tv312[ebp]

; 15876: 
; 15877: 		lpObj->Life = lpObj->MaxLife;
; 15878: 		lpObj->Mana = lpObj->MaxMana;
; 15879: 	}
; 15880: 	else

  000b6	eb 37		 jmp	 SHORT $LN5@gObjAbilit
$LN2@gObjAbilit:

; 15881: 	{
; 15882: 		lpObj->MaxLife += 2.0f * (lpObj->Level - 1);

  000b8	4a		 dec	 edx
  000b9	89 55 08	 mov	 DWORD PTR tv306[ebp], edx
  000bc	db 45 08	 fild	 DWORD PTR tv306[ebp]
  000bf	d9 5d 08	 fstp	 DWORD PTR tv301[ebp]
  000c2	d9 45 08	 fld	 DWORD PTR tv301[ebp]
  000c5	d9 c0		 fld	 ST(0)
  000c7	d8 c1		 fadd	 ST(0), ST(1)
  000c9	d8 80 c0 00 00
	00		 fadd	 DWORD PTR [eax+192]
  000cf	d9 5d 08	 fstp	 DWORD PTR tv318[ebp]
  000d2	d9 45 08	 fld	 DWORD PTR tv318[ebp]
  000d5	d9 90 c0 00 00
	00		 fst	 DWORD PTR [eax+192]

; 15883: 		lpObj->MaxMana += (lpObj->Level - 1)*0.5f;

  000db	d9 c9		 fxch	 ST(1)
  000dd	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  000e3	d8 80 d4 00 00
	00		 fadd	 DWORD PTR [eax+212]
  000e9	d9 5d 08	 fstp	 DWORD PTR tv320[ebp]
  000ec	d9 45 08	 fld	 DWORD PTR tv320[ebp]
$LN5@gObjAbilit:

; 15884: 
; 15885: 		lpObj->Life = lpObj->MaxLife;
; 15886: 		lpObj->Mana = lpObj->MaxMana;
; 15887: 	}
; 15888: 
; 15889: 	CloseClient(lpObj->m_Index);

  000ef	8b 10		 mov	 edx, DWORD PTR [eax]
  000f1	d9 90 d4 00 00
	00		 fst	 DWORD PTR [eax+212]
  000f7	d9 98 d0 00 00
	00		 fstp	 DWORD PTR [eax+208]
  000fd	52		 push	 edx
  000fe	d9 98 bc 00 00
	00		 fstp	 DWORD PTR [eax+188]
  00104	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00109	83 c4 04	 add	 esp, 4

; 15890: }

  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
?gObjAbilityReSet@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjAbilityReSet
_TEXT	ENDS
PUBLIC	?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
; Function compile flags: /Ogtp
;	COMDAT ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z PROC	; gObjTargetGuildWarCheck, COMDAT

; 15893: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15894: 	if(lpObj->Type != OBJ_USER)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	b9 01 00 00 00	 mov	 ecx, 1
  0000b	66 39 48 60	 cmp	 WORD PTR [eax+96], cx
  0000f	74 04		 je	 SHORT $LN7@gObjTarget

; 15895: 	{
; 15896: 		return false;

  00011	33 c0		 xor	 eax, eax

; 15915: 	{
; 15916: 		return false;
; 15917: 	}
; 15918: 	return true;
; 15919: }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
$LN7@gObjTarget:
  00015	56		 push	 esi

; 15897: 	}
; 15898: 
; 15899: 	if(lpTargetObj->Type != OBJ_USER)

  00016	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]
  00019	66 39 4e 60	 cmp	 WORD PTR [esi+96], cx

; 15900: 	{
; 15901: 		return false;

  0001d	75 70		 jne	 SHORT $LN4@gObjTarget

; 15902: 	}
; 15903: 
; 15904: 	if(lpObj->GuildNumber < 1 || lpTargetObj->GuildNumber < 1)

  0001f	39 88 b0 02 00
	00		 cmp	 DWORD PTR [eax+688], ecx
  00025	7c 68		 jl	 SHORT $LN4@gObjTarget
  00027	39 8e b0 02 00
	00		 cmp	 DWORD PTR [esi+688], ecx
  0002d	7c 60		 jl	 SHORT $LN4@gObjTarget

; 15907: 	}
; 15908: 
; 15909: 	if(lpObj->lpGuild->WarState != 1 || lpTargetObj->lpGuild->WarState != 1)

  0002f	8b 90 b4 02 00
	00		 mov	 edx, DWORD PTR [eax+692]
  00035	38 8a 91 05 00
	00		 cmp	 BYTE PTR [edx+1425], cl
  0003b	75 52		 jne	 SHORT $LN4@gObjTarget
  0003d	8b 86 b4 02 00
	00		 mov	 eax, DWORD PTR [esi+692]
  00043	38 88 91 05 00
	00		 cmp	 BYTE PTR [eax+1425], cl
  00049	75 44		 jne	 SHORT $LN4@gObjTarget

; 15910: 	{
; 15911: 		return false;
; 15912: 	}
; 15913: 
; 15914: 	if(strcmp(lpObj->lpGuild->TargetGuildName,lpTargetObj->lpGuild->Name))

  0004b	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0004e	8d 82 e0 04 00
	00		 lea	 eax, DWORD PTR [edx+1248]
$LL10@gObjTarget:
  00054	8a 10		 mov	 dl, BYTE PTR [eax]
  00056	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00058	75 24		 jne	 SHORT $LN11@gObjTarget
  0005a	84 d2		 test	 dl, dl
  0005c	74 12		 je	 SHORT $LN12@gObjTarget
  0005e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00061	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00064	75 18		 jne	 SHORT $LN11@gObjTarget
  00066	83 c0 02	 add	 eax, 2
  00069	83 c1 02	 add	 ecx, 2
  0006c	84 d2		 test	 dl, dl
  0006e	75 e4		 jne	 SHORT $LL10@gObjTarget
$LN12@gObjTarget:
  00070	33 c0		 xor	 eax, eax
  00072	33 c9		 xor	 ecx, ecx
  00074	85 c0		 test	 eax, eax
  00076	0f 94 c1	 sete	 cl
  00079	5e		 pop	 esi
  0007a	8b c1		 mov	 eax, ecx

; 15915: 	{
; 15916: 		return false;
; 15917: 	}
; 15918: 	return true;
; 15919: }

  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
$LN11@gObjTarget:

; 15910: 	{
; 15911: 		return false;
; 15912: 	}
; 15913: 
; 15914: 	if(strcmp(lpObj->lpGuild->TargetGuildName,lpTargetObj->lpGuild->Name))

  0007e	1b c0		 sbb	 eax, eax
  00080	83 d8 ff	 sbb	 eax, -1
  00083	33 c9		 xor	 ecx, ecx
  00085	85 c0		 test	 eax, eax
  00087	0f 94 c1	 sete	 cl
  0008a	5e		 pop	 esi
  0008b	8b c1		 mov	 eax, ecx

; 15915: 	{
; 15916: 		return false;
; 15917: 	}
; 15918: 	return true;
; 15919: }

  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
$LN4@gObjTarget:

; 15905: 	{
; 15906: 		return false;

  0008f	33 c0		 xor	 eax, eax
  00091	5e		 pop	 esi

; 15915: 	{
; 15916: 		return false;
; 15917: 	}
; 15918: 	return true;
; 15919: }

  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ENDP	; gObjTargetGuildWarCheck
_TEXT	ENDS
PUBLIC	?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ; gObjGuildWarEndSend
EXTRN	?GCGuildWarEnd@@YAXHEPAD@Z:PROC			; GCGuildWarEnd
; Function compile flags: /Ogtp
;	COMDAT ?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z
_TEXT	SEGMENT
_lpGuild1$ = 8						; size = 4
_lpGuild2$ = 12						; size = 4
_Result1$ = 16						; size = 1
_Result2$ = 20						; size = 1
?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z PROC ; gObjGuildWarEndSend, COMDAT

; 15980: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15981: 	if(lpGuild1 == 0 || lpGuild2 == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 c5 00 00
	00		 je	 $LN9@gObjGuildW
  0000e	53		 push	 ebx
  0000f	8b 5d 0c	 mov	 ebx, DWORD PTR _lpGuild2$[ebp]
  00012	85 db		 test	 ebx, ebx
  00014	0f 84 b8 00 00
	00		 je	 $LN20@gObjGuildW

; 15982: 	{
; 15983: 		return;
; 15984: 	}
; 15985: 
; 15986: 	if(lpGuild1->WarState != 1 || lpGuild2->WarState != 1)

  0001a	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  00021	0f 85 ab 00 00
	00		 jne	 $LN20@gObjGuildW
  00027	80 bb 91 05 00
	00 01		 cmp	 BYTE PTR [ebx+1425], 1
  0002e	0f 85 9e 00 00
	00		 jne	 $LN20@gObjGuildW

; 15987: 	{
; 15988: 		return;
; 15989: 	}
; 15990: 
; 15991: 	for(int n = 0; n < MAX_USER_GUILD;n++)

  00034	56		 push	 esi
  00035	57		 push	 edi
  00036	33 ff		 xor	 edi, edi
  00038	8d b0 a0 03 00
	00		 lea	 esi, DWORD PTR [eax+928]
  0003e	8b ff		 npad	 2
$LL19@gObjGuildW:

; 15992: 	{
; 15993: 		if(lpGuild1->Use[n] && lpGuild1->Index[n] >= 0)

  00040	80 bc 38 40 04
	00 00 00	 cmp	 BYTE PTR [eax+edi+1088], 0
  00048	74 2d		 je	 SHORT $LN7@gObjGuildW
  0004a	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  0004e	7c 27		 jl	 SHORT $LN7@gObjGuildW

; 15994: 		{
; 15995: 			gObj[lpGuild1->Index[n]].IsInBattleGround = 0;

  00050	0f bf 06	 movsx	 eax, WORD PTR [esi]

; 15996: 			GCGuildWarEnd(lpGuild1->Index[n],Result1,lpGuild2->Name);

  00053	8b 55 10	 mov	 edx, DWORD PTR _Result1$[ebp]
  00056	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0005c	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  0005f	c6 80 aa 0e 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3754], 0
  00066	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00069	51		 push	 ecx
  0006a	52		 push	 edx
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?GCGuildWarEnd@@YAXHEPAD@Z ; GCGuildWarEnd
  00071	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@gObjGuildW:

; 15987: 	{
; 15988: 		return;
; 15989: 	}
; 15990: 
; 15991: 	for(int n = 0; n < MAX_USER_GUILD;n++)

  00077	47		 inc	 edi
  00078	83 c6 02	 add	 esi, 2
  0007b	83 ff 50	 cmp	 edi, 80			; 00000050H
  0007e	7c c0		 jl	 SHORT $LL19@gObjGuildW

; 15997: 		}
; 15998: 	}
; 15999: 
; 16000: 	for(int n = 0; n < MAX_USER_GUILD;n++)

  00080	8d b3 a0 03 00
	00		 lea	 esi, DWORD PTR [ebx+928]
  00086	8b 5d 14	 mov	 ebx, DWORD PTR _Result2$[ebp]
  00089	33 ff		 xor	 edi, edi
  0008b	eb 03 8d 49 00	 npad	 5
$LL4@gObjGuildW:

; 16001: 	{
; 16002: 		if(lpGuild2->Use[n] && lpGuild2->Index[n] >= 0)

  00090	8b 4d 0c	 mov	 ecx, DWORD PTR _lpGuild2$[ebp]
  00093	80 bc 39 40 04
	00 00 00	 cmp	 BYTE PTR [ecx+edi+1088], 0
  0009b	74 2a		 je	 SHORT $LN3@gObjGuildW
  0009d	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  000a1	7c 24		 jl	 SHORT $LN3@gObjGuildW

; 16003: 		{
; 16004: 			gObj[lpGuild2->Index[n]].IsInBattleGround = 0;

  000a3	0f bf 16	 movsx	 edx, WORD PTR [esi]

; 16005: 			GCGuildWarEnd(lpGuild2->Index[n],Result2,lpGuild1->Name);

  000a6	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  000a9	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  000af	83 c0 04	 add	 eax, 4
  000b2	c6 82 aa 0e 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3754], 0
  000b9	0f bf 0e	 movsx	 ecx, WORD PTR [esi]
  000bc	50		 push	 eax
  000bd	53		 push	 ebx
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 ?GCGuildWarEnd@@YAXHEPAD@Z ; GCGuildWarEnd
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@gObjGuildW:

; 15997: 		}
; 15998: 	}
; 15999: 
; 16000: 	for(int n = 0; n < MAX_USER_GUILD;n++)

  000c7	47		 inc	 edi
  000c8	83 c6 02	 add	 esi, 2
  000cb	83 ff 50	 cmp	 edi, 80			; 00000050H
  000ce	7c c0		 jl	 SHORT $LL4@gObjGuildW
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
$LN20@gObjGuildW:
  000d2	5b		 pop	 ebx
$LN9@gObjGuildW:

; 16006: 		}
; 16007: 	}
; 16008: }

  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ENDP ; gObjGuildWarEndSend
_TEXT	ENDS
PUBLIC	?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z	; gObjGuildWarEnd
; Function compile flags: /Ogtp
;	COMDAT ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z
_TEXT	SEGMENT
_lpGuild$ = 8						; size = 4
_lpTargetGuild$ = 12					; size = 4
?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z PROC	; gObjGuildWarEnd, COMDAT

; 16011: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 16012: 	if(lpGuild == 0 || lpTargetGuild == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpGuild$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	3b c2		 cmp	 eax, edx
  0000a	74 2b		 je	 SHORT $LN2@gObjGuildW@2
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetGuild$[ebp]
  0000f	3b ca		 cmp	 ecx, edx
  00011	74 24		 je	 SHORT $LN2@gObjGuildW@2

; 16013: 	{
; 16014: 		return;
; 16015: 	}
; 16016: 
; 16017: 	lpGuild->WarDeclareState = 0;

  00013	66 89 90 90 05
	00 00		 mov	 WORD PTR [eax+1424], dx

; 16018: 	lpGuild->WarState = 0;
; 16019: 
; 16020: 	if(lpTargetGuild != 0)
; 16021: 	{
; 16022: 		lpTargetGuild->WarDeclareState = 0;

  0001a	66 89 91 90 05
	00 00		 mov	 WORD PTR [ecx+1424], dx

; 16023: 		lpTargetGuild->WarState = 0;
; 16024: 
; 16025: 		if(lpGuild->lpTargetGuildNode != 0)

  00021	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00027	3b ca		 cmp	 ecx, edx
  00029	74 0c		 je	 SHORT $LN2@gObjGuildW@2

; 16026: 		{
; 16027: 			_GUILD_INFO_STRUCT * lpTguild = lpGuild->lpTargetGuildNode;
; 16028: 
; 16029: 			lpGuild->lpTargetGuildNode = 0;

  0002b	89 90 8c 05 00
	00		 mov	 DWORD PTR [eax+1420], edx

; 16030: 			lpTguild->lpTargetGuildNode = 0;

  00031	89 91 8c 05 00
	00		 mov	 DWORD PTR [ecx+1420], edx
$LN2@gObjGuildW@2:

; 16031: 		}
; 16032: 	}
; 16033: 	else
; 16034: 	{
; 16035: 		lpGuild->lpTargetGuildNode = 0;
; 16036: 	}
; 16037: }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ENDP	; gObjGuildWarEnd
_TEXT	ENDS
PUBLIC	??_C@_0BH@KKLHENOF@?$CFs?5?$CI?5?$CFd?5?$CJ?5VS?5?$CFs?5?$CI?5?$CFd?5?$CJ?$AA@ ; `string'
PUBLIC	_lpGuild2$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjGuildWarProc@@YAHPAU_GUILD_INFO_STRUCT@@0H@Z ; gObjGuildWarProc
EXTRN	?GCGuildWarScore@@YAXH@Z:PROC			; GCGuildWarScore
EXTRN	?DGGuildScoreUpdate@@YAXPADH@Z:PROC		; DGGuildScoreUpdate
EXTRN	?BattleInfoSend@CGMMng@@QAEXPADE0E@Z:PROC	; CGMMng::BattleInfoSend
EXTRN	?cManager@@3VCGMMng@@A:BYTE			; cManager
EXTRN	?GetBattleTeamName@@YAPADHH@Z:PROC		; GetBattleTeamName
EXTRN	?GetBattleTeamScore@@YAHHH@Z:PROC		; GetBattleTeamScore
EXTRN	?SetBattleTeamScore@@YAXHHH@Z:PROC		; SetBattleTeamScore
;	COMDAT ??_C@_0BH@KKLHENOF@?$CFs?5?$CI?5?$CFd?5?$CJ?5VS?5?$CFs?5?$CI?5?$CFd?5?$CJ?$AA@
CONST	SEGMENT
??_C@_0BH@KKLHENOF@?$CFs?5?$CI?5?$CFd?5?$CJ?5VS?5?$CFs?5?$CI?5?$CFd?5?$CJ?$AA@ DB '%'
	DB	's ( %d ) VS %s ( %d )', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjGuildWarProc@@YAHPAU_GUILD_INFO_STRUCT@@0H@Z
_TEXT	SEGMENT
_lpGuild2$GSCopy$ = -276				; size = 4
tv268 = -272						; size = 4
_maxscore$ = -268					; size = 4
_totalscore$ = -264					; size = 4
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpGuild1$ = 8						; size = 4
_lpGuild2$ = 12						; size = 4
_score$ = 16						; size = 4
?gObjGuildWarProc@@YAHPAU_GUILD_INFO_STRUCT@@0H@Z PROC	; gObjGuildWarProc, COMDAT

; 16040: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpGuild1$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _lpGuild2$[ebp]

; 16087: 	}
; 16088: 
; 16089: 	for(n = 0; n < MAX_USER_GUILD; n++)

  0001b	89 bd ec fe ff
	ff		 mov	 DWORD PTR _lpGuild2$GSCopy$[ebp], edi
  00021	85 f6		 test	 esi, esi
  00023	0f 84 d4 01 00
	00		 je	 $LN15@gObjGuildW@3

; 16041: 	int totalscore;
; 16042: 	int n;
; 16043: 	int maxscore;
; 16044: 	char szTemp[0x100];
; 16045: 
; 16046: 	if(lpGuild1 == 0 || lpGuild2 == 0)

  00029	85 ff		 test	 edi, edi
  0002b	0f 84 cc 01 00
	00		 je	 $LN15@gObjGuildW@3

; 16047: 	{
; 16048: 		return false;
; 16049: 	}
; 16050: 
; 16051: 	totalscore = 1;
; 16052: 	maxscore = 20;
; 16053: 
; 16054: 	lpGuild1->PlayScore += score;

  00031	8a 45 10	 mov	 al, BYTE PTR _score$[ebp]
  00034	00 86 95 05 00
	00		 add	 BYTE PTR [esi+1429], al

; 16055: 
; 16056: 	wsprintf(szTemp,"%s ( %d ) VS %s ( %d )",lpGuild1->Name,lpGuild1->PlayScore,lpGuild2->Name,lpGuild2->PlayScore);

  0003a	0f b6 97 95 05
	00 00		 movzx	 edx, BYTE PTR [edi+1429]
  00041	0f b6 86 95 05
	00 00		 movzx	 eax, BYTE PTR [esi+1429]
  00048	53		 push	 ebx
  00049	52		 push	 edx
  0004a	8d 5f 04	 lea	 ebx, DWORD PTR [edi+4]
  0004d	53		 push	 ebx
  0004e	50		 push	 eax
  0004f	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00052	51		 push	 ecx
  00053	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv268[ebp], ecx
  00059	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@KKLHENOF@?$CFs?5?$CI?5?$CFd?5?$CJ?5VS?5?$CFs?5?$CI?5?$CFd?5?$CJ?$AA@
  00064	51		 push	 ecx
  00065	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _totalscore$[ebp], 1
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 16057: 	LogAdd(LOG_BLACK, szTemp);

  00075	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  0007b	52		 push	 edx
  0007c	6a 00		 push	 0
  0007e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00083	83 c4 20	 add	 esp, 32			; 00000020H

; 16058: 
; 16059: 	if(lpGuild1->WarType == 1)

  00086	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  0008d	75 2c		 jne	 SHORT $LN14@gObjGuildW@3

; 16060: 	{
; 16061: 		SetBattleTeamScore(lpGuild1->BattleGroundIndex,lpGuild1->BattleTeamCode,lpGuild1->PlayScore);

  0008f	0f b6 86 95 05
	00 00		 movzx	 eax, BYTE PTR [esi+1429]
  00096	0f b6 8e 94 05
	00 00		 movzx	 ecx, BYTE PTR [esi+1428]
  0009d	0f b6 96 93 05
	00 00		 movzx	 edx, BYTE PTR [esi+1427]
  000a4	50		 push	 eax
  000a5	51		 push	 ecx
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ?SetBattleTeamScore@@YAXHHH@Z ; SetBattleTeamScore
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16062: 		maxscore = 100;

  000af	c7 85 f4 fe ff
	ff 64 00 00 00	 mov	 DWORD PTR _maxscore$[ebp], 100 ; 00000064H

; 16063: 	}
; 16064: 	else

  000b9	eb 0a		 jmp	 SHORT $LN13@gObjGuildW@3
$LN14@gObjGuildW@3:

; 16065: 	{
; 16066: 		maxscore = 20;

  000bb	c7 85 f4 fe ff
	ff 14 00 00 00	 mov	 DWORD PTR _maxscore$[ebp], 20 ; 00000014H
$LN13@gObjGuildW@3:

; 16067: 	}
; 16068: 
; 16069: 	cManager.BattleInfoSend(GetBattleTeamName(0,0),GetBattleTeamScore(0,0),GetBattleTeamName(0,1),GetBattleTeamScore(0,1));

  000c5	6a 01		 push	 1
  000c7	6a 00		 push	 0
  000c9	e8 00 00 00 00	 call	 ?GetBattleTeamScore@@YAHHH@Z ; GetBattleTeamScore
  000ce	83 c4 08	 add	 esp, 8
  000d1	50		 push	 eax
  000d2	6a 01		 push	 1
  000d4	6a 00		 push	 0
  000d6	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  000db	83 c4 08	 add	 esp, 8
  000de	50		 push	 eax
  000df	6a 00		 push	 0
  000e1	6a 00		 push	 0
  000e3	e8 00 00 00 00	 call	 ?GetBattleTeamScore@@YAHHH@Z ; GetBattleTeamScore
  000e8	83 c4 08	 add	 esp, 8
  000eb	50		 push	 eax
  000ec	6a 00		 push	 0
  000ee	6a 00		 push	 0
  000f0	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  000f5	83 c4 08	 add	 esp, 8
  000f8	50		 push	 eax
  000f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  000fe	e8 00 00 00 00	 call	 ?BattleInfoSend@CGMMng@@QAEXPADE0E@Z ; CGMMng::BattleInfoSend

; 16070: 
; 16071: 	if(lpGuild1->PlayScore >= maxscore)

  00103	0f b6 86 95 05
	00 00		 movzx	 eax, BYTE PTR [esi+1429]
  0010a	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _maxscore$[ebp]
  00110	3b c1		 cmp	 eax, ecx
  00112	7c 73		 jl	 SHORT $LN12@gObjGuildW@3

; 16072: 	{
; 16073: 		if(lpGuild1->PlayScore > maxscore && lpGuild2->PlayScore == 0)

  00114	7e 2c		 jle	 SHORT $LN23@gObjGuildW@3
  00116	80 bf 95 05 00
	00 00		 cmp	 BYTE PTR [edi+1429], 0
  0011d	75 0c		 jne	 SHORT $LN11@gObjGuildW@3

; 16074: 		{
; 16075: 			totalscore = 3;

  0011f	c7 85 f8 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR _totalscore$[ebp], 3
  00129	eb 17		 jmp	 SHORT $LN23@gObjGuildW@3
$LN11@gObjGuildW@3:

; 16076: 		}
; 16077: 		else if(lpGuild1->PlayScore > maxscore && lpGuild2->PlayScore <= 10)

  0012b	3b c1		 cmp	 eax, ecx
  0012d	7e 13		 jle	 SHORT $LN23@gObjGuildW@3
  0012f	80 bf 95 05 00
	00 0a		 cmp	 BYTE PTR [edi+1429], 10	; 0000000aH
  00136	77 0a		 ja	 SHORT $LN23@gObjGuildW@3

; 16078: 		{
; 16079: 			totalscore = 2;

  00138	c7 85 f8 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _totalscore$[ebp], 2
$LN23@gObjGuildW@3:

; 16080: 		}
; 16081: 
; 16082: 		lpGuild1->TotalScore += totalscore;

  00142	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _totalscore$[ebp]
  00148	01 86 98 05 00
	00		 add	 DWORD PTR [esi+1432], eax
  0014e	8b b6 98 05 00
	00		 mov	 esi, DWORD PTR [esi+1432]

; 16083: 		DGGuildScoreUpdate(lpGuild1->Name,lpGuild1->TotalScore);

  00154	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv268[ebp]
  0015a	56		 push	 esi
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 ?DGGuildScoreUpdate@@YAXPADH@Z ; DGGuildScoreUpdate

; 16084: 		DGGuildScoreUpdate(lpGuild2->Name,lpGuild2->TotalScore);

  00161	8b 97 98 05 00
	00		 mov	 edx, DWORD PTR [edi+1432]
  00167	52		 push	 edx
  00168	53		 push	 ebx
  00169	e8 00 00 00 00	 call	 ?DGGuildScoreUpdate@@YAXPADH@Z ; DGGuildScoreUpdate
  0016e	83 c4 10	 add	 esp, 16			; 00000010H
  00171	5b		 pop	 ebx
  00172	5f		 pop	 edi

; 16085: 
; 16086: 		return true;

  00173	b8 01 00 00 00	 mov	 eax, 1
  00178	5e		 pop	 esi

; 16105: }

  00179	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017c	33 cd		 xor	 ecx, ebp
  0017e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c3		 ret	 0
$LN12@gObjGuildW@3:

; 16087: 	}
; 16088: 
; 16089: 	for(n = 0; n < MAX_USER_GUILD; n++)

  00187	33 ff		 xor	 edi, edi
  00189	8d 9e a0 03 00
	00		 lea	 ebx, DWORD PTR [esi+928]
  0018f	90		 npad	 1
$LL8@gObjGuildW@3:

; 16090: 	{
; 16091: 		if(lpGuild1->Use[n] && lpGuild1->Index[n] >= 0)

  00190	80 bc 3e 40 04
	00 00 00	 cmp	 BYTE PTR [esi+edi+1088], 0
  00198	74 12		 je	 SHORT $LN7@gObjGuildW@3
  0019a	0f b7 03	 movzx	 eax, WORD PTR [ebx]
  0019d	66 85 c0	 test	 ax, ax
  001a0	78 0a		 js	 SHORT $LN7@gObjGuildW@3

; 16092: 		{
; 16093: 			GCGuildWarScore(lpGuild1->Index[n]);

  001a2	98		 cwde
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?GCGuildWarScore@@YAXH@Z ; GCGuildWarScore
  001a9	83 c4 04	 add	 esp, 4
$LN7@gObjGuildW@3:

; 16087: 	}
; 16088: 
; 16089: 	for(n = 0; n < MAX_USER_GUILD; n++)

  001ac	47		 inc	 edi
  001ad	83 c3 02	 add	 ebx, 2
  001b0	83 ff 50	 cmp	 edi, 80			; 00000050H
  001b3	7c db		 jl	 SHORT $LL8@gObjGuildW@3

; 16094: 		}
; 16095: 	}
; 16096: 
; 16097: 	for(n = 0; n < MAX_USER_GUILD; n++)

  001b5	8b 9d ec fe ff
	ff		 mov	 ebx, DWORD PTR _lpGuild2$GSCopy$[ebp]
  001bb	33 f6		 xor	 esi, esi
  001bd	8d bb a0 03 00
	00		 lea	 edi, DWORD PTR [ebx+928]
$LL24@gObjGuildW@3:

; 16098: 	{
; 16099: 		if(lpGuild2->Use[n] && lpGuild2->Index[n] >= 0)

  001c3	80 bc 33 40 04
	00 00 00	 cmp	 BYTE PTR [ebx+esi+1088], 0
  001cb	74 14		 je	 SHORT $LN3@gObjGuildW@3
  001cd	0f b7 07	 movzx	 eax, WORD PTR [edi]
  001d0	66 85 c0	 test	 ax, ax
  001d3	78 0c		 js	 SHORT $LN3@gObjGuildW@3

; 16100: 		{
; 16101: 			GCGuildWarScore(lpGuild2->Index[n]);

  001d5	0f bf c8	 movsx	 ecx, ax
  001d8	51		 push	 ecx
  001d9	e8 00 00 00 00	 call	 ?GCGuildWarScore@@YAXH@Z ; GCGuildWarScore
  001de	83 c4 04	 add	 esp, 4
$LN3@gObjGuildW@3:

; 16094: 		}
; 16095: 	}
; 16096: 
; 16097: 	for(n = 0; n < MAX_USER_GUILD; n++)

  001e1	46		 inc	 esi
  001e2	83 c7 02	 add	 edi, 2
  001e5	83 fe 50	 cmp	 esi, 80			; 00000050H
  001e8	7c d9		 jl	 SHORT $LL24@gObjGuildW@3

; 16102: 		}
; 16103: 	}
; 16104: 	return false;

  001ea	5b		 pop	 ebx
  001eb	5f		 pop	 edi
  001ec	33 c0		 xor	 eax, eax
  001ee	5e		 pop	 esi

; 16105: }

  001ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f2	33 cd		 xor	 ecx, ebp
  001f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f9	8b e5		 mov	 esp, ebp
  001fb	5d		 pop	 ebp
  001fc	c3		 ret	 0
$LN15@gObjGuildW@3:
  001fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00200	5f		 pop	 edi
  00201	33 cd		 xor	 ecx, ebp
  00203	33 c0		 xor	 eax, eax
  00205	5e		 pop	 esi
  00206	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020b	8b e5		 mov	 esp, ebp
  0020d	5d		 pop	 ebp
  0020e	c3		 ret	 0
?gObjGuildWarProc@@YAHPAU_GUILD_INFO_STRUCT@@0H@Z ENDP	; gObjGuildWarProc
_TEXT	ENDS
PUBLIC	?gObjGetPkTime@@YAHPAUOBJECTSTRUCT@@AAH1@Z	; gObjGetPkTime
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetPkTime@@YAHPAUOBJECTSTRUCT@@AAH1@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_hour$ = 12						; size = 4
_min$ = 16						; size = 4
?gObjGetPkTime@@YAHPAUOBJECTSTRUCT@@AAH1@Z PROC		; gObjGetPkTime, COMDAT

; 16271: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 16272: 	int pktime = 0;
; 16273: 
; 16274: 	if(lpObj->m_PK_Time > 0)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00008	8b b7 00 01 00
	00		 mov	 esi, DWORD PTR [edi+256]
  0000e	33 c9		 xor	 ecx, ecx
  00010	85 f6		 test	 esi, esi
  00012	7e 13		 jle	 SHORT $LN4@gObjGetPkT

; 16275: 	{
; 16276: 		pktime = lpObj->m_PK_Time / 60;

  00014	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00019	f7 ee		 imul	 esi
  0001b	03 d6		 add	 edx, esi
  0001d	c1 fa 05	 sar	 edx, 5
  00020	8b ca		 mov	 ecx, edx
  00022	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00025	03 ca		 add	 ecx, edx
$LN4@gObjGetPkT:

; 16277: 	}
; 16278: 
; 16279: 	if(lpObj->m_PK_Level == 4)

  00027	8a 87 fd 00 00
	00		 mov	 al, BYTE PTR [edi+253]
  0002d	3c 04		 cmp	 al, 4
  0002f	75 22		 jne	 SHORT $LN3@gObjGetPkT

; 16280: 	{
; 16281: 		hour = (180 - pktime) / 60;

  00031	b8 b4 00 00 00	 mov	 eax, 180		; 000000b4H
  00036	2b c1		 sub	 eax, ecx
  00038	99		 cdq
  00039	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0003e	f7 f9		 idiv	 ecx
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _hour$[ebp]
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	89 01		 mov	 DWORD PTR [ecx], eax

; 16282: 		min = (180 - pktime) % 60;

  00047	8b 45 10	 mov	 eax, DWORD PTR _min$[ebp]
  0004a	89 10		 mov	 DWORD PTR [eax], edx

; 16283: 		return true;

  0004c	b8 01 00 00 00	 mov	 eax, 1

; 16301: }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN3@gObjGetPkT:

; 16284: 	}
; 16285: 
; 16286: 	if(lpObj->m_PK_Level == 5)

  00053	3c 05		 cmp	 al, 5
  00055	75 22		 jne	 SHORT $LN2@gObjGetPkT

; 16287: 	{
; 16288: 		hour = (360 - pktime) / 60;

  00057	b8 68 01 00 00	 mov	 eax, 360		; 00000168H
  0005c	2b c1		 sub	 eax, ecx
  0005e	99		 cdq
  0005f	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00064	f7 f9		 idiv	 ecx
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _hour$[ebp]
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	89 01		 mov	 DWORD PTR [ecx], eax

; 16289: 		min = (360 - pktime) % 60;

  0006d	8b 45 10	 mov	 eax, DWORD PTR _min$[ebp]
  00070	89 10		 mov	 DWORD PTR [eax], edx

; 16290: 		return true;

  00072	b8 01 00 00 00	 mov	 eax, 1

; 16301: }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN2@gObjGetPkT:

; 16291: 	}
; 16292: 
; 16293: 	if(lpObj->m_PK_Level >= 6)

  00079	3c 06		 cmp	 al, 6
  0007b	7c 5b		 jl	 SHORT $LN1@gObjGetPkT

; 16294: 	{
; 16295: 		hour = (((lpObj->m_PK_Count - 3) * 60 + 540) - pktime) / 60;

  0007d	0f be 87 fc 00
	00 00		 movsx	 eax, BYTE PTR [edi+252]
  00084	83 c0 06	 add	 eax, 6
  00087	8b d0		 mov	 edx, eax
  00089	c1 e2 04	 shl	 edx, 4
  0008c	2b d0		 sub	 edx, eax
  0008e	03 d2		 add	 edx, edx
  00090	8d 34 12	 lea	 esi, DWORD PTR [edx+edx]
  00093	2b f1		 sub	 esi, ecx
  00095	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0009a	f7 ee		 imul	 esi
  0009c	03 d6		 add	 edx, esi
  0009e	c1 fa 05	 sar	 edx, 5
  000a1	8b c2		 mov	 eax, edx
  000a3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000a6	03 c2		 add	 eax, edx
  000a8	8b 55 0c	 mov	 edx, DWORD PTR _hour$[ebp]
  000ab	89 02		 mov	 DWORD PTR [edx], eax

; 16296: 		min = (((lpObj->m_PK_Count - 3) * 60 + 540) - pktime) % 60;

  000ad	0f be 97 fc 00
	00 00		 movsx	 edx, BYTE PTR [edi+252]
  000b4	83 c2 06	 add	 edx, 6
  000b7	8b c2		 mov	 eax, edx
  000b9	c1 e0 04	 shl	 eax, 4
  000bc	2b c2		 sub	 eax, edx
  000be	03 c0		 add	 eax, eax
  000c0	03 c0		 add	 eax, eax
  000c2	2b c1		 sub	 eax, ecx
  000c4	99		 cdq
  000c5	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  000ca	f7 f9		 idiv	 ecx
  000cc	8b 45 10	 mov	 eax, DWORD PTR _min$[ebp]
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	89 10		 mov	 DWORD PTR [eax], edx

; 16297: 		return true;

  000d3	8d 41 c5	 lea	 eax, DWORD PTR [ecx-59]

; 16301: }

  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
$LN1@gObjGetPkT:
  000d8	5f		 pop	 edi

; 16298: 	}
; 16299: 
; 16300: 	return false;

  000d9	33 c0		 xor	 eax, eax
  000db	5e		 pop	 esi

; 16301: }

  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
?gObjGetPkTime@@YAHPAUOBJECTSTRUCT@@AAH1@Z ENDP		; gObjGetPkTime
_TEXT	ENDS
PUBLIC	?gObjCheckTeleportArea@@YAHHEE@Z		; gObjCheckTeleportArea
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckTeleportArea@@YAHHEE@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_x$ = 12						; size = 1
_y$ = 16						; size = 1
?gObjCheckTeleportArea@@YAHHEE@Z PROC			; gObjCheckTeleportArea, COMDAT

; 16396: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 16397: 
; 16398: 	if(x < (gObj[aIndex].X - 8)
; 16399: 		|| x > (gObj[aIndex].X + 8)
; 16400: 		|| y < (gObj[aIndex].Y - 8)
; 16401: 		|| y > (gObj[aIndex].Y + 8))

  00003	0f b6 55 0c	 movzx	 edx, BYTE PTR _x$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000b	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00011	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  00018	8d 48 f8	 lea	 ecx, DWORD PTR [eax-8]
  0001b	57		 push	 edi
  0001c	3b d1		 cmp	 edx, ecx
  0001e	7c 69		 jl	 SHORT $LN5@gObjCheckT@2
  00020	83 c0 08	 add	 eax, 8
  00023	3b d0		 cmp	 edx, eax
  00025	7f 62		 jg	 SHORT $LN5@gObjCheckT@2
  00027	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  0002e	0f b6 4d 10	 movzx	 ecx, BYTE PTR _y$[ebp]
  00032	8d 78 f8	 lea	 edi, DWORD PTR [eax-8]
  00035	3b cf		 cmp	 ecx, edi
  00037	7c 50		 jl	 SHORT $LN5@gObjCheckT@2
  00039	83 c0 08	 add	 eax, 8
  0003c	3b c8		 cmp	 ecx, eax
  0003e	7f 49		 jg	 SHORT $LN5@gObjCheckT@2

; 16404: 	}
; 16405: 
; 16406: 	int mapnumber = gObj[aIndex].MapNumber;

  00040	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]

; 16407: 
; 16408: 	if(mapnumber < 0 || mapnumber >= MAX_NUMBER_MAP)

  00047	83 f8 27	 cmp	 eax, 39			; 00000027H
  0004a	77 3d		 ja	 SHORT $LN5@gObjCheckT@2

; 16409: 	{
; 16410: 		return false;
; 16411: 	}
; 16412: 
; 16413: 	BYTE attr = MapC[mapnumber].GetAttr(x,y);

  0004c	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  00052	51		 push	 ecx
  00053	8d b8 00 00 00
	00		 lea	 edi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  00059	52		 push	 edx
  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 16414: 
; 16415: 	if(attr)

  00061	84 c0		 test	 al, al

; 16416: 	{
; 16417: 		return false;

  00063	75 24		 jne	 SHORT $LN5@gObjCheckT@2

; 16418: 	}
; 16419: 
; 16420: 	attr = MapC[mapnumber].GetAttr(gObj[aIndex].X,gObj[aIndex].Y);
; 16421: 
; 16422: 	if(attr & 1)

  00065	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  0006c	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  00073	52		 push	 edx
  00074	50		 push	 eax
  00075	8b cf		 mov	 ecx, edi
  00077	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0007c	0f b6 c0	 movzx	 eax, al
  0007f	83 f0 ff	 xor	 eax, -1
  00082	5f		 pop	 edi
  00083	83 e0 01	 and	 eax, 1
  00086	5e		 pop	 esi

; 16423: 	{
; 16424: 		return false;
; 16425: 	}
; 16426: 
; 16427: 	return true;
; 16428: }

  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
$LN5@gObjCheckT@2:
  00089	5f		 pop	 edi

; 16402: 	{
; 16403: 		return false;

  0008a	33 c0		 xor	 eax, eax
  0008c	5e		 pop	 esi

; 16423: 	{
; 16424: 		return false;
; 16425: 	}
; 16426: 
; 16427: 	return true;
; 16428: }

  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?gObjCheckTeleportArea@@YAHHEE@Z ENDP			; gObjCheckTeleportArea
_TEXT	ENDS
PUBLIC	?gObjCheckAttackAreaUsedPath@@YAHHH@Z		; gObjCheckAttackAreaUsedPath
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckAttackAreaUsedPath@@YAHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_TarObjIndex$ = 12					; size = 4
?gObjCheckAttackAreaUsedPath@@YAHHH@Z PROC		; gObjCheckAttackAreaUsedPath, COMDAT

; 16431: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 16432: 	int X,Y;
; 16433: 	if(gObj[aIndex].PathCount > 1)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	8b c8		 mov	 ecx, eax
  00008	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0000e	8b 89 28 01 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+296]
  00014	83 f9 01	 cmp	 ecx, 1
  00017	7e 5d		 jle	 SHORT $LN4@gObjCheckA

; 16434: 	{
; 16435: 		 X = gObj[aIndex].PathX[gObj[aIndex].PathCount-1];

  00019	69 c0 b2 0a 00
	00		 imul	 eax, 2738		; 00000ab2H
  0001f	03 c1		 add	 eax, ecx
  00021	0f bf 8c 00 4e
	01 00 00	 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+eax+334]
  00029	03 c0		 add	 eax, eax
  0002b	56		 push	 esi

; 16436: 		 Y = gObj[aIndex].PathY[gObj[aIndex].PathCount-1];

  0002c	0f bf b0 6c 01
	00 00		 movsx	 esi, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+364]

; 16441: 	}
; 16442: 
; 16443: 	if(gObj[TarObjIndex].X < (X - 10)
; 16444: 		|| gObj[TarObjIndex].X > (X + 10)
; 16445: 		|| gObj[TarObjIndex].Y < (Y - 10)
; 16446: 		|| gObj[TarObjIndex].Y > (Y + 10))

  00033	8b 45 0c	 mov	 eax, DWORD PTR _TarObjIndex$[ebp]
  00036	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0003c	0f bf 90 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  00043	57		 push	 edi
  00044	8d 79 f6	 lea	 edi, DWORD PTR [ecx-10]
  00047	3b d7		 cmp	 edx, edi
  00049	7c 25		 jl	 SHORT $LN1@gObjCheckA
  0004b	83 c1 0a	 add	 ecx, 10			; 0000000aH
  0004e	3b d1		 cmp	 edx, ecx
  00050	7f 1e		 jg	 SHORT $LN1@gObjCheckA
  00052	0f bf 80 06 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  00059	8d 56 f6	 lea	 edx, DWORD PTR [esi-10]
  0005c	3b c2		 cmp	 eax, edx
  0005e	7c 10		 jl	 SHORT $LN1@gObjCheckA
  00060	83 c6 0a	 add	 esi, 10			; 0000000aH
  00063	3b c6		 cmp	 eax, esi
  00065	7f 09		 jg	 SHORT $LN1@gObjCheckA

; 16449: 	}
; 16450: 	return true;

  00067	5f		 pop	 edi
  00068	b8 01 00 00 00	 mov	 eax, 1
  0006d	5e		 pop	 esi

; 16451: }

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
$LN1@gObjCheckA:
  00070	5f		 pop	 edi

; 16447: 	{
; 16448: 		return false;

  00071	33 c0		 xor	 eax, eax
  00073	5e		 pop	 esi

; 16451: }

  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
$LN4@gObjCheckA:

; 16437: 	}
; 16438: 	else
; 16439: 	{
; 16440: 		return false;

  00076	33 c0		 xor	 eax, eax

; 16451: }

  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?gObjCheckAttackAreaUsedPath@@YAHHH@Z ENDP		; gObjCheckAttackAreaUsedPath
_TEXT	ENDS
PUBLIC	?gObjCheckattackAreaUsedViewPort@@YAHHH@Z	; gObjCheckattackAreaUsedViewPort
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckattackAreaUsedViewPort@@YAHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_TarObjIndex$ = 12					; size = 4
?gObjCheckattackAreaUsedViewPort@@YAHHH@Z PROC		; gObjCheckattackAreaUsedViewPort, COMDAT

; 16454: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 16455: 	LPOBJ lpObj = &gObj[aIndex];
; 16456: 	LPOBJ lpTargetObj = &gObj[TarObjIndex];

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _TarObjIndex$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00009	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0000f	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00015	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16457: 
; 16458: 	if(lpTargetObj->m_Index == lpObj->m_Index)

  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001d	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00022	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00024	75 07		 jne	 SHORT $LN9@gObjChecka

; 16459: 	{
; 16460: 		return true;

  00026	b8 01 00 00 00	 mov	 eax, 1

; 16489: }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN9@gObjChecka:

; 16461: 	}
; 16462: 
; 16463: 	int MVL = MAX_VIEWPORT;
; 16464: 
; 16465: 	if(lpObj->Type == OBJ_MONSTER)

  0002d	66 83 78 60 02	 cmp	 WORD PTR [eax+96], 2
  00032	56		 push	 esi
  00033	be 4b 00 00 00	 mov	 esi, 75			; 0000004bH
  00038	75 05		 jne	 SHORT $LN8@gObjChecka

; 16466: 	{
; 16467: 		MVL = MAX_VIEWPORT_MONSTER;

  0003a	be 14 00 00 00	 mov	 esi, 20			; 00000014H
$LN8@gObjChecka:

; 16468: 	}
; 16469: 
; 16470: 	for(int n = 0; n < MVL;n++)

  0003f	33 d2		 xor	 edx, edx
  00041	57		 push	 edi
  00042	85 f6		 test	 esi, esi
  00044	7e 33		 jle	 SHORT $LN5@gObjChecka
  00046	05 92 03 00 00	 add	 eax, 914		; 00000392H
  0004b	eb 03 8d 49 00	 npad	 5
$LL7@gObjChecka:

; 16471: 	{
; 16472: 		if(lpObj->VpPlayer[n].state)

  00050	80 78 fe 00	 cmp	 BYTE PTR [eax-2], 0
  00054	74 07		 je	 SHORT $LN3@gObjChecka

; 16473: 		{
; 16474: 			if(lpObj->VpPlayer[n].number == lpTargetObj->m_Index)

  00056	0f bf 38	 movsx	 edi, WORD PTR [eax]
  00059	3b f9		 cmp	 edi, ecx
  0005b	74 22		 je	 SHORT $LN14@gObjChecka
$LN3@gObjChecka:

; 16475: 			{
; 16476: 				return true;
; 16477: 			}
; 16478: 		}
; 16479: 
; 16480: 		if(lpObj->VpPlayer2[n].state)

  0005d	80 b8 82 03 00
	00 00		 cmp	 BYTE PTR [eax+898], 0
  00064	74 0b		 je	 SHORT $LN6@gObjChecka

; 16481: 		{
; 16482: 			if(lpObj->VpPlayer2[n].number == lpTargetObj->m_Index)

  00066	0f bf b8 84 03
	00 00		 movsx	 edi, WORD PTR [eax+900]
  0006d	3b f9		 cmp	 edi, ecx
  0006f	74 0e		 je	 SHORT $LN14@gObjChecka
$LN6@gObjChecka:

; 16468: 	}
; 16469: 
; 16470: 	for(int n = 0; n < MVL;n++)

  00071	42		 inc	 edx
  00072	83 c0 0c	 add	 eax, 12			; 0000000cH
  00075	3b d6		 cmp	 edx, esi
  00077	7c d7		 jl	 SHORT $LL7@gObjChecka
$LN5@gObjChecka:
  00079	5f		 pop	 edi

; 16485: 			}
; 16486: 		}
; 16487: 	}
; 16488: 	return false;

  0007a	33 c0		 xor	 eax, eax
  0007c	5e		 pop	 esi

; 16489: }

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
$LN14@gObjChecka:
  0007f	5f		 pop	 edi

; 16483: 			{
; 16484: 				return true;

  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	5e		 pop	 esi

; 16489: }

  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
?gObjCheckattackAreaUsedViewPort@@YAHHH@Z ENDP		; gObjCheckattackAreaUsedViewPort
_TEXT	ENDS
PUBLIC	?gObjCheckAttackArea@@YAHHH@Z			; gObjCheckAttackArea
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckAttackArea@@YAHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_TarObjIndex$ = 12					; size = 4
?gObjCheckAttackArea@@YAHHH@Z PROC			; gObjCheckAttackArea, COMDAT

; 16492: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 16493: 
; 16494: 	if(gObjCheckattackAreaUsedViewPort(aIndex,TarObjIndex)==0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR _TarObjIndex$[ebp]
  0000b	57		 push	 edi
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 ?gObjCheckattackAreaUsedViewPort@@YAHHH@Z ; gObjCheckattackAreaUsedViewPort
  00012	83 c4 08	 add	 esp, 8
  00015	85 c0		 test	 eax, eax
  00017	75 09		 jne	 SHORT $LN8@gObjCheckA@2

; 16495: 	{
; 16496: 		return 1;

  00019	5f		 pop	 edi
  0001a	b8 01 00 00 00	 mov	 eax, 1
  0001f	5e		 pop	 esi

; 16535: }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$LN8@gObjCheckA@2:

; 16497: 	}
; 16498: 
; 16499: 	int mapnumber = gObj[aIndex].MapNumber;

  00022	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00028	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]

; 16500: 
; 16501: 	if(mapnumber < 0 || mapnumber >= MAX_NUMBER_MAP)

  0002f	83 f9 27	 cmp	 ecx, 39			; 00000027H
  00032	0f 87 8c 00 00
	00		 ja	 $LN6@gObjCheckA@2

; 16504: 	}
; 16505: 
; 16506: 	int tarmapnumber = gObj[TarObjIndex].MapNumber;

  00038	8b c7		 mov	 eax, edi
  0003a	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00040	0f b6 90 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]

; 16507: 
; 16508: 	if(tarmapnumber < 0 || tarmapnumber >= MAX_NUMBER_MAP)

  00047	83 fa 27	 cmp	 edx, 39			; 00000027H
  0004a	77 6f		 ja	 SHORT $LN4@gObjCheckA@2

; 16511: 	}
; 16512: 
; 16513: 	if(tarmapnumber != mapnumber)

  0004c	3b d1		 cmp	 edx, ecx
  0004e	74 09		 je	 SHORT $LN3@gObjCheckA@2

; 16514: 	{
; 16515: 		return 4;

  00050	5f		 pop	 edi
  00051	b8 04 00 00 00	 mov	 eax, 4
  00056	5e		 pop	 esi

; 16535: }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN3@gObjCheckA@2:

; 16516: 	}
; 16517: #if(GS_CASTLE==0)
; 16518: 	unsigned char attr = MapC[mapnumber].GetAttr(gObj[TarObjIndex].X,gObj[TarObjIndex].Y);

  00059	0f bf 90 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  00060	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00066	8d b9 00 00 00
	00		 lea	 edi, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  0006c	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  00073	51		 push	 ecx
  00074	52		 push	 edx
  00075	8b cf		 mov	 ecx, edi
  00077	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 16519: 
; 16520: 	if(attr && !(attr&2))

  0007c	84 c0		 test	 al, al
  0007e	74 0d		 je	 SHORT $LN2@gObjCheckA@2
  00080	a8 02		 test	 al, 2
  00082	75 09		 jne	 SHORT $LN2@gObjCheckA@2

; 16521: 	{
; 16522: 		return 5;

  00084	5f		 pop	 edi
  00085	b8 05 00 00 00	 mov	 eax, 5
  0008a	5e		 pop	 esi

; 16535: }

  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN2@gObjCheckA@2:

; 16523: 	}
; 16524: #else
; 16525: 	unsigned char attr = 0;
; 16526: #endif
; 16527: 	attr = MapC[mapnumber].GetAttr(gObj[aIndex].X,gObj[aIndex].Y);

  0008d	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  00094	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  0009b	50		 push	 eax
  0009c	51		 push	 ecx
  0009d	8b cf		 mov	 ecx, edi
  0009f	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 16528: 
; 16529: 	if(attr && !(attr&2))

  000a4	84 c0		 test	 al, al
  000a6	74 0d		 je	 SHORT $LN1@gObjCheckA@2
  000a8	a8 02		 test	 al, 2
  000aa	75 09		 jne	 SHORT $LN1@gObjCheckA@2

; 16530: 	{
; 16531: 		return 6;

  000ac	5f		 pop	 edi
  000ad	b8 06 00 00 00	 mov	 eax, 6
  000b2	5e		 pop	 esi

; 16535: }

  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
$LN1@gObjCheckA@2:
  000b5	5f		 pop	 edi

; 16532: 	}
; 16533: 
; 16534: 	return false;

  000b6	33 c0		 xor	 eax, eax
  000b8	5e		 pop	 esi

; 16535: }

  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
$LN4@gObjCheckA@2:
  000bb	5f		 pop	 edi

; 16509: 	{
; 16510: 		return 3;

  000bc	b8 03 00 00 00	 mov	 eax, 3
  000c1	5e		 pop	 esi

; 16535: }

  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
$LN6@gObjCheckA@2:
  000c4	5f		 pop	 edi

; 16502: 	{
; 16503: 		return 2;

  000c5	b8 02 00 00 00	 mov	 eax, 2
  000ca	5e		 pop	 esi

; 16535: }

  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
?gObjCheckAttackArea@@YAHHH@Z ENDP			; gObjCheckAttackArea
_TEXT	ENDS
PUBLIC	?GetTimeStamp@_GUILD_INFO_STRUCT@@QAEHXZ	; _GUILD_INFO_STRUCT::GetTimeStamp
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\guildclass.h
;	COMDAT ?GetTimeStamp@_GUILD_INFO_STRUCT@@QAEHXZ
_TEXT	SEGMENT
?GetTimeStamp@_GUILD_INFO_STRUCT@@QAEHXZ PROC		; _GUILD_INFO_STRUCT::GetTimeStamp, COMDAT
; _this$ = ecx

; 154  : 		return this->iTimeStamp;

  00000	8b 81 24 07 00
	00		 mov	 eax, DWORD PTR [ecx+1828]

; 155  : 	};	// line : 124

  00006	c3		 ret	 0
?GetTimeStamp@_GUILD_INFO_STRUCT@@QAEHXZ ENDP		; _GUILD_INFO_STRUCT::GetTimeStamp
_TEXT	ENDS
PUBLIC	?gUserFindDevilSquareInvitation@@YAHH@Z		; gUserFindDevilSquareInvitation
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
;	COMDAT ?gUserFindDevilSquareInvitation@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gUserFindDevilSquareInvitation@@YAHH@Z PROC		; gUserFindDevilSquareInvitation, COMDAT

; 16538: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 16539: 	LPOBJ lpObj = &gObj[aIndex];

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00008	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0000e	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00014	33 f6		 xor	 esi, esi
  00016	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL6@gUserFindD:

; 16542: 	{
; 16543: 		if(lpObj->pInventory[n].IsItem() == 1)

  00020	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3212]
  00026	03 ce		 add	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	75 1f		 jne	 SHORT $LN5@gUserFindD

; 16544: 		{
; 16545: 			if(lpObj->pInventory[n].m_Type == ITEMGET(14,19))

  00032	8b 87 8c 0c 00
	00		 mov	 eax, DWORD PTR [edi+3212]
  00038	0f b7 44 30 06	 movzx	 eax, WORD PTR [eax+esi+6]
  0003d	b9 13 1c 00 00	 mov	 ecx, 7187		; 00001c13H
  00042	66 3b c1	 cmp	 ax, cx
  00045	74 1e		 je	 SHORT $LN10@gUserFindD

; 16548: 			}
; 16549: 
; 16550: 			if(lpObj->pInventory[n].m_Type == ITEMGET(13,46))

  00047	ba 2e 1a 00 00	 mov	 edx, 6702		; 00001a2eH
  0004c	66 3b c2	 cmp	 ax, dx
  0004f	74 14		 je	 SHORT $LN10@gUserFindD
$LN5@gUserFindD:

; 16540: 
; 16541: 	for(int n = 0; n < MAIN_INVENTORY_SIZE; n++)

  00051	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00057	81 fe e0 31 00
	00		 cmp	 esi, 12768		; 000031e0H
  0005d	7c c1		 jl	 SHORT $LL6@gUserFindD

; 16551: 			{
; 16552: 				return true;
; 16553: 			}
; 16554: 		}
; 16555: 	}
; 16556: 	return false;

  0005f	5f		 pop	 edi
  00060	33 c0		 xor	 eax, eax
  00062	5e		 pop	 esi

; 16557: }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN10@gUserFindD:
  00065	5f		 pop	 edi

; 16546: 			{
; 16547: 				return true;

  00066	b8 01 00 00 00	 mov	 eax, 1
  0006b	5e		 pop	 esi

; 16557: }

  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?gUserFindDevilSquareInvitation@@YAHH@Z ENDP		; gUserFindDevilSquareInvitation
_TEXT	ENDS
PUBLIC	?CheckTimeStamp@_GUILD_INFO_STRUCT@@QAEHH@Z	; _GUILD_INFO_STRUCT::CheckTimeStamp
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\guildclass.h
;	COMDAT ?CheckTimeStamp@_GUILD_INFO_STRUCT@@QAEHH@Z
_TEXT	SEGMENT
_iTime$ = 8						; size = 4
?CheckTimeStamp@_GUILD_INFO_STRUCT@@QAEHH@Z PROC	; _GUILD_INFO_STRUCT::CheckTimeStamp, COMDAT
; _this$ = ecx

; 158  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 159  : 		return (iTime == this->iTimeStamp)? TRUE : FALSE;

  00003	8b 55 08	 mov	 edx, DWORD PTR _iTime$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	3b 91 24 07 00
	00		 cmp	 edx, DWORD PTR [ecx+1828]
  0000e	0f 94 c0	 sete	 al

; 160  : 	}	// line : 129

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?CheckTimeStamp@_GUILD_INFO_STRUCT@@QAEHH@Z ENDP	; _GUILD_INFO_STRUCT::CheckTimeStamp
_TEXT	ENDS
PUBLIC	??4CMagicInf@@QAEAAV0@AAV0@@Z			; CMagicInf::operator=
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\magicinf.h
;	COMDAT ??4CMagicInf@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CMagicInf@@QAEAAV0@AAV0@@Z PROC			; CMagicInf::operator=, COMDAT
; _this$ = ecx

; 31   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 32   : 		this->m_Level = __that.m_Level;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00008	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  0000c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 33   : 		this->m_Skill = __that.m_Skill;

  0000f	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  00013	88 50 05	 mov	 BYTE PTR [eax+5], dl

; 34   : 		this->m_DamageMin = __that.m_DamageMin;

  00016	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00019	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 35   : 		this->m_DamageMax = __that.m_DamageMax;

  0001c	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0001f	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 36   : 
; 37   : 		return *this;
; 38   : 	};

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??4CMagicInf@@QAEAAV0@AAV0@@Z ENDP			; CMagicInf::operator=
_TEXT	ENDS
PUBLIC	?gUserFindDevilSquareKeyEyes@@YAHH@Z		; gUserFindDevilSquareKeyEyes
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
;	COMDAT ?gUserFindDevilSquareKeyEyes@@YAHH@Z
_TEXT	SEGMENT
_bFindEyes$ = 8						; size = 4
_aIndex$ = 8						; size = 4
?gUserFindDevilSquareKeyEyes@@YAHH@Z PROC		; gUserFindDevilSquareKeyEyes, COMDAT

; 16560: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 16561: 	LPOBJ lpObj = &gObj[aIndex];

  00005	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00008	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0000e	57		 push	 edi

; 16562: 	int bFindKey = 0;

  0000f	33 ff		 xor	 edi, edi
  00011	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00017	33 db		 xor	 ebx, ebx

; 16563: 	int bFindEyes = 0;

  00019	89 7d 08	 mov	 DWORD PTR _bFindEyes$[ebp], edi
  0001c	8d 64 24 00	 npad	 4
$LL7@gUserFindD@2:

; 16566: 	{
; 16567: 		if(lpObj->pInventory[n].IsItem() == 1)

  00020	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00026	03 cf		 add	 ecx, edi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	75 2b		 jne	 SHORT $LN6@gUserFindD@2

; 16568: 		{
; 16569: 			if(lpObj->pInventory[n].m_Type == ITEMGET(14,17))

  00032	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00038	0f b7 44 38 06	 movzx	 eax, WORD PTR [eax+edi+6]
  0003d	b9 11 1c 00 00	 mov	 ecx, 7185		; 00001c11H
  00042	66 3b c1	 cmp	 ax, cx
  00045	75 07		 jne	 SHORT $LN3@gUserFindD@2

; 16570: 			{
; 16571: 				bFindEyes = 1;

  00047	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _bFindEyes$[ebp], 1
$LN3@gUserFindD@2:

; 16572: 			}
; 16573: 
; 16574: 			if(lpObj->pInventory[n].m_Type == ITEMGET(14,18))

  0004e	ba 12 1c 00 00	 mov	 edx, 7186		; 00001c12H
  00053	66 3b c2	 cmp	 ax, dx
  00056	75 05		 jne	 SHORT $LN6@gUserFindD@2

; 16575: 			{
; 16576: 				bFindKey = 1;

  00058	bb 01 00 00 00	 mov	 ebx, 1
$LN6@gUserFindD@2:

; 16564: 
; 16565: 	for(int n = 0; n < MAIN_INVENTORY_SIZE; n++)

  0005d	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00063	81 ff e0 31 00
	00		 cmp	 edi, 12768		; 000031e0H
  00069	7c b5		 jl	 SHORT $LL7@gUserFindD@2

; 16577: 			}
; 16578: 		}
; 16579: 	}
; 16580: 
; 16581: 	if(bFindKey != 0 && bFindEyes != 0)

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	85 db		 test	 ebx, ebx
  0006f	5b		 pop	 ebx
  00070	74 0d		 je	 SHORT $LN1@gUserFindD@2
  00072	83 7d 08 00	 cmp	 DWORD PTR _bFindEyes$[ebp], 0
  00076	74 07		 je	 SHORT $LN1@gUserFindD@2

; 16582: 	{
; 16583: 		return true;

  00078	b8 01 00 00 00	 mov	 eax, 1

; 16586: }

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
$LN1@gUserFindD@2:

; 16584: 	}
; 16585: 	return false;

  0007f	33 c0		 xor	 eax, eax

; 16586: }

  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?gUserFindDevilSquareKeyEyes@@YAHH@Z ENDP		; gUserFindDevilSquareKeyEyes
_TEXT	ENDS
PUBLIC	?Init@BILL_CLASS@@QAEXXZ			; BILL_CLASS::Init
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.h
;	COMDAT ?Init@BILL_CLASS@@QAEXXZ
_TEXT	SEGMENT
?Init@BILL_CLASS@@QAEXXZ PROC				; BILL_CLASS::Init, COMDAT
; _this$ = ecx

; 823  : 		this->cCertifyType=-1;
; 824  : 		this->PayCode=0;

  00000	33 c0		 xor	 eax, eax
  00002	66 c7 01 ff 00	 mov	 WORD PTR [ecx], 255	; 000000ffH

; 825  : 		this->EndTime=0;

  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 826  : 		this->EndsDays[0]='\0';

  0000a	88 41 08	 mov	 BYTE PTR [ecx+8], al

; 827  : 	};

  0000d	c3		 ret	 0
?Init@BILL_CLASS@@QAEXXZ ENDP				; BILL_CLASS::Init
_TEXT	ENDS
PUBLIC	?gObjFind@@YAPAUOBJECTSTRUCT@@PAD@Z		; gObjFind
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
;	COMDAT ?gObjFind@@YAPAUOBJECTSTRUCT@@PAD@Z
_TEXT	SEGMENT
_lpObj$ = -4						; size = 4
_targetcharname$ = 8					; size = 4
?gObjFind@@YAPAUOBJECTSTRUCT@@PAD@Z PROC		; gObjFind, COMDAT

; 16633: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 16634: 	if ( gDisconnect == TRUE )

  00004	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect
  0000b	75 06		 jne	 SHORT $LN7@gObjFind

; 16635: 	{
; 16636: 		return NULL;

  0000d	33 c0		 xor	 eax, eax

; 16659: 
; 16660: }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
$LN7@gObjFind:
  00013	56		 push	 esi
  00014	57		 push	 edi

; 16637: 	}
; 16638: 
; 16639: 	int n;
; 16640: 	LPOBJ lpObj;
; 16641: 
; 16642: 	for (int n = OBJ_STARTUSERINDEX ; n<OBJMAX;n++)

  00015	8b 7d 08	 mov	 edi, DWORD PTR _targetcharname$[ebp]
  00018	be 6f c4 16 02	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046511
  0001d	b8 02 00 00 00	 mov	 eax, 2
  00022	53		 push	 ebx
$LL6@gObjFind:

; 16643: 	{
; 16644: 		lpObj = &gObj[n];

  00023	8d 4e 91	 lea	 ecx, DWORD PTR [esi-111]
  00026	89 4d fc	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 16645: 
; 16646: 		if ( lpObj->Connected > PLAYER_LOGGED )

  00029	38 46 95	 cmp	 BYTE PTR [esi-107], al
  0002c	76 31		 jbe	 SHORT $LN5@gObjFind

; 16647: 		{
; 16648: 			if ( lpObj->Name[0] == targetcharname[0] )

  0002e	8a 16		 mov	 dl, BYTE PTR [esi]
  00030	3a 17		 cmp	 dl, BYTE PTR [edi]
  00032	75 2b		 jne	 SHORT $LN5@gObjFind

; 16649: 			{
; 16650: 				if ( strcmp(lpObj->Name, targetcharname) == 0 )

  00034	8b d7		 mov	 edx, edi
  00036	8b ce		 mov	 ecx, esi
$LL13@gObjFind:
  00038	8a 19		 mov	 bl, BYTE PTR [ecx]
  0003a	3a 1a		 cmp	 bl, BYTE PTR [edx]
  0003c	75 18		 jne	 SHORT $LN14@gObjFind
  0003e	84 db		 test	 bl, bl
  00040	74 10		 je	 SHORT $LN15@gObjFind
  00042	8a 59 01	 mov	 bl, BYTE PTR [ecx+1]
  00045	3a 5a 01	 cmp	 bl, BYTE PTR [edx+1]
  00048	75 0c		 jne	 SHORT $LN14@gObjFind
  0004a	03 c8		 add	 ecx, eax
  0004c	03 d0		 add	 edx, eax
  0004e	84 db		 test	 bl, bl
  00050	75 e6		 jne	 SHORT $LL13@gObjFind
$LN15@gObjFind:
  00052	33 c9		 xor	 ecx, ecx
  00054	eb 05		 jmp	 SHORT $LN16@gObjFind
$LN14@gObjFind:
  00056	1b c9		 sbb	 ecx, ecx
  00058	83 d9 ff	 sbb	 ecx, -1
$LN16@gObjFind:
  0005b	85 c9		 test	 ecx, ecx
  0005d	74 17		 je	 SHORT $LN11@gObjFind
$LN5@gObjFind:

; 16637: 	}
; 16638: 
; 16639: 	int n;
; 16640: 	LPOBJ lpObj;
; 16641: 
; 16642: 	for (int n = OBJ_STARTUSERINDEX ; n<OBJMAX;n++)

  0005f	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  00065	81 fe 0f 53 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522511
  0006b	7c b6		 jl	 SHORT $LL6@gObjFind

; 16653: 				}
; 16654: 			}
; 16655: 		}
; 16656: 	}
; 16657: 
; 16658: 	return NULL;

  0006d	5b		 pop	 ebx
  0006e	5f		 pop	 edi
  0006f	33 c0		 xor	 eax, eax
  00071	5e		 pop	 esi

; 16659: 
; 16660: }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
$LN11@gObjFind:

; 16651: 				{
; 16652: 					return lpObj;

  00076	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00079	5b		 pop	 ebx
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi

; 16659: 
; 16660: }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?gObjFind@@YAPAUOBJECTSTRUCT@@PAD@Z ENDP		; gObjFind
_TEXT	ENDS
PUBLIC	?gObjFind10EventChip@@YAHH@Z			; gObjFind10EventChip
; Function compile flags: /Ogtp
;	COMDAT ?gObjFind10EventChip@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjFind10EventChip@@YAHH@Z PROC			; gObjFind10EventChip, COMDAT

; 16663: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 16664: 	LPOBJ lpObj = &gObj[aIndex];

  00005	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00008	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0000e	57		 push	 edi
  0000f	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16665: 	int count = 0;

  00015	33 db		 xor	 ebx, ebx
  00017	33 ff		 xor	 edi, edi
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL6@gObjFind10:

; 16668: 	{
; 16669: 		if(lpObj->pInventory[n].IsItem() == 1)

  00020	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00026	03 cf		 add	 ecx, edi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	75 18		 jne	 SHORT $LN5@gObjFind10

; 16670: 		{
; 16671: 			if(lpObj->pInventory[n].m_Type == ITEMGET(14,21))

  00032	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00038	b9 15 1c 00 00	 mov	 ecx, 7189		; 00001c15H
  0003d	66 39 4c 38 06	 cmp	 WORD PTR [eax+edi+6], cx
  00042	75 06		 jne	 SHORT $LN5@gObjFind10

; 16672: 			{
; 16673: 				count++;

  00044	43		 inc	 ebx

; 16674: 
; 16675: 				if(count >= 10)

  00045	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  00048	7d 15		 jge	 SHORT $LN10@gObjFind10
$LN5@gObjFind10:

; 16666: 
; 16667: 	for(int n = 0; n < MAIN_INVENTORY_SIZE;n++)

  0004a	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00050	81 ff e0 31 00
	00		 cmp	 edi, 12768		; 000031e0H
  00056	7c c8		 jl	 SHORT $LL6@gObjFind10

; 16678: 				}
; 16679: 			}
; 16680: 		}
; 16681: 	}
; 16682: 	return false;

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	33 c0		 xor	 eax, eax
  0005c	5b		 pop	 ebx

; 16683: }

  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN10@gObjFind10:
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 16676: 				{
; 16677: 					return true;

  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	5b		 pop	 ebx

; 16683: }

  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?gObjFind10EventChip@@YAHH@Z ENDP			; gObjFind10EventChip
_TEXT	ENDS
PUBLIC	?GetPayCode@BILL_CLASS@@QAEEXZ			; BILL_CLASS::GetPayCode
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.h
;	COMDAT ?GetPayCode@BILL_CLASS@@QAEEXZ
_TEXT	SEGMENT
?GetPayCode@BILL_CLASS@@QAEEXZ PROC			; BILL_CLASS::GetPayCode, COMDAT
; _this$ = ecx

; 854  : 		return this->PayCode;

  00000	8a 41 01	 mov	 al, BYTE PTR [ecx+1]

; 855  : 	};

  00003	c3		 ret	 0
?GetPayCode@BILL_CLASS@@QAEEXZ ENDP			; BILL_CLASS::GetPayCode
_TEXT	ENDS
PUBLIC	?GetEndsDays@BILL_CLASS@@QAEPADXZ		; BILL_CLASS::GetEndsDays
; Function compile flags: /Ogtp
;	COMDAT ?GetEndsDays@BILL_CLASS@@QAEPADXZ
_TEXT	SEGMENT
?GetEndsDays@BILL_CLASS@@QAEPADXZ PROC			; BILL_CLASS::GetEndsDays, COMDAT
; _this$ = ecx

; 859  : 		return &this->EndsDays[0];

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 860  : 	};

  00003	c3		 ret	 0
?GetEndsDays@BILL_CLASS@@QAEPADXZ ENDP			; BILL_CLASS::GetEndsDays
_TEXT	ENDS
PUBLIC	?GetEndTime@BILL_CLASS@@QAEHXZ			; BILL_CLASS::GetEndTime
; Function compile flags: /Ogtp
;	COMDAT ?GetEndTime@BILL_CLASS@@QAEHXZ
_TEXT	SEGMENT
?GetEndTime@BILL_CLASS@@QAEHXZ PROC			; BILL_CLASS::GetEndTime, COMDAT
; _this$ = ecx

; 864  : 		return this->EndTime;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 865  : 	};

  00003	c3		 ret	 0
?GetEndTime@BILL_CLASS@@QAEHXZ ENDP			; BILL_CLASS::GetEndTime
_TEXT	ENDS
PUBLIC	?GetCertify@BILL_CLASS@@QAEHXZ			; BILL_CLASS::GetCertify
; Function compile flags: /Ogtp
;	COMDAT ?GetCertify@BILL_CLASS@@QAEHXZ
_TEXT	SEGMENT
?GetCertify@BILL_CLASS@@QAEHXZ PROC			; BILL_CLASS::GetCertify, COMDAT
; _this$ = ecx

; 869  : 		return this->cCertifyType;

  00000	0f be 01	 movsx	 eax, BYTE PTR [ecx]

; 870  : 	};

  00003	c3		 ret	 0
?GetCertify@BILL_CLASS@@QAEHXZ ENDP			; BILL_CLASS::GetCertify
_TEXT	ENDS
PUBLIC	?gObjSetPosition@@YAXHHH@Z			; gObjSetPosition
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
;	COMDAT ?gObjSetPosition@@YAXHHH@Z
_TEXT	SEGMENT
_pMove$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?gObjSetPosition@@YAXHHH@Z PROC				; gObjSetPosition, COMDAT

; 16712: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 16713: 
; 16714: 	LPOBJ lpObj = &gObj[aIndex];

  00008	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 16715: 	PMSG_POSISTION_SET pMove;
; 16716: 
; 16717: 	pMove.h.c = 0xC1;
; 16718: 	pMove.h.headcode = PROTOCOL_POSITION;
; 16719: 	pMove.h.size = sizeof(pMove);
; 16720: 
; 16721: 	pMove.X = x;
; 16722: 	pMove.Y = y;

  0000b	8a 45 10	 mov	 al, BYTE PTR _y$[ebp]
  0000e	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _x$[ebp]
  00017	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16723: 
; 16724: 	lpObj->m_Rest = 0;
; 16725: 
; 16726: 
; 16727: 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX,lpObj->m_OldY);

  0001d	0f bf 8e 1e 01
	00 00		 movsx	 ecx, WORD PTR [esi+286]
  00024	0f bf 96 1c 01
	00 00		 movsx	 edx, WORD PTR [esi+284]
  0002b	51		 push	 ecx
  0002c	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00033	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00039	52		 push	 edx
  0003a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00040	c6 45 f8 c1	 mov	 BYTE PTR _pMove$[ebp], 193 ; 000000c1H
  00044	66 c7 45 f9 05
	df		 mov	 WORD PTR _pMove$[ebp+1], 57093 ; 0000df05H
  0004a	88 5d fb	 mov	 BYTE PTR _pMove$[ebp+3], bl
  0004d	88 45 fc	 mov	 BYTE PTR _pMove$[ebp+4], al
  00050	c6 86 c1 01 00
	00 00		 mov	 BYTE PTR [esi+449], 0
  00057	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 16728: 	MapC[lpObj->MapNumber].SetStandAttr(x,y);

  0005c	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00063	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00066	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  0006c	50		 push	 eax
  0006d	53		 push	 ebx
  0006e	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00074	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 16729: 
; 16730: 	lpObj->m_OldX = x;
; 16731: 	lpObj->m_OldY = y;
; 16732: 
; 16733: 	RecvPositionSetProc(&pMove,lpObj->m_Index);

  00079	8b 16		 mov	 edx, DWORD PTR [esi]
  0007b	66 8b 4d 10	 mov	 cx, WORD PTR _y$[ebp]
  0007f	52		 push	 edx
  00080	8d 45 f8	 lea	 eax, DWORD PTR _pMove$[ebp]
  00083	50		 push	 eax
  00084	66 89 9e 1c 01
	00 00		 mov	 WORD PTR [esi+284], bx
  0008b	66 89 8e 1e 01
	00 00		 mov	 WORD PTR [esi+286], cx
  00092	e8 00 00 00 00	 call	 ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
  00097	83 c4 08	 add	 esp, 8
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx

; 16734: }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
?gObjSetPosition@@YAXHHH@Z ENDP				; gObjSetPosition
_TEXT	ENDS
PUBLIC	?gObjGetItemCountInEquipment@@YAHHHHH@Z		; gObjGetItemCountInEquipment
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetItemCountInEquipment@@YAHHHHH@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_itemtype$ = 12						; size = 4
_itemindex$ = 16					; size = 4
_itemlevel$ = 20					; size = 4
?gObjGetItemCountInEquipment@@YAHHHHH@Z PROC		; gObjGetItemCountInEquipment, COMDAT

; 16737: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 16738: 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _itemindex$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000b	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00011	57		 push	 edi
  00012	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16739: 	int count = 0;

  00018	33 ff		 xor	 edi, edi
  0001a	89 7d 08	 mov	 DWORD PTR _count$[ebp], edi
  0001d	8d 49 00	 npad	 3
$LL7@gObjGetIte:

; 16742: 	{
; 16743: 		if ( lpObj->pInventory[n].IsItem() == TRUE )

  00020	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00026	03 cf		 add	 ecx, edi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	75 2b		 jne	 SHORT $LN6@gObjGetIte

; 16744: 		{
; 16745: 			if ( lpObj->pInventory[n].m_Type == ((itemtype * MAX_SUBTYPE_ITEMS) + itemindex) )

  00032	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _itemtype$[ebp]
  0003b	0f bf 54 38 06	 movsx	 edx, WORD PTR [eax+edi+6]
  00040	c1 e1 09	 shl	 ecx, 9
  00043	03 cb		 add	 ecx, ebx
  00045	3b d1		 cmp	 edx, ecx
  00047	75 14		 jne	 SHORT $LN6@gObjGetIte

; 16746: 			{
; 16747: 				if ( itemlevel != -1 )

  00049	8b 4d 14	 mov	 ecx, DWORD PTR _itemlevel$[ebp]
  0004c	83 f9 ff	 cmp	 ecx, -1
  0004f	74 09		 je	 SHORT $LN1@gObjGetIte

; 16748: 				{
; 16749: 					if (  lpObj->pInventory[n].m_Level != itemlevel )

  00051	0f bf 44 38 08	 movsx	 eax, WORD PTR [eax+edi+8]
  00056	3b c1		 cmp	 eax, ecx
  00058	75 03		 jne	 SHORT $LN6@gObjGetIte
$LN1@gObjGetIte:

; 16750: 					{
; 16751: 						continue;
; 16752: 					}
; 16753: 				}
; 16754: 				
; 16755: 				count++;

  0005a	ff 45 08	 inc	 DWORD PTR _count$[ebp]
$LN6@gObjGetIte:

; 16740: 
; 16741: 	for ( int n =0;n<MAX_PLAYER_EQUIPMENT ; n++ )

  0005d	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00063	81 ff e0 07 00
	00		 cmp	 edi, 2016		; 000007e0H
  00069	7c b5		 jl	 SHORT $LL7@gObjGetIte

; 16756: 			}
; 16757: 		}
; 16758: 	}
; 16759: 
; 16760: 	return count;

  0006b	8b 45 08	 mov	 eax, DWORD PTR _count$[ebp]
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx

; 16761: }

  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?gObjGetItemCountInEquipment@@YAHHHHH@Z ENDP		; gObjGetItemCountInEquipment
_TEXT	ENDS
PUBLIC	?gObjGetItemCountInIventory@@YAHHHHH@Z		; gObjGetItemCountInIventory
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetItemCountInIventory@@YAHHHHH@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_itemtype$ = 12						; size = 4
_itemindex$ = 16					; size = 4
_itemlevel$ = 20					; size = 4
?gObjGetItemCountInIventory@@YAHHHHH@Z PROC		; gObjGetItemCountInIventory, COMDAT

; 16764: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 16765: 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _itemindex$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000b	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00011	57		 push	 edi
  00012	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16766: 	int count = 0;

  00018	33 ff		 xor	 edi, edi
  0001a	89 7d 08	 mov	 DWORD PTR _count$[ebp], edi
  0001d	8d 49 00	 npad	 3
$LL7@gObjGetIte@2:

; 16769: 	{
; 16770: 		if ( lpObj->pInventory[n].IsItem() == TRUE )

  00020	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00026	03 cf		 add	 ecx, edi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	75 2b		 jne	 SHORT $LN6@gObjGetIte@2

; 16771: 		{
; 16772: 			if ( lpObj->pInventory[n].m_Type == ((itemtype * MAX_SUBTYPE_ITEMS) + itemindex) )

  00032	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _itemtype$[ebp]
  0003b	0f bf 54 38 06	 movsx	 edx, WORD PTR [eax+edi+6]
  00040	c1 e1 09	 shl	 ecx, 9
  00043	03 cb		 add	 ecx, ebx
  00045	3b d1		 cmp	 edx, ecx
  00047	75 14		 jne	 SHORT $LN6@gObjGetIte@2

; 16773: 			{
; 16774: 				if ( itemlevel != -1 )

  00049	8b 4d 14	 mov	 ecx, DWORD PTR _itemlevel$[ebp]
  0004c	83 f9 ff	 cmp	 ecx, -1
  0004f	74 09		 je	 SHORT $LN1@gObjGetIte@2

; 16775: 				{
; 16776: 					if (  lpObj->pInventory[n].m_Level != itemlevel )

  00051	0f bf 44 38 08	 movsx	 eax, WORD PTR [eax+edi+8]
  00056	3b c1		 cmp	 eax, ecx
  00058	75 03		 jne	 SHORT $LN6@gObjGetIte@2
$LN1@gObjGetIte@2:

; 16777: 					{
; 16778: 						continue;
; 16779: 					}
; 16780: 				}
; 16781: 				
; 16782: 				count++;

  0005a	ff 45 08	 inc	 DWORD PTR _count$[ebp]
$LN6@gObjGetIte@2:

; 16767: 
; 16768: 	for ( int n =0;n<MAIN_INVENTORY_SIZE ; n++ )

  0005d	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00063	81 ff e0 31 00
	00		 cmp	 edi, 12768		; 000031e0H
  00069	7c b5		 jl	 SHORT $LL7@gObjGetIte@2

; 16783: 			}
; 16784: 		}
; 16785: 	}
; 16786: 
; 16787: 	return count;

  0006b	8b 45 08	 mov	 eax, DWORD PTR _count$[ebp]
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx

; 16788: }

  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?gObjGetItemCountInIventory@@YAHHHHH@Z ENDP		; gObjGetItemCountInIventory
_TEXT	ENDS
PUBLIC	?gObjGetItemCountInIventory@@YAHHH@Z		; gObjGetItemCountInIventory
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetItemCountInIventory@@YAHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_itemnum$ = 12						; size = 4
?gObjGetItemCountInIventory@@YAHHH@Z PROC		; gObjGetItemCountInIventory, COMDAT

; 16791: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 16792: 	LPOBJ lpObj = &gObj[aIndex];

  00005	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00008	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0000e	57		 push	 edi
  0000f	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16793: 	int count = 0;

  00015	33 db		 xor	 ebx, ebx
  00017	33 ff		 xor	 edi, edi
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL5@gObjGetIte@3:

; 16796: 	{
; 16797: 		if ( lpObj->pInventory[n].IsItem() == TRUE )

  00020	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00026	03 cf		 add	 ecx, edi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	75 11		 jne	 SHORT $LN4@gObjGetIte@3

; 16798: 		{
; 16799: 			if ( lpObj->pInventory[n].m_Type == itemnum )

  00032	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00038	0f bf 4c 38 06	 movsx	 ecx, WORD PTR [eax+edi+6]
  0003d	3b 4d 0c	 cmp	 ecx, DWORD PTR _itemnum$[ebp]
  00040	75 01		 jne	 SHORT $LN4@gObjGetIte@3

; 16800: 			{
; 16801: 				count++;

  00042	43		 inc	 ebx
$LN4@gObjGetIte@3:

; 16794: 
; 16795: 	for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  00043	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00049	81 ff e0 31 00
	00		 cmp	 edi, 12768		; 000031e0H
  0004f	7c cf		 jl	 SHORT $LL5@gObjGetIte@3

; 16802: 			}
; 16803: 		}
; 16804: 	}
; 16805: 
; 16806: 	return count;

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	8b c3		 mov	 eax, ebx
  00055	5b		 pop	 ebx

; 16807: 
; 16808: }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?gObjGetItemCountInIventory@@YAHHH@Z ENDP		; gObjGetItemCountInIventory
_TEXT	ENDS
PUBLIC	?gObjGetManaItemPos@@YAHH@Z			; gObjGetManaItemPos
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetManaItemPos@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjGetManaItemPos@@YAHH@Z PROC			; gObjGetManaItemPos, COMDAT

; 16811: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 16812: 	LPOBJ lpObj = &gObj[aIndex];

  00006	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00009	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0000f	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16813: 	int count = 0;
; 16814: 	
; 16815: 	for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  00015	33 db		 xor	 ebx, ebx
  00017	33 f6		 xor	 esi, esi
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL6@gObjGetMan:

; 16816: 	{
; 16817: 		if ( lpObj->pInventory[n].IsItem() == TRUE )

  00020	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3212]
  00026	03 ce		 add	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	75 29		 jne	 SHORT $LN5@gObjGetMan

; 16818: 		{
; 16819: 			if ( lpObj->pInventory[n].m_Type == ITEMGET(14,4) || lpObj->pInventory[n].m_Type == ITEMGET(14,5) || lpObj->pInventory[n].m_Type == ITEMGET(14,6) )

  00032	8b 87 8c 0c 00
	00		 mov	 eax, DWORD PTR [edi+3212]
  00038	0f b7 44 30 06	 movzx	 eax, WORD PTR [eax+esi+6]
  0003d	b9 04 1c 00 00	 mov	 ecx, 7172		; 00001c04H
  00042	66 3b c1	 cmp	 ax, cx
  00045	74 2b		 je	 SHORT $LN1@gObjGetMan
  00047	ba 05 1c 00 00	 mov	 edx, 7173		; 00001c05H
  0004c	66 3b c2	 cmp	 ax, dx
  0004f	74 21		 je	 SHORT $LN1@gObjGetMan
  00051	b9 06 1c 00 00	 mov	 ecx, 7174		; 00001c06H
  00056	66 3b c1	 cmp	 ax, cx
  00059	74 17		 je	 SHORT $LN1@gObjGetMan
$LN5@gObjGetMan:

; 16813: 	int count = 0;
; 16814: 	
; 16815: 	for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  0005b	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00061	43		 inc	 ebx
  00062	81 fe e0 31 00
	00		 cmp	 esi, 12768		; 000031e0H
  00068	7c b6		 jl	 SHORT $LL6@gObjGetMan

; 16822: 			}
; 16823: 		}
; 16824: 	}
; 16825: 
; 16826: 	return -1;

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	83 c8 ff	 or	 eax, -1
  0006f	5b		 pop	 ebx

; 16827: }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
$LN1@gObjGetMan:
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi

; 16820: 			{
; 16821: 				return n;

  00074	8b c3		 mov	 eax, ebx
  00076	5b		 pop	 ebx

; 16827: }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?gObjGetManaItemPos@@YAHH@Z ENDP			; gObjGetManaItemPos
_TEXT	ENDS
PUBLIC	?gObjGetStatPointState@@YAXHAAF000@Z		; gObjGetStatPointState
EXTRN	?GetMaxMinusStat@CStatMng@@QAEHHH@Z:PROC	; CStatMng::GetMaxMinusStat
EXTRN	?GetMaxStat@CStatMng@@QAEHHH@Z:PROC		; CStatMng::GetMaxStat
EXTRN	?gStatMng@@3VCStatMng@@A:BYTE			; gStatMng
EXTRN	?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CQuestInfo::GetQuestState
EXTRN	?g_QuestInfo@@3VCQuestInfo@@A:BYTE		; g_QuestInfo
EXTRN	?GetDefPoint@classdef@@QAEHH@Z:PROC		; classdef::GetDefPoint
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetStatPointState@@YAXHAAF000@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_AddPoint$ = 12						; size = 4
_MaxAddPoint$ = 16					; size = 4
_MinusPoint$ = 20					; size = 4
_MaxMinusPoint$ = 24					; size = 4
?gObjGetStatPointState@@YAXHAAF000@Z PROC		; gObjGetStatPointState, COMDAT

; 16855: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 16856: 	if(gObj[aIndex].Level <= 5)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0000c	66 83 b8 9c 00
	00 00 05	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+156], 5
  00014	7f 0e		 jg	 SHORT $LN7@gObjGetSta

; 16857: 	{
; 16858: 		AddPoint = 0;

  00016	8b 55 0c	 mov	 edx, DWORD PTR _AddPoint$[ebp]
  00019	33 c9		 xor	 ecx, ecx
  0001b	66 89 0a	 mov	 WORD PTR [edx], cx

; 16859: 		MaxAddPoint = 0;

  0001e	8b 55 10	 mov	 edx, DWORD PTR _MaxAddPoint$[ebp]
  00021	66 89 0a	 mov	 WORD PTR [edx], cx
$LN7@gObjGetSta:

; 16860: 	}
; 16861: 
; 16862: 	LPOBJ lpObj = &gObj[aIndex];
; 16863: 
; 16864: 	int total_point = lpObj->Strength + lpObj->Dexterity + lpObj->Vitality + lpObj->Energy + lpObj->Leadership + lpObj->LevelUpPoint;

  00024	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+184]
  0002b	0f b7 90 b6 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+182]
  00032	53		 push	 ebx
  00033	56		 push	 esi
  00034	8d b0 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  0003a	0f b7 86 ba 00
	00 00		 movzx	 eax, WORD PTR [esi+186]
  00041	57		 push	 edi
  00042	0f b7 be d8 00
	00 00		 movzx	 edi, WORD PTR [esi+216]
  00049	03 f8		 add	 edi, eax
  0004b	0f b7 86 b4 00
	00 00		 movzx	 eax, WORD PTR [esi+180]
  00052	03 f9		 add	 edi, ecx
  00054	03 fa		 add	 edi, edx
  00056	03 f8		 add	 edi, eax

; 16865: 	int ori_point;
; 16866: 
; 16867: 	if(lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA)

  00058	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  0005f	03 be a0 00 00
	00		 add	 edi, DWORD PTR [esi+160]
  00065	83 f8 04	 cmp	 eax, 4
  00068	74 20		 je	 SHORT $LN5@gObjGetSta
  0006a	83 f8 03	 cmp	 eax, 3
  0006d	74 1b		 je	 SHORT $LN5@gObjGetSta

; 16870: 	}
; 16871: 	else
; 16872: 	{
; 16873: 		ori_point = DCInfo.GetDefPoint(lpObj->Class) + (lpObj->Level - 1) * 5;

  0006f	50		 push	 eax
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET ?DCInfo@@3Vclassdef@@A ; DCInfo
  00075	e8 00 00 00 00	 call	 ?GetDefPoint@classdef@@QAEHH@Z ; classdef::GetDefPoint
  0007a	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR [esi+156]
  00081	8d 14 89	 lea	 edx, DWORD PTR [ecx+ecx*4]
  00084	8d 5c 10 fb	 lea	 ebx, DWORD PTR [eax+edx-5]
  00088	eb 1f		 jmp	 SHORT $LN4@gObjGetSta
$LN5@gObjGetSta:

; 16868: 	{
; 16869: 		ori_point = DCInfo.GetDefPoint(lpObj->Class) + (lpObj->Level - 1) * 7;

  0008a	50		 push	 eax
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET ?DCInfo@@3Vclassdef@@A ; DCInfo
  00090	e8 00 00 00 00	 call	 ?GetDefPoint@classdef@@QAEHH@Z ; classdef::GetDefPoint
  00095	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR [esi+156]
  0009c	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  000a3	2b d1		 sub	 edx, ecx
  000a5	8d 5c 10 f9	 lea	 ebx, DWORD PTR [eax+edx-7]
$LN4@gObjGetSta:

; 16874: 	}
; 16875: 
; 16876: 	if(g_QuestInfo.GetQuestState(lpObj,0) == 2)

  000a9	6a 00		 push	 0
  000ab	56		 push	 esi
  000ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  000b1	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  000b6	83 f8 02	 cmp	 eax, 2
  000b9	75 03		 jne	 SHORT $LN3@gObjGetSta

; 16877: 	{
; 16878: 		ori_point+= 10;

  000bb	83 c3 0a	 add	 ebx, 10			; 0000000aH
$LN3@gObjGetSta:

; 16879: 	}
; 16880: 
; 16881: 	if(g_QuestInfo.GetQuestState(lpObj,1) == 2)

  000be	6a 01		 push	 1
  000c0	56		 push	 esi
  000c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  000c6	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  000cb	83 f8 02	 cmp	 eax, 2
  000ce	75 03		 jne	 SHORT $LN2@gObjGetSta

; 16882: 	{
; 16883: 		ori_point+= 10;

  000d0	83 c3 0a	 add	 ebx, 10			; 0000000aH
$LN2@gObjGetSta:

; 16884: 	}
; 16885: 
; 16886: 	if(g_QuestInfo.GetQuestState(lpObj,2) == 2)

  000d3	6a 02		 push	 2
  000d5	56		 push	 esi
  000d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  000db	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  000e0	83 f8 02	 cmp	 eax, 2
  000e3	75 0e		 jne	 SHORT $LN1@gObjGetSta

; 16887: 	{
; 16888: 		ori_point+= lpObj->Level - 220;

  000e5	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  000ec	8d 9c 03 24 ff
	ff ff		 lea	 ebx, DWORD PTR [ebx+eax-220]
$LN1@gObjGetSta:

; 16889: 	}
; 16890: 
; 16891: 	int addpoint = ori_point;
; 16892: 
; 16893: 	addpoint += gStatMng.GetMaxStat(lpObj->Level,lpObj->Class);

  000f3	0f b7 8e 98 00
	00 00		 movzx	 ecx, WORD PTR [esi+152]
  000fa	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  00101	51		 push	 ecx
  00102	52		 push	 edx
  00103	b9 00 00 00 00	 mov	 ecx, OFFSET ?gStatMng@@3VCStatMng@@A ; gStatMng
  00108	e8 00 00 00 00	 call	 ?GetMaxStat@CStatMng@@QAEHHH@Z ; CStatMng::GetMaxStat

; 16894: 
; 16895: 	AddPoint = total_point - ori_point;

  0010d	8b 45 0c	 mov	 eax, DWORD PTR _AddPoint$[ebp]
  00110	2b fb		 sub	 edi, ebx
  00112	66 89 38	 mov	 WORD PTR [eax], di

; 16896: 	MaxAddPoint = gStatMng.GetMaxStat(lpObj->Level,lpObj->Class);

  00115	0f b7 8e 98 00
	00 00		 movzx	 ecx, WORD PTR [esi+152]
  0011c	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  00123	51		 push	 ecx
  00124	52		 push	 edx
  00125	b9 00 00 00 00	 mov	 ecx, OFFSET ?gStatMng@@3VCStatMng@@A ; gStatMng
  0012a	e8 00 00 00 00	 call	 ?GetMaxStat@CStatMng@@QAEHHH@Z ; CStatMng::GetMaxStat
  0012f	8b 4d 10	 mov	 ecx, DWORD PTR _MaxAddPoint$[ebp]
  00132	66 89 01	 mov	 WORD PTR [ecx], ax

; 16897: 	MinusPoint = lpObj->iFruitPoint;

  00135	66 8b 96 a4 00
	00 00		 mov	 dx, WORD PTR [esi+164]
  0013c	8b 45 14	 mov	 eax, DWORD PTR _MinusPoint$[ebp]
  0013f	66 89 10	 mov	 WORD PTR [eax], dx

; 16898: 	MaxMinusPoint = gStatMng.GetMaxMinusStat(lpObj->Level,lpObj->Class);

  00142	0f b7 8e 98 00
	00 00		 movzx	 ecx, WORD PTR [esi+152]
  00149	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  00150	51		 push	 ecx
  00151	52		 push	 edx
  00152	b9 00 00 00 00	 mov	 ecx, OFFSET ?gStatMng@@3VCStatMng@@A ; gStatMng
  00157	e8 00 00 00 00	 call	 ?GetMaxMinusStat@CStatMng@@QAEHHH@Z ; CStatMng::GetMaxMinusStat
  0015c	8b 4d 18	 mov	 ecx, DWORD PTR _MaxMinusPoint$[ebp]
  0015f	5f		 pop	 edi
  00160	5e		 pop	 esi
  00161	66 89 01	 mov	 WORD PTR [ecx], ax
  00164	5b		 pop	 ebx

; 16899: }

  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
?gObjGetStatPointState@@YAXHAAF000@Z ENDP		; gObjGetStatPointState
_TEXT	ENDS
PUBLIC	?gObjCheckStatPointUp@@YAHH@Z			; gObjCheckStatPointUp
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckStatPointUp@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjCheckStatPointUp@@YAHH@Z PROC			; gObjCheckStatPointUp, COMDAT

; 16902: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 16903: 	LPOBJ lpObj = &gObj[aIndex];

  00005	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00008	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0000e	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16904: 
; 16905: 	int total_point = lpObj->Strength + lpObj->Dexterity + lpObj->Vitality + lpObj->Energy + lpObj->Leadership + lpObj->LevelUpPoint;

  00014	0f b7 86 ba 00
	00 00		 movzx	 eax, WORD PTR [esi+186]
  0001b	0f b7 9e d8 00
	00 00		 movzx	 ebx, WORD PTR [esi+216]
  00022	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  00029	0f b7 96 b6 00
	00 00		 movzx	 edx, WORD PTR [esi+182]
  00030	03 d8		 add	 ebx, eax
  00032	0f b7 86 b4 00
	00 00		 movzx	 eax, WORD PTR [esi+180]
  00039	03 d9		 add	 ebx, ecx
  0003b	03 da		 add	 ebx, edx
  0003d	03 d8		 add	 ebx, eax

; 16906: 	int ori_point;
; 16907: 
; 16908: 	if(lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA)

  0003f	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00046	03 9e a0 00 00
	00		 add	 ebx, DWORD PTR [esi+160]
  0004c	57		 push	 edi
  0004d	83 f8 04	 cmp	 eax, 4
  00050	74 20		 je	 SHORT $LN6@gObjCheckS@2
  00052	83 f8 03	 cmp	 eax, 3
  00055	74 1b		 je	 SHORT $LN6@gObjCheckS@2

; 16911: 	}
; 16912: 	else
; 16913: 	{
; 16914: 		ori_point = DCInfo.GetDefPoint(lpObj->Class) + (lpObj->Level - 1) * 5;

  00057	50		 push	 eax
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?DCInfo@@3Vclassdef@@A ; DCInfo
  0005d	e8 00 00 00 00	 call	 ?GetDefPoint@classdef@@QAEHH@Z ; classdef::GetDefPoint
  00062	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR [esi+156]
  00069	8d 14 89	 lea	 edx, DWORD PTR [ecx+ecx*4]
  0006c	8d 7c 10 fb	 lea	 edi, DWORD PTR [eax+edx-5]
  00070	eb 1f		 jmp	 SHORT $LN5@gObjCheckS@2
$LN6@gObjCheckS@2:

; 16909: 	{
; 16910: 		ori_point = DCInfo.GetDefPoint(lpObj->Class) + (lpObj->Level - 1) * 7;

  00072	50		 push	 eax
  00073	b9 00 00 00 00	 mov	 ecx, OFFSET ?DCInfo@@3Vclassdef@@A ; DCInfo
  00078	e8 00 00 00 00	 call	 ?GetDefPoint@classdef@@QAEHH@Z ; classdef::GetDefPoint
  0007d	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR [esi+156]
  00084	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  0008b	2b d1		 sub	 edx, ecx
  0008d	8d 7c 10 f9	 lea	 edi, DWORD PTR [eax+edx-7]
$LN5@gObjCheckS@2:

; 16915: 	}
; 16916: 
; 16917: 	if(g_QuestInfo.GetQuestState(lpObj,0) == 2)

  00091	6a 00		 push	 0
  00093	56		 push	 esi
  00094	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00099	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  0009e	83 f8 02	 cmp	 eax, 2
  000a1	75 03		 jne	 SHORT $LN4@gObjCheckS@2

; 16918: 	{
; 16919: 		ori_point+= 10;

  000a3	83 c7 0a	 add	 edi, 10			; 0000000aH
$LN4@gObjCheckS@2:

; 16920: 	}
; 16921: 
; 16922: 	if(g_QuestInfo.GetQuestState(lpObj,1) == 2)

  000a6	6a 01		 push	 1
  000a8	56		 push	 esi
  000a9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  000ae	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  000b3	83 f8 02	 cmp	 eax, 2
  000b6	75 03		 jne	 SHORT $LN3@gObjCheckS@2

; 16923: 	{
; 16924: 		ori_point+= 10;

  000b8	83 c7 0a	 add	 edi, 10			; 0000000aH
$LN3@gObjCheckS@2:

; 16925: 	}
; 16926: 
; 16927: 	if(g_QuestInfo.GetQuestState(lpObj,2) == 2)

  000bb	6a 02		 push	 2
  000bd	56		 push	 esi
  000be	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  000c3	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  000c8	83 f8 02	 cmp	 eax, 2
  000cb	75 0e		 jne	 SHORT $LN2@gObjCheckS@2

; 16928: 	{
; 16929: 		ori_point+= lpObj->Level - 220;

  000cd	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  000d4	8d bc 07 24 ff
	ff ff		 lea	 edi, DWORD PTR [edi+eax-220]
$LN2@gObjCheckS@2:

; 16930: 	}
; 16931: 
; 16932: 	ori_point += gStatMng.GetMaxStat(lpObj->Level,lpObj->Class);
; 16933: 
; 16934: 	if(total_point < ori_point)

  000db	0f b7 8e 98 00
	00 00		 movzx	 ecx, WORD PTR [esi+152]
  000e2	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  000e9	51		 push	 ecx
  000ea	52		 push	 edx
  000eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gStatMng@@3VCStatMng@@A ; gStatMng
  000f0	e8 00 00 00 00	 call	 ?GetMaxStat@CStatMng@@QAEHHH@Z ; CStatMng::GetMaxStat
  000f5	03 c7		 add	 eax, edi
  000f7	33 c9		 xor	 ecx, ecx
  000f9	3b d8		 cmp	 ebx, eax
  000fb	0f 9c c1	 setl	 cl
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	8b c1		 mov	 eax, ecx

; 16935: 	{
; 16936: 		return true;
; 16937: 	}
; 16938: 	return false;
; 16939: }

  00103	5d		 pop	 ebp
  00104	c3		 ret	 0
?gObjCheckStatPointUp@@YAHH@Z ENDP			; gObjCheckStatPointUp
_TEXT	ENDS
PUBLIC	?gObjCheckStatPointDown@@YAHH@Z			; gObjCheckStatPointDown
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckStatPointDown@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjCheckStatPointDown@@YAHH@Z PROC			; gObjCheckStatPointDown, COMDAT

; 16942: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 16943: 	LPOBJ lpObj = &gObj[aIndex];

  00005	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00008	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0000e	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16944: 
; 16945: 	int total_point = lpObj->Strength + lpObj->Dexterity + lpObj->Vitality + lpObj->Energy + lpObj->LevelUpPoint;

  00014	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  0001b	0f b7 9e ba 00
	00 00		 movzx	 ebx, WORD PTR [esi+186]
  00022	0f b7 8e b6 00
	00 00		 movzx	 ecx, WORD PTR [esi+182]
  00029	0f b7 96 b4 00
	00 00		 movzx	 edx, WORD PTR [esi+180]
  00030	03 d8		 add	 ebx, eax

; 16946: 	int ori_point;
; 16947: 
; 16948: 	if(lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA)

  00032	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00039	03 d9		 add	 ebx, ecx
  0003b	03 da		 add	 ebx, edx
  0003d	03 9e a0 00 00
	00		 add	 ebx, DWORD PTR [esi+160]
  00043	57		 push	 edi
  00044	83 f8 04	 cmp	 eax, 4
  00047	74 20		 je	 SHORT $LN5@gObjCheckS@3
  00049	83 f8 03	 cmp	 eax, 3
  0004c	74 1b		 je	 SHORT $LN5@gObjCheckS@3

; 16951: 	}
; 16952: 	else
; 16953: 	{
; 16954: 		ori_point = DCInfo.GetDefPoint(lpObj->Class) + (lpObj->Level - 1) * 5;

  0004e	50		 push	 eax
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET ?DCInfo@@3Vclassdef@@A ; DCInfo
  00054	e8 00 00 00 00	 call	 ?GetDefPoint@classdef@@QAEHH@Z ; classdef::GetDefPoint
  00059	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR [esi+156]
  00060	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  00063	8d 7c 08 fb	 lea	 edi, DWORD PTR [eax+ecx-5]
  00067	eb 1f		 jmp	 SHORT $LN4@gObjCheckS@3
$LN5@gObjCheckS@3:

; 16949: 	{
; 16950: 		ori_point = DCInfo.GetDefPoint(lpObj->Class) + (lpObj->Level - 1) * 7;

  00069	50		 push	 eax
  0006a	b9 00 00 00 00	 mov	 ecx, OFFSET ?DCInfo@@3Vclassdef@@A ; DCInfo
  0006f	e8 00 00 00 00	 call	 ?GetDefPoint@classdef@@QAEHH@Z ; classdef::GetDefPoint
  00074	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR [esi+156]
  0007b	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  00082	2b d1		 sub	 edx, ecx
  00084	8d 7c 10 f9	 lea	 edi, DWORD PTR [eax+edx-7]
$LN4@gObjCheckS@3:

; 16955: 	}
; 16956: 
; 16957: 	if(g_QuestInfo.GetQuestState(lpObj,0) == 2)

  00088	6a 00		 push	 0
  0008a	56		 push	 esi
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00090	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  00095	83 f8 02	 cmp	 eax, 2
  00098	75 03		 jne	 SHORT $LN3@gObjCheckS@3

; 16958: 	{
; 16959: 		ori_point+= 10;

  0009a	83 c7 0a	 add	 edi, 10			; 0000000aH
$LN3@gObjCheckS@3:

; 16960: 	}
; 16961: 
; 16962: 	if(g_QuestInfo.GetQuestState(lpObj,1) == 2)

  0009d	6a 01		 push	 1
  0009f	56		 push	 esi
  000a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  000a5	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  000aa	83 f8 02	 cmp	 eax, 2
  000ad	75 03		 jne	 SHORT $LN2@gObjCheckS@3

; 16963: 	{
; 16964: 		ori_point+= 10;

  000af	83 c7 0a	 add	 edi, 10			; 0000000aH
$LN2@gObjCheckS@3:

; 16965: 	}
; 16966: 
; 16967: 	ori_point += gStatMng.GetMaxStat(lpObj->Level,lpObj->Class);
; 16968: 
; 16969: 	if(total_point > ori_point)

  000b2	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  000b9	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR [esi+156]
  000c0	50		 push	 eax
  000c1	51		 push	 ecx
  000c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gStatMng@@3VCStatMng@@A ; gStatMng
  000c7	e8 00 00 00 00	 call	 ?GetMaxStat@CStatMng@@QAEHHH@Z ; CStatMng::GetMaxStat
  000cc	03 c7		 add	 eax, edi
  000ce	33 d2		 xor	 edx, edx
  000d0	3b d8		 cmp	 ebx, eax
  000d2	0f 9f c2	 setg	 dl
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	8b c2		 mov	 eax, edx

; 16970: 	{
; 16971: 		return true;
; 16972: 	}
; 16973: 	return false;
; 16974: }

  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
?gObjCheckStatPointDown@@YAHH@Z ENDP			; gObjCheckStatPointDown
_TEXT	ENDS
PUBLIC	?gObjCalcMaxLifePower@@YAXH@Z			; gObjCalcMaxLifePower
; Function compile flags: /Ogtp
;	COMDAT ?gObjCalcMaxLifePower@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjCalcMaxLifePower@@YAXH@Z PROC			; gObjCalcMaxLifePower, COMDAT

; 17539: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17540: 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0000c	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17541: 
; 17542: 	switch(lpObj->Class)

  00011	0f b7 88 98 00
	00 00		 movzx	 ecx, WORD PTR [eax+152]
  00018	83 f9 04	 cmp	 ecx, 4
  0001b	77 6f		 ja	 SHORT $LN1@gObjCalcMa
  0001d	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN10@gObjCalcMa[ecx*4]
$LN5@gObjCalcMa:

; 17543: 	{
; 17544: 	case CLASS_WIZARD:
; 17545: 			lpObj->m_MaxLifePower = lpObj->Level + lpObj->Vitality + 110;

  00024	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0002b	0f bf 90 9c 00
	00 00		 movsx	 edx, WORD PTR [eax+156]
  00032	8d 4c 11 6e	 lea	 ecx, DWORD PTR [ecx+edx+110]
  00036	89 88 00 0f 00
	00		 mov	 DWORD PTR [eax+3840], ecx

; 17559: 		break;
; 17560: 	}
; 17561: }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN4@gObjCalcMa:

; 17546: 		break;
; 17547: 	case CLASS_KNIGHT:
; 17548: 			lpObj->m_MaxLifePower = lpObj->Level*2 + lpObj->Vitality + 60;

  0003e	0f bf 90 9c 00
	00 00		 movsx	 edx, WORD PTR [eax+156]
  00045	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0004c	8d 54 51 3c	 lea	 edx, DWORD PTR [ecx+edx*2+60]
  00050	89 90 00 0f 00
	00		 mov	 DWORD PTR [eax+3840], edx

; 17559: 		break;
; 17560: 	}
; 17561: }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN3@gObjCalcMa:

; 17549: 		break;
; 17550: 	case CLASS_ELF:
; 17551: 			lpObj->m_MaxLifePower = lpObj->Level + lpObj->Vitality + 80;

  00058	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0005f	0f bf 90 9c 00
	00 00		 movsx	 edx, WORD PTR [eax+156]
  00066	8d 4c 11 50	 lea	 ecx, DWORD PTR [ecx+edx+80]
  0006a	89 88 00 0f 00
	00		 mov	 DWORD PTR [eax+3840], ecx

; 17559: 		break;
; 17560: 	}
; 17561: }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
$LN2@gObjCalcMa:

; 17552: 		break;
; 17553: 	case CLASS_MAGUMSA:
; 17554: 	case CLASS_DARKLORD:
; 17555: 			lpObj->m_MaxLifePower = lpObj->Level + lpObj->Vitality + 110;

  00072	0f b7 90 b8 00
	00 00		 movzx	 edx, WORD PTR [eax+184]
  00079	0f bf 88 9c 00
	00 00		 movsx	 ecx, WORD PTR [eax+156]
  00080	8d 54 0a 6e	 lea	 edx, DWORD PTR [edx+ecx+110]
  00084	89 90 00 0f 00
	00		 mov	 DWORD PTR [eax+3840], edx

; 17559: 		break;
; 17560: 	}
; 17561: }

  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
$LN1@gObjCalcMa:

; 17556: 		break;
; 17557: 	default :
; 17558: 		lpObj->m_MaxLifePower = 0;

  0008c	c7 80 00 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3840], 0

; 17559: 		break;
; 17560: 	}
; 17561: }

  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
$LN10@gObjCalcMa:
  00098	00 00 00 00	 DD	 $LN5@gObjCalcMa
  0009c	00 00 00 00	 DD	 $LN4@gObjCalcMa
  000a0	00 00 00 00	 DD	 $LN3@gObjCalcMa
  000a4	00 00 00 00	 DD	 $LN2@gObjCalcMa
  000a8	00 00 00 00	 DD	 $LN2@gObjCalcMa
?gObjCalcMaxLifePower@@YAXH@Z ENDP			; gObjCalcMaxLifePower
_TEXT	ENDS
PUBLIC	?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z		; gObjDuelCheck
; Function compile flags: /Ogtp
;	COMDAT ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z PROC		; gObjDuelCheck, COMDAT

; 17589: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17590: 	BOOL bRetVal = FALSE;
; 17591: 
; 17592: 	if ( lpObj->Type == OBJ_USER )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	66 83 79 60 01	 cmp	 WORD PTR [ecx+96], 1
  0000d	75 20		 jne	 SHORT $LN1@gObjDuelCh

; 17593: 	{
; 17594: 		int iDuelIndex = lpObj->m_iDuelUser;

  0000f	8b 89 1c 0d 00
	00		 mov	 ecx, DWORD PTR [ecx+3356]

; 17595: 		if (  OBJMAX_RANGE(iDuelIndex) )

  00015	85 c9		 test	 ecx, ecx
  00017	78 16		 js	 SHORT $LN1@gObjDuelCh
  00019	33 d2		 xor	 edx, edx
  0001b	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  00021	0f 9e c2	 setle	 dl
  00024	8b ca		 mov	 ecx, edx
  00026	85 c9		 test	 ecx, ecx
  00028	74 05		 je	 SHORT $LN1@gObjDuelCh

; 17596: 		{
; 17597: 			bRetVal = TRUE;

  0002a	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjDuelCh:

; 17598: 		}
; 17599: 	}
; 17600: 
; 17601: 	return bRetVal;
; 17602: }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; gObjDuelCheck
_TEXT	ENDS
PUBLIC	?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z		; gObjDuelCheck
; Function compile flags: /Ogtp
;	COMDAT ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z PROC		; gObjDuelCheck, COMDAT

; 17605: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17606: 	BOOL bRetVal = FALSE;
; 17607: 
; 17608: 	if ( lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_USER)

  00003	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	66 83 7a 60 01	 cmp	 WORD PTR [edx+96], 1
  0000d	75 25		 jne	 SHORT $LN1@gObjDuelCh@2
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00012	66 83 79 60 01	 cmp	 WORD PTR [ecx+96], 1
  00017	75 1b		 jne	 SHORT $LN1@gObjDuelCh@2

; 17609: 	{
; 17610: 		if ( lpObj->m_iDuelUser == lpTargetObj->m_Index && lpTargetObj->m_iDuelUser == lpObj->m_Index)

  00019	57		 push	 edi
  0001a	8b ba 1c 0d 00
	00		 mov	 edi, DWORD PTR [edx+3356]
  00020	3b 39		 cmp	 edi, DWORD PTR [ecx]
  00022	5f		 pop	 edi
  00023	75 0f		 jne	 SHORT $LN1@gObjDuelCh@2
  00025	8b 89 1c 0d 00
	00		 mov	 ecx, DWORD PTR [ecx+3356]
  0002b	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0002d	75 05		 jne	 SHORT $LN1@gObjDuelCh@2

; 17611: 		{
; 17612: 			bRetVal = TRUE;

  0002f	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjDuelCh@2:

; 17613: 		}
; 17614: 	}
; 17615: 
; 17616: 	return bRetVal;
; 17617: 
; 17618: }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z ENDP		; gObjDuelCheck
_TEXT	ENDS
PUBLIC	?gObjResetDuel@@YAXPAUOBJECTSTRUCT@@@Z		; gObjResetDuel
EXTRN	?ReSetTarget@CDarkSpirit@@QAEXH@Z:PROC		; CDarkSpirit::ReSetTarget
EXTRN	?gDarkSpirit@@3PAVCDarkSpirit@@A:BYTE		; gDarkSpirit
; Function compile flags: /Ogtp
;	COMDAT ?gObjResetDuel@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjResetDuel@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjResetDuel, COMDAT

; 17621: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 17622: 	int iDuelIndex = lpObj->m_iDuelUser;

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	57		 push	 edi
  00008	8b be 1c 0d 00
	00		 mov	 edi, DWORD PTR [esi+3356]

; 17623: 
; 17624: 	if ( OBJMAX_RANGE(iDuelIndex))

  0000e	85 ff		 test	 edi, edi
  00010	78 79		 js	 SHORT $LN1@gObjResetD
  00012	33 c0		 xor	 eax, eax
  00014	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	74 6a		 je	 SHORT $LN1@gObjResetD

; 17625: 	{
; 17626: 		lpObj->m_iDuelUser = -1;
; 17627: 		lpObj->m_iDuelUserReserved = -1;
; 17628: 		lpObj->m_btDuelScore = 0;
; 17629: 		lpObj->m_iDuelTickCount = 0;
; 17630: 		gDarkSpirit[lpObj->m_Index].ReSetTarget(iDuelIndex);

  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	53		 push	 ebx
  00024	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00027	83 cb ff	 or	 ebx, -1
  0002a	57		 push	 edi
  0002b	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gDarkSpirit@@3PAVCDarkSpirit@@A[ecx*8]
  00032	89 9e 1c 0d 00
	00		 mov	 DWORD PTR [esi+3356], ebx
  00038	89 9e 14 0d 00
	00		 mov	 DWORD PTR [esi+3348], ebx
  0003e	c6 86 20 0d 00
	00 00		 mov	 BYTE PTR [esi+3360], 0
  00045	c7 86 24 0d 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3364], 0
  0004f	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget

; 17631: 		gDarkSpirit[iDuelIndex].ReSetTarget(lpObj->m_Index);

  00054	8b 06		 mov	 eax, DWORD PTR [esi]
  00056	8d 0c bf	 lea	 ecx, DWORD PTR [edi+edi*4]
  00059	50		 push	 eax
  0005a	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gDarkSpirit@@3PAVCDarkSpirit@@A[ecx*8]
  00061	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget

; 17632: 		gObj[iDuelIndex].m_iDuelUser = -1;

  00066	8b c7		 mov	 eax, edi
  00068	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0006e	89 98 1c 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3356], ebx

; 17633: 		gObj[iDuelIndex].m_iDuelUserReserved = -1;

  00074	89 98 14 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3348], ebx

; 17634: 		gObj[iDuelIndex].m_iDuelUserRequested = -1;

  0007a	89 98 18 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3352], ebx

; 17635: 		gObj[iDuelIndex].m_iDuelTickCount = 0;

  00080	c7 80 24 0d 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3364], 0
  0008a	5b		 pop	 ebx
$LN1@gObjResetD:
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi

; 17636: 	}
; 17637: }

  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?gObjResetDuel@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjResetDuel
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjSendDuelEnd@@YAXPAUOBJECTSTRUCT@@@Z	; gObjSendDuelEnd
; Function compile flags: /Ogtp
;	COMDAT ?gObjSendDuelEnd@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 15
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjSendDuelEnd@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjSendDuelEnd, COMDAT

; 17640: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]

; 17641: 	PMSG_ANS_END_DUEL pMsg;
; 17642: 	if(gObjIsConnected(lpObj->m_Index)==0)

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001b	83 c4 04	 add	 esp, 4
  0001e	85 c0		 test	 eax, eax
  00020	74 75		 je	 SHORT $LN4@gObjSendDu

; 17643: 	{
; 17644: 		return;
; 17645: 	}
; 17646: 
; 17647: 	if(lpObj->Type == OBJ_MONSTER)

  00022	66 83 79 60 02	 cmp	 WORD PTR [ecx+96], 2
  00027	74 6e		 je	 SHORT $LN4@gObjSendDu

; 17648: 	{
; 17649: 		return;
; 17650: 	}
; 17651: 
; 17652: 	if(lpObj->CloseCount >= 0)

  00029	80 79 07 00	 cmp	 BYTE PTR [ecx+7], 0
  0002d	7d 68		 jge	 SHORT $LN4@gObjSendDu

; 17653: 	{
; 17654: 		return;
; 17655: 	}
; 17656: 
; 17657: 	lpObj->m_iDuelUser = -1;

  0002f	83 c8 ff	 or	 eax, -1
  00032	89 81 1c 0d 00
	00		 mov	 DWORD PTR [ecx+3356], eax

; 17658: 	lpObj->m_iDuelUserReserved = -1;

  00038	89 81 14 0d 00
	00		 mov	 DWORD PTR [ecx+3348], eax

; 17659: 	lpObj->m_iDuelUserRequested = -1;

  0003e	89 81 18 0d 00
	00		 mov	 DWORD PTR [ecx+3352], eax

; 17660: 	lpObj->m_btDuelScore = 0;

  00044	c6 81 20 0d 00
	00 00		 mov	 BYTE PTR [ecx+3360], 0

; 17661: 	lpObj->m_iDuelTickCount = 0;

  0004b	c7 81 24 0d 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+3364], 0

; 17662: 
; 17663: 	pMsg.h.c = 0xC1;
; 17664: 	pMsg.h.headcode = 0xAB;
; 17665: 	pMsg.h.size = sizeof(pMsg);
; 17666: 
; 17667: 	pMsg.NumberH = SET_NUMBERH(lpObj->m_iDuelUser);
; 17668: 	pMsg.NumberL = SET_NUMBERL(lpObj->m_iDuelUser);

  00055	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 17669: 
; 17670: 	memcpy(pMsg.szName,gObj[lpObj->m_iDuelUser].Name,10);

  00058	b8 6f 00 00 00	 mov	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+111
  0005d	8b 88 9c ea ff
	ff		 mov	 ecx, DWORD PTR [eax-5476]
  00063	89 4d f1	 mov	 DWORD PTR _pMsg$[ebp+5], ecx
  00066	8b 88 a0 ea ff
	ff		 mov	 ecx, DWORD PTR [eax-5472]
  0006c	66 8b 80 a4 ea
	ff ff		 mov	 ax, WORD PTR [eax-5468]
  00073	89 4d f5	 mov	 DWORD PTR _pMsg$[ebp+9], ecx

; 17671: 	DataSend(lpObj->m_Index,(unsigned char *)&pMsg,pMsg.h.size);

  00076	6a 0f		 push	 15			; 0000000fH
  00078	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0007b	51		 push	 ecx
  0007c	52		 push	 edx
  0007d	c6 45 ec c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H
  00081	66 c7 45 ed 0f
	ab		 mov	 WORD PTR _pMsg$[ebp+1], 43791 ; 0000ab0fH
  00087	c6 45 ef ff	 mov	 BYTE PTR _pMsg$[ebp+3], 255 ; 000000ffH
  0008b	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+13], ax
  0008f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@gObjSendDu:

; 17672: }

  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	33 cd		 xor	 ecx, ebp
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?gObjSendDuelEnd@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjSendDuelEnd
_TEXT	ENDS
PUBLIC	?gObjCheckAllUserDuelStop@@YAXXZ		; gObjCheckAllUserDuelStop
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckAllUserDuelStop@@YAXXZ
_TEXT	SEGMENT
?gObjCheckAllUserDuelStop@@YAXXZ PROC			; gObjCheckAllUserDuelStop, COMDAT

; 17675: {

  00000	53		 push	 ebx

; 17676: 	for(int i = OBJ_STARTUSERINDEX; i < OBJMAX; i++)

  00001	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	be 1c d1 16 02	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35049756
  0000e	8b ff		 npad	 2
$LL7@gObjCheckA@3:

; 17677: 	{
; 17678: 		if(gObj[i].Connected == PLAYER_PLAYING)

  00010	80 be e8 f2 ff
	ff 03		 cmp	 BYTE PTR [esi-3352], 3
  00017	75 55		 jne	 SHORT $LN6@gObjCheckA@3

; 17679: 		{
; 17680: 			if(gObj[i].Type == OBJ_USER)

  00019	66 83 be 44 f3
	ff ff 01	 cmp	 WORD PTR [esi-3260], 1
  00021	75 4b		 jne	 SHORT $LN6@gObjCheckA@3

; 17681: 			{
; 17682: 				if(OBJMAX_RANGE(gObj[i].m_iDuelUser))

  00023	8b 06		 mov	 eax, DWORD PTR [esi]
  00025	85 c0		 test	 eax, eax
  00027	78 45		 js	 SHORT $LN6@gObjCheckA@3
  00029	33 c9		 xor	 ecx, ecx
  0002b	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00030	0f 9e c1	 setle	 cl
  00033	8b c1		 mov	 eax, ecx
  00035	85 c0		 test	 eax, eax
  00037	74 35		 je	 SHORT $LN6@gObjCheckA@3

; 17683: 				{
; 17684: 					if(GetTickCount() - gObj[i].m_iDuelTickCount > 60000)

  00039	ff d3		 call	 ebx
  0003b	2b 46 08	 sub	 eax, DWORD PTR [esi+8]
  0003e	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  00043	76 29		 jbe	 SHORT $LN6@gObjCheckA@3

; 17685: 					{
; 17686: 						gObjSendDuelEnd(&gObj[gObj[i].m_iDuelUser]);

  00045	8b 16		 mov	 edx, DWORD PTR [esi]
  00047	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  0004d	81 c2 00 00 00
	00		 add	 edx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 ?gObjSendDuelEnd@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSendDuelEnd

; 17687: 						gObjSendDuelEnd(&gObj[i]);

  00059	8d be e4 f2 ff
	ff		 lea	 edi, DWORD PTR [esi-3356]
  0005f	57		 push	 edi
  00060	e8 00 00 00 00	 call	 ?gObjSendDuelEnd@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSendDuelEnd

; 17688: 						gObjResetDuel(&gObj[i]);

  00065	57		 push	 edi
  00066	e8 00 00 00 00	 call	 ?gObjResetDuel@@YAXPAUOBJECTSTRUCT@@@Z ; gObjResetDuel
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@gObjCheckA@3:

; 17676: 	for(int i = OBJ_STARTUSERINDEX; i < OBJMAX; i++)

  0006e	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  00074	81 fe bc 5f 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40525756
  0007a	7c 94		 jl	 SHORT $LL7@gObjCheckA@3

; 17689: 					}
; 17690: 				}
; 17691: 			}
; 17692: 		}
; 17693: 	}
; 17694: }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	c3		 ret	 0
?gObjCheckAllUserDuelStop@@YAXXZ ENDP			; gObjCheckAllUserDuelStop
_TEXT	ENDS
PUBLIC	__real@bf800000
PUBLIC	__real@40c00000
PUBLIC	__real@c0c00000
PUBLIC	__$ArrayPad$
PUBLIC	?SkillFrustrum@@YAXEH@Z				; SkillFrustrum
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@c0c00000
CONST	SEGMENT
__real@c0c00000 DD 0c0c00000r			; -6
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SkillFrustrum@@YAXEH@Z
_TEXT	SEGMENT
tv309 = -168						; size = 4
_lpObj$ = -164						; size = 4
_Matrix$ = -160						; size = 48
_vFrustrum$ = -112					; size = 48
_p$ = -64						; size = 48
_Angle$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_bangle$ = 8						; size = 1
_aIndex$ = 12						; size = 4
?SkillFrustrum@@YAXEH@Z PROC				; SkillFrustrum, COMDAT

; 17757: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 17758: 	LPOBJ lpObj = &gObj[aIndex];
; 17759: 
; 17760: 	float p[MAX_ARRAY_FRUSTRUM][3];
; 17761: 
; 17762: 	p[0][0] = -6;
; 17763: 	p[0][1] = 6;
; 17764: 	p[0][2] = 0;
; 17765: 	p[1][0] = 6;
; 17766: 	p[1][1] = 6;
; 17767: 	p[1][2] = 0;
; 17768: 	p[2][0] = 1;
; 17769: 	p[2][1] = 0;
; 17770: 	p[2][2] = 0;
; 17771: 	p[3][0] = -1;
; 17772: 	p[3][1] = 0;
; 17773: 	p[3][2] = 0;
; 17774: 
; 17775: 	float Angle[0x3];
; 17776: 
; 17777: 	Angle[0] = 0;
; 17778: 	Angle[1] = 0;
; 17779: 	Angle[2] = bangle * 360 / 255;

  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	0f b6 4d 08	 movzx	 ecx, BYTE PTR _bangle$[ebp]
  0001a	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c0c00000
  00020	d9 5d c0	 fstp	 DWORD PTR _p$[ebp]
  00023	69 c9 68 01 00
	00		 imul	 ecx, 360		; 00000168H
  00029	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40c00000
  0002f	d9 55 c4	 fst	 DWORD PTR _p$[ebp+4]
  00032	d9 ee		 fldz
  00034	d9 55 c8	 fst	 DWORD PTR _p$[ebp+8]
  00037	d9 55 d4	 fst	 DWORD PTR _p$[ebp+20]
  0003a	d9 c9		 fxch	 ST(1)
  0003c	d9 55 cc	 fst	 DWORD PTR _p$[ebp+12]
  0003f	d9 5d d0	 fstp	 DWORD PTR _p$[ebp+16]
  00042	d9 e8		 fld1
  00044	b8 81 80 80 80	 mov	 eax, -2139062143	; 80808081H
  00049	d9 5d d8	 fstp	 DWORD PTR _p$[ebp+24]
  0004c	f7 e9		 imul	 ecx
  0004e	d9 55 dc	 fst	 DWORD PTR _p$[ebp+28]
  00051	d9 55 e0	 fst	 DWORD PTR _p$[ebp+32]
  00054	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@bf800000
  0005a	d9 5d e4	 fstp	 DWORD PTR _p$[ebp+36]
  0005d	d9 55 e8	 fst	 DWORD PTR _p$[ebp+40]
  00060	d9 55 ec	 fst	 DWORD PTR _p$[ebp+44]
  00063	d9 55 f0	 fst	 DWORD PTR _Angle$[ebp]
  00066	d9 5d f4	 fstp	 DWORD PTR _Angle$[ebp+4]
  00069	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0006c	03 d1		 add	 edx, ecx
  0006e	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00074	c1 fa 07	 sar	 edx, 7
  00077	8b c2		 mov	 eax, edx
  00079	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0007c	03 c2		 add	 eax, edx
  0007e	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv309[ebp], eax

; 17780: 
; 17781: 	float Matrix[3][MAX_ARRAY_FRUSTRUM];
; 17782: 
; 17783: 	AngleMatrix(Angle,Matrix);

  00084	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _Matrix$[ebp]
  0008a	51		 push	 ecx
  0008b	db 85 58 ff ff
	ff		 fild	 DWORD PTR tv309[ebp]
  00091	8d 55 f0	 lea	 edx, DWORD PTR _Angle$[ebp]
  00094	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009a	52		 push	 edx
  0009b	d9 5d f8	 fstp	 DWORD PTR _Angle$[ebp+8]
  0009e	89 bd 5c ff ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], edi
  000a4	e8 00 00 00 00	 call	 ?AngleMatrix@@YAXPBMPAY03M@Z ; AngleMatrix
  000a9	83 c4 08	 add	 esp, 8

; 17790: 
; 17791: 		lpObj->fSkillFrustrumX[i] = (int)vFrustrum[i][0] + lpObj->X;

  000ac	81 c7 40 0f 00
	00		 add	 edi, 3904		; 00000f40H
  000b2	33 f6		 xor	 esi, esi
$LL3@SkillFrust:

; 17784: 
; 17785: 	float vFrustrum[MAX_ARRAY_FRUSTRUM][3];
; 17786: 
; 17787: 	for(int i = 0; i < MAX_ARRAY_FRUSTRUM; i++)
; 17788: 	{
; 17789: 		VectorRotate((const float *)&p[i],(const float *)&Matrix[0],(float *)&vFrustrum[i]);

  000b4	8d 5c 35 90	 lea	 ebx, DWORD PTR _vFrustrum$[ebp+esi]
  000b8	53		 push	 ebx
  000b9	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _Matrix$[ebp]
  000bf	50		 push	 eax
  000c0	8d 4c 35 c0	 lea	 ecx, DWORD PTR _p$[ebp+esi]
  000c4	51		 push	 ecx
  000c5	e8 00 00 00 00	 call	 ?VectorRotate@@YAXQBM0QAM@Z ; VectorRotate

; 17790: 
; 17791: 		lpObj->fSkillFrustrumX[i] = (int)vFrustrum[i][0] + lpObj->X;

  000ca	d9 03		 fld	 DWORD PTR [ebx]
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cf	e8 00 00 00 00	 call	 __ftol2_sse

; 17792: 		lpObj->fSkillFrustrumY[i] = (int)vFrustrum[i][1] + lpObj->Y;

  000d4	d9 44 35 94	 fld	 DWORD PTR _vFrustrum$[ebp+esi+4]
  000d8	8b 9d 5c ff ff
	ff		 mov	 ebx, DWORD PTR _lpObj$[ebp]
  000de	0f bf 93 04 01
	00 00		 movsx	 edx, WORD PTR [ebx+260]
  000e5	03 c2		 add	 eax, edx
  000e7	89 47 f0	 mov	 DWORD PTR [edi-16], eax
  000ea	e8 00 00 00 00	 call	 __ftol2_sse
  000ef	0f bf 8b 06 01
	00 00		 movsx	 ecx, WORD PTR [ebx+262]
  000f6	03 c1		 add	 eax, ecx
  000f8	89 07		 mov	 DWORD PTR [edi], eax
  000fa	83 c6 0c	 add	 esi, 12			; 0000000cH
  000fd	83 c7 04	 add	 edi, 4
  00100	83 fe 30	 cmp	 esi, 48			; 00000030H
  00103	7c af		 jl	 SHORT $LL3@SkillFrust

; 17793: 	}
; 17794: }

  00105	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	33 cd		 xor	 ecx, ebp
  0010c	5b		 pop	 ebx
  0010d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c3		 ret	 0
?SkillFrustrum@@YAXEH@Z ENDP				; SkillFrustrum
_TEXT	ENDS
PUBLIC	?SkillTestFrustrum@@YAHHHH@Z			; SkillTestFrustrum
; Function compile flags: /Ogtp
;	COMDAT ?SkillTestFrustrum@@YAHHHH@Z
_TEXT	SEGMENT
tv310 = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
tv318 = 16						; size = 4
_aIndex$ = 16						; size = 4
?SkillTestFrustrum@@YAHHHH@Z PROC			; SkillTestFrustrum, COMDAT

; 17797: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 17798: 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 55 10	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00007	d9 ee		 fldz
  00009	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	81 c2 00 00 00
	00		 add	 edx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17799: 
; 17800: 	int j = 3;
; 17801: 
; 17802: 	for(int i = 0; i < MAX_ARRAY_FRUSTRUM; j = i,i++)

  00018	33 f6		 xor	 esi, esi
  0001a	bf d0 f0 ff ff	 mov	 edi, -3888		; fffff0d0H
  0001f	2b fa		 sub	 edi, edx
  00021	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00024	8d 8a 30 0f 00
	00		 lea	 ecx, DWORD PTR [edx+3888]
  0002a	89 7d fc	 mov	 DWORD PTR tv310[ebp], edi
$LN10@SkillTestF:

; 17803: 	{
; 17804: 		if((lpObj->fSkillFrustrumX[i]- x) * (lpObj->fSkillFrustrumY[j]-y) - (lpObj->fSkillFrustrumX[j]-x) * (lpObj->fSkillFrustrumY[i]-y) < 0.0f)

  0002d	8b bc 10 30 0f
	00 00		 mov	 edi, DWORD PTR [eax+edx+3888]
  00034	8b 59 10	 mov	 ebx, DWORD PTR [ecx+16]
  00037	2b 5d 0c	 sub	 ebx, DWORD PTR _y$[ebp]
  0003a	2b 7d 08	 sub	 edi, DWORD PTR _x$[ebp]
  0003d	8b 84 10 40 0f
	00 00		 mov	 eax, DWORD PTR [eax+edx+3904]
  00044	2b 45 0c	 sub	 eax, DWORD PTR _y$[ebp]
  00047	0f af fb	 imul	 edi, ebx
  0004a	8b 19		 mov	 ebx, DWORD PTR [ecx]
  0004c	2b 5d 08	 sub	 ebx, DWORD PTR _x$[ebp]
  0004f	0f af c3	 imul	 eax, ebx
  00052	2b c7		 sub	 eax, edi
  00054	89 45 10	 mov	 DWORD PTR tv318[ebp], eax
  00057	db 45 10	 fild	 DWORD PTR tv318[ebp]
  0005a	d8 d9		 fcomp	 ST(1)
  0005c	df e0		 fnstsw	 ax
  0005e	f6 c4 05	 test	 ah, 5
  00061	7b 1c		 jnp	 SHORT $LN13@SkillTestF

; 17799: 
; 17800: 	int j = 3;
; 17801: 
; 17802: 	for(int i = 0; i < MAX_ARRAY_FRUSTRUM; j = i,i++)

  00063	8b 45 fc	 mov	 eax, DWORD PTR tv310[ebp]
  00066	03 c1		 add	 eax, ecx
  00068	46		 inc	 esi
  00069	83 c1 04	 add	 ecx, 4
  0006c	83 fe 04	 cmp	 esi, 4
  0006f	7c bc		 jl	 SHORT $LN10@SkillTestF
  00071	5f		 pop	 edi
  00072	dd d8		 fstp	 ST(0)
  00074	5e		 pop	 esi

; 17807: 		}
; 17808: 	}
; 17809: 	return true;

  00075	b8 01 00 00 00	 mov	 eax, 1
  0007a	5b		 pop	 ebx

; 17810: }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
$LN13@SkillTestF:
  0007f	5f		 pop	 edi

; 17803: 	{
; 17804: 		if((lpObj->fSkillFrustrumX[i]- x) * (lpObj->fSkillFrustrumY[j]-y) - (lpObj->fSkillFrustrumX[j]-x) * (lpObj->fSkillFrustrumY[i]-y) < 0.0f)

  00080	dd d8		 fstp	 ST(0)
  00082	5e		 pop	 esi

; 17805: 		{
; 17806: 			return false;

  00083	33 c0		 xor	 eax, eax
  00085	5b		 pop	 ebx

; 17810: }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?SkillTestFrustrum@@YAHHHH@Z ENDP			; SkillTestFrustrum
_TEXT	ENDS
PUBLIC	?gObjCheckMaxZen@@YAHHH@Z			; gObjCheckMaxZen
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckMaxZen@@YAHHH@Z
_TEXT	SEGMENT
tv70 = -8						; size = 8
_aIndex$ = 8						; size = 4
_nAddZen$ = 12						; size = 4
?gObjCheckMaxZen@@YAHHH@Z PROC				; gObjCheckMaxZen, COMDAT

; 17813: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17814: 	if ( !OBJMAX_RANGE(aIndex) )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c9		 test	 ecx, ecx
  0000b	78 0f		 js	 SHORT $LN7@gObjCheckM
  0000d	33 c0		 xor	 eax, eax
  0000f	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  00015	0f 9e c0	 setle	 al
  00018	85 c0		 test	 eax, eax
  0001a	75 06		 jne	 SHORT $LN2@gObjCheckM
$LN7@gObjCheckM:

; 17815: 		return FALSE;

  0001c	33 c0		 xor	 eax, eax

; 17829: }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$LN2@gObjCheckM:

; 17816: 
; 17817: 	LPOBJ lpObj = &gObj[aIndex];

  00022	8b c1		 mov	 eax, ecx
  00024	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 17818: 	
; 17819: 	__int64 _Money = 0;
; 17820: 	_Money = (__int64)lpObj->Money + (__int64)nAddZen;
; 17821: 
; 17822: 	if ( _Money > (__int64)MAX_ZEN )

  0002a	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+176]
  00030	99		 cdq
  00031	56		 push	 esi
  00032	8b f0		 mov	 esi, eax
  00034	8b 45 0c	 mov	 eax, DWORD PTR _nAddZen$[ebp]
  00037	57		 push	 edi
  00038	8b fa		 mov	 edi, edx
  0003a	99		 cdq
  0003b	03 f0		 add	 esi, eax
  0003d	13 fa		 adc	 edi, edx
  0003f	89 7d fc	 mov	 DWORD PTR tv70[ebp+4], edi
  00042	78 2d		 js	 SHORT $LN1@gObjCheckM
  00044	7f 08		 jg	 SHORT $LN8@gObjCheckM
  00046	81 fe 00 94 35
	77		 cmp	 esi, 2000000000		; 77359400H
  0004c	76 23		 jbe	 SHORT $LN1@gObjCheckM
$LN8@gObjCheckM:

; 17823: 	{
; 17824: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 226)), aIndex, 1);

  0004e	6a 01		 push	 1
  00050	51		 push	 ecx
  00051	68 e2 04 00 00	 push	 1250			; 000004e2H
  00056	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0005b	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	5f		 pop	 edi

; 17825: 		return FALSE;

  0006a	33 c0		 xor	 eax, eax
  0006c	5e		 pop	 esi

; 17829: }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN1@gObjCheckM:
  00071	5f		 pop	 edi

; 17826: 	}
; 17827: 
; 17828: 	return TRUE;

  00072	b8 01 00 00 00	 mov	 eax, 1
  00077	5e		 pop	 esi

; 17829: }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?gObjCheckMaxZen@@YAHHH@Z ENDP				; gObjCheckMaxZen
_TEXT	ENDS
PUBLIC	??_C@_0GF@BPBLCLPB@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Winner?5S@ ; `string'
PUBLIC	?MakeRandomSetItem@@YAXH@Z			; MakeRandomSetItem
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?GenSetOption@CSetItemOption@@QAEHH@Z:PROC	; CSetItemOption::GenSetOption
EXTRN	?GenRandomItemNum@CSetItemOption@@QAEHXZ:PROC	; CSetItemOption::GenRandomItemNum
EXTRN	?gSetItemOption@@3VCSetItemOption@@A:BYTE	; gSetItemOption
;	COMDAT ??_C@_0GF@BPBLCLPB@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Winner?5S@
CONST	SEGMENT
??_C@_0GF@BPBLCLPB@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Winner?5S@ DB '['
	DB	'Chaos Castle] [%s][%s] Winner Set Item itemnum:[%d] skill:[%d'
	DB	'] luck:[%d] option:[%d] SetOption:[%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?MakeRandomSetItem@@YAXH@Z
_TEXT	SEGMENT
_SetOption$ = -12					; size = 4
_Option2$ = -8						; size = 4
_option3rand$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?MakeRandomSetItem@@YAXH@Z PROC				; MakeRandomSetItem, COMDAT

; 17832: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 17833: 	int itemnum = gSetItemOption.GenRandomItemNum();

  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  0000e	e8 00 00 00 00	 call	 ?GenRandomItemNum@CSetItemOption@@QAEHXZ ; CSetItemOption::GenRandomItemNum
  00013	8b f8		 mov	 edi, eax

; 17834: 
; 17835: 	int SetOption = gSetItemOption.GenSetOption(itemnum);

  00015	57		 push	 edi
  00016	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  0001b	e8 00 00 00 00	 call	 ?GenSetOption@CSetItemOption@@QAEHH@Z ; CSetItemOption::GenSetOption

; 17836: 
; 17837: 	int option1rand;
; 17838: 	int option2rand;
; 17839: 	int option3rand;
; 17840: 	int optionc;
; 17841: 	int Option1 = 0;
; 17842: 	int Option2 = 0;

  00020	33 db		 xor	 ebx, ebx
  00022	89 45 f4	 mov	 DWORD PTR _SetOption$[ebp], eax
  00025	89 5d f8	 mov	 DWORD PTR _Option2$[ebp], ebx

; 17843: 	int Option3 = 0;
; 17844: 
; 17845: 	option1rand = 6;
; 17846: 	option2rand = 4;
; 17847: 
; 17848: 	option3rand = rand()%100;

  00028	e8 00 00 00 00	 call	 _rand
  0002d	99		 cdq
  0002e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00033	f7 f9		 idiv	 ecx
  00035	89 55 fc	 mov	 DWORD PTR _option3rand$[ebp], edx

; 17849: 	optionc = rand()%3;

  00038	e8 00 00 00 00	 call	 _rand
  0003d	99		 cdq
  0003e	b9 03 00 00 00	 mov	 ecx, 3
  00043	f7 f9		 idiv	 ecx
  00045	8b f2		 mov	 esi, edx

; 17850: 
; 17851: 	if(rand()%100 < option2rand)

  00047	e8 00 00 00 00	 call	 _rand
  0004c	99		 cdq
  0004d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00052	f7 f9		 idiv	 ecx
  00054	83 fa 04	 cmp	 edx, 4
  00057	7d 07		 jge	 SHORT $LN13@MakeRandom

; 17852: 	{
; 17853: 		Option2 = 1;

  00059	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 1
$LN13@MakeRandom:

; 17854: 	}
; 17855: 
; 17856: 	switch(optionc)

  00060	2b f3		 sub	 esi, ebx
  00062	74 1e		 je	 SHORT $LN7@MakeRandom
  00064	4e		 dec	 esi
  00065	74 0e		 je	 SHORT $LN5@MakeRandom
  00067	4e		 dec	 esi
  00068	75 23		 jne	 SHORT $LN14@MakeRandom

; 17870: 	case 2: 
; 17871: 		if(option3rand < 12)

  0006a	83 7d fc 0c	 cmp	 DWORD PTR _option3rand$[ebp], 12 ; 0000000cH
  0006e	7d 1d		 jge	 SHORT $LN14@MakeRandom

; 17872: 		{
; 17873: 			Option3 = 1;

  00070	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]

; 17874: 		}
; 17875: 		break;

  00073	eb 18		 jmp	 SHORT $LN14@MakeRandom
$LN5@MakeRandom:

; 17862: 		}
; 17863: 		break;
; 17864: 	case 1:
; 17865: 		if(option3rand < 8)

  00075	83 7d fc 08	 cmp	 DWORD PTR _option3rand$[ebp], 8
  00079	7d 12		 jge	 SHORT $LN14@MakeRandom

; 17866: 		{
; 17867: 			Option3 = 2;

  0007b	bb 02 00 00 00	 mov	 ebx, 2

; 17868: 		}
; 17869: 		break;

  00080	eb 0b		 jmp	 SHORT $LN14@MakeRandom
$LN7@MakeRandom:

; 17857: 	{
; 17858: 	case 0: 
; 17859: 		if(option3rand < 4)

  00082	83 7d fc 04	 cmp	 DWORD PTR _option3rand$[ebp], 4
  00086	7d 05		 jge	 SHORT $LN14@MakeRandom

; 17860: 		{
; 17861: 			Option3 = 3;

  00088	bb 03 00 00 00	 mov	 ebx, 3
$LN14@MakeRandom:

; 17876: 	default: break;
; 17877: 	}
; 17878: 
; 17879: 	Option1 = 1;
; 17880: 
; 17881: 	ItemSerialCreateSend(aIndex,gObj[aIndex].MapNumber,gObj[aIndex].X,gObj[aIndex].Y,itemnum,0,0,Option1,Option2,Option3,aIndex,0,SetOption);

  0008d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00090	8b 55 f4	 mov	 edx, DWORD PTR _SetOption$[ebp]
  00093	8b 4d f8	 mov	 ecx, DWORD PTR _Option2$[ebp]
  00096	52		 push	 edx
  00097	6a 00		 push	 0
  00099	50		 push	 eax
  0009a	53		 push	 ebx
  0009b	51		 push	 ecx
  0009c	8b f0		 mov	 esi, eax
  0009e	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000a4	0f b6 96 06 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  000ab	0f b6 8e 04 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  000b2	6a 01		 push	 1
  000b4	6a 00		 push	 0
  000b6	6a 00		 push	 0
  000b8	57		 push	 edi
  000b9	52		 push	 edx
  000ba	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]
  000c1	51		 push	 ecx
  000c2	52		 push	 edx
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 17882: 	LogAdd(LOG_BLACK, "[Chaos Castle] [%s][%s] Winner Set Item itemnum:[%d] skill:[%d] luck:[%d] option:[%d] SetOption:[%d]",gObj[aIndex].AccountID,gObj[aIndex].Name,
; 17883: 		itemnum,Option1,Option2,Option3,SetOption);

  000c9	8b 45 f4	 mov	 eax, DWORD PTR _SetOption$[ebp]
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _Option2$[ebp]
  000cf	50		 push	 eax
  000d0	53		 push	 ebx
  000d1	51		 push	 ecx
  000d2	6a 01		 push	 1
  000d4	57		 push	 edi
  000d5	8d 96 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  000db	52		 push	 edx
  000dc	8d 86 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  000e2	50		 push	 eax
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0GF@BPBLCLPB@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Winner?5S@
  000e8	6a 00		 push	 0
  000ea	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000ef	83 c4 58	 add	 esp, 88			; 00000058H
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx

; 17884: }

  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
?MakeRandomSetItem@@YAXH@Z ENDP				; MakeRandomSetItem
_TEXT	ENDS
PUBLIC	??_C@_0FN@IPFPLKOM@?$FLReward?$FN?$FLEtc?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5Item?5@ ; `string'
PUBLIC	??_C@_0GE@HKPKGOEM@?$FL?$KB?Z?$KB?YReward?$FN?$FLKUNDUN?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Se@ ; `string'
PUBLIC	?MakeRewardSetItem@@YAXHEEHH@Z			; MakeRewardSetItem
;	COMDAT ??_C@_0FN@IPFPLKOM@?$FLReward?$FN?$FLEtc?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5Item?5@
CONST	SEGMENT
??_C@_0FN@IPFPLKOM@?$FLReward?$FN?$FLEtc?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5Item?5@ DB '['
	DB	'Reward][Etc] [%s][%s] Set Item itemnum:[%d] skill:[%d] luck:['
	DB	'%d] option:[%d] SetOption:[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@HKPKGOEM@?$FL?$KB?Z?$KB?YReward?$FN?$FLKUNDUN?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Se@
CONST	SEGMENT
??_C@_0GE@HKPKGOEM@?$FL?$KB?Z?$KB?YReward?$FN?$FLKUNDUN?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Se@ DB '['
	DB	0a1H, 0daH, 0a1H, 0d9H, 'Reward][KUNDUN] [%s][%s] Set Item ite'
	DB	'mnum:[%d] skill:[%d] luck:[%d] option:[%d] SetOption:[%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?MakeRewardSetItem@@YAXHEEHH@Z
_TEXT	SEGMENT
_SetOption$ = -12					; size = 4
_option3rand$ = -8					; size = 4
_Option2$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_cDropX$ = 12						; size = 1
_cDropY$ = 16						; size = 1
_iRewardType$ = 20					; size = 4
_iMapnumber$ = 24					; size = 4
?MakeRewardSetItem@@YAXHEEHH@Z PROC			; MakeRewardSetItem, COMDAT

; 17892: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 17893: 	int itemnum = gSetItemOption.GenRandomItemNum();

  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  0000e	e8 00 00 00 00	 call	 ?GenRandomItemNum@CSetItemOption@@QAEHXZ ; CSetItemOption::GenRandomItemNum
  00013	8b f0		 mov	 esi, eax

; 17894: 
; 17895: 	int SetOption = gSetItemOption.GenSetOption(itemnum);

  00015	56		 push	 esi
  00016	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  0001b	e8 00 00 00 00	 call	 ?GenSetOption@CSetItemOption@@QAEHH@Z ; CSetItemOption::GenSetOption

; 17896: 
; 17897: 	int option1rand;
; 17898: 	int option2rand;
; 17899: 	int option3rand;
; 17900: 	int optionc;
; 17901: 	int Option1 = 0;
; 17902: 	int Option2 = 0;

  00020	33 db		 xor	 ebx, ebx
  00022	89 45 f4	 mov	 DWORD PTR _SetOption$[ebp], eax
  00025	89 5d fc	 mov	 DWORD PTR _Option2$[ebp], ebx

; 17903: 	int Option3 = 0;
; 17904: 
; 17905: 	option1rand = 6;
; 17906: 	option2rand = 4;
; 17907: 
; 17908: 	option3rand = rand()%100;

  00028	e8 00 00 00 00	 call	 _rand
  0002d	99		 cdq
  0002e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00033	f7 f9		 idiv	 ecx
  00035	89 55 f8	 mov	 DWORD PTR _option3rand$[ebp], edx

; 17909: 	optionc = rand()%3;

  00038	e8 00 00 00 00	 call	 _rand
  0003d	99		 cdq
  0003e	b9 03 00 00 00	 mov	 ecx, 3
  00043	f7 f9		 idiv	 ecx
  00045	8b fa		 mov	 edi, edx

; 17910: 
; 17911: 	if(rand()%100 < option2rand)

  00047	e8 00 00 00 00	 call	 _rand
  0004c	99		 cdq
  0004d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00052	f7 f9		 idiv	 ecx
  00054	83 fa 04	 cmp	 edx, 4
  00057	7d 07		 jge	 SHORT $LN16@MakeReward

; 17912: 	{
; 17913: 		Option2 = 1;

  00059	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 1
$LN16@MakeReward:

; 17914: 	}
; 17915: 
; 17916: 	switch(optionc)

  00060	2b fb		 sub	 edi, ebx
  00062	74 1e		 je	 SHORT $LN10@MakeReward
  00064	4f		 dec	 edi
  00065	74 0e		 je	 SHORT $LN8@MakeReward
  00067	4f		 dec	 edi
  00068	75 23		 jne	 SHORT $LN17@MakeReward

; 17930: 	case 2: 
; 17931: 		if(option3rand < 12)

  0006a	83 7d f8 0c	 cmp	 DWORD PTR _option3rand$[ebp], 12 ; 0000000cH
  0006e	7d 1d		 jge	 SHORT $LN17@MakeReward

; 17932: 		{
; 17933: 			Option3 = 1;

  00070	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]

; 17934: 		}
; 17935: 		break;

  00073	eb 18		 jmp	 SHORT $LN17@MakeReward
$LN8@MakeReward:

; 17922: 		}
; 17923: 		break;
; 17924: 	case 1:
; 17925: 		if(option3rand < 8)

  00075	83 7d f8 08	 cmp	 DWORD PTR _option3rand$[ebp], 8
  00079	7d 12		 jge	 SHORT $LN17@MakeReward

; 17926: 		{
; 17927: 			Option3 = 2;

  0007b	bb 02 00 00 00	 mov	 ebx, 2

; 17928: 		}
; 17929: 		break;

  00080	eb 0b		 jmp	 SHORT $LN17@MakeReward
$LN10@MakeReward:

; 17917: 	{
; 17918: 	case 0: 
; 17919: 		if(option3rand < 4)

  00082	83 7d f8 04	 cmp	 DWORD PTR _option3rand$[ebp], 4
  00086	7d 05		 jge	 SHORT $LN17@MakeReward

; 17920: 		{
; 17921: 			Option3 = 3;

  00088	bb 03 00 00 00	 mov	 ebx, 3
$LN17@MakeReward:

; 17936: 	default: break;
; 17937: 	}
; 17938: 
; 17939: 	Option1 = 1;
; 17940: 
; 17941: 	if(cDropX == 0 && cDropY == 0)

  0008d	80 7d 0c 00	 cmp	 BYTE PTR _cDropX$[ebp], 0
  00091	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00094	75 20		 jne	 SHORT $LN3@MakeReward
  00096	80 7d 10 00	 cmp	 BYTE PTR _cDropY$[ebp], 0
  0009a	75 1a		 jne	 SHORT $LN3@MakeReward

; 17942: 	{
; 17943: 		cDropX = gObj[aIndex].X;

  0009c	8b c7		 mov	 eax, edi
  0009e	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000a4	8a 90 04 01 00
	00		 mov	 dl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]

; 17944: 		cDropY = gObj[aIndex].Y;

  000aa	8a 80 06 01 00
	00		 mov	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  000b0	88 55 0c	 mov	 BYTE PTR _cDropX$[ebp], dl
  000b3	88 45 10	 mov	 BYTE PTR _cDropY$[ebp], al
$LN3@MakeReward:

; 17945: 	}
; 17946: 
; 17947: 	ItemSerialCreateSend(aIndex,iMapnumber,cDropX,cDropY,itemnum,0,0,Option1,Option2,Option3,aIndex,0,SetOption);

  000b6	8b 4d f4	 mov	 ecx, DWORD PTR _SetOption$[ebp]
  000b9	8b 55 fc	 mov	 edx, DWORD PTR _Option2$[ebp]
  000bc	8b 45 10	 mov	 eax, DWORD PTR _cDropY$[ebp]
  000bf	51		 push	 ecx
  000c0	8b 4d 0c	 mov	 ecx, DWORD PTR _cDropX$[ebp]
  000c3	6a 00		 push	 0
  000c5	57		 push	 edi
  000c6	53		 push	 ebx
  000c7	52		 push	 edx
  000c8	8b 55 18	 mov	 edx, DWORD PTR _iMapnumber$[ebp]
  000cb	6a 01		 push	 1
  000cd	6a 00		 push	 0
  000cf	6a 00		 push	 0
  000d1	56		 push	 esi
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	52		 push	 edx
  000d5	57		 push	 edi
  000d6	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 17948: 
; 17949: 	if(iRewardType == 1)
; 17950: 	{
; 17951: 		LogAdd(LOG_BLACK, "[Reward][KUNDUN] [%s][%s] Set Item itemnum:[%d] skill:[%d] luck:[%d] option:[%d] SetOption:[%d]",
; 17952: 			gObj[aIndex].AccountID,gObj[aIndex].Name,itemnum,Option1,Option2,Option3,SetOption);

  000db	8b 4d f4	 mov	 ecx, DWORD PTR _SetOption$[ebp]
  000de	8b 55 fc	 mov	 edx, DWORD PTR _Option2$[ebp]
  000e1	83 c4 34	 add	 esp, 52			; 00000034H
  000e4	51		 push	 ecx
  000e5	8b c7		 mov	 eax, edi
  000e7	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000ed	83 7d 14 01	 cmp	 DWORD PTR _iRewardType$[ebp], 1
  000f1	53		 push	 ebx
  000f2	52		 push	 edx
  000f3	6a 01		 push	 1
  000f5	56		 push	 esi
  000f6	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  000fc	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00102	51		 push	 ecx
  00103	52		 push	 edx
  00104	75 16		 jne	 SHORT $LN2@MakeReward
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@HKPKGOEM@?$FL?$KB?Z?$KB?YReward?$FN?$FLKUNDUN?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Se@

; 17953: 	}
; 17954: 	else
; 17955: 	{
; 17956: 		LogAdd(LOG_BLACK, "[Reward][Etc] [%s][%s] Set Item itemnum:[%d] skill:[%d] luck:[%d] option:[%d] SetOption:[%d]",
; 17957: 			gObj[aIndex].AccountID,gObj[aIndex].Name,itemnum,Option1,Option2,Option3,SetOption);

  0010b	6a 00		 push	 0
  0010d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00112	83 c4 24	 add	 esp, 36			; 00000024H
  00115	5f		 pop	 edi
  00116	5e		 pop	 esi
  00117	5b		 pop	 ebx

; 17958: 	}		
; 17959: }

  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
$LN2@MakeReward:

; 17953: 	}
; 17954: 	else
; 17955: 	{
; 17956: 		LogAdd(LOG_BLACK, "[Reward][Etc] [%s][%s] Set Item itemnum:[%d] skill:[%d] luck:[%d] option:[%d] SetOption:[%d]",
; 17957: 			gObj[aIndex].AccountID,gObj[aIndex].Name,itemnum,Option1,Option2,Option3,SetOption);

  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@IPFPLKOM@?$FLReward?$FN?$FLEtc?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5Item?5@
  00121	6a 00		 push	 0
  00123	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00128	83 c4 24	 add	 esp, 36			; 00000024H
  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx

; 17958: 	}		
; 17959: }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c3		 ret	 0
?MakeRewardSetItem@@YAXHEEHH@Z ENDP			; MakeRewardSetItem
_TEXT	ENDS
PUBLIC	?gObjRecall@@YAXHHHH@Z				; gObjRecall
EXTRN	?PHeadSetBE@@YAXPAEEH@Z:PROC			; PHeadSetBE
; Function compile flags: /Ogtp
;	COMDAT ?gObjRecall@@YAXHHHH@Z
_TEXT	SEGMENT
_pAttack$168066 = -8					; size = 8
_aIndex$ = 8						; size = 4
_mapnumber$ = 12					; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?gObjRecall@@YAXHHHH@Z PROC				; gObjRecall, COMDAT

; 17962: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 17963: 	if(gObj[aIndex].MapNumber != mapnumber)

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _mapnumber$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000e	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00014	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]
  0001b	3b c3		 cmp	 eax, ebx
  0001d	0f 84 9c 00 00
	00		 je	 $LN3@gObjRecall

; 17964: 	{
; 17965: 		gObj[aIndex].X = x;
; 17966: 		gObj[aIndex].Y = y;

  00023	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  00026	66 8b 4d 10	 mov	 cx, WORD PTR _x$[ebp]
  0002a	57		 push	 edi

; 17967: 
; 17968: 		gObj[aIndex].TX = x;
; 17969: 		gObj[aIndex].TX = y;	// #error Change to TY
; 17970: 
; 17971: 		gObj[aIndex].MapNumber = mapnumber;
; 17972: 
; 17973: 		gObj[aIndex].PathCount = 0;
; 17974: 		gObj[aIndex].Teleport = 0;
; 17975: 
; 17976: 		gObjClearViewport(&gObj[aIndex]);

  0002b	8d be 00 00 00
	00		 lea	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00031	57		 push	 edi
  00032	66 89 8e 04 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260], cx
  00039	66 89 86 06 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262], ax
  00040	66 89 86 20 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+288], ax
  00047	88 9e 09 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265], bl
  0004d	c7 86 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+296], 0
  00057	c6 86 00 02 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+512], 0
  0005e	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport

; 17977: 		GCTeleportSend(&gObj[aIndex],-1,mapnumber,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);

  00063	0f b6 96 08 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+264]
  0006a	0f b6 86 06 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  00071	0f b6 8e 04 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  00078	52		 push	 edx
  00079	50		 push	 eax
  0007a	51		 push	 ecx
  0007b	53		 push	 ebx
  0007c	6a ff		 push	 -1
  0007e	57		 push	 edi
  0007f	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend
  00084	83 c4 1c	 add	 esp, 28			; 0000001cH

; 17978: 
; 17979: 		if(gObj[aIndex].m_Change >= 0)

  00087	83 be d0 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+720], 0
  0008e	7c 09		 jl	 SHORT $LN2@gObjRecall

; 17980: 		{
; 17981: 			gObjViewportListProtocolCreate(&gObj[aIndex]);

  00090	57		 push	 edi
  00091	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00096	83 c4 04	 add	 esp, 4
$LN2@gObjRecall:

; 17982: 		}
; 17983: 
; 17984: 		gObj[aIndex].RegenMapNumber = mapnumber;
; 17985: 		gObj[aIndex].RegenMapX = x;

  00099	8a 55 10	 mov	 dl, BYTE PTR _x$[ebp]

; 17986: 		gObj[aIndex].RegenMapY = y;

  0009c	8a 45 14	 mov	 al, BYTE PTR _y$[ebp]
  0009f	5f		 pop	 edi
  000a0	88 9e 04 02 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+516], bl
  000a6	88 96 05 02 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+517], dl
  000ac	88 86 06 02 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+518], al

; 17987: 		gObj[aIndex].RegenOk = 1;

  000b2	c6 86 03 02 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+515], 1
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx

; 18004: 	}
; 18005: }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
$LN3@gObjRecall:

; 17988: 	}
; 17989: 	else
; 17990: 	{
; 17991: 		PMSG_MAGICATTACK_RESULT pAttack;
; 17992: 
; 17993: 		PHeadSetBE((unsigned char *)&pAttack,0x19,sizeof(pAttack));

  000bf	6a 08		 push	 8
  000c1	8d 4d f8	 lea	 ecx, DWORD PTR _pAttack$168066[ebp]
  000c4	6a 19		 push	 25			; 00000019H
  000c6	51		 push	 ecx
  000c7	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 17994: 
; 17995: 		pAttack.MagicNumber = 6;
; 17996: 		pAttack.SourceNumberH = SET_NUMBERH(aIndex);

  000cc	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 17997: 		pAttack.SourceNumberL = SET_NUMBERL(aIndex);
; 17998: 		pAttack.TargetNumberH = SET_NUMBERH(aIndex);
; 17999: 		pAttack.TargetNumberL = SET_NUMBERL(aIndex);
; 18000: 
; 18001: 		DataSend(aIndex,(unsigned char *)&pAttack,pAttack.h.size);

  000cf	0f b6 55 f9	 movzx	 edx, BYTE PTR _pAttack$168066[ebp+1]
  000d3	8b c3		 mov	 eax, ebx
  000d5	c1 e8 08	 shr	 eax, 8
  000d8	88 45 fc	 mov	 BYTE PTR _pAttack$168066[ebp+4], al
  000db	88 45 fe	 mov	 BYTE PTR _pAttack$168066[ebp+6], al
  000de	52		 push	 edx
  000df	8d 45 f8	 lea	 eax, DWORD PTR _pAttack$168066[ebp]
  000e2	50		 push	 eax
  000e3	53		 push	 ebx
  000e4	c6 45 fb 06	 mov	 BYTE PTR _pAttack$168066[ebp+3], 6
  000e8	88 5d fd	 mov	 BYTE PTR _pAttack$168066[ebp+5], bl
  000eb	88 5d ff	 mov	 BYTE PTR _pAttack$168066[ebp+7], bl
  000ee	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18002: 		MsgSendV2(&gObj[aIndex],(unsigned char*)&pAttack,pAttack.h.size);

  000f3	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pAttack$168066[ebp+1]
  000f7	51		 push	 ecx
  000f8	8d 55 f8	 lea	 edx, DWORD PTR _pAttack$168066[ebp]
  000fb	52		 push	 edx
  000fc	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 18003: 		gObjTeleportMagicUse(aIndex,x,y);

  00108	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  0010b	8b 55 10	 mov	 edx, DWORD PTR _x$[ebp]
  0010e	51		 push	 ecx
  0010f	52		 push	 edx
  00110	53		 push	 ebx
  00111	e8 00 00 00 00	 call	 ?gObjTeleportMagicUse@@YAXHEE@Z ; gObjTeleportMagicUse
  00116	83 c4 30	 add	 esp, 48			; 00000030H
  00119	5e		 pop	 esi
  0011a	5b		 pop	 ebx

; 18004: 	}
; 18005: }

  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c3		 ret	 0
?gObjRecall@@YAXHHHH@Z ENDP				; gObjRecall
_TEXT	ENDS
PUBLIC	??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@ ; `string'
PUBLIC	?TalkRefDel@CQeustNpcTeleport@@QAEXXZ		; CQeustNpcTeleport::TalkRefDel
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
;	COMDAT ??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\gobjmonster.h
CONST	SEGMENT
??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@ DB 'QeustNpc R'
	DB	'efCount Dec= %d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?TalkRefDel@CQeustNpcTeleport@@QAEXXZ
_TEXT	SEGMENT
?TalkRefDel@CQeustNpcTeleport@@QAEXXZ PROC		; CQeustNpcTeleport::TalkRefDel, COMDAT
; _this$ = ecx

; 71   : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 72   : 		EnterCriticalSection(&this->CsRef);

  00004	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00007	57		 push	 edi
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 73   : 		this->RefCount--;

  0000e	ff 0e		 dec	 DWORD PTR [esi]

; 74   : 
; 75   : 		if ( this->RefCount < 0 )

  00010	79 06		 jns	 SHORT $LN1@TalkRefDel

; 76   : 		{
; 77   : 			this->RefCount = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@TalkRefDel:

; 78   : 		}
; 79   : 		
; 80   : 		LogAdd(LOG_BLACK, "QeustNpc RefCount Dec= %d", this->RefCount);

  00018	8b 06		 mov	 eax, DWORD PTR [esi]
  0001a	50		 push	 eax
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@
  00020	6a 00		 push	 0
  00022	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 81   : 		LeaveCriticalSection(&this->CsRef);

  0002a	57		 push	 edi
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 82   : 	};	// line : 135

  00033	c3		 ret	 0
?TalkRefDel@CQeustNpcTeleport@@QAEXXZ ENDP		; CQeustNpcTeleport::TalkRefDel
_TEXT	ENDS
PUBLIC	?GetState@CDragonEvent@@QAEEXZ			; CDragonEvent::GetState
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\dragonevent.h
;	COMDAT ?GetState@CDragonEvent@@QAEEXZ
_TEXT	SEGMENT
?GetState@CDragonEvent@@QAEEXZ PROC			; CDragonEvent::GetState, COMDAT
; _this$ = ecx

; 19   : 	BYTE GetState(){return this->EventState;}	// Dagon event line 30.h

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	c3		 ret	 0
?GetState@CDragonEvent@@QAEEXZ ENDP			; CDragonEvent::GetState
_TEXT	ENDS
PUBLIC	?GetMapNumber@CDragonEvent@@QAEEXZ		; CDragonEvent::GetMapNumber
; Function compile flags: /Ogtp
;	COMDAT ?GetMapNumber@CDragonEvent@@QAEEXZ
_TEXT	SEGMENT
?GetMapNumber@CDragonEvent@@QAEEXZ PROC			; CDragonEvent::GetMapNumber, COMDAT
; _this$ = ecx

; 20   : 	BYTE GetMapNumber(){return this->m_MapNumber;}	// Dragon event line 35.h 

  00000	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]
  00003	c3		 ret	 0
?GetMapNumber@CDragonEvent@@QAEEXZ ENDP			; CDragonEvent::GetMapNumber
_TEXT	ENDS
PUBLIC	?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z	; gObjGetRandomItemDropLocation
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
;	COMDAT ?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z
_TEXT	SEGMENT
_iUY$ = -8						; size = 4
_iUX$ = -4						; size = 4
_iMapNumber$ = 8					; size = 4
tv203 = 12						; size = 4
_cX$ = 12						; size = 4
_cY$ = 16						; size = 4
tv209 = 20						; size = 4
_iRangeX$ = 20						; size = 4
tv216 = 24						; size = 4
_iRangeY$ = 24						; size = 4
_iLoopCount$ = 28					; size = 4
?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z PROC	; gObjGetRandomItemDropLocation, COMDAT

; 18093: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 18094: 	int iUX = cX;
; 18095: 	int iUY = cY;

  00006	8b 4d 10	 mov	 ecx, DWORD PTR _cY$[ebp]
  00009	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b 75 0c	 mov	 esi, DWORD PTR _cX$[ebp]
  00011	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00014	89 45 fc	 mov	 DWORD PTR _iUX$[ebp], eax

; 18096: 
; 18097: 	if ( iRangeX <= 0 )

  00017	8b 45 14	 mov	 eax, DWORD PTR _iRangeX$[ebp]
  0001a	57		 push	 edi
  0001b	89 55 f8	 mov	 DWORD PTR _iUY$[ebp], edx
  0001e	85 c0		 test	 eax, eax
  00020	7f 05		 jg	 SHORT $LN15@gObjGetRan

; 18098: 	{
; 18099: 		iRangeX = 1;

  00022	b8 01 00 00 00	 mov	 eax, 1
$LN15@gObjGetRan:

; 18100: 	}
; 18101: 
; 18102: 	if ( iRangeY <= 0 )

  00027	8b 4d 18	 mov	 ecx, DWORD PTR _iRangeY$[ebp]
  0002a	85 c9		 test	 ecx, ecx
  0002c	7f 05		 jg	 SHORT $LN17@gObjGetRan

; 18103: 	{
; 18104: 		iRangeY = 1;

  0002e	b9 01 00 00 00	 mov	 ecx, 1
$LN17@gObjGetRan:

; 18105: 	}
; 18106: 
; 18107: 	if ( iLoopCount <= 0 )

  00033	8b 7d 1c	 mov	 edi, DWORD PTR _iLoopCount$[ebp]
  00036	85 ff		 test	 edi, edi
  00038	7f 05		 jg	 SHORT $LN14@gObjGetRan

; 18108: 	{
; 18109: 		iLoopCount = 1;

  0003a	bf 01 00 00 00	 mov	 edi, 1
$LN14@gObjGetRan:

; 18118: 
; 18119: 		if ( (attr&4) != 4 && (attr&8) != 8)

  0003f	40		 inc	 eax
  00040	89 45 0c	 mov	 DWORD PTR tv203[ebp], eax
  00043	8b 45 08	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  00046	41		 inc	 ecx
  00047	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  0004d	89 4d 14	 mov	 DWORD PTR tv209[ebp], ecx
  00050	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  00056	89 4d 18	 mov	 DWORD PTR tv216[ebp], ecx
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL3@gObjGetRan:

; 18113: 	{
; 18114: 		cX = ( rand() % (iRangeX+1) ) * (((rand()%2==0)?-1:1)) + iUX;

  00060	4f		 dec	 edi
  00061	e8 00 00 00 00	 call	 _rand
  00066	99		 cdq
  00067	f7 7d 0c	 idiv	 DWORD PTR tv203[ebp]
  0006a	8b da		 mov	 ebx, edx
  0006c	e8 00 00 00 00	 call	 _rand
  00071	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00076	79 05		 jns	 SHORT $LN18@gObjGetRan
  00078	48		 dec	 eax
  00079	83 c8 fe	 or	 eax, -2			; fffffffeH
  0007c	40		 inc	 eax
$LN18@gObjGetRan:
  0007d	f7 d8		 neg	 eax
  0007f	1a c0		 sbb	 al, al
  00081	24 02		 and	 al, 2
  00083	fe c8		 dec	 al
  00085	f6 eb		 imul	 bl
  00087	02 45 fc	 add	 al, BYTE PTR _iUX$[ebp]
  0008a	88 06		 mov	 BYTE PTR [esi], al

; 18115: 		cY = ( rand() % (iRangeY+1) ) * (((rand()%2==0)?-1:1)) + iUY;

  0008c	e8 00 00 00 00	 call	 _rand
  00091	99		 cdq
  00092	f7 7d 14	 idiv	 DWORD PTR tv209[ebp]
  00095	8b da		 mov	 ebx, edx
  00097	e8 00 00 00 00	 call	 _rand
  0009c	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000a1	79 05		 jns	 SHORT $LN19@gObjGetRan
  000a3	48		 dec	 eax
  000a4	83 c8 fe	 or	 eax, -2			; fffffffeH
  000a7	40		 inc	 eax
$LN19@gObjGetRan:
  000a8	8b 55 10	 mov	 edx, DWORD PTR _cY$[ebp]
  000ab	f7 d8		 neg	 eax
  000ad	1a c0		 sbb	 al, al
  000af	24 02		 and	 al, 2
  000b1	fe c8		 dec	 al
  000b3	f6 eb		 imul	 bl
  000b5	02 45 f8	 add	 al, BYTE PTR _iUY$[ebp]
  000b8	88 02		 mov	 BYTE PTR [edx], al

; 18116: 
; 18117: 		BYTE attr = MapC[iMapNumber].GetAttr(cX, cY);

  000ba	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  000bd	0f b6 c0	 movzx	 eax, al
  000c0	50		 push	 eax
  000c1	51		 push	 ecx
  000c2	8b 4d 18	 mov	 ecx, DWORD PTR tv216[ebp]
  000c5	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 18118: 
; 18119: 		if ( (attr&4) != 4 && (attr&8) != 8)

  000ca	a8 0c		 test	 al, 12			; 0000000cH
  000cc	74 0d		 je	 SHORT $LN10@gObjGetRan

; 18110: 	}
; 18111: 
; 18112: 	while ( iLoopCount-- > 0 )

  000ce	85 ff		 test	 edi, edi
  000d0	7f 8e		 jg	 SHORT $LL3@gObjGetRan

; 18122: 		}
; 18123: 	}
; 18124: 
; 18125: 	return FALSE;

  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	33 c0		 xor	 eax, eax
  000d6	5b		 pop	 ebx

; 18126: }

  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
$LN10@gObjGetRan:
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi

; 18120: 		{
; 18121: 			return TRUE;

  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	5b		 pop	 ebx

; 18126: }

  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z ENDP	; gObjGetRandomItemDropLocation
_TEXT	ENDS
PUBLIC	?gObjGetRandomFreeLocation@@YAHHAAE0HHH@Z	; gObjGetRandomFreeLocation
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetRandomFreeLocation@@YAHHAAE0HHH@Z
_TEXT	SEGMENT
_iUY$ = -8						; size = 4
_iUX$ = -4						; size = 4
_iMapNumber$ = 8					; size = 4
tv203 = 12						; size = 4
_cX$ = 12						; size = 4
_cY$ = 16						; size = 4
tv209 = 20						; size = 4
_iRangeX$ = 20						; size = 4
tv216 = 24						; size = 4
_iRangeY$ = 24						; size = 4
_iLoopCount$ = 28					; size = 4
?gObjGetRandomFreeLocation@@YAHHAAE0HHH@Z PROC		; gObjGetRandomFreeLocation, COMDAT

; 18129: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 18130: 	int iUX = cX;
; 18131: 	int iUY = cY;

  00006	8b 4d 10	 mov	 ecx, DWORD PTR _cY$[ebp]
  00009	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b 75 0c	 mov	 esi, DWORD PTR _cX$[ebp]
  00011	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00014	89 45 fc	 mov	 DWORD PTR _iUX$[ebp], eax

; 18132: 
; 18133: 	if ( iRangeX <= 0 )

  00017	8b 45 14	 mov	 eax, DWORD PTR _iRangeX$[ebp]
  0001a	57		 push	 edi
  0001b	89 55 f8	 mov	 DWORD PTR _iUY$[ebp], edx
  0001e	85 c0		 test	 eax, eax
  00020	7f 05		 jg	 SHORT $LN15@gObjGetRan@2

; 18134: 	{
; 18135: 		iRangeX = 1;

  00022	b8 01 00 00 00	 mov	 eax, 1
$LN15@gObjGetRan@2:

; 18136: 	}
; 18137: 
; 18138: 	if ( iRangeY <= 0 )

  00027	8b 4d 18	 mov	 ecx, DWORD PTR _iRangeY$[ebp]
  0002a	85 c9		 test	 ecx, ecx
  0002c	7f 05		 jg	 SHORT $LN17@gObjGetRan@2

; 18139: 	{
; 18140: 		iRangeY = 1;

  0002e	b9 01 00 00 00	 mov	 ecx, 1
$LN17@gObjGetRan@2:

; 18141: 	}
; 18142: 
; 18143: 	if ( iLoopCount <= 0 )

  00033	8b 7d 1c	 mov	 edi, DWORD PTR _iLoopCount$[ebp]
  00036	85 ff		 test	 edi, edi
  00038	7f 05		 jg	 SHORT $LN14@gObjGetRan@2

; 18144: 	{
; 18145: 		iLoopCount = 1;

  0003a	bf 01 00 00 00	 mov	 edi, 1
$LN14@gObjGetRan@2:

; 18152: 
; 18153: 		BYTE attr = MapC[iMapNumber].GetAttr(cX, cY);
; 18154: 
; 18155: 		if ( attr == 0 )

  0003f	40		 inc	 eax
  00040	89 45 0c	 mov	 DWORD PTR tv203[ebp], eax
  00043	8b 45 08	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  00046	41		 inc	 ecx
  00047	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  0004d	89 4d 14	 mov	 DWORD PTR tv209[ebp], ecx
  00050	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  00056	89 4d 18	 mov	 DWORD PTR tv216[ebp], ecx
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL3@gObjGetRan@2:

; 18149: 	{
; 18150: 		cX = ( rand() % (iRangeX+1) ) * (((rand()%2==0)?-1:1)) + iUX;

  00060	4f		 dec	 edi
  00061	e8 00 00 00 00	 call	 _rand
  00066	99		 cdq
  00067	f7 7d 0c	 idiv	 DWORD PTR tv203[ebp]
  0006a	8b da		 mov	 ebx, edx
  0006c	e8 00 00 00 00	 call	 _rand
  00071	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00076	79 05		 jns	 SHORT $LN18@gObjGetRan@2
  00078	48		 dec	 eax
  00079	83 c8 fe	 or	 eax, -2			; fffffffeH
  0007c	40		 inc	 eax
$LN18@gObjGetRan@2:
  0007d	f7 d8		 neg	 eax
  0007f	1a c0		 sbb	 al, al
  00081	24 02		 and	 al, 2
  00083	fe c8		 dec	 al
  00085	f6 eb		 imul	 bl
  00087	02 45 fc	 add	 al, BYTE PTR _iUX$[ebp]
  0008a	88 06		 mov	 BYTE PTR [esi], al

; 18151: 		cY = ( rand() % (iRangeY+1) ) * (((rand()%2==0)?-1:1)) + iUY;

  0008c	e8 00 00 00 00	 call	 _rand
  00091	99		 cdq
  00092	f7 7d 14	 idiv	 DWORD PTR tv209[ebp]
  00095	8b da		 mov	 ebx, edx
  00097	e8 00 00 00 00	 call	 _rand
  0009c	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000a1	79 05		 jns	 SHORT $LN19@gObjGetRan@2
  000a3	48		 dec	 eax
  000a4	83 c8 fe	 or	 eax, -2			; fffffffeH
  000a7	40		 inc	 eax
$LN19@gObjGetRan@2:
  000a8	8b 55 10	 mov	 edx, DWORD PTR _cY$[ebp]
  000ab	f7 d8		 neg	 eax
  000ad	1a c0		 sbb	 al, al
  000af	24 02		 and	 al, 2
  000b1	fe c8		 dec	 al
  000b3	f6 eb		 imul	 bl
  000b5	02 45 f8	 add	 al, BYTE PTR _iUY$[ebp]
  000b8	88 02		 mov	 BYTE PTR [edx], al

; 18152: 
; 18153: 		BYTE attr = MapC[iMapNumber].GetAttr(cX, cY);
; 18154: 
; 18155: 		if ( attr == 0 )

  000ba	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  000bd	0f b6 c0	 movzx	 eax, al
  000c0	50		 push	 eax
  000c1	51		 push	 ecx
  000c2	8b 4d 18	 mov	 ecx, DWORD PTR tv216[ebp]
  000c5	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000ca	84 c0		 test	 al, al
  000cc	74 0d		 je	 SHORT $LN10@gObjGetRan@2

; 18146: 	}
; 18147: 
; 18148: 	while ( iLoopCount-- > 0 )

  000ce	85 ff		 test	 edi, edi
  000d0	7f 8e		 jg	 SHORT $LL3@gObjGetRan@2

; 18158: 		}
; 18159: 	}
; 18160: 
; 18161: 	return FALSE;

  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	33 c0		 xor	 eax, eax
  000d6	5b		 pop	 ebx

; 18162: }

  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
$LN10@gObjGetRan@2:
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi

; 18156: 		{
; 18157: 			return TRUE;

  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	5b		 pop	 ebx

; 18162: }

  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
?gObjGetRandomFreeLocation@@YAHHAAE0HHH@Z ENDP		; gObjGetRandomFreeLocation
_TEXT	ENDS
PUBLIC	?gObjCheckAttackTypeMagic@@YAHHH@Z		; gObjCheckAttackTypeMagic
EXTRN	?GetSkillType@CMagicDamage@@QAEHH@Z:PROC	; CMagicDamage::GetSkillType
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckAttackTypeMagic@@YAHHH@Z
_TEXT	SEGMENT
_iClass$ = 8						; size = 4
_iSkill$ = 12						; size = 4
?gObjCheckAttackTypeMagic@@YAHHH@Z PROC			; gObjCheckAttackTypeMagic, COMDAT

; 18165: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18166: 	if ( iSkill == 0 )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iSkill$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN1@gObjCheckA@4

; 18172: }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN1@gObjCheckA@4:

; 18167: 	{
; 18168: 		return 0;
; 18169: 	}
; 18170: 
; 18171: 	return MagicDamageC.GetSkillType(iSkill);

  0000c	50		 push	 eax
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00012	e8 00 00 00 00	 call	 ?GetSkillType@CMagicDamage@@QAEHH@Z ; CMagicDamage::GetSkillType

; 18172: }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?gObjCheckAttackTypeMagic@@YAHHH@Z ENDP			; gObjCheckAttackTypeMagic
_TEXT	ENDS
PUBLIC	?gObjGetGuildUnionNumber@@YAHPAUOBJECTSTRUCT@@@Z ; gObjGetGuildUnionNumber
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetGuildUnionNumber@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjGetGuildUnionNumber@@YAHPAUOBJECTSTRUCT@@@Z PROC	; gObjGetGuildUnionNumber, COMDAT

; 18220: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18221: 	int iUnion=0;
; 18222: 
; 18223: 	if ( lpObj->lpGuild != NULL )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00006	8b 89 b4 02 00
	00		 mov	 ecx, DWORD PTR [ecx+692]
  0000c	33 c0		 xor	 eax, eax
  0000e	85 c9		 test	 ecx, ecx
  00010	74 0c		 je	 SHORT $LN5@gObjGetGui

; 18224: 	{
; 18225: 		iUnion = (lpObj->lpGuild->iGuildUnion == 0)? lpObj->lpGuild->Number : lpObj->lpGuild->iGuildUnion;

  00012	8b 81 1c 07 00
	00		 mov	 eax, DWORD PTR [ecx+1820]
  00018	85 c0		 test	 eax, eax
  0001a	75 02		 jne	 SHORT $LN5@gObjGetGui

; 18226: 	}
; 18227: 
; 18228: 	return iUnion;

  0001c	8b 01		 mov	 eax, DWORD PTR [ecx]
$LN5@gObjGetGui:

; 18229: 
; 18230: }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?gObjGetGuildUnionNumber@@YAHPAUOBJECTSTRUCT@@@Z ENDP	; gObjGetGuildUnionNumber
_TEXT	ENDS
PUBLIC	?gObjGetGuildUnionName@@YAXPAUOBJECTSTRUCT@@PADH@Z ; gObjGetGuildUnionName
EXTRN	?SearchUnion@TUnion@@QAEPAVTUnionInfo@@H@Z:PROC	; TUnion::SearchUnion
EXTRN	?UnionManager@@3VTUnion@@A:BYTE			; UnionManager
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetGuildUnionName@@YAXPAUOBJECTSTRUCT@@PADH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_szUnionName$ = 12					; size = 4
_iUnionNameLen$ = 16					; size = 4
?gObjGetGuildUnionName@@YAXPAUOBJECTSTRUCT@@PADH@Z PROC	; gObjGetGuildUnionName, COMDAT

; 18233: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18234: 	szUnionName[0] = 0;
; 18235: 	
; 18236: 	if ( lpObj->lpGuild == NULL )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR _szUnionName$[ebp]
  0000a	c6 06 00	 mov	 BYTE PTR [esi], 0
  0000d	8b 80 b4 02 00
	00		 mov	 eax, DWORD PTR [eax+692]
  00013	85 c0		 test	 eax, eax
  00015	74 2a		 je	 SHORT $LN1@gObjGetGui@2

; 18237: 	{
; 18238: 		return;
; 18239: 	}
; 18240: 
; 18241: 	if ( lpObj->lpGuild->iGuildUnion == 0 )

  00017	8b 80 1c 07 00
	00		 mov	 eax, DWORD PTR [eax+1820]
  0001d	85 c0		 test	 eax, eax
  0001f	74 20		 je	 SHORT $LN1@gObjGetGui@2

; 18242: 	{
; 18243: 		return;
; 18244: 	}
; 18245: 
; 18246: 	TUnionInfo * pUnionInfo = UnionManager.SearchUnion(lpObj->lpGuild->iGuildUnion);

  00021	50		 push	 eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  00027	e8 00 00 00 00	 call	 ?SearchUnion@TUnion@@QAEPAVTUnionInfo@@H@Z ; TUnion::SearchUnion

; 18247: 
; 18248: 	if ( pUnionInfo != NULL )

  0002c	85 c0		 test	 eax, eax
  0002e	74 11		 je	 SHORT $LN1@gObjGetGui@2

; 18249: 	{
; 18250: 		memcpy(szUnionName, pUnionInfo->m_szMasterGuild, iUnionNameLen);

  00030	8b 4d 10	 mov	 ecx, DWORD PTR _iUnionNameLen$[ebp]
  00033	51		 push	 ecx
  00034	83 c0 10	 add	 eax, 16			; 00000010H
  00037	50		 push	 eax
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 _memcpy
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjGetGui@2:
  00041	5e		 pop	 esi

; 18251: 	}
; 18252: }

  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?gObjGetGuildUnionName@@YAXPAUOBJECTSTRUCT@@PADH@Z ENDP	; gObjGetGuildUnionName
_TEXT	ENDS
PUBLIC	?gObjCheckRival@@YAHPAUOBJECTSTRUCT@@0@Z	; gObjCheckRival
EXTRN	?GetGuildRelationShip@TUnion@@QAEHHH@Z:PROC	; TUnion::GetGuildRelationShip
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckRival@@YAHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjCheckRival@@YAHPAUOBJECTSTRUCT@@0@Z PROC		; gObjCheckRival, COMDAT

; 18255: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18256: 	if(lpTargetObj->Type != OBJ_USER)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00006	ba 01 00 00 00	 mov	 edx, 1
  0000b	66 39 50 60	 cmp	 WORD PTR [eax+96], dx

; 18257: 	{
; 18258: 		return false;

  0000f	75 59		 jne	 SHORT $LN4@gObjCheckR

; 18259: 	}
; 18260: 
; 18261: 	if(lpObj->Type != OBJ_USER)

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00014	66 39 51 60	 cmp	 WORD PTR [ecx+96], dx

; 18262: 	{
; 18263: 		return false;

  00018	75 50		 jne	 SHORT $LN4@gObjCheckR

; 18264: 	}
; 18265: 
; 18266: 	if(lpTargetObj->lpGuild == 0 || lpObj->lpGuild == 0)

  0001a	8b 90 b4 02 00
	00		 mov	 edx, DWORD PTR [eax+692]
  00020	85 d2		 test	 edx, edx
  00022	74 46		 je	 SHORT $LN4@gObjCheckR
  00024	8b 81 b4 02 00
	00		 mov	 eax, DWORD PTR [ecx+692]
  0002a	85 c0		 test	 eax, eax
  0002c	74 3c		 je	 SHORT $LN4@gObjCheckR

; 18269: 	}
; 18270: 
; 18271: 	if(lpTargetObj->lpGuild->iGuildRival == 0 || lpObj->lpGuild->iGuildRival == 0)

  0002e	83 ba 20 07 00
	00 00		 cmp	 DWORD PTR [edx+1824], 0
  00035	74 33		 je	 SHORT $LN4@gObjCheckR
  00037	83 b8 20 07 00
	00 00		 cmp	 DWORD PTR [eax+1824], 0
  0003e	74 2a		 je	 SHORT $LN4@gObjCheckR

; 18272: 	{
; 18273: 		return false;
; 18274: 	}
; 18275: 
; 18276: 	int iUnion = !lpObj->lpGuild->iGuildUnion ? lpObj->lpGuild->Number : lpObj->lpGuild->iGuildUnion;

  00040	8b 88 1c 07 00
	00		 mov	 ecx, DWORD PTR [eax+1820]
  00046	85 c9		 test	 ecx, ecx
  00048	75 04		 jne	 SHORT $LN10@gObjCheckR
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	eb 02		 jmp	 SHORT $LN11@gObjCheckR
$LN10@gObjCheckR:
  0004e	8b c1		 mov	 eax, ecx
$LN11@gObjCheckR:

; 18277: 
; 18278: 	if(UnionManager.GetGuildRelationShip(iUnion,lpTargetObj->lpGuild->Number) == 2)

  00050	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00052	51		 push	 ecx
  00053	50		 push	 eax
  00054	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  00059	e8 00 00 00 00	 call	 ?GetGuildRelationShip@TUnion@@QAEHHH@Z ; TUnion::GetGuildRelationShip
  0005e	33 d2		 xor	 edx, edx
  00060	83 f8 02	 cmp	 eax, 2
  00063	0f 94 c2	 sete	 dl
  00066	8b c2		 mov	 eax, edx

; 18279: 	{
; 18280: 		return true;
; 18281: 	}
; 18282: 	return false;
; 18283: }

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN4@gObjCheckR:

; 18267: 	{
; 18268: 		return false;

  0006a	33 c0		 xor	 eax, eax

; 18279: 	{
; 18280: 		return true;
; 18281: 	}
; 18282: 	return false;
; 18283: }

  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?gObjCheckRival@@YAHPAUOBJECTSTRUCT@@0@Z ENDP		; gObjCheckRival
_TEXT	ENDS
PUBLIC	?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z	; gObjGetRelationShip
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z PROC	; gObjGetRelationShip, COMDAT

; 18286: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18287: 	if ( lpObj == NULL || lpTargetObj == NULL )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 49		 je	 SHORT $LN3@gObjGetRel
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 42		 je	 SHORT $LN3@gObjGetRel

; 18290: 	}
; 18291: 
; 18292: 	if ( lpObj->lpGuild == NULL || lpTargetObj->lpGuild == NULL )

  00011	8b 80 b4 02 00
	00		 mov	 eax, DWORD PTR [eax+692]
  00017	85 c0		 test	 eax, eax
  00019	74 38		 je	 SHORT $LN3@gObjGetRel
  0001b	8b 91 b4 02 00
	00		 mov	 edx, DWORD PTR [ecx+692]
  00021	85 d2		 test	 edx, edx
  00023	74 2e		 je	 SHORT $LN3@gObjGetRel

; 18293: 	{
; 18294: 		return 0;
; 18295: 	}
; 18296: 
; 18297: 	int iUnion = (!lpObj->lpGuild->iGuildUnion) ? lpObj->lpGuild->Number : lpObj->lpGuild->iGuildUnion;

  00025	8b 88 1c 07 00
	00		 mov	 ecx, DWORD PTR [eax+1820]
  0002b	85 c9		 test	 ecx, ecx
  0002d	75 12		 jne	 SHORT $LN7@gObjGetRel

; 18298: 
; 18299: 	return UnionManager.GetGuildRelationShip(iUnion, lpTargetObj->lpGuild->Number);

  0002f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00031	8b 00		 mov	 eax, DWORD PTR [eax]
  00033	51		 push	 ecx
  00034	50		 push	 eax
  00035	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  0003a	e8 00 00 00 00	 call	 ?GetGuildRelationShip@TUnion@@QAEHHH@Z ; TUnion::GetGuildRelationShip

; 18300: }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN7@gObjGetRel:

; 18293: 	{
; 18294: 		return 0;
; 18295: 	}
; 18296: 
; 18297: 	int iUnion = (!lpObj->lpGuild->iGuildUnion) ? lpObj->lpGuild->Number : lpObj->lpGuild->iGuildUnion;

  00041	8b c1		 mov	 eax, ecx

; 18298: 
; 18299: 	return UnionManager.GetGuildRelationShip(iUnion, lpTargetObj->lpGuild->Number);

  00043	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00045	51		 push	 ecx
  00046	50		 push	 eax
  00047	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  0004c	e8 00 00 00 00	 call	 ?GetGuildRelationShip@TUnion@@QAEHHH@Z ; TUnion::GetGuildRelationShip

; 18300: }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN3@gObjGetRel:

; 18288: 	{
; 18289: 		return false;

  00053	33 c0		 xor	 eax, eax

; 18300: }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z ENDP	; gObjGetRelationShip
_TEXT	ENDS
PUBLIC	??_C@_0DH@GADDHGKB@?$FLUnion?5ViewPort?$FN?5ERROR?5?3?5iVp1Cou@ ; `string'
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjNotifyUpdateUnionV1@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNotifyUpdateUnionV1
EXTRN	?PHeadSetW@@YAXPAEEH@Z:PROC			; PHeadSetW
;	COMDAT ??_C@_0DH@GADDHGKB@?$FLUnion?5ViewPort?$FN?5ERROR?5?3?5iVp1Cou@
CONST	SEGMENT
??_C@_0DH@GADDHGKB@?$FLUnion?5ViewPort?$FN?5ERROR?5?3?5iVp1Cou@ DB '[Unio'
	DB	'n ViewPort] ERROR : iVp1Count is OUT of BOUND: %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjNotifyUpdateUnionV1@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$GSCopy$ = -6016					; size = 4
tv246 = -6012						; size = 4
_iVp1Count$ = -6008					; size = 4
_cBUFFER_V1$ = -6004					; size = 6000
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjNotifyUpdateUnionV1@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjNotifyUpdateUnionV1, COMDAT

; 18321: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 80 17 00 00	 mov	 eax, 6016		; 00001780H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]

; 18331: 
; 18332: 	PMSG_UNION_VIEWPORT_NOTIFY_COUNT * lpMsg = (PMSG_UNION_VIEWPORT_NOTIFY_COUNT *)&cBUFFER_V1;
; 18333: 	PMSG_UNION_VIEWPORT_NOTIFY * lpMsgBody = (PMSG_UNION_VIEWPORT_NOTIFY * )&cBUFFER_V1[sizeof(PMSG_UNION_VIEWPORT_NOTIFY_COUNT)];
; 18334: 
; 18335: 
; 18336: 	for(int n = 0; n < MAX_VIEWPORT; n++)

  0001b	89 9d 80 e8 ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$[ebp], ebx
  00021	85 db		 test	 ebx, ebx
  00023	0f 84 43 01 00
	00		 je	 $LN1@gObjNotify

; 18322: 	if(lpObj == 0)
; 18323: 	{
; 18324: 		return;
; 18325: 	}
; 18326: 
; 18327: 	char cBUFFER_V1[6000];
; 18328: 	int iVp1Count = 0;
; 18329: 
; 18330: 	memset(cBUFFER_V1,0x00,sizeof(cBUFFER_V1));

  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	68 70 17 00 00	 push	 6000			; 00001770H
  00030	8d 85 8c e8 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER_V1$[ebp]
  00036	6a 00		 push	 0
  00038	50		 push	 eax
  00039	c7 85 88 e8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _iVp1Count$[ebp], 0
  00043	e8 00 00 00 00	 call	 _memset
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	8d bd 99 e8 ff
	ff		 lea	 edi, DWORD PTR _cBUFFER_V1$[ebp+13]
  00051	81 c3 92 03 00
	00		 add	 ebx, 914		; 00000392H
  00057	c7 85 84 e8 ff
	ff 4b 00 00 00	 mov	 DWORD PTR tv246[ebp], 75 ; 0000004bH
$LL21@gObjNotify:

; 18337: 	{
; 18338: 		if(!OBJMAX_RANGE(lpObj->VpPlayer[n].number))

  00061	0f b7 03	 movzx	 eax, WORD PTR [ebx]
  00064	66 85 c0	 test	 ax, ax
  00067	78 76		 js	 SHORT $LN9@gObjNotify
  00069	33 d2		 xor	 edx, edx
  0006b	b9 e7 1c 00 00	 mov	 ecx, 7399		; 00001ce7H
  00070	66 3b c1	 cmp	 ax, cx
  00073	0f 9e c2	 setle	 dl
  00076	8b ca		 mov	 ecx, edx
  00078	85 c9		 test	 ecx, ecx
  0007a	74 63		 je	 SHORT $LN9@gObjNotify

; 18339: 		{
; 18340: 			continue;
; 18341: 		}
; 18342: 
; 18343: 		if(lpObj->VpPlayer[n].state == 2 && lpObj->VpPlayer[n].type == OBJ_USER)

  0007c	80 7b fe 02	 cmp	 BYTE PTR [ebx-2], 2
  00080	75 5d		 jne	 SHORT $LN9@gObjNotify
  00082	80 7b 02 01	 cmp	 BYTE PTR [ebx+2], 1
  00086	75 57		 jne	 SHORT $LN9@gObjNotify

; 18344: 		{
; 18345: 			LPOBJ lpTargetObj = &gObj[lpObj->VpPlayer[n].number];

  00088	0f bf f0	 movsx	 esi, ax
  0008b	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00091	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 18346: 
; 18347: 			if(lpTargetObj == 0)

  00097	74 46		 je	 SHORT $LN9@gObjNotify

; 18348: 			{
; 18349: 				continue;
; 18350: 			}
; 18351: 
; 18352: 			if(lpTargetObj->lpGuild == 0)

  00099	83 be b4 02 00
	00 00		 cmp	 DWORD PTR [esi+692], 0
  000a0	74 3d		 je	 SHORT $LN9@gObjNotify

; 18353: 			{
; 18354: 				continue;
; 18355: 			}
; 18356: 
; 18357: 			gObjGetGuildUnionName(lpTargetObj,lpMsgBody[iVp1Count].szUnionName,sizeof(lpMsgBody[iVp1Count].szUnionName));

  000a2	6a 08		 push	 8
  000a4	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000a7	50		 push	 eax
  000a8	56		 push	 esi
  000a9	e8 00 00 00 00	 call	 ?gObjGetGuildUnionName@@YAXPAUOBJECTSTRUCT@@PADH@Z ; gObjGetGuildUnionName

; 18358: 
; 18359: 			lpMsgBody[iVp1Count].btGuildRelationShip = gObjGetRelationShip(lpObj,lpTargetObj);

  000ae	8b 8d 80 e8 ff
	ff		 mov	 ecx, DWORD PTR _lpObj$GSCopy$[ebp]
  000b4	56		 push	 esi
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 ?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjGetRelationShip

; 18360: 			lpMsgBody[iVp1Count].btNumberL = SET_NUMBERL(WORD(lpTargetObj->m_Index));

  000bb	8a 16		 mov	 dl, BYTE PTR [esi]

; 18361: 			lpMsgBody[iVp1Count].btNumberH = SET_NUMBERH(WORD(lpTargetObj->m_Index));
; 18362: 			lpMsgBody[iVp1Count].iGuildNumber = lpTargetObj->lpGuild->Number;

  000bd	8b 8e b4 02 00
	00		 mov	 ecx, DWORD PTR [esi+692]

; 18363: 			iVp1Count++;

  000c3	ff 85 88 e8 ff
	ff		 inc	 DWORD PTR _iVp1Count$[ebp]
  000c9	88 07		 mov	 BYTE PTR [edi], al
  000cb	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  000ce	88 57 f9	 mov	 BYTE PTR [edi-7], dl
  000d1	88 47 f8	 mov	 BYTE PTR [edi-8], al
  000d4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d6	83 c4 14	 add	 esp, 20			; 00000014H
  000d9	89 57 fc	 mov	 DWORD PTR [edi-4], edx
  000dc	83 c7 14	 add	 edi, 20			; 00000014H
$LN9@gObjNotify:

; 18331: 
; 18332: 	PMSG_UNION_VIEWPORT_NOTIFY_COUNT * lpMsg = (PMSG_UNION_VIEWPORT_NOTIFY_COUNT *)&cBUFFER_V1;
; 18333: 	PMSG_UNION_VIEWPORT_NOTIFY * lpMsgBody = (PMSG_UNION_VIEWPORT_NOTIFY * )&cBUFFER_V1[sizeof(PMSG_UNION_VIEWPORT_NOTIFY_COUNT)];
; 18334: 
; 18335: 
; 18336: 	for(int n = 0; n < MAX_VIEWPORT; n++)

  000df	83 c3 0c	 add	 ebx, 12			; 0000000cH
  000e2	ff 8d 84 e8 ff
	ff		 dec	 DWORD PTR tv246[ebp]
  000e8	0f 85 73 ff ff
	ff		 jne	 $LL21@gObjNotify

; 18364: 		}
; 18365: 	}
; 18366: 
; 18367: 	if(iVp1Count > 0 && iVp1Count <= MAX_VIEWPORT)

  000ee	8b 85 88 e8 ff
	ff		 mov	 eax, DWORD PTR _iVp1Count$[ebp]
  000f4	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	83 f9 4a	 cmp	 ecx, 74			; 0000004aH
  000fc	77 5a		 ja	 SHORT $LN3@gObjNotify

; 18368: 	{
; 18369: 		lpMsg->btCount = iVp1Count;
; 18370: 
; 18371: 		PHeadSetW((unsigned char *)lpMsg,0x67,iVp1Count * sizeof(PMSG_UNION_VIEWPORT_NOTIFY) + sizeof(PMSG_UNION_VIEWPORT_NOTIFY_COUNT));

  000fe	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00101	88 85 90 e8 ff
	ff		 mov	 BYTE PTR _cBUFFER_V1$[ebp+4], al
  00107	8d 04 95 05 00
	00 00		 lea	 eax, DWORD PTR [edx*4+5]
  0010e	50		 push	 eax
  0010f	8d 8d 8c e8 ff
	ff		 lea	 ecx, DWORD PTR _cBUFFER_V1$[ebp]
  00115	6a 67		 push	 103			; 00000067H
  00117	51		 push	 ecx
  00118	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 18372: 
; 18373: 		DataSend(lpObj->m_Index,(unsigned char *)lpMsg,((lpMsg->h.sizeL & 0xFF) & 0xFF | ((lpMsg->h.sizeH & 0xFF) & 0xFF) << 8) & 0xFFFF);

  0011d	0f b6 95 8d e8
	ff ff		 movzx	 edx, BYTE PTR _cBUFFER_V1$[ebp+1]
  00124	0f b6 85 8e e8
	ff ff		 movzx	 eax, BYTE PTR _cBUFFER_V1$[ebp+2]
  0012b	c1 e2 08	 shl	 edx, 8
  0012e	0b d0		 or	 edx, eax
  00130	52		 push	 edx
  00131	8b 95 80 e8 ff
	ff		 mov	 edx, DWORD PTR _lpObj$GSCopy$[ebp]
  00137	8b 02		 mov	 eax, DWORD PTR [edx]
  00139	8d 8d 8c e8 ff
	ff		 lea	 ecx, DWORD PTR _cBUFFER_V1$[ebp]
  0013f	51		 push	 ecx
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00146	83 c4 18	 add	 esp, 24			; 00000018H
  00149	5b		 pop	 ebx

; 18380: 		}
; 18381: 	}
; 18382: }

  0014a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014d	33 cd		 xor	 ecx, ebp
  0014f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c3		 ret	 0
$LN3@gObjNotify:

; 18374: 	}
; 18375: 	else
; 18376: 	{
; 18377: 		if(iVp1Count != 0)

  00158	85 c0		 test	 eax, eax
  0015a	74 10		 je	 SHORT $LN1@gObjNotify

; 18378: 		{
; 18379: 			LogAdd(LOG_BLACK, "[Union ViewPort] ERROR : iVp1Count is OUT of BOUND: %d",iVp1Count);

  0015c	50		 push	 eax
  0015d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@GADDHGKB@?$FLUnion?5ViewPort?$FN?5ERROR?5?3?5iVp1Cou@
  00162	6a 00		 push	 0
  00164	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00169	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjNotify:

; 18380: 		}
; 18381: 	}
; 18382: }

  0016c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016f	33 cd		 xor	 ecx, ebp
  00171	5b		 pop	 ebx
  00172	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
?gObjNotifyUpdateUnionV1@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjNotifyUpdateUnionV1
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjNotifyUpdateUnionV2@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNotifyUpdateUnionV2
; Function compile flags: /Ogtp
;	COMDAT ?gObjNotifyUpdateUnionV2@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_cBUFFER_V2$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjNotifyUpdateUnionV2@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjNotifyUpdateUnionV2, COMDAT

; 18385: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]

; 18386: 	if(lpObj == 0)

  00014	85 ff		 test	 edi, edi
  00016	0f 84 e0 00 00
	00		 je	 $LN4@gObjNotify@2

; 18387: 	{
; 18388: 		return;
; 18389: 	}
; 18390: 
; 18391: 	if(lpObj->lpGuild == 0)

  0001c	83 bf b4 02 00
	00 00		 cmp	 DWORD PTR [edi+692], 0
  00023	0f 84 d3 00 00
	00		 je	 $LN4@gObjNotify@2

; 18392: 	{
; 18393: 		return;
; 18394: 	}
; 18395: 
; 18396: 	char cBUFFER_V2[100] = {0};

  00029	53		 push	 ebx
  0002a	56		 push	 esi
  0002b	6a 63		 push	 99			; 00000063H
  0002d	8d 45 99	 lea	 eax, DWORD PTR _cBUFFER_V2$[ebp+1]
  00030	6a 00		 push	 0
  00032	50		 push	 eax
  00033	c6 45 98 00	 mov	 BYTE PTR _cBUFFER_V2$[ebp], 0
  00037	e8 00 00 00 00	 call	 _memset

; 18397: 
; 18398: 	PMSG_UNION_VIEWPORT_NOTIFY_COUNT * lpMsg2 = (PMSG_UNION_VIEWPORT_NOTIFY_COUNT *)&cBUFFER_V2;
; 18399: 	PMSG_UNION_VIEWPORT_NOTIFY * lpMsgBody2 = (PMSG_UNION_VIEWPORT_NOTIFY *)&cBUFFER_V2[sizeof(PMSG_UNION_VIEWPORT_NOTIFY_COUNT)];
; 18400: 
; 18401: 	gObjGetGuildUnionName(lpObj,lpMsgBody2->szUnionName,sizeof(lpMsgBody2->szUnionName));

  0003c	6a 08		 push	 8
  0003e	8d 4d a6	 lea	 ecx, DWORD PTR _cBUFFER_V2$[ebp+14]
  00041	51		 push	 ecx
  00042	57		 push	 edi
  00043	e8 00 00 00 00	 call	 ?gObjGetGuildUnionName@@YAXPAUOBJECTSTRUCT@@PADH@Z ; gObjGetGuildUnionName

; 18402: 	lpMsgBody2->btNumberL = SET_NUMBERL(WORD(lpObj->m_Index));
; 18403: 	lpMsgBody2->btNumberH = SET_NUMBERH(WORD(lpObj->m_Index));

  00048	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0004b	8a 17		 mov	 dl, BYTE PTR [edi]

; 18404: 
; 18405: 	lpMsgBody2->iGuildNumber = lpObj->lpGuild->Number;

  0004d	8b 8f b4 02 00
	00		 mov	 ecx, DWORD PTR [edi+692]
  00053	88 45 9d	 mov	 BYTE PTR _cBUFFER_V2$[ebp+5], al

; 18406: 	lpMsgBody2->btGuildRelationShip = 0;
; 18407: 	lpMsg2->btCount = 1;
; 18408: 
; 18409: 	PHeadSetW((unsigned char *)lpMsg2,0x67,sizeof(lpMsg2) + sizeof(lpMsgBody2[0])+1);

  00056	6a 19		 push	 25			; 00000019H
  00058	88 55 9e	 mov	 BYTE PTR _cBUFFER_V2$[ebp+6], dl
  0005b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005d	8d 45 98	 lea	 eax, DWORD PTR _cBUFFER_V2$[ebp]
  00060	6a 67		 push	 103			; 00000067H
  00062	50		 push	 eax
  00063	89 55 a1	 mov	 DWORD PTR _cBUFFER_V2$[ebp+9], edx
  00066	c6 45 a5 00	 mov	 BYTE PTR _cBUFFER_V2$[ebp+13], 0
  0006a	c6 45 9c 01	 mov	 BYTE PTR _cBUFFER_V2$[ebp+4], 1
  0006e	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 18410: 
; 18411: 	DataSend(lpObj->m_Index,(unsigned char *)lpMsg2,((lpMsg2->h.sizeL & 0xFF) & 0xFF | ((lpMsg2->h.sizeH & 0xFF) & 0xFF) << 8) & 0xFFFF);

  00073	0f b6 4d 99	 movzx	 ecx, BYTE PTR _cBUFFER_V2$[ebp+1]
  00077	0f b6 55 9a	 movzx	 edx, BYTE PTR _cBUFFER_V2$[ebp+2]
  0007b	c1 e1 08	 shl	 ecx, 8
  0007e	0b ca		 or	 ecx, edx
  00080	51		 push	 ecx
  00081	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00083	8d 45 98	 lea	 eax, DWORD PTR _cBUFFER_V2$[ebp]
  00086	50		 push	 eax
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008d	83 c4 30	 add	 esp, 48			; 00000030H
  00090	8d b7 16 07 00
	00		 lea	 esi, DWORD PTR [edi+1814]
  00096	bb 4b 00 00 00	 mov	 ebx, 75			; 0000004bH
  0009b	eb 03 8d 49 00	 npad	 5
$LL6@gObjNotify@2:

; 18414: 	{
; 18415: 		if(lpObj->VpPlayer2[n].type == OBJ_USER && lpObj->VpPlayer2[n].state != 0)

  000a0	80 7e 02 01	 cmp	 BYTE PTR [esi+2], 1
  000a4	75 4e		 jne	 SHORT $LN5@gObjNotify@2
  000a6	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  000aa	74 48		 je	 SHORT $LN5@gObjNotify@2

; 18416: 		{
; 18417: 			LPOBJ lpTargetObj = &gObj[lpObj->VpPlayer2[n].number];

  000ac	0f bf 06	 movsx	 eax, WORD PTR [esi]
  000af	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000b5	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 18418: 
; 18419: 			if(lpTargetObj->lpGuild != 0)

  000ba	83 b8 b4 02 00
	00 00		 cmp	 DWORD PTR [eax+692], 0
  000c1	74 0d		 je	 SHORT $LN13@gObjNotify@2

; 18420: 			{
; 18421: 				lpMsgBody2->btGuildRelationShip = gObjGetRelationShip(lpTargetObj,lpObj);

  000c3	57		 push	 edi
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjGetRelationShip
  000ca	83 c4 08	 add	 esp, 8
  000cd	88 45 a5	 mov	 BYTE PTR _cBUFFER_V2$[ebp+13], al
$LN13@gObjNotify@2:

; 18422: 			}
; 18423: 
; 18424: 			if(lpMsgBody2->btGuildRelationShip != 1)

  000d0	80 7d a5 01	 cmp	 BYTE PTR _cBUFFER_V2$[ebp+13], 1
  000d4	74 1e		 je	 SHORT $LN5@gObjNotify@2

; 18425: 			{
; 18426: 				DataSend(lpObj->VpPlayer2[n].number,(unsigned char *)lpMsg2,((lpMsg2->h.sizeL & 0xFF) & 0xFF | ((lpMsg2->h.sizeH & 0xFF) & 0xFF) << 8) & 0xFFFF);

  000d6	0f b6 55 99	 movzx	 edx, BYTE PTR _cBUFFER_V2$[ebp+1]
  000da	0f b6 45 9a	 movzx	 eax, BYTE PTR _cBUFFER_V2$[ebp+2]
  000de	c1 e2 08	 shl	 edx, 8
  000e1	0b d0		 or	 edx, eax
  000e3	52		 push	 edx
  000e4	0f bf 16	 movsx	 edx, WORD PTR [esi]
  000e7	8d 4d 98	 lea	 ecx, DWORD PTR _cBUFFER_V2$[ebp]
  000ea	51		 push	 ecx
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@gObjNotify@2:

; 18412: 
; 18413: 	for(int n = 0; n < MAX_VIEWPORT; n++)

  000f4	83 c6 0c	 add	 esi, 12			; 0000000cH
  000f7	4b		 dec	 ebx
  000f8	75 a6		 jne	 SHORT $LL6@gObjNotify@2
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx
$LN4@gObjNotify@2:

; 18427: 			}
; 18428: 		}
; 18429: 	}
; 18430: }

  000fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ff	33 cd		 xor	 ecx, ebp
  00101	5f		 pop	 edi
  00102	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c3		 ret	 0
?gObjNotifyUpdateUnionV2@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjNotifyUpdateUnionV2
_TEXT	ENDS
PUBLIC	?gObjUnionUpdateProc@@YAXH@Z			; gObjUnionUpdateProc
; Function compile flags: /Ogtp
;	COMDAT ?gObjUnionUpdateProc@@YAXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?gObjUnionUpdateProc@@YAXH@Z PROC			; gObjUnionUpdateProc, COMDAT

; 18433: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 18434: 
; 18435: 	if ( gObjIsConnected(iIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 4f		 je	 SHORT $LN7@gObjUnionU

; 18436: 	{
; 18437: 		return;
; 18438: 	}
; 18439: 
; 18440: 	LPOBJ lpObj = &gObj[iIndex];

  00014	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0001a	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 18441: 
; 18442: 	if ( lpObj->Type != OBJ_USER )

  00020	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00025	75 3c		 jne	 SHORT $LN7@gObjUnionU

; 18443: 	{
; 18444: 		return;
; 18445: 	}
; 18446: 
; 18447: 	if ( lpObj->RegenOk > 0 )

  00027	80 be 03 02 00
	00 00		 cmp	 BYTE PTR [esi+515], 0
  0002e	7f 33		 jg	 SHORT $LN7@gObjUnionU

; 18448: 	{
; 18449: 		return;
; 18450: 	}
; 18451: 
; 18452: 	if ( lpObj->CloseCount > -1 )

  00030	80 7e 07 ff	 cmp	 BYTE PTR [esi+7], -1
  00034	7f 2d		 jg	 SHORT $LN7@gObjUnionU

; 18453: 		return;
; 18454: 
; 18455: 	if ( lpObj->lpGuild == NULL )

  00036	8b 86 b4 02 00
	00		 mov	 eax, DWORD PTR [esi+692]
  0003c	85 c0		 test	 eax, eax
  0003e	74 23		 je	 SHORT $LN7@gObjUnionU

; 18456: 	{
; 18457: 		return;
; 18458: 	}
; 18459: 
; 18460: 	if ( lpObj->lpGuild->CheckTimeStamp(lpObj->iGuildUnionTimeStamp) != FALSE )

  00040	8b 80 24 07 00
	00		 mov	 eax, DWORD PTR [eax+1828]
  00046	39 86 c8 02 00
	00		 cmp	 DWORD PTR [esi+712], eax
  0004c	74 15		 je	 SHORT $LN7@gObjUnionU

; 18461: 	{
; 18462: 		return;
; 18463: 	}
; 18464: 
; 18465: 	lpObj->iGuildUnionTimeStamp = lpObj->lpGuild->GetTimeStamp();
; 18466: 	gObjNotifyUpdateUnionV1(lpObj);

  0004e	56		 push	 esi
  0004f	89 86 c8 02 00
	00		 mov	 DWORD PTR [esi+712], eax
  00055	e8 00 00 00 00	 call	 ?gObjNotifyUpdateUnionV1@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNotifyUpdateUnionV1

; 18467: 	gObjNotifyUpdateUnionV2(lpObj);

  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 ?gObjNotifyUpdateUnionV2@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNotifyUpdateUnionV2
  00060	83 c4 08	 add	 esp, 8
$LN7@gObjUnionU:
  00063	5e		 pop	 esi

; 18468: 
; 18469: }

  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?gObjUnionUpdateProc@@YAXH@Z ENDP			; gObjUnionUpdateProc
_TEXT	ENDS
PUBLIC	?gObjSetKillCount@@YAXHH@Z			; gObjSetKillCount
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
; Function compile flags: /Ogtp
;	COMDAT ?gObjSetKillCount@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_iOption$ = 12						; size = 4
?gObjSetKillCount@@YAXHH@Z PROC				; gObjSetKillCount, COMDAT

; 18473: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi

; 18474: 	if ( gObjIsConnected(aIndex) == FALSE )

  00007	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000a	57		 push	 edi
  0000b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00010	83 c4 04	 add	 esp, 4
  00013	85 c0		 test	 eax, eax
  00015	0f 84 81 00 00
	00		 je	 $LN9@gObjSetKil

; 18475: 	{
; 18476: 		return;
; 18477: 	}
; 18478: 
; 18479: 	LPOBJ lpObj = &gObj[aIndex];
; 18480: 
; 18481: 	if ( iOption== 1 )

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _iOption$[ebp]
  0001e	56		 push	 esi
  0001f	8b f7		 mov	 esi, edi
  00021	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00027	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002d	33 c9		 xor	 ecx, ecx
  0002f	83 f8 01	 cmp	 eax, 1
  00032	75 14		 jne	 SHORT $LN7@gObjSetKil

; 18482: 	{
; 18483: 		if ( lpObj->m_btKillCount <= 254 )

  00034	8a 86 d8 14 00
	00		 mov	 al, BYTE PTR [esi+5336]
  0003a	3c fe		 cmp	 al, 254			; 000000feH
  0003c	77 2d		 ja	 SHORT $LN1@gObjSetKil

; 18484: 		{
; 18485: 			lpObj->m_btKillCount++;

  0003e	fe c0		 inc	 al
  00040	88 86 d8 14 00
	00		 mov	 BYTE PTR [esi+5336], al

; 18486: 		}
; 18487: 	}

  00046	eb 23		 jmp	 SHORT $LN1@gObjSetKil
$LN7@gObjSetKil:

; 18488: 	else if ( iOption == 2 )

  00048	83 f8 02	 cmp	 eax, 2
  0004b	75 14		 jne	 SHORT $LN4@gObjSetKil

; 18489: 	{
; 18490: 		if ( lpObj->m_btKillCount > 0 )

  0004d	8a 86 d8 14 00
	00		 mov	 al, BYTE PTR [esi+5336]
  00053	3a c1		 cmp	 al, cl
  00055	76 14		 jbe	 SHORT $LN1@gObjSetKil

; 18491: 		{
; 18492: 			lpObj->m_btKillCount--;

  00057	fe c8		 dec	 al
  00059	88 86 d8 14 00
	00		 mov	 BYTE PTR [esi+5336], al

; 18493: 		}
; 18494: 	}

  0005f	eb 0a		 jmp	 SHORT $LN1@gObjSetKil
$LN4@gObjSetKil:

; 18495: 	else if ( iOption == 0 )

  00061	3b c1		 cmp	 eax, ecx
  00063	75 06		 jne	 SHORT $LN1@gObjSetKil

; 18496: 	{
; 18497: 		lpObj->m_btKillCount = 0;

  00065	88 8e d8 14 00
	00		 mov	 BYTE PTR [esi+5336], cl
$LN1@gObjSetKil:

; 18498: 	}
; 18499: 
; 18500: 	PMSG_KILLCOUNT pMsg = {0};
; 18501: 	PHeadSubSetB((LPBYTE)&pMsg, 0xB8,0x01, sizeof(pMsg));

  0006b	6a 05		 push	 5
  0006d	6a 01		 push	 1
  0006f	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00072	68 b8 00 00 00	 push	 184			; 000000b8H
  00077	50		 push	 eax
  00078	88 4d f8	 mov	 BYTE PTR _pMsg$[ebp], cl
  0007b	89 4d f9	 mov	 DWORD PTR _pMsg$[ebp+1], ecx
  0007e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 18502: 	pMsg.btKillCount = lpObj->m_btKillCount;

  00083	8a 8e d8 14 00
	00		 mov	 cl, BYTE PTR [esi+5336]

; 18503: 	
; 18504: 	DataSend( aIndex, (UCHAR*)&pMsg, sizeof(pMsg));

  00089	6a 05		 push	 5
  0008b	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0008e	52		 push	 edx
  0008f	57		 push	 edi
  00090	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00093	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00098	83 c4 1c	 add	 esp, 28			; 0000001cH
  0009b	5e		 pop	 esi
$LN9@gObjSetKil:
  0009c	5f		 pop	 edi

; 18505: }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
?gObjSetKillCount@@YAXHH@Z ENDP				; gObjSetKillCount
_TEXT	ENDS
PUBLIC	_lpOwnerObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjNotifyUseWeaponV1@@YAXPAUOBJECTSTRUCT@@0HH@Z ; gObjNotifyUseWeaponV1
; Function compile flags: /Ogtp
;	COMDAT ?gObjNotifyUseWeaponV1@@YAXPAUOBJECTSTRUCT@@0HH@Z
_TEXT	SEGMENT
_lpOwnerObj$GSCopy$ = -6032				; size = 4
_iVp1Count$ = -6028					; size = 4
_n$168359 = -6024					; size = 4
_pNotifyTargetMsg$ = -6020				; size = 7
_pNotifyRegionMsg$ = -6012				; size = 7
_cBUFFER_V1$ = -6004					; size = 6000
__$ArrayPad$ = -4					; size = 4
_lpOwnerObj$ = 8					; size = 4
_lpWeaponObj$ = 12					; size = 4
_iTargetX$ = 16						; size = 4
_iTargetY$ = 20						; size = 4
?gObjNotifyUseWeaponV1@@YAXPAUOBJECTSTRUCT@@0HH@Z PROC	; gObjNotifyUseWeaponV1, COMDAT

; 18550: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 90 17 00 00	 mov	 eax, 6032		; 00001790H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR _lpOwnerObj$[ebp]
  0001a	53		 push	 ebx

; 18551: 	if(lpOwnerObj == 0)

  0001b	33 db		 xor	 ebx, ebx

; 18587: 
; 18588: 	PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY_COUNT * lpMsg = (PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY_COUNT *)&cBUFFER_V1;
; 18589: 	PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY * lpMsgBody = (PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY *)&cBUFFER_V1[sizeof(PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY_COUNT)];
; 18590: 
; 18591: 	for(int n = 0; n < OBJMAX;n++)

  0001d	89 85 70 e8 ff
	ff		 mov	 DWORD PTR _lpOwnerObj$GSCopy$[ebp], eax
  00023	3b c3		 cmp	 eax, ebx
  00025	0f 84 a6 02 00
	00		 je	 $LN1@gObjNotify@3

; 18552: 	{
; 18553: 		return;
; 18554: 	}
; 18555: 
; 18556: 	if(lpWeaponObj == 0)

  0002b	56		 push	 esi
  0002c	8b 75 0c	 mov	 esi, DWORD PTR _lpWeaponObj$[ebp]
  0002f	3b f3		 cmp	 esi, ebx
  00031	0f 84 99 02 00
	00		 je	 $LN28@gObjNotify@3

; 18557: 	{
; 18558: 		return;
; 18559: 	}
; 18560: 
; 18561: 	PMSG_NOTIFY_REGION_OF_WEAPON pNotifyRegionMsg = {0};

  00037	33 c0		 xor	 eax, eax

; 18562: 
; 18563: 	PHeadSubSetB((unsigned char *)&pNotifyRegionMsg,0xB7,2,sizeof(pNotifyRegionMsg));

  00039	6a 07		 push	 7
  0003b	6a 02		 push	 2
  0003d	89 85 85 e8 ff
	ff		 mov	 DWORD PTR _pNotifyRegionMsg$[ebp+1], eax
  00043	66 89 85 89 e8
	ff ff		 mov	 WORD PTR _pNotifyRegionMsg$[ebp+5], ax
  0004a	8d 85 84 e8 ff
	ff		 lea	 eax, DWORD PTR _pNotifyRegionMsg$[ebp]
  00050	68 b7 00 00 00	 push	 183			; 000000b7H
  00055	50		 push	 eax
  00056	88 9d 84 e8 ff
	ff		 mov	 BYTE PTR _pNotifyRegionMsg$[ebp], bl
  0005c	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 18564: 
; 18565: 	pNotifyRegionMsg.btPointX = iTargetX;

  00061	8a 4d 10	 mov	 cl, BYTE PTR _iTargetX$[ebp]

; 18566: 	pNotifyRegionMsg.btPointY = iTargetY;

  00064	8a 55 14	 mov	 dl, BYTE PTR _iTargetY$[ebp]

; 18567: 
; 18568: 	PMSG_NOTIFY_TARGET_OF_WEAPON pNotifyTargetMsg = {0};

  00067	33 c0		 xor	 eax, eax

; 18569: 
; 18570: 	PHeadSubSetB((unsigned char *)&pNotifyTargetMsg,0xB7,3,sizeof(pNotifyTargetMsg));

  00069	6a 07		 push	 7
  0006b	6a 03		 push	 3
  0006d	89 85 7d e8 ff
	ff		 mov	 DWORD PTR _pNotifyTargetMsg$[ebp+1], eax
  00073	66 89 85 81 e8
	ff ff		 mov	 WORD PTR _pNotifyTargetMsg$[ebp+5], ax
  0007a	8d 85 7c e8 ff
	ff		 lea	 eax, DWORD PTR _pNotifyTargetMsg$[ebp]
  00080	68 b7 00 00 00	 push	 183			; 000000b7H
  00085	50		 push	 eax
  00086	88 8d 89 e8 ff
	ff		 mov	 BYTE PTR _pNotifyRegionMsg$[ebp+5], cl
  0008c	88 95 8a e8 ff
	ff		 mov	 BYTE PTR _pNotifyRegionMsg$[ebp+6], dl
  00092	88 9d 7c e8 ff
	ff		 mov	 BYTE PTR _pNotifyTargetMsg$[ebp], bl
  00098	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 18571: 
; 18572: 	if(lpWeaponObj->Class == 0xDD)

  0009d	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  000a4	b9 dd 00 00 00	 mov	 ecx, 221		; 000000ddH
  000a9	83 c4 20	 add	 esp, 32			; 00000020H
  000ac	66 3b c1	 cmp	 ax, cx
  000af	75 10		 jne	 SHORT $LN18@gObjNotify@3

; 18573: 	{
; 18574: 		pNotifyRegionMsg.btWeaponType = 1;

  000b1	c6 85 88 e8 ff
	ff 01		 mov	 BYTE PTR _pNotifyRegionMsg$[ebp+4], 1

; 18575: 		pNotifyTargetMsg.btWeaponType = 1;

  000b8	c6 85 82 e8 ff
	ff 01		 mov	 BYTE PTR _pNotifyTargetMsg$[ebp+6], 1
  000bf	eb 18		 jmp	 SHORT $LN16@gObjNotify@3
$LN18@gObjNotify@3:

; 18576: 	}
; 18577: 	else if(lpWeaponObj->Class == 0xDE)

  000c1	ba de 00 00 00	 mov	 edx, 222		; 000000deH
  000c6	66 3b c2	 cmp	 ax, dx
  000c9	75 0e		 jne	 SHORT $LN16@gObjNotify@3

; 18578: 	{
; 18579: 		pNotifyRegionMsg.btWeaponType = 2;

  000cb	c6 85 88 e8 ff
	ff 02		 mov	 BYTE PTR _pNotifyRegionMsg$[ebp+4], 2

; 18580: 		pNotifyTargetMsg.btWeaponType = 2;

  000d2	c6 85 82 e8 ff
	ff 02		 mov	 BYTE PTR _pNotifyTargetMsg$[ebp+6], 2
$LN16@gObjNotify@3:

; 18581: 	}
; 18582: 
; 18583: 	char cBUFFER_V1[6000];
; 18584: 	int iVp1Count = 0;
; 18585: 
; 18586: 	memset(cBUFFER_V1,0x00,sizeof(cBUFFER_V1));

  000d9	57		 push	 edi
  000da	68 70 17 00 00	 push	 6000			; 00001770H
  000df	8d 85 8c e8 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER_V1$[ebp]
  000e5	53		 push	 ebx
  000e6	50		 push	 eax
  000e7	89 9d 74 e8 ff
	ff		 mov	 DWORD PTR _iVp1Count$[ebp], ebx
  000ed	e8 00 00 00 00	 call	 _memset
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18587: 
; 18588: 	PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY_COUNT * lpMsg = (PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY_COUNT *)&cBUFFER_V1;
; 18589: 	PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY * lpMsgBody = (PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY *)&cBUFFER_V1[sizeof(PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY_COUNT)];
; 18590: 
; 18591: 	for(int n = 0; n < OBJMAX;n++)

  000f5	89 9d 78 e8 ff
	ff		 mov	 DWORD PTR _n$168359[ebp], ebx
  000fb	bf 98 00 00 00	 mov	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+152
  00100	8d b5 96 e8 ff
	ff		 lea	 esi, DWORD PTR _cBUFFER_V1$[ebp+10]
  00106	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL15@gObjNotify@3:

; 18592: 	{
; 18593: 		LPOBJ lpTargetObj = &gObj[n];
; 18594: 
; 18595: 		if(gObjIsConnected(n) == 0)

  00110	8b 8d 78 e8 ff
	ff		 mov	 ecx, DWORD PTR _n$168359[ebp]
  00116	51		 push	 ecx
  00117	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0011c	83 c4 04	 add	 esp, 4
  0011f	85 c0		 test	 eax, eax
  00121	0f 84 31 01 00
	00		 je	 $LN14@gObjNotify@3

; 18596: 		{
; 18597: 			continue;
; 18598: 		}
; 18599: 
; 18600: 		if(lpOwnerObj->MapNumber != lpTargetObj->MapNumber)

  00127	8b 95 70 e8 ff
	ff		 mov	 edx, DWORD PTR _lpOwnerObj$GSCopy$[ebp]
  0012d	8a 82 09 01 00
	00		 mov	 al, BYTE PTR [edx+265]
  00133	3a 47 71	 cmp	 al, BYTE PTR [edi+113]
  00136	0f 85 1c 01 00
	00		 jne	 $LN14@gObjNotify@3

; 18601: 		{
; 18602: 			continue;
; 18603: 		}
; 18604: 
; 18605: 		if(abs(lpTargetObj->X - iTargetX) > 6)

  0013c	0f bf 47 6c	 movsx	 eax, WORD PTR [edi+108]
  00140	2b 45 10	 sub	 eax, DWORD PTR _iTargetX$[ebp]
  00143	99		 cdq
  00144	33 c2		 xor	 eax, edx
  00146	2b c2		 sub	 eax, edx
  00148	83 f8 06	 cmp	 eax, 6
  0014b	0f 8f 07 01 00
	00		 jg	 $LN14@gObjNotify@3

; 18606: 		{
; 18607: 			continue;
; 18608: 		}
; 18609: 
; 18610: 		if(abs(lpTargetObj->Y - iTargetY) > 6)

  00151	0f bf 47 6e	 movsx	 eax, WORD PTR [edi+110]
  00155	2b 45 14	 sub	 eax, DWORD PTR _iTargetY$[ebp]
  00158	99		 cdq
  00159	33 c2		 xor	 eax, edx
  0015b	2b c2		 sub	 eax, edx
  0015d	83 f8 06	 cmp	 eax, 6
  00160	0f 8f f2 00 00
	00		 jg	 $LN14@gObjNotify@3

; 18611: 		{
; 18612: 			continue;
; 18613: 		}
; 18614: 
; 18615: 		lpMsgBody[iVp1Count].btObjClassH = SET_NUMBERH(lpTargetObj->Class);

  00166	0f b6 4f 01	 movzx	 ecx, BYTE PTR [edi+1]

; 18616: 		lpMsgBody[iVp1Count].btObjClassL = SET_NUMBERL(lpTargetObj->Class);
; 18617: 		lpMsgBody[iVp1Count].btObjIndexH = SET_NUMBERH(lpTargetObj->m_Index);
; 18618: 		lpMsgBody[iVp1Count].btObjIndexH = SET_NUMBERL(lpTargetObj->m_Index);

  0016a	0f b6 97 68 ff
	ff ff		 movzx	 edx, BYTE PTR [edi-152]
  00171	8a 07		 mov	 al, BYTE PTR [edi]
  00173	88 4e fc	 mov	 BYTE PTR [esi-4], cl

; 18619: 		// lpMsgBody[iVp1Count].btObjIndexL = SET_NUMBERL(lpTargetObj->m_Index); need some testing here 
; 18620: 		lpMsgBody[iVp1Count].btX = lpTargetObj->X;

  00176	0f b6 4f 6c	 movzx	 ecx, BYTE PTR [edi+108]
  0017a	88 0e		 mov	 BYTE PTR [esi], cl

; 18621: 		lpMsgBody[iVp1Count].btY = lpTargetObj->Y;
; 18622: 		lpMsgBody[iVp1Count].dwViewSkillState = lpTargetObj->m_ViewSkillState;

  0017c	8b 8f 2c 01 00
	00		 mov	 ecx, DWORD PTR [edi+300]
  00182	89 4e 13	 mov	 DWORD PTR [esi+19], ecx

; 18623: 
; 18624: 		if(lpTargetObj->Type == OBJ_USER)

  00185	0f b7 4f c8	 movzx	 ecx, WORD PTR [edi-56]
  00189	88 56 fe	 mov	 BYTE PTR [esi-2], dl
  0018c	0f b6 57 6e	 movzx	 edx, BYTE PTR [edi+110]
  00190	88 46 fd	 mov	 BYTE PTR [esi-3], al
  00193	88 56 01	 mov	 BYTE PTR [esi+1], dl
  00196	83 f9 01	 cmp	 ecx, 1
  00199	75 3b		 jne	 SHORT $LN8@gObjNotify@3

; 18625: 		{
; 18626: 			lpMsgBody[iVp1Count].btObjType = OBJ_USER;
; 18627: 			lpMsgBody[iVp1Count].btObjClassH = CS_SET_CLASS(lpTargetObj->Class);
; 18628: 			lpMsgBody[iVp1Count].btObjClassL = 0;
; 18629: 
; 18630: 			memcpy(lpMsgBody[iVp1Count].CharSet,&lpTargetObj->CharSet[1],sizeof(lpMsgBody[iVp1Count].CharSet));

  0019b	8b 97 b9 02 00
	00		 mov	 edx, DWORD PTR [edi+697]
  001a1	c0 e0 05	 shl	 al, 5
  001a4	89 56 02	 mov	 DWORD PTR [esi+2], edx
  001a7	8b 97 c1 02 00
	00		 mov	 edx, DWORD PTR [edi+705]
  001ad	88 46 fc	 mov	 BYTE PTR [esi-4], al
  001b0	8b 87 bd 02 00
	00		 mov	 eax, DWORD PTR [edi+701]
  001b6	89 46 06	 mov	 DWORD PTR [esi+6], eax
  001b9	8b 87 c5 02 00
	00		 mov	 eax, DWORD PTR [edi+709]
  001bf	89 56 0a	 mov	 DWORD PTR [esi+10], edx
  001c2	8a 97 c9 02 00
	00		 mov	 dl, BYTE PTR [edi+713]
  001c8	89 46 0e	 mov	 DWORD PTR [esi+14], eax
  001cb	88 4e fb	 mov	 BYTE PTR [esi-5], cl
  001ce	88 5e fd	 mov	 BYTE PTR [esi-3], bl
  001d1	88 56 12	 mov	 BYTE PTR [esi+18], dl
  001d4	eb 1f		 jmp	 SHORT $LN5@gObjNotify@3
$LN8@gObjNotify@3:

; 18635: 			memset(lpMsgBody[iVp1Count].CharSet,0x00,sizeof(lpMsgBody[iVp1Count].CharSet));

  001d6	33 c0		 xor	 eax, eax
  001d8	83 f9 02	 cmp	 ecx, 2
  001db	75 05		 jne	 SHORT $LN6@gObjNotify@3

; 18631: 		}
; 18632: 		else if(lpTargetObj->Type == OBJ_MONSTER)
; 18633: 		{
; 18634: 			lpMsgBody[iVp1Count].btObjType = OBJ_MONSTER;

  001dd	88 4e fb	 mov	 BYTE PTR [esi-5], cl

; 18636: 		}
; 18637: 		else

  001e0	eb 04		 jmp	 SHORT $LN29@gObjNotify@3
$LN6@gObjNotify@3:

; 18638: 		{
; 18639: 			lpMsgBody[iVp1Count].btObjType = OBJ_NPC;

  001e2	c6 46 fb 03	 mov	 BYTE PTR [esi-5], 3
$LN29@gObjNotify@3:

; 18640: 			memset(lpMsgBody[iVp1Count].CharSet,0x00,sizeof(lpMsgBody[iVp1Count].CharSet));

  001e6	89 46 02	 mov	 DWORD PTR [esi+2], eax
  001e9	89 46 06	 mov	 DWORD PTR [esi+6], eax
  001ec	89 46 0a	 mov	 DWORD PTR [esi+10], eax
  001ef	89 46 0e	 mov	 DWORD PTR [esi+14], eax
  001f2	88 46 12	 mov	 BYTE PTR [esi+18], al
$LN5@gObjNotify@3:

; 18641: 		}
; 18642: 
; 18643: 		iVp1Count++;

  001f5	ff 85 74 e8 ff
	ff		 inc	 DWORD PTR _iVp1Count$[ebp]
  001fb	83 c6 1c	 add	 esi, 28			; 0000001cH

; 18644: 
; 18645: 		if(lpTargetObj->Type == OBJ_USER)

  001fe	83 f9 01	 cmp	 ecx, 1
  00201	75 55		 jne	 SHORT $LN14@gObjNotify@3

; 18646: 		{
; 18647: 			DataSend(lpTargetObj->m_Index,(unsigned char *)&pNotifyRegionMsg,sizeof(pNotifyRegionMsg));

  00203	8b 8f 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edi-152]
  00209	6a 07		 push	 7
  0020b	8d 85 84 e8 ff
	ff		 lea	 eax, DWORD PTR _pNotifyRegionMsg$[ebp]
  00211	50		 push	 eax
  00212	51		 push	 ecx
  00213	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18648: 
; 18649: 			if(abs(lpTargetObj->X - iTargetX) > 3)

  00218	0f bf 47 6c	 movsx	 eax, WORD PTR [edi+108]
  0021c	2b 45 10	 sub	 eax, DWORD PTR _iTargetX$[ebp]
  0021f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00222	99		 cdq
  00223	33 c2		 xor	 eax, edx
  00225	2b c2		 sub	 eax, edx
  00227	83 f8 03	 cmp	 eax, 3
  0022a	7f 2c		 jg	 SHORT $LN14@gObjNotify@3

; 18650: 			{
; 18651: 				continue;
; 18652: 			}
; 18653: 
; 18654: 			if(abs(lpTargetObj->Y - iTargetY) > 3)

  0022c	0f bf 47 6e	 movsx	 eax, WORD PTR [edi+110]
  00230	2b 45 14	 sub	 eax, DWORD PTR _iTargetY$[ebp]
  00233	99		 cdq
  00234	33 c2		 xor	 eax, edx
  00236	2b c2		 sub	 eax, edx
  00238	83 f8 03	 cmp	 eax, 3
  0023b	7f 1b		 jg	 SHORT $LN14@gObjNotify@3

; 18655: 			{
; 18656: 				continue;
; 18657: 			}
; 18658: 
; 18659: 			pNotifyTargetMsg.NumberH = SET_NUMBERH(lpTargetObj->m_Index);

  0023d	8b 97 68 ff ff
	ff		 mov	 edx, DWORD PTR [edi-152]

; 18660: 			pNotifyTargetMsg.NumberL = SET_NUMBERL(lpTargetObj->m_Index);

  00243	8a 87 68 ff ff
	ff		 mov	 al, BYTE PTR [edi-152]
  00249	c1 ea 08	 shr	 edx, 8
  0024c	88 95 80 e8 ff
	ff		 mov	 BYTE PTR _pNotifyTargetMsg$[ebp+4], dl
  00252	88 85 81 e8 ff
	ff		 mov	 BYTE PTR _pNotifyTargetMsg$[ebp+5], al
$LN14@gObjNotify@3:

; 18587: 
; 18588: 	PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY_COUNT * lpMsg = (PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY_COUNT *)&cBUFFER_V1;
; 18589: 	PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY * lpMsgBody = (PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY *)&cBUFFER_V1[sizeof(PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY_COUNT)];
; 18590: 
; 18591: 	for(int n = 0; n < OBJMAX;n++)

  00258	ff 85 78 e8 ff
	ff		 inc	 DWORD PTR _n$168359[ebp]
  0025e	81 c7 64 15 00
	00		 add	 edi, 5476		; 00001564H
  00264	81 ff 38 53 6a
	02		 cmp	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522552
  0026a	0f 8c a0 fe ff
	ff		 jl	 $LL15@gObjNotify@3

; 18661: 		}
; 18662: 	}
; 18663: 
; 18664: 	if(iVp1Count > 0 && iVp1Count <= 100)

  00270	8b 85 74 e8 ff
	ff		 mov	 eax, DWORD PTR _iVp1Count$[ebp]
  00276	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00279	5f		 pop	 edi
  0027a	83 f9 63	 cmp	 ecx, 99			; 00000063H
  0027d	77 51		 ja	 SHORT $LN28@gObjNotify@3

; 18665: 	{
; 18666: 		lpMsg->btCount = iVp1Count;
; 18667: 		PHeadSetW((unsigned char *)lpMsg,0x68,iVp1Count * sizeof(PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY) + sizeof(PMSG_WEAPON_OWNER_VIEWPORT_NOTIFY_COUNT));

  0027f	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00286	2b d0		 sub	 edx, eax
  00288	88 85 90 e8 ff
	ff		 mov	 BYTE PTR _cBUFFER_V1$[ebp+4], al
  0028e	8d 04 95 05 00
	00 00		 lea	 eax, DWORD PTR [edx*4+5]
  00295	50		 push	 eax
  00296	8d 8d 8c e8 ff
	ff		 lea	 ecx, DWORD PTR _cBUFFER_V1$[ebp]
  0029c	6a 68		 push	 104			; 00000068H
  0029e	51		 push	 ecx
  0029f	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 18668: 
; 18669: 		DataSend(lpOwnerObj->m_Index,(unsigned char *)lpMsg,((lpMsg->h.sizeL & 0xFF) & 0xFF | ((lpMsg->h.sizeH & 0xFF) & 0xFF) << 8) & 0xFFFF);

  002a4	0f b6 95 8d e8
	ff ff		 movzx	 edx, BYTE PTR _cBUFFER_V1$[ebp+1]
  002ab	0f b6 85 8e e8
	ff ff		 movzx	 eax, BYTE PTR _cBUFFER_V1$[ebp+2]
  002b2	c1 e2 08	 shl	 edx, 8
  002b5	0b d0		 or	 edx, eax
  002b7	52		 push	 edx
  002b8	8b 95 70 e8 ff
	ff		 mov	 edx, DWORD PTR _lpOwnerObj$GSCopy$[ebp]
  002be	8b 02		 mov	 eax, DWORD PTR [edx]
  002c0	8d 8d 8c e8 ff
	ff		 lea	 ecx, DWORD PTR _cBUFFER_V1$[ebp]
  002c6	51		 push	 ecx
  002c7	50		 push	 eax
  002c8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002cd	83 c4 18	 add	 esp, 24			; 00000018H
$LN28@gObjNotify@3:
  002d0	5e		 pop	 esi
$LN1@gObjNotify@3:

; 18670: 	}
; 18671: }

  002d1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d4	33 cd		 xor	 ecx, ebp
  002d6	5b		 pop	 ebx
  002d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002dc	8b e5		 mov	 esp, ebp
  002de	5d		 pop	 ebp
  002df	c3		 ret	 0
?gObjNotifyUseWeaponV1@@YAXPAUOBJECTSTRUCT@@0HH@Z ENDP	; gObjNotifyUseWeaponV1
_TEXT	ENDS
PUBLIC	?gObjNotifyUseWeaponDamage@@YAXPAUOBJECTSTRUCT@@HH@Z ; gObjNotifyUseWeaponDamage
EXTRN	?AddWeaponDamagedTargetInfo@CWeapon@@QAEHHHH@Z:PROC ; CWeapon::AddWeaponDamagedTargetInfo
EXTRN	?g_CsNPC_Weapon@@3VCWeapon@@A:BYTE		; g_CsNPC_Weapon
; Function compile flags: /Ogtp
;	COMDAT ?gObjNotifyUseWeaponDamage@@YAXPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_lpWeaponObj$ = 8					; size = 4
_iTargetX$ = 12						; size = 4
_iTargetY$ = 16						; size = 4
?gObjNotifyUseWeaponDamage@@YAXPAUOBJECTSTRUCT@@HH@Z PROC ; gObjNotifyUseWeaponDamage, COMDAT

; 18674: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 18675: 	if ( lpWeaponObj->Class == 221 || lpWeaponObj->Class == 222)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lpWeaponObj$[ebp]
  00007	0f b7 83 98 00
	00 00		 movzx	 eax, WORD PTR [ebx+152]
  0000e	b9 dd 00 00 00	 mov	 ecx, 221		; 000000ddH
  00013	66 3b c1	 cmp	 ax, cx
  00016	74 0a		 je	 SHORT $LN7@gObjNotify@4
  00018	ba de 00 00 00	 mov	 edx, 222		; 000000deH
  0001d	66 3b c2	 cmp	 ax, dx
  00020	75 5b		 jne	 SHORT $LN4@gObjNotify@4
$LN7@gObjNotify@4:
  00022	56		 push	 esi
  00023	57		 push	 edi

; 18676: 	{
; 18677: 		for ( int i=0;i<OBJMAX;i++)

  00024	33 ff		 xor	 edi, edi
  00026	be 04 01 00 00	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+260
  0002b	eb 03 8d 49 00	 npad	 5
$LL6@gObjNotify@4:

; 18678: 		{
; 18679: 			LPOBJ lpObj = &gObj[i];
; 18680: 
; 18681: 			if ( lpWeaponObj->MapNumber != lpObj->MapNumber )

  00030	8a 83 09 01 00
	00		 mov	 al, BYTE PTR [ebx+265]
  00036	3a 46 05	 cmp	 al, BYTE PTR [esi+5]
  00039	75 31		 jne	 SHORT $LN5@gObjNotify@4

; 18682: 			{
; 18683: 				continue;
; 18684: 			}
; 18685: 
; 18686: 			if ( abs(lpObj->X - iTargetX) > 3 )

  0003b	0f bf 06	 movsx	 eax, WORD PTR [esi]
  0003e	2b 45 0c	 sub	 eax, DWORD PTR _iTargetX$[ebp]
  00041	99		 cdq
  00042	33 c2		 xor	 eax, edx
  00044	2b c2		 sub	 eax, edx
  00046	83 f8 03	 cmp	 eax, 3
  00049	7f 21		 jg	 SHORT $LN5@gObjNotify@4

; 18687: 			{
; 18688: 				continue;
; 18689: 			}
; 18690: 
; 18691: 			if ( abs(lpObj->Y - iTargetY) > 3 )

  0004b	0f bf 46 02	 movsx	 eax, WORD PTR [esi+2]
  0004f	2b 45 10	 sub	 eax, DWORD PTR _iTargetY$[ebp]
  00052	99		 cdq
  00053	33 c2		 xor	 eax, edx
  00055	2b c2		 sub	 eax, edx
  00057	83 f8 03	 cmp	 eax, 3
  0005a	7f 10		 jg	 SHORT $LN5@gObjNotify@4

; 18692: 			{
; 18693: 				continue;
; 18694: 			}
; 18695: 
; 18696: 			g_CsNPC_Weapon.AddWeaponDamagedTargetInfo(lpWeaponObj->m_Index, i, 100);

  0005c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0005e	6a 64		 push	 100			; 00000064H
  00060	57		 push	 edi
  00061	51		 push	 ecx
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  00067	e8 00 00 00 00	 call	 ?AddWeaponDamagedTargetInfo@CWeapon@@QAEHHHH@Z ; CWeapon::AddWeaponDamagedTargetInfo
$LN5@gObjNotify@4:

; 18676: 	{
; 18677: 		for ( int i=0;i<OBJMAX;i++)

  0006c	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  00072	47		 inc	 edi
  00073	81 fe a4 53 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522660
  00079	7c b5		 jl	 SHORT $LL6@gObjNotify@4
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
$LN4@gObjNotify@4:
  0007d	5b		 pop	 ebx

; 18697: 		}
; 18698: 	}
; 18699: 
; 18700: }

  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?gObjNotifyUseWeaponDamage@@YAXPAUOBJECTSTRUCT@@HH@Z ENDP ; gObjNotifyUseWeaponDamage
_TEXT	ENDS
PUBLIC	?gObjUseBlessAndSoulPotion@@YAXHH@Z		; gObjUseBlessAndSoulPotion
EXTRN	?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z:PROC	; GCStateInfoSend
; Function compile flags: /Ogtp
;	COMDAT ?gObjUseBlessAndSoulPotion@@YAXHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_iItemLevel$ = 12					; size = 4
?gObjUseBlessAndSoulPotion@@YAXHH@Z PROC		; gObjUseBlessAndSoulPotion, COMDAT

; 18703: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18704: 	LPOBJ lpObj = &gObj[aIndex];
; 18705: 
; 18706: 	if ( iItemLevel == 0 )	// Bless Potion

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iItemLevel$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000a	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00010	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00016	85 c0		 test	 eax, eax
  00018	75 27		 jne	 SHORT $LN3@gObjUseBle

; 18707: 	{
; 18708: 		lpObj->m_iPotionBlessTime = 120;
; 18709: 		lpObj->m_ViewSkillState |= 0x8000;

  0001a	81 8e c4 01 00
	00 00 80 00 00	 or	 DWORD PTR [esi+452], 32768 ; 00008000H

; 18710: 		GCStateInfoSend(lpObj, 1, 0x8000);

  00024	68 00 80 00 00	 push	 32768			; 00008000H
  00029	6a 01		 push	 1
  0002b	56		 push	 esi
  0002c	c7 86 f4 14 00
	00 78 00 00 00	 mov	 DWORD PTR [esi+5364], 120 ; 00000078H
  00036	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003e	5e		 pop	 esi

; 18718: 	}
; 18719: }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN3@gObjUseBle:

; 18711: 	}
; 18712: 	else if ( iItemLevel == 1 ) // Soul Potion

  00041	83 f8 01	 cmp	 eax, 1
  00044	75 2b		 jne	 SHORT $LN1@gObjUseBle

; 18713: 	{
; 18714: 		lpObj->m_iPotionSoulTime = 60;
; 18715: 		lpObj->m_ViewSkillState |= 0x10000;

  00046	81 8e c4 01 00
	00 00 00 01 00	 or	 DWORD PTR [esi+452], 65536 ; 00010000H

; 18716: 		GCStateInfoSend(lpObj,  1, 0x10000);

  00050	68 00 00 01 00	 push	 65536			; 00010000H
  00055	50		 push	 eax
  00056	56		 push	 esi
  00057	c7 86 f8 14 00
	00 3c 00 00 00	 mov	 DWORD PTR [esi+5368], 60 ; 0000003cH
  00061	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend

; 18717: 		gObjUseDrink(lpObj, 0x4D);

  00066	6a 4d		 push	 77			; 0000004dH
  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 ?gObjUseDrink@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjUseDrink
  0006e	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@gObjUseBle:
  00071	5e		 pop	 esi

; 18718: 	}
; 18719: }

  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?gObjUseBlessAndSoulPotion@@YAXHH@Z ENDP		; gObjUseBlessAndSoulPotion
_TEXT	ENDS
PUBLIC	?gObjWeaponDurDownInCastle@@YAXPAUOBJECTSTRUCT@@0H@Z ; gObjWeaponDurDownInCastle
EXTRN	?SimpleDurabilityDown@CItem@@QAEHH@Z:PROC	; CItem::SimpleDurabilityDown
; Function compile flags: /Ogtp
;	COMDAT ?gObjWeaponDurDownInCastle@@YAXPAUOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
tv264 = -8						; size = 4
tv262 = -8						; size = 4
tv252 = -8						; size = 4
tv250 = -8						; size = 4
_bIsLeftDurDown$ = -4					; size = 4
_lpObj$ = 8						; size = 4
tv267 = 10						; size = 2
tv255 = 10						; size = 2
_lpTargetObj$ = 12					; size = 4
_iDecValue$ = 16					; size = 4
?gObjWeaponDurDownInCastle@@YAXPAUOBJECTSTRUCT@@0H@Z PROC ; gObjWeaponDurDownInCastle, COMDAT

; 18722: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 18723: 	if(lpObj->Type == OBJ_MONSTER || lpObj->Type == OBJ_NPC)

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  0000a	0f b7 43 60	 movzx	 eax, WORD PTR [ebx+96]
  0000e	83 f8 02	 cmp	 eax, 2
  00011	0f 84 90 01 00
	00		 je	 $LN21@gObjWeapon@3
  00017	83 f8 03	 cmp	 eax, 3
  0001a	0f 84 87 01 00
	00		 je	 $LN21@gObjWeapon@3

; 18724: 	{
; 18725: 		return;
; 18726: 	}
; 18727: 
; 18728: 	int itargetdefence = 0;
; 18729: 
; 18730: 	CItem * Right = &lpObj->pInventory[0];
; 18731: 	CItem * Left = &lpObj->pInventory[1];
; 18732: 
; 18733: 	int bIsRightDurDown = 0;
; 18734: 	int bIsLeftDurDown = 0;
; 18735: 
; 18736: 
; 18737: 	if(lpObj->Class == 1 || lpObj->Class == 3 || lpObj->Class == 4)

  00020	0f b7 83 98 00
	00 00		 movzx	 eax, WORD PTR [ebx+152]
  00027	56		 push	 esi
  00028	8b b3 8c 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3212]
  0002e	33 c9		 xor	 ecx, ecx
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	57		 push	 edi
  00036	89 4d fc	 mov	 DWORD PTR _bIsLeftDurDown$[ebp], ecx
  00039	66 3b c2	 cmp	 ax, dx
  0003c	74 0a		 je	 SHORT $LN19@gObjWeapon@3
  0003e	83 f8 03	 cmp	 eax, 3
  00041	74 05		 je	 SHORT $LN19@gObjWeapon@3
  00043	83 f8 04	 cmp	 eax, 4
  00046	75 29		 jne	 SHORT $LN18@gObjWeapon@3
$LN19@gObjWeapon@3:

; 18738: 	{
; 18739: 		if(Right->m_Type >= ITEMGET(0,0) && Right->m_Type < ITEMGET(4,0)
; 18740: 			&& Left->m_Type >= ITEMGET(0,0) && Left->m_Type < ITEMGET(4,0))

  00048	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  0004c	66 3b c1	 cmp	 ax, cx
  0004f	7c 20		 jl	 SHORT $LN18@gObjWeapon@3
  00051	bf 00 08 00 00	 mov	 edi, 2048		; 00000800H
  00056	66 3b c7	 cmp	 ax, di
  00059	7d 16		 jge	 SHORT $LN18@gObjWeapon@3
  0005b	0f b7 86 ae 00
	00 00		 movzx	 eax, WORD PTR [esi+174]
  00062	66 85 c0	 test	 ax, ax
  00065	78 0a		 js	 SHORT $LN18@gObjWeapon@3
  00067	66 3b c7	 cmp	 ax, di
  0006a	7d 05		 jge	 SHORT $LN18@gObjWeapon@3

; 18741: 		{
; 18742: 			bIsRightDurDown = 1;

  0006c	8b ca		 mov	 ecx, edx

; 18743: 			bIsLeftDurDown = 1;

  0006e	89 55 fc	 mov	 DWORD PTR _bIsLeftDurDown$[ebp], edx
$LN18@gObjWeapon@3:

; 18744: 		}
; 18745: 	}
; 18746: 
; 18747: 	if(Left->m_Type >= ITEMGET(4,0) && Left->m_Type < ITEMGET(4,7)
; 18748: 		|| Left->m_Type == ITEMGET(4,20)
; 18749: 		|| Left->m_Type == ITEMGET(4,21))

  00071	0f b7 86 ae 00
	00 00		 movzx	 eax, WORD PTR [esi+174]
  00078	bf 00 08 00 00	 mov	 edi, 2048		; 00000800H
  0007d	66 3b c7	 cmp	 ax, di
  00080	7c 0a		 jl	 SHORT $LN15@gObjWeapon@3
  00082	bf 07 08 00 00	 mov	 edi, 2055		; 00000807H
  00087	66 3b c7	 cmp	 ax, di
  0008a	7c 65		 jl	 SHORT $LN16@gObjWeapon@3
$LN15@gObjWeapon@3:
  0008c	bf 14 08 00 00	 mov	 edi, 2068		; 00000814H
  00091	66 3b c7	 cmp	 ax, di
  00094	74 5b		 je	 SHORT $LN16@gObjWeapon@3
  00096	bf 15 08 00 00	 mov	 edi, 2069		; 00000815H
  0009b	66 3b c7	 cmp	 ax, di
  0009e	74 51		 je	 SHORT $LN16@gObjWeapon@3

; 18752: 	}
; 18753: 	else if(Right->m_Type >= ITEMGET(4,8) && Right->m_Type < ITEMGET(4,15) || Right->m_Type >= ITEMGET(4,16) && Right->m_Type < ITEMGET(5,0))

  000a0	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  000a4	ba 08 08 00 00	 mov	 edx, 2056		; 00000808H
  000a9	66 3b c2	 cmp	 ax, dx
  000ac	7c 0a		 jl	 SHORT $LN11@gObjWeapon@3
  000ae	ba 0f 08 00 00	 mov	 edx, 2063		; 0000080fH
  000b3	66 3b c2	 cmp	 ax, dx
  000b6	7c 40		 jl	 SHORT $LN25@gObjWeapon@3
$LN11@gObjWeapon@3:
  000b8	ba 10 08 00 00	 mov	 edx, 2064		; 00000810H
  000bd	66 3b c2	 cmp	 ax, dx
  000c0	7c 0a		 jl	 SHORT $LN13@gObjWeapon@3
  000c2	ba 00 0a 00 00	 mov	 edx, 2560		; 00000a00H
  000c7	66 3b c2	 cmp	 ax, dx

; 18754: 	{
; 18755: 		bIsRightDurDown = 1;

  000ca	7c 2c		 jl	 SHORT $LN25@gObjWeapon@3
$LN13@gObjWeapon@3:

; 18756: 	}
; 18757: 	else if(Right->m_Type >= 0 && Right->m_Type < ITEMGET(4,0))

  000cc	66 85 c0	 test	 ax, ax
  000cf	78 0a		 js	 SHORT $LN9@gObjWeapon@3
  000d1	ba 00 08 00 00	 mov	 edx, 2048		; 00000800H
  000d6	66 3b c2	 cmp	 ax, dx

; 18758: 	{
; 18759: 		bIsRightDurDown = 1;

  000d9	7c 1d		 jl	 SHORT $LN25@gObjWeapon@3
$LN9@gObjWeapon@3:

; 18760: 	}
; 18761: 	else if(Right->m_Type >= ITEMGET(5,0) && Right->m_Type < ITEMGET(6,0))

  000db	ba 00 0a 00 00	 mov	 edx, 2560		; 00000a00H
  000e0	66 3b c2	 cmp	 ax, dx
  000e3	7c 0f		 jl	 SHORT $LN27@gObjWeapon@3
  000e5	ba 00 0c 00 00	 mov	 edx, 3072		; 00000c00H
  000ea	66 3b c2	 cmp	 ax, dx
  000ed	7d 05		 jge	 SHORT $LN27@gObjWeapon@3

; 18762: 	{
; 18763: 		bIsRightDurDown = 1;

  000ef	eb 07		 jmp	 SHORT $LN25@gObjWeapon@3
$LN16@gObjWeapon@3:

; 18750: 	{
; 18751: 		bIsLeftDurDown = 1;

  000f1	89 55 fc	 mov	 DWORD PTR _bIsLeftDurDown$[ebp], edx
$LN27@gObjWeapon@3:

; 18764: 	}
; 18765: 
; 18766: 	if(bIsRightDurDown != 0)

  000f4	85 c9		 test	 ecx, ecx
  000f6	74 52		 je	 SHORT $LN26@gObjWeapon@3
$LN25@gObjWeapon@3:

; 18767: 	{
; 18768: 		int iRet = Right->SimpleDurabilityDown(iDecValue);

  000f8	8b 45 10	 mov	 eax, DWORD PTR _iDecValue$[ebp]
  000fb	50		 push	 eax
  000fc	8b ce		 mov	 ecx, esi
  000fe	e8 00 00 00 00	 call	 ?SimpleDurabilityDown@CItem@@QAEHH@Z ; CItem::SimpleDurabilityDown
  00103	8b f8		 mov	 edi, eax

; 18769: 
; 18770: 		if(iRet != 0)

  00105	85 ff		 test	 edi, edi
  00107	74 41		 je	 SHORT $LN26@gObjWeapon@3

; 18771: 		{
; 18772: 			GCItemDurSend(lpObj->m_Index,0,Right->m_Durability,0);

  00109	d9 46 24	 fld	 DWORD PTR [esi+36]
  0010c	6a 00		 push	 0
  0010e	d9 7d 0a	 fnstcw	 WORD PTR tv267[ebp]
  00111	0f b7 45 0a	 movzx	 eax, WORD PTR tv267[ebp]
  00115	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0011a	89 45 f8	 mov	 DWORD PTR tv264[ebp], eax
  0011d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0011f	d9 6d f8	 fldcw	 WORD PTR tv264[ebp]
  00122	db 5d f8	 fistp	 DWORD PTR tv262[ebp]
  00125	8a 4d f8	 mov	 cl, BYTE PTR tv262[ebp]
  00128	0f b6 d1	 movzx	 edx, cl
  0012b	52		 push	 edx
  0012c	d9 6d 0a	 fldcw	 WORD PTR tv267[ebp]
  0012f	6a 00		 push	 0
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00137	83 c4 10	 add	 esp, 16			; 00000010H

; 18773: 
; 18774: 			if(iRet == 2)

  0013a	83 ff 02	 cmp	 edi, 2
  0013d	75 0b		 jne	 SHORT $LN26@gObjWeapon@3

; 18775: 			{
; 18776: 				gObjCalCharacter(lpObj->m_Index);

  0013f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00141	51		 push	 ecx
  00142	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00147	83 c4 04	 add	 esp, 4
$LN26@gObjWeapon@3:

; 18777: 			}
; 18778: 		}
; 18779: 	}
; 18780: 
; 18781: 	if(bIsLeftDurDown != 0)

  0014a	83 7d fc 00	 cmp	 DWORD PTR _bIsLeftDurDown$[ebp], 0
  0014e	74 55		 je	 SHORT $LN28@gObjWeapon@3

; 18782: 	{
; 18783: 		int iRet = Right->SimpleDurabilityDown(iDecValue); // again a stupid webzen error ? 

  00150	8b 55 10	 mov	 edx, DWORD PTR _iDecValue$[ebp]
  00153	52		 push	 edx
  00154	8b ce		 mov	 ecx, esi
  00156	e8 00 00 00 00	 call	 ?SimpleDurabilityDown@CItem@@QAEHH@Z ; CItem::SimpleDurabilityDown
  0015b	8b f8		 mov	 edi, eax

; 18784: 
; 18785: 		if(iRet != 0)

  0015d	85 ff		 test	 edi, edi
  0015f	74 44		 je	 SHORT $LN28@gObjWeapon@3

; 18786: 		{
; 18787: 			GCItemDurSend(lpObj->m_Index,1,Left->m_Durability,0);

  00161	d9 86 cc 00 00
	00		 fld	 DWORD PTR [esi+204]
  00167	8b 13		 mov	 edx, DWORD PTR [ebx]
  00169	d9 7d 0a	 fnstcw	 WORD PTR tv255[ebp]
  0016c	6a 00		 push	 0
  0016e	0f b7 45 0a	 movzx	 eax, WORD PTR tv255[ebp]
  00172	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00177	89 45 f8	 mov	 DWORD PTR tv252[ebp], eax
  0017a	d9 6d f8	 fldcw	 WORD PTR tv252[ebp]
  0017d	db 5d f8	 fistp	 DWORD PTR tv250[ebp]
  00180	8a 45 f8	 mov	 al, BYTE PTR tv250[ebp]
  00183	0f b6 c8	 movzx	 ecx, al
  00186	51		 push	 ecx
  00187	d9 6d 0a	 fldcw	 WORD PTR tv255[ebp]
  0018a	6a 01		 push	 1
  0018c	52		 push	 edx
  0018d	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00192	83 c4 10	 add	 esp, 16			; 00000010H

; 18788: 
; 18789: 			if(iRet == 2)

  00195	83 ff 02	 cmp	 edi, 2
  00198	75 0b		 jne	 SHORT $LN28@gObjWeapon@3

; 18790: 			{
; 18791: 				gObjCalCharacter(lpObj->m_Index);

  0019a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  001a2	83 c4 04	 add	 esp, 4
$LN28@gObjWeapon@3:
  001a5	5f		 pop	 edi
  001a6	5e		 pop	 esi
$LN21@gObjWeapon@3:
  001a7	5b		 pop	 ebx

; 18792: 			}
; 18793: 		}
; 18794: 	}
; 18795: }

  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c3		 ret	 0
?gObjWeaponDurDownInCastle@@YAXPAUOBJECTSTRUCT@@0H@Z ENDP ; gObjWeaponDurDownInCastle
_TEXT	ENDS
PUBLIC	?gObjReady4Relife@@YAXPAUOBJECTSTRUCT@@@Z	; gObjReady4Relife
; Function compile flags: /Ogtp
;	COMDAT ?gObjReady4Relife@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjReady4Relife@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjReady4Relife, COMDAT

; 18798: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 18799: 	gObjCalCharacter(lpObj->m_Index);

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 18800: 	GCReFillSend(lpObj->m_Index,lpObj->MaxLife + lpObj->AddLife,0xFE,0);

  0000f	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  00015	83 c4 04	 add	 esp, 4
  00018	6a 00		 push	 0
  0001a	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  00020	68 fe 00 00 00	 push	 254			; 000000feH
  00025	e8 00 00 00 00	 call	 __ftol2_sse
  0002a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	5e		 pop	 esi

; 18801: }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?gObjReady4Relife@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjReady4Relife
_TEXT	ENDS
PUBLIC	?gObjCheckTimeOutValue@@YAXPAUOBJECTSTRUCT@@AAK@Z ; gObjCheckTimeOutValue
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckTimeOutValue@@YAXPAUOBJECTSTRUCT@@AAK@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_rNowTick$ = 12						; size = 4
?gObjCheckTimeOutValue@@YAXPAUOBJECTSTRUCT@@AAK@Z PROC	; gObjCheckTimeOutValue, COMDAT

; 18804: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18805: 	long lTick;
; 18806: 	long lSecond;
; 18807: 
; 18808: 	lTick = rNowTick - lpObj->m_dwLastCheckTick;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _rNowTick$[ebp]
  00006	56		 push	 esi
  00007	8b 30		 mov	 esi, DWORD PTR [eax]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0000d	8b ce		 mov	 ecx, esi
  0000f	2b 8f 1c 15 00
	00		 sub	 ecx, DWORD PTR [edi+5404]

; 18809: 	lSecond = lTick / 1000;

  00015	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0001a	f7 e9		 imul	 ecx
  0001c	c1 fa 06	 sar	 edx, 6
  0001f	8b ca		 mov	 ecx, edx
  00021	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00024	03 ca		 add	 ecx, edx

; 18810: 
; 18811: 	if(lSecond == 0)

  00026	74 06		 je	 SHORT $LN2@gObjCheckT@3

; 18812: 	{
; 18813: 		return;
; 18814: 	}
; 18815: 
; 18816: 	lpObj->m_dwLastCheckTick = rNowTick;

  00028	89 b7 1c 15 00
	00		 mov	 DWORD PTR [edi+5404], esi
$LN2@gObjCheckT@3:
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 18817: }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?gObjCheckTimeOutValue@@YAXPAUOBJECTSTRUCT@@AAK@Z ENDP	; gObjCheckTimeOutValue
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?MsgOutput@@YAXHPADZZ				; MsgOutput
EXTRN	_vsprintf:PROC
; Function compile flags: /Ogtp
;	COMDAT ?MsgOutput@@YAXHPADZZ
_TEXT	SEGMENT
_szBuffer$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_msg$ = 12						; size = 4
?MsgOutput@@YAXHPADZZ PROC				; MsgOutput, COMDAT

; 18820: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 02 00
	00		 sub	 esp, 516		; 00000204H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18821: 	char szBuffer[512]="";

  00013	68 ff 01 00 00	 push	 511			; 000001ffH
  00018	8d 85 fd fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp+1]
  0001e	6a 00		 push	 0
  00020	50		 push	 eax
  00021	c6 85 fc fd ff
	ff 00		 mov	 BYTE PTR _szBuffer$[ebp], 0
  00028	e8 00 00 00 00	 call	 _memset

; 18822: 	va_list pArguments;
; 18823: 
; 18824: 	va_start(pArguments, msg );
; 18825: 	vsprintf(&szBuffer[0], msg, pArguments);

  0002d	8b 55 0c	 mov	 edx, DWORD PTR _msg$[ebp]
  00030	8d 4d 10	 lea	 ecx, DWORD PTR _msg$[ebp+4]
  00033	51		 push	 ecx
  00034	52		 push	 edx
  00035	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _vsprintf

; 18826: 	va_end(pArguments);
; 18827: 	
; 18828: 	GCServerMsgStringSend(&szBuffer[0], aIndex, 1);

  00041	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00044	6a 01		 push	 1
  00046	51		 push	 ecx
  00047	8d 95 fc fd ff
	ff		 lea	 edx, DWORD PTR _szBuffer$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 18829: }

  00053	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00056	33 cd		 xor	 ecx, ebp
  00058	83 c4 24	 add	 esp, 36			; 00000024H
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?MsgOutput@@YAXHPADZZ ENDP				; MsgOutput
_TEXT	ENDS
PUBLIC	__real@4024000000000000
PUBLIC	__real@4014000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	?gProcessAutoRecuperation@@YAXPAUOBJECTSTRUCT@@@Z ; gProcessAutoRecuperation
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gProcessAutoRecuperation@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv625 = 8						; size = 4
tv623 = 8						; size = 4
tv618 = 8						; size = 4
tv616 = 8						; size = 4
tv605 = 8						; size = 4
tv596 = 8						; size = 4
_lpObj$ = 8						; size = 4
?gProcessAutoRecuperation@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gProcessAutoRecuperation, COMDAT

; 18832: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 18833: 	if(lpObj->Life == (lpObj->MaxLife + lpObj->AddLife)
; 18834: 		&& lpObj->Mana == (lpObj->MaxMana + lpObj->AddMana)
; 18835: 		&& lpObj->BP == (lpObj->MaxBP + lpObj->AddBP) )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  0000d	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  00013	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  00019	da e9		 fucompp
  0001b	df e0		 fnstsw	 ax
  0001d	f6 c4 44	 test	 ah, 68			; 00000044H
  00020	7a 3e		 jp	 SHORT $LN24@gProcessAu
  00022	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  00028	db 86 10 01 00
	00		 fild	 DWORD PTR [esi+272]
  0002e	d8 86 d4 00 00
	00		 fadd	 DWORD PTR [esi+212]
  00034	da e9		 fucompp
  00036	df e0		 fnstsw	 ax
  00038	f6 c4 44	 test	 ah, 68			; 00000044H
  0003b	7a 23		 jp	 SHORT $LN24@gProcessAu
  0003d	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  00043	03 86 ec 00 00
	00		 add	 eax, DWORD PTR [esi+236]
  00049	39 86 e8 00 00
	00		 cmp	 DWORD PTR [esi+232], eax
  0004f	75 0f		 jne	 SHORT $LN24@gProcessAu

; 18836: 	{
; 18837: 		lpObj->m_iAutoRecuperationTime = GetTickCount();

  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00057	89 86 20 15 00
	00		 mov	 DWORD PTR [esi+5408], eax
  0005d	5e		 pop	 esi

; 18938: 		}
; 18939: 	}
; 18940: }

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN24@gProcessAu:
  00060	57		 push	 edi

; 18838: 		return;
; 18839: 	}
; 18840: 
; 18841: 	if(( GetTickCount() - lpObj->m_iAutoRecuperationTime ) >= 10000 && ( GetTickCount() - lpObj->m_iAutoRecuperationTime ) < 15000)

  00061	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  00067	ff d7		 call	 edi
  00069	2b 86 20 15 00
	00		 sub	 eax, DWORD PTR [esi+5408]
  0006f	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  00074	0f 82 22 01 00
	00		 jb	 $LN23@gProcessAu
  0007a	ff d7		 call	 edi
  0007c	2b 86 20 15 00
	00		 sub	 eax, DWORD PTR [esi+5408]
  00082	3d 98 3a 00 00	 cmp	 eax, 15000		; 00003a98H
  00087	0f 83 0f 01 00
	00		 jae	 $LN23@gProcessAu

; 18842: 	{
; 18843: 		if(lpObj->Life < ( lpObj->MaxLife + lpObj->AddLife ) )

  0008d	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  00093	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  00099	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  0009f	d8 d9		 fcomp	 ST(1)
  000a1	df e0		 fnstsw	 ax
  000a3	f6 c4 05	 test	 ah, 5
  000a6	7a 4b		 jp	 SHORT $LN29@gProcessAu

; 18844: 		{
; 18845: 			lpObj->Life += 1.0f;

  000a8	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  000ae	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  000b4	d9 5d 08	 fstp	 DWORD PTR tv596[ebp]
  000b7	d9 45 08	 fld	 DWORD PTR tv596[ebp]
  000ba	d9 96 bc 00 00
	00		 fst	 DWORD PTR [esi+188]

; 18846: 
; 18847: 			if(lpObj->Life > (lpObj->MaxLife + lpObj->AddLife))

  000c0	d8 d9		 fcomp	 ST(1)
  000c2	df e0		 fnstsw	 ax
  000c4	f6 c4 41	 test	 ah, 65			; 00000041H
  000c7	75 08		 jne	 SHORT $LN32@gProcessAu

; 18848: 			{
; 18849: 				lpObj->Life = lpObj->MaxLife + lpObj->AddLife;

  000c9	d9 9e bc 00 00
	00		 fstp	 DWORD PTR [esi+188]
  000cf	eb 02		 jmp	 SHORT $LN21@gProcessAu
$LN32@gProcessAu:
  000d1	dd d8		 fstp	 ST(0)
$LN21@gProcessAu:

; 18850: 			}
; 18851: 
; 18852: 			GCReFillSend(lpObj->m_Index,lpObj->Life,0xFF,0);

  000d3	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  000d9	6a 00		 push	 0
  000db	68 ff 00 00 00	 push	 255			; 000000ffH
  000e0	e8 00 00 00 00	 call	 __ftol2_sse
  000e5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000e7	50		 push	 eax
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend
  000ee	83 c4 10	 add	 esp, 16			; 00000010H
  000f1	eb 02		 jmp	 SHORT $LN22@gProcessAu
$LN29@gProcessAu:
  000f3	dd d8		 fstp	 ST(0)
$LN22@gProcessAu:

; 18853: 		}
; 18854: 
; 18855: 		if(lpObj->Mana < ( lpObj->MaxMana + lpObj->AddMana ) || lpObj->BP < ( lpObj->MaxBP + lpObj->AddBP) )

  000f5	db 86 10 01 00
	00		 fild	 DWORD PTR [esi+272]
  000fb	d8 86 d4 00 00
	00		 fadd	 DWORD PTR [esi+212]
  00101	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  00107	d8 d9		 fcomp	 ST(1)
  00109	df e0		 fnstsw	 ax
  0010b	f6 c4 05	 test	 ah, 5
  0010e	7b 18		 jnp	 SHORT $LN19@gProcessAu
  00110	8b 96 f0 00 00
	00		 mov	 edx, DWORD PTR [esi+240]
  00116	03 96 ec 00 00
	00		 add	 edx, DWORD PTR [esi+236]
  0011c	39 96 e8 00 00
	00		 cmp	 DWORD PTR [esi+232], edx
  00122	0f 8d c9 02 00
	00		 jge	 $LN63@gProcessAu
$LN19@gProcessAu:

; 18856: 		{
; 18857: 			lpObj->Mana += 1.0f;

  00128	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  0012e	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  00134	d9 5d 08	 fstp	 DWORD PTR tv605[ebp]
  00137	d9 45 08	 fld	 DWORD PTR tv605[ebp]
  0013a	d9 96 d0 00 00
	00		 fst	 DWORD PTR [esi+208]

; 18858: 
; 18859: 			if(lpObj->Mana > (lpObj->MaxMana + lpObj->AddMana))

  00140	d8 d9		 fcomp	 ST(1)
  00142	df e0		 fnstsw	 ax
  00144	f6 c4 41	 test	 ah, 65			; 00000041H
  00147	75 08		 jne	 SHORT $LN39@gProcessAu

; 18860: 			{
; 18861: 				lpObj->Mana = lpObj->MaxMana + lpObj->AddMana;

  00149	d9 9e d0 00 00
	00		 fstp	 DWORD PTR [esi+208]
  0014f	eb 02		 jmp	 SHORT $LN18@gProcessAu
$LN39@gProcessAu:
  00151	dd d8		 fstp	 ST(0)
$LN18@gProcessAu:

; 18862: 			}
; 18863: 
; 18864: 			lpObj->BP += 1;
; 18865: 
; 18866: 			if(lpObj->BP > (lpObj->MaxBP + lpObj->AddBP))

  00153	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  00159	03 86 ec 00 00
	00		 add	 eax, DWORD PTR [esi+236]
  0015f	ff 86 e8 00 00
	00		 inc	 DWORD PTR [esi+232]
  00165	39 86 e8 00 00
	00		 cmp	 DWORD PTR [esi+232], eax
  0016b	7e 06		 jle	 SHORT $LN17@gProcessAu

; 18867: 			{
; 18868: 				lpObj->BP = lpObj->MaxBP + lpObj->AddBP;

  0016d	89 86 e8 00 00
	00		 mov	 DWORD PTR [esi+232], eax
$LN17@gProcessAu:

; 18869: 			}
; 18870: 
; 18871: 			GCManaSend(lpObj->m_Index,lpObj->Mana,0xFF,0,lpObj->BP);

  00173	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR [esi+232]
  00179	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  0017f	50		 push	 eax
  00180	6a 00		 push	 0
  00182	68 ff 00 00 00	 push	 255			; 000000ffH
  00187	e8 00 00 00 00	 call	 __ftol2_sse
  0018c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0018e	50		 push	 eax
  0018f	51		 push	 ecx
  00190	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  00195	83 c4 14	 add	 esp, 20			; 00000014H
  00198	5f		 pop	 edi
  00199	5e		 pop	 esi

; 18938: 		}
; 18939: 	}
; 18940: }

  0019a	5d		 pop	 ebp
  0019b	c3		 ret	 0
$LN23@gProcessAu:

; 18872: 		}
; 18873: 	}
; 18874: 	else if(( GetTickCount() - lpObj->m_iAutoRecuperationTime ) >= 15000 && ( GetTickCount() - lpObj->m_iAutoRecuperationTime ) < 25000)

  0019c	ff d7		 call	 edi
  0019e	2b 86 20 15 00
	00		 sub	 eax, DWORD PTR [esi+5408]
  001a4	3d 98 3a 00 00	 cmp	 eax, 15000		; 00003a98H
  001a9	0f 82 23 01 00
	00		 jb	 $LN15@gProcessAu
  001af	ff d7		 call	 edi
  001b1	2b 86 20 15 00
	00		 sub	 eax, DWORD PTR [esi+5408]
  001b7	3d a8 61 00 00	 cmp	 eax, 25000		; 000061a8H
  001bc	0f 83 10 01 00
	00		 jae	 $LN15@gProcessAu

; 18875: 	{
; 18876: 		if(lpObj->Life < ( lpObj->MaxLife + lpObj->AddLife ) )

  001c2	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  001c8	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  001ce	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  001d4	d8 d9		 fcomp	 ST(1)
  001d6	df e0		 fnstsw	 ax
  001d8	f6 c4 05	 test	 ah, 5
  001db	7a 4b		 jp	 SHORT $LN42@gProcessAu

; 18877: 		{
; 18878: 			lpObj->Life += 5.0f;

  001dd	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  001e3	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4014000000000000
  001e9	d9 5d 08	 fstp	 DWORD PTR tv616[ebp]
  001ec	d9 45 08	 fld	 DWORD PTR tv616[ebp]
  001ef	d9 96 bc 00 00
	00		 fst	 DWORD PTR [esi+188]

; 18879: 
; 18880: 			if(lpObj->Life > (lpObj->MaxLife + lpObj->AddLife))

  001f5	d8 d9		 fcomp	 ST(1)
  001f7	df e0		 fnstsw	 ax
  001f9	f6 c4 41	 test	 ah, 65			; 00000041H
  001fc	75 08		 jne	 SHORT $LN45@gProcessAu

; 18881: 			{
; 18882: 				lpObj->Life = lpObj->MaxLife + lpObj->AddLife;

  001fe	d9 9e bc 00 00
	00		 fstp	 DWORD PTR [esi+188]
  00204	eb 02		 jmp	 SHORT $LN13@gProcessAu
$LN45@gProcessAu:
  00206	dd d8		 fstp	 ST(0)
$LN13@gProcessAu:

; 18883: 			}
; 18884: 
; 18885: 			GCReFillSend(lpObj->m_Index,lpObj->Life,0xFF,0);

  00208	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  0020e	6a 00		 push	 0
  00210	68 ff 00 00 00	 push	 255			; 000000ffH
  00215	e8 00 00 00 00	 call	 __ftol2_sse
  0021a	8b 16		 mov	 edx, DWORD PTR [esi]
  0021c	50		 push	 eax
  0021d	52		 push	 edx
  0021e	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend
  00223	83 c4 10	 add	 esp, 16			; 00000010H
  00226	eb 02		 jmp	 SHORT $LN14@gProcessAu
$LN42@gProcessAu:
  00228	dd d8		 fstp	 ST(0)
$LN14@gProcessAu:

; 18886: 		}
; 18887: 
; 18888: 		if(lpObj->Mana < ( lpObj->MaxMana + lpObj->AddMana ) || lpObj->BP < ( lpObj->MaxBP + lpObj->AddBP) )

  0022a	db 86 10 01 00
	00		 fild	 DWORD PTR [esi+272]
  00230	d8 86 d4 00 00
	00		 fadd	 DWORD PTR [esi+212]
  00236	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  0023c	d8 d9		 fcomp	 ST(1)
  0023e	df e0		 fnstsw	 ax
  00240	f6 c4 05	 test	 ah, 5
  00243	7b 18		 jnp	 SHORT $LN11@gProcessAu
  00245	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  0024b	03 86 ec 00 00
	00		 add	 eax, DWORD PTR [esi+236]
  00251	39 86 e8 00 00
	00		 cmp	 DWORD PTR [esi+232], eax
  00257	0f 8d 94 01 00
	00		 jge	 $LN63@gProcessAu
$LN11@gProcessAu:

; 18889: 		{
; 18890: 			lpObj->Mana += 5.0f;

  0025d	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  00263	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4014000000000000
  00269	d9 5d 08	 fstp	 DWORD PTR tv618[ebp]
  0026c	d9 45 08	 fld	 DWORD PTR tv618[ebp]
  0026f	d9 96 d0 00 00
	00		 fst	 DWORD PTR [esi+208]

; 18891: 
; 18892: 			if(lpObj->Mana > (lpObj->MaxMana + lpObj->AddMana))

  00275	d8 d9		 fcomp	 ST(1)
  00277	df e0		 fnstsw	 ax
  00279	f6 c4 41	 test	 ah, 65			; 00000041H
  0027c	75 08		 jne	 SHORT $LN52@gProcessAu

; 18893: 			{
; 18894: 				lpObj->Mana = lpObj->MaxMana + lpObj->AddMana;

  0027e	d9 9e d0 00 00
	00		 fstp	 DWORD PTR [esi+208]
  00284	eb 02		 jmp	 SHORT $LN10@gProcessAu
$LN52@gProcessAu:
  00286	dd d8		 fstp	 ST(0)
$LN10@gProcessAu:

; 18895: 			}
; 18896: 
; 18897: 			lpObj->BP += 5;
; 18898: 
; 18899: 			if(lpObj->BP > (lpObj->MaxBP + lpObj->AddBP))

  00288	8b 86 ec 00 00
	00		 mov	 eax, DWORD PTR [esi+236]
  0028e	03 86 f0 00 00
	00		 add	 eax, DWORD PTR [esi+240]
  00294	83 86 e8 00 00
	00 05		 add	 DWORD PTR [esi+232], 5
  0029b	39 86 e8 00 00
	00		 cmp	 DWORD PTR [esi+232], eax
  002a1	7e 06		 jle	 SHORT $LN9@gProcessAu

; 18900: 			{
; 18901: 				lpObj->BP = lpObj->MaxBP + lpObj->AddBP;

  002a3	89 86 e8 00 00
	00		 mov	 DWORD PTR [esi+232], eax
$LN9@gProcessAu:

; 18902: 			}
; 18903: 
; 18904: 			GCManaSend(lpObj->m_Index,lpObj->Mana,0xFF,0,lpObj->BP);

  002a9	8b 8e e8 00 00
	00		 mov	 ecx, DWORD PTR [esi+232]
  002af	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  002b5	51		 push	 ecx
  002b6	6a 00		 push	 0
  002b8	68 ff 00 00 00	 push	 255			; 000000ffH
  002bd	e8 00 00 00 00	 call	 __ftol2_sse
  002c2	8b 16		 mov	 edx, DWORD PTR [esi]
  002c4	50		 push	 eax
  002c5	52		 push	 edx
  002c6	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  002cb	83 c4 14	 add	 esp, 20			; 00000014H
  002ce	5f		 pop	 edi
  002cf	5e		 pop	 esi

; 18938: 		}
; 18939: 	}
; 18940: }

  002d0	5d		 pop	 ebp
  002d1	c3		 ret	 0
$LN15@gProcessAu:

; 18905: 		}
; 18906: 	}
; 18907: 	else if(( GetTickCount() - lpObj->m_iAutoRecuperationTime ) >= 25000)

  002d2	ff d7		 call	 edi
  002d4	2b 86 20 15 00
	00		 sub	 eax, DWORD PTR [esi+5408]
  002da	3d a8 61 00 00	 cmp	 eax, 25000		; 000061a8H
  002df	0f 82 0e 01 00
	00		 jb	 $LN27@gProcessAu

; 18908: 	{
; 18909: 		if(lpObj->Life < ( lpObj->MaxLife + lpObj->AddLife ) )

  002e5	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  002eb	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  002f1	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  002f7	d8 d9		 fcomp	 ST(1)
  002f9	df e0		 fnstsw	 ax
  002fb	f6 c4 05	 test	 ah, 5
  002fe	7a 4b		 jp	 SHORT $LN55@gProcessAu

; 18910: 		{
; 18911: 			lpObj->Life += 10.0f;

  00300	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  00306	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4024000000000000
  0030c	d9 5d 08	 fstp	 DWORD PTR tv623[ebp]
  0030f	d9 45 08	 fld	 DWORD PTR tv623[ebp]
  00312	d9 96 bc 00 00
	00		 fst	 DWORD PTR [esi+188]

; 18912: 
; 18913: 			if(lpObj->Life > (lpObj->MaxLife + lpObj->AddLife))

  00318	d8 d9		 fcomp	 ST(1)
  0031a	df e0		 fnstsw	 ax
  0031c	f6 c4 41	 test	 ah, 65			; 00000041H
  0031f	75 08		 jne	 SHORT $LN58@gProcessAu

; 18914: 			{
; 18915: 				lpObj->Life = lpObj->MaxLife + lpObj->AddLife;

  00321	d9 9e bc 00 00
	00		 fstp	 DWORD PTR [esi+188]
  00327	eb 02		 jmp	 SHORT $LN5@gProcessAu
$LN58@gProcessAu:
  00329	dd d8		 fstp	 ST(0)
$LN5@gProcessAu:

; 18916: 			}
; 18917: 
; 18918: 			GCReFillSend(lpObj->m_Index,lpObj->Life,0xFF,0);

  0032b	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  00331	6a 00		 push	 0
  00333	68 ff 00 00 00	 push	 255			; 000000ffH
  00338	e8 00 00 00 00	 call	 __ftol2_sse
  0033d	50		 push	 eax
  0033e	8b 06		 mov	 eax, DWORD PTR [esi]
  00340	50		 push	 eax
  00341	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend
  00346	83 c4 10	 add	 esp, 16			; 00000010H
  00349	eb 02		 jmp	 SHORT $LN6@gProcessAu
$LN55@gProcessAu:
  0034b	dd d8		 fstp	 ST(0)
$LN6@gProcessAu:

; 18919: 		}
; 18920: 
; 18921: 		if(lpObj->Mana < ( lpObj->MaxMana + lpObj->AddMana ) || lpObj->BP < ( lpObj->MaxBP + lpObj->AddBP) )

  0034d	db 86 10 01 00
	00		 fild	 DWORD PTR [esi+272]
  00353	d8 86 d4 00 00
	00		 fadd	 DWORD PTR [esi+212]
  00359	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  0035f	d8 d9		 fcomp	 ST(1)
  00361	df e0		 fnstsw	 ax
  00363	f6 c4 05	 test	 ah, 5
  00366	7b 14		 jnp	 SHORT $LN3@gProcessAu
  00368	8b 8e f0 00 00
	00		 mov	 ecx, DWORD PTR [esi+240]
  0036e	03 8e ec 00 00
	00		 add	 ecx, DWORD PTR [esi+236]
  00374	39 8e e8 00 00
	00		 cmp	 DWORD PTR [esi+232], ecx
  0037a	7d 75		 jge	 SHORT $LN63@gProcessAu
$LN3@gProcessAu:

; 18922: 		{
; 18923: 			lpObj->Mana += 10.0f;

  0037c	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  00382	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4024000000000000
  00388	d9 5d 08	 fstp	 DWORD PTR tv625[ebp]
  0038b	d9 45 08	 fld	 DWORD PTR tv625[ebp]
  0038e	d9 96 d0 00 00
	00		 fst	 DWORD PTR [esi+208]

; 18924: 
; 18925: 			if(lpObj->Mana > (lpObj->MaxMana + lpObj->AddMana))

  00394	d8 d9		 fcomp	 ST(1)
  00396	df e0		 fnstsw	 ax
  00398	f6 c4 41	 test	 ah, 65			; 00000041H
  0039b	75 08		 jne	 SHORT $LN65@gProcessAu

; 18926: 			{
; 18927: 				lpObj->Mana = lpObj->MaxMana + lpObj->AddMana;

  0039d	d9 9e d0 00 00
	00		 fstp	 DWORD PTR [esi+208]
  003a3	eb 02		 jmp	 SHORT $LN2@gProcessAu
$LN65@gProcessAu:
  003a5	dd d8		 fstp	 ST(0)
$LN2@gProcessAu:

; 18928: 			}
; 18929: 
; 18930: 			lpObj->BP += 10;
; 18931: 
; 18932: 			if(lpObj->BP > (lpObj->MaxBP + lpObj->AddBP))

  003a7	8b 86 ec 00 00
	00		 mov	 eax, DWORD PTR [esi+236]
  003ad	03 86 f0 00 00
	00		 add	 eax, DWORD PTR [esi+240]
  003b3	83 86 e8 00 00
	00 0a		 add	 DWORD PTR [esi+232], 10	; 0000000aH
  003ba	39 86 e8 00 00
	00		 cmp	 DWORD PTR [esi+232], eax
  003c0	7e 06		 jle	 SHORT $LN1@gProcessAu

; 18933: 			{
; 18934: 				lpObj->BP = lpObj->MaxBP + lpObj->AddBP;

  003c2	89 86 e8 00 00
	00		 mov	 DWORD PTR [esi+232], eax
$LN1@gProcessAu:

; 18935: 			}
; 18936: 
; 18937: 			GCManaSend(lpObj->m_Index,lpObj->Mana,0xFF,0,lpObj->BP);

  003c8	8b 8e e8 00 00
	00		 mov	 ecx, DWORD PTR [esi+232]
  003ce	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  003d4	51		 push	 ecx
  003d5	6a 00		 push	 0
  003d7	68 ff 00 00 00	 push	 255			; 000000ffH
  003dc	e8 00 00 00 00	 call	 __ftol2_sse
  003e1	8b 16		 mov	 edx, DWORD PTR [esi]
  003e3	50		 push	 eax
  003e4	52		 push	 edx
  003e5	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  003ea	83 c4 14	 add	 esp, 20			; 00000014H
  003ed	5f		 pop	 edi
  003ee	5e		 pop	 esi

; 18938: 		}
; 18939: 	}
; 18940: }

  003ef	5d		 pop	 ebp
  003f0	c3		 ret	 0
$LN63@gProcessAu:

; 18919: 		}
; 18920: 
; 18921: 		if(lpObj->Mana < ( lpObj->MaxMana + lpObj->AddMana ) || lpObj->BP < ( lpObj->MaxBP + lpObj->AddBP) )

  003f1	dd d8		 fstp	 ST(0)
$LN27@gProcessAu:
  003f3	5f		 pop	 edi
  003f4	5e		 pop	 esi

; 18938: 		}
; 18939: 	}
; 18940: }

  003f5	5d		 pop	 ebp
  003f6	c3		 ret	 0
?gProcessAutoRecuperation@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gProcessAutoRecuperation
_TEXT	ENDS
PUBLIC	?gObjCheckOverlapItemUsingDur@@YAHHHHH@Z	; gObjCheckOverlapItemUsingDur
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckOverlapItemUsingDur@@YAHHHHH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
_iMaxOverlapped$ = 12					; size = 4
_iItemType$ = 16					; size = 4
_iItemLevel$ = 20					; size = 4
?gObjCheckOverlapItemUsingDur@@YAHHHHH@Z PROC		; gObjCheckOverlapItemUsingDur, COMDAT

; 18943: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 18944: 	for(int x = INVETORY_WEAR_SIZE; x < MAIN_INVENTORY_SIZE; x++)

  00006	8b 7d 08	 mov	 edi, DWORD PTR _iUserIndex$[ebp]
  00009	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0000f	bb 0c 00 00 00	 mov	 ebx, 12			; 0000000cH
  00014	8d bf 8c 0c 00
	00		 lea	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3212]
  0001a	be e0 07 00 00	 mov	 esi, 2016		; 000007e0H
  0001f	90		 npad	 1
$LL5@gObjCheckO:

; 18945: 	{
; 18946: 		if(gObj[iUserIndex].pInventory[x].IsItem() == 1
; 18947: 			&& gObj[iUserIndex].pInventory[x].m_Type == (short)iItemType
; 18948: 			&& gObj[iUserIndex].pInventory[x].m_Level == (short)iItemLevel)

  00020	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00022	03 ce		 add	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00029	83 f8 01	 cmp	 eax, 1
  0002c	75 36		 jne	 SHORT $LN4@gObjCheckO
  0002e	8b 07		 mov	 eax, DWORD PTR [edi]
  00030	66 8b 4d 10	 mov	 cx, WORD PTR _iItemType$[ebp]
  00034	66 39 4c 30 06	 cmp	 WORD PTR [eax+esi+6], cx
  00039	75 29		 jne	 SHORT $LN4@gObjCheckO
  0003b	66 8b 55 14	 mov	 dx, WORD PTR _iItemLevel$[ebp]
  0003f	66 39 54 30 08	 cmp	 WORD PTR [eax+esi+8], dx
  00044	75 1e		 jne	 SHORT $LN4@gObjCheckO

; 18949: 		{
; 18950: 			int iITEM_DUR = gObj[iUserIndex].pInventory[x].m_Durability;

  00046	d9 44 30 24	 fld	 DWORD PTR [eax+esi+36]
  0004a	e8 00 00 00 00	 call	 __ftol2_sse

; 18951: 
; 18952: 			if((((iITEM_DUR)<0)?FALSE:((iITEM_DUR)>iMaxOverlapped-1)?FALSE:TRUE ))

  0004f	85 c0		 test	 eax, eax
  00051	78 11		 js	 SHORT $LN4@gObjCheckO
  00053	8b 4d 0c	 mov	 ecx, DWORD PTR _iMaxOverlapped$[ebp]
  00056	33 d2		 xor	 edx, edx
  00058	49		 dec	 ecx
  00059	3b c1		 cmp	 eax, ecx
  0005b	0f 9e c2	 setle	 dl
  0005e	8b c2		 mov	 eax, edx
  00060	85 c0		 test	 eax, eax
  00062	75 17		 jne	 SHORT $LN11@gObjCheckO
$LN4@gObjCheckO:

; 18944: 	for(int x = INVETORY_WEAR_SIZE; x < MAIN_INVENTORY_SIZE; x++)

  00064	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  0006a	43		 inc	 ebx
  0006b	81 fe e0 31 00
	00		 cmp	 esi, 12768		; 000031e0H
  00071	7c ad		 jl	 SHORT $LL5@gObjCheckO

; 18955: 			}
; 18956: 		}
; 18957: 	}
; 18958: return -1;

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	83 c8 ff	 or	 eax, -1
  00078	5b		 pop	 ebx

; 18959: }

  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN11@gObjCheckO:
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 18953: 			{
; 18954: 				return x;

  0007d	8b c3		 mov	 eax, ebx
  0007f	5b		 pop	 ebx

; 18959: }

  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?gObjCheckOverlapItemUsingDur@@YAHHHHH@Z ENDP		; gObjCheckOverlapItemUsingDur
_TEXT	ENDS
PUBLIC	?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z	; gObjOverlapItemUsingDur
EXTRN	?ItemGive@MapClass@@QAEHHH_N@Z:PROC		; MapClass::ItemGive
; Function compile flags: /Ogtp
;	COMDAT ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z
_TEXT	SEGMENT
tv204 = -12						; size = 4
tv202 = -12						; size = 4
_iLoop$168526 = -8					; size = 4
tv210 = -4						; size = 4
tv208 = -2						; size = 2
_lpItem$ = 8						; size = 4
_iMapNumber$ = 12					; size = 4
_iItemNumber$ = 16					; size = 4
_iUserIndex$ = 20					; size = 4
_iMaxOverlapped$ = 24					; size = 4
_iItemType$ = 28					; size = 4
_iItemLevel$ = 32					; size = 4
?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z PROC	; gObjOverlapItemUsingDur, COMDAT

; 18962: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 18963: 	for(int iLoop = 0; iLoop < MAIN_INVENTORY_SIZE; iLoop ++)

  00008	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iLoop$168526[ebp], 0
  0000f	57		 push	 edi
$LL8@gObjOverla:

; 18964: 	{
; 18965: 		int iInventoryIndex = gObjCheckOverlapItemUsingDur(iUserIndex,iMaxOverlapped,iItemType,iItemLevel);

  00010	8b 45 20	 mov	 eax, DWORD PTR _iItemLevel$[ebp]
  00013	8b 4d 1c	 mov	 ecx, DWORD PTR _iItemType$[ebp]
  00016	8b 55 18	 mov	 edx, DWORD PTR _iMaxOverlapped$[ebp]
  00019	8b 75 14	 mov	 esi, DWORD PTR _iUserIndex$[ebp]
  0001c	50		 push	 eax
  0001d	51		 push	 ecx
  0001e	52		 push	 edx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ?gObjCheckOverlapItemUsingDur@@YAHHHHH@Z ; gObjCheckOverlapItemUsingDur
  00025	8b d8		 mov	 ebx, eax
  00027	83 c4 10	 add	 esp, 16			; 00000010H

; 18966: 		if(MAIN_INVENTORY_RANGE(iInventoryIndex))

  0002a	85 db		 test	 ebx, ebx
  0002c	0f 88 c7 00 00
	00		 js	 $LN6@gObjOverla
  00032	33 c0		 xor	 eax, eax
  00034	83 fb 4b	 cmp	 ebx, 75			; 0000004bH
  00037	0f 9e c0	 setle	 al
  0003a	85 c0		 test	 eax, eax
  0003c	0f 84 b7 00 00
	00		 je	 $LN6@gObjOverla

; 18967: 		{
; 18968: 			int iItemDur = gObj[iUserIndex].pInventory[iInventoryIndex].m_Durability + lpItem->m_Durability;

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  00045	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0004b	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  00051	8d be 8c 0c 00
	00		 lea	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  00057	8b f3		 mov	 esi, ebx
  00059	69 f6 a8 00 00
	00		 imul	 esi, 168		; 000000a8H
  0005f	d9 44 30 24	 fld	 DWORD PTR [eax+esi+36]
  00063	d8 41 24	 fadd	 DWORD PTR [ecx+36]
  00066	e8 00 00 00 00	 call	 __ftol2_sse

; 18969: 
; 18970: 			if(iItemDur <= iMaxOverlapped)

  0006b	8b 4d 18	 mov	 ecx, DWORD PTR _iMaxOverlapped$[ebp]
  0006e	3b c1		 cmp	 eax, ecx
  00070	7f 2c		 jg	 SHORT $LN4@gObjOverla

; 18971: 			{
; 18972: 				if(MapC[iMapNumber].ItemGive(iUserIndex,iItemNumber,1) == 1)

  00072	8b 4d 0c	 mov	 ecx, DWORD PTR _iMapNumber$[ebp]
  00075	8b 55 10	 mov	 edx, DWORD PTR _iItemNumber$[ebp]
  00078	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  0007e	8b 45 14	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  00081	6a 01		 push	 1
  00083	52		 push	 edx
  00084	50		 push	 eax
  00085	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0008b	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  00090	83 f8 01	 cmp	 eax, 1
  00093	75 54		 jne	 SHORT $LN7@gObjOverla

; 18973: 				{
; 18974: 					return iInventoryIndex;

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	8b c3		 mov	 eax, ebx
  00099	5b		 pop	 ebx

; 18991: }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
$LN4@gObjOverla:

; 18975: 				}
; 18976: 			}
; 18977: 			else
; 18978: 			{
; 18979: 				lpItem->m_Durability = iItemDur - iMaxOverlapped;

  0009e	2b c1		 sub	 eax, ecx
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  000a3	89 45 fc	 mov	 DWORD PTR tv210[ebp], eax
  000a6	db 45 fc	 fild	 DWORD PTR tv210[ebp]

; 18980: 				gObj[iUserIndex].pInventory[iInventoryIndex].m_Durability = iMaxOverlapped;
; 18981: 
; 18982: 				GCItemDurSend(iUserIndex,iInventoryIndex,gObj[iUserIndex].pInventory[iInventoryIndex].m_Durability,0);

  000a9	6a 00		 push	 0
  000ab	d9 7d fe	 fnstcw	 WORD PTR tv208[ebp]
  000ae	d9 59 24	 fstp	 DWORD PTR [ecx+36]
  000b1	db 45 18	 fild	 DWORD PTR _iMaxOverlapped$[ebp]
  000b4	8b 17		 mov	 edx, DWORD PTR [edi]
  000b6	d9 5c 32 24	 fstp	 DWORD PTR [edx+esi+36]
  000ba	8b 07		 mov	 eax, DWORD PTR [edi]
  000bc	d9 44 30 24	 fld	 DWORD PTR [eax+esi+36]
  000c0	0f b7 45 fe	 movzx	 eax, WORD PTR tv208[ebp]
  000c4	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000c9	89 45 f4	 mov	 DWORD PTR tv204[ebp], eax
  000cc	8b 45 14	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  000cf	d9 6d f4	 fldcw	 WORD PTR tv204[ebp]
  000d2	db 5d f4	 fistp	 DWORD PTR tv202[ebp]
  000d5	8a 4d f4	 mov	 cl, BYTE PTR tv202[ebp]
  000d8	0f b6 d1	 movzx	 edx, cl
  000db	52		 push	 edx
  000dc	d9 6d fe	 fldcw	 WORD PTR tv208[ebp]
  000df	53		 push	 ebx
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  000e6	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@gObjOverla:

; 18963: 	for(int iLoop = 0; iLoop < MAIN_INVENTORY_SIZE; iLoop ++)

  000e9	8b 45 f8	 mov	 eax, DWORD PTR _iLoop$168526[ebp]
  000ec	40		 inc	 eax
  000ed	89 45 f8	 mov	 DWORD PTR _iLoop$168526[ebp], eax
  000f0	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  000f3	0f 8c 17 ff ff
	ff		 jl	 $LL8@gObjOverla
$LN6@gObjOverla:
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi

; 18983: 			}
; 18984: 		}
; 18985: 		else
; 18986: 		{
; 18987: 			return -1;
; 18988: 		}
; 18989: 	}
; 18990: 	return -1;

  000fb	83 c8 ff	 or	 eax, -1
  000fe	5b		 pop	 ebx

; 18991: }

  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ENDP	; gObjOverlapItemUsingDur
_TEXT	ENDS
PUBLIC	?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z	; gObjCheckSerial0ItemList
; Function compile flags: /Ogtp
;	COMDAT ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z
_TEXT	SEGMENT
_lpItem$ = 8						; size = 4
?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z PROC		; gObjCheckSerial0ItemList, COMDAT

; 18994: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18995: 	if(gItemSerialCheck == 0)

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gItemSerialCheck@@3HA, 0 ; gItemSerialCheck
  0000a	75 07		 jne	 SHORT $LN6@gObjCheckS@4

; 18996: 	{
; 18997: 		return true;

  0000c	b8 01 00 00 00	 mov	 eax, 1

; 19021: 	}
; 19022: }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
$LN6@gObjCheckS@4:

; 18998: 	}
; 18999: 
; 19000: 	if(lpItem->m_Type == ITEMGET(14,13)
; 19001: 		|| lpItem->m_Type == ITEMGET(14,14)
; 19002: 		|| lpItem->m_Type == ITEMGET(14,16)
; 19003: 		|| lpItem->m_Type == ITEMGET(14,22)
; 19004: 		|| lpItem->m_Type == ITEMGET(12,15)
; 19005: 		|| lpItem->m_Type == ITEMGET(12,30)
; 19006: 		|| lpItem->m_Type == ITEMGET(12,31)
; 19007: 		|| lpItem->m_Type == ITEMGET(14,31))

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  00016	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  0001a	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  0001f	66 3b c2	 cmp	 ax, dx
  00022	74 4a		 je	 SHORT $LN4@gObjCheckS@4
  00024	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  00029	66 3b c2	 cmp	 ax, dx
  0002c	74 40		 je	 SHORT $LN4@gObjCheckS@4
  0002e	ba 10 1c 00 00	 mov	 edx, 7184		; 00001c10H
  00033	66 3b c2	 cmp	 ax, dx
  00036	74 36		 je	 SHORT $LN4@gObjCheckS@4
  00038	ba 16 1c 00 00	 mov	 edx, 7190		; 00001c16H
  0003d	66 3b c2	 cmp	 ax, dx
  00040	74 2c		 je	 SHORT $LN4@gObjCheckS@4
  00042	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  00047	66 3b c2	 cmp	 ax, dx
  0004a	74 22		 je	 SHORT $LN4@gObjCheckS@4
  0004c	ba 1e 18 00 00	 mov	 edx, 6174		; 0000181eH
  00051	66 3b c2	 cmp	 ax, dx
  00054	74 18		 je	 SHORT $LN4@gObjCheckS@4
  00056	ba 1f 18 00 00	 mov	 edx, 6175		; 0000181fH
  0005b	66 3b c2	 cmp	 ax, dx
  0005e	74 0e		 je	 SHORT $LN4@gObjCheckS@4
  00060	ba 1f 1c 00 00	 mov	 edx, 7199		; 00001c1fH
  00065	66 3b c2	 cmp	 ax, dx
  00068	74 04		 je	 SHORT $LN4@gObjCheckS@4

; 19010: 		{
; 19011: 			return true;
; 19012: 		}
; 19013: 		else
; 19014: 		{
; 19015: 			return false;
; 19016: 		}
; 19017: 	}
; 19018: 	else
; 19019: 	{
; 19020: 		return false;

  0006a	33 c0		 xor	 eax, eax

; 19021: 	}
; 19022: }

  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN4@gObjCheckS@4:

; 19008: 	{
; 19009: 		if(lpItem->GetNumber() == 0)

  0006e	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  00073	f7 d8		 neg	 eax
  00075	1b c0		 sbb	 eax, eax
  00077	40		 inc	 eax

; 19021: 	}
; 19022: }

  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ENDP		; gObjCheckSerial0ItemList
_TEXT	ENDS
PUBLIC	??_C@_0DF@GBAGDNJH@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$CI?$CFs?$CJ?$CI@ ; `string'
PUBLIC	?gObjCheckInventorySerial0Item@@YAHPAUOBJECTSTRUCT@@@Z ; gObjCheckInventorySerial0Item
;	COMDAT ??_C@_0DF@GBAGDNJH@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$CI?$CFs?$CJ?$CI@
CONST	SEGMENT
??_C@_0DF@GBAGDNJH@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$CI?$CFs?$CJ?$CI@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] (%s)(%s) Item(%s) Pos(%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjCheckInventorySerial0Item@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iCount$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjCheckInventorySerial0Item@@YAHPAUOBJECTSTRUCT@@@Z PROC ; gObjCheckInventorySerial0Item, COMDAT

; 19025: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 19026: int iItemSerial;
; 19027: int iCount;
; 19028: int i;
; 19029: 
; 19030: 	if(gItemSerialCheck == 0)

  00005	33 f6		 xor	 esi, esi
  00007	39 35 00 00 00
	00		 cmp	 DWORD PTR ?gItemSerialCheck@@3HA, esi ; gItemSerialCheck
  0000d	75 08		 jne	 SHORT $LN8@gObjCheckI

; 19031: 	{
; 19032: 		return true;

  0000f	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00012	5e		 pop	 esi

; 19060: 	{
; 19061: 		return true;
; 19062: 	}
; 19063: return false;
; 19064: }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
$LN8@gObjCheckI:
  00017	53		 push	 ebx
  00018	57		 push	 edi

; 19033: 	}
; 19034: 
; 19035: 	iCount = 0;
; 19036: 
; 19037: 	for(i = 0; i < INVENTORY_SIZE; i++)

  00019	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0001c	89 75 fc	 mov	 DWORD PTR _iCount$[ebp], esi
  0001f	33 db		 xor	 ebx, ebx
$LL7@gObjCheckI:

; 19038: 	{
; 19039: 		if(lpObj->pInventory[i].IsItem() == 0)

  00021	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3212]
  00027	03 ce		 add	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002e	85 c0		 test	 eax, eax
  00030	74 4f		 je	 SHORT $LN6@gObjCheckI

; 19040: 		{
; 19041: 			continue;
; 19042: 		}
; 19043: 
; 19044: 		if(gObjCheckSerial0ItemList(&lpObj->pInventory[i])==0)

  00032	8b 87 8c 0c 00
	00		 mov	 eax, DWORD PTR [edi+3212]
  00038	03 c6		 add	 eax, esi
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  00040	83 c4 04	 add	 esp, 4
  00043	85 c0		 test	 eax, eax
  00045	74 3a		 je	 SHORT $LN6@gObjCheckI

; 19045: 		{
; 19046: 			continue;
; 19047: 		}
; 19048: 
; 19049: 		iItemSerial = lpObj->pInventory[i].GetNumber();

  00047	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3212]
  0004d	03 ce		 add	 ecx, esi
  0004f	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 19050: 
; 19051: 		if(iItemSerial == 0)

  00054	85 c0		 test	 eax, eax
  00056	75 29		 jne	 SHORT $LN6@gObjCheckI

; 19052: 		{
; 19053: 			LogAdd(LOG_BLACK, "[ANTI-HACK][Serial 0 Item] (%s)(%s) Item(%s) Pos(%d)",
; 19054: 				lpObj->AccountID,lpObj->Name,lpObj->pInventory[i].GetName(),i);

  00058	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3212]
  0005e	53		 push	 ebx
  0005f	03 ce		 add	 ecx, esi
  00061	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00066	50		 push	 eax
  00067	8d 4f 6f	 lea	 ecx, DWORD PTR [edi+111]
  0006a	51		 push	 ecx
  0006b	8d 57 64	 lea	 edx, DWORD PTR [edi+100]
  0006e	52		 push	 edx
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@GBAGDNJH@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$CI?$CFs?$CJ?$CI@
  00074	6a 00		 push	 0
  00076	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0007b	83 c4 18	 add	 esp, 24			; 00000018H

; 19055: 			iCount++;

  0007e	ff 45 fc	 inc	 DWORD PTR _iCount$[ebp]
$LN6@gObjCheckI:

; 19033: 	}
; 19034: 
; 19035: 	iCount = 0;
; 19036: 
; 19037: 	for(i = 0; i < INVENTORY_SIZE; i++)

  00081	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00087	43		 inc	 ebx
  00088	81 fe e0 46 00
	00		 cmp	 esi, 18144		; 000046e0H
  0008e	7c 91		 jl	 SHORT $LL7@gObjCheckI

; 19056: 		}
; 19057: 	}
; 19058: 
; 19059: 	if(iCount > 0)

  00090	33 c0		 xor	 eax, eax
  00092	39 45 fc	 cmp	 DWORD PTR _iCount$[ebp], eax
  00095	5f		 pop	 edi
  00096	5b		 pop	 ebx
  00097	0f 9f c0	 setg	 al
  0009a	5e		 pop	 esi

; 19060: 	{
; 19061: 		return true;
; 19062: 	}
; 19063: return false;
; 19064: }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
?gObjCheckInventorySerial0Item@@YAHPAUOBJECTSTRUCT@@@Z ENDP ; gObjCheckInventorySerial0Item
_TEXT	ENDS
PUBLIC	??_C@_0GP@MDNOLJFE@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	?gCheckSkillDistance@@YAHHHH@Z			; gCheckSkillDistance
EXTRN	?g_iSkillDistanceCheckTemp@@3HA:DWORD		; g_iSkillDistanceCheckTemp
EXTRN	?GetSkillDistance@CMagicDamage@@QAEHH@Z:PROC	; CMagicDamage::GetSkillDistance
EXTRN	?g_iSkillDistanceCheck@@3HA:DWORD		; g_iSkillDistanceCheck
;	COMDAT ??_C@_0GP@MDNOLJFE@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0GP@MDNOLJFE@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'SKILL DISTANCE CHECK] [%s][%s] Invalid Skill attacker(%d, %d)'
	DB	', defender(%d, %d), skillnum:%d skilldistance:%d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gCheckSkillDistance@@YAHHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_iSkillNum$ = 16					; size = 4
?gCheckSkillDistance@@YAHHHH@Z PROC			; gCheckSkillDistance, COMDAT

; 19067: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19068: 	if ( !g_iSkillDistanceCheck  )

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iSkillDistanceCheck@@3HA, 0 ; g_iSkillDistanceCheck
  0000a	75 07		 jne	 SHORT $LN5@gCheckSkil
$LN11@gCheckSkil:

; 19069: 		return TRUE;

  0000c	b8 01 00 00 00	 mov	 eax, 1

; 19096: }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
$LN5@gCheckSkil:

; 19070: 
; 19071: 	if ( iSkillNum == 40 )

  00013	8b 45 10	 mov	 eax, DWORD PTR _iSkillNum$[ebp]
  00016	83 f8 28	 cmp	 eax, 40			; 00000028H

; 19072: 		return TRUE;

  00019	74 f1		 je	 SHORT $LN11@gCheckSkil

; 19073: 
; 19074: 	int iSkillDistance = MagicDamageC.GetSkillDistance(iSkillNum);

  0001b	57		 push	 edi
  0001c	50		 push	 eax
  0001d	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00022	e8 00 00 00 00	 call	 ?GetSkillDistance@CMagicDamage@@QAEHH@Z ; CMagicDamage::GetSkillDistance
  00027	8b f8		 mov	 edi, eax

; 19075: 
; 19076: 	if ( iSkillDistance == -1 )

  00029	83 ff ff	 cmp	 edi, -1
  0002c	75 05		 jne	 SHORT $LN3@gCheckSkil

; 19077: 		return FALSE;

  0002e	33 c0		 xor	 eax, eax
  00030	5f		 pop	 edi

; 19096: }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN3@gCheckSkil:

; 19078: 
; 19079: 	iSkillDistance += g_iSkillDistanceCheckTemp;
; 19080: 	LPOBJ lpObj = &gObj[aIndex];

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00036	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?g_iSkillDistanceCheckTemp@@3HA ; g_iSkillDistanceCheckTemp
  0003c	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00042	53		 push	 ebx
  00043	56		 push	 esi

; 19081: 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  00044	8b 75 0c	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]
  00047	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0004d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 19082: 
; 19083: 	if ( abs(lpObj->X - lpTargetObj->X) > iSkillDistance ||
; 19084: 		 abs(lpObj->Y - lpTargetObj->Y) > iSkillDistance )

  00053	0f bf 81 04 01
	00 00		 movsx	 eax, WORD PTR [ecx+260]
  0005a	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00060	0f bf 9e 04 01
	00 00		 movsx	 ebx, WORD PTR [esi+260]
  00067	2b c3		 sub	 eax, ebx
  00069	99		 cdq
  0006a	33 c2		 xor	 eax, edx
  0006c	2b c2		 sub	 eax, edx
  0006e	3b c7		 cmp	 eax, edi
  00070	7f 23		 jg	 SHORT $LN1@gCheckSkil
  00072	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  00079	0f bf 81 06 01
	00 00		 movsx	 eax, WORD PTR [ecx+262]
  00080	2b c2		 sub	 eax, edx
  00082	99		 cdq
  00083	33 c2		 xor	 eax, edx
  00085	2b c2		 sub	 eax, edx
  00087	3b c7		 cmp	 eax, edi
  00089	7f 0a		 jg	 SHORT $LN1@gCheckSkil

; 19093: 	}
; 19094: 
; 19095: 	return TRUE;

  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	b8 01 00 00 00	 mov	 eax, 1
  00092	5f		 pop	 edi

; 19096: }

  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
$LN1@gCheckSkil:

; 19085: 	{
; 19086: 		LogAdd(LOG_BLACK, "[SKILL DISTANCE CHECK] [%s][%s] Invalid Skill attacker(%d, %d), defender(%d, %d), skillnum:%d skilldistance:%d",
; 19087: 			lpObj->AccountID, lpObj->Name,
; 19088: 			lpObj->X, lpObj->Y, 
; 19089: 			lpTargetObj->X, lpTargetObj->Y,
; 19090: 			iSkillNum, iSkillDistance);

  00095	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  0009c	8b 45 10	 mov	 eax, DWORD PTR _iSkillNum$[ebp]
  0009f	57		 push	 edi
  000a0	50		 push	 eax
  000a1	0f bf 81 06 01
	00 00		 movsx	 eax, WORD PTR [ecx+262]
  000a8	52		 push	 edx
  000a9	53		 push	 ebx
  000aa	50		 push	 eax
  000ab	0f bf 81 04 01
	00 00		 movsx	 eax, WORD PTR [ecx+260]
  000b2	50		 push	 eax
  000b3	8d 51 6f	 lea	 edx, DWORD PTR [ecx+111]
  000b6	52		 push	 edx
  000b7	83 c1 64	 add	 ecx, 100		; 00000064H
  000ba	51		 push	 ecx
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0GP@MDNOLJFE@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  000c0	6a 00		 push	 0
  000c2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000c7	83 c4 28	 add	 esp, 40			; 00000028H
  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx

; 19091: 
; 19092: 		return FALSE;

  000cc	33 c0		 xor	 eax, eax
  000ce	5f		 pop	 edi

; 19096: }

  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
?gCheckSkillDistance@@YAHHHH@Z ENDP			; gCheckSkillDistance
_TEXT	ENDS
PUBLIC	??_C@_0HC@ILNJAOKB@?$FLChaosBoxItemList?$FN?$FLLost?5ItemList@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?gObjSaveChaosBoxItemList@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSaveChaosBoxItemList
;	COMDAT ??_C@_0HC@ILNJAOKB@?$FLChaosBoxItemList?$FN?$FLLost?5ItemList@
CONST	SEGMENT
??_C@_0HC@ILNJAOKB@?$FLChaosBoxItemList?$FN?$FLLost?5ItemList@ DB '[Chaos'
	DB	'BoxItemList][Lost ItemList] [%s][%s] [%d,%s,%d,%d,%d,%d] Seri'
	DB	'al:[%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjSaveChaosBoxItemList@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$168579 = -16						; size = 4
_ExOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjSaveChaosBoxItemList@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjSaveChaosBoxItemList, COMDAT

; 19099: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi

; 19100: 	BYTE ExOption[0x8];
; 19101: 	for(int n = 0; n < CHAOS_BOX_SIZE;n++)

  00016	33 ff		 xor	 edi, edi
  00018	89 7d f0	 mov	 DWORD PTR _n$168579[ebp], edi
  0001b	eb 03 8d 49 00	 npad	 5
$LL4@gObjSaveCh:

; 19102: 	{
; 19103: 		if(lpObj->pChaosBox[n].IsItem() == 1)

  00020	8b 8b dc 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3292]
  00026	03 cf		 add	 ecx, edi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	0f 85 8e 00 00
	00		 jne	 $LN3@gObjSaveCh

; 19104: 		{
; 19105: 			ItemIsBufExOption(ExOption,&lpObj->pChaosBox[n]);

  00036	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  0003c	03 c7		 add	 eax, edi
  0003e	50		 push	 eax
  0003f	8d 4d f4	 lea	 ecx, DWORD PTR _ExOption$[ebp]
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 19106: 
; 19107: 			LogAdd(LOG_BLACK, "[ChaosBoxItemList][Lost ItemList] [%s][%s] [%d,%s,%d,%d,%d,%d] Serial:[%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 19108: 				lpObj->AccountID,lpObj->Name,n,lpObj->pChaosBox[n].GetName(),lpObj->pChaosBox[n].m_Level,lpObj->pChaosBox[n].m_Option1,lpObj->pChaosBox[n].m_Option2,lpObj->pChaosBox[n].m_Option3,lpObj->pChaosBox[n].m_Number,
; 19109: 				(int)lpObj->pChaosBox[n].m_Durability,ExOption[0],ExOption[1],ExOption[2],ExOption[3],ExOption[4],ExOption[5],ExOption[6],lpObj->pChaosBox[n].m_SetOption);

  00048	8b 93 dc 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3292]
  0004e	0f b6 84 17 92
	00 00 00	 movzx	 eax, BYTE PTR [edi+edx+146]
  00056	d9 44 17 24	 fld	 DWORD PTR [edi+edx+36]
  0005a	0f b6 4d fa	 movzx	 ecx, BYTE PTR _ExOption$[ebp+6]
  0005e	8d 34 17	 lea	 esi, DWORD PTR [edi+edx]
  00061	0f b6 55 f9	 movzx	 edx, BYTE PTR _ExOption$[ebp+5]
  00065	83 c4 08	 add	 esp, 8
  00068	50		 push	 eax
  00069	0f b6 45 f8	 movzx	 eax, BYTE PTR _ExOption$[ebp+4]
  0006d	51		 push	 ecx
  0006e	0f b6 4d f7	 movzx	 ecx, BYTE PTR _ExOption$[ebp+3]
  00072	52		 push	 edx
  00073	0f b6 55 f6	 movzx	 edx, BYTE PTR _ExOption$[ebp+2]
  00077	50		 push	 eax
  00078	0f b6 45 f5	 movzx	 eax, BYTE PTR _ExOption$[ebp+1]
  0007c	51		 push	 ecx
  0007d	0f b6 4d f4	 movzx	 ecx, BYTE PTR _ExOption$[ebp]
  00081	52		 push	 edx
  00082	50		 push	 eax
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 __ftol2_sse
  00089	8b 16		 mov	 edx, DWORD PTR [esi]
  0008b	0f b6 4e 79	 movzx	 ecx, BYTE PTR [esi+121]
  0008f	50		 push	 eax
  00090	0f b6 46 7a	 movzx	 eax, BYTE PTR [esi+122]
  00094	52		 push	 edx
  00095	0f b6 56 78	 movzx	 edx, BYTE PTR [esi+120]
  00099	50		 push	 eax
  0009a	0f bf 46 08	 movsx	 eax, WORD PTR [esi+8]
  0009e	51		 push	 ecx
  0009f	52		 push	 edx
  000a0	50		 push	 eax
  000a1	8b ce		 mov	 ecx, esi
  000a3	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000a8	8b 4d f0	 mov	 ecx, DWORD PTR _n$168579[ebp]
  000ab	50		 push	 eax
  000ac	51		 push	 ecx
  000ad	8d 53 6f	 lea	 edx, DWORD PTR [ebx+111]
  000b0	52		 push	 edx
  000b1	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  000b4	50		 push	 eax
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0HC@ILNJAOKB@?$FLChaosBoxItemList?$FN?$FLLost?5ItemList@
  000ba	6a 00		 push	 0
  000bc	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000c1	83 c4 50	 add	 esp, 80			; 00000050H
$LN3@gObjSaveCh:

; 19100: 	BYTE ExOption[0x8];
; 19101: 	for(int n = 0; n < CHAOS_BOX_SIZE;n++)

  000c4	ff 45 f0	 inc	 DWORD PTR _n$168579[ebp]
  000c7	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  000cd	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  000d3	0f 8c 47 ff ff
	ff		 jl	 $LL4@gObjSaveCh

; 19110: 		}
; 19111: 	}
; 19112: }

  000d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi
  000de	33 cd		 xor	 ecx, ebp
  000e0	5b		 pop	 ebx
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
?gObjSaveChaosBoxItemList@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjSaveChaosBoxItemList
_TEXT	ENDS
PUBLIC	??_C@_0GG@GPEABMHM@?$FL?5CHECK?5POSITION?5?$FN?5MoveMosterPro@ ; `string'
PUBLIC	__real@3ff4cccccccccccd
PUBLIC	?MoveMonsterProc@@YAXXZ				; MoveMonsterProc
;	COMDAT ??_C@_0GG@GPEABMHM@?$FL?5CHECK?5POSITION?5?$FN?5MoveMosterPro@
CONST	SEGMENT
??_C@_0GG@GPEABMHM@?$FL?5CHECK?5POSITION?5?$FN?5MoveMosterPro@ DB '[ CHEC'
	DB	'K POSITION ] MoveMosterProc [%s][%s] Map[%d]-(%d,%d) User(%d,'
	DB	'%d) Can not Move Position Attr[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT __real@3ff4cccccccccccd
CONST	SEGMENT
__real@3ff4cccccccccccd DQ 03ff4cccccccccccdr	; 1.3
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?MoveMonsterProc@@YAXXZ
_TEXT	SEGMENT
tv1214 = -16						; size = 8
tv1216 = -12						; size = 4
_n$161952 = -8						; size = 4
tv1220 = -4						; size = 4
tv1219 = -2						; size = 2
?MoveMonsterProc@@YAXXZ PROC				; MoveMonsterProc, COMDAT

; 488  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 489  : 	DWORD MoveTime;
; 490  : 	int DelayTime;
; 491  : 	LPOBJ lpObj;
; 492  : 
; 493  : 	for(int n = 0; n < OBJMAX;n++)

  00009	33 ff		 xor	 edi, edi
  0000b	89 7d f8	 mov	 DWORD PTR _n$161952[ebp], edi
  0000e	be 26 03 00 00	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+806
$LL43@MoveMonste:

; 494  : 	{
; 495  : 		lpObj = &gObj[n];
; 496  : 
; 497  : 		if(lpObj->Connected == PLAYER_PLAYING)

  00013	80 be de fc ff
	ff 03		 cmp	 BYTE PTR [esi-802], 3
  0001a	0f 85 85 02 00
	00		 jne	 $LN26@MoveMonste

; 498  : 		{
; 499  : 			if(lpObj->Type == OBJ_MONSTER)

  00020	0f b7 8e 3a fd
	ff ff		 movzx	 ecx, WORD PTR [esi-710]
  00027	83 f9 02	 cmp	 ecx, 2
  0002a	75 1c		 jne	 SHORT $LN44@MoveMonste

; 500  : 			{
; 501  : 				if(	 ATTRIBUTE_RANGE(lpObj->m_Attribute) != FALSE
; 502  : #if GS_CASTLE == 1
; 503  : 				  || lpObj->Class == 277 || lpObj->Class == 283 ||
; 504  : 					 lpObj->Class == 288 || lpObj->Class == 278 ||
; 505  : 					 lpObj->Class == 216 || lpObj->Class == 217 || 
; 506  : 					 lpObj->Class == 218 || lpObj->Class == 219 ||
; 507  : 					 CHECK_LIMIT2(lpObj->Class, 205, 210) ||
; 508  : 					 CHECK_CLASS(lpObj->Class, 204)
; 509  : #endif
; 510  : 						)

  0002c	0f b7 06	 movzx	 eax, WORD PTR [esi]
  0002f	66 83 f8 33	 cmp	 ax, 51			; 00000033H
  00033	7c 13		 jl	 SHORT $LN44@MoveMonste
  00035	33 d2		 xor	 edx, edx
  00037	66 83 f8 3a	 cmp	 ax, 58			; 0000003aH
  0003b	0f 9e c2	 setle	 dl
  0003e	8b c2		 mov	 eax, edx
  00040	85 c0		 test	 eax, eax
  00042	0f 85 7a 02 00
	00		 jne	 $LN34@MoveMonste
$LN44@MoveMonste:

; 513  : 					return;
; 514  : 				}
; 515  : 			}
; 516  : 			
; 517  : 			if(lpObj->m_State == 2)

  00048	83 be 96 fe ff
	ff 02		 cmp	 DWORD PTR [esi-362], 2
  0004f	0f 85 50 02 00
	00		 jne	 $LN26@MoveMonste

; 518  : 			{
; 519  : 				if(lpObj->PathCount != 0 && lpObj->m_SkillHarden == 0 && lpObj->m_iSkillStunTime == 0)

  00055	83 be 02 fe ff
	ff 00		 cmp	 DWORD PTR [esi-510], 0
  0005c	0f 84 27 02 00
	00		 je	 $LN38@MoveMonste
  00062	83 be 72 ff ff
	ff 00		 cmp	 DWORD PTR [esi-142], 0
  00069	0f 85 1a 02 00
	00		 jne	 $LN38@MoveMonste
  0006f	83 be b6 11 00
	00 00		 cmp	 DWORD PTR [esi+4534], 0
  00076	0f 85 0d 02 00
	00		 jne	 $LN38@MoveMonste

; 520  : 				{
; 521  : 					if(lpObj->DelayLevel != 0)

  0007c	0f be 86 fe fe
	ff ff		 movsx	 eax, BYTE PTR [esi-258]
  00083	f7 d8		 neg	 eax
  00085	1b c0		 sbb	 eax, eax
  00087	25 2c 01 00 00	 and	 eax, 300		; 0000012cH

; 522  : 					{
; 523  : 						DelayTime = 300;
; 524  : 					}
; 525  : 					else
; 526  : 					{
; 527  : 						DelayTime = 0;
; 528  : 					}
; 529  : 	
; 530  : 					if(lpObj->Type == OBJ_MONSTER && lpObj->m_RecallMon >= 100)

  0008c	83 f9 02	 cmp	 ecx, 2
  0008f	75 11		 jne	 SHORT $LN17@MoveMonste
  00091	83 7e a6 64	 cmp	 DWORD PTR [esi-90], 100	; 00000064H
  00095	7c 0b		 jl	 SHORT $LN17@MoveMonste

; 531  : 					{
; 532  : 						lpObj->m_MoveSpeed = 200;

  00097	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  0009c	66 89 4e f6	 mov	 WORD PTR [esi-10], cx

; 533  : 					}
; 534  : 					else

  000a0	eb 09		 jmp	 SHORT $LN16@MoveMonste
$LN17@MoveMonste:

; 535  : 					{
; 536  : 						lpObj->m_MoveSpeed = 400;

  000a2	ba 90 01 00 00	 mov	 edx, 400		; 00000190H
  000a7	66 89 56 f6	 mov	 WORD PTR [esi-10], dx
$LN16@MoveMonste:

; 537  : 					}
; 538  : 	
; 539  : 					if(lpObj->PathDir[lpObj->PathCur]%2 == 0)

  000ab	8b 8e 06 fe ff
	ff		 mov	 ecx, DWORD PTR [esi-506]
  000b1	0f be 94 0e 66
	fe ff ff	 movsx	 edx, BYTE PTR [esi+ecx-410]
  000b9	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  000bf	79 05		 jns	 SHORT $LN45@MoveMonste
  000c1	4a		 dec	 edx
  000c2	83 ca fe	 or	 edx, -2			; fffffffeH
  000c5	42		 inc	 edx
$LN45@MoveMonste:
  000c6	75 2f		 jne	 SHORT $LN15@MoveMonste

; 540  : 					{
; 541  : 						MoveTime = (lpObj->m_MoveSpeed + DelayTime)*(double)1.3;

  000c8	0f bf 4e f6	 movsx	 ecx, WORD PTR [esi-10]
  000cc	03 c8		 add	 ecx, eax
  000ce	89 4d fc	 mov	 DWORD PTR tv1220[ebp], ecx
  000d1	db 45 fc	 fild	 DWORD PTR tv1220[ebp]
  000d4	d9 7d fe	 fnstcw	 WORD PTR tv1219[ebp]
  000d7	0f b7 45 fe	 movzx	 eax, WORD PTR tv1219[ebp]
  000db	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3ff4cccccccccccd
  000e1	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000e6	89 45 f4	 mov	 DWORD PTR tv1216[ebp], eax
  000e9	d9 6d f4	 fldcw	 WORD PTR tv1216[ebp]
  000ec	df 7d f0	 fistp	 QWORD PTR tv1214[ebp]
  000ef	8b 7d f0	 mov	 edi, DWORD PTR tv1214[ebp]
  000f2	d9 6d fe	 fldcw	 WORD PTR tv1219[ebp]

; 542  : 					}
; 543  : 					else

  000f5	eb 06		 jmp	 SHORT $LN14@MoveMonste
$LN15@MoveMonste:

; 544  : 					{
; 545  : 						MoveTime = lpObj->m_MoveSpeed + DelayTime;

  000f7	0f bf 7e f6	 movsx	 edi, WORD PTR [esi-10]
  000fb	03 f8		 add	 edi, eax
$LN14@MoveMonste:

; 546  : 					}
; 547  : 	
; 548  : 					if( (GetTickCount() - lpObj->PathTime) > MoveTime && lpObj->PathCur < 14)

  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00103	2b 86 76 fe ff
	ff		 sub	 eax, DWORD PTR [esi-394]
  00109	3b c7		 cmp	 eax, edi
  0010b	0f 86 78 01 00
	00		 jbe	 $LN38@MoveMonste
  00111	8b 86 06 fe ff
	ff		 mov	 eax, DWORD PTR [esi-506]
  00117	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  0011a	0f 8d 69 01 00
	00		 jge	 $LN38@MoveMonste

; 549  : 					{
; 550  : 						int nextX = lpObj->PathX[lpObj->PathCur];
; 551  : 						int nextY = lpObj->PathY[lpObj->PathCur];
; 552  : 						BYTE mapnumber = lpObj->MapNumber;
; 553  : 						BYTE attr = MapC[mapnumber].GetAttr(nextX,nextY);

  00120	0f b6 8e e3 fd
	ff ff		 movzx	 ecx, BYTE PTR [esi-541]
  00127	0f bf 9c 46 48
	fe ff ff	 movsx	 ebx, WORD PTR [esi+eax*2-440]
  0012f	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00135	0f bf bc 46 2a
	fe ff ff	 movsx	 edi, WORD PTR [esi+eax*2-470]
  0013d	53		 push	 ebx
  0013e	57		 push	 edi
  0013f	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00145	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 554  : 	
; 555  : 						if( lpObj->Type == OBJ_USER &&
; 556  : 							( (attr & 4) == 4 || (attr & 8) == 8) )

  0014a	66 83 be 3a fd
	ff ff 01	 cmp	 WORD PTR [esi-710], 1
  00152	0f 85 ba 00 00
	00		 jne	 $LN12@MoveMonste
  00158	a8 0c		 test	 al, 12			; 0000000cH
  0015a	0f 84 b2 00 00
	00		 je	 $LN12@MoveMonste

; 557  : 						{
; 558  : 							LogAdd(LOG_BLACK, "[ CHECK POSITION ] MoveMosterProc [%s][%s] Map[%d]-(%d,%d) User(%d,%d) Can not Move Position Attr[%d]",
; 559  : 								lpObj->AccountID,lpObj->Name,lpObj->MapNumber,nextX,nextY,lpObj->X,lpObj->Y,attr);

  00160	0f bf 8e de fd
	ff ff		 movsx	 ecx, WORD PTR [esi-546]
  00167	0f b6 d0	 movzx	 edx, al
  0016a	0f bf 86 e0 fd
	ff ff		 movsx	 eax, WORD PTR [esi-544]
  00171	52		 push	 edx
  00172	0f b6 96 e3 fd
	ff ff		 movzx	 edx, BYTE PTR [esi-541]
  00179	50		 push	 eax
  0017a	51		 push	 ecx
  0017b	53		 push	 ebx
  0017c	57		 push	 edi
  0017d	52		 push	 edx
  0017e	8d 86 49 fd ff
	ff		 lea	 eax, DWORD PTR [esi-695]
  00184	50		 push	 eax
  00185	8d 8e 3e fd ff
	ff		 lea	 ecx, DWORD PTR [esi-706]
  0018b	51		 push	 ecx
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@GPEABMHM@?$FL?5CHECK?5POSITION?5?$FN?5MoveMosterPro@
  00191	33 ff		 xor	 edi, edi
  00193	57		 push	 edi
  00194	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00199	83 c4 28	 add	 esp, 40			; 00000028H
  0019c	8d 86 48 fe ff
	ff		 lea	 eax, DWORD PTR [esi-440]
  001a2	8d 4f 0f	 lea	 ecx, DWORD PTR [edi+15]
$LL10@MoveMonste:

; 560  : 							for(int n = 0; n < 15;n++)
; 561  : 							{
; 562  : 								lpObj->PathX[n] = 0;

  001a5	33 d2		 xor	 edx, edx
  001a7	66 89 50 e2	 mov	 WORD PTR [eax-30], dx

; 563  : 								lpObj->PathY[n] = 0;

  001ab	66 89 10	 mov	 WORD PTR [eax], dx

; 564  : 								lpObj->PathOri[n] = 0;

  001ae	66 89 50 c4	 mov	 WORD PTR [eax-60], dx
  001b2	83 c0 02	 add	 eax, 2
  001b5	49		 dec	 ecx
  001b6	75 ed		 jne	 SHORT $LL10@MoveMonste

; 565  : 							}
; 566  : 	
; 567  : 							lpObj->PathCount = 0;

  001b8	89 be 02 fe ff
	ff		 mov	 DWORD PTR [esi-510], edi

; 568  : 							lpObj->PathCur = 0;

  001be	89 be 06 fe ff
	ff		 mov	 DWORD PTR [esi-506], edi

; 569  : 							lpObj->PathTime = GetTickCount();

  001c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001ca	89 86 76 fe ff
	ff		 mov	 DWORD PTR [esi-394], eax

; 570  : 
; 571  : 							if(lpObj->Type == OBJ_MONSTER || lpObj->Type == OBJ_NPC)

  001d0	0f b7 86 3a fd
	ff ff		 movzx	 eax, WORD PTR [esi-710]
  001d7	83 f8 02	 cmp	 eax, 2
  001da	74 05		 je	 SHORT $LN6@MoveMonste
  001dc	83 f8 03	 cmp	 eax, 3
  001df	75 07		 jne	 SHORT $LN7@MoveMonste
$LN6@MoveMonste:

; 572  : 							{
; 573  : 								lpObj->PathStartEnd = 0;

  001e1	c6 86 0a fe ff
	ff 00		 mov	 BYTE PTR [esi-502], 0
$LN7@MoveMonste:

; 574  : 							}
; 575  : 	
; 576  : 							if(lpObj->Type == OBJ_USER)

  001e8	83 f8 01	 cmp	 eax, 1
  001eb	0f 85 98 00 00
	00		 jne	 $LN38@MoveMonste

; 577  : 							{
; 578  : 								gObjSetPosition(lpObj->m_Index,lpObj->X,lpObj->Y);

  001f1	0f bf 86 e0 fd
	ff ff		 movsx	 eax, WORD PTR [esi-544]
  001f8	0f bf 8e de fd
	ff ff		 movsx	 ecx, WORD PTR [esi-546]
  001ff	8b 96 da fc ff
	ff		 mov	 edx, DWORD PTR [esi-806]
  00205	50		 push	 eax
  00206	51		 push	 ecx
  00207	52		 push	 edx
  00208	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  0020d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 579  : 							}
; 580  : 						}
; 581  : 						else

  00210	eb 77		 jmp	 SHORT $LN38@MoveMonste
$LN12@MoveMonste:

; 582  : 						{
; 583  : 							lpObj->X = lpObj->PathX[lpObj->PathCur];

  00212	8b 86 06 fe ff
	ff		 mov	 eax, DWORD PTR [esi-506]
  00218	66 8b 8c 46 2a
	fe ff ff	 mov	 cx, WORD PTR [esi+eax*2-470]
  00220	66 89 8e de fd
	ff ff		 mov	 WORD PTR [esi-546], cx

; 584  : 							lpObj->Y = lpObj->PathY[lpObj->PathCur];

  00227	66 8b 94 46 48
	fe ff ff	 mov	 dx, WORD PTR [esi+eax*2-440]
  0022f	66 89 96 e0 fd
	ff ff		 mov	 WORD PTR [esi-544], dx

; 585  : 							lpObj->Dir = lpObj->PathDir[lpObj->PathCur];

  00236	8a 84 06 66 fe
	ff ff		 mov	 al, BYTE PTR [esi+eax-410]
  0023d	88 86 e2 fd ff
	ff		 mov	 BYTE PTR [esi-542], al

; 586  : 
; 587  : 							lpObj->PathTime = GetTickCount();

  00243	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 588  : 							lpObj->PathCur++;

  00249	ff 86 06 fe ff
	ff		 inc	 DWORD PTR [esi-506]
  0024f	89 86 76 fe ff
	ff		 mov	 DWORD PTR [esi-394], eax
  00255	8b 86 06 fe ff
	ff		 mov	 eax, DWORD PTR [esi-506]

; 589  : 
; 590  : 							if(lpObj->PathCur >= lpObj->PathCount)

  0025b	3b 86 02 fe ff
	ff		 cmp	 eax, DWORD PTR [esi-510]
  00261	7c 26		 jl	 SHORT $LN38@MoveMonste

; 591  : 							{
; 592  : 								lpObj->PathCur = 0;

  00263	33 c0		 xor	 eax, eax
  00265	89 86 06 fe ff
	ff		 mov	 DWORD PTR [esi-506], eax

; 593  : 								lpObj->PathCount = 0;

  0026b	89 86 02 fe ff
	ff		 mov	 DWORD PTR [esi-510], eax

; 594  : 
; 595  : 								if(lpObj->Type == OBJ_MONSTER || lpObj->Type == OBJ_NPC)

  00271	0f b7 86 3a fd
	ff ff		 movzx	 eax, WORD PTR [esi-710]
  00278	83 f8 02	 cmp	 eax, 2
  0027b	74 05		 je	 SHORT $LN1@MoveMonste
  0027d	83 f8 03	 cmp	 eax, 3
  00280	75 07		 jne	 SHORT $LN38@MoveMonste
$LN1@MoveMonste:

; 596  : 								{
; 597  : 									lpObj->PathStartEnd = 0;

  00282	c6 86 0a fe ff
	ff 00		 mov	 BYTE PTR [esi-502], 0
$LN38@MoveMonste:

; 598  : 								}
; 599  : 							}
; 600  : 						}
; 601  : 					}
; 602  : 				}
; 603  : 				CreateFrustrum(lpObj->X,lpObj->Y,n);

  00289	0f bf 8e e0 fd
	ff ff		 movsx	 ecx, WORD PTR [esi-544]
  00290	8b 7d f8	 mov	 edi, DWORD PTR _n$161952[ebp]
  00293	0f bf 96 de fd
	ff ff		 movsx	 edx, WORD PTR [esi-546]
  0029a	57		 push	 edi
  0029b	51		 push	 ecx
  0029c	52		 push	 edx
  0029d	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  002a2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@MoveMonste:

; 489  : 	DWORD MoveTime;
; 490  : 	int DelayTime;
; 491  : 	LPOBJ lpObj;
; 492  : 
; 493  : 	for(int n = 0; n < OBJMAX;n++)

  002a5	47		 inc	 edi
  002a6	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  002ac	89 7d f8	 mov	 DWORD PTR _n$161952[ebp], edi
  002af	81 fe c6 55 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40523206
  002b5	0f 8c 58 fd ff
	ff		 jl	 $LL43@MoveMonste
  002bb	5f		 pop	 edi
  002bc	5e		 pop	 esi
  002bd	5b		 pop	 ebx

; 604  : 			}
; 605  : 		}
; 606  : 	}
; 607  : 
; 608  : 	// STRANGE COMPILATION ... 
; 609  : }

  002be	8b e5		 mov	 esp, ebp
  002c0	5d		 pop	 ebp
  002c1	c3		 ret	 0
$LN34@MoveMonste:

; 511  : 				{
; 512  : 					CreateFrustrum(lpObj->X,lpObj->Y,n);

  002c2	0f bf 86 e0 fd
	ff ff		 movsx	 eax, WORD PTR [esi-544]
  002c9	0f bf 8e de fd
	ff ff		 movsx	 ecx, WORD PTR [esi-546]
  002d0	57		 push	 edi
  002d1	50		 push	 eax
  002d2	51		 push	 ecx
  002d3	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  002d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002db	5f		 pop	 edi
  002dc	5e		 pop	 esi
  002dd	5b		 pop	 ebx

; 604  : 			}
; 605  : 		}
; 606  : 	}
; 607  : 
; 608  : 	// STRANGE COMPILATION ... 
; 609  : }

  002de	8b e5		 mov	 esp, ebp
  002e0	5d		 pop	 ebp
  002e1	c3		 ret	 0
?MoveMonsterProc@@YAXXZ ENDP				; MoveMonsterProc
_TEXT	ENDS
PUBLIC	?gObjInit@@YAXXZ				; gObjInit
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??0CMagicInf@@QAE@XZ:PROC			; CMagicInf::CMagicInf
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?gObjInit@@YAXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?gObjInit@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?gObjInit@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$6
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?gObjInit@@YAXXZ
_TEXT	SEGMENT
$T170737 = -32						; size = 4
$T170726 = -32						; size = 4
_pTempInventoryMap$ = -28				; size = 4
$T170709 = -28						; size = 4
$T170708 = -24						; size = 4
$T170783 = -20						; size = 4
$T170769 = -20						; size = 4
$T170732 = -20						; size = 4
$T170722 = -20						; size = 4
$T170718 = -20						; size = 4
$T170714 = -20						; size = 4
_n$162002 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?gObjInit@@YAXXZ PROC					; gObjInit, COMDAT

; 622  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?gObjInit@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 623  : 	gObjCount=OBJ_STARTUSERINDEX;
; 624  : 	gObjMonCount=0;

  00028	33 db		 xor	 ebx, ebx

; 625  : 	gObjCallMonCount= OBJ_MAXMONSTER;
; 626  : 
; 627  : 	CItem * pTempInventory = new CItem[INVENTORY_SIZE];

  0002a	68 e0 46 00 00	 push	 18144			; 000046e0H
  0002f	c7 05 00 00 00
	00 00 19 00 00	 mov	 DWORD PTR ?gObjCount@@3HA, 6400 ; gObjCount, 00001900H
  00039	89 1d 00 00 00
	00		 mov	 DWORD PTR ?gObjMonCount@@3HA, ebx ; gObjMonCount
  0003f	c7 05 00 00 00
	00 a8 16 00 00	 mov	 DWORD PTR ?gObjCallMonCount@@3HA, 5800 ; gObjCallMonCount, 000016a8H
  00049	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0004e	8b f8		 mov	 edi, eax
  00050	83 c4 04	 add	 esp, 4
  00053	89 7d e4	 mov	 DWORD PTR $T170709[ebp], edi
  00056	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00059	3b fb		 cmp	 edi, ebx
  0005b	74 1e		 je	 SHORT $LN10@gObjInit
  0005d	8b f7		 mov	 esi, edi
  0005f	bb 6b 00 00 00	 mov	 ebx, 107		; 0000006bH
$LL32@gObjInit:
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  0006b	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00071	4b		 dec	 ebx
  00072	79 f0		 jns	 SHORT $LL32@gObjInit
  00074	89 7d e8	 mov	 DWORD PTR $T170708[ebp], edi
  00077	33 db		 xor	 ebx, ebx
  00079	eb 03		 jmp	 SHORT $LN11@gObjInit
$LN10@gObjInit:
  0007b	89 5d e8	 mov	 DWORD PTR $T170708[ebp], ebx
$LN11@gObjInit:
  0007e	83 cf ff	 or	 edi, -1

; 628  : 	BYTE * pTempInventoryMap = new BYTE [INVENTORY_MAP_SIZE];

  00081	6a 60		 push	 96			; 00000060H
  00083	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00086	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0008b	83 c4 04	 add	 esp, 4
  0008e	89 45 e4	 mov	 DWORD PTR _pTempInventoryMap$[ebp], eax

; 629  : 
; 630  : 	for ( int n = 0; n< OBJMAX ; n++)

  00091	89 5d f0	 mov	 DWORD PTR _n$162002[ebp], ebx
  00094	be 60 00 00 00	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+96
  00099	eb 08		 jmp	 SHORT $LN7@gObjInit
  0009b	eb 03 8d 49 00	 npad	 5
$LL63@gObjInit:

; 625  : 	gObjCallMonCount= OBJ_MAXMONSTER;
; 626  : 
; 627  : 	CItem * pTempInventory = new CItem[INVENTORY_SIZE];

  000a0	83 cf ff	 or	 edi, -1
$LN7@gObjInit:

; 631  : 	{
; 632  : 		memset(&gObj[n], 0, sizeof(OBJECTSTRUCT));

  000a3	68 64 15 00 00	 push	 5476			; 00001564H
  000a8	8d 46 a0	 lea	 eax, DWORD PTR [esi-96]
  000ab	6a 00		 push	 0
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 _memset

; 633  : 		gObj[n].Type = (BYTE)OBJ_EMPTY;

  000b3	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bb	66 89 0e	 mov	 WORD PTR [esi], cx

; 634  : 		gObj[n].m_socket = INVALID_SOCKET;

  000be	89 7e b0	 mov	 DWORD PTR [esi-80], edi

; 635  : 		gObj[n].PathTime = GetTickCount();

  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 636  : 		gObj[n].m_RecallMon = -1;
; 637  : 		gObj[n].m_lpMagicBack = new CMagicInf[MAGIC_SIZE];

  000c7	68 c4 03 00 00	 push	 964			; 000003c4H
  000cc	89 86 3c 01 00
	00		 mov	 DWORD PTR [esi+316], eax
  000d2	89 be 6c 02 00
	00		 mov	 DWORD PTR [esi+620], edi
  000d8	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000dd	83 c4 04	 add	 esp, 4
  000e0	89 45 ec	 mov	 DWORD PTR $T170714[ebp], eax
  000e3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000ea	85 c0		 test	 eax, eax
  000ec	74 1f		 je	 SHORT $LN12@gObjInit
  000ee	68 00 00 00 00	 push	 OFFSET ??1CMagicInf@@UAE@XZ ; CMagicInf::~CMagicInf
  000f3	68 00 00 00 00	 push	 OFFSET ??0CMagicInf@@QAE@XZ ; CMagicInf::CMagicInf
  000f8	6a 3c		 push	 60			; 0000003cH
  000fa	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  000fd	6a 10		 push	 16			; 00000010H
  000ff	57		 push	 edi
  00100	c7 00 3c 00 00
	00		 mov	 DWORD PTR [eax], 60	; 0000003cH
  00106	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  0010b	eb 02		 jmp	 SHORT $LN13@gObjInit
$LN12@gObjInit:
  0010d	33 ff		 xor	 edi, edi
$LN13@gObjInit:

; 638  : 		gObj[n].Magic = new CMagicInf[MAGIC_SIZE];

  0010f	68 c4 03 00 00	 push	 964			; 000003c4H
  00114	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0011b	89 be d4 02 00
	00		 mov	 DWORD PTR [esi+724], edi
  00121	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00126	83 c4 04	 add	 esp, 4
  00129	89 45 ec	 mov	 DWORD PTR $T170718[ebp], eax
  0012c	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00133	85 c0		 test	 eax, eax
  00135	74 1f		 je	 SHORT $LN14@gObjInit
  00137	68 00 00 00 00	 push	 OFFSET ??1CMagicInf@@UAE@XZ ; CMagicInf::~CMagicInf
  0013c	68 00 00 00 00	 push	 OFFSET ??0CMagicInf@@QAE@XZ ; CMagicInf::CMagicInf
  00141	6a 3c		 push	 60			; 0000003cH
  00143	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00146	6a 10		 push	 16			; 00000010H
  00148	57		 push	 edi
  00149	c7 00 3c 00 00
	00		 mov	 DWORD PTR [eax], 60	; 0000003cH
  0014f	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  00154	eb 02		 jmp	 SHORT $LN15@gObjInit
$LN14@gObjInit:
  00156	33 ff		 xor	 edi, edi
$LN15@gObjInit:
  00158	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0015f	89 be d8 02 00
	00		 mov	 DWORD PTR [esi+728], edi

; 639  : 		
; 640  : 		if ( n >= OBJ_STARTUSERINDEX )

  00165	81 fb 00 19 00
	00		 cmp	 ebx, 6400		; 00001900H
  0016b	0f 8c ae 00 00
	00		 jl	 $LN4@gObjInit

; 641  : 		{
; 642  : 			gObj[n].Inventory1 = new CItem[INVENTORY_SIZE];

  00171	68 e0 46 00 00	 push	 18144			; 000046e0H
  00176	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0017b	83 c4 04	 add	 esp, 4
  0017e	89 45 ec	 mov	 DWORD PTR $T170722[ebp], eax
  00181	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00188	85 c0		 test	 eax, eax
  0018a	74 1c		 je	 SHORT $LN16@gObjInit
  0018c	8b f8		 mov	 edi, eax
  0018e	bb 6b 00 00 00	 mov	 ebx, 107		; 0000006bH
$LL36@gObjInit:
  00193	8b cf		 mov	 ecx, edi
  00195	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  0019a	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  001a0	4b		 dec	 ebx
  001a1	79 f0		 jns	 SHORT $LL36@gObjInit
  001a3	8b 45 ec	 mov	 eax, DWORD PTR $T170722[ebp]
  001a6	eb 02		 jmp	 SHORT $LN17@gObjInit
$LN16@gObjInit:
  001a8	33 c0		 xor	 eax, eax
$LN17@gObjInit:

; 643  : 			gObj[n].Inventory2 = new CItem[INVENTORY_SIZE];

  001aa	68 e0 46 00 00	 push	 18144			; 000046e0H
  001af	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001b6	89 86 3c 0c 00
	00		 mov	 DWORD PTR [esi+3132], eax
  001bc	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  001c1	8b d8		 mov	 ebx, eax
  001c3	83 c4 04	 add	 esp, 4
  001c6	89 5d e0	 mov	 DWORD PTR $T170726[ebp], ebx
  001c9	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  001d0	85 db		 test	 ebx, ebx
  001d2	74 20		 je	 SHORT $LN18@gObjInit
  001d4	8b fb		 mov	 edi, ebx
  001d6	c7 45 ec 6b 00
	00 00		 mov	 DWORD PTR $T170769[ebp], 107 ; 0000006bH
  001dd	8d 49 00	 npad	 3
$LL40@gObjInit:
  001e0	8b cf		 mov	 ecx, edi
  001e2	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  001e7	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  001ed	ff 4d ec	 dec	 DWORD PTR $T170769[ebp]
  001f0	79 ee		 jns	 SHORT $LL40@gObjInit
  001f2	eb 02		 jmp	 SHORT $LN19@gObjInit
$LN18@gObjInit:
  001f4	33 db		 xor	 ebx, ebx
$LN19@gObjInit:

; 644  : 			gObj[n].InventoryMap1 = new BYTE[INVENTORY_MAP_SIZE];

  001f6	6a 60		 push	 96			; 00000060H
  001f8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001ff	89 9e 48 0c 00
	00		 mov	 DWORD PTR [esi+3144], ebx
  00205	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 645  : 			gObj[n].InventoryMap2 = new BYTE[INVENTORY_MAP_SIZE];

  0020a	6a 60		 push	 96			; 00000060H
  0020c	89 86 40 0c 00
	00		 mov	 DWORD PTR [esi+3136], eax
  00212	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 646  : 		}
; 647  : 		else

  00217	8b 5d f0	 mov	 ebx, DWORD PTR _n$162002[ebp]
  0021a	83 c4 08	 add	 esp, 8
  0021d	eb 18		 jmp	 SHORT $LN65@gObjInit
$LN4@gObjInit:

; 648  : 		{
; 649  : 			gObj[n].Inventory1 = pTempInventory;

  0021f	8b 45 e8	 mov	 eax, DWORD PTR $T170708[ebp]
  00222	89 86 3c 0c 00
	00		 mov	 DWORD PTR [esi+3132], eax

; 650  : 			gObj[n].Inventory2 = pTempInventory;

  00228	89 86 48 0c 00
	00		 mov	 DWORD PTR [esi+3144], eax

; 651  : 			gObj[n].InventoryMap1 = pTempInventoryMap;

  0022e	8b 45 e4	 mov	 eax, DWORD PTR _pTempInventoryMap$[ebp]
  00231	89 86 40 0c 00
	00		 mov	 DWORD PTR [esi+3136], eax
$LN65@gObjInit:

; 652  : 			gObj[n].InventoryMap2 = pTempInventoryMap;

  00237	89 86 4c 0c 00
	00		 mov	 DWORD PTR [esi+3148], eax

; 653  : 		}
; 654  : 
; 655  : 		if ( n >= OBJ_STARTUSERINDEX )

  0023d	81 fb 00 19 00
	00		 cmp	 ebx, 6400		; 00001900H
  00243	0f 8c b4 00 00
	00		 jl	 $LN2@gObjInit

; 656  : 		{
; 657  : 			gObj[n].Trade = new CItem[TRADE_BOX_SIZE];

  00249	68 00 15 00 00	 push	 5376			; 00001500H
  0024e	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00253	83 c4 04	 add	 esp, 4
  00256	89 45 ec	 mov	 DWORD PTR $T170732[ebp], eax
  00259	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  00260	85 c0		 test	 eax, eax
  00262	74 21		 je	 SHORT $LN20@gObjInit
  00264	8b f8		 mov	 edi, eax
  00266	bb 1f 00 00 00	 mov	 ebx, 31			; 0000001fH
  0026b	eb 03 8d 49 00	 npad	 5
$LL44@gObjInit:
  00270	8b cf		 mov	 ecx, edi
  00272	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  00277	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  0027d	4b		 dec	 ebx
  0027e	79 f0		 jns	 SHORT $LL44@gObjInit
  00280	8b 45 ec	 mov	 eax, DWORD PTR $T170732[ebp]
  00283	eb 02		 jmp	 SHORT $LN21@gObjInit
$LN20@gObjInit:
  00285	33 c0		 xor	 eax, eax
$LN21@gObjInit:

; 658  : 			gObj[n].TradeMap = new BYTE[TRADE_BOX_MAP_SIZE];

  00287	6a 20		 push	 32			; 00000020H
  00289	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00290	89 86 54 0c 00
	00		 mov	 DWORD PTR [esi+3156], eax
  00296	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 659  : 			gObj[n].pWarehouse = new CItem[WAREHOUSE_SIZE];

  0029b	68 c0 4e 00 00	 push	 20160			; 00004ec0H
  002a0	89 86 58 0c 00
	00		 mov	 DWORD PTR [esi+3160], eax
  002a6	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  002ab	8b d8		 mov	 ebx, eax
  002ad	83 c4 08	 add	 esp, 8
  002b0	89 5d e0	 mov	 DWORD PTR $T170737[ebp], ebx
  002b3	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
  002ba	85 db		 test	 ebx, ebx
  002bc	74 1d		 je	 SHORT $LN22@gObjInit
  002be	8b fb		 mov	 edi, ebx
  002c0	c7 45 ec 77 00
	00 00		 mov	 DWORD PTR $T170783[ebp], 119 ; 00000077H
$LL48@gObjInit:
  002c7	8b cf		 mov	 ecx, edi
  002c9	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  002ce	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  002d4	ff 4d ec	 dec	 DWORD PTR $T170783[ebp]
  002d7	79 ee		 jns	 SHORT $LL48@gObjInit
  002d9	eb 02		 jmp	 SHORT $LN23@gObjInit
$LN22@gObjInit:
  002db	33 db		 xor	 ebx, ebx
$LN23@gObjInit:

; 660  : 			gObj[n].pWarehouseMap = new BYTE[WAREHOUSE_SIZE];

  002dd	6a 78		 push	 120			; 00000078H
  002df	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002e6	89 9e 64 0c 00
	00		 mov	 DWORD PTR [esi+3172], ebx
  002ec	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  002f1	8b 5d f0	 mov	 ebx, DWORD PTR _n$162002[ebp]
  002f4	83 c4 04	 add	 esp, 4
  002f7	89 86 68 0c 00
	00		 mov	 DWORD PTR [esi+3176], eax
$LN2@gObjInit:

; 661  : 		}
; 662  : 		
; 663  : 		gObj[n].WarehouseCount = 0;

  002fd	c6 86 6c 0c 00
	00 00		 mov	 BYTE PTR [esi+3180], 0

; 664  : 		gObj[n].pChaosBox = NULL;

  00304	c7 86 7c 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3196], 0

; 665  : 		
; 666  : 		if ( n >= OBJ_STARTUSERINDEX )

  0030e	81 fb 00 19 00
	00		 cmp	 ebx, 6400		; 00001900H
  00314	7c 10		 jl	 SHORT $LN1@gObjInit

; 667  : 		{
; 668  : 			gObj[n].PerSocketContext = new _PER_SOCKET_CONTEXT;

  00316	68 2c 5e 00 00	 push	 24108			; 00005e2cH
  0031b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00320	83 c4 04	 add	 esp, 4
  00323	89 46 ac	 mov	 DWORD PTR [esi-84], eax
$LN1@gObjInit:

; 669  : 		}
; 670  : 
; 671  : 		InitializeCriticalSection(&gObj[n].m_critPShopTrade);

  00326	8d 96 04 0d 00
	00		 lea	 edx, DWORD PTR [esi+3332]
  0032c	52		 push	 edx
  0032d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4
  00333	43		 inc	 ebx
  00334	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  0033a	89 5d f0	 mov	 DWORD PTR _n$162002[ebp], ebx
  0033d	81 fe 00 53 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522496
  00343	0f 8c 57 fd ff
	ff		 jl	 $LL63@gObjInit

; 672  : 	}
; 673  : 
; 674  : 
; 675  : 	InitFrustrum();

  00349	e8 00 00 00 00	 call	 ?InitFrustrum@@YAXXZ	; InitFrustrum

; 676  : }

  0034e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00351	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00358	59		 pop	 ecx
  00359	5f		 pop	 edi
  0035a	5e		 pop	 esi
  0035b	5b		 pop	 ebx
  0035c	8b e5		 mov	 esp, ebp
  0035e	5d		 pop	 ebp
  0035f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?gObjInit@@YAXXZ$0:
  00000	8b 45 e4	 mov	 eax, DWORD PTR $T170709[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__unwindfunclet$?gObjInit@@YAXXZ$1:
  0000b	8b 45 ec	 mov	 eax, DWORD PTR $T170714[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
__unwindfunclet$?gObjInit@@YAXXZ$2:
  00016	8b 45 ec	 mov	 eax, DWORD PTR $T170718[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001f	59		 pop	 ecx
  00020	c3		 ret	 0
__unwindfunclet$?gObjInit@@YAXXZ$3:
  00021	8b 45 ec	 mov	 eax, DWORD PTR $T170722[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002a	59		 pop	 ecx
  0002b	c3		 ret	 0
__unwindfunclet$?gObjInit@@YAXXZ$4:
  0002c	8b 45 e0	 mov	 eax, DWORD PTR $T170726[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00035	59		 pop	 ecx
  00036	c3		 ret	 0
__unwindfunclet$?gObjInit@@YAXXZ$5:
  00037	8b 45 ec	 mov	 eax, DWORD PTR $T170732[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00040	59		 pop	 ecx
  00041	c3		 ret	 0
__unwindfunclet$?gObjInit@@YAXXZ$6:
  00042	8b 45 e0	 mov	 eax, DWORD PTR $T170737[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0004b	59		 pop	 ecx
  0004c	c3		 ret	 0
__ehhandler$?gObjInit@@YAXXZ:
  0004d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00051	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00054	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00057	33 c8		 xor	 ecx, eax
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?gObjInit@@YAXXZ
  00063	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?gObjInit@@YAXXZ ENDP					; gObjInit
PUBLIC	?gObjCloseSet@@YAXHH@Z				; gObjCloseSet
EXTRN	?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z:PROC ; CBloodCastle::SearchUserDropQuestItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjCloseSet@@YAXHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_Flag$ = 12						; size = 4
?gObjCloseSet@@YAXHH@Z PROC				; gObjCloseSet, COMDAT

; 768  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 769  : 	if ( aIndex < 0 || aIndex > OBJMAX-1 )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  0000c	0f 87 0c 01 00
	00		 ja	 $LN13@gObjCloseS

; 770  : 	{
; 771  : 		return;
; 772  : 	}
; 773  : 
; 774  : 	LPOBJ lpObj = &gObj[aIndex];

  00012	56		 push	 esi
  00013	8b f1		 mov	 esi, ecx
  00015	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0001b	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 775  : 
; 776  : 	if ( lpObj->CloseCount > 0 )

  00021	80 7e 07 00	 cmp	 BYTE PTR [esi+7], 0
  00025	0f 8f f2 00 00
	00		 jg	 $LN20@gObjCloseS

; 777  : 	{
; 778  : 		return;
; 779  : 	}
; 780  : 
; 781  : 	if ( lpObj->Connected == PLAYER_PLAYING )

  0002b	80 7e 04 03	 cmp	 BYTE PTR [esi+4], 3
  0002f	0f 85 da 00 00
	00		 jne	 $LN8@gObjCloseS

; 782  : 	{
; 783  : 		
; 784  : 		if ( BC_MAP_RANGE(lpObj->MapNumber) )

  00035	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  0003c	3c 0b		 cmp	 al, 11			; 0000000bH
  0003e	72 14		 jb	 SHORT $LN10@gObjCloseS
  00040	b2 11		 mov	 dl, 17			; 00000011H
  00042	3a d0		 cmp	 dl, al
  00044	1b c0		 sbb	 eax, eax
  00046	40		 inc	 eax
  00047	74 0b		 je	 SHORT $LN10@gObjCloseS

; 785  : 		{
; 786  : 			g_BloodCastle.SearchUserDropQuestItem(aIndex);

  00049	51		 push	 ecx
  0004a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0004f	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem
$LN10@gObjCloseS:

; 787  : 		}
; 788  : 
; 789  : 		if ( (GetTickCount() - lpObj->MySelfDefenseTime )< 30000)

  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0005a	2b 86 70 02 00
	00		 sub	 eax, DWORD PTR [esi+624]
  00060	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00065	73 0f		 jae	 SHORT $LN9@gObjCloseS

; 790  : 		{
; 791  : 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 109)), lpObj->m_Index, 1);

  00067	8b 06		 mov	 eax, DWORD PTR [esi]
  00069	6a 01		 push	 1
  0006b	50		 push	 eax
  0006c	68 6d 04 00 00	 push	 1133			; 0000046dH

; 792  : 			return;

  00071	e9 83 00 00 00	 jmp	 $LN21@gObjCloseS
$LN9@gObjCloseS:

; 793  : 		}
; 794  : 
; 795  : 		if ( (lpObj->m_IfState.use != 0 ) && ( ( lpObj->m_IfState.type == 1 ) || (lpObj->m_IfState.type == 6) || (lpObj->m_IfState.type == 13) || (lpObj->m_IfState.type == 7)  ) ) 

  00076	8b 86 84 0c 00
	00		 mov	 eax, DWORD PTR [esi+3204]
  0007c	a8 03		 test	 al, 3
  0007e	0f 84 8b 00 00
	00		 je	 $LN8@gObjCloseS
  00084	c1 e8 06	 shr	 eax, 6
  00087	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0008c	83 f8 01	 cmp	 eax, 1
  0008f	74 0f		 je	 SHORT $LN7@gObjCloseS
  00091	83 f8 06	 cmp	 eax, 6
  00094	74 0a		 je	 SHORT $LN7@gObjCloseS
  00096	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00099	74 05		 je	 SHORT $LN7@gObjCloseS
  0009b	83 f8 07	 cmp	 eax, 7
  0009e	75 6f		 jne	 SHORT $LN8@gObjCloseS
$LN7@gObjCloseS:

; 796  : 		{
; 797  : 			gObjSaveChaosBoxItemList(lpObj);

  000a0	56		 push	 esi
  000a1	e8 00 00 00 00	 call	 ?gObjSaveChaosBoxItemList@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSaveChaosBoxItemList

; 798  : 			switch ( lpObj->m_IfState.type )

  000a6	8b 86 84 0c 00
	00		 mov	 eax, DWORD PTR [esi+3204]
  000ac	c1 e8 06	 shr	 eax, 6
  000af	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  000b4	48		 dec	 eax
  000b5	83 c4 04	 add	 esp, 4
  000b8	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  000bb	77 60		 ja	 SHORT $LN20@gObjCloseS
  000bd	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN19@gObjCloseS[eax]
  000c4	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN22@gObjCloseS[ecx*4]
$LN4@gObjCloseS:

; 799  : 			{
; 800  : 				case 1:
; 801  : 					GCServerMsgStringSend(lMsg.Get(MSGGET(4, 110)), lpObj->m_Index, 1);

  000cb	8b 16		 mov	 edx, DWORD PTR [esi]
  000cd	6a 01		 push	 1
  000cf	52		 push	 edx
  000d0	68 6e 04 00 00	 push	 1134			; 0000046eH

; 802  : 					break;

  000d5	eb 22		 jmp	 SHORT $LN21@gObjCloseS
$LN3@gObjCloseS:

; 803  : 
; 804  : 				case 6:
; 805  : 					GCServerMsgStringSend(lMsg.Get(MSGGET(4, 111)), lpObj->m_Index, 1);

  000d7	8b 06		 mov	 eax, DWORD PTR [esi]
  000d9	6a 01		 push	 1
  000db	50		 push	 eax
  000dc	68 6f 04 00 00	 push	 1135			; 0000046fH

; 806  : 					break;

  000e1	eb 16		 jmp	 SHORT $LN21@gObjCloseS
$LN2@gObjCloseS:

; 807  : 
; 808  : 				case 7:
; 809  : 					GCServerMsgStringSend(lMsg.Get(MSGGET(4, 127)), lpObj->m_Index, 1);

  000e3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000e5	6a 01		 push	 1
  000e7	51		 push	 ecx
  000e8	68 7f 04 00 00	 push	 1151			; 0000047fH

; 810  : 					break;

  000ed	eb 0a		 jmp	 SHORT $LN21@gObjCloseS
$LN1@gObjCloseS:

; 811  : 
; 812  : 				case 13:
; 813  : 					GCServerMsgStringSend(lMsg.Get(MSGGET(4, 229)), lpObj->m_Index, 1);

  000ef	8b 16		 mov	 edx, DWORD PTR [esi]
  000f1	6a 01		 push	 1
  000f3	52		 push	 edx
  000f4	68 e5 04 00 00	 push	 1253			; 000004e5H
$LN21@gObjCloseS:
  000f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000fe	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010c	5e		 pop	 esi

; 824  : 	
; 825  : }

  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
$LN8@gObjCloseS:

; 814  : 					break;
; 815  : 			}
; 816  : 
; 817  : 			return;
; 818  : 		}
; 819  : 	}
; 820  : 	
; 821  : 	lpObj->CloseCount = 6;
; 822  : 	lpObj->CloseType = Flag;

  0010f	8a 45 0c	 mov	 al, BYTE PTR _Flag$[ebp]
  00112	c6 46 07 06	 mov	 BYTE PTR [esi+7], 6
  00116	88 46 08	 mov	 BYTE PTR [esi+8], al

; 823  : 	lpObj->bEnableDelCharacter = 1;

  00119	c6 46 09 01	 mov	 BYTE PTR [esi+9], 1
$LN20@gObjCloseS:
  0011d	5e		 pop	 esi
$LN13@gObjCloseS:

; 824  : 	
; 825  : }

  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
$LN22@gObjCloseS:
  00120	00 00 00 00	 DD	 $LN4@gObjCloseS
  00124	00 00 00 00	 DD	 $LN3@gObjCloseS
  00128	00 00 00 00	 DD	 $LN2@gObjCloseS
  0012c	00 00 00 00	 DD	 $LN1@gObjCloseS
  00130	00 00 00 00	 DD	 $LN20@gObjCloseS
$LN19@gObjCloseS:
  00134	00		 DB	 0
  00135	04		 DB	 4
  00136	04		 DB	 4
  00137	04		 DB	 4
  00138	04		 DB	 4
  00139	01		 DB	 1
  0013a	02		 DB	 2
  0013b	04		 DB	 4
  0013c	04		 DB	 4
  0013d	04		 DB	 4
  0013e	04		 DB	 4
  0013f	04		 DB	 4
  00140	03		 DB	 3
?gObjCloseSet@@YAXHH@Z ENDP				; gObjCloseSet
_TEXT	ENDS
PUBLIC	?gObjCharZeroSet@@YAXH@Z			; gObjCharZeroSet
EXTRN	?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterHitDamageInit
EXTRN	?Init@CSkillDelay@@QAEXXZ:PROC			; CSkillDelay::Init
EXTRN	?ClearCheckSum@CPacketCheckSum@@QAEXH@Z:PROC	; CPacketCheckSum::ClearCheckSum
EXTRN	?gPacketCheckSum@@3VCPacketCheckSum@@A:BYTE	; gPacketCheckSum
; Function compile flags: /Ogtp
;	COMDAT ?gObjCharZeroSet@@YAXH@Z
_TEXT	SEGMENT
tv1984 = -4						; size = 4
tv2028 = 8						; size = 4
_aIndex$ = 8						; size = 4
?gObjCharZeroSet@@YAXH@Z PROC				; gObjCharZeroSet, COMDAT

; 846  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 847  : 	int i;
; 848  : 	LPOBJ lpObj = &gObj[aIndex];
; 849  : 	int n;
; 850  : 
; 851  : 	memset( lpObj->Name, 0, MAX_ACCOUNT_LEN);
; 852  : 	memset( lpObj->GuildName, 0, sizeof (lpObj->GuildName ));
; 853  : 	lpObj->m_Option = 3;
; 854  : 	lpObj->m_iScriptMaxLife = 0;
; 855  : 	lpObj->Level = 0;
; 856  : 
; 857  : 	memset( lpObj->BackName,0,sizeof(lpObj->BackName));
; 858  : 
; 859  : 	lpObj->Life = 0;

  00005	56		 push	 esi

; 883  : 	lpObj->m_InterfaceTime = 0;
; 884  : 	lpObj->m_ActionNumber = 0;
; 885  : 	lpObj->m_State = 0;
; 886  : 	lpObj->m_StateSub = 0;
; 887  : 	lpObj->m_ViewState = 0;
; 888  : 	lpObj->m_Rest = 0;
; 889  : 
; 890  : 	lpObj->m_ViewSkillState = 0;
; 891  : 	lpObj->m_PoisonBeattackCount = 0;
; 892  : 	lpObj->m_ColdBeattackCount = 0;
; 893  : 	lpObj->m_Attribute = 0;
; 894  : 	lpObj->m_ImmuneToMagicCount = 0;
; 895  : 	lpObj->m_ImmuneToHarmCount = 0;
; 896  : 	lpObj->m_iMonsterBattleDelay = 0;
; 897  : 	lpObj->m_cKalimaGateExist = FALSE;
; 898  : 	lpObj->m_iKalimaGateIndex = -1;
; 899  : 	lpObj->m_cKalimaGateEnterCount = 0;
; 900  : 	lpObj->TradeOk = false;
; 901  : 	lpObj->sHDCount = 0;
; 902  : 	lpObj->PathCount = 0;
; 903  : 	lpObj->PathCur = 0;
; 904  : 	lpObj->PathStartEnd = 0;
; 905  : 	lpObj->VPCount = 0;
; 906  : 	lpObj->VPCount2 = 0;
; 907  : 	lpObj->m_ShopTime = 0;
; 908  : 	lpObj->m_ManaFillCount = 0;
; 909  : 	lpObj->FillLife = 0;

  00006	57		 push	 edi

; 847  : 	int i;
; 848  : 	LPOBJ lpObj = &gObj[aIndex];
; 849  : 	int n;
; 850  : 
; 851  : 	memset( lpObj->Name, 0, MAX_ACCOUNT_LEN);
; 852  : 	memset( lpObj->GuildName, 0, sizeof (lpObj->GuildName ));
; 853  : 	lpObj->m_Option = 3;
; 854  : 	lpObj->m_iScriptMaxLife = 0;
; 855  : 	lpObj->Level = 0;
; 856  : 
; 857  : 	memset( lpObj->BackName,0,sizeof(lpObj->BackName));
; 858  : 
; 859  : 	lpObj->Life = 0;

  00007	d9 ee		 fldz
  00009	33 db		 xor	 ebx, ebx
  0000b	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000e	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00014	8d b6 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  0001a	89 5e 6f	 mov	 DWORD PTR [esi+111], ebx
  0001d	89 5e 73	 mov	 DWORD PTR [esi+115], ebx
  00020	66 89 5e 77	 mov	 WORD PTR [esi+119], bx
  00024	89 9e b8 02 00
	00		 mov	 DWORD PTR [esi+696], ebx
  0002a	89 9e bc 02 00
	00		 mov	 DWORD PTR [esi+700], ebx
  00030	66 89 9e c0 02
	00 00		 mov	 WORD PTR [esi+704], bx
  00037	88 9e c2 02 00
	00		 mov	 BYTE PTR [esi+706], bl
  0003d	33 c0		 xor	 eax, eax
  0003f	c7 86 f0 0c 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+3312], 3
  00049	89 9e c4 00 00
	00		 mov	 DWORD PTR [esi+196], ebx
  0004f	66 89 86 9c 00
	00 00		 mov	 WORD PTR [esi+156], ax
  00056	89 9e 15 0f 00
	00		 mov	 DWORD PTR [esi+3861], ebx
  0005c	89 9e 19 0f 00
	00		 mov	 DWORD PTR [esi+3865], ebx
  00062	66 89 9e 1d 0f
	00 00		 mov	 WORD PTR [esi+3869], bx
  00069	88 9e 1f 0f 00
	00		 mov	 BYTE PTR [esi+3871], bl

; 860  : 	lpObj->MaxLife = 0;
; 861  : 	lpObj->AddLife = 0;
; 862  : 	lpObj->AddMana = 0;
; 863  : 	lpObj->Live = FALSE;
; 864  : 	lpObj->Dir = 0;
; 865  : 	lpObj->X = 0;

  0006f	33 c9		 xor	 ecx, ecx
  00071	89 8e 04 01 00
	00		 mov	 DWORD PTR [esi+260], ecx
  00077	d9 96 bc 00 00
	00		 fst	 DWORD PTR [esi+188]

; 866  : 	lpObj->Y = 0;
; 867  : 	lpObj->TX = 0;
; 868  : 	lpObj->TY = 0;
; 869  : 	lpObj->MTX = 0;
; 870  : 	lpObj->MTY = 0;
; 871  : 	lpObj->MapNumber = MAP_INDEX_LORENCIA;
; 872  : 	lpObj->RegenTime = 0;
; 873  : 	lpObj->m_State = 0;
; 874  : 	lpObj->RegenOk = 0;
; 875  : 	lpObj->lpAttackObj = 0;
; 876  : 	lpObj->PartyTargetUser = -1;
; 877  : 	lpObj->m_MoveGateNumber = -1;
; 878  : 	lpObj->CloseCount = -1;
; 879  : 	lpObj->CloseType = -1;
; 880  : 	lpObj->m_IfState.state = -1;
; 881  : 	lpObj->m_IfState.type = -1;
; 882  : 	lpObj->m_IfState.use = 0;

  0007d	8b 8e 84 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3204]
  00083	d9 96 c0 00 00
	00		 fst	 DWORD PTR [esi+192]
  00089	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 883  : 	lpObj->m_InterfaceTime = 0;
; 884  : 	lpObj->m_ActionNumber = 0;
; 885  : 	lpObj->m_State = 0;
; 886  : 	lpObj->m_StateSub = 0;
; 887  : 	lpObj->m_ViewState = 0;
; 888  : 	lpObj->m_Rest = 0;
; 889  : 
; 890  : 	lpObj->m_ViewSkillState = 0;
; 891  : 	lpObj->m_PoisonBeattackCount = 0;
; 892  : 	lpObj->m_ColdBeattackCount = 0;
; 893  : 	lpObj->m_Attribute = 0;
; 894  : 	lpObj->m_ImmuneToMagicCount = 0;
; 895  : 	lpObj->m_ImmuneToHarmCount = 0;
; 896  : 	lpObj->m_iMonsterBattleDelay = 0;
; 897  : 	lpObj->m_cKalimaGateExist = FALSE;
; 898  : 	lpObj->m_iKalimaGateIndex = -1;
; 899  : 	lpObj->m_cKalimaGateEnterCount = 0;
; 900  : 	lpObj->TradeOk = false;
; 901  : 	lpObj->sHDCount = 0;
; 902  : 	lpObj->PathCount = 0;
; 903  : 	lpObj->PathCur = 0;
; 904  : 	lpObj->PathStartEnd = 0;
; 905  : 	lpObj->VPCount = 0;
; 906  : 	lpObj->VPCount2 = 0;
; 907  : 	lpObj->m_ShopTime = 0;
; 908  : 	lpObj->m_ManaFillCount = 0;
; 909  : 	lpObj->FillLife = 0;

  0008c	d9 9e c8 00 00
	00		 fstp	 DWORD PTR [esi+200]
  00092	33 d2		 xor	 edx, edx
  00094	81 c9 fc ff 00
	00		 or	 ecx, 65532		; 0000fffcH
  0009a	83 cf ff	 or	 edi, -1
  0009d	89 8e 84 0c 00
	00		 mov	 DWORD PTR [esi+3204], ecx

; 910  : 	lpObj->iObjectSecTimer = 0;
; 911  : 	lpObj->m_FriendServerOnline = FALSE;
; 912  : 	lpObj->SetOpAddMaxAttackDamage = 0;

  000a3	33 c9		 xor	 ecx, ecx
  000a5	89 9e 0c 01 00
	00		 mov	 DWORD PTR [esi+268], ebx
  000ab	89 9e 10 01 00
	00		 mov	 DWORD PTR [esi+272], ebx
  000b1	88 5e 62	 mov	 BYTE PTR [esi+98], bl
  000b4	89 86 20 01 00
	00		 mov	 DWORD PTR [esi+288], eax
  000ba	89 96 24 01 00
	00		 mov	 DWORD PTR [esi+292], edx
  000c0	66 89 9e 08 01
	00 00		 mov	 WORD PTR [esi+264], bx
  000c7	89 9e 08 02 00
	00		 mov	 DWORD PTR [esi+520], ebx
  000cd	88 9e 03 02 00
	00		 mov	 BYTE PTR [esi+515], bl
  000d3	89 9e 38 02 00
	00		 mov	 DWORD PTR [esi+568], ebx
  000d9	89 be ac 02 00
	00		 mov	 DWORD PTR [esi+684], edi
  000df	c6 86 a0 01 00
	00 ff		 mov	 BYTE PTR [esi+416], 255	; 000000ffH
  000e6	66 c7 46 07 ff
	ff		 mov	 WORD PTR [esi+7], 65535	; 0000ffffH
  000ec	89 9e 88 0c 00
	00		 mov	 DWORD PTR [esi+3208], ebx
  000f2	88 9e b8 01 00
	00		 mov	 BYTE PTR [esi+440], bl
  000f8	89 9e bc 01 00
	00		 mov	 DWORD PTR [esi+444], ebx
  000fe	88 9e c0 01 00
	00		 mov	 BYTE PTR [esi+448], bl
  00104	66 89 9e c1 01
	00 00		 mov	 WORD PTR [esi+449], bx
  0010b	89 9e c4 01 00
	00		 mov	 DWORD PTR [esi+452], ebx
  00111	66 89 96 26 03
	00 00		 mov	 WORD PTR [esi+806], dx
  00118	89 9e 27 02 00
	00		 mov	 DWORD PTR [esi+551], ebx
  0011e	66 89 9e 2b 02
	00 00		 mov	 WORD PTR [esi+555], bx
  00125	89 be 30 02 00
	00		 mov	 DWORD PTR [esi+560], edi
  0012b	88 9e 34 02 00
	00		 mov	 BYTE PTR [esi+564], bl
  00131	88 9e c0 0c 00
	00		 mov	 BYTE PTR [esi+3264], bl
  00137	66 89 86 80 0c
	00 00		 mov	 WORD PTR [esi+3200], ax
  0013e	89 9e 28 01 00
	00		 mov	 DWORD PTR [esi+296], ebx
  00144	89 9e 2c 01 00
	00		 mov	 DWORD PTR [esi+300], ebx
  0014a	88 9e 30 01 00
	00		 mov	 BYTE PTR [esi+304], bl
  00150	89 9e 98 0a 00
	00		 mov	 DWORD PTR [esi+2712], ebx
  00156	89 9e 9c 0a 00
	00		 mov	 DWORD PTR [esi+2716], ebx
  0015c	88 9e f0 01 00
	00		 mov	 BYTE PTR [esi+496], bl
  00162	88 9e 45 02 00
	00		 mov	 BYTE PTR [esi+581], bl
  00168	89 9e c0 14 00
	00		 mov	 DWORD PTR [esi+5312], ebx
  0016e	88 9e d0 01 00
	00		 mov	 BYTE PTR [esi+464], bl
  00174	89 8e 6e 0f 00
	00		 mov	 DWORD PTR [esi+3950], ecx

; 913  : 	lpObj->SetOpAddMinAttackDamage = 0;
; 914  : 	lpObj->SetOpAddDamage = 0;

  0017a	89 86 6a 0f 00
	00		 mov	 DWORD PTR [esi+3946], eax

; 915  : 	lpObj->SetOpIncAGValue = 0;
; 916  : 	lpObj->SetOpAddCriticalDamageSuccessRate = 0;

  00180	89 96 66 0f 00
	00		 mov	 DWORD PTR [esi+3942], edx

; 917  : 	lpObj->SetOpAddCriticalDamage = 0;
; 918  : 	lpObj->SetOpAddExDamageSuccessRate = 0;

  00186	89 8e 62 0f 00
	00		 mov	 DWORD PTR [esi+3938], ecx

; 919  : 	lpObj->SetOpAddExDamage = 0;
; 920  : 	lpObj->SetOpAddSkillAttack = 0;

  0018c	66 89 86 60 0f
	00 00		 mov	 WORD PTR [esi+3936], ax

; 921  : 	lpObj->AddStrength = 0;

  00193	89 8e e0 00 00
	00		 mov	 DWORD PTR [esi+224], ecx

; 922  : 	lpObj->AddDexterity = 0;
; 923  : 	lpObj->AddVitality = 0;

  00199	89 86 e4 00 00
	00		 mov	 DWORD PTR [esi+228], eax

; 924  : 	lpObj->AddEnergy = 0;
; 925  : 	lpObj->SetOpAddAttackDamage = 0;

  0019f	89 96 72 0f 00
	00		 mov	 DWORD PTR [esi+3954], edx

; 926  : 	lpObj->SetOpAddDefence = 0;
; 927  : 	lpObj->SetOpAddMagicPower = 0;

  001a5	89 8e 76 0f 00
	00		 mov	 DWORD PTR [esi+3958], ecx

; 928  : 	lpObj->SetOpAddDefenceRate = 0;
; 929  : 	lpObj->SetOpIgnoreDefense = 0;

  001ab	89 9e 7a 0f 00
	00		 mov	 DWORD PTR [esi+3962], ebx

; 930  : 	lpObj->SetOpDoubleDamage = 0;
; 931  : 	lpObj->SetOpTwoHandSwordImproveDamage = 0;
; 932  : 	lpObj->SetOpImproveSuccessAttackRate = 0;
; 933  : 	lpObj->SetOpReflectionDamage = 0;

  001b1	89 9e 7e 0f 00
	00		 mov	 DWORD PTR [esi+3966], ebx

; 934  : 	lpObj->SetOpImproveSheldDefence = 0;
; 935  : 	lpObj->SetOpDecreaseAG = 0;
; 936  : 	lpObj->SetOpImproveItemDropRate = 0;
; 937  : 	memset( lpObj->m_AddResistance, 0, sizeof(lpObj->m_AddResistance));

  001b7	89 9e 69 03 00
	00		 mov	 DWORD PTR [esi+873], ebx
  001bd	66 89 9e 6d 03
	00 00		 mov	 WORD PTR [esi+877], bx
  001c4	88 9e 6f 03 00
	00		 mov	 BYTE PTR [esi+879], bl

; 938  : 	lpObj->IsFullSetItem = false;
; 939  : 	lpObj->DamageMinus = 0;
; 940  : 	lpObj->DamageReflect = 0;
; 941  : 	lpObj->MonsterDieGetMoney = 0;
; 942  : 	lpObj->MonsterDieGetLife = 0;
; 943  : 	lpObj->MonsterDieGetMana = 0;
; 944  : 	lpObj->m_CriticalDamage = 0;
; 945  : 	lpObj->m_ExcelentDamage = 0;
; 946  : 	lpObj->UseMagicNumber = 0;
; 947  : 	lpObj->UseMagicTime = 0;
; 948  : 	lpObj->UseMagicCount = 0;
; 949  : 	lpObj->OSAttackSerial = -1;

  001ca	8b cf		 mov	 ecx, edi
  001cc	88 9e 82 0f 00
	00		 mov	 BYTE PTR [esi+3970], bl
  001d2	89 9e 14 01 00
	00		 mov	 DWORD PTR [esi+276], ebx
  001d8	66 89 9e 18 01
	00 00		 mov	 WORD PTR [esi+280], bx
  001df	89 9e 2c 03 00
	00		 mov	 DWORD PTR [esi+812], ebx
  001e5	89 9e 30 03 00
	00		 mov	 DWORD PTR [esi+816], ebx
  001eb	88 9e 3d 03 00
	00		 mov	 BYTE PTR [esi+829], bl
  001f1	89 9e 40 03 00
	00		 mov	 DWORD PTR [esi+832], ebx
  001f7	88 9e 44 03 00
	00		 mov	 BYTE PTR [esi+836], bl
  001fd	66 89 8e 46 03
	00 00		 mov	 WORD PTR [esi+838], cx

; 950  : 	lpObj->SASCount = 0;

  00204	88 9e 48 03 00
	00		 mov	 BYTE PTR [esi+840], bl

; 951  : 	lpObj->SkillAttackTime = GetTickCount();

  0020a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00210	89 86 4c 03 00
	00		 mov	 DWORD PTR [esi+844], eax

; 952  : 	lpObj->m_AttackSpeed = 0;

  00216	89 9e 08 03 00
	00		 mov	 DWORD PTR [esi+776], ebx

; 953  : 	lpObj->m_MagicSpeed = 0;

  0021c	89 9e 0c 03 00
	00		 mov	 DWORD PTR [esi+780], ebx

; 954  : 	lpObj->m_TotalAttackTime = GetTickCount();

  00222	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00228	89 86 f4 01 00
	00		 mov	 DWORD PTR [esi+500], eax

; 955  : 	lpObj->m_TotalAttackCount = 0;

  0022e	89 9e f8 01 00
	00		 mov	 DWORD PTR [esi+504], ebx

; 956  : 	lpObj->CheckSumTime = GetTickCount() + 10000;

  00234	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0023a	05 10 27 00 00	 add	 eax, 10000		; 00002710H
  0023f	89 46 5c	 mov	 DWORD PTR [esi+92], eax

; 957  : 	lpObj->CheckSumTableNum = -1;

  00242	8b d7		 mov	 edx, edi
  00244	66 89 56 58	 mov	 WORD PTR [esi+88], dx

; 958  : 	lpObj->m_SumLastAttackTime = 0;

  00248	89 9e d8 01 00
	00		 mov	 DWORD PTR [esi+472], ebx

; 959  : 	lpObj->m_DetectCount = 0;

  0024e	89 9e dc 01 00
	00		 mov	 DWORD PTR [esi+476], ebx

; 960  : 	lpObj->m_DetectSpeedHackTime = 0;

  00254	89 9e d4 01 00
	00		 mov	 DWORD PTR [esi+468], ebx

; 961  : 	lpObj->m_SpeedHackPenalty = 0;

  0025a	89 9e e4 01 00
	00		 mov	 DWORD PTR [esi+484], ebx

; 962  : 	lpObj->m_DetectedHackKickCount = 0;

  00260	89 9e e0 01 00
	00		 mov	 DWORD PTR [esi+480], ebx

; 963  : 	lpObj->IsInBattleGround = false;

  00266	88 9e aa 0e 00
	00		 mov	 BYTE PTR [esi+3754], bl

; 964  : 	lpObj->m_dwPKTimer = GetTickCount();

  0026c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00272	89 46 54	 mov	 DWORD PTR [esi+84], eax

; 965  : 	lpObj->CheckTickCount = 0;

  00275	88 5e 44	 mov	 BYTE PTR [esi+68], bl

; 966  : 	lpObj->m_AttackSpeedHackDetectedCount = 0;

  00278	88 9e e8 01 00
	00		 mov	 BYTE PTR [esi+488], bl
  0027e	8d 86 14 07 00
	00		 lea	 eax, DWORD PTR [esi+1812]
  00284	8d 4b 4b	 lea	 ecx, DWORD PTR [ebx+75]
  00287	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL35@gObjCharZe:

; 967  : 
; 968  : 	for (int n =0;n<MAX_VIEWPORT ;n++)
; 969  : 	{
; 970  : 		lpObj->VpPlayer[n].state = 0;
; 971  : 		lpObj->VpPlayer2[n].state = 0;
; 972  : 		lpObj->VpPlayer[n].number = -1;

  00290	8b d7		 mov	 edx, edi
  00292	88 98 7c fc ff
	ff		 mov	 BYTE PTR [eax-900], bl
  00298	88 18		 mov	 BYTE PTR [eax], bl
  0029a	66 89 90 7e fc
	ff ff		 mov	 WORD PTR [eax-898], dx

; 973  : 		lpObj->VpPlayer2[n].number = -1;

  002a1	66 89 50 02	 mov	 WORD PTR [eax+2], dx
  002a5	83 c0 0c	 add	 eax, 12			; 0000000cH
  002a8	49		 dec	 ecx
  002a9	75 e5		 jne	 SHORT $LL35@gObjCharZe

; 974  : 	}
; 975  : 
; 976  : 	lpObj->GuildNumber = 0;

  002ab	89 9e b0 02 00
	00		 mov	 DWORD PTR [esi+688], ebx

; 977  : 	lpObj->lpGuild = NULL;

  002b1	89 9e b4 02 00
	00		 mov	 DWORD PTR [esi+692], ebx

; 978  : 	lpObj->PartyNumber = -1;

  002b7	89 be a8 02 00
	00		 mov	 DWORD PTR [esi+680], edi

; 979  : 	lpObj->PartyTargetUser = -1;

  002bd	89 be ac 02 00
	00		 mov	 DWORD PTR [esi+684], edi

; 980  : 	lpObj->m_Drink = 0;

  002c3	88 9e 74 02 00
	00		 mov	 BYTE PTR [esi+628], bl

; 981  : 	lpObj->Authority = 0;

  002c9	89 9e a4 01 00
	00		 mov	 DWORD PTR [esi+420], ebx

; 982  : 	lpObj->AuthorityCode = 0;

  002cf	89 9e a8 01 00
	00		 mov	 DWORD PTR [esi+424], ebx

; 983  : 	lpObj->Penalty = 0;

  002d5	89 9e ac 01 00
	00		 mov	 DWORD PTR [esi+428], ebx

; 984  : 	lpObj->m_RecallMon = -1;

  002db	89 be cc 02 00
	00		 mov	 DWORD PTR [esi+716], edi

; 985  : 	lpObj->m_Change = -1;

  002e1	89 be d0 02 00
	00		 mov	 DWORD PTR [esi+720], edi

; 986  : 	lpObj->GuildStatus = -1;

  002e7	89 be c4 02 00
	00		 mov	 DWORD PTR [esi+708], edi

; 987  : 	lpObj->LastAttackerID = -1;

  002ed	8b c7		 mov	 eax, edi
  002ef	66 89 86 da 02
	00 00		 mov	 WORD PTR [esi+730], ax

; 988  : 	lpObj->m_cChaosCastleIndex= -1;

  002f6	66 c7 86 09 0d
	00 00 ff ff	 mov	 WORD PTR [esi+3337], 65535 ; 0000ffffH

; 989  : 	lpObj->m_cChaosCastleSubIndex = -1;
; 990  : 	lpObj->m_iChaosCastleBlowTime = 0;

  002ff	89 9e 0c 0d 00
	00		 mov	 DWORD PTR [esi+3340], ebx

; 991  : 	lpObj->m_cKillUserCount = 0;

  00305	66 89 9e 10 0d
	00 00		 mov	 WORD PTR [esi+3344], bx

; 992  : 	lpObj->m_cKillMonsterCount = 0;
; 993  : 	memset( lpObj->CharSet, 0, sizeof(lpObj->CharSet));

  0030c	89 9e 50 03 00
	00		 mov	 DWORD PTR [esi+848], ebx
  00312	89 9e 54 03 00
	00		 mov	 DWORD PTR [esi+852], ebx
  00318	89 9e 58 03 00
	00		 mov	 DWORD PTR [esi+856], ebx
  0031e	89 9e 5c 03 00
	00		 mov	 DWORD PTR [esi+860], ebx
  00324	66 89 9e 60 03
	00 00		 mov	 WORD PTR [esi+864], bx

; 994  : 
; 995  : 	for ( i =0; i<MAX_SELF_DEFENSE;i++)
; 996  : 	{
; 997  : 		lpObj->SelfDefense[i] = -1;

  0032b	89 be 48 02 00
	00		 mov	 DWORD PTR [esi+584], edi

; 998  : 		lpObj->SelfDefenseTime[i] = 0;

  00331	89 9e 5c 02 00
	00		 mov	 DWORD PTR [esi+604], ebx
  00337	89 be 4c 02 00
	00		 mov	 DWORD PTR [esi+588], edi
  0033d	89 9e 60 02 00
	00		 mov	 DWORD PTR [esi+608], ebx
  00343	89 be 50 02 00
	00		 mov	 DWORD PTR [esi+592], edi
  00349	89 9e 64 02 00
	00		 mov	 DWORD PTR [esi+612], ebx
  0034f	89 be 54 02 00
	00		 mov	 DWORD PTR [esi+596], edi
  00355	89 9e 68 02 00
	00		 mov	 DWORD PTR [esi+616], ebx
  0035b	89 be 58 02 00
	00		 mov	 DWORD PTR [esi+600], edi
  00361	89 9e 6c 02 00
	00		 mov	 DWORD PTR [esi+620], ebx

; 999  : 	}
; 1000 : 
; 1001 : 	lpObj->MySelfDefenseTime = 0;

  00367	89 9e 70 02 00
	00		 mov	 DWORD PTR [esi+624], ebx

; 1002 : 	lpObj->m_MagicDefense = 0;

  0036d	89 9e 14 03 00
	00		 mov	 DWORD PTR [esi+788], ebx

; 1003 : 	lpObj->m_SkillDefense = 0;

  00373	89 9e 78 02 00
	00		 mov	 DWORD PTR [esi+632], ebx

; 1004 : 	lpObj->m_SkillDefenseTime = 0;

  00379	88 9e 7c 02 00
	00		 mov	 BYTE PTR [esi+636], bl

; 1005 : 	lpObj->m_SkillAttack = 0;

  0037f	89 9e 80 02 00
	00		 mov	 DWORD PTR [esi+640], ebx

; 1006 : 	lpObj->m_SkillAttackTime = 0;

  00385	88 9e 84 02 00
	00		 mov	 BYTE PTR [esi+644], bl

; 1007 : 	lpObj->m_SkillAttack2 = 0;

  0038b	89 9e 88 02 00
	00		 mov	 DWORD PTR [esi+648], ebx

; 1008 : 	lpObj->m_SkillAttackTime2 = 0;

  00391	88 9e 8c 02 00
	00		 mov	 BYTE PTR [esi+652], bl

; 1009 : 	lpObj->LoadWareHouseInfo = false;

  00397	88 9e b8 0e 00
	00		 mov	 BYTE PTR [esi+3768], bl

; 1010 : 	lpObj->m_SkillAddLife = 0;

  0039d	89 9e 90 02 00
	00		 mov	 DWORD PTR [esi+656], ebx

; 1011 : 	lpObj->m_SkillAddLifeTime = 0;

  003a3	89 9e 94 02 00
	00		 mov	 DWORD PTR [esi+660], ebx

; 1012 : 	lpObj->m_SkillHarden = 0;

  003a9	89 9e 98 02 00
	00		 mov	 DWORD PTR [esi+664], ebx

; 1013 : 	lpObj->m_SkillHardenTime = 0;

  003af	89 9e 9c 02 00
	00		 mov	 DWORD PTR [esi+668], ebx

; 1014 : 	lpObj->m_SkillMagumReduceDefense = 0;

  003b5	89 9e a0 02 00
	00		 mov	 DWORD PTR [esi+672], ebx

; 1015 : 	lpObj->m_SkillMagumReduceDefenseTime = 0;

  003bb	89 9e a4 02 00
	00		 mov	 DWORD PTR [esi+676], ebx

; 1016 : 	lpObj->m_SkyBossMonSheildLinkIndex = -1;

  003c1	89 be f4 0e 00
	00		 mov	 DWORD PTR [esi+3828], edi

; 1017 : 	lpObj->m_SkyBossMonSheild = 0;

  003c7	89 9e f8 0e 00
	00		 mov	 DWORD PTR [esi+3832], ebx

; 1018 : 	lpObj->m_SkyBossMonSheildTime = 0;

  003cd	89 9e fc 0e 00
	00		 mov	 DWORD PTR [esi+3836], ebx

; 1019 : 	lpObj->m_bAttackerKilled = false;

  003d3	88 9e 44 02 00
	00		 mov	 BYTE PTR [esi+580], bl

; 1020 : 	lpObj->m_MoveOtherServer = 0;

  003d9	88 9e 14 0f 00
	00		 mov	 BYTE PTR [esi+3860], bl

; 1021 : 	lpObj->m_BossGoldDerconMapNumber = -1;

  003df	c6 86 20 0f 00
	00 ff		 mov	 BYTE PTR [esi+3872], -1

; 1022 : 	lpObj->TargetNumber =	0;

  003e6	89 8e d4 02 00
	00		 mov	 DWORD PTR [esi+724], ecx

; 1023 : 	lpObj->TargetShopNumber = 0;
; 1024 : 	lpObj->WarehouseMoney = 0;

  003ec	89 9e d4 0c 00
	00		 mov	 DWORD PTR [esi+3284], ebx

; 1025 : 	lpObj->WarehouseSave = 0;

  003f2	89 9e d8 0c 00
	00		 mov	 DWORD PTR [esi+3288], ebx

; 1026 : 	lpObj->WarehouseLock = -1;

  003f8	c6 86 d0 0c 00
	00 ff		 mov	 BYTE PTR [esi+3280], 255 ; 000000ffH

; 1027 : 	lpObj->WarehouseCount = 0;

  003ff	88 9e cc 0c 00
	00		 mov	 BYTE PTR [esi+3276], bl

; 1028 : 	lpObj->WarehousePW = 0;

  00405	33 c0		 xor	 eax, eax
  00407	66 89 86 ce 0c
	00 00		 mov	 WORD PTR [esi+3278], ax

; 1029 : 	lpObj->WarehouseUnfailLock = 0;

  0040e	88 9e d1 0c 00
	00		 mov	 BYTE PTR [esi+3281], bl

; 1030 : 	lpObj->m_bDevilSquareAuth = false;

  00414	88 9e 01 0d 00
	00		 mov	 BYTE PTR [esi+3329], bl

; 1031 : 	lpObj->m_TimeCount = 0;

  0041a	88 5e 50	 mov	 BYTE PTR [esi+80], bl

; 1032 : 	lpObj->EventChipCount = 0;

  0041d	66 89 8e ac 0e
	00 00		 mov	 WORD PTR [esi+3756], cx

; 1033 : 	lpObj->MutoNumber = 0;

  00424	89 9e b0 0e 00
	00		 mov	 DWORD PTR [esi+3760], ebx

; 1034 : 	lpObj->HaveWeaponInHand = false;

  0042a	88 9e ab 0e 00
	00		 mov	 BYTE PTR [esi+3755], bl

; 1035 : 	lpObj->m_ReqWarehouseOpen = 0;

  00430	88 9e 58 0f 00
	00		 mov	 BYTE PTR [esi+3928], bl

; 1036 : 	lpObj->iStoneCount = 0;

  00436	89 9e bc 0e 00
	00		 mov	 DWORD PTR [esi+3772], ebx

; 1037 : 	lpObj->m_iDuelUserReserved = -1;

  0043c	89 be 14 0d 00
	00		 mov	 DWORD PTR [esi+3348], edi

; 1038 : 	lpObj->m_iDuelUserRequested = -1;

  00442	89 be 18 0d 00
	00		 mov	 DWORD PTR [esi+3352], edi

; 1039 : 	lpObj->m_iDuelUser = -1;

  00448	89 be 1c 0d 00
	00		 mov	 DWORD PTR [esi+3356], edi

; 1040 : 	lpObj->m_btDuelScore = 0;

  0044e	88 9e 20 0d 00
	00		 mov	 BYTE PTR [esi+3360], bl

; 1041 : 	lpObj->m_iDuelTickCount = 0;

  00454	89 9e 24 0d 00
	00		 mov	 DWORD PTR [esi+3364], ebx

; 1042 : 	lpObj->m_MaxLifePower = 0;

  0045a	89 9e 00 0f 00
	00		 mov	 DWORD PTR [esi+3840], ebx

; 1043 : 	lpObj->m_WizardSkillDefense = 0;

  00460	89 9e 04 0f 00
	00		 mov	 DWORD PTR [esi+3844], ebx

; 1044 : 	lpObj->m_WizardSkillDefenseTime = 0;

  00466	89 9e 08 0f 00
	00		 mov	 DWORD PTR [esi+3848], ebx

; 1045 : 	lpObj->m_PacketChecksumTime = 0;

  0046c	89 9e 0c 0f 00
	00		 mov	 DWORD PTR [esi+3852], ebx

; 1046 : 	lpObj->AddBP = 0;
; 1047 : 	lpObj->m_CheckLifeTime = 0;
; 1048 : 	memset(lpObj->m_Quest, (BYTE)-1, sizeof(lpObj->m_Quest));

  00472	6a 32		 push	 50			; 00000032H
  00474	89 9e f0 00 00
	00		 mov	 DWORD PTR [esi+240], ebx
  0047a	89 9e 10 0f 00
	00		 mov	 DWORD PTR [esi+3856], ebx
  00480	68 ff 00 00 00	 push	 255			; 000000ffH
  00485	8d 96 c0 0e 00
	00		 lea	 edx, DWORD PTR [esi+3776]
  0048b	52		 push	 edx
  0048c	e8 00 00 00 00	 call	 _memset

; 1049 : 	lpObj->m_SendQuestInfo = 0;

  00491	88 9e f2 0e 00
	00		 mov	 BYTE PTR [esi+3826], bl

; 1050 : 	gPacketCheckSum.ClearCheckSum(lpObj->m_Index);

  00497	8b 06		 mov	 eax, DWORD PTR [esi]
  00499	83 c4 0c	 add	 esp, 12			; 0000000cH
  0049c	50		 push	 eax
  0049d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gPacketCheckSum@@3VCPacketCheckSum@@A ; gPacketCheckSum
  004a2	e8 00 00 00 00	 call	 ?ClearCheckSum@CPacketCheckSum@@QAEXH@Z ; CPacketCheckSum::ClearCheckSum

; 1051 : 
; 1052 : 	/*lpObj->NPggCSAuth.Init();
; 1053 : 	lpObj->m_bSentGGAuth = false;
; 1054 : 	lpObj->m_NPggCheckSumSendTime = 0;*/
; 1055 : 
; 1056 : 	lpObj->PlusStatQuestClear = false;

  004a7	66 89 9e 88 00
	00 00		 mov	 WORD PTR [esi+136], bx

; 1057 : 	lpObj->ComboSkillquestClear = false;
; 1058 : 	lpObj->m_LastTeleportTime = 0;

  004ae	66 89 9e 21 0f
	00 00		 mov	 WORD PTR [esi+3873], bx

; 1059 : 	lpObj->m_ClientHackLogCount = 0;
; 1060 : 	lpObj->UseEventServer = FALSE;

  004b5	89 9e b4 0e 00
	00		 mov	 DWORD PTR [esi+3764], ebx

; 1061 : 
; 1062 : 	if ( lpObj->Type == OBJ_USER )

  004bb	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  004c0	75 35		 jne	 SHORT $LN29@gObjCharZe

; 1063 : 	{
; 1064 : 		memset(lpObj->pWarehouseMap, (BYTE)-1, WAREHOUSE_SIZE);

  004c2	8b 8e c8 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3272]
  004c8	6a 78		 push	 120			; 00000078H
  004ca	68 ff 00 00 00	 push	 255			; 000000ffH
  004cf	51		 push	 ecx
  004d0	e8 00 00 00 00	 call	 _memset

; 1065 : 		memset(lpObj->TradeMap, (BYTE)-1, TRADE_BOX_SIZE);

  004d5	8b 8e b8 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3256]
  004db	8b c7		 mov	 eax, edi
  004dd	89 01		 mov	 DWORD PTR [ecx], eax
  004df	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  004e2	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  004e5	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  004e8	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  004eb	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  004ee	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  004f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  004f4	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN29@gObjCharZe:

; 1066 : 	}
; 1067 : 
; 1068 : 	for ( i=0;i<MAX_MAGIC ; i++)

  004f7	89 5d fc	 mov	 DWORD PTR tv1984[ebp], ebx
  004fa	8d 9b 00 00 00
	00		 npad	 6
$LL75@gObjCharZe:

; 1069 : 	{
; 1070 : 		lpObj->Magic[i].Clear();

  00500	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  00506	03 4d fc	 add	 ecx, DWORD PTR tv1984[ebp]
  00509	e8 00 00 00 00	 call	 ?Clear@CMagicInf@@QAEXXZ ; CMagicInf::Clear
  0050e	8b 45 fc	 mov	 eax, DWORD PTR tv1984[ebp]
  00511	83 c0 10	 add	 eax, 16			; 00000010H
  00514	89 45 fc	 mov	 DWORD PTR tv1984[ebp], eax
  00517	3d c0 03 00 00	 cmp	 eax, 960		; 000003c0H
  0051c	7c e2		 jl	 SHORT $LL75@gObjCharZe

; 1071 : 	}
; 1072 : 
; 1073 : 	lpObj->MagicCount = 0;
; 1074 : 
; 1075 : 	for ( i=0;i<MAX_MONSTER_SEND_MSG;i++)
; 1076 : 	{
; 1077 : 		gSMMsg[aIndex][i].MsgCode = -1;

  0051e	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00521	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00524	c1 e0 05	 shl	 eax, 5
  00527	88 9e 3c 03 00
	00		 mov	 BYTE PTR [esi+828], bl
  0052d	89 b8 00 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax], edi
  00533	89 b8 10 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+16], edi
  00539	89 b8 20 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+32], edi
  0053f	89 b8 30 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+48], edi
  00545	89 b8 40 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+64], edi
  0054b	89 b8 50 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+80], edi
  00551	89 b8 60 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+96], edi
  00557	89 b8 70 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+112], edi
  0055d	89 b8 80 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+128], edi
  00563	89 b8 90 00 00
	00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+144], edi

; 1078 : 	}
; 1079 : 
; 1080 : 	lpObj->m_bIsInMonsterHerd = false;

  00569	89 9e 24 0f 00
	00		 mov	 DWORD PTR [esi+3876], ebx

; 1081 : 	lpObj->m_bIsMonsterAttackFirst = true;
; 1082 : 	lpObj->m_lpMonsterHerd = NULL;
; 1083 : 
; 1084 : 	if ( (aIndex-OBJ_STARTUSERINDEX) >= 0 )

  0056f	8d 81 00 e7 ff
	ff		 lea	 eax, DWORD PTR [ecx-6400]
  00575	c7 86 28 0f 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3880], 1
  0057f	89 9e 2c 0f 00
	00		 mov	 DWORD PTR [esi+3884], ebx
  00585	3b c3		 cmp	 eax, ebx
  00587	7c 1f		 jl	 SHORT $LN19@gObjCharZe

; 1085 : 	{
; 1086 : 		for ( i=0;i<MAX_MONSTER_SEND_ATTACK_MSG;i++)

  00589	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  0058f	05 00 00 00 00	 add	 eax, OFFSET ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A ; gSMAttackProcMsg
  00594	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00599	8d a4 24 00 00
	00 00		 npad	 7
$LL21@gObjCharZe:

; 1087 : 		{
; 1088 : 			gSMAttackProcMsg[aIndex-OBJ_STARTUSERINDEX][i].MsgCode = -1;

  005a0	89 38		 mov	 DWORD PTR [eax], edi
  005a2	83 c0 14	 add	 eax, 20			; 00000014H
  005a5	49		 dec	 ecx
  005a6	75 f8		 jne	 SHORT $LL21@gObjCharZe
$LN19@gObjCharZe:

; 1089 : 		}
; 1090 : 	}
; 1091 : 
; 1092 : 	lpObj->SkillHellFire2State = 0;

  005a8	66 89 9e 50 0f
	00 00		 mov	 WORD PTR [esi+3920], bx

; 1093 : 	lpObj->SkillHellFire2Count = 0;
; 1094 : 	lpObj->m_PoisonType = 0;

  005af	66 89 9e 25 02
	00 00		 mov	 WORD PTR [esi+549], bx

; 1095 : 	lpObj->m_IceType = 0;
; 1096 : 	lpObj->Leadership = 0;

  005b6	33 d2		 xor	 edx, edx
  005b8	89 96 d8 00 00
	00		 mov	 DWORD PTR [esi+216], edx

; 1097 : 	lpObj->AddLeadership = 0;
; 1098 : 	lpObj->ChatLimitTime = 0;

  005be	33 c9		 xor	 ecx, ecx
  005c0	66 89 8e dc 00
	00 00		 mov	 WORD PTR [esi+220], cx

; 1099 : 	lpObj->ChatLimitTimeSec = 0;

  005c7	88 9e de 00 00
	00		 mov	 BYTE PTR [esi+222], bl

; 1100 : 	lpObj->SkillRecallParty_Time = 0;

  005cd	66 89 96 b0 10
	00 00		 mov	 WORD PTR [esi+4272], dx

; 1101 : 	lpObj->SkillAddCriticalDamageTime = 0;

  005d4	33 c0		 xor	 eax, eax
  005d6	89 86 b6 10 00
	00		 mov	 DWORD PTR [esi+4278], eax

; 1102 : 	lpObj->SkillAddCriticalDamage = 0;
; 1103 : 	lpObj->SkillLongSpearChange = false;
; 1104 : 	lpObj->SkillDelay.Init();

  005dc	8d 8e bc 10 00
	00		 lea	 ecx, DWORD PTR [esi+4284]
  005e2	88 9e bb 10 00
	00		 mov	 BYTE PTR [esi+4283], bl
  005e8	e8 00 00 00 00	 call	 ?Init@CSkillDelay@@QAEXXZ ; CSkillDelay::Init

; 1105 : 
; 1106 : 	lpObj->bEnableDelCharacter = 1;

  005ed	c6 46 09 01	 mov	 BYTE PTR [esi+9], 1

; 1107 : 
; 1108 : 	if ( lpObj->Type == OBJ_USER )

  005f1	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  005f6	75 28		 jne	 SHORT $LN15@gObjCharZe

; 1109 : 	{
; 1110 : 		for (i=0;i<WAREHOUSE_SIZE;i++)

  005f8	89 5d 08	 mov	 DWORD PTR tv2028[ebp], ebx
  005fb	eb 03 8d 49 00	 npad	 5
$LL76@gObjCharZe:

; 1111 : 		{
; 1112 : 			lpObj->pWarehouse[i].Clear();

  00600	8b 8e c4 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3268]
  00606	03 4d 08	 add	 ecx, DWORD PTR tv2028[ebp]
  00609	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  0060e	8b 45 08	 mov	 eax, DWORD PTR tv2028[ebp]
  00611	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  00616	89 45 08	 mov	 DWORD PTR tv2028[ebp], eax
  00619	3d c0 4e 00 00	 cmp	 eax, 20160		; 00004ec0H
  0061e	7c e0		 jl	 SHORT $LL76@gObjCharZe
$LN15@gObjCharZe:

; 1113 : 		}
; 1114 : 	}
; 1115 : 
; 1116 : 	lpObj->pTransaction = 0;
; 1117 : 	::gObjMonsterHitDamageInit(lpObj);

  00620	56		 push	 esi
  00621	88 9e 98 0c 00
	00		 mov	 BYTE PTR [esi+3224], bl
  00627	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageInit

; 1118 : 	::gObjSetInventory1Pointer(&gObj[aIndex]);

  0062c	56		 push	 esi
  0062d	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer
  00632	83 c4 08	 add	 esp, 8

; 1119 : 
; 1120 : 	if ( lpObj->Type == OBJ_USER )

  00635	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0063a	75 16		 jne	 SHORT $LN14@gObjCharZe

; 1121 : 	{
; 1122 : 		memset(lpObj->pInventoryMap, (BYTE)-1, INVENTORY_MAP_SIZE);

  0063c	8b 96 90 0c 00
	00		 mov	 edx, DWORD PTR [esi+3216]
  00642	6a 60		 push	 96			; 00000060H
  00644	68 ff 00 00 00	 push	 255			; 000000ffH
  00649	52		 push	 edx
  0064a	e8 00 00 00 00	 call	 _memset
  0064f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@gObjCharZe:

; 1123 : 	}
; 1124 : 
; 1125 : 	lpObj->m_bPShopOpen = false;

  00652	66 89 9e 28 0d
	00 00		 mov	 WORD PTR [esi+3368], bx

; 1126 : 	lpObj->m_bPShopTransaction = false;
; 1127 : 	lpObj->m_bPShopItemChange = false;

  00659	66 89 9e 2a 0d
	00 00		 mov	 WORD PTR [esi+3370], bx

; 1128 : 	lpObj->m_bPShopRedrawAbs = false;
; 1129 : 	memset(lpObj->m_szPShopText, 0, sizeof(lpObj->m_szPShopText));

  00660	89 9e 2c 0d 00
	00		 mov	 DWORD PTR [esi+3372], ebx
  00666	89 9e 30 0d 00
	00		 mov	 DWORD PTR [esi+3376], ebx
  0066c	89 9e 34 0d 00
	00		 mov	 DWORD PTR [esi+3380], ebx
  00672	89 9e 38 0d 00
	00		 mov	 DWORD PTR [esi+3384], ebx
  00678	89 9e 3c 0d 00
	00		 mov	 DWORD PTR [esi+3388], ebx
  0067e	89 9e 40 0d 00
	00		 mov	 DWORD PTR [esi+3392], ebx
  00684	89 9e 44 0d 00
	00		 mov	 DWORD PTR [esi+3396], ebx
  0068a	89 9e 48 0d 00
	00		 mov	 DWORD PTR [esi+3400], ebx
  00690	89 9e 4c 0d 00
	00		 mov	 DWORD PTR [esi+3404], ebx

; 1130 : 	lpObj->m_bPShopWantDeal = false;

  00696	88 9e 50 0d 00
	00		 mov	 BYTE PTR [esi+3408], bl

; 1131 : 	lpObj->m_iPShopDealerIndex = -1;

  0069c	89 be 54 0d 00
	00		 mov	 DWORD PTR [esi+3412], edi

; 1132 : 	memset(lpObj->m_szPShopDealerName, 0, sizeof(lpObj->m_szPShopDealerName));
; 1133 : 	memset(lpObj->m_iVpPShopPlayer, 0, sizeof(lpObj->m_iVpPShopPlayer));

  006a2	68 2c 01 00 00	 push	 300			; 0000012cH
  006a7	89 9e 58 0d 00
	00		 mov	 DWORD PTR [esi+3416], ebx
  006ad	8d 86 7c 0d 00
	00		 lea	 eax, DWORD PTR [esi+3452]
  006b3	53		 push	 ebx
  006b4	89 9e 5c 0d 00
	00		 mov	 DWORD PTR [esi+3420], ebx
  006ba	50		 push	 eax
  006bb	66 89 9e 60 0d
	00 00		 mov	 WORD PTR [esi+3424], bx
  006c2	e8 00 00 00 00	 call	 _memset

; 1134 : 	lpObj->m_wVpPShopPlayerCount =0;

  006c7	33 c9		 xor	 ecx, ecx
  006c9	66 89 8e a8 0e
	00 00		 mov	 WORD PTR [esi+3752], cx

; 1135 : 	lpObj->iGuildUnionTimeStamp = 0;
; 1136 : 	::gObjCharTradeClear(lpObj);

  006d0	56		 push	 esi
  006d1	89 9e c8 02 00
	00		 mov	 DWORD PTR [esi+712], ebx
  006d7	e8 00 00 00 00	 call	 ?gObjCharTradeClear@@YAXPAUOBJECTSTRUCT@@@Z ; gObjCharTradeClear
  006dc	83 c4 10	 add	 esp, 16			; 00000010H

; 1137 : 
; 1138 : 	if ( lpObj->Type == OBJ_USER )

  006df	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  006e4	0f 85 81 00 00
	00		 jne	 $LN1@gObjCharZe

; 1139 : 	{
; 1140 : 		for ( i=0;i<WAREHOUSE_SIZE;i++)

  006ea	33 ff		 xor	 edi, edi
  006ec	8d 64 24 00	 npad	 4
$LL12@gObjCharZe:

; 1141 : 		{
; 1142 : 			lpObj->pWarehouse[i].Clear();

  006f0	8b 8e c4 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3268]
  006f6	03 cf		 add	 ecx, edi
  006f8	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  006fd	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00703	81 ff c0 4e 00
	00		 cmp	 edi, 20160		; 00004ec0H
  00709	7c e5		 jl	 SHORT $LL12@gObjCharZe

; 1143 : 		}
; 1144 : 
; 1145 : 		for ( i=0;i<INVENTORY_SIZE;i++)

  0070b	33 ff		 xor	 edi, edi
  0070d	8d 49 00	 npad	 3
$LL9@gObjCharZe:

; 1146 : 		{
; 1147 : 			lpObj->Inventory1[i].Clear();

  00710	8b 8e 9c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3228]
  00716	03 cf		 add	 ecx, edi
  00718	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  0071d	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00723	81 ff e0 46 00
	00		 cmp	 edi, 18144		; 000046e0H
  00729	7c e5		 jl	 SHORT $LL9@gObjCharZe

; 1148 : 		}
; 1149 : 
; 1150 : 		for ( i=0;i<INVENTORY_SIZE;i++)

  0072b	33 ff		 xor	 edi, edi
  0072d	8d 49 00	 npad	 3
$LL6@gObjCharZe:

; 1151 : 		{
; 1152 : 			lpObj->Inventory2[i].Clear();

  00730	8b 8e a8 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3240]
  00736	03 cf		 add	 ecx, edi
  00738	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  0073d	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00743	81 ff e0 46 00
	00		 cmp	 edi, 18144		; 000046e0H
  00749	7c e5		 jl	 SHORT $LL6@gObjCharZe

; 1153 : 		}
; 1154 : 
; 1155 : 		for ( i=0;i<TRADE_BOX_SIZE;i++)

  0074b	33 ff		 xor	 edi, edi
  0074d	8d 49 00	 npad	 3
$LL3@gObjCharZe:

; 1156 : 		{
; 1157 : 			lpObj->Trade[i].Clear();

  00750	8b 8e b4 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3252]
  00756	03 cf		 add	 ecx, edi
  00758	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  0075d	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00763	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  00769	7c e5		 jl	 SHORT $LL3@gObjCharZe
$LN1@gObjCharZe:

; 1158 : 		}
; 1159 : 	}
; 1160 : 
; 1161 : 	lpObj->bIsChaosMixCompleted = false;

  0076b	88 9e ba 10 00
	00		 mov	 BYTE PTR [esi+4282], bl

; 1162 : 	lpObj->m_bMapSvrMoveQuit = false;

  00771	88 9e c4 14 00
	00		 mov	 BYTE PTR [esi+5316], bl

; 1163 : 
; 1164 : #if (GS_CASTLE == 1)
; 1165 : 
; 1166 : 	lpObj->m_iCsNpcExistVal = 0;
; 1167 : 	lpObj->m_btCsNpcType = 0;
; 1168 : 	lpObj->m_btCsGateOpen = 0;
; 1169 : 	lpObj->m_iCsGateLeverLinkIndex = -1;
; 1170 : 	lpObj->m_btCsNpcDfLevel = 0;
; 1171 : 	lpObj->m_btCsNpcRgLevel = 0;
; 1172 : 	lpObj->m_btCsJoinSide = 0;
; 1173 : 	lpObj->m_bCsGuildInvolved = 0;
; 1174 : 
; 1175 : #endif
; 1176 : 
; 1177 : 	lpObj->m_bIsCastleNPCUpgradeCompleted = false;

  00777	66 89 9e d2 14
	00 00		 mov	 WORD PTR [esi+5330], bx

; 1178 : 	lpObj->m_btWeaponState = 0;
; 1179 : 	lpObj->m_btKillCount = 0;

  0077e	88 9e d8 14 00
	00		 mov	 BYTE PTR [esi+5336], bl

; 1180 : 	lpObj->m_iSkillStunTime = 0;

  00784	89 9e dc 14 00
	00		 mov	 DWORD PTR [esi+5340], ebx

; 1181 : 	lpObj->m_iSkillBrandOfSkillTime = 0;

  0078a	89 9e e0 14 00
	00		 mov	 DWORD PTR [esi+5344], ebx

; 1182 : 	lpObj->m_iSkillInvisibleTime = 0;

  00790	89 9e e4 14 00
	00		 mov	 DWORD PTR [esi+5348], ebx

; 1183 : 	lpObj->m_iSkillManaSwellTime = 0;

  00796	89 9e e8 14 00
	00		 mov	 DWORD PTR [esi+5352], ebx

; 1184 : 	lpObj->m_iSkillManaSwell = 0;

  0079c	89 9e ec 14 00
	00		 mov	 DWORD PTR [esi+5356], ebx

; 1185 : 	lpObj->m_iPotionBlessTime = 0;

  007a2	89 9e f4 14 00
	00		 mov	 DWORD PTR [esi+5364], ebx

; 1186 : 	lpObj->m_iPotionSoulTime = 0;

  007a8	89 9e f8 14 00
	00		 mov	 DWORD PTR [esi+5368], ebx

; 1187 : 	lpObj->m_iAccumulatedDamage = 0;

  007ae	89 9e f0 14 00
	00		 mov	 DWORD PTR [esi+5360], ebx

; 1188 : 
; 1189 : #if (GS_CASTLE == 1)
; 1190 : 
; 1191 : 	lpObj->m_iCreatedActivationTime = 0;
; 1192 : 	lpObj->m_btLifeStoneCount = 0;
; 1193 : 
; 1194 : #endif
; 1195 : 
; 1196 : 	lpObj->m_iAccumulatedCrownAccessTime = 0;

  007b4	89 9e fc 14 00
	00		 mov	 DWORD PTR [esi+5372], ebx

; 1197 : 
; 1198 : 	lpObj->m_iSkillNPCHelpTime = 0;

  007ba	89 9e 24 15 00
	00		 mov	 DWORD PTR [esi+5412], ebx

; 1199 : 	lpObj->m_iSkillNPCDefense = 0;

  007c0	89 9e 28 15 00
	00		 mov	 DWORD PTR [esi+5416], ebx

; 1200 : 	lpObj->m_iSkillNPCAttack = 0;

  007c6	89 9e 2c 15 00
	00		 mov	 DWORD PTR [esi+5420], ebx

; 1201 : 	lpObj->m_iMuseElfInfinityArrowSkillTime = 0;

  007cc	89 9e 30 15 00
	00		 mov	 DWORD PTR [esi+5424], ebx

; 1202 : 
; 1203 : 	lpObj->m_iCrywolfMVPScore = 0;

  007d2	89 9e 18 15 00
	00		 mov	 DWORD PTR [esi+5400], ebx

; 1204 : 	lpObj->m_iSkillDistanceErrorCount = 0;

  007d8	89 9e 34 15 00
	00		 mov	 DWORD PTR [esi+5428], ebx

; 1205 : 	lpObj->m_dwSkillDistanceErrorTick = 0;

  007de	89 9e 38 15 00
	00		 mov	 DWORD PTR [esi+5432], ebx

; 1206 : 
; 1207 : 	lpObj->m_Vip = 0;

  007e4	89 9e 3c 15 00
	00		 mov	 DWORD PTR [esi+5436], ebx

; 1208 : 	lpObj->m_Resets = 0;

  007ea	89 9e 40 15 00
	00		 mov	 DWORD PTR [esi+5440], ebx

; 1209 : 	lpObj->m_MasterResets = 0;

  007f0	89 9e 44 15 00
	00		 mov	 DWORD PTR [esi+5444], ebx

; 1210 : 	lpObj->m_Cash = 0;

  007f6	89 9e 48 15 00
	00		 mov	 DWORD PTR [esi+5448], ebx

; 1211 : 	lpObj->m_Gold = 0;

  007fc	89 9e 4c 15 00
	00		 mov	 DWORD PTR [esi+5452], ebx

; 1212 : 
; 1213 : 	lpObj->m_DelayPost = 0;

  00802	89 9e 50 15 00
	00		 mov	 DWORD PTR [esi+5456], ebx

; 1214 : 	lpObj->m_DelayWare = 0;

  00808	89 9e 54 15 00
	00		 mov	 DWORD PTR [esi+5460], ebx

; 1215 : 	lpObj->m_DelayOpenWare = 0;

  0080e	89 9e 58 15 00
	00		 mov	 DWORD PTR [esi+5464], ebx

; 1216 : 
; 1217 : 	lpObj->bReconnect = false;

  00814	88 9e 5c 15 00
	00		 mov	 BYTE PTR [esi+5468], bl

; 1218 : 
; 1219 : 	lpObj->m_WareNumber = 0;
; 1220 : 
; 1221 : 	::gObjClearViewport(&gObj[aIndex]);

  0081a	56		 push	 esi
  0081b	89 9e 60 15 00
	00		 mov	 DWORD PTR [esi+5472], ebx
  00821	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport
  00826	83 c4 04	 add	 esp, 4
  00829	5f		 pop	 edi
  0082a	5e		 pop	 esi
  0082b	5b		 pop	 ebx

; 1222 : }

  0082c	8b e5		 mov	 esp, ebp
  0082e	5d		 pop	 ebp
  0082f	c3		 ret	 0
?gObjCharZeroSet@@YAXH@Z ENDP				; gObjCharZeroSet
_TEXT	ENDS
PUBLIC	?gObjSetTradeOption@@YAXHH@Z			; gObjSetTradeOption
; Function compile flags: /Ogtp
;	COMDAT ?gObjSetTradeOption@@YAXHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_option$ = 12						; size = 4
?gObjSetTradeOption@@YAXHH@Z PROC			; gObjSetTradeOption, COMDAT

; 1245 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1246 : 	if ( gObjIsConnected(aIndex) == TRUE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	51		 push	 ecx
  00007	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000c	83 c4 04	 add	 esp, 4
  0000f	83 f8 01	 cmp	 eax, 1
  00012	75 48		 jne	 SHORT $LN1@gObjSetTra

; 1247 : 	{
; 1248 : 		if ( option == 0 )

  00014	83 7d 0c 00	 cmp	 DWORD PTR _option$[ebp], 0

; 1251 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 97)), aIndex, 1);

  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	75 19		 jne	 SHORT $LN2@gObjSetTra

; 1249 : 		{
; 1250 : 			gObj[aIndex].m_Option = 0;

  0001c	8b c1		 mov	 eax, ecx
  0001e	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00024	c7 80 f0 0c 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3312], 0

; 1251 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 97)), aIndex, 1);

  0002e	68 61 04 00 00	 push	 1121			; 00000461H

; 1252 : 		}
; 1253 : 		else

  00033	eb 14		 jmp	 SHORT $LN6@gObjSetTra
$LN2@gObjSetTra:

; 1254 : 		{
; 1255 : 			gObj[aIndex].m_Option |= 1;

  00035	8b d1		 mov	 edx, ecx
  00037	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  0003d	83 8a f0 0c 00
	00 01		 or	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3312], 1

; 1256 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 96)), aIndex, 1);

  00044	68 60 04 00 00	 push	 1120			; 00000460H
$LN6@gObjSetTra:
  00049	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0004e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjSetTra:

; 1257 : 		}
; 1258 : 	}
; 1259 : }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?gObjSetTradeOption@@YAXHH@Z ENDP			; gObjSetTradeOption
_TEXT	ENDS
PUBLIC	?gObjSetDuelOption@@YAXHH@Z			; gObjSetDuelOption
; Function compile flags: /Ogtp
;	COMDAT ?gObjSetDuelOption@@YAXHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_option$ = 12						; size = 4
?gObjSetDuelOption@@YAXHH@Z PROC			; gObjSetDuelOption, COMDAT

; 1262 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1263 : 	if ( gObjIsConnected(aIndex) == TRUE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	51		 push	 ecx
  00007	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000c	83 c4 04	 add	 esp, 4
  0000f	83 f8 01	 cmp	 eax, 1
  00012	75 1f		 jne	 SHORT $LN1@gObjSetDue

; 1264 : 	{
; 1265 : 		if ( option == 0 )
; 1266 : 		{
; 1267 : 			gObj[aIndex].m_Option = 0;

  00014	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0001a	83 7d 0c 00	 cmp	 DWORD PTR _option$[ebp], 0
  0001e	75 0c		 jne	 SHORT $LN2@gObjSetDue
  00020	c7 81 f0 0c 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3312], 0

; 1272 : 		}
; 1273 : 	}
; 1274 : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN2@gObjSetDue:

; 1268 : 		}
; 1269 : 		else
; 1270 : 		{
; 1271 : 			gObj[aIndex].m_Option |= 2;

  0002c	83 89 f0 0c 00
	00 02		 or	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3312], 2
$LN1@gObjSetDue:

; 1272 : 		}
; 1273 : 	}
; 1274 : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?gObjSetDuelOption@@YAXHH@Z ENDP			; gObjSetDuelOption
_TEXT	ENDS
PUBLIC	?IsDuelEnable@@YA_NH@Z				; IsDuelEnable
; Function compile flags: /Ogtp
;	COMDAT ?IsDuelEnable@@YA_NH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?IsDuelEnable@@YA_NH@Z PROC				; IsDuelEnable, COMDAT

; 1277 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1278 : 	if ( OBJMAX_RANGE(aIndex ) == FALSE)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 30		 js	 SHORT $LN1@IsDuelEnab
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax

; 1279 : 	{
; 1280 : 		return false;

  00017	74 21		 je	 SHORT $LN1@IsDuelEnab

; 1281 : 	}
; 1282 : 
; 1283 : 	if ( gObjIsConnected(aIndex) == TRUE )

  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001f	83 c4 04	 add	 esp, 4
  00022	83 f8 01	 cmp	 eax, 1
  00025	75 13		 jne	 SHORT $LN1@IsDuelEnab

; 1284 : 	{
; 1285 : 		if ( (gObj[aIndex].m_Option&2) == 2 )

  00027	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0002d	f6 81 f0 0c 00
	00 02		 test	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3312], 2
  00034	74 04		 je	 SHORT $LN1@IsDuelEnab

; 1286 : 		{
; 1287 : 			return true;

  00036	8a c0		 mov	 al, al

; 1292 : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@IsDuelEnab:

; 1288 : 		}
; 1289 : 	}
; 1290 : 
; 1291 : 	return false;

  0003a	32 c0		 xor	 al, al

; 1292 : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?IsDuelEnable@@YA_NH@Z ENDP				; IsDuelEnable
_TEXT	ENDS
PUBLIC	??_C@_0BD@LOIPIKDB@connect?5?3?5?$FL?$CFd?$FN?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	?gObjAdd@@YAFIPADH@Z				; gObjAdd
EXTRN	?init@NSerialCheck@@QAEXXZ:PROC			; NSerialCheck::init
EXTRN	?gNSerialCheck@@3PAVNSerialCheck@@A:BYTE	; gNSerialCheck
;	COMDAT ??_C@_0BD@LOIPIKDB@connect?5?3?5?$FL?$CFd?$FN?$FL?$CFs?$FN?$AA@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.h
CONST	SEGMENT
??_C@_0BD@LOIPIKDB@connect?5?3?5?$FL?$CFd?$FN?$FL?$CFs?$FN?$AA@ DB 'conne'
	DB	'ct : [%d][%s]', 00H				; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
CONST	ENDS
;	COMDAT ?gObjAdd@@YAFIPADH@Z
_TEXT	SEGMENT
_aSocket$ = 8						; size = 4
_ip$ = 12						; size = 4
_aIndex$ = 16						; size = 4
?gObjAdd@@YAFIPADH@Z PROC				; gObjAdd, COMDAT

; 2764 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 2765 : 	if ( gObj[aIndex].Connected != PLAYER_EMPTY )

  00006	8b 7d 10	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00009	8b f7		 mov	 esi, edi
  0000b	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00011	33 db		 xor	 ebx, ebx
  00013	38 9e 04 00 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+4], bl
  00019	74 08		 je	 SHORT $LN2@gObjAdd

; 2766 : 	{
; 2767 : 		return -1;

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	83 c8 ff	 or	 eax, -1
  00020	5b		 pop	 ebx

; 2796 : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
$LN2@gObjAdd:

; 2768 : 	}
; 2769 : 
; 2770 : 	gObjCharZeroSet(aIndex);

  00023	57		 push	 edi
  00024	e8 00 00 00 00	 call	 ?gObjCharZeroSet@@YAXH@Z ; gObjCharZeroSet
  00029	83 c4 04	 add	 esp, 4

; 2771 : 	gNSerialCheck[aIndex].init();

  0002c	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[edi*8]
  00033	e8 00 00 00 00	 call	 ?init@NSerialCheck@@QAEXXZ ; NSerialCheck::init

; 2772 : 	gObj[aIndex].LoginMsgSnd = FALSE;
; 2773 : 	gObj[aIndex].LoginMsgCount = 0;
; 2774 : 	memset(gObj[aIndex].AccountID, 0, sizeof(gObj[0].AccountID)-1);

  00038	33 c0		 xor	 eax, eax
  0003a	88 9e 05 00 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+5], bl
  00040	88 9e 06 00 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+6], bl
  00046	89 86 64 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100], eax
  0004c	89 86 68 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+104], eax
  00052	66 89 86 6c 00
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+108], ax

; 2775 : 	gObj[aIndex].m_Index = aIndex;
; 2776 : 	gObj[aIndex].m_socket = aSocket;

  00059	8b 45 08	 mov	 eax, DWORD PTR _aSocket$[ebp]
  0005c	89 be 00 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi], edi
  00062	89 86 10 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+16], eax

; 2777 : 	gObj[aIndex].ConnectCheckTime = GetTickCount();

  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 2778 : 	gObj[aIndex].AutoSaveTime = gObj[aIndex].ConnectCheckTime;
; 2779 : 	gObj[aIndex].Connected = PLAYER_CONNECTED;
; 2780 : 	gObj[aIndex].CheckSpeedHack = false;
; 2781 : 	gObj[aIndex].LoginMsgCount = 0;
; 2782 : 	gObj[aIndex].Magumsa = 0;
; 2783 : 	gObj[aIndex].Type = OBJ_USER;

  0006e	b9 01 00 00 00	 mov	 ecx, 1
  00073	89 86 34 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+52], eax
  00079	89 86 30 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+48], eax
  0007f	c6 86 04 00 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+4], 1
  00086	88 9e 3c 00 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+60], bl
  0008c	88 9e 06 00 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+6], bl
  00092	88 9e 2c 00 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+44], bl
  00098	66 89 8e 60 00
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+96], cx

; 2784 : 	gObj[aIndex].SaveTimeForStatics = GetTickCount() + 3600000;

  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 2785 : 	m_ObjBill[aIndex].Init();
; 2786 : 	strcpy(gObj[aIndex].Ip_addr, ip);

  000a5	8b 55 0c	 mov	 edx, DWORD PTR _ip$[ebp]
  000a8	05 80 ee 36 00	 add	 eax, 3600000		; 0036ee80H
  000ad	89 86 48 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+72], eax
  000b3	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  000b6	8d 04 c5 00 00
	00 00		 lea	 eax, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[eax*8]
  000bd	8d b6 14 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+20]
  000c3	66 c7 00 ff 00	 mov	 WORD PTR [eax], 255	; 000000ffH
  000c8	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  000cb	88 58 08	 mov	 BYTE PTR [eax+8], bl
  000ce	8b c2		 mov	 eax, edx
  000d0	2b f2		 sub	 esi, edx
$LL5@gObjAdd:
  000d2	8a 08		 mov	 cl, BYTE PTR [eax]
  000d4	88 0c 06	 mov	 BYTE PTR [esi+eax], cl
  000d7	40		 inc	 eax
  000d8	3a cb		 cmp	 cl, bl
  000da	75 f6		 jne	 SHORT $LL5@gObjAdd

; 2787 : 	LogAdd(LOG_BLACK, "connect : [%d][%s]", aIndex, ip);

  000dc	52		 push	 edx
  000dd	57		 push	 edi
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@LOIPIKDB@connect?5?3?5?$FL?$CFd?$FN?$FL?$CFs?$FN?$AA@
  000e3	53		 push	 ebx
  000e4	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2788 : 	gObjCount++;

  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjCount@@3HA ; gObjCount
  000ee	40		 inc	 eax
  000ef	83 c4 10	 add	 esp, 16			; 00000010H
  000f2	a3 00 00 00 00	 mov	 DWORD PTR ?gObjCount@@3HA, eax ; gObjCount

; 2789 : 	
; 2790 : 	if ( gObjCount >= OBJMAX )

  000f7	3d e8 1c 00 00	 cmp	 eax, 7400		; 00001ce8H
  000fc	7c 0a		 jl	 SHORT $LN1@gObjAdd

; 2791 : 	{
; 2792 : 		gObjCount = OBJ_STARTUSERINDEX;

  000fe	c7 05 00 00 00
	00 00 19 00 00	 mov	 DWORD PTR ?gObjCount@@3HA, 6400 ; gObjCount, 00001900H
$LN1@gObjAdd:

; 2793 : 	}
; 2794 : 
; 2795 : 	return aIndex;

  00108	66 8b c7	 mov	 ax, di
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx

; 2796 : }

  0010e	5d		 pop	 ebp
  0010f	c3		 ret	 0
?gObjAdd@@YAFIPADH@Z ENDP				; gObjAdd
_TEXT	ENDS
PUBLIC	?gObjAddMonster@@YAFH@Z				; gObjAddMonster
EXTRN	?CheckMapCanMove@CMapServerManager@@QAEHH@Z:PROC ; CMapServerManager::CheckMapCanMove
; Function compile flags: /Ogtp
;	COMDAT ?gObjAddMonster@@YAFH@Z
_TEXT	SEGMENT
_iMapNumber$ = 8					; size = 4
?gObjAddMonster@@YAFH@Z PROC				; gObjAddMonster, COMDAT

; 2810 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2811 : 	if (g_MapServerManager.CheckMapCanMove(iMapNumber) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  00006	50		 push	 eax
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  0000c	e8 00 00 00 00	 call	 ?CheckMapCanMove@CMapServerManager@@QAEHH@Z ; CMapServerManager::CheckMapCanMove
  00011	85 c0		 test	 eax, eax
  00013	75 05		 jne	 SHORT $LN7@gObjAddMon

; 2812 : 	{
; 2813 : 		return -1;

  00015	83 c8 ff	 or	 eax, -1

; 2852 : 		}
; 2853 : 	}
; 2854 : 	return -1;
; 2855 : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN7@gObjAddMon:
  0001a	56		 push	 esi

; 2814 : 	}
; 2815 : 
; 2816 : 	int count;
; 2817 : 	int totalcount=0;
; 2818 : 
; 2819 : 	count = gObjMonCount;

  0001b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObjMonCount@@3HA ; gObjMonCount

; 2820 : 
; 2821 : 	while ( true )
; 2822 : 	{
; 2823 : 		if ( gObj[count].Connected == PLAYER_EMPTY )

  00021	8b ce		 mov	 ecx, esi
  00023	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00029	33 c0		 xor	 eax, eax
  0002b	38 81 04 00 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], al
  00031	74 24		 je	 SHORT $LN12@gObjAddMon
$LL6@gObjAddMon:

; 2836 : 
; 2837 : 		}
; 2838 : 
; 2839 : 		count ++;

  00033	46		 inc	 esi

; 2840 : 		
; 2841 : 		if ( count >= OBJ_MAXMONSTER )

  00034	81 fe a8 16 00
	00		 cmp	 esi, 5800		; 000016a8H
  0003a	7c 02		 jl	 SHORT $LN2@gObjAddMon

; 2842 : 		{
; 2843 : 			count = 0;

  0003c	33 f6		 xor	 esi, esi
$LN2@gObjAddMon:

; 2844 : 		}
; 2845 : 
; 2846 : 		totalcount++;

  0003e	40		 inc	 eax

; 2847 : 
; 2848 : 		if ( totalcount >= OBJ_MAXMONSTER )

  0003f	3d a8 16 00 00	 cmp	 eax, 5800		; 000016a8H
  00044	7d 51		 jge	 SHORT $LN13@gObjAddMon

; 2820 : 
; 2821 : 	while ( true )
; 2822 : 	{
; 2823 : 		if ( gObj[count].Connected == PLAYER_EMPTY )

  00046	8b d6		 mov	 edx, esi
  00048	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  0004e	80 ba 04 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+4], 0
  00055	75 dc		 jne	 SHORT $LL6@gObjAddMon
$LN12@gObjAddMon:

; 2824 : 		{
; 2825 : 			gObjCharZeroSet(count);

  00057	56		 push	 esi
  00058	e8 00 00 00 00	 call	 ?gObjCharZeroSet@@YAXH@Z ; gObjCharZeroSet

; 2826 : 			gObj[count].m_Index = count;

  0005d	8b c6		 mov	 eax, esi
  0005f	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00065	89 b0 00 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax], esi

; 2827 : 			gObj[count].Connected = PLAYER_CONNECTED;

  0006b	c6 80 04 00 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 1

; 2828 : 			gObjMonCount++;

  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjMonCount@@3HA ; gObjMonCount
  00077	40		 inc	 eax
  00078	83 c4 04	 add	 esp, 4
  0007b	a3 00 00 00 00	 mov	 DWORD PTR ?gObjMonCount@@3HA, eax ; gObjMonCount

; 2829 : 
; 2830 : 			if ( gObjMonCount >= OBJ_MAXMONSTER )

  00080	3d a8 16 00 00	 cmp	 eax, 5800		; 000016a8H
  00085	7c 0a		 jl	 SHORT $LN3@gObjAddMon

; 2831 : 			{
; 2832 : 				gObjMonCount = 0;

  00087	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObjMonCount@@3HA, 0 ; gObjMonCount
$LN3@gObjAddMon:

; 2833 : 			}
; 2834 : 			
; 2835 : 		return count;

  00091	66 8b c6	 mov	 ax, si
  00094	5e		 pop	 esi

; 2852 : 		}
; 2853 : 	}
; 2854 : 	return -1;
; 2855 : }

  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
$LN13@gObjAddMon:

; 2849 : 		{
; 2850 : 			LogAdd(LOG_BLACK, lMsg.Get( MSGGET ( 1, 255 )), __FILE__, __LINE__ );

  00097	68 22 0b 00 00	 push	 2850			; 00000b22H
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  000a1	68 ff 01 00 00	 push	 511			; 000001ffH
  000a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ab	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000b0	50		 push	 eax
  000b1	6a 00		 push	 0
  000b3	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000b8	83 c4 10	 add	 esp, 16			; 00000010H

; 2851 : 			return -1;

  000bb	83 c8 ff	 or	 eax, -1
  000be	5e		 pop	 esi

; 2852 : 		}
; 2853 : 	}
; 2854 : 	return -1;
; 2855 : }

  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
?gObjAddMonster@@YAFH@Z ENDP				; gObjAddMonster
_TEXT	ENDS
PUBLIC	?gObjAddCallMon@@YAFXZ				; gObjAddCallMon
; Function compile flags: /Ogtp
;	COMDAT ?gObjAddCallMon@@YAFXZ
_TEXT	SEGMENT
?gObjAddCallMon@@YAFXZ PROC				; gObjAddCallMon, COMDAT

; 2858 : {

  00000	56		 push	 esi

; 2859 : 	int count;
; 2860 : 	int totalcount = 0;
; 2861 : 
; 2862 : 	count = gObjCallMonCount;

  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObjCallMonCount@@3HA ; gObjCallMonCount

; 2863 : 
; 2864 : 	while ( true )
; 2865 : 	{
; 2866 : 		if ( gObj[count].Connected == PLAYER_EMPTY )

  00007	8b ce		 mov	 ecx, esi
  00009	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0000f	33 c0		 xor	 eax, eax
  00011	38 81 04 00 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], al
  00017	74 2e		 je	 SHORT $LN11@gObjAddCal
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL6@gObjAddCal:

; 2879 : 		}
; 2880 : 
; 2881 : 		count++;

  00020	46		 inc	 esi

; 2882 : 
; 2883 : 		if ( count >= OBJ_STARTUSERINDEX )

  00021	81 fe 00 19 00
	00		 cmp	 esi, 6400		; 00001900H
  00027	7c 05		 jl	 SHORT $LN2@gObjAddCal

; 2884 : 		{
; 2885 : 			count = OBJ_MAXMONSTER;

  00029	be a8 16 00 00	 mov	 esi, 5800		; 000016a8H
$LN2@gObjAddCal:

; 2886 : 		}
; 2887 : 
; 2888 : 		totalcount++;

  0002e	40		 inc	 eax

; 2889 : 
; 2890 : 		if ( totalcount >= OBJ_CALLMONCOUNT )

  0002f	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  00034	7d 50		 jge	 SHORT $LN12@gObjAddCal

; 2863 : 
; 2864 : 	while ( true )
; 2865 : 	{
; 2866 : 		if ( gObj[count].Connected == PLAYER_EMPTY )

  00036	8b d6		 mov	 edx, esi
  00038	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  0003e	80 ba 04 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+4], 0
  00045	75 d9		 jne	 SHORT $LL6@gObjAddCal
$LN11@gObjAddCal:

; 2867 : 		{
; 2868 : 			gObjCharZeroSet(count);

  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 ?gObjCharZeroSet@@YAXH@Z ; gObjCharZeroSet

; 2869 : 			gObj[count].m_Index = count;

  0004d	8b c6		 mov	 eax, esi
  0004f	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00055	89 b0 00 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax], esi

; 2870 : 			gObj[count].Connected = PLAYER_CONNECTED;

  0005b	c6 80 04 00 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 1

; 2871 : 			gObjCallMonCount++;

  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjCallMonCount@@3HA ; gObjCallMonCount
  00067	40		 inc	 eax
  00068	83 c4 04	 add	 esp, 4
  0006b	a3 00 00 00 00	 mov	 DWORD PTR ?gObjCallMonCount@@3HA, eax ; gObjCallMonCount

; 2872 : 
; 2873 : 			if ( gObjCallMonCount >= OBJ_STARTUSERINDEX )

  00070	3d 00 19 00 00	 cmp	 eax, 6400		; 00001900H
  00075	7c 0a		 jl	 SHORT $LN3@gObjAddCal

; 2874 : 			{
; 2875 : 				gObjCallMonCount = OBJ_MAXMONSTER;

  00077	c7 05 00 00 00
	00 a8 16 00 00	 mov	 DWORD PTR ?gObjCallMonCount@@3HA, 5800 ; gObjCallMonCount, 000016a8H
$LN3@gObjAddCal:

; 2876 : 
; 2877 : 			}
; 2878 : 			return count;

  00081	66 8b c6	 mov	 ax, si
  00084	5e		 pop	 esi

; 2894 : 		}
; 2895 : 	}
; 2896 : 
; 2897 : 	return -1;
; 2898 : 
; 2899 : }

  00085	c3		 ret	 0
$LN12@gObjAddCal:

; 2891 : 		{
; 2892 : 			LogAdd(LOG_BLACK, lMsg.Get(MSGGET(1, 255)), __FILE__, __LINE__);

  00086	68 4c 0b 00 00	 push	 2892			; 00000b4cH
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00090	68 ff 01 00 00	 push	 511			; 000001ffH
  00095	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0009a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0009f	50		 push	 eax
  000a0	6a 00		 push	 0
  000a2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000a7	83 c4 10	 add	 esp, 16			; 00000010H

; 2893 : 			return -1;

  000aa	83 c8 ff	 or	 eax, -1
  000ad	5e		 pop	 esi

; 2894 : 		}
; 2895 : 	}
; 2896 : 
; 2897 : 	return -1;
; 2898 : 
; 2899 : }

  000ae	c3		 ret	 0
?gObjAddCallMon@@YAFXZ ENDP				; gObjAddCallMon
_TEXT	ENDS
PUBLIC	?gObjAllLogOut@@YAXXZ				; gObjAllLogOut
EXTRN	__imp__Sleep@4:PROC
;	COMDAT ?bAllLogOut@?1??gObjAllLogOut@@YAXXZ@4HA
_BSS	SEGMENT
?bAllLogOut@?1??gObjAllLogOut@@YAXXZ@4HA DD 01H DUP (?)	; `gObjAllLogOut'::`2'::bAllLogOut
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT ?gObjAllLogOut@@YAXXZ
_TEXT	SEGMENT
?gObjAllLogOut@@YAXXZ PROC				; gObjAllLogOut, COMDAT

; 2914 : 	static BOOL bAllLogOut = FALSE;
; 2915 : 
; 2916 : 	if ( bAllLogOut == 0 )

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bAllLogOut@?1??gObjAllLogOut@@YAXXZ@4HA, 0
  00007	75 34		 jne	 SHORT $LN1@gObjAllLog

; 2917 : 	{
; 2918 : 		bAllLogOut = 1;

  00009	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bAllLogOut@?1??gObjAllLogOut@@YAXXZ@4HA, 1

; 2919 : 		gObjAllDisconnect();

  00013	e8 00 00 00 00	 call	 ?gObjAllDisconnect@@YAXXZ ; gObjAllDisconnect

; 2920 : 		Sleep(1000);

  00018	68 e8 03 00 00	 push	 1000			; 000003e8H
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 2921 : 		LogAdd(LOG_RED,  lMsg.Get( MSGGET(2, 0)));

  00023	68 00 02 00 00	 push	 512			; 00000200H
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0002d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00032	50		 push	 eax
  00033	6a 01		 push	 1
  00035	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0003a	83 c4 08	 add	 esp, 8
$LN1@gObjAllLog:

; 2922 : 	}
; 2923 : }

  0003d	c3		 ret	 0
?gObjAllLogOut@@YAXXZ ENDP				; gObjAllLogOut
_TEXT	ENDS
PUBLIC	??_C@_0BP@FCDEDEIA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5BillType?5?3?5?$CINoCharge?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0DD@EGADHIAE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5BillType?5?3?5?$CIDate?$CJ?5Remai@ ; `string'
PUBLIC	??_C@_0CO@CIBMOLHH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5BillType?5?3?5?$CITime?$CJ?5Remai@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?gObjBillRequest@@YAXPAUOBJECTSTRUCT@@@Z	; gObjBillRequest
EXTRN	_atoi:PROC
EXTRN	_strncpy:PROC
;	COMDAT ??_C@_0BP@FCDEDEIA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5BillType?5?3?5?$CINoCharge?$CJ?$AA@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.h
CONST	SEGMENT
??_C@_0BP@FCDEDEIA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5BillType?5?3?5?$CINoCharge?$CJ?$AA@ DB '['
	DB	'%s][%s] BillType : (NoCharge)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EGADHIAE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5BillType?5?3?5?$CIDate?$CJ?5Remai@
CONST	SEGMENT
??_C@_0DD@EGADHIAE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5BillType?5?3?5?$CIDate?$CJ?5Remai@ DB '['
	DB	'%s][%s] BillType : (Date) RemainDate : (%s-%s-%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@CIBMOLHH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5BillType?5?3?5?$CITime?$CJ?5Remai@
CONST	SEGMENT
??_C@_0CO@CIBMOLHH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5BillType?5?3?5?$CITime?$CJ?5Remai@ DB '['
	DB	'%s][%s] BillType : (Time) RemainPoint : (%d)', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
CONST	ENDS
;	COMDAT ?gObjBillRequest@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_szDay$162705 = -180					; size = 3
_szMonth$162712 = -176					; size = 3
_szMin$162707 = -176					; size = 3
_szDay$162713 = -172					; size = 3
_szHour$162706 = -172					; size = 3
_szMsg$ = -168						; size = 128
_szTemp$162694 = -40					; size = 20
_szYear$162703 = -20					; size = 5
_szYear$162711 = -12					; size = 5
_szMonth$162704 = -12					; size = 3
_Month$162696 = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjBillRequest@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjBillRequest, COMDAT

; 2964 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 2965 : 	char szMsg[128];
; 2966 : 
; 2967 : 	if ( m_ObjBill[lpObj->m_Index].GetPayCode() == 0 )

  00018	8b 06		 mov	 eax, DWORD PTR [esi]
  0001a	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0001d	03 c0		 add	 eax, eax
  0001f	03 c0		 add	 eax, eax
  00021	8a 8c 00 01 00
	00 00		 mov	 cl, BYTE PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[eax+eax+1]
  00028	03 c0		 add	 eax, eax
  0002a	33 db		 xor	 ebx, ebx
  0002c	57		 push	 edi
  0002d	3a cb		 cmp	 cl, bl
  0002f	75 73		 jne	 SHORT $LN17@gObjBillRe

; 2968 : 	{
; 2969 : 		if ( m_ObjBill[lpObj->m_Index].GetCertify() == 0 )

  00031	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[eax]
  00037	3a cb		 cmp	 cl, bl
  00039	75 2c		 jne	 SHORT $LN16@gObjBillRe

; 2970 : 		{
; 2971 : 			wsprintf(szMsg, lMsg.Get(MSGGET(4, 85)), m_ObjBill[lpObj->m_Index].GetEndTime());

  0003b	8b 80 04 00 00
	00		 mov	 eax, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[eax+4]
  00041	50		 push	 eax
  00042	68 55 04 00 00	 push	 1109			; 00000455H
  00047	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0004c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00051	50		 push	 eax
  00052	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$[ebp]
  00058	50		 push	 eax
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2972 : 		}
; 2973 : 		else if ( m_ObjBill[lpObj->m_Index].GetCertify() == 1 )

  00062	e9 77 03 00 00	 jmp	 $LN1@gObjBillRe
$LN16@gObjBillRe:
  00067	80 f9 01	 cmp	 cl, 1
  0006a	0f 85 6e 03 00
	00		 jne	 $LN1@gObjBillRe

; 2974 : 		{
; 2975 : 			if ( m_ObjBill[lpObj->m_Index].GetEndTime() != 0 )

  00070	8b 80 04 00 00
	00		 mov	 eax, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[eax+4]
  00076	3b c3		 cmp	 eax, ebx
  00078	0f 84 60 03 00
	00		 je	 $LN1@gObjBillRe

; 2976 : 			{
; 2977 : 				wsprintf(szMsg, lMsg.Get(MSGGET(4, 86)), m_ObjBill[lpObj->m_Index].GetEndTime());

  0007e	50		 push	 eax
  0007f	68 56 04 00 00	 push	 1110			; 00000456H
  00084	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00089	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0008e	50		 push	 eax
  0008f	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _szMsg$[ebp]
  00095	51		 push	 ecx
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2978 : 			}
; 2979 : 		}
; 2980 : 	}

  0009f	e9 3a 03 00 00	 jmp	 $LN1@gObjBillRe
$LN17@gObjBillRe:

; 2981 : 	else if ( m_ObjBill[lpObj->m_Index].GetPayCode() == 1 )

  000a4	80 f9 01	 cmp	 cl, 1
  000a7	0f 85 dd 00 00
	00		 jne	 $LN11@gObjBillRe

; 2982 : 	{
; 2983 : 		char szTemp[20];
; 2984 : 		szTemp[4] = 0;
; 2985 : 		strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays(), 4);

  000ad	8d 90 08 00 00
	00		 lea	 edx, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[eax+8]
  000b3	6a 04		 push	 4
  000b5	52		 push	 edx
  000b6	8d 45 d8	 lea	 eax, DWORD PTR _szTemp$162694[ebp]
  000b9	50		 push	 eax
  000ba	88 5d dc	 mov	 BYTE PTR _szTemp$162694[ebp+4], bl
  000bd	e8 00 00 00 00	 call	 _strncpy

; 2986 : 		int Day = atoi(szTemp);

  000c2	8d 4d d8	 lea	 ecx, DWORD PTR _szTemp$162694[ebp]
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 _atoi
  000cb	8b f8		 mov	 edi, eax

; 2987 : 
; 2988 : 		strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+4, 2);

  000cd	8b 06		 mov	 eax, DWORD PTR [esi]
  000cf	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  000d2	6a 02		 push	 2
  000d4	8d 04 d5 0c 00
	00 00		 lea	 eax, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[edx*8+12]
  000db	50		 push	 eax
  000dc	8d 4d d8	 lea	 ecx, DWORD PTR _szTemp$162694[ebp]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _strncpy

; 2989 : 		szTemp[2] = 0;
; 2990 : 		int Month = atoi(szTemp);

  000e5	8d 55 d8	 lea	 edx, DWORD PTR _szTemp$162694[ebp]
  000e8	52		 push	 edx
  000e9	88 5d da	 mov	 BYTE PTR _szTemp$162694[ebp+2], bl
  000ec	e8 00 00 00 00	 call	 _atoi
  000f1	89 45 f4	 mov	 DWORD PTR _Month$162696[ebp], eax

; 2991 : 
; 2992 : 		strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+6, 2);

  000f4	8b 06		 mov	 eax, DWORD PTR [esi]
  000f6	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000f9	6a 02		 push	 2
  000fb	8d 0c c5 0e 00
	00 00		 lea	 ecx, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[eax*8+14]
  00102	51		 push	 ecx
  00103	8d 55 d8	 lea	 edx, DWORD PTR _szTemp$162694[ebp]
  00106	52		 push	 edx
  00107	e8 00 00 00 00	 call	 _strncpy

; 2993 : 		szTemp[2] = 0;
; 2994 : 		int Year = atoi(szTemp);

  0010c	8d 45 d8	 lea	 eax, DWORD PTR _szTemp$162694[ebp]
  0010f	50		 push	 eax
  00110	88 5d da	 mov	 BYTE PTR _szTemp$162694[ebp+2], bl
  00113	e8 00 00 00 00	 call	 _atoi

; 2995 : 
; 2996 : 		if ( m_ObjBill[lpObj->m_Index].GetCertify() == 0 )	// Account Based

  00118	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0011a	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0011d	8a 0c cd 00 00
	00 00		 mov	 cl, BYTE PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[ecx*8]
  00124	83 c4 30	 add	 esp, 48			; 00000030H
  00127	3a cb		 cmp	 cl, bl
  00129	75 2b		 jne	 SHORT $LN10@gObjBillRe

; 2997 : 		{
; 2998 : 			wsprintf(szMsg, lMsg.Get(MSGGET(4, 87)), Day, Month, Year);

  0012b	8b 55 f4	 mov	 edx, DWORD PTR _Month$162696[ebp]
  0012e	50		 push	 eax
  0012f	52		 push	 edx
  00130	57		 push	 edi
  00131	68 57 04 00 00	 push	 1111			; 00000457H
  00136	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0013b	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00140	50		 push	 eax
  00141	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$[ebp]
  00147	50		 push	 eax
  00148	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0014e	83 c4 14	 add	 esp, 20			; 00000014H

; 2999 : 		}
; 3000 : 		else if ( m_ObjBill[lpObj->m_Index].GetCertify() == 1 )	// IP Based

  00151	e9 88 02 00 00	 jmp	 $LN1@gObjBillRe
$LN10@gObjBillRe:
  00156	80 f9 01	 cmp	 cl, 1
  00159	0f 85 7f 02 00
	00		 jne	 $LN1@gObjBillRe

; 3001 : 		{
; 3002 : 			wsprintf(szMsg, lMsg.Get(MSGGET(4, 88)), Day, Month, Year);

  0015f	8b 4d f4	 mov	 ecx, DWORD PTR _Month$162696[ebp]
  00162	50		 push	 eax
  00163	51		 push	 ecx
  00164	57		 push	 edi
  00165	68 58 04 00 00	 push	 1112			; 00000458H
  0016a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0016f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00174	50		 push	 eax
  00175	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _szMsg$[ebp]
  0017b	52		 push	 edx
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00182	83 c4 14	 add	 esp, 20			; 00000014H

; 3003 : 		}
; 3004 : 	}

  00185	e9 54 02 00 00	 jmp	 $LN1@gObjBillRe
$LN11@gObjBillRe:

; 3005 : 	else if ( m_ObjBill[lpObj->m_Index].GetPayCode() == 3)

  0018a	80 f9 03	 cmp	 cl, 3
  0018d	0f 85 25 01 00
	00		 jne	 $LN6@gObjBillRe

; 3006 : 	{
; 3007 : 		char szYear[5] = "";
; 3008 : 		char szMonth[3] = "";

  00193	33 c9		 xor	 ecx, ecx

; 3009 : 		char szDay[3] = "";
; 3010 : 		char szHour[3] = "";
; 3011 : 		char szMin[3] = "";
; 3012 : 
; 3013 : 		strncpy(szYear, m_ObjBill[lpObj->m_Index].GetEndsDays(), 4);

  00195	6a 04		 push	 4
  00197	8d 80 08 00 00
	00		 lea	 eax, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[eax+8]
  0019d	66 89 4d f5	 mov	 WORD PTR _szMonth$162704[ebp+1], cx
  001a1	66 89 8d 55 ff
	ff ff		 mov	 WORD PTR _szHour$162706[ebp+1], cx
  001a8	33 d2		 xor	 edx, edx
  001aa	50		 push	 eax
  001ab	8d 4d ec	 lea	 ecx, DWORD PTR _szYear$162703[ebp]
  001ae	51		 push	 ecx
  001af	88 5d ec	 mov	 BYTE PTR _szYear$162703[ebp], bl
  001b2	89 5d ed	 mov	 DWORD PTR _szYear$162703[ebp+1], ebx
  001b5	88 5d f4	 mov	 BYTE PTR _szMonth$162704[ebp], bl
  001b8	88 9d 4c ff ff
	ff		 mov	 BYTE PTR _szDay$162705[ebp], bl
  001be	66 89 95 4d ff
	ff ff		 mov	 WORD PTR _szDay$162705[ebp+1], dx
  001c5	88 9d 54 ff ff
	ff		 mov	 BYTE PTR _szHour$162706[ebp], bl
  001cb	88 9d 50 ff ff
	ff		 mov	 BYTE PTR _szMin$162707[ebp], bl
  001d1	66 89 95 51 ff
	ff ff		 mov	 WORD PTR _szMin$162707[ebp+1], dx
  001d8	e8 00 00 00 00	 call	 _strncpy

; 3014 : 		strncpy(szMonth, m_ObjBill[lpObj->m_Index].GetEndsDays()+4, 2);

  001dd	8b 06		 mov	 eax, DWORD PTR [esi]
  001df	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  001e2	6a 02		 push	 2
  001e4	8d 04 d5 0c 00
	00 00		 lea	 eax, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[edx*8+12]
  001eb	50		 push	 eax
  001ec	8d 4d f4	 lea	 ecx, DWORD PTR _szMonth$162704[ebp]
  001ef	51		 push	 ecx
  001f0	e8 00 00 00 00	 call	 _strncpy

; 3015 : 		strncpy(szDay, m_ObjBill[lpObj->m_Index].GetEndsDays()+6, 2);

  001f5	8b 06		 mov	 eax, DWORD PTR [esi]
  001f7	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  001fa	6a 02		 push	 2
  001fc	8d 04 d5 0e 00
	00 00		 lea	 eax, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[edx*8+14]
  00203	50		 push	 eax
  00204	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _szDay$162705[ebp]
  0020a	51		 push	 ecx
  0020b	e8 00 00 00 00	 call	 _strncpy

; 3016 : 		strncpy(szHour, m_ObjBill[lpObj->m_Index].GetEndsDays()+8, 2);

  00210	8b 06		 mov	 eax, DWORD PTR [esi]
  00212	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00215	6a 02		 push	 2
  00217	8d 04 d5 10 00
	00 00		 lea	 eax, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[edx*8+16]
  0021e	50		 push	 eax
  0021f	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _szHour$162706[ebp]
  00225	51		 push	 ecx
  00226	e8 00 00 00 00	 call	 _strncpy

; 3017 : 		strncpy(szMin, m_ObjBill[lpObj->m_Index].GetEndsDays()+10, 2);

  0022b	8b 06		 mov	 eax, DWORD PTR [esi]
  0022d	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00230	6a 02		 push	 2
  00232	8d 04 d5 12 00
	00 00		 lea	 eax, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[edx*8+18]
  00239	50		 push	 eax
  0023a	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _szMin$162707[ebp]
  00240	51		 push	 ecx
  00241	e8 00 00 00 00	 call	 _strncpy

; 3018 : 
; 3019 : 		wsprintf(szMsg, lMsg.Get(MSGGET(5, 220)), m_ObjBill[lpObj->m_Index].GetEndTime(), szYear, szMonth,
; 3020 : 			szDay, szHour, szMin);

  00246	8b 06		 mov	 eax, DWORD PTR [esi]
  00248	83 c4 3c	 add	 esp, 60			; 0000003cH
  0024b	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0024e	8b 04 d5 04 00
	00 00		 mov	 eax, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[edx*8+4]
  00255	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _szMin$162707[ebp]
  0025b	51		 push	 ecx
  0025c	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _szHour$162706[ebp]
  00262	52		 push	 edx
  00263	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _szDay$162705[ebp]
  00269	51		 push	 ecx
  0026a	8d 55 f4	 lea	 edx, DWORD PTR _szMonth$162704[ebp]
  0026d	52		 push	 edx
  0026e	8d 4d ec	 lea	 ecx, DWORD PTR _szYear$162703[ebp]
  00271	51		 push	 ecx
  00272	50		 push	 eax
  00273	68 dc 05 00 00	 push	 1500			; 000005dcH
  00278	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0027d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00282	50		 push	 eax
  00283	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _szMsg$[ebp]
  00289	52		 push	 edx
  0028a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 3021 : 
; 3022 : 		LogAdd(LOG_BLACK, "[%s][%s] BillType : (Time) RemainPoint : (%d)",
; 3023 : 			lpObj->AccountID, lpObj->Name, m_ObjBill[lpObj->m_Index].GetEndTime());

  00290	8b 06		 mov	 eax, DWORD PTR [esi]
  00292	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00295	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[eax*8+4]
  0029c	51		 push	 ecx
  0029d	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  002a0	52		 push	 edx
  002a1	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  002a4	50		 push	 eax
  002a5	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@CIBMOLHH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5BillType?5?3?5?$CITime?$CJ?5Remai@
  002aa	53		 push	 ebx
  002ab	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  002b0	83 c4 34	 add	 esp, 52			; 00000034H
  002b3	e9 26 01 00 00	 jmp	 $LN1@gObjBillRe
$LN6@gObjBillRe:

; 3024 : 	}
; 3025 : 	else if ( m_ObjBill[lpObj->m_Index].GetPayCode() == 4)

  002b8	80 f9 04	 cmp	 cl, 4
  002bb	0f 85 c8 00 00
	00		 jne	 $LN4@gObjBillRe

; 3026 : 	{
; 3027 : 		char szYear[5] = "";
; 3028 : 		char szMonth[3] = "";

  002c1	33 c9		 xor	 ecx, ecx

; 3029 : 		char szDay[3] = "";
; 3030 : 
; 3031 : 		strncpy(szYear, m_ObjBill[lpObj->m_Index].GetEndsDays(), 4);

  002c3	6a 04		 push	 4
  002c5	8d 80 08 00 00
	00		 lea	 eax, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[eax+8]
  002cb	66 89 8d 51 ff
	ff ff		 mov	 WORD PTR _szMonth$162712[ebp+1], cx
  002d2	50		 push	 eax
  002d3	8d 4d f4	 lea	 ecx, DWORD PTR _szYear$162711[ebp]
  002d6	33 d2		 xor	 edx, edx
  002d8	51		 push	 ecx
  002d9	88 5d f4	 mov	 BYTE PTR _szYear$162711[ebp], bl
  002dc	89 5d f5	 mov	 DWORD PTR _szYear$162711[ebp+1], ebx
  002df	88 9d 50 ff ff
	ff		 mov	 BYTE PTR _szMonth$162712[ebp], bl
  002e5	88 9d 54 ff ff
	ff		 mov	 BYTE PTR _szDay$162713[ebp], bl
  002eb	66 89 95 55 ff
	ff ff		 mov	 WORD PTR _szDay$162713[ebp+1], dx
  002f2	e8 00 00 00 00	 call	 _strncpy

; 3032 : 		strncpy(szMonth, m_ObjBill[lpObj->m_Index].GetEndsDays()+4, 2);

  002f7	8b 06		 mov	 eax, DWORD PTR [esi]
  002f9	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  002fc	6a 02		 push	 2
  002fe	8d 04 d5 0c 00
	00 00		 lea	 eax, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[edx*8+12]
  00305	50		 push	 eax
  00306	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _szMonth$162712[ebp]
  0030c	51		 push	 ecx
  0030d	e8 00 00 00 00	 call	 _strncpy

; 3033 : 		strncpy(szDay, m_ObjBill[lpObj->m_Index].GetEndsDays()+6, 2);

  00312	8b 06		 mov	 eax, DWORD PTR [esi]
  00314	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00317	6a 02		 push	 2
  00319	8d 04 d5 0e 00
	00 00		 lea	 eax, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[edx*8+14]
  00320	50		 push	 eax
  00321	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _szDay$162713[ebp]
  00327	51		 push	 ecx
  00328	e8 00 00 00 00	 call	 _strncpy
  0032d	83 c4 24	 add	 esp, 36			; 00000024H

; 3034 : 
; 3035 : 		wsprintf(szMsg, lMsg.Get(MSGGET(5, 221)),  szYear, szMonth,	szDay);

  00330	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _szDay$162713[ebp]
  00336	52		 push	 edx
  00337	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _szMonth$162712[ebp]
  0033d	50		 push	 eax
  0033e	8d 4d f4	 lea	 ecx, DWORD PTR _szYear$162711[ebp]
  00341	51		 push	 ecx
  00342	68 dd 05 00 00	 push	 1501			; 000005ddH
  00347	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0034c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00351	50		 push	 eax
  00352	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _szMsg$[ebp]
  00358	52		 push	 edx
  00359	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 3036 : 
; 3037 : 		LogAdd(LOG_BLACK, "[%s][%s] BillType : (Date) RemainDate : (%s-%s-%s)",
; 3038 : 			lpObj->AccountID, lpObj->Name, szYear, szMonth, szDay);

  0035f	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _szDay$162713[ebp]
  00365	50		 push	 eax
  00366	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _szMonth$162712[ebp]
  0036c	51		 push	 ecx
  0036d	8d 55 f4	 lea	 edx, DWORD PTR _szYear$162711[ebp]
  00370	52		 push	 edx
  00371	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00374	50		 push	 eax
  00375	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  00378	51		 push	 ecx
  00379	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@EGADHIAE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5BillType?5?3?5?$CIDate?$CJ?5Remai@
  0037e	53		 push	 ebx
  0037f	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00384	83 c4 30	 add	 esp, 48			; 00000030H
  00387	eb 55		 jmp	 SHORT $LN1@gObjBillRe
$LN4@gObjBillRe:

; 3039 : 	}
; 3040 : 	else if ( m_ObjBill[lpObj->m_Index].GetPayCode() == 5)		// FREE

  00389	80 f9 05	 cmp	 cl, 5

; 3041 : 	{
; 3042 : 		wsprintf(szMsg, lMsg.Get(MSGGET(5, 222)));

  0038c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00391	75 30		 jne	 SHORT $LN2@gObjBillRe
  00393	68 de 05 00 00	 push	 1502			; 000005deH
  00398	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0039d	50		 push	 eax
  0039e	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _szMsg$[ebp]
  003a4	52		 push	 edx
  003a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 3043 : 		LogAdd(LOG_BLACK, "[%s][%s] BillType : (NoCharge)", lpObj->AccountID, lpObj->Name);

  003ab	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  003ae	50		 push	 eax
  003af	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  003b2	51		 push	 ecx
  003b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@FCDEDEIA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5BillType?5?3?5?$CINoCharge?$CJ?$AA@
  003b8	53		 push	 ebx
  003b9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  003be	83 c4 18	 add	 esp, 24			; 00000018H

; 3044 : 	}
; 3045 : 	else	// Pospaid Account

  003c1	eb 1b		 jmp	 SHORT $LN1@gObjBillRe
$LN2@gObjBillRe:

; 3046 : 	{
; 3047 : 		wsprintf(szMsg, lMsg.Get(MSGGET(4, 89)));

  003c3	68 59 04 00 00	 push	 1113			; 00000459H
  003c8	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003cd	50		 push	 eax
  003ce	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _szMsg$[ebp]
  003d4	52		 push	 edx
  003d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  003db	83 c4 08	 add	 esp, 8
$LN1@gObjBillRe:

; 3048 : 	}
; 3049 : 
; 3050 : 
; 3051 : 	LogAdd(LOG_BLACK, szMsg);

  003de	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$[ebp]
  003e4	50		 push	 eax
  003e5	53		 push	 ebx
  003e6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 3052 : 	GCServerMsgStringSend(szMsg, lpObj->m_Index, 1);

  003eb	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003ed	6a 01		 push	 1
  003ef	51		 push	 ecx
  003f0	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _szMsg$[ebp]
  003f6	52		 push	 edx
  003f7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 3053 : }

  003fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ff	83 c4 14	 add	 esp, 20			; 00000014H
  00402	5f		 pop	 edi
  00403	5e		 pop	 esi
  00404	33 cd		 xor	 ecx, ebp
  00406	5b		 pop	 ebx
  00407	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040c	8b e5		 mov	 esp, ebp
  0040e	5d		 pop	 ebp
  0040f	c3		 ret	 0
?gObjBillRequest@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjBillRequest
_TEXT	ENDS
PUBLIC	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z	; gObjCalDistance
; Function compile flags: /Ogtp
;	COMDAT ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv179 = 8						; size = 4
tv178 = 8						; size = 4
tv171 = 8						; size = 4
tv164 = 8						; size = 4
_ty$ = 8						; size = 4
_lpObj1$ = 8						; size = 4
_tx$ = 12						; size = 4
_lpObj2$ = 12						; size = 4
?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z PROC		; gObjCalDistance, COMDAT

; 3807 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3808 : 	if ( lpObj1->X == lpObj2->X && lpObj1->Y == lpObj2->Y )

  00003	8b 55 08	 mov	 edx, DWORD PTR _lpObj1$[ebp]
  00006	0f b7 82 04 01
	00 00		 movzx	 eax, WORD PTR [edx+260]
  0000d	56		 push	 esi
  0000e	8b 75 0c	 mov	 esi, DWORD PTR _lpObj2$[ebp]
  00011	0f b7 8e 04 01
	00 00		 movzx	 ecx, WORD PTR [esi+260]
  00018	66 3b c1	 cmp	 ax, cx
  0001b	75 17		 jne	 SHORT $LN1@gObjCalDis
  0001d	57		 push	 edi
  0001e	66 8b ba 06 01
	00 00		 mov	 di, WORD PTR [edx+262]
  00025	66 3b be 06 01
	00 00		 cmp	 di, WORD PTR [esi+262]
  0002c	5f		 pop	 edi
  0002d	75 05		 jne	 SHORT $LN1@gObjCalDis

; 3809 : 	{
; 3810 : 		return 0;

  0002f	33 c0		 xor	 eax, eax
  00031	5e		 pop	 esi

; 3817 : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN1@gObjCalDis:

; 3811 : 	}
; 3812 : 
; 3813 : 	float tx = lpObj1->X - lpObj2->X;

  00034	0f bf c9	 movsx	 ecx, cx
  00037	98		 cwde
  00038	2b c1		 sub	 eax, ecx

; 3814 : 	float ty = lpObj1->Y - lpObj2->Y;

  0003a	0f bf 8a 06 01
	00 00		 movsx	 ecx, WORD PTR [edx+262]
  00041	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  00048	89 45 08	 mov	 DWORD PTR tv179[ebp], eax
  0004b	2b ca		 sub	 ecx, edx
  0004d	db 45 08	 fild	 DWORD PTR tv179[ebp]
  00050	89 4d 08	 mov	 DWORD PTR tv178[ebp], ecx
  00053	d9 5d 0c	 fstp	 DWORD PTR _tx$[ebp]
  00056	db 45 08	 fild	 DWORD PTR tv178[ebp]
  00059	d9 5d 08	 fstp	 DWORD PTR _ty$[ebp]

; 3815 : 
; 3816 : 	return sqrt( (tx*tx)+(ty*ty) );

  0005c	d9 45 08	 fld	 DWORD PTR _ty$[ebp]
  0005f	d9 45 0c	 fld	 DWORD PTR _tx$[ebp]
  00062	dc c8		 fmul	 ST(0), ST(0)
  00064	d9 c1		 fld	 ST(1)
  00066	de ca		 fmulp	 ST(2), ST(0)
  00068	de c1		 faddp	 ST(1), ST(0)
  0006a	d9 5d 08	 fstp	 DWORD PTR tv171[ebp]
  0006d	d9 45 08	 fld	 DWORD PTR tv171[ebp]
  00070	e8 00 00 00 00	 call	 __CIsqrt
  00075	d9 5d 08	 fstp	 DWORD PTR tv164[ebp]
  00078	d9 45 08	 fld	 DWORD PTR tv164[ebp]
  0007b	5e		 pop	 esi

; 3817 : }

  0007c	5d		 pop	 ebp

; 3815 : 
; 3816 : 	return sqrt( (tx*tx)+(ty*ty) );

  0007d	e9 00 00 00 00	 jmp	 __ftol2_sse
?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ENDP		; gObjCalDistance
_TEXT	ENDS
PUBLIC	?gObjStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z	; gObjStateProc
EXTRN	?DefMagicInf@@3PAVCMagicInf@@A:BYTE		; DefMagicInf
EXTRN	?GCManagerGuildWarEnd@@YAXPAD@Z:PROC		; GCManagerGuildWarEnd
EXTRN	?BattleSoccerGoalStart@@YAXH@Z:PROC		; BattleSoccerGoalStart
; Function compile flags: /Ogtp
;	COMDAT ?gObjStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
_SubCode$ = 20						; size = 4
?gObjStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z PROC		; gObjStateProc, COMDAT

; 3986 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3987 : 	if ( (  (aIndex<0)?FALSE:(aIndex > OBJMAX-1)?FALSE:TRUE ) == FALSE )

  00003	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN23@gObjStateP
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 1b		 jne	 SHORT $LN17@gObjStateP
$LN23@gObjStateP:

; 3988 : 	{
; 3989 : 		LogAdd(LOG_BLACK, "error : %s %d", __FILE__, __LINE__ );

  00018	68 95 0f 00 00	 push	 3989			; 00000f95H
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00027	6a 00		 push	 0
  00029	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0002e	83 c4 10	 add	 esp, 16			; 00000010H

; 4044 : 	}
; 4045 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN17@gObjStateP:

; 3990 : 		return;
; 3991 : 	}
; 3992 : 
; 3993 : 	switch ( aMsgCode )

  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _aMsgCode$[ebp]
  00036	83 f9 36	 cmp	 ecx, 54			; 00000036H
  00039	0f 8f 2a 01 00
	00		 jg	 $LN22@gObjStateP
  0003f	0f 84 0a 01 00
	00		 je	 $LN2@gObjStateP
  00045	83 c1 fe	 add	 ecx, -2			; fffffffeH
  00048	83 f9 08	 cmp	 ecx, 8
  0004b	0f 87 2c 01 00
	00		 ja	 $LN15@gObjStateP
  00051	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN26@gObjStateP[ecx*4]
$LN14@gObjStateP:

; 3994 : 	{
; 3995 : 		case  2:
; 3996 : 			gObjBackSpring(lpObj, &gObj[aIndex]);

  00058	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0005e	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00063	50		 push	 eax
  00064	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?gObjBackSpring@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjBackSpring
  0006d	83 c4 08	 add	 esp, 8

; 4044 : 	}
; 4045 : }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
$LN13@gObjStateP:

; 3997 : 			break;
; 3998 : 
; 3999 : 		case  3:
; 4000 : 			gObjMonsterDieLifePlus(lpObj, &gObj[aIndex]);

  00072	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00075	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0007b	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00080	50		 push	 eax
  00081	51		 push	 ecx
  00082	e8 00 00 00 00	 call	 ?gObjMonsterDieLifePlus@@YAXPAUOBJECTSTRUCT@@0@Z ; gObjMonsterDieLifePlus
  00087	83 c4 08	 add	 esp, 8

; 4044 : 	}
; 4045 : }

  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
$LN11@gObjStateP:

; 4005 : 			break;
; 4006 : 
; 4007 : 		case  4:
; 4008 : 			if ( lpObj->lpGuild != NULL && lpObj->lpGuild->lpTargetGuildNode != NULL )

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0008f	8b 81 b4 02 00
	00		 mov	 eax, DWORD PTR [ecx+692]
  00095	85 c0		 test	 eax, eax
  00097	0f 84 e0 00 00
	00		 je	 $LN15@gObjStateP
  0009d	83 b8 8c 05 00
	00 00		 cmp	 DWORD PTR [eax+1420], 0
  000a4	0f 84 d3 00 00
	00		 je	 $LN15@gObjStateP

; 4009 : 			{
; 4010 : 				gObjGuildWarEnd(lpObj->lpGuild, lpObj->lpGuild->lpTargetGuildNode);

  000aa	8b 90 8c 05 00
	00		 mov	 edx, DWORD PTR [eax+1420]
  000b0	52		 push	 edx
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  000b7	83 c4 08	 add	 esp, 8

; 4044 : 	}
; 4045 : }

  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
$LN9@gObjStateP:

; 4011 : 			}
; 4012 : 			break;
; 4013 : 
; 4014 : 		case  5:
; 4015 : 			if ( lpObj->lpGuild != NULL && lpObj->lpGuild->WarState != NULL && lpObj->lpGuild->WarType == 1 )

  000bc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bf	8b 80 b4 02 00
	00		 mov	 eax, DWORD PTR [eax+692]
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 b0 00 00
	00		 je	 $LN15@gObjStateP
  000cd	80 b8 91 05 00
	00 00		 cmp	 BYTE PTR [eax+1425], 0
  000d4	0f 84 a3 00 00
	00		 je	 $LN15@gObjStateP
  000da	80 b8 92 05 00
	00 01		 cmp	 BYTE PTR [eax+1426], 1
  000e1	0f 85 96 00 00
	00		 jne	 $LN15@gObjStateP

; 4016 : 			{
; 4017 : 				BattleSoccerGoalStart(0);

  000e7	6a 00		 push	 0
  000e9	e8 00 00 00 00	 call	 ?BattleSoccerGoalStart@@YAXH@Z ; BattleSoccerGoalStart
  000ee	83 c4 04	 add	 esp, 4

; 4044 : 	}
; 4045 : }

  000f1	5d		 pop	 ebp
  000f2	c3		 ret	 0
$LN7@gObjStateP:

; 4018 : 			}
; 4019 : 			break;
; 4020 : 
; 4021 : 		case  7:
; 4022 : 			if ( lpObj->lpGuild != NULL && lpObj->lpGuild->WarState != NULL && lpObj->lpGuild->WarType == 1)

  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000f6	8b 81 b4 02 00
	00		 mov	 eax, DWORD PTR [ecx+692]
  000fc	85 c0		 test	 eax, eax
  000fe	74 7d		 je	 SHORT $LN15@gObjStateP
  00100	80 b8 91 05 00
	00 00		 cmp	 BYTE PTR [eax+1425], 0
  00107	74 74		 je	 SHORT $LN15@gObjStateP
  00109	80 b8 92 05 00
	00 01		 cmp	 BYTE PTR [eax+1426], 1
  00110	75 6b		 jne	 SHORT $LN15@gObjStateP

; 4023 : 			{
; 4024 : 				if ( lpObj->lpGuild->BattleGroundIndex >= 0 )
; 4025 : 				{
; 4026 : 					GCManagerGuildWarEnd(lpObj->lpGuild->Name);

  00112	83 c0 04	 add	 eax, 4
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ?GCManagerGuildWarEnd@@YAXPAD@Z ; GCManagerGuildWarEnd
  0011b	83 c4 04	 add	 esp, 4

; 4044 : 	}
; 4045 : }

  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
$LN4@gObjStateP:

; 4027 : 				}
; 4028 : 			}
; 4029 : 			break;
; 4030 : 
; 4031 : 		case 10:
; 4032 : 			if ( lpObj->DamageReflect != 0 )

  00120	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00123	80 b9 15 01 00
	00 00		 cmp	 BYTE PTR [ecx+277], 0
  0012a	74 51		 je	 SHORT $LN15@gObjStateP

; 4033 : 			{
; 4034 : 				gObjAttack(lpObj, &gObj[aIndex], 0, 0, 0, SubCode, 0);

  0012c	8b 55 14	 mov	 edx, DWORD PTR _SubCode$[ebp]
  0012f	6a 00		 push	 0
  00131	52		 push	 edx
  00132	6a 00		 push	 0
  00134	6a 00		 push	 0
  00136	6a 00		 push	 0
$LN25@gObjStateP:
  00138	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0013e	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00143	50		 push	 eax
  00144	51		 push	 ecx
  00145	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  0014a	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4044 : 	}
; 4045 : }

  0014d	5d		 pop	 ebp
  0014e	c3		 ret	 0
$LN2@gObjStateP:

; 4035 : 			}
; 4036 : 			break;
; 4037 : 		case 54:
; 4038 : 			if( lpObj->Live )

  0014f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00152	80 79 62 00	 cmp	 BYTE PTR [ecx+98], 0
  00156	74 25		 je	 SHORT $LN15@gObjStateP

; 4039 : 			{
; 4040 : 				CMagicInf * lpMagic = &DefMagicInf[79];
; 4041 : 				gObjAttack(lpObj, &gObj[aIndex], lpMagic, 1, 0, SubCode, 0);

  00158	8b 55 14	 mov	 edx, DWORD PTR _SubCode$[ebp]
  0015b	6a 00		 push	 0
  0015d	52		 push	 edx
  0015e	6a 00		 push	 0
  00160	6a 01		 push	 1
  00162	68 f0 04 00 00	 push	 OFFSET ?DefMagicInf@@3PAVCMagicInf@@A+1264

; 4042 : 			}
; 4043 : 			break;

  00167	eb cf		 jmp	 SHORT $LN25@gObjStateP
$LN22@gObjStateP:

; 3990 : 		return;
; 3991 : 	}
; 3992 : 
; 3993 : 	switch ( aMsgCode )

  00169	81 f9 e8 03 00
	00		 cmp	 ecx, 1000		; 000003e8H
  0016f	75 0c		 jne	 SHORT $LN15@gObjStateP

; 4001 : 			break;
; 4002 : 
; 4003 : 		case 1000:
; 4004 : 			gObjBillRequest(lpObj);

  00171	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?gObjBillRequest@@YAXPAUOBJECTSTRUCT@@@Z ; gObjBillRequest
  0017a	83 c4 04	 add	 esp, 4
$LN15@gObjStateP:

; 4044 : 	}
; 4045 : }

  0017d	5d		 pop	 ebp
  0017e	c3		 ret	 0
  0017f	90		 npad	 1
$LN26@gObjStateP:
  00180	00 00 00 00	 DD	 $LN14@gObjStateP
  00184	00 00 00 00	 DD	 $LN13@gObjStateP
  00188	00 00 00 00	 DD	 $LN11@gObjStateP
  0018c	00 00 00 00	 DD	 $LN9@gObjStateP
  00190	00 00 00 00	 DD	 $LN15@gObjStateP
  00194	00 00 00 00	 DD	 $LN7@gObjStateP
  00198	00 00 00 00	 DD	 $LN15@gObjStateP
  0019c	00 00 00 00	 DD	 $LN15@gObjStateP
  001a0	00 00 00 00	 DD	 $LN4@gObjStateP
?gObjStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z ENDP		; gObjStateProc
_TEXT	ENDS
PUBLIC	?gObjLevelUpPointAdd@@YAHEPAUOBJECTSTRUCT@@@Z	; gObjLevelUpPointAdd
; Function compile flags: /Ogtp
;	COMDAT ?gObjLevelUpPointAdd@@YAHEPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_type$ = 8						; size = 1
_lpObj$ = 12						; size = 4
?gObjLevelUpPointAdd@@YAHEPAUOBJECTSTRUCT@@@Z PROC	; gObjLevelUpPointAdd, COMDAT

; 4443 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4444 : 	if(lpObj->Type > OBJ_NPC)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	66 83 7e 60 03	 cmp	 WORD PTR [esi+96], 3
  0000c	76 31		 jbe	 SHORT $LN19@gObjLevelU

; 4445 : 	{
; 4446 : 		LogAdd(LOG_RED,  lMsg.Get(MSGGET(2, 9)), lpObj->AccountID, lpObj->Name, __FILE__, __LINE__);

  0000e	68 5e 11 00 00	 push	 4446			; 0000115eH
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00018	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  0001b	50		 push	 eax
  0001c	83 c6 64	 add	 esi, 100		; 00000064H
  0001f	56		 push	 esi
  00020	68 09 02 00 00	 push	 521			; 00000209H
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0002a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0002f	50		 push	 eax
  00030	6a 01		 push	 1
  00032	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00037	83 c4 18	 add	 esp, 24			; 00000018H
$LN22@gObjLevelU:

; 4447 : 		return false;

  0003a	33 c0		 xor	 eax, eax
  0003c	5e		 pop	 esi

; 4522 : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN19@gObjLevelU:

; 4448 : 	}
; 4449 : 	// ---
; 4450 : 	if(lpObj->LevelUpPoint < 1)

  0003f	83 be a0 00 00
	00 01		 cmp	 DWORD PTR [esi+160], 1

; 4451 : 	{
; 4452 : 		return false;

  00046	7c f2		 jl	 SHORT $LN22@gObjLevelU

; 4453 : 	}
; 4454 : 	// ---
; 4455 : 	switch(type)

  00048	0f b6 45 08	 movzx	 eax, BYTE PTR _type$[ebp]
  0004c	83 f8 04	 cmp	 eax, 4
  0004f	0f 87 bf 00 00
	00		 ja	 $LN1@gObjLevelU
  00055	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN23@gObjLevelU[eax*4]
$LN15@gObjLevelU:

; 4456 : 	{
; 4457 : 		case 0:
; 4458 : 			if(lpObj->Strength >= gServerInfo.m_Data.iMaxStatus)

  0005c	0f b7 86 b4 00
	00 00		 movzx	 eax, WORD PTR [esi+180]
  00063	3b 05 70 00 00
	00		 cmp	 eax, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+112

; 4459 : 			{
; 4460 : 				return false;

  00069	7d cf		 jge	 SHORT $LN22@gObjLevelU

; 4461 : 			}
; 4462 : 			else
; 4463 : 			{
; 4464 : 				lpObj->Strength++;

  0006b	40		 inc	 eax
  0006c	66 89 86 b4 00
	00 00		 mov	 WORD PTR [esi+180], ax

; 4465 : 			}
; 4466 : 			break;

  00073	e9 9c 00 00 00	 jmp	 $LN1@gObjLevelU
$LN12@gObjLevelU:

; 4467 : 			// ---
; 4468 : 		case 1:
; 4469 : 			if(lpObj->Dexterity >= gServerInfo.m_Data.iMaxStatus)

  00078	0f b7 86 b6 00
	00 00		 movzx	 eax, WORD PTR [esi+182]
  0007f	3b 05 70 00 00
	00		 cmp	 eax, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+112

; 4470 : 			{
; 4471 : 				return false;

  00085	7d b3		 jge	 SHORT $LN22@gObjLevelU

; 4472 : 			}
; 4473 : 			else
; 4474 : 			{
; 4475 : 				lpObj->Dexterity++;

  00087	40		 inc	 eax
  00088	66 89 86 b6 00
	00 00		 mov	 WORD PTR [esi+182], ax

; 4476 : 			}
; 4477 : 			break;

  0008f	e9 80 00 00 00	 jmp	 $LN1@gObjLevelU
$LN9@gObjLevelU:

; 4478 : 			// ---
; 4479 : 		case 2:
; 4480 : 			if(lpObj->Vitality >= gServerInfo.m_Data.iMaxStatus)

  00094	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  0009b	3b 05 70 00 00
	00		 cmp	 eax, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+112

; 4481 : 			{
; 4482 : 				return false;

  000a1	7d 97		 jge	 SHORT $LN22@gObjLevelU

; 4483 : 			}
; 4484 : 			else
; 4485 : 			{
; 4486 : 				lpObj->Vitality++;
; 4487 : 				// ---
; 4488 : 				lpObj->MaxLife += lpObj->VitalityToLife;

  000a3	d9 86 f4 00 00
	00		 fld	 DWORD PTR [esi+244]

; 4489 : 				gObjCalcMaxLifePower(lpObj->m_Index);

  000a9	8b 16		 mov	 edx, DWORD PTR [esi]
  000ab	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  000b1	40		 inc	 eax
  000b2	52		 push	 edx
  000b3	66 89 86 b8 00
	00 00		 mov	 WORD PTR [esi+184], ax
  000ba	d9 9e c0 00 00
	00		 fstp	 DWORD PTR [esi+192]
  000c0	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower
  000c5	83 c4 04	 add	 esp, 4

; 4490 : 			}
; 4491 : 			break;

  000c8	eb 4a		 jmp	 SHORT $LN1@gObjLevelU
$LN6@gObjLevelU:

; 4492 : 			// ---
; 4493 : 		case 3:
; 4494 : 			if(lpObj->Energy >= gServerInfo.m_Data.iMaxStatus)

  000ca	0f b7 86 ba 00
	00 00		 movzx	 eax, WORD PTR [esi+186]
  000d1	3b 05 70 00 00
	00		 cmp	 eax, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+112

; 4495 : 			{
; 4496 : 				return false;

  000d7	0f 8d 5d ff ff
	ff		 jge	 $LN22@gObjLevelU

; 4497 : 			}
; 4498 : 			else
; 4499 : 			{
; 4500 : 				lpObj->Energy++;
; 4501 : 				lpObj->MaxMana += lpObj->EnergyToMana;

  000dd	d9 86 f8 00 00
	00		 fld	 DWORD PTR [esi+248]
  000e3	40		 inc	 eax
  000e4	d8 86 d4 00 00
	00		 fadd	 DWORD PTR [esi+212]
  000ea	66 89 86 ba 00
	00 00		 mov	 WORD PTR [esi+186], ax
  000f1	d9 9e d4 00 00
	00		 fstp	 DWORD PTR [esi+212]

; 4502 : 			}
; 4503 : 			break;

  000f7	eb 1b		 jmp	 SHORT $LN1@gObjLevelU
$LN3@gObjLevelU:

; 4504 : 			// ---
; 4505 : 		case 4:
; 4506 : 			if(lpObj->Leadership >= gServerInfo.m_Data.iMaxStatus)

  000f9	0f b7 86 d8 00
	00 00		 movzx	 eax, WORD PTR [esi+216]
  00100	3b 05 70 00 00
	00		 cmp	 eax, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+112

; 4507 : 			{
; 4508 : 				return false;

  00106	0f 8d 2e ff ff
	ff		 jge	 $LN22@gObjLevelU

; 4509 : 			}
; 4510 : 			else
; 4511 : 			{
; 4512 : 				lpObj->Leadership++;

  0010c	40		 inc	 eax
  0010d	66 89 86 d8 00
	00 00		 mov	 WORD PTR [esi+216], ax
$LN1@gObjLevelU:

; 4513 : 			}
; 4514 : 			break;
; 4515 : 	}
; 4516 : 	// ---
; 4517 : 	lpObj->LevelUpPoint--;
; 4518 : 	// ---
; 4519 : 	gObjCalCharacter(lpObj->m_Index);

  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	ff 8e a0 00 00
	00		 dec	 DWORD PTR [esi+160]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00122	83 c4 04	 add	 esp, 4

; 4520 : 	// ---
; 4521 : 	return true;

  00125	b8 01 00 00 00	 mov	 eax, 1
  0012a	5e		 pop	 esi

; 4522 : }

  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
  0012d	8d 49 00	 npad	 3
$LN23@gObjLevelU:
  00130	00 00 00 00	 DD	 $LN15@gObjLevelU
  00134	00 00 00 00	 DD	 $LN12@gObjLevelU
  00138	00 00 00 00	 DD	 $LN9@gObjLevelU
  0013c	00 00 00 00	 DD	 $LN6@gObjLevelU
  00140	00 00 00 00	 DD	 $LN3@gObjLevelU
?gObjLevelUpPointAdd@@YAHEPAUOBJECTSTRUCT@@@Z ENDP	; gObjLevelUpPointAdd
_TEXT	ENDS
PUBLIC	??_C@_0GE@HFNAODDP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5PK?5Info?5Set?5?$CIKilled?5Pla@ ; `string'
PUBLIC	??_C@_0FN@EACPGCDP@?$FLU?4System?$FN?$FLRival?$FN?$FLPlayer?5Kill?$FN?$FL?$KB@ ; `string'
PUBLIC	??_C@_0HA@LKHMDCKL@?$FLU?4System?$FN?$FLRival?$FN?$FLPlayer?5Kill?$FN?5?$CI@ ; `string'
PUBLIC	?gObjPlayerKiller@@YAXPAUOBJECTSTRUCT@@0@Z	; gObjPlayerKiller
EXTRN	?g_PKLevelIncreaseOff@@3HA:DWORD		; g_PKLevelIncreaseOff
EXTRN	?GetCurrentState@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetCurrentState
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
;	COMDAT ??_C@_0GE@HFNAODDP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5PK?5Info?5Set?5?$CIKilled?5Pla@
CONST	SEGMENT
??_C@_0GE@HFNAODDP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5PK?5Info?5Set?5?$CIKilled?5Pla@ DB '['
	DB	'%s][%s] PK Info Set (Killed Player) Origin(PkLevel:%d, PkCoun'
	DB	't:%d) Changed(PkLevel:%d, PkCount:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@EACPGCDP@?$FLU?4System?$FN?$FLRival?$FN?$FLPlayer?5Kill?$FN?$FL?$KB@
CONST	SEGMENT
??_C@_0FN@EACPGCDP@?$FLU?4System?$FN?$FLRival?$FN?$FLPlayer?5Kill?$FN?$FL?$KB@ DB '['
	DB	'U.System][Rival][Player Kill][', 0a1H, 0daH, 'ERROR : Can''t '
	DB	'find GuildInfo] (  [%s][%s] ) vs ( [%s][%s] )', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HA@LKHMDCKL@?$FLU?4System?$FN?$FLRival?$FN?$FLPlayer?5Kill?$FN?5?$CI@
CONST	SEGMENT
??_C@_0HA@LKHMDCKL@?$FLU?4System?$FN?$FLRival?$FN?$FLPlayer?5Kill?$FN?5?$CI@ DB '['
	DB	'U.System][Rival][Player Kill] ( Killer [%s][%s] / %s / U:%d /'
	DB	' R:%d ) vs ( Victim [%s][%s] / %s / U:%d / R:%d )', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjPlayerKiller@@YAXPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_iOriginPkLevel$ = -4					; size = 4
_iOriginPkCount$ = 8					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjPlayerKiller@@YAXPAUOBJECTSTRUCT@@0@Z PROC		; gObjPlayerKiller, COMDAT

; 4783 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 4784 : 	if ( lpObj->Type != OBJ_USER )

  00006	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00009	bb 01 00 00 00	 mov	 ebx, 1
  0000e	66 39 5e 60	 cmp	 WORD PTR [esi+96], bx
  00012	0f 85 d4 02 00
	00		 jne	 $LN43@gObjPlayer

; 4785 : 	{
; 4786 : 		return;
; 4787 : 	}
; 4788 : 
; 4789 : 	if ( gObjGetRelationShip(lpObj, lpTargetObj) == 2 )

  00018	57		 push	 edi
  00019	8b 7d 0c	 mov	 edi, DWORD PTR _lpTargetObj$[ebp]
  0001c	57		 push	 edi
  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 ?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjGetRelationShip
  00023	83 c4 08	 add	 esp, 8
  00026	83 f8 02	 cmp	 eax, 2
  00029	0f 85 89 00 00
	00		 jne	 $LN49@gObjPlayer

; 4790 : 	{
; 4791 : 		if ( lpObj->lpGuild!= NULL && lpTargetObj->lpGuild != NULL )

  0002f	8b 8e b4 02 00
	00		 mov	 ecx, DWORD PTR [esi+692]
  00035	85 c9		 test	 ecx, ecx
  00037	74 59		 je	 SHORT $LN48@gObjPlayer
  00039	83 bf b4 02 00
	00 00		 cmp	 DWORD PTR [edi+692], 0
  00040	74 50		 je	 SHORT $LN48@gObjPlayer

; 4792 : 		{
; 4793 : 			LogAdd(LOG_BLACK, "[U.System][Rival][Player Kill] ( Killer [%s][%s] / %s / U:%d / R:%d ) vs ( Victim [%s][%s] / %s / U:%d / R:%d )",
; 4794 : 				lpObj->AccountID, lpObj->Name, lpObj->lpGuild->Name, lpObj->lpGuild->iGuildUnion, lpObj->lpGuild->iGuildRival,
; 4795 : 				lpTargetObj->AccountID, lpTargetObj->Name, lpTargetObj->lpGuild->Name, lpTargetObj->lpGuild->iGuildUnion, lpTargetObj->lpGuild->iGuildRival);

  00042	8b 87 b4 02 00
	00		 mov	 eax, DWORD PTR [edi+692]
  00048	8b 90 20 07 00
	00		 mov	 edx, DWORD PTR [eax+1824]
  0004e	52		 push	 edx
  0004f	8b 90 1c 07 00
	00		 mov	 edx, DWORD PTR [eax+1820]
  00055	52		 push	 edx
  00056	8b 91 20 07 00
	00		 mov	 edx, DWORD PTR [ecx+1824]
  0005c	83 c0 04	 add	 eax, 4
  0005f	50		 push	 eax
  00060	8d 47 6f	 lea	 eax, DWORD PTR [edi+111]
  00063	50		 push	 eax
  00064	8b 81 1c 07 00
	00		 mov	 eax, DWORD PTR [ecx+1820]
  0006a	83 c7 64	 add	 edi, 100		; 00000064H
  0006d	57		 push	 edi
  0006e	52		 push	 edx
  0006f	50		 push	 eax
  00070	83 c1 04	 add	 ecx, 4
  00073	51		 push	 ecx
  00074	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  00077	51		 push	 ecx
  00078	83 c6 64	 add	 esi, 100		; 00000064H
  0007b	56		 push	 esi
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0HA@LKHMDCKL@?$FLU?4System?$FN?$FLRival?$FN?$FLPlayer?5Kill?$FN?5?$CI@
  00081	6a 00		 push	 0
  00083	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00088	83 c4 30	 add	 esp, 48			; 00000030H
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx

; 4974 : 	
; 4975 : 
; 4976 : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
$LN48@gObjPlayer:

; 4796 : 		}
; 4797 : 		else
; 4798 : 		{
; 4799 : 			LogAdd(LOG_BLACK, "[U.System][Rival][Player Kill][ERROR : Can't find GuildInfo] (  [%s][%s] ) vs ( [%s][%s] )",
; 4800 : 				lpObj->AccountID,lpObj->Name,lpTargetObj->AccountID,lpTargetObj->Name);

  00092	8d 57 6f	 lea	 edx, DWORD PTR [edi+111]
  00095	52		 push	 edx
  00096	83 c7 64	 add	 edi, 100		; 00000064H
  00099	57		 push	 edi
  0009a	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  0009d	50		 push	 eax
  0009e	83 c6 64	 add	 esi, 100		; 00000064H
  000a1	56		 push	 esi
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@EACPGCDP@?$FLU?4System?$FN?$FLRival?$FN?$FLPlayer?5Kill?$FN?$FL?$KB@
  000a7	6a 00		 push	 0
  000a9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000ae	83 c4 18	 add	 esp, 24			; 00000018H
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx

; 4974 : 	
; 4975 : 
; 4976 : }

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
$LN49@gObjPlayer:

; 4801 : 		}
; 4802 : 		return;
; 4803 : 	}
; 4804 : 
; 4805 : 	if ( CC_MAP_RANGE(lpTargetObj->MapNumber)  )

  000b8	8a 87 09 01 00
	00		 mov	 al, BYTE PTR [edi+265]
  000be	3c 12		 cmp	 al, 18			; 00000012H
  000c0	72 26		 jb	 SHORT $LN58@gObjPlayer
  000c2	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  000c7	3a c8		 cmp	 cl, al
  000c9	1b c9		 sbb	 ecx, ecx
  000cb	41		 inc	 ecx
  000cc	74 1a		 je	 SHORT $LN58@gObjPlayer

; 4806 : 	{
; 4807 : 		if ( g_ChaosCastle.GetCurrentState(lpTargetObj->MapNumber-MAP_INDEX_CHAOSCASTLE1) == 2 )

  000ce	0f b6 d0	 movzx	 edx, al
  000d1	83 ea 12	 sub	 edx, 18			; 00000012H
  000d4	52		 push	 edx
  000d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  000da	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  000df	83 f8 02	 cmp	 eax, 2
  000e2	0f 84 03 02 00
	00		 je	 $LN60@gObjPlayer
$LN58@gObjPlayer:

; 4808 : 		{
; 4809 : 			return;
; 4810 : 		}
; 4811 : 	}
; 4812 : 
; 4813 : #if GS_CASTLE == 1
; 4814 : 	if ( lpTargetObj->MapNumber == MAP_INDEX_CASTLESIEGE )
; 4815 : 	{
; 4816 : 		if ( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 4817 : 		{
; 4818 : 			if ( lpObj->m_btCsJoinSide )
; 4819 : 				return;
; 4820 : 		}
; 4821 : 		else if ( lpObj->Y > 113 )
; 4822 : 		{
; 4823 : 			if ( g_CastleSiege.CheckCastleOwnerUnionMember(lpObj->m_Index) == TRUE )
; 4824 : 			{
; 4825 : 				return;
; 4826 : 			}
; 4827 : 		}
; 4828 : 	
; 4829 : 		if ( lpTargetObj->m_PK_Level >= 6 )
; 4830 : 		{
; 4831 : 			return;
; 4832 : 		}
; 4833 : 	}
; 4834 : #endif
; 4835 : 
; 4836 : 	if((lpObj->Authority & 16) || (lpTargetObj->Authority & 16))

  000e8	b0 10		 mov	 al, 16			; 00000010H
  000ea	84 86 a4 01 00
	00		 test	 BYTE PTR [esi+420], al
  000f0	0f 85 f5 01 00
	00		 jne	 $LN60@gObjPlayer
  000f6	84 87 a4 01 00
	00		 test	 BYTE PTR [edi+420], al
  000fc	0f 85 e9 01 00
	00		 jne	 $LN60@gObjPlayer

; 4837 : 	{
; 4838 : 		return;
; 4839 : 	}
; 4840 : 
; 4841 : 	for ( int n=0;n<MAX_SELF_DEFENSE;n++)

  00102	33 c0		 xor	 eax, eax
  00104	8d 8f 48 02 00
	00		 lea	 ecx, DWORD PTR [edi+584]
  0010a	8d 9b 00 00 00
	00		 npad	 6
$LL42@gObjPlayer:

; 4842 : 	{
; 4843 : 		if ( lpTargetObj->SelfDefense[n] >= 0 )

  00110	8b 11		 mov	 edx, DWORD PTR [ecx]
  00112	85 d2		 test	 edx, edx
  00114	78 08		 js	 SHORT $LN41@gObjPlayer

; 4844 : 		{
; 4845 : 			if ( lpTargetObj->SelfDefense[n] == lpObj->m_Index )

  00116	3b 16		 cmp	 edx, DWORD PTR [esi]
  00118	0f 84 cd 01 00
	00		 je	 $LN60@gObjPlayer
$LN41@gObjPlayer:

; 4837 : 	{
; 4838 : 		return;
; 4839 : 	}
; 4840 : 
; 4841 : 	for ( int n=0;n<MAX_SELF_DEFENSE;n++)

  0011e	03 c3		 add	 eax, ebx
  00120	83 c1 04	 add	 ecx, 4
  00123	83 f8 05	 cmp	 eax, 5
  00126	7c e8		 jl	 SHORT $LL42@gObjPlayer

; 4846 : 			{
; 4847 : 				return;
; 4848 : 			}
; 4849 : 		}
; 4850 : 	}
; 4851 : 
; 4852 : 	int iOriginPkLevel = lpObj->m_PK_Level;

  00128	8a 8e fd 00 00
	00		 mov	 cl, BYTE PTR [esi+253]
  0012e	0f be c1	 movsx	 eax, cl
  00131	89 45 fc	 mov	 DWORD PTR _iOriginPkLevel$[ebp], eax

; 4853 : 	int iOriginPkCount = lpObj->m_PK_Count;

  00134	8a 86 fc 00 00
	00		 mov	 al, BYTE PTR [esi+252]
  0013a	0f be d0	 movsx	 edx, al
  0013d	89 55 08	 mov	 DWORD PTR _iOriginPkCount$[ebp], edx

; 4854 : 
; 4855 : 	if(g_PKLevelIncreaseOff == 1)

  00140	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?g_PKLevelIncreaseOff@@3HA, ebx ; g_PKLevelIncreaseOff
  00146	0f 84 9f 01 00
	00		 je	 $LN60@gObjPlayer

; 4856 : 	{
; 4857 : 		return;
; 4858 : 	}
; 4859 : 
; 4860 : 	if ( lpObj->m_PK_Level == 3 )

  0014c	b2 fd		 mov	 dl, -3			; fffffffdH
  0014e	80 f9 03	 cmp	 cl, 3
  00151	75 67		 jne	 SHORT $LN61@gObjPlayer

; 4861 : 	{
; 4862 : 		if(lpTargetObj->m_PK_Level == 3)

  00153	8a 8f fd 00 00
	00		 mov	 cl, BYTE PTR [edi+253]
  00159	80 f9 03	 cmp	 cl, 3
  0015c	75 0b		 jne	 SHORT $LN62@gObjPlayer

; 4863 : 		{
; 4864 : 			lpObj->m_PK_Count = 1;

  0015e	88 9e fc 00 00
	00		 mov	 BYTE PTR [esi+252], bl
  00164	e9 cd 00 00 00	 jmp	 $LN11@gObjPlayer
$LN62@gObjPlayer:

; 4865 : 		}
; 4866 : 		else if(lpTargetObj->m_PK_Level < 3)

  00169	7d 0b		 jge	 SHORT $LN33@gObjPlayer

; 4867 : 		{
; 4868 : 			lpObj->m_PK_Count = 1;

  0016b	88 9e fc 00 00
	00		 mov	 BYTE PTR [esi+252], bl
  00171	e9 c0 00 00 00	 jmp	 $LN11@gObjPlayer
$LN33@gObjPlayer:

; 4869 : 		}
; 4870 : 		else if(lpTargetObj->m_PK_Level == 4)

  00176	80 f9 04	 cmp	 cl, 4
  00179	75 0b		 jne	 SHORT $LN31@gObjPlayer

; 4871 : 		{
; 4872 : 			lpObj->m_PK_Count = 1;

  0017b	88 9e fc 00 00
	00		 mov	 BYTE PTR [esi+252], bl

; 4873 : 		}
; 4874 : 		else

  00181	e9 b0 00 00 00	 jmp	 $LN11@gObjPlayer
$LN31@gObjPlayer:

; 4875 : 		{
; 4876 : 			if(lpTargetObj->m_PK_Level >= 6 && lpTargetObj->Level > 20)

  00186	80 f9 06	 cmp	 cl, 6
  00189	0f 8c 5c 01 00
	00		 jl	 $LN60@gObjPlayer
  0018f	66 83 bf 9c 00
	00 00 14	 cmp	 WORD PTR [edi+156], 20	; 00000014H
  00197	0f 8e 4e 01 00
	00		 jle	 $LN60@gObjPlayer

; 4877 : 			{
; 4878 : 				lpObj->m_PK_Count--;

  0019d	2a c3		 sub	 al, bl
  0019f	88 86 fc 00 00
	00		 mov	 BYTE PTR [esi+252], al

; 4879 : 
; 4880 : 				if(lpObj->m_PK_Count < -3)

  001a5	3a c2		 cmp	 al, dl
  001a7	0f 8d 89 00 00
	00		 jge	 $LN11@gObjPlayer

; 4881 : 				{
; 4882 : 					lpObj->m_PK_Count = (BYTE)-3;

  001ad	5f		 pop	 edi
  001ae	88 96 fc 00 00
	00		 mov	 BYTE PTR [esi+252], dl
  001b4	5e		 pop	 esi
  001b5	5b		 pop	 ebx

; 4974 : 	
; 4975 : 
; 4976 : }

  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c3		 ret	 0
$LN61@gObjPlayer:

; 4883 : 					return;
; 4884 : 				}
; 4885 : 			}
; 4886 : 			else
; 4887 : 			{
; 4888 : 				return;
; 4889 : 			}
; 4890 : 		}
; 4891 : 	}
; 4892 : 	else if( lpObj->m_PK_Level > 3)

  001ba	7e 22		 jle	 SHORT $LN25@gObjPlayer

; 4893 : 	{
; 4894 : 		if(lpTargetObj->m_PK_Level <= 4)

  001bc	80 bf fd 00 00
	00 04		 cmp	 BYTE PTR [edi+253], 4
  001c3	0f 8f 22 01 00
	00		 jg	 $LN60@gObjPlayer

; 4895 : 		{
; 4896 : 			lpObj->m_PK_Count++;

  001c9	02 c3		 add	 al, bl
  001cb	88 86 fc 00 00
	00		 mov	 BYTE PTR [esi+252], al

; 4897 : 			if(lpObj->m_PK_Count > 100)

  001d1	3c 64		 cmp	 al, 100			; 00000064H
  001d3	7e 61		 jle	 SHORT $LN11@gObjPlayer

; 4898 : 			{
; 4899 : 				lpObj->m_PK_Count = 100;

  001d5	c6 86 fc 00 00
	00 64		 mov	 BYTE PTR [esi+252], 100	; 00000064H

; 4900 : 			}
; 4901 : 		}
; 4902 : 		else
; 4903 : 		{
; 4904 : 			return;
; 4905 : 		}

  001dc	eb 58		 jmp	 SHORT $LN11@gObjPlayer
$LN25@gObjPlayer:

; 4906 : 	}
; 4907 : 	else if( lpObj->m_PK_Level < 3)

  001de	80 f9 03	 cmp	 cl, 3
  001e1	7d 53		 jge	 SHORT $LN11@gObjPlayer

; 4908 : 	{
; 4909 : 		if(lpTargetObj->m_PK_Level == 3)

  001e3	8a 8f fd 00 00
	00		 mov	 cl, BYTE PTR [edi+253]
  001e9	80 f9 03	 cmp	 cl, 3
  001ec	75 08		 jne	 SHORT $LN63@gObjPlayer

; 4910 : 		{
; 4911 : 			lpObj->m_PK_Count = 1;

  001ee	88 9e fc 00 00
	00		 mov	 BYTE PTR [esi+252], bl
  001f4	eb 40		 jmp	 SHORT $LN11@gObjPlayer
$LN63@gObjPlayer:

; 4912 : 		}
; 4913 : 		else if(lpTargetObj->m_PK_Level < 3)

  001f6	7d 08		 jge	 SHORT $LN17@gObjPlayer

; 4914 : 		{
; 4915 : 			lpObj->m_PK_Count = 1;

  001f8	88 9e fc 00 00
	00		 mov	 BYTE PTR [esi+252], bl
  001fe	eb 36		 jmp	 SHORT $LN11@gObjPlayer
$LN17@gObjPlayer:

; 4916 : 		}
; 4917 : 		else if(lpTargetObj->m_PK_Level == 4)

  00200	80 f9 04	 cmp	 cl, 4
  00203	75 08		 jne	 SHORT $LN15@gObjPlayer

; 4918 : 		{
; 4919 : 			lpObj->m_PK_Count = 1;

  00205	88 9e fc 00 00
	00		 mov	 BYTE PTR [esi+252], bl

; 4920 : 		}
; 4921 : 		else

  0020b	eb 29		 jmp	 SHORT $LN11@gObjPlayer
$LN15@gObjPlayer:

; 4922 : 		{
; 4923 : 			if(lpTargetObj->m_PK_Level >= 6 && lpTargetObj->Level > 20)

  0020d	80 f9 06	 cmp	 cl, 6
  00210	0f 8c d5 00 00
	00		 jl	 $LN60@gObjPlayer
  00216	66 83 bf 9c 00
	00 00 14	 cmp	 WORD PTR [edi+156], 20	; 00000014H
  0021e	0f 8e c7 00 00
	00		 jle	 $LN60@gObjPlayer

; 4924 : 			{
; 4925 : 				lpObj->m_PK_Count--;

  00224	2a c3		 sub	 al, bl
  00226	88 86 fc 00 00
	00		 mov	 BYTE PTR [esi+252], al

; 4926 : 
; 4927 : 				if(lpObj->m_PK_Count < -3)

  0022c	3a c2		 cmp	 al, dl
  0022e	7d 06		 jge	 SHORT $LN11@gObjPlayer

; 4928 : 				{
; 4929 : 					lpObj->m_PK_Count = (BYTE)-3;

  00230	88 96 fc 00 00
	00		 mov	 BYTE PTR [esi+252], dl
$LN11@gObjPlayer:

; 4930 : 				}
; 4931 : 			}
; 4932 : 			else
; 4933 : 			{
; 4934 : 				return;
; 4935 : 			}
; 4936 : 		}
; 4937 : 	}
; 4938 : 
; 4939 : 	if(lpObj->m_PK_Count == 0)

  00236	8a 86 fc 00 00
	00		 mov	 al, BYTE PTR [esi+252]
  0023c	84 c0		 test	 al, al
  0023e	75 09		 jne	 SHORT $LN10@gObjPlayer

; 4940 : 	{
; 4941 : 		lpObj->m_PK_Level = 3;

  00240	c6 86 fd 00 00
	00 03		 mov	 BYTE PTR [esi+253], 3

; 4942 : 		lpObj->m_PK_Time = 0;

  00247	eb 31		 jmp	 SHORT $LN64@gObjPlayer
$LN10@gObjPlayer:

; 4943 : 	}
; 4944 : 	else if(lpObj->m_PK_Count == 1)

  00249	3a c3		 cmp	 al, bl
  0024b	75 09		 jne	 SHORT $LN8@gObjPlayer

; 4945 : 	{
; 4946 : 		lpObj->m_PK_Level = 4;

  0024d	c6 86 fd 00 00
	00 04		 mov	 BYTE PTR [esi+253], 4

; 4947 : 		lpObj->m_PK_Time = 0;

  00254	eb 24		 jmp	 SHORT $LN64@gObjPlayer
$LN8@gObjPlayer:

; 4948 : 	}
; 4949 : 	else if(lpObj->m_PK_Count == 2)

  00256	3c 02		 cmp	 al, 2
  00258	75 09		 jne	 SHORT $LN6@gObjPlayer

; 4950 : 	{
; 4951 : 		lpObj->m_PK_Level = 5;

  0025a	c6 86 fd 00 00
	00 05		 mov	 BYTE PTR [esi+253], 5

; 4952 : 		lpObj->m_PK_Time = 0;

  00261	eb 17		 jmp	 SHORT $LN64@gObjPlayer
$LN6@gObjPlayer:

; 4953 : 	}
; 4954 : 	else if(lpObj->m_PK_Count >= 3)

  00263	3c 03		 cmp	 al, 3
  00265	7c 09		 jl	 SHORT $LN4@gObjPlayer

; 4955 : 	{
; 4956 : 		lpObj->m_PK_Level = 6;

  00267	c6 86 fd 00 00
	00 06		 mov	 BYTE PTR [esi+253], 6

; 4957 : 		lpObj->m_PK_Time = 0;

  0026e	eb 0a		 jmp	 SHORT $LN64@gObjPlayer
$LN4@gObjPlayer:

; 4958 : 	}
; 4959 : 	else if(lpObj->m_PK_Count <= -3)

  00270	3a c2		 cmp	 al, dl
  00272	7f 10		 jg	 SHORT $LN59@gObjPlayer

; 4960 : 	{
; 4961 : 		lpObj->m_PK_Level = 1;

  00274	88 9e fd 00 00
	00		 mov	 BYTE PTR [esi+253], bl
$LN64@gObjPlayer:

; 4962 : 		lpObj->m_PK_Time = 0;

  0027a	c7 86 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+256], 0
$LN59@gObjPlayer:

; 4963 : 	}
; 4964 : 	
; 4965 : 	GCPkLevelSend(lpObj->m_Index, lpObj->m_PK_Level);

  00284	0f b6 86 fd 00
	00 00		 movzx	 eax, BYTE PTR [esi+253]
  0028b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0028d	50		 push	 eax
  0028e	51		 push	 ecx
  0028f	e8 00 00 00 00	 call	 ?GCPkLevelSend@@YAXHE@Z	; GCPkLevelSend
  00294	83 c4 08	 add	 esp, 8

; 4966 : 
; 4967 : 	if ( lpObj->m_PK_Level == 4 )

  00297	80 be fd 00 00
	00 04		 cmp	 BYTE PTR [esi+253], 4
  0029e	75 1c		 jne	 SHORT $LN1@gObjPlayer

; 4968 : 	{
; 4969 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 113)), lpObj->m_Index, 1);

  002a0	8b 16		 mov	 edx, DWORD PTR [esi]
  002a2	53		 push	 ebx
  002a3	52		 push	 edx
  002a4	68 71 04 00 00	 push	 1137			; 00000471H
  002a9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002ae	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  002b3	50		 push	 eax
  002b4	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  002b9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjPlayer:

; 4970 : 	}
; 4971 : 
; 4972 : 	LogAdd(LOG_BLACK, "[%s][%s] PK Info Set (Killed Player) Origin(PkLevel:%d, PkCount:%d) Changed(PkLevel:%d, PkCount:%d)",
; 4973 : 		lpObj->AccountID, lpObj->Name, iOriginPkLevel, iOriginPkCount, lpObj->m_PK_Level, lpObj->m_PK_Count);

  002bc	0f be 86 fc 00
	00 00		 movsx	 eax, BYTE PTR [esi+252]
  002c3	0f be 8e fd 00
	00 00		 movsx	 ecx, BYTE PTR [esi+253]
  002ca	8b 55 08	 mov	 edx, DWORD PTR _iOriginPkCount$[ebp]
  002cd	50		 push	 eax
  002ce	8b 45 fc	 mov	 eax, DWORD PTR _iOriginPkLevel$[ebp]
  002d1	51		 push	 ecx
  002d2	52		 push	 edx
  002d3	50		 push	 eax
  002d4	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  002d7	51		 push	 ecx
  002d8	83 c6 64	 add	 esi, 100		; 00000064H
  002db	56		 push	 esi
  002dc	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@HFNAODDP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5PK?5Info?5Set?5?$CIKilled?5Pla@
  002e1	6a 00		 push	 0
  002e3	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  002e8	83 c4 20	 add	 esp, 32			; 00000020H
$LN60@gObjPlayer:
  002eb	5f		 pop	 edi
$LN43@gObjPlayer:
  002ec	5e		 pop	 esi
  002ed	5b		 pop	 ebx

; 4974 : 	
; 4975 : 
; 4976 : }

  002ee	8b e5		 mov	 esp, ebp
  002f0	5d		 pop	 ebp
  002f1	c3		 ret	 0
?gObjPlayerKiller@@YAXPAUOBJECTSTRUCT@@0@Z ENDP		; gObjPlayerKiller
_TEXT	ENDS
PUBLIC	??_C@_0CK@PAJOKIHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Death?5reduces?5Experienc@ ; `string'
PUBLIC	??_C@_0CJ@CKMJEEKH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5User?5Die?5Item?5Drop?0?5Ite@ ; `string'
PUBLIC	??_C@_0GL@DJDDMNFC@Killed?5by?5User?5State?5Victim?3?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0EG@HIGLADFI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIPkLevel?5?$DN?5?$CFd?$CJ?5Killed?5?$FL@ ; `string'
PUBLIC	??_C@_0CI@JFDMHJOK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Killed?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pos?3?$CI?$CFd@ ; `string'
PUBLIC	??_C@_07GOHPBKOH@Monster?$AA@			; `string'
PUBLIC	??_C@_0EM@NNNAIELC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Bloo@ ; `string'
PUBLIC	??_C@_0EJ@EGIDAPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Bloo@ ; `string'
PUBLIC	??_C@_0DL@COJKOION@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5delet@ ; `string'
PUBLIC	??_C@_0DJ@HJPHEOFL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5drop?5@ ; `string'
PUBLIC	??_C@_0CP@MMNCCLML@?$FLDevilSquare?$FN?5Dead?5In?5DevilSquar@ ; `string'
PUBLIC	?gObjUserDie@@YAXPAUOBJECTSTRUCT@@0@Z		; gObjUserDie
EXTRN	?GDSetWarehouseMoney@@YAXH@Z:PROC		; GDSetWarehouseMoney
EXTRN	?GCSendDuelScore@@YAXHH@Z:PROC			; GCSendDuelScore
EXTRN	?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z:PROC ; CGItemDropRequest
EXTRN	?gPkItemDrop@@3HA:DWORD				; gPkItemDrop
EXTRN	?gPkLimitFree@@3HA:DWORD			; gPkLimitFree
EXTRN	?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z:PROC ; CBloodCastle::SearchUserDeleteQuestItem
EXTRN	?GetCurrentState@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetCurrentState
EXTRN	?SetUserState@CBloodCastle@@QAEXHH@Z:PROC	; CBloodCastle::SetUserState
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
EXTRN	?RemoveAllCharacterInvalidMagicAndSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CObjUseSkill::RemoveAllCharacterInvalidMagicAndSkillState
;	COMDAT ??_C@_0CK@PAJOKIHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Death?5reduces?5Experienc@
CONST	SEGMENT
??_C@_0CK@PAJOKIHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Death?5reduces?5Experienc@ DB '['
	DB	'%s][%s] Death reduces Experience %u - %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CKMJEEKH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5User?5Die?5Item?5Drop?0?5Ite@
CONST	SEGMENT
??_C@_0CJ@CKMJEEKH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5User?5Die?5Item?5Drop?0?5Ite@ DB '['
	DB	'%s][%s] User Die Item Drop, ItemName:%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@DJDDMNFC@Killed?5by?5User?5State?5Victim?3?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0GL@DJDDMNFC@Killed?5by?5User?5State?5Victim?3?$FL?$CFs?$FN@ DB 'Ki'
	DB	'lled by User State Victim:[%s][%s], Murderer:[%s][%s], Dead S'
	DB	'tate (Duel:%d, GuildWar:%d, SeldDefense:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@HIGLADFI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIPkLevel?5?$DN?5?$CFd?$CJ?5Killed?5?$FL@
CONST	SEGMENT
??_C@_0EG@HIGLADFI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIPkLevel?5?$DN?5?$CFd?$CJ?5Killed?5?$FL@ DB '['
	DB	'%s][%s] (PkLevel = %d) Killed [%s][%s] (PkLevel = %d) Pos:(%d'
	DB	',%d,%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JFDMHJOK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Killed?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pos?3?$CI?$CFd@
CONST	SEGMENT
??_C@_0CI@JFDMHJOK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Killed?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pos?3?$CI?$CFd@ DB '['
	DB	'%s][%s] Killed [%s][%s] Pos:(%d,%d,%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOHPBKOH@Monster?$AA@
CONST	SEGMENT
??_C@_07GOHPBKOH@Monster?$AA@ DB 'Monster', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@NNNAIELC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Bloo@
CONST	SEGMENT
??_C@_0EM@NNNAIELC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Bloo@ DB '['
	DB	'Blood Castle] (%d) Dead In Blood Castle, Killed by Other User'
	DB	' [%s][%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@EGIDAPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Bloo@
CONST	SEGMENT
??_C@_0EJ@EGIDAPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Bloo@ DB '['
	DB	'Blood Castle] (%d) Dead In Blood Castle, Killed by Monster [%'
	DB	's][%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@COJKOION@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5delet@
CONST	SEGMENT
??_C@_0DL@COJKOION@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5delet@ DB '['
	DB	'Blood Castle] (%d) Try to delete Ultimate Weapon [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HJPHEOFL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5drop?5@
CONST	SEGMENT
??_C@_0DJ@HJPHEOFL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5drop?5@ DB '['
	DB	'Blood Castle] (%d) Try to drop Ultimate Weapon [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MMNCCLML@?$FLDevilSquare?$FN?5Dead?5In?5DevilSquar@
CONST	SEGMENT
??_C@_0CP@MMNCCLML@?$FLDevilSquare?$FN?5Dead?5In?5DevilSquar@ DB '[DevilS'
	DB	'quare] Dead In DevilSquare [%s][%s][%s]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjUserDie@@YAXPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpMsg$163459 = -8					; size = 6
_lpMsg$163451 = -8					; size = 6
_minexp$ = 8						; size = 4
_count$ = 8						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjUserDie@@YAXPAUOBJECTSTRUCT@@0@Z PROC		; gObjUserDie, COMDAT

; 4979 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 4980 : 	int count = 76;
; 4981 : 	int itemdrop = 1;
; 4982 : 	int number = 0;
; 4983 : 	int dropresult = 0;
; 4984 : 
; 4985 : 	if(lpObj->Type != OBJ_USER)

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000a	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0000f	0f 85 6c 08 00
	00		 jne	 $LN97@gObjUserDi

; 4986 : 	{
; 4987 : 		return;
; 4988 : 	}
; 4989 : 
; 4990 : 	gObjSetKillCount(lpObj->m_Index,0);

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	53		 push	 ebx
  00018	57		 push	 edi
  00019	33 db		 xor	 ebx, ebx
  0001b	53		 push	 ebx
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount
  00022	83 c4 08	 add	 esp, 8

; 4991 : 
; 4992 : 	gObjUseSkill.RemoveAllCharacterInvalidMagicAndSkillState(lpObj);

  00025	56		 push	 esi
  00026	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0002b	e8 00 00 00 00	 call	 ?RemoveAllCharacterInvalidMagicAndSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@@Z ; CObjUseSkill::RemoveAllCharacterInvalidMagicAndSkillState

; 4993 : 
; 4994 : 	lpObj->m_iPotionBlessTime = 0;
; 4995 : 	lpObj->m_iPotionSoulTime = 0;
; 4996 : 
; 4997 : 	lpObj->m_ViewSkillState &= ~0x8000;
; 4998 : 	lpObj->m_ViewSkillState &= 0xFFFEFFFF;
; 4999 : 
; 5000 : 	if(gObjTargetGuildWarCheck(lpObj,lpTargetObj) == 1)

  00030	8b 7d 0c	 mov	 edi, DWORD PTR _lpTargetObj$[ebp]
  00033	81 a6 c4 01 00
	00 ff 7f fe ff	 and	 DWORD PTR [esi+452], -98305 ; fffe7fffH
  0003d	57		 push	 edi
  0003e	56		 push	 esi
  0003f	89 9e f4 14 00
	00		 mov	 DWORD PTR [esi+5364], ebx
  00045	89 9e f8 14 00
	00		 mov	 DWORD PTR [esi+5368], ebx
  0004b	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00050	83 c4 08	 add	 esp, 8
  00053	83 f8 01	 cmp	 eax, 1
  00056	0f 84 23 08 00
	00		 je	 $LN132@gObjUserDi

; 5001 : 	{
; 5002 : 		return;
; 5003 : 	}
; 5004 : 
; 5005 : 	if(DS_MAP_RANGE(lpObj->MapNumber))

  0005c	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00062	3c 09		 cmp	 al, 9
  00064	74 0b		 je	 SHORT $LN128@gObjUserDi
  00066	33 c9		 xor	 ecx, ecx
  00068	3c 20		 cmp	 al, 32			; 00000020H
  0006a	0f 94 c1	 sete	 cl
  0006d	3b cb		 cmp	 ecx, ebx
  0006f	74 46		 je	 SHORT $LN110@gObjUserDi
$LN128@gObjUserDi:

; 5006 : 	{
; 5007 : 		if(lpTargetObj->Type == OBJ_MONSTER)

  00071	66 83 7f 60 02	 cmp	 WORD PTR [edi+96], 2
  00076	0f 85 03 08 00
	00		 jne	 $LN132@gObjUserDi

; 5008 : 		{
; 5009 : 			LPMONSTER_ATTRIBUTE mAttr = gMAttr.GetAttr(lpTargetObj->Class);

  0007c	0f b7 8f 98 00
	00 00		 movzx	 ecx, WORD PTR [edi+152]
  00083	51		 push	 ecx
  00084	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00089	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr

; 5010 : 
; 5011 : 			if(mAttr != 0)

  0008e	3b c3		 cmp	 eax, ebx
  00090	0f 84 e9 07 00
	00		 je	 $LN132@gObjUserDi

; 5012 : 			{
; 5013 : 				LogAdd(LOG_BLACK, "[DevilSquare] Dead In DevilSquare [%s][%s][%s]",lpObj->AccountID,lpObj->Name,mAttr->m_Name);

  00096	83 c0 08	 add	 eax, 8
  00099	50		 push	 eax
  0009a	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  0009d	52		 push	 edx
  0009e	83 c6 64	 add	 esi, 100		; 00000064H
  000a1	56		 push	 esi
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@MMNCCLML@?$FLDevilSquare?$FN?5Dead?5In?5DevilSquar@
  000a7	53		 push	 ebx
  000a8	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000ad	83 c4 14	 add	 esp, 20			; 00000014H
  000b0	5f		 pop	 edi
  000b1	5b		 pop	 ebx
  000b2	5e		 pop	 esi

; 5387 : }

  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
$LN110@gObjUserDi:

; 5014 : 			}
; 5015 : 		}
; 5016 : 
; 5017 : 		return;
; 5018 : 	}
; 5019 : 	
; 5020 : 	if(BC_MAP_RANGE(lpObj->MapNumber))

  000b7	3c 0b		 cmp	 al, 11			; 0000000bH
  000b9	0f 82 2d 01 00
	00		 jb	 $LN107@gObjUserDi
  000bf	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  000c4	3a c8		 cmp	 cl, al
  000c6	1b c9		 sbb	 ecx, ecx
  000c8	41		 inc	 ecx
  000c9	3b cb		 cmp	 ecx, ebx
  000cb	0f 84 1b 01 00
	00		 je	 $LN107@gObjUserDi

; 5021 : 	{
; 5022 : 		g_BloodCastle.SetUserState(lpObj->m_Index,1);

  000d1	8b 16		 mov	 edx, DWORD PTR [esi]
  000d3	6a 01		 push	 1
  000d5	52		 push	 edx
  000d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  000db	e8 00 00 00 00	 call	 ?SetUserState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetUserState

; 5023 : 		if(g_BloodCastle.GetCurrentState(lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1) == BC_STATE_PLAYING)

  000e0	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  000e7	83 e8 0b	 sub	 eax, 11			; 0000000bH
  000ea	50		 push	 eax
  000eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  000f0	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState

; 5024 : 		{
; 5025 : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) Try to drop Ultimate Weapon [%s][%s]",lpObj->MapNumber - (MAP_INDEX_BLOODCASTLE1-1),lpObj->AccountID,lpObj->Name);

  000f5	8d 5e 6f	 lea	 ebx, DWORD PTR [esi+111]
  000f8	83 f8 02	 cmp	 eax, 2
  000fb	53		 push	 ebx
  000fc	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  000ff	50		 push	 eax
  00100	75 29		 jne	 SHORT $LN106@gObjUserDi
  00102	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00109	83 e9 0a	 sub	 ecx, 10			; 0000000aH
  0010c	51		 push	 ecx
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@HJPHEOFL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5drop?5@
  00112	6a 00		 push	 0
  00114	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 5026 : 			g_BloodCastle.SearchUserDropQuestItem(lpObj->m_Index);

  00119	8b 16		 mov	 edx, DWORD PTR [esi]
  0011b	83 c4 14	 add	 esp, 20			; 00000014H
  0011e	52		 push	 edx
  0011f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00124	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem

; 5027 : 		}
; 5028 : 		else

  00129	eb 27		 jmp	 SHORT $LN105@gObjUserDi
$LN106@gObjUserDi:

; 5029 : 		{
; 5030 : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) Try to delete Ultimate Weapon [%s][%s]",lpObj->MapNumber - (MAP_INDEX_BLOODCASTLE1-1),lpObj->AccountID,lpObj->Name);

  0012b	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00132	83 e8 0a	 sub	 eax, 10			; 0000000aH
  00135	50		 push	 eax
  00136	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@COJKOION@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5delet@
  0013b	6a 00		 push	 0
  0013d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 5031 : 			g_BloodCastle.SearchUserDeleteQuestItem(lpObj->m_Index);

  00142	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00144	83 c4 14	 add	 esp, 20			; 00000014H
  00147	51		 push	 ecx
  00148	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0014d	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN105@gObjUserDi:

; 5032 : 		}
; 5033 : 
; 5034 : 		if(lpTargetObj->Type == OBJ_MONSTER)

  00152	0f b7 47 60	 movzx	 eax, WORD PTR [edi+96]
  00156	83 f8 02	 cmp	 eax, 2
  00159	75 51		 jne	 SHORT $LN104@gObjUserDi

; 5035 : 		{
; 5036 : 			LPMONSTER_ATTRIBUTE mAttr = gMAttr.GetAttr(lpTargetObj->Class);

  0015b	0f b7 97 98 00
	00 00		 movzx	 edx, WORD PTR [edi+152]
  00162	52		 push	 edx
  00163	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00168	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr

; 5037 : 
; 5038 : 			if(mAttr != 0)

  0016d	85 c0		 test	 eax, eax
  0016f	0f 84 0a 07 00
	00		 je	 $LN132@gObjUserDi

; 5039 : 			{
; 5040 : 				LogAdd(LOG_BLACK, "[Blood Castle] (%d) Dead In Blood Castle, Killed by Monster [%s][%s][%s]",lpObj->MapNumber - (MAP_INDEX_BLOODCASTLE1-1),lpObj->AccountID,lpObj->Name,mAttr->m_Name);

  00175	83 c0 08	 add	 eax, 8
  00178	50		 push	 eax
  00179	53		 push	 ebx
  0017a	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  0017d	50		 push	 eax
  0017e	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00185	83 e8 0a	 sub	 eax, 10			; 0000000aH
  00188	50		 push	 eax
  00189	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@EGIDAPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Bloo@
  0018e	6a 00		 push	 0
  00190	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 5041 : 				g_BloodCastle.SearchUserDropQuestItem(lpObj->m_Index);

  00195	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00197	83 c4 18	 add	 esp, 24			; 00000018H
  0019a	51		 push	 ecx
  0019b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001a0	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem
  001a5	5f		 pop	 edi
  001a6	5b		 pop	 ebx
  001a7	5e		 pop	 esi

; 5387 : }

  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c3		 ret	 0
$LN104@gObjUserDi:

; 5042 : 			}
; 5043 : 		}
; 5044 : 		else if(lpTargetObj->Type == OBJ_USER)

  001ac	83 f8 01	 cmp	 eax, 1
  001af	0f 85 ca 06 00
	00		 jne	 $LN132@gObjUserDi

; 5045 : 		{
; 5046 : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) Dead In Blood Castle, Killed by Other User [%s][%s][%s]",lpObj->MapNumber - (MAP_INDEX_BLOODCASTLE1-1),lpObj->AccountID,lpObj->Name,lpTargetObj->Name);

  001b5	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR [esi+265]
  001bc	83 c7 6f	 add	 edi, 111		; 0000006fH
  001bf	57		 push	 edi
  001c0	53		 push	 ebx
  001c1	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  001c4	50		 push	 eax
  001c5	83 ea 0a	 sub	 edx, 10			; 0000000aH
  001c8	52		 push	 edx
  001c9	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@NNNAIELC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Bloo@
  001ce	6a 00		 push	 0
  001d0	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 5047 : 			g_BloodCastle.SearchUserDropQuestItem(lpObj->m_Index);

  001d5	8b 06		 mov	 eax, DWORD PTR [esi]
  001d7	83 c4 18	 add	 esp, 24			; 00000018H
  001da	50		 push	 eax
  001db	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001e0	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem
  001e5	5f		 pop	 edi
  001e6	5b		 pop	 ebx
  001e7	5e		 pop	 esi

; 5387 : }

  001e8	8b e5		 mov	 esp, ebp
  001ea	5d		 pop	 ebp
  001eb	c3		 ret	 0
$LN107@gObjUserDi:

; 5048 : 		}
; 5049 : 		return;
; 5050 : 	}
; 5051 : 	else if(CC_MAP_RANGE(lpObj->MapNumber))

  001ec	3c 12		 cmp	 al, 18			; 00000012H
  001ee	72 12		 jb	 SHORT $LN129@gObjUserDi
  001f0	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  001f5	3a c8		 cmp	 cl, al
  001f7	1b c9		 sbb	 ecx, ecx
  001f9	41		 inc	 ecx
  001fa	3b cb		 cmp	 ecx, ebx
  001fc	0f 85 7d 06 00
	00		 jne	 $LN132@gObjUserDi
$LN129@gObjUserDi:

; 5052 : 	{
; 5053 : 		return;
; 5054 : 	}
; 5055 : 
; 5056 : #if GS_CASTLE == 1
; 5057 : 	if ( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE &&
; 5058 : 		 lpObj->MapNumber == MAP_INDEX_CASTLESIEGE )
; 5059 : 	{
; 5060 : 		return;
; 5061 : 	}
; 5062 : #endif
; 5063 : 
; 5064 : 	if((lpObj->Authority & 0x10) || (lpTargetObj->Authority & 0x10))

  00202	b1 10		 mov	 cl, 16			; 00000010H
  00204	84 8e a4 01 00
	00		 test	 BYTE PTR [esi+420], cl
  0020a	0f 85 6f 06 00
	00		 jne	 $LN132@gObjUserDi
  00210	84 8f a4 01 00
	00		 test	 BYTE PTR [edi+420], cl
  00216	0f 85 63 06 00
	00		 jne	 $LN132@gObjUserDi

; 5065 : 	{
; 5066 : 		return;
; 5067 : 	}
; 5068 : 
; 5069 : 	if(lpTargetObj->Type == OBJ_MONSTER)

  0021c	66 83 7f 60 02	 cmp	 WORD PTR [edi+96], 2

; 5070 : 	{
; 5071 : 		LogAdd(LOG_BLACK, "[%s][%s] Killed [%s][%s] Pos:(%d,%d,%d)","Monster",lpTargetObj->Name,lpObj->AccountID,lpObj->Name,lpObj->MapNumber,lpObj->X,lpObj->Y);

  00221	0f b6 c0	 movzx	 eax, al
  00224	75 2c		 jne	 SHORT $LN96@gObjUserDi
  00226	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]
  0022d	53		 push	 ebx
  0022e	0f bf 9e 04 01
	00 00		 movsx	 ebx, WORD PTR [esi+260]
  00235	53		 push	 ebx
  00236	50		 push	 eax
  00237	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  0023a	51		 push	 ecx
  0023b	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  0023e	52		 push	 edx
  0023f	8d 4f 6f	 lea	 ecx, DWORD PTR [edi+111]
  00242	51		 push	 ecx
  00243	68 00 00 00 00	 push	 OFFSET ??_C@_07GOHPBKOH@Monster?$AA@
  00248	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@JFDMHJOK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Killed?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pos?3?$CI?$CFd@

; 5072 : 	}
; 5073 : 	else

  0024d	e9 8a 00 00 00	 jmp	 $LN146@gObjUserDi
$LN96@gObjUserDi:

; 5074 : 	{
; 5075 : 		LogAdd(LOG_BLACK, "[%s][%s] (PkLevel = %d) Killed [%s][%s] (PkLevel = %d) Pos:(%d,%d,%d)",lpTargetObj->AccountID,lpTargetObj->Name,lpTargetObj->m_PK_Level,lpObj->AccountID,lpObj->Name,lpObj->m_PK_Level,lpObj->MapNumber,lpObj->X,lpObj->Y);

  00252	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  00259	52		 push	 edx
  0025a	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  00261	52		 push	 edx
  00262	0f be 96 fd 00
	00 00		 movsx	 edx, BYTE PTR [esi+253]
  00269	50		 push	 eax
  0026a	0f be 87 fd 00
	00 00		 movsx	 eax, BYTE PTR [edi+253]
  00271	52		 push	 edx
  00272	8d 5e 6f	 lea	 ebx, DWORD PTR [esi+111]
  00275	53		 push	 ebx
  00276	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  00279	51		 push	 ecx
  0027a	50		 push	 eax
  0027b	8d 47 6f	 lea	 eax, DWORD PTR [edi+111]
  0027e	50		 push	 eax
  0027f	8d 47 64	 lea	 eax, DWORD PTR [edi+100]
  00282	50		 push	 eax
  00283	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@HIGLADFI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIPkLevel?5?$DN?5?$CFd?$CJ?5Killed?5?$FL@
  00288	6a 00		 push	 0
  0028a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 5076 : 		LogAdd(LOG_BLACK, "Killed by User State Victim:[%s][%s], Murderer:[%s][%s], Dead State (Duel:%d, GuildWar:%d, SeldDefense:%d)",lpObj->AccountID,lpObj->Name,lpTargetObj->AccountID,lpTargetObj->Name,!!IsOnDuel(lpTargetObj->m_Index,lpObj->m_Index),!!gObjTargetGuildWarCheck(lpObj,lpTargetObj),!!gObjIsSelfDefense(lpTargetObj,lpObj->m_Index));

  0028f	8b 06		 mov	 eax, DWORD PTR [esi]
  00291	50		 push	 eax
  00292	57		 push	 edi
  00293	e8 00 00 00 00	 call	 ?gObjIsSelfDefense@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjIsSelfDefense
  00298	83 c4 34	 add	 esp, 52			; 00000034H
  0029b	33 c9		 xor	 ecx, ecx
  0029d	84 c0		 test	 al, al
  0029f	0f 95 c1	 setne	 cl
  002a2	51		 push	 ecx
  002a3	57		 push	 edi
  002a4	56		 push	 esi
  002a5	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  002aa	8b 17		 mov	 edx, DWORD PTR [edi]
  002ac	83 c4 08	 add	 esp, 8
  002af	f7 d8		 neg	 eax
  002b1	1b c0		 sbb	 eax, eax
  002b3	f7 d8		 neg	 eax
  002b5	50		 push	 eax
  002b6	8b 06		 mov	 eax, DWORD PTR [esi]
  002b8	50		 push	 eax
  002b9	52		 push	 edx
  002ba	e8 00 00 00 00	 call	 ?IsOnDuel@@YA_NHH@Z	; IsOnDuel
  002bf	83 c4 08	 add	 esp, 8
  002c2	33 c9		 xor	 ecx, ecx
  002c4	84 c0		 test	 al, al
  002c6	0f 95 c1	 setne	 cl
  002c9	8d 47 6f	 lea	 eax, DWORD PTR [edi+111]
  002cc	51		 push	 ecx
  002cd	50		 push	 eax
  002ce	8d 47 64	 lea	 eax, DWORD PTR [edi+100]
  002d1	50		 push	 eax
  002d2	53		 push	 ebx
  002d3	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  002d6	50		 push	 eax
  002d7	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@DJDDMNFC@Killed?5by?5User?5State?5Victim?3?$FL?$CFs?$FN@
$LN146@gObjUserDi:
  002dc	6a 00		 push	 0
  002de	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 5077 : 	}
; 5078 : 
; 5079 : 	if(gPkLimitFree == 0)
; 5080 : 	{
; 5081 : 		if(lpObj->m_PK_Level == 2)

  002e3	8a 86 fd 00 00
	00		 mov	 al, BYTE PTR [esi+253]
  002e9	83 c4 24	 add	 esp, 36			; 00000024H
  002ec	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  002f3	0f 85 a0 00 00
	00		 jne	 $LN94@gObjUserDi
  002f9	3c 02		 cmp	 al, 2
  002fb	75 1c		 jne	 SHORT $LN93@gObjUserDi

; 5082 : 		{
; 5083 : 			itemdrop = rand()%32;

  002fd	e8 00 00 00 00	 call	 _rand
  00302	8b d8		 mov	 ebx, eax
  00304	81 e3 1f 00 00
	80		 and	 ebx, -2147483617	; 8000001fH
  0030a	0f 89 21 01 00
	00		 jns	 $LN145@gObjUserDi
  00310	4b		 dec	 ebx
  00311	83 cb e0	 or	 ebx, -32		; ffffffe0H
  00314	e9 17 01 00 00	 jmp	 $LN147@gObjUserDi
$LN93@gObjUserDi:

; 5084 : 		}
; 5085 : 		else if(lpObj->m_PK_Level == 3)

  00319	3c 03		 cmp	 al, 3
  0031b	75 1c		 jne	 SHORT $LN91@gObjUserDi

; 5086 : 		{
; 5087 : 			itemdrop = rand()%16;

  0031d	e8 00 00 00 00	 call	 _rand
  00322	8b d8		 mov	 ebx, eax
  00324	81 e3 0f 00 00
	80		 and	 ebx, -2147483633	; 8000000fH
  0032a	0f 89 01 01 00
	00		 jns	 $LN145@gObjUserDi
  00330	4b		 dec	 ebx
  00331	83 cb f0	 or	 ebx, -16		; fffffff0H
  00334	e9 f7 00 00 00	 jmp	 $LN147@gObjUserDi
$LN91@gObjUserDi:

; 5088 : 		}
; 5089 : 		else if(lpObj->m_PK_Level == 4)

  00339	3c 04		 cmp	 al, 4
  0033b	75 1c		 jne	 SHORT $LN89@gObjUserDi

; 5090 : 		{
; 5091 : 			itemdrop = rand()%8;

  0033d	e8 00 00 00 00	 call	 _rand
  00342	8b d8		 mov	 ebx, eax
  00344	81 e3 07 00 00
	80		 and	 ebx, -2147483641	; 80000007H
  0034a	0f 89 e1 00 00
	00		 jns	 $LN145@gObjUserDi
  00350	4b		 dec	 ebx
  00351	83 cb f8	 or	 ebx, -8			; fffffff8H
  00354	e9 d7 00 00 00	 jmp	 $LN147@gObjUserDi
$LN89@gObjUserDi:

; 5092 : 		}
; 5093 : 		else if(lpObj->m_PK_Level == 5)

  00359	3c 05		 cmp	 al, 5
  0035b	75 1c		 jne	 SHORT $LN87@gObjUserDi

; 5094 : 		{
; 5095 : 			itemdrop = rand()%4;

  0035d	e8 00 00 00 00	 call	 _rand
  00362	8b d8		 mov	 ebx, eax
  00364	81 e3 03 00 00
	80		 and	 ebx, -2147483645	; 80000003H
  0036a	0f 89 c1 00 00
	00		 jns	 $LN145@gObjUserDi
  00370	4b		 dec	 ebx
  00371	83 cb fc	 or	 ebx, -4			; fffffffcH
  00374	e9 b7 00 00 00	 jmp	 $LN147@gObjUserDi
$LN87@gObjUserDi:

; 5096 : 		}
; 5097 : 		else if(lpObj->m_PK_Level >= 6)

  00379	3c 06		 cmp	 al, 6
  0037b	7c 3d		 jl	 SHORT $LN85@gObjUserDi

; 5098 : 		{
; 5099 : 			itemdrop = rand()%2;

  0037d	e8 00 00 00 00	 call	 _rand
  00382	8b d8		 mov	 ebx, eax
  00384	81 e3 01 00 00
	80		 and	 ebx, -2147483647	; 80000001H
  0038a	0f 89 a1 00 00
	00		 jns	 $LN145@gObjUserDi
  00390	4b		 dec	 ebx
  00391	83 cb fe	 or	 ebx, -2			; fffffffeH

; 5100 : 		}
; 5101 : 		else

  00394	e9 97 00 00 00	 jmp	 $LN147@gObjUserDi
$LN94@gObjUserDi:

; 5102 : 		{
; 5103 : 			itemdrop = rand()%64;
; 5104 : 		}
; 5105 : 	}
; 5106 : 	else
; 5107 : 	{
; 5108 : 		if(lpObj->m_PK_Level == 2)

  00399	3c 02		 cmp	 al, 2
  0039b	75 19		 jne	 SHORT $LN82@gObjUserDi

; 5109 : 		{
; 5110 : 			itemdrop = rand()%128;

  0039d	e8 00 00 00 00	 call	 _rand
  003a2	8b d8		 mov	 ebx, eax
  003a4	81 e3 7f 00 00
	80		 and	 ebx, -2147483521	; 8000007fH
  003aa	0f 89 81 00 00
	00		 jns	 $LN145@gObjUserDi
  003b0	4b		 dec	 ebx
  003b1	83 cb 80	 or	 ebx, -128		; ffffff80H
  003b4	eb 7a		 jmp	 SHORT $LN147@gObjUserDi
$LN82@gObjUserDi:

; 5111 : 		}
; 5112 : 		else if(lpObj->m_PK_Level == 3)

  003b6	3c 03		 cmp	 al, 3
  003b8	75 15		 jne	 SHORT $LN80@gObjUserDi
$LN85@gObjUserDi:

; 5113 : 		{
; 5114 : 			itemdrop = rand()%64;

  003ba	e8 00 00 00 00	 call	 _rand
  003bf	8b d8		 mov	 ebx, eax
  003c1	81 e3 3f 00 00
	80		 and	 ebx, -2147483585	; 8000003fH
  003c7	79 68		 jns	 SHORT $LN145@gObjUserDi
  003c9	4b		 dec	 ebx
  003ca	83 cb c0	 or	 ebx, -64		; ffffffc0H
  003cd	eb 61		 jmp	 SHORT $LN147@gObjUserDi
$LN80@gObjUserDi:

; 5115 : 		}
; 5116 : 		else if(lpObj->m_PK_Level == 4)

  003cf	3c 04		 cmp	 al, 4
  003d1	75 15		 jne	 SHORT $LN78@gObjUserDi

; 5117 : 		{
; 5118 : 			itemdrop = rand()%16;

  003d3	e8 00 00 00 00	 call	 _rand
  003d8	8b d8		 mov	 ebx, eax
  003da	81 e3 0f 00 00
	80		 and	 ebx, -2147483633	; 8000000fH
  003e0	79 4f		 jns	 SHORT $LN145@gObjUserDi
  003e2	4b		 dec	 ebx
  003e3	83 cb f0	 or	 ebx, -16		; fffffff0H
  003e6	eb 48		 jmp	 SHORT $LN147@gObjUserDi
$LN78@gObjUserDi:

; 5119 : 		}
; 5120 : 		else if(lpObj->m_PK_Level == 5)

  003e8	3c 05		 cmp	 al, 5
  003ea	75 15		 jne	 SHORT $LN76@gObjUserDi

; 5121 : 		{
; 5122 : 			itemdrop = rand()%4;

  003ec	e8 00 00 00 00	 call	 _rand
  003f1	8b d8		 mov	 ebx, eax
  003f3	81 e3 03 00 00
	80		 and	 ebx, -2147483645	; 80000003H
  003f9	79 36		 jns	 SHORT $LN145@gObjUserDi
  003fb	4b		 dec	 ebx
  003fc	83 cb fc	 or	 ebx, -4			; fffffffcH
  003ff	eb 2f		 jmp	 SHORT $LN147@gObjUserDi
$LN76@gObjUserDi:

; 5123 : 		}
; 5124 : 		else if(lpObj->m_PK_Level >= 6)

  00401	3c 06		 cmp	 al, 6
  00403	7c 15		 jl	 SHORT $LN74@gObjUserDi

; 5125 : 		{
; 5126 : 			itemdrop = rand()%2;

  00405	e8 00 00 00 00	 call	 _rand
  0040a	8b d8		 mov	 ebx, eax
  0040c	81 e3 01 00 00
	80		 and	 ebx, -2147483647	; 80000001H
  00412	79 1d		 jns	 SHORT $LN145@gObjUserDi
  00414	4b		 dec	 ebx
  00415	83 cb fe	 or	 ebx, -2			; fffffffeH

; 5127 : 		}
; 5128 : 		else

  00418	eb 16		 jmp	 SHORT $LN147@gObjUserDi
$LN74@gObjUserDi:

; 5129 : 		{
; 5130 : 			itemdrop = rand()%256;

  0041a	e8 00 00 00 00	 call	 _rand
  0041f	8b d8		 mov	 ebx, eax
  00421	81 e3 ff 00 00
	80		 and	 ebx, -2147483393	; 800000ffH
  00427	79 08		 jns	 SHORT $LN145@gObjUserDi
  00429	4b		 dec	 ebx
  0042a	81 cb 00 ff ff
	ff		 or	 ebx, -256		; ffffff00H
$LN147@gObjUserDi:
  00430	43		 inc	 ebx
$LN145@gObjUserDi:

; 5131 : 		}
; 5132 : 	}
; 5133 : 
; 5134 : 	if(gPkItemDrop == 0)

  00431	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkItemDrop@@3HA, 0 ; gPkItemDrop
  00438	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gPkLimitFree@@3HA ; gPkLimitFree
  0043d	75 16		 jne	 SHORT $LN131@gObjUserDi

; 5135 : 	{
; 5136 : 		if(lpTargetObj->m_PK_Level >= 4 && gPkLimitFree == 0)

  0043f	80 bf fd 00 00
	00 04		 cmp	 BYTE PTR [edi+253], 4
  00446	7c 0d		 jl	 SHORT $LN131@gObjUserDi
  00448	85 c0		 test	 eax, eax
  0044a	75 09		 jne	 SHORT $LN131@gObjUserDi

; 5137 : 		{
; 5138 : 			itemdrop = 1;

  0044c	b9 01 00 00 00	 mov	 ecx, 1
  00451	8b d9		 mov	 ebx, ecx
  00453	eb 05		 jmp	 SHORT $LN71@gObjUserDi
$LN131@gObjUserDi:
  00455	b9 01 00 00 00	 mov	 ecx, 1
$LN71@gObjUserDi:

; 5139 : 		}
; 5140 : 	}
; 5141 : 
; 5142 : 	if(gLanguage == 0)

  0045a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gLanguage@@3HA, 0 ; gLanguage
  00461	75 0c		 jne	 SHORT $LN69@gObjUserDi

; 5143 : 	{
; 5144 : 		if(lpTargetObj->Type == OBJ_USER && gPkLimitFree == 0)

  00463	66 39 4f 60	 cmp	 WORD PTR [edi+96], cx
  00467	75 06		 jne	 SHORT $LN69@gObjUserDi
  00469	85 c0		 test	 eax, eax
  0046b	75 02		 jne	 SHORT $LN69@gObjUserDi

; 5145 : 		{
; 5146 : 			itemdrop = 1;

  0046d	8b d9		 mov	 ebx, ecx
$LN69@gObjUserDi:

; 5147 : 		}
; 5148 : 	}
; 5149 : 
; 5150 : 	if(gObjCanItemTouch(lpObj,0)==0)

  0046f	6a 00		 push	 0
  00471	56		 push	 esi
  00472	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  00477	83 c4 08	 add	 esp, 8
  0047a	85 c0		 test	 eax, eax
  0047c	75 02		 jne	 SHORT $LN68@gObjUserDi

; 5151 : 	{
; 5152 : 		itemdrop = 1;

  0047e	8b d9		 mov	 ebx, ecx
$LN68@gObjUserDi:

; 5153 : 	}
; 5154 : 
; 5155 : 	if(lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_USER)

  00480	66 39 4e 60	 cmp	 WORD PTR [esi+96], cx
  00484	75 1c		 jne	 SHORT $LN66@gObjUserDi
  00486	66 39 4f 60	 cmp	 WORD PTR [edi+96], cx
  0048a	75 16		 jne	 SHORT $LN66@gObjUserDi

; 5156 : 	{
; 5157 : 		if(IsOnDuel(lpObj->m_Index,lpTargetObj->m_Index))

  0048c	8b 17		 mov	 edx, DWORD PTR [edi]
  0048e	8b 06		 mov	 eax, DWORD PTR [esi]
  00490	52		 push	 edx
  00491	50		 push	 eax
  00492	e8 00 00 00 00	 call	 ?IsOnDuel@@YA_NHH@Z	; IsOnDuel
  00497	83 c4 08	 add	 esp, 8
  0049a	84 c0		 test	 al, al

; 5158 : 		{
; 5159 : 			itemdrop = 1;
; 5160 : 		}
; 5161 : 	}
; 5162 : 
; 5163 : 	if(itemdrop == 0)

  0049c	0f 85 31 01 00
	00		 jne	 $LN127@gObjUserDi
$LN66@gObjUserDi:
  004a2	85 db		 test	 ebx, ebx
  004a4	0f 85 29 01 00
	00		 jne	 $LN127@gObjUserDi

; 5164 : 	{
; 5165 : 		if(lpObj->m_PK_Level >= 4)

  004aa	80 be fd 00 00
	00 04		 cmp	 BYTE PTR [esi+253], 4
  004b1	7c 60		 jl	 SHORT $LN130@gObjUserDi

; 5166 : 		{
; 5167 : 			count = 24;

  004b3	bf 18 00 00 00	 mov	 edi, 24			; 00000018H
$LL63@gObjUserDi:

; 5168 : 
; 5169 : 			while(count-- != 0)

  004b8	4f		 dec	 edi

; 5170 : 			{
; 5171 : 				number = rand()%12;

  004b9	e8 00 00 00 00	 call	 _rand
  004be	99		 cdq
  004bf	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  004c4	f7 f9		 idiv	 ecx
  004c6	8b da		 mov	 ebx, edx

; 5172 : 
; 5173 : 				if(lpObj->pInventory[number].IsItem()==1)

  004c8	8b cb		 mov	 ecx, ebx
  004ca	69 c9 a8 00 00
	00		 imul	 ecx, 168		; 000000a8H
  004d0	03 8e 8c 0c 00
	00		 add	 ecx, DWORD PTR [esi+3212]
  004d6	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  004db	83 f8 01	 cmp	 eax, 1
  004de	75 2f		 jne	 SHORT $LN60@gObjUserDi

; 5174 : 				{
; 5175 : 					PMSG_ITEMTHROW lpMsg;
; 5176 : 					lpMsg.Ipos = number;
; 5177 : 					lpMsg.px = lpObj->X;

  004e0	8a 96 04 01 00
	00		 mov	 dl, BYTE PTR [esi+260]

; 5178 : 					lpMsg.py = lpObj->Y;
; 5179 : 					if(CGItemDropRequest(&lpMsg,lpObj->m_Index,1)==1)

  004e6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  004e8	8a 86 06 01 00
	00		 mov	 al, BYTE PTR [esi+262]
  004ee	6a 01		 push	 1
  004f0	88 55 fb	 mov	 BYTE PTR _lpMsg$163451[ebp+3], dl
  004f3	51		 push	 ecx
  004f4	8d 55 f8	 lea	 edx, DWORD PTR _lpMsg$163451[ebp]
  004f7	52		 push	 edx
  004f8	88 5d fd	 mov	 BYTE PTR _lpMsg$163451[ebp+5], bl
  004fb	88 45 fc	 mov	 BYTE PTR _lpMsg$163451[ebp+4], al
  004fe	e8 00 00 00 00	 call	 ?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z ; CGItemDropRequest
  00503	83 c4 0c	 add	 esp, 12			; 0000000cH
  00506	83 f8 01	 cmp	 eax, 1
  00509	0f 84 c4 00 00
	00		 je	 $LN127@gObjUserDi
$LN60@gObjUserDi:

; 5168 : 
; 5169 : 			while(count-- != 0)

  0050f	85 ff		 test	 edi, edi
  00511	75 a5		 jne	 SHORT $LL63@gObjUserDi
$LN130@gObjUserDi:

; 5180 : 					{
; 5181 : 						dropresult = 1;
; 5182 : 						break;
; 5183 : 					}
; 5184 : 				}
; 5185 : 			}
; 5186 : 		}
; 5187 : 
; 5188 : 		if(dropresult == 0)
; 5189 : 		{
; 5190 : 			count = INVENTORY_MAP_SIZE;

  00513	c7 45 08 60 00
	00 00		 mov	 DWORD PTR _count$[ebp], 96 ; 00000060H
  0051a	8d 9b 00 00 00
	00		 npad	 6
$LL58@gObjUserDi:

; 5191 : 
; 5192 : 			while(count-- != 0)

  00520	ff 4d 08	 dec	 DWORD PTR _count$[ebp]

; 5193 : 			{
; 5194 : 				number = rand()%INVENTORY_MAP_SIZE + 12;

  00523	e8 00 00 00 00	 call	 _rand
  00528	99		 cdq
  00529	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  0052e	f7 f9		 idiv	 ecx

; 5195 : 
; 5196 : 				if(lpObj->pInventory[number].IsItem()==1)

  00530	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00536	8d 5a 0c	 lea	 ebx, DWORD PTR [edx+12]
  00539	8b fb		 mov	 edi, ebx
  0053b	69 ff a8 00 00
	00		 imul	 edi, 168		; 000000a8H
  00541	03 cf		 add	 ecx, edi
  00543	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00548	83 f8 01	 cmp	 eax, 1
  0054b	75 4f		 jne	 SHORT $LN54@gObjUserDi

; 5197 : 				{
; 5198 : 					if(lpObj->pInventory[number].m_Type >= ITEMGET(13,20) && (lpObj->pInventory[number].m_Level >= 1 && lpObj->pInventory[number].m_Level <= 2 ))

  0054d	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00553	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00556	b9 14 1a 00 00	 mov	 ecx, 6676		; 00001a14H
  0055b	66 39 48 06	 cmp	 WORD PTR [eax+6], cx
  0055f	7c 10		 jl	 SHORT $LN55@gObjUserDi
  00561	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00565	66 83 f8 01	 cmp	 ax, 1
  00569	7c 06		 jl	 SHORT $LN55@gObjUserDi
  0056b	66 83 f8 02	 cmp	 ax, 2
  0056f	7e 2b		 jle	 SHORT $LN54@gObjUserDi
$LN55@gObjUserDi:

; 5199 : 					{
; 5200 : 						continue;
; 5201 : 					}
; 5202 : 
; 5203 : 					PMSG_ITEMTHROW lpMsg;
; 5204 : 					lpMsg.Ipos = number;
; 5205 : 					lpMsg.px = lpObj->X;

  00571	8a 96 04 01 00
	00		 mov	 dl, BYTE PTR [esi+260]

; 5206 : 					lpMsg.py = lpObj->Y;
; 5207 : 
; 5208 : 					if(CGItemDropRequest(&lpMsg,lpObj->m_Index,1)==1)

  00577	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00579	8a 86 06 01 00
	00		 mov	 al, BYTE PTR [esi+262]
  0057f	6a 01		 push	 1
  00581	88 55 fb	 mov	 BYTE PTR _lpMsg$163459[ebp+3], dl
  00584	51		 push	 ecx
  00585	8d 55 f8	 lea	 edx, DWORD PTR _lpMsg$163459[ebp]
  00588	52		 push	 edx
  00589	88 5d fd	 mov	 BYTE PTR _lpMsg$163459[ebp+5], bl
  0058c	88 45 fc	 mov	 BYTE PTR _lpMsg$163459[ebp+4], al
  0058f	e8 00 00 00 00	 call	 ?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z ; CGItemDropRequest
  00594	83 c4 0c	 add	 esp, 12			; 0000000cH
  00597	83 f8 01	 cmp	 eax, 1
  0059a	74 0c		 je	 SHORT $LN125@gObjUserDi
$LN54@gObjUserDi:

; 5191 : 
; 5192 : 			while(count-- != 0)

  0059c	83 7d 08 00	 cmp	 DWORD PTR _count$[ebp], 0
  005a0	0f 85 7a ff ff
	ff		 jne	 $LL58@gObjUserDi

; 5206 : 					lpMsg.py = lpObj->Y;
; 5207 : 
; 5208 : 					if(CGItemDropRequest(&lpMsg,lpObj->m_Index,1)==1)

  005a6	eb 2b		 jmp	 SHORT $LN127@gObjUserDi
$LN125@gObjUserDi:

; 5209 : 					{
; 5210 : 						dropresult = 1;
; 5211 : 						LogAdd(LOG_BLACK, "[%s][%s] User Die Item Drop, ItemName:%s",lpObj->AccountID,lpObj->Name,lpObj->pInventory[number].GetName());

  005a8	8b cb		 mov	 ecx, ebx
  005aa	69 c9 a8 00 00
	00		 imul	 ecx, 168		; 000000a8H
  005b0	03 8e 8c 0c 00
	00		 add	 ecx, DWORD PTR [esi+3212]
  005b6	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  005bb	50		 push	 eax
  005bc	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  005bf	50		 push	 eax
  005c0	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  005c3	50		 push	 eax
  005c4	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@CKMJEEKH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5User?5Die?5Item?5Drop?0?5Ite@
  005c9	6a 00		 push	 0
  005cb	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  005d0	83 c4 14	 add	 esp, 20			; 00000014H
$LN127@gObjUserDi:

; 5212 : 						break;
; 5213 : 					}
; 5214 : 				}
; 5215 : 			}
; 5216 : 		}
; 5217 : 	}
; 5218 : 
; 5219 : 	if(lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_USER ) 

  005d3	bf 01 00 00 00	 mov	 edi, 1
  005d8	66 39 7e 60	 cmp	 WORD PTR [esi+96], di
  005dc	75 3a		 jne	 SHORT $LN53@gObjUserDi
  005de	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  005e1	66 39 78 60	 cmp	 WORD PTR [eax+96], di
  005e5	75 31		 jne	 SHORT $LN53@gObjUserDi

; 5220 : 	{
; 5221 : 		if ( IsOnDuel(lpObj->m_Index,lpTargetObj->m_Index) )

  005e7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  005e9	8b d8		 mov	 ebx, eax
  005eb	8b 3b		 mov	 edi, DWORD PTR [ebx]
  005ed	57		 push	 edi
  005ee	51		 push	 ecx
  005ef	e8 00 00 00 00	 call	 ?IsOnDuel@@YA_NHH@Z	; IsOnDuel
  005f4	83 c4 08	 add	 esp, 8
  005f7	84 c0		 test	 al, al
  005f9	0f 84 80 02 00
	00		 je	 $LN132@gObjUserDi

; 5222 : 		{
; 5223 : 			lpTargetObj->m_btDuelScore += 1;

  005ff	fe 83 20 0d 00
	00		 inc	 BYTE PTR [ebx+3360]

; 5224 : 			GCSendDuelScore(lpObj->m_Index,lpTargetObj->m_Index);

  00605	8b 16		 mov	 edx, DWORD PTR [esi]
  00607	57		 push	 edi
  00608	52		 push	 edx
  00609	e8 00 00 00 00	 call	 ?GCSendDuelScore@@YAXHH@Z ; GCSendDuelScore
  0060e	83 c4 08	 add	 esp, 8
  00611	5f		 pop	 edi
  00612	5b		 pop	 ebx
  00613	5e		 pop	 esi

; 5387 : }

  00614	8b e5		 mov	 esp, ebp
  00616	5d		 pop	 ebp
  00617	c3		 ret	 0
$LN53@gObjUserDi:

; 5225 : 		}
; 5226 : 		return;
; 5227 : 	}
; 5228 : 
; 5229 : 	DWORD minexp = gLevelExperience[-1 + lpObj->Level];

  00618	0f b7 8e 9c 00
	00 00		 movzx	 ecx, WORD PTR [esi+156]
  0061f	0f bf d1	 movsx	 edx, cx
  00622	8b 1c 95 fc ff
	ff ff		 mov	 ebx, DWORD PTR ?gLevelExperience@@3PAKA[edx*4-4]

; 5230 : 	DWORD maxexp = gLevelExperience[lpObj->Level];

  00629	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR ?gLevelExperience@@3PAKA[edx*4]
  00630	89 5d 08	 mov	 DWORD PTR _minexp$[ebp], ebx

; 5231 : 	DWORD subexp = 0;
; 5232 : 	DWORD decexp = 0;
; 5233 : 	DWORD decexprate = 0;
; 5234 : 
; 5235 : 	if(lpObj->Level <= 10)

  00633	66 83 f9 0a	 cmp	 cx, 10			; 0000000aH
  00637	7f 07		 jg	 SHORT $LN51@gObjUserDi

; 5236 : 	{
; 5237 : 		decexprate = 0;

  00639	33 c0		 xor	 eax, eax
  0063b	e9 e3 00 00 00	 jmp	 $LN17@gObjUserDi
$LN51@gObjUserDi:

; 5238 : 	}
; 5239 : 	else if(lpObj->Level <= 150)

  00640	b8 96 00 00 00	 mov	 eax, 150		; 00000096H
  00645	66 3b c8	 cmp	 cx, ax
  00648	7f 53		 jg	 SHORT $LN49@gObjUserDi

; 5240 : 	{
; 5241 : 		if(lpObj->m_PK_Level == 2)

  0064a	8a 86 fd 00 00
	00		 mov	 al, BYTE PTR [esi+253]
  00650	3c 02		 cmp	 al, 2
  00652	75 0a		 jne	 SHORT $LN48@gObjUserDi

; 5242 : 		{
; 5243 : 			decexprate = 2;

  00654	b8 02 00 00 00	 mov	 eax, 2
  00659	e9 c5 00 00 00	 jmp	 $LN17@gObjUserDi
$LN48@gObjUserDi:

; 5244 : 		}
; 5245 : 		else if(lpObj->m_PK_Level == 3)

  0065e	3c 03		 cmp	 al, 3
  00660	75 0a		 jne	 SHORT $LN46@gObjUserDi

; 5246 : 		{
; 5247 : 			decexprate = 3;

  00662	b8 03 00 00 00	 mov	 eax, 3
  00667	e9 b7 00 00 00	 jmp	 $LN17@gObjUserDi
$LN46@gObjUserDi:

; 5248 : 		}
; 5249 : 		else if(lpObj->m_PK_Level == 4)

  0066c	3c 04		 cmp	 al, 4
  0066e	75 0a		 jne	 SHORT $LN44@gObjUserDi

; 5250 : 		{
; 5251 : 			decexprate = 5;

  00670	b8 05 00 00 00	 mov	 eax, 5
  00675	e9 a9 00 00 00	 jmp	 $LN17@gObjUserDi
$LN44@gObjUserDi:

; 5252 : 		}
; 5253 : 		else if(lpObj->m_PK_Level == 5)

  0067a	3c 05		 cmp	 al, 5
  0067c	75 0a		 jne	 SHORT $LN42@gObjUserDi

; 5254 : 		{
; 5255 : 			decexprate = 6;

  0067e	b8 06 00 00 00	 mov	 eax, 6
  00683	e9 9b 00 00 00	 jmp	 $LN17@gObjUserDi
$LN42@gObjUserDi:

; 5256 : 		}
; 5257 : 		else if(lpObj->m_PK_Level >= 6)

  00688	33 c9		 xor	 ecx, ecx
  0068a	3c 06		 cmp	 al, 6
  0068c	0f 9c c1	 setl	 cl
  0068f	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00692	83 e0 05	 and	 eax, 5
  00695	83 c0 02	 add	 eax, 2

; 5258 : 		{
; 5259 : 			decexprate = 7;
; 5260 : 		}
; 5261 : 		else
; 5262 : 		{
; 5263 : 			decexprate = 2;
; 5264 : 		}

  00698	e9 86 00 00 00	 jmp	 $LN17@gObjUserDi
$LN49@gObjUserDi:

; 5265 : 	}
; 5266 : 	else if(lpObj->Level <= 220)

  0069d	b8 dc 00 00 00	 mov	 eax, 220		; 000000dcH
  006a2	66 3b c8	 cmp	 cx, ax

; 5267 : 	{
; 5268 : 		if(lpObj->m_PK_Level == 2)

  006a5	8a 8e fd 00 00
	00		 mov	 cl, BYTE PTR [esi+253]
  006ab	7f 3d		 jg	 SHORT $LN37@gObjUserDi
  006ad	80 f9 02	 cmp	 cl, 2
  006b0	75 04		 jne	 SHORT $LN36@gObjUserDi

; 5269 : 		{
; 5270 : 			decexprate = 1;

  006b2	8b c7		 mov	 eax, edi
  006b4	eb 6d		 jmp	 SHORT $LN17@gObjUserDi
$LN36@gObjUserDi:

; 5271 : 		}
; 5272 : 		else if(lpObj->m_PK_Level == 3)

  006b6	80 f9 03	 cmp	 cl, 3
  006b9	75 07		 jne	 SHORT $LN34@gObjUserDi

; 5273 : 		{
; 5274 : 			decexprate = 2;

  006bb	b8 02 00 00 00	 mov	 eax, 2
  006c0	eb 61		 jmp	 SHORT $LN17@gObjUserDi
$LN34@gObjUserDi:

; 5275 : 		}
; 5276 : 		else if(lpObj->m_PK_Level == 4)

  006c2	80 f9 04	 cmp	 cl, 4
  006c5	75 07		 jne	 SHORT $LN32@gObjUserDi

; 5277 : 		{
; 5278 : 			decexprate = 4;

  006c7	b8 04 00 00 00	 mov	 eax, 4
  006cc	eb 55		 jmp	 SHORT $LN17@gObjUserDi
$LN32@gObjUserDi:

; 5279 : 		}
; 5280 : 		else if(lpObj->m_PK_Level == 5)

  006ce	80 f9 05	 cmp	 cl, 5
  006d1	75 07		 jne	 SHORT $LN30@gObjUserDi

; 5281 : 		{
; 5282 : 			decexprate = 5;

  006d3	b8 05 00 00 00	 mov	 eax, 5
  006d8	eb 49		 jmp	 SHORT $LN17@gObjUserDi
$LN30@gObjUserDi:

; 5283 : 		}
; 5284 : 		else if(lpObj->m_PK_Level >= 6)

  006da	33 c0		 xor	 eax, eax
  006dc	80 f9 06	 cmp	 cl, 6
  006df	0f 9c c0	 setl	 al
  006e2	48		 dec	 eax
  006e3	83 e0 05	 and	 eax, 5
  006e6	03 c7		 add	 eax, edi

; 5285 : 		{
; 5286 : 			decexprate = 6;
; 5287 : 		}
; 5288 : 		else
; 5289 : 		{
; 5290 : 			decexprate = 1;
; 5291 : 		}
; 5292 : 	}
; 5293 : 	else

  006e8	eb 39		 jmp	 SHORT $LN17@gObjUserDi
$LN37@gObjUserDi:

; 5294 : 	{
; 5295 : 		if(lpObj->m_PK_Level == 2)

  006ea	80 f9 02	 cmp	 cl, 2
  006ed	75 04		 jne	 SHORT $LN25@gObjUserDi

; 5296 : 		{
; 5297 : 			decexprate = 1;

  006ef	8b c7		 mov	 eax, edi
  006f1	eb 30		 jmp	 SHORT $LN17@gObjUserDi
$LN25@gObjUserDi:

; 5298 : 		}
; 5299 : 		else if(lpObj->m_PK_Level == 3)

  006f3	80 f9 03	 cmp	 cl, 3
  006f6	75 04		 jne	 SHORT $LN23@gObjUserDi

; 5300 : 		{
; 5301 : 			decexprate = 1;

  006f8	8b c7		 mov	 eax, edi
  006fa	eb 27		 jmp	 SHORT $LN17@gObjUserDi
$LN23@gObjUserDi:

; 5302 : 		}
; 5303 : 		else if(lpObj->m_PK_Level == 4)

  006fc	80 f9 04	 cmp	 cl, 4
  006ff	75 07		 jne	 SHORT $LN21@gObjUserDi

; 5304 : 		{
; 5305 : 			decexprate = 3;

  00701	b8 03 00 00 00	 mov	 eax, 3
  00706	eb 1b		 jmp	 SHORT $LN17@gObjUserDi
$LN21@gObjUserDi:

; 5306 : 		}
; 5307 : 		else if(lpObj->m_PK_Level == 5)

  00708	80 f9 05	 cmp	 cl, 5
  0070b	75 07		 jne	 SHORT $LN19@gObjUserDi

; 5308 : 		{
; 5309 : 			decexprate = 4;

  0070d	b8 04 00 00 00	 mov	 eax, 4
  00712	eb 0f		 jmp	 SHORT $LN17@gObjUserDi
$LN19@gObjUserDi:

; 5310 : 		}
; 5311 : 		else if(lpObj->m_PK_Level >= 6)

  00714	33 c0		 xor	 eax, eax
  00716	80 f9 06	 cmp	 cl, 6
  00719	0f 9d c0	 setge	 al
  0071c	8d 04 85 01 00
	00 00		 lea	 eax, DWORD PTR [eax*4+1]
$LN17@gObjUserDi:

; 5312 : 		{
; 5313 : 			decexprate = 5;
; 5314 : 		}
; 5315 : 		else
; 5316 : 		{
; 5317 : 			decexprate = 1;
; 5318 : 		}
; 5319 : 	}
; 5320 : 
; 5321 : 	decexp = (maxexp - minexp)*decexprate/100;

  00723	2b d3		 sub	 edx, ebx

; 5322 : 
; 5323 : 	subexp = lpObj->Experience - decexp;

  00725	8b 9e a8 00 00
	00		 mov	 ebx, DWORD PTR [esi+168]
  0072b	0f af d0	 imul	 edx, eax
  0072e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00733	f7 e2		 mul	 edx

; 5324 : 
; 5325 : 	if(subexp < minexp)

  00735	8b 45 08	 mov	 eax, DWORD PTR _minexp$[ebp]
  00738	c1 ea 05	 shr	 edx, 5
  0073b	2b da		 sub	 ebx, edx
  0073d	3b d8		 cmp	 ebx, eax
  0073f	73 02		 jae	 SHORT $LN15@gObjUserDi

; 5326 : 	{
; 5327 : 		subexp = minexp;

  00741	8b d8		 mov	 ebx, eax
$LN15@gObjUserDi:

; 5328 : 	}
; 5329 : 
; 5330 : 	LogAdd(LOG_BLACK, "[%s][%s] Death reduces Experience %u - %d",lpObj->AccountID,lpObj->Name,subexp,decexp);

  00743	52		 push	 edx
  00744	53		 push	 ebx
  00745	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00748	50		 push	 eax
  00749	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  0074c	50		 push	 eax
  0074d	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PAJOKIHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Death?5reduces?5Experienc@
  00752	6a 00		 push	 0
  00754	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 5331 : 
; 5332 : 	DWORD submoney = 0;
; 5333 : 
; 5334 : 	if(lpObj->Money > 0)

  00759	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  0075f	83 c4 18	 add	 esp, 24			; 00000018H
  00762	33 ff		 xor	 edi, edi
  00764	85 c9		 test	 ecx, ecx
  00766	7e 7c		 jle	 SHORT $LN14@gObjUserDi

; 5335 : 	{
; 5336 : 		if(lpObj->Level > 10 && lpObj->Level <= 99)

  00768	0f b7 86 9c 00
	00 00		 movzx	 eax, WORD PTR [esi+156]
  0076f	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00773	7e 06		 jle	 SHORT $LN13@gObjUserDi
  00775	66 83 f8 63	 cmp	 ax, 99			; 00000063H

; 5337 : 		{
; 5338 : 			submoney = (DWORD)(lpObj->Money)/100;

  00779	7e 21		 jle	 SHORT $LN148@gObjUserDi
$LN13@gObjUserDi:

; 5339 : 		}
; 5340 : 		else if(lpObj->Level >= 100 && lpObj->Level <= 199)

  0077b	66 83 f8 64	 cmp	 ax, 100			; 00000064H
  0077f	7c 0e		 jl	 SHORT $LN11@gObjUserDi
  00781	ba c7 00 00 00	 mov	 edx, 199		; 000000c7H
  00786	66 3b c2	 cmp	 ax, dx
  00789	7f 04		 jg	 SHORT $LN11@gObjUserDi

; 5341 : 		{
; 5342 : 			submoney = (DWORD)(lpObj->Money*2)/100;

  0078b	03 c9		 add	 ecx, ecx
  0078d	eb 0d		 jmp	 SHORT $LN148@gObjUserDi
$LN11@gObjUserDi:

; 5343 : 		}
; 5344 : 		else if(lpObj->Level > 200)

  0078f	ba c8 00 00 00	 mov	 edx, 200		; 000000c8H
  00794	66 3b c2	 cmp	 ax, dx
  00797	7e 0f		 jle	 SHORT $LN9@gObjUserDi

; 5345 : 		{
; 5346 : 			submoney = (DWORD)(lpObj->Money*3)/100;

  00799	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
$LN148@gObjUserDi:
  0079c	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  007a1	f7 e1		 mul	 ecx
  007a3	8b fa		 mov	 edi, edx
  007a5	c1 ef 05	 shr	 edi, 5
$LN9@gObjUserDi:

; 5347 : 		}
; 5348 : 
; 5349 : 		lpObj->Money = lpObj->Money - submoney;

  007a8	29 be b0 00 00
	00		 sub	 DWORD PTR [esi+176], edi

; 5350 : 		
; 5351 : 		if(lpObj->Money < 0)

  007ae	79 0a		 jns	 SHORT $LN8@gObjUserDi

; 5352 : 		{
; 5353 : 			lpObj->Money = 0;

  007b0	c7 86 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+176], 0
$LN8@gObjUserDi:

; 5354 : 		}
; 5355 : 
; 5356 : 		LogAdd(LOG_BLACK, lMsg.Get(574),lpObj->AccountID,lpObj->Name,lpObj->Money,submoney);

  007ba	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  007c0	57		 push	 edi
  007c1	52		 push	 edx
  007c2	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  007c5	50		 push	 eax
  007c6	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  007c9	50		 push	 eax
  007ca	68 3e 02 00 00	 push	 574			; 0000023eH
  007cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  007d4	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  007d9	50		 push	 eax
  007da	6a 00		 push	 0
  007dc	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  007e1	83 c4 18	 add	 esp, 24			; 00000018H
$LN14@gObjUserDi:

; 5357 : 	}
; 5358 : 
; 5359 : 	if(lpObj->WarehouseMoney > 0)

  007e4	8b 8e d4 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3284]
  007ea	85 c9		 test	 ecx, ecx
  007ec	0f 8e 87 00 00
	00		 jle	 $LN7@gObjUserDi

; 5360 : 	{
; 5361 : 		if(lpObj->Level > 10 && lpObj->Level <= 99)

  007f2	0f b7 86 9c 00
	00 00		 movzx	 eax, WORD PTR [esi+156]
  007f9	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  007fd	7e 06		 jle	 SHORT $LN6@gObjUserDi
  007ff	66 83 f8 63	 cmp	 ax, 99			; 00000063H

; 5362 : 		{
; 5363 : 			submoney = (DWORD)(lpObj->WarehouseMoney)/100;

  00803	7e 21		 jle	 SHORT $LN149@gObjUserDi
$LN6@gObjUserDi:

; 5364 : 		}
; 5365 : 		else if(lpObj->Level >= 100 && lpObj->Level <= 199)

  00805	66 83 f8 64	 cmp	 ax, 100			; 00000064H
  00809	7c 0e		 jl	 SHORT $LN4@gObjUserDi
  0080b	ba c7 00 00 00	 mov	 edx, 199		; 000000c7H
  00810	66 3b c2	 cmp	 ax, dx
  00813	7f 04		 jg	 SHORT $LN4@gObjUserDi

; 5366 : 		{
; 5367 : 			submoney = (DWORD)(lpObj->WarehouseMoney*2)/100;

  00815	03 c9		 add	 ecx, ecx
  00817	eb 0d		 jmp	 SHORT $LN149@gObjUserDi
$LN4@gObjUserDi:

; 5368 : 		}
; 5369 : 		else if(lpObj->Level > 200)

  00819	ba c8 00 00 00	 mov	 edx, 200		; 000000c8H
  0081e	66 3b c2	 cmp	 ax, dx
  00821	7e 0f		 jle	 SHORT $LN2@gObjUserDi

; 5370 : 		{
; 5371 : 			submoney = (DWORD)(lpObj->WarehouseMoney*3)/100;

  00823	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
$LN149@gObjUserDi:
  00826	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0082b	f7 e1		 mul	 ecx
  0082d	8b fa		 mov	 edi, edx
  0082f	c1 ef 05	 shr	 edi, 5
$LN2@gObjUserDi:

; 5372 : 		}
; 5373 : 
; 5374 : 		lpObj->WarehouseMoney = lpObj->WarehouseMoney - submoney;

  00832	29 be d4 0c 00
	00		 sub	 DWORD PTR [esi+3284], edi

; 5375 : 		
; 5376 : 		if(lpObj->WarehouseMoney < 0)

  00838	79 0a		 jns	 SHORT $LN1@gObjUserDi

; 5377 : 		{
; 5378 : 			lpObj->WarehouseMoney = 0;

  0083a	c7 86 d4 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3284], 0
$LN1@gObjUserDi:

; 5379 : 		}
; 5380 : 
; 5381 : 		GDSetWarehouseMoney(lpObj->m_Index);

  00844	8b 16		 mov	 edx, DWORD PTR [esi]
  00846	52		 push	 edx
  00847	e8 00 00 00 00	 call	 ?GDSetWarehouseMoney@@YAXH@Z ; GDSetWarehouseMoney

; 5382 : 
; 5383 : 		LogAdd(LOG_BLACK, lMsg.Get(575),lpObj->AccountID,lpObj->Name,lpObj->WarehouseMoney,submoney);

  0084c	8b 86 d4 0c 00
	00		 mov	 eax, DWORD PTR [esi+3284]
  00852	83 c4 04	 add	 esp, 4
  00855	57		 push	 edi
  00856	50		 push	 eax
  00857	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  0085a	50		 push	 eax
  0085b	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  0085e	50		 push	 eax
  0085f	68 3f 02 00 00	 push	 575			; 0000023fH
  00864	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00869	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0086e	50		 push	 eax
  0086f	6a 00		 push	 0
  00871	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00876	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@gObjUserDi:

; 5384 : 	}
; 5385 : 
; 5386 : 	lpObj->Experience = subexp;

  00879	89 9e a8 00 00
	00		 mov	 DWORD PTR [esi+168], ebx
$LN132@gObjUserDi:
  0087f	5f		 pop	 edi
  00880	5b		 pop	 ebx
$LN97@gObjUserDi:
  00881	5e		 pop	 esi

; 5387 : }

  00882	8b e5		 mov	 esp, ebp
  00884	5d		 pop	 ebp
  00885	c3		 ret	 0
?gObjUserDie@@YAXPAUOBJECTSTRUCT@@0@Z ENDP		; gObjUserDie
_TEXT	ENDS
PUBLIC	?gObjSecondDurDown@@YAXPAUOBJECTSTRUCT@@@Z	; gObjSecondDurDown
EXTRN	?DurabilityDown@CItem@@QAEHHH@Z:PROC		; CItem::DurabilityDown
; Function compile flags: /Ogtp
;	COMDAT ?gObjSecondDurDown@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv447 = -8						; size = 4
tv444 = -8						; size = 4
tv433 = -8						; size = 4
tv431 = -8						; size = 4
tv420 = -8						; size = 4
tv418 = -8						; size = 4
tv406 = -8						; size = 4
tv404 = -8						; size = 4
tv393 = -8						; size = 4
tv391 = -8						; size = 4
tv364 = -8						; size = 4
tv362 = -8						; size = 4
tv352 = -8						; size = 4
tv350 = -8						; size = 4
tv308 = -8						; size = 4
tv299 = -8						; size = 4
_reCalCharacter$ = -4					; size = 4
_lpObj$ = 8						; size = 4
tv450 = 10						; size = 2
tv436 = 10						; size = 2
tv423 = 10						; size = 2
tv410 = 10						; size = 2
tv396 = 10						; size = 2
tv367 = 10						; size = 2
tv355 = 10						; size = 2
tv342 = 10						; size = 2
?gObjSecondDurDown@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjSecondDurDown, COMDAT

; 5843 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 5844 : 	lpObj->m_TimeCount +=1;

  00008	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000b	fe 46 50	 inc	 BYTE PTR [esi+80]

; 5845 : 
; 5846 : 	int ret = 0;
; 5847 : 	int reCalCharacter = 0;
; 5848 : 
; 5849 : 	if(lpObj->m_Change >= 0)

  0000e	83 be d0 02 00
	00 00		 cmp	 DWORD PTR [esi+720], 0
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 0
  0001c	7c 09		 jl	 SHORT $LN33@gObjSecond

; 5850 : 	{
; 5851 : 		gObjChangeDurProc(lpObj);

  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ?gObjChangeDurProc@@YAXPAUOBJECTSTRUCT@@@Z ; gObjChangeDurProc
  00024	83 c4 04	 add	 esp, 4
$LN33@gObjSecond:

; 5852 : 	}
; 5853 : 
; 5854 : 	BYTE attr = MapC[lpObj->MapNumber].GetAttr(lpObj->X,lpObj->Y);

  00027	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  0002e	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  00035	50		 push	 eax
  00036	51		 push	 ecx
  00037	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  0003e	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00044	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0004a	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0004f	8a d8		 mov	 bl, al

; 5855 : 
; 5856 : 	if(lpObj->m_TimeCount % 10 != 0)

  00051	0f b6 46 50	 movzx	 eax, BYTE PTR [esi+80]
  00055	99		 cdq
  00056	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0005b	f7 f9		 idiv	 ecx
  0005d	85 d2		 test	 edx, edx
  0005f	0f 85 9c 03 00
	00		 jne	 $LN1@gObjSecond

; 5857 : 	{
; 5858 : 		return;
; 5859 : 	}
; 5860 : 
; 5861 : 	if(lpObj->pInventory[7].IsItem() == 1 )

  00065	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0006b	57		 push	 edi
  0006c	81 c1 98 04 00
	00		 add	 ecx, 1176		; 00000498H
  00072	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00077	83 f8 01	 cmp	 eax, 1
  0007a	75 61		 jne	 SHORT $LN37@gObjSecond

; 5862 : 	{
; 5863 : 		ret = lpObj->pInventory[7].DurabilityDown(1,lpObj->m_Index);

  0007c	8b 16		 mov	 edx, DWORD PTR [esi]
  0007e	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00084	52		 push	 edx
  00085	50		 push	 eax
  00086	81 c1 98 04 00
	00		 add	 ecx, 1176		; 00000498H
  0008c	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown
  00091	8b f8		 mov	 edi, eax

; 5864 : 
; 5865 : 		if(ret != 0)

  00093	85 ff		 test	 edi, edi
  00095	74 3a		 je	 SHORT $LN30@gObjSecond

; 5866 : 		{
; 5867 : 			GCItemDurSend2(lpObj->m_Index,7,lpObj->pInventory[7].m_Durability,0);

  00097	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0009d	d9 7d 0a	 fnstcw	 WORD PTR tv450[ebp]
  000a0	d9 80 bc 04 00
	00		 fld	 DWORD PTR [eax+1212]
  000a6	6a 00		 push	 0
  000a8	0f b7 45 0a	 movzx	 eax, WORD PTR tv450[ebp]
  000ac	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000b1	89 45 f8	 mov	 DWORD PTR tv447[ebp], eax
  000b4	8b 06		 mov	 eax, DWORD PTR [esi]
  000b6	d9 6d f8	 fldcw	 WORD PTR tv447[ebp]
  000b9	db 5d f8	 fistp	 DWORD PTR tv444[ebp]
  000bc	8a 4d f8	 mov	 cl, BYTE PTR tv444[ebp]
  000bf	0f b6 d1	 movzx	 edx, cl
  000c2	52		 push	 edx
  000c3	d9 6d 0a	 fldcw	 WORD PTR tv450[ebp]
  000c6	6a 07		 push	 7
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  000ce	83 c4 10	 add	 esp, 16			; 00000010H
$LN30@gObjSecond:

; 5868 : 		}
; 5869 : 
; 5870 : 		if(ret == 2)

  000d1	83 ff 02	 cmp	 edi, 2
  000d4	75 07		 jne	 SHORT $LN37@gObjSecond

; 5871 : 		{
; 5872 : 			reCalCharacter = 1;

  000d6	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN37@gObjSecond:

; 5873 : 		}
; 5874 : 	}
; 5875 : 
; 5876 : 	if((attr&1)==0)

  000dd	f6 c3 01	 test	 bl, 1
  000e0	0f 85 09 03 00
	00		 jne	 $LN2@gObjSecond

; 5877 : 	{
; 5878 : 		if(lpObj->pInventory[10].IsItem() == 1)

  000e6	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  000ec	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
  000f2	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000f7	83 f8 01	 cmp	 eax, 1
  000fa	0f 85 2b 01 00
	00		 jne	 $LN39@gObjSecond

; 5879 : 		{
; 5880 : 			if(lpObj->pInventory[10].m_Type == ITEMGET(13,20) && lpObj->pInventory[10].m_Level == 0)

  00100	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00106	0f b7 88 96 06
	00 00		 movzx	 ecx, WORD PTR [eax+1686]
  0010d	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  00112	66 3b ca	 cmp	 cx, dx
  00115	75 50		 jne	 SHORT $LN44@gObjSecond
  00117	66 83 b8 98 06
	00 00 00	 cmp	 WORD PTR [eax+1688], 0
  0011f	75 46		 jne	 SHORT $LN44@gObjSecond

; 5881 : 			{
; 5882 : 				ret = lpObj->pInventory[10].DurabilityDown(70,lpObj->m_Index);

  00121	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00123	51		 push	 ecx
  00124	6a 46		 push	 70			; 00000046H
  00126	8d 88 90 06 00
	00		 lea	 ecx, DWORD PTR [eax+1680]
  0012c	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown
  00131	8b f8		 mov	 edi, eax

; 5883 : 				if(ret != 0)

  00133	85 ff		 test	 edi, edi
  00135	0f 84 e4 00 00
	00		 je	 $LN18@gObjSecond

; 5884 : 				{
; 5885 : 					GCItemDurSend2(lpObj->m_Index,10,lpObj->pInventory[10].m_Durability,0);

  0013b	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00141	d9 7d 0a	 fnstcw	 WORD PTR tv436[ebp]
  00144	0f b7 45 0a	 movzx	 eax, WORD PTR tv436[ebp]
  00148	d9 82 b4 06 00
	00		 fld	 DWORD PTR [edx+1716]
  0014e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00153	89 45 f8	 mov	 DWORD PTR tv433[ebp], eax
  00156	d9 6d f8	 fldcw	 WORD PTR tv433[ebp]
  00159	db 5d f8	 fistp	 DWORD PTR tv431[ebp]
  0015c	8a 45 f8	 mov	 al, BYTE PTR tv431[ebp]
  0015f	d9 6d 0a	 fldcw	 WORD PTR tv436[ebp]

; 5886 : 				}
; 5887 : 
; 5888 : 				if(ret == 2)
; 5889 : 				{
; 5890 : 					reCalCharacter = 1;
; 5891 : 				}
; 5892 : 			}

  00162	e9 a5 00 00 00	 jmp	 $LN51@gObjSecond
$LN44@gObjSecond:

; 5893 : 			else if(lpObj->pInventory[10].m_Type == ITEMGET(13,38))

  00167	ba 26 1a 00 00	 mov	 edx, 6694		; 00001a26H
  0016c	66 3b ca	 cmp	 cx, dx
  0016f	75 54		 jne	 SHORT $LN22@gObjSecond

; 5894 : 			{
; 5895 : 				ret = lpObj->pInventory[10].DurabilityDown(63,lpObj->m_Index);

  00171	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00173	51		 push	 ecx
  00174	6a 3f		 push	 63			; 0000003fH
  00176	8d 88 90 06 00
	00		 lea	 ecx, DWORD PTR [eax+1680]
  0017c	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown

; 5896 : 				if(ret != 0)

  00181	85 c0		 test	 eax, eax
  00183	0f 84 a2 00 00
	00		 je	 $LN39@gObjSecond

; 5897 : 				{
; 5898 : 					GCItemDurSend2(lpObj->m_Index,10,lpObj->pInventory[10].m_Durability,0);

  00189	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  0018f	d9 7d 0a	 fnstcw	 WORD PTR tv423[ebp]
  00192	0f b7 45 0a	 movzx	 eax, WORD PTR tv423[ebp]
  00196	d9 82 b4 06 00
	00		 fld	 DWORD PTR [edx+1716]
  0019c	8b 16		 mov	 edx, DWORD PTR [esi]
  0019e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  001a3	89 45 f8	 mov	 DWORD PTR tv420[ebp], eax
  001a6	6a 00		 push	 0
  001a8	d9 6d f8	 fldcw	 WORD PTR tv420[ebp]
  001ab	db 5d f8	 fistp	 DWORD PTR tv418[ebp]
  001ae	8a 45 f8	 mov	 al, BYTE PTR tv418[ebp]
  001b1	0f b6 c8	 movzx	 ecx, al
  001b4	51		 push	 ecx
  001b5	d9 6d 0a	 fldcw	 WORD PTR tv423[ebp]
  001b8	6a 0a		 push	 10			; 0000000aH
  001ba	52		 push	 edx
  001bb	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  001c0	83 c4 10	 add	 esp, 16			; 00000010H

; 5899 : 				}
; 5900 : 			}

  001c3	eb 66		 jmp	 SHORT $LN39@gObjSecond
$LN22@gObjSecond:

; 5901 : 			else if(lpObj->pInventory[10].m_Type != ITEMGET(13,10))

  001c5	ba 0a 1a 00 00	 mov	 edx, 6666		; 00001a0aH
  001ca	66 3b ca	 cmp	 cx, dx
  001cd	74 5c		 je	 SHORT $LN39@gObjSecond

; 5902 : 			{
; 5903 : 				ret = lpObj->pInventory[10].DurabilityDown(1,lpObj->m_Index);

  001cf	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001d1	51		 push	 ecx
  001d2	6a 01		 push	 1
  001d4	8d 88 90 06 00
	00		 lea	 ecx, DWORD PTR [eax+1680]
  001da	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown
  001df	8b f8		 mov	 edi, eax

; 5904 : 				if(ret != 0)

  001e1	85 ff		 test	 edi, edi
  001e3	74 3a		 je	 SHORT $LN18@gObjSecond

; 5905 : 				{
; 5906 : 					GCItemDurSend2(lpObj->m_Index,10,lpObj->pInventory[10].m_Durability,0);

  001e5	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  001eb	d9 7d 0a	 fnstcw	 WORD PTR tv410[ebp]
  001ee	0f b7 45 0a	 movzx	 eax, WORD PTR tv410[ebp]
  001f2	d9 82 b4 06 00
	00		 fld	 DWORD PTR [edx+1716]
  001f8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  001fd	89 45 f8	 mov	 DWORD PTR tv406[ebp], eax
  00200	d9 6d f8	 fldcw	 WORD PTR tv406[ebp]
  00203	db 5d f8	 fistp	 DWORD PTR tv404[ebp]
  00206	8a 45 f8	 mov	 al, BYTE PTR tv404[ebp]
  00209	d9 6d 0a	 fldcw	 WORD PTR tv410[ebp]
$LN51@gObjSecond:
  0020c	8b 16		 mov	 edx, DWORD PTR [esi]
  0020e	0f b6 c8	 movzx	 ecx, al
  00211	6a 00		 push	 0
  00213	51		 push	 ecx
  00214	6a 0a		 push	 10			; 0000000aH
  00216	52		 push	 edx
  00217	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  0021c	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@gObjSecond:

; 5907 : 				}
; 5908 : 
; 5909 : 				if(ret == 2)

  0021f	83 ff 02	 cmp	 edi, 2
  00222	75 07		 jne	 SHORT $LN39@gObjSecond

; 5910 : 				{
; 5911 : 					reCalCharacter = 1;

  00224	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN39@gObjSecond:

; 5912 : 				}
; 5913 : 			}
; 5914 : 		}
; 5915 : 
; 5916 : 		if(lpObj->pInventory[11].IsItem() == 1)

  0022b	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00231	81 c1 38 07 00
	00		 add	 ecx, 1848		; 00000738H
  00237	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0023c	83 f8 01	 cmp	 eax, 1
  0023f	0f 85 2b 01 00
	00		 jne	 $LN43@gObjSecond

; 5917 : 		{
; 5918 : 			if(lpObj->pInventory[11].m_Type == ITEMGET(13,20) && lpObj->pInventory[11].m_Level == 0)

  00245	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0024b	0f b7 88 3e 07
	00 00		 movzx	 ecx, WORD PTR [eax+1854]
  00252	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  00257	66 3b ca	 cmp	 cx, dx
  0025a	75 50		 jne	 SHORT $LN46@gObjSecond
  0025c	66 83 b8 40 07
	00 00 00	 cmp	 WORD PTR [eax+1856], 0
  00264	75 46		 jne	 SHORT $LN46@gObjSecond

; 5919 : 			{
; 5920 : 				ret = lpObj->pInventory[11].DurabilityDown(70,lpObj->m_Index);

  00266	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00268	51		 push	 ecx
  00269	6a 46		 push	 70			; 00000046H
  0026b	8d 88 38 07 00
	00		 lea	 ecx, DWORD PTR [eax+1848]
  00271	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown
  00276	8b f8		 mov	 edi, eax

; 5921 : 				if(ret != 0)

  00278	85 ff		 test	 edi, edi
  0027a	0f 84 e4 00 00
	00		 je	 $LN47@gObjSecond

; 5922 : 				{
; 5923 : 					GCItemDurSend2(lpObj->m_Index,11,lpObj->pInventory[11].m_Durability,0);

  00280	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00286	d9 7d 0a	 fnstcw	 WORD PTR tv396[ebp]
  00289	0f b7 45 0a	 movzx	 eax, WORD PTR tv396[ebp]
  0028d	d9 82 5c 07 00
	00		 fld	 DWORD PTR [edx+1884]
  00293	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00298	89 45 f8	 mov	 DWORD PTR tv393[ebp], eax
  0029b	d9 6d f8	 fldcw	 WORD PTR tv393[ebp]
  0029e	db 5d f8	 fistp	 DWORD PTR tv391[ebp]
  002a1	8a 45 f8	 mov	 al, BYTE PTR tv391[ebp]
  002a4	d9 6d 0a	 fldcw	 WORD PTR tv396[ebp]

; 5924 : 				}
; 5925 : 
; 5926 : 				if(ret == 2)
; 5927 : 				{
; 5928 : 					reCalCharacter = 1;
; 5929 : 				}
; 5930 : 			}

  002a7	e9 a5 00 00 00	 jmp	 $LN53@gObjSecond
$LN46@gObjSecond:

; 5931 : 			else if(lpObj->pInventory[11].m_Type == ITEMGET(13,38))

  002ac	ba 26 1a 00 00	 mov	 edx, 6694		; 00001a26H
  002b1	66 3b ca	 cmp	 cx, dx
  002b4	75 54		 jne	 SHORT $LN11@gObjSecond

; 5932 : 			{
; 5933 : 				ret = lpObj->pInventory[11].DurabilityDown(63,lpObj->m_Index);

  002b6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002b8	51		 push	 ecx
  002b9	6a 3f		 push	 63			; 0000003fH
  002bb	8d 88 38 07 00
	00		 lea	 ecx, DWORD PTR [eax+1848]
  002c1	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown

; 5934 : 				if(ret != 0)

  002c6	85 c0		 test	 eax, eax
  002c8	0f 84 a2 00 00
	00		 je	 $LN43@gObjSecond

; 5935 : 				{
; 5936 : 					GCItemDurSend2(lpObj->m_Index,11,lpObj->pInventory[11].m_Durability,0);

  002ce	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  002d4	d9 7d 0a	 fnstcw	 WORD PTR tv367[ebp]
  002d7	0f b7 45 0a	 movzx	 eax, WORD PTR tv367[ebp]
  002db	d9 82 5c 07 00
	00		 fld	 DWORD PTR [edx+1884]
  002e1	8b 16		 mov	 edx, DWORD PTR [esi]
  002e3	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002e8	89 45 f8	 mov	 DWORD PTR tv364[ebp], eax
  002eb	6a 00		 push	 0
  002ed	d9 6d f8	 fldcw	 WORD PTR tv364[ebp]
  002f0	db 5d f8	 fistp	 DWORD PTR tv362[ebp]
  002f3	8a 45 f8	 mov	 al, BYTE PTR tv362[ebp]
  002f6	0f b6 c8	 movzx	 ecx, al
  002f9	51		 push	 ecx
  002fa	d9 6d 0a	 fldcw	 WORD PTR tv367[ebp]
  002fd	6a 0b		 push	 11			; 0000000bH
  002ff	52		 push	 edx
  00300	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  00305	83 c4 10	 add	 esp, 16			; 00000010H

; 5937 : 				}
; 5938 : 			}

  00308	eb 66		 jmp	 SHORT $LN43@gObjSecond
$LN11@gObjSecond:

; 5939 : 			else if(lpObj->pInventory[11].m_Type != ITEMGET(13,10))

  0030a	ba 0a 1a 00 00	 mov	 edx, 6666		; 00001a0aH
  0030f	66 3b ca	 cmp	 cx, dx
  00312	74 5c		 je	 SHORT $LN43@gObjSecond

; 5940 : 			{
; 5941 : 				ret = lpObj->pInventory[11].DurabilityDown(1,lpObj->m_Index);

  00314	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00316	51		 push	 ecx
  00317	6a 01		 push	 1
  00319	8d 88 38 07 00
	00		 lea	 ecx, DWORD PTR [eax+1848]
  0031f	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown
  00324	8b f8		 mov	 edi, eax

; 5942 : 				if(ret != 0)

  00326	85 ff		 test	 edi, edi
  00328	74 3a		 je	 SHORT $LN47@gObjSecond

; 5943 : 				{
; 5944 : 					GCItemDurSend2(lpObj->m_Index,11,lpObj->pInventory[11].m_Durability,0);

  0032a	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  00330	d9 7d 0a	 fnstcw	 WORD PTR tv355[ebp]
  00333	0f b7 45 0a	 movzx	 eax, WORD PTR tv355[ebp]
  00337	d9 82 5c 07 00
	00		 fld	 DWORD PTR [edx+1884]
  0033d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00342	89 45 f8	 mov	 DWORD PTR tv352[ebp], eax
  00345	d9 6d f8	 fldcw	 WORD PTR tv352[ebp]
  00348	db 5d f8	 fistp	 DWORD PTR tv350[ebp]
  0034b	8a 45 f8	 mov	 al, BYTE PTR tv350[ebp]
  0034e	d9 6d 0a	 fldcw	 WORD PTR tv355[ebp]
$LN53@gObjSecond:
  00351	8b 16		 mov	 edx, DWORD PTR [esi]
  00353	0f b6 c8	 movzx	 ecx, al
  00356	6a 00		 push	 0
  00358	51		 push	 ecx
  00359	6a 0b		 push	 11			; 0000000bH
  0035b	52		 push	 edx
  0035c	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  00361	83 c4 10	 add	 esp, 16			; 00000010H
$LN47@gObjSecond:

; 5945 : 				}
; 5946 : 
; 5947 : 				if(ret == 2)

  00364	83 ff 02	 cmp	 edi, 2
  00367	75 07		 jne	 SHORT $LN43@gObjSecond

; 5948 : 				{
; 5949 : 					reCalCharacter = 1;

  00369	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN43@gObjSecond:

; 5950 : 				}
; 5951 : 			}
; 5952 : 		}
; 5953 : 
; 5954 : 		if(lpObj->pInventory[9].IsItem() == 1)

  00370	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00376	81 c1 e8 05 00
	00		 add	 ecx, 1512		; 000005e8H
  0037c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00381	83 f8 01	 cmp	 eax, 1
  00384	75 69		 jne	 SHORT $LN2@gObjSecond

; 5955 : 		{
; 5956 : 			if(lpObj->pInventory[9].m_Type != ITEMGET(13,10))

  00386	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0038c	b9 0a 1a 00 00	 mov	 ecx, 6666		; 00001a0aH
  00391	66 39 88 ee 05
	00 00		 cmp	 WORD PTR [eax+1518], cx
  00398	74 55		 je	 SHORT $LN2@gObjSecond

; 5957 : 			{
; 5958 : 				ret = lpObj->pInventory[9].DurabilityDown(1,lpObj->m_Index);

  0039a	8b 16		 mov	 edx, DWORD PTR [esi]
  0039c	52		 push	 edx
  0039d	6a 01		 push	 1
  0039f	8d 88 e8 05 00
	00		 lea	 ecx, DWORD PTR [eax+1512]
  003a5	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown
  003aa	8b f8		 mov	 edi, eax

; 5959 : 
; 5960 : 				if(ret != 0)

  003ac	85 ff		 test	 edi, edi
  003ae	74 3a		 je	 SHORT $LN3@gObjSecond

; 5961 : 				{
; 5962 : 					GCItemDurSend2(lpObj->m_Index,9,lpObj->pInventory[9].m_Durability,0);

  003b0	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  003b6	d9 7d 0a	 fnstcw	 WORD PTR tv342[ebp]
  003b9	d9 80 0c 06 00
	00		 fld	 DWORD PTR [eax+1548]
  003bf	6a 00		 push	 0
  003c1	0f b7 45 0a	 movzx	 eax, WORD PTR tv342[ebp]
  003c5	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  003ca	89 45 f8	 mov	 DWORD PTR tv308[ebp], eax
  003cd	8b 06		 mov	 eax, DWORD PTR [esi]
  003cf	d9 6d f8	 fldcw	 WORD PTR tv308[ebp]
  003d2	db 5d f8	 fistp	 DWORD PTR tv299[ebp]
  003d5	8a 4d f8	 mov	 cl, BYTE PTR tv299[ebp]
  003d8	0f b6 d1	 movzx	 edx, cl
  003db	52		 push	 edx
  003dc	d9 6d 0a	 fldcw	 WORD PTR tv342[ebp]
  003df	6a 09		 push	 9
  003e1	50		 push	 eax
  003e2	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  003e7	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@gObjSecond:

; 5963 : 				}
; 5964 : 
; 5965 : 				if(ret == 2)

  003ea	83 ff 02	 cmp	 edi, 2

; 5966 : 				{
; 5967 : 					reCalCharacter = 1;
; 5968 : 				}
; 5969 : 			}
; 5970 : 		}
; 5971 : 	}
; 5972 : 
; 5973 : 	if(reCalCharacter != 0)

  003ed	74 06		 je	 SHORT $LN36@gObjSecond
$LN2@gObjSecond:
  003ef	83 7d fc 00	 cmp	 DWORD PTR _reCalCharacter$[ebp], 0
  003f3	74 0b		 je	 SHORT $LN49@gObjSecond
$LN36@gObjSecond:

; 5974 : 	{
; 5975 : 		gObjCalCharacter(lpObj->m_Index);

  003f5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003f7	51		 push	 ecx
  003f8	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  003fd	83 c4 04	 add	 esp, 4
$LN49@gObjSecond:
  00400	5f		 pop	 edi
$LN1@gObjSecond:
  00401	5e		 pop	 esi
  00402	5b		 pop	 ebx

; 5976 : 	}
; 5977 : }

  00403	8b e5		 mov	 esp, ebp
  00405	5d		 pop	 ebp
  00406	c3		 ret	 0
?gObjSecondDurDown@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjSecondDurDown
_TEXT	ENDS
PUBLIC	??_C@_0BH@NHBCKBPB@Trade?5Transaction?5?$CI?$CFs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0DI@CKMLLKAG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransaction@ ; `string'
PUBLIC	?gObjInventoryTrans@@YAHH@Z			; gObjInventoryTrans
;	COMDAT ??_C@_0BH@NHBCKBPB@Trade?5Transaction?5?$CI?$CFs?$CJ?$AA@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\magicinf.h
CONST	SEGMENT
??_C@_0BH@NHBCKBPB@Trade?5Transaction?5?$CI?$CFs?$CJ?$AA@ DB 'Trade Trans'
	DB	'action (%s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CKMLLKAG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransaction@
CONST	SEGMENT
??_C@_0DI@CKMLLKAG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransaction@ DB '['
	DB	'%s][%s] error-L3 : pTransaction(%d) status error %s %d', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
CONST	ENDS
;	COMDAT ?gObjInventoryTrans@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjInventoryTrans@@YAHH@Z PROC			; gObjInventoryTrans, COMDAT

; 7369 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 7370 : 	if ( ((aIndex< 0)?FALSE:(aIndex > OBJMAX-1)?FALSE:TRUE) == FALSE )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	78 0f		 js	 SHORT $LN21@gObjInvent@6
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 1e		 jne	 SHORT $LN8@gObjInvent@6
$LN21@gObjInvent@6:

; 7371 : 	{
; 7372 : 		LogAdd(LOG_BLACK, "error : %s %d", __FILE__, __LINE__);

  0001a	68 cc 1c 00 00	 push	 7372			; 00001cccH
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00029	6a 00		 push	 0
  0002b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00030	83 c4 10	 add	 esp, 16			; 00000010H

; 7373 : 		return FALSE;

  00033	33 c0		 xor	 eax, eax
  00035	5b		 pop	 ebx

; 7403 : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN8@gObjInvent@6:

; 7374 : 	}
; 7375 : 
; 7376 : 	if ( gObj[aIndex].pTransaction == 1 )

  00038	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  0003e	80 bb 98 0c 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3224], 1
  00045	75 2e		 jne	 SHORT $LN7@gObjInvent@6

; 7377 : 	{
; 7378 : 		LogAdd(LOG_BLACK, "[%s][%s] error-L3 : pTransaction(%d) status error %s %d",
; 7379 : 			gObj[aIndex].AccountID, gObj[aIndex].Name,
; 7380 : 			gObj[aIndex].pTransaction, __FILE__, __LINE__);

  00047	68 d4 1c 00 00	 push	 7380			; 00001cd4H
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00051	6a 01		 push	 1
  00053	8d 83 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+111]
  00059	50		 push	 eax
  0005a	8d 8b 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+100]
  00060	51		 push	 ecx
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@CKMLLKAG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransaction@
  00066	6a 00		 push	 0
  00068	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0006d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 7381 : 		return FALSE;

  00070	33 c0		 xor	 eax, eax
  00072	5b		 pop	 ebx

; 7403 : }

  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN7@gObjInvent@6:
  00075	56		 push	 esi

; 7382 : 	}
; 7383 : 
; 7384 : 	for ( int n=0;n<MAX_MAGIC;n++)

  00076	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  0007b	57		 push	 edi
  0007c	8d 64 24 00	 npad	 4
$LL6@gObjInvent@6:

; 7385 : 	{
; 7386 : 		gObj[aIndex].m_lpMagicBack[n] = gObj[aIndex].Magic[n]; 

  00080	8b b3 38 03 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+824]
  00086	8b bb 34 03 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+820]
  0008c	8d 48 d0	 lea	 ecx, DWORD PTR [eax-48]
  0008f	0f b6 54 0e 04	 movzx	 edx, BYTE PTR [esi+ecx+4]
  00094	88 54 0f 04	 mov	 BYTE PTR [edi+ecx+4], dl
  00098	0f b6 54 0e 05	 movzx	 edx, BYTE PTR [esi+ecx+5]
  0009d	88 54 0f 05	 mov	 BYTE PTR [edi+ecx+5], dl
  000a1	8b 54 0e 08	 mov	 edx, DWORD PTR [esi+ecx+8]
  000a5	89 54 0f 08	 mov	 DWORD PTR [edi+ecx+8], edx
  000a9	8b 54 0e 0c	 mov	 edx, DWORD PTR [esi+ecx+12]
  000ad	89 54 0f 0c	 mov	 DWORD PTR [edi+ecx+12], edx
  000b1	8b 93 38 03 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+824]
  000b7	03 f1		 add	 esi, ecx
  000b9	03 f9		 add	 edi, ecx
  000bb	8d 74 11 10	 lea	 esi, DWORD PTR [ecx+edx+16]
  000bf	8b 93 34 03 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+820]
  000c5	8d 7c 11 10	 lea	 edi, DWORD PTR [ecx+edx+16]
  000c9	0f b6 4e 04	 movzx	 ecx, BYTE PTR [esi+4]
  000cd	88 4f 04	 mov	 BYTE PTR [edi+4], cl
  000d0	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  000d4	88 57 05	 mov	 BYTE PTR [edi+5], dl
  000d7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000da	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  000dd	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000e0	89 57 0c	 mov	 DWORD PTR [edi+12], edx
  000e3	8b b3 38 03 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+824]
  000e9	8b bb 34 03 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+820]
  000ef	8d 48 f0	 lea	 ecx, DWORD PTR [eax-16]
  000f2	03 f9		 add	 edi, ecx
  000f4	03 f1		 add	 esi, ecx
  000f6	0f b6 4e 04	 movzx	 ecx, BYTE PTR [esi+4]
  000fa	88 4f 04	 mov	 BYTE PTR [edi+4], cl
  000fd	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  00101	88 57 05	 mov	 BYTE PTR [edi+5], dl
  00104	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00107	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  0010a	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0010d	89 57 0c	 mov	 DWORD PTR [edi+12], edx
  00110	8b b3 38 03 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+824]
  00116	0f b6 4c 06 04	 movzx	 ecx, BYTE PTR [esi+eax+4]
  0011b	8b bb 34 03 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+820]
  00121	88 4c 07 04	 mov	 BYTE PTR [edi+eax+4], cl
  00125	0f b6 54 06 05	 movzx	 edx, BYTE PTR [esi+eax+5]
  0012a	88 54 07 05	 mov	 BYTE PTR [edi+eax+5], dl
  0012e	8b 4c 06 08	 mov	 ecx, DWORD PTR [esi+eax+8]
  00132	89 4c 07 08	 mov	 DWORD PTR [edi+eax+8], ecx
  00136	8b 54 06 0c	 mov	 edx, DWORD PTR [esi+eax+12]
  0013a	03 f0		 add	 esi, eax
  0013c	03 f8		 add	 edi, eax
  0013e	89 57 0c	 mov	 DWORD PTR [edi+12], edx
  00141	8b b3 38 03 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+824]
  00147	8b bb 34 03 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+820]
  0014d	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00150	03 f9		 add	 edi, ecx
  00152	03 f1		 add	 esi, ecx
  00154	0f b6 4e 04	 movzx	 ecx, BYTE PTR [esi+4]
  00158	88 4f 04	 mov	 BYTE PTR [edi+4], cl
  0015b	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  0015f	88 57 05	 mov	 BYTE PTR [edi+5], dl
  00162	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00165	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00168	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0016b	89 57 0c	 mov	 DWORD PTR [edi+12], edx
  0016e	8b b3 38 03 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+824]
  00174	8b bb 34 03 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+820]
  0017a	8d 48 20	 lea	 ecx, DWORD PTR [eax+32]
  0017d	03 f9		 add	 edi, ecx
  0017f	03 f1		 add	 esi, ecx
  00181	0f b6 4e 04	 movzx	 ecx, BYTE PTR [esi+4]
  00185	88 4f 04	 mov	 BYTE PTR [edi+4], cl
  00188	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  0018c	88 57 05	 mov	 BYTE PTR [edi+5], dl
  0018f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00192	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00195	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00198	83 c0 60	 add	 eax, 96			; 00000060H
  0019b	89 57 0c	 mov	 DWORD PTR [edi+12], edx
  0019e	3d f0 03 00 00	 cmp	 eax, 1008		; 000003f0H
  001a3	0f 8c d7 fe ff
	ff		 jl	 $LL6@gObjInvent@6

; 7387 : 	}
; 7388 : 
; 7389 : 	for (int n=0;n<MAIN_INVENTORY_SIZE;n++)

  001a9	33 c0		 xor	 eax, eax
  001ab	eb 03 8d 49 00	 npad	 5
$LL3@gObjInvent@6:

; 7390 : 	{
; 7391 : 		gObj[aIndex].Inventory2[n] = gObj[aIndex].Inventory1[n];

  001b0	8b b3 9c 0c 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3228]
  001b6	8b bb a8 0c 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3240]
  001bc	03 f0		 add	 esi, eax
  001be	03 f8		 add	 edi, eax
  001c0	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  001c5	f3 a5		 rep movsd
  001c7	8b 8b 9c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3228]
  001cd	8b 93 a8 0c 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3240]
  001d3	8d b4 08 a8 00
	00 00		 lea	 esi, DWORD PTR [eax+ecx+168]
  001da	8d bc 10 a8 00
	00 00		 lea	 edi, DWORD PTR [eax+edx+168]
  001e1	8d 90 f8 01 00
	00		 lea	 edx, DWORD PTR [eax+504]
  001e7	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  001ec	f3 a5		 rep movsd
  001ee	8b b3 9c 0c 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3228]
  001f4	8b bb a8 0c 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3240]
  001fa	8d 8a 58 ff ff
	ff		 lea	 ecx, DWORD PTR [edx-168]
  00200	03 f1		 add	 esi, ecx
  00202	03 f9		 add	 edi, ecx
  00204	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00209	f3 a5		 rep movsd
  0020b	8b b3 9c 0c 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3228]
  00211	8b bb a8 0c 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3240]
  00217	03 f2		 add	 esi, edx
  00219	03 fa		 add	 edi, edx
  0021b	05 a0 02 00 00	 add	 eax, 672		; 000002a0H
  00220	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00225	f3 a5		 rep movsd
  00227	3d e0 31 00 00	 cmp	 eax, 12768		; 000031e0H
  0022c	7c 82		 jl	 SHORT $LL3@gObjInvent@6

; 7392 : 	}
; 7393 : 
; 7394 : 	//memcpy(gObj[aIndex].InventoryMap2, gObj[aIndex].InventoryMap1, INVENTORY_MAP_SIZE);	// #error Deathway Fix
; 7395 : 	memcpy(gObj[aIndex].InventoryMap2, gObj[aIndex].InventoryMap1, 64);

  0022e	8b b3 a0 0c 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3232]
  00234	8b bb ac 0c 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3244]
  0023a	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0023f	f3 a5		 rep movsd

; 7396 : 	gObj[aIndex].InventoryCount2 = gObj[aIndex].InventoryCount1;

  00241	8a 83 a4 0c 00
	00		 mov	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3236]

; 7397 : 	gObjSetInventory2Pointer(&gObj[aIndex]);

  00247	8d 8b 00 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx]
  0024d	51		 push	 ecx
  0024e	88 83 b0 0c 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3248], al
  00254	e8 00 00 00 00	 call	 ?gObjSetInventory2Pointer@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSetInventory2Pointer

; 7398 : 	gObj[aIndex].pTransaction = 1;
; 7399 : 	
; 7400 : 	LogAdd(LOG_BLACK, "Trade Transaction (%s)", gObj[aIndex].Name);

  00259	8d 93 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+111]
  0025f	52		 push	 edx
  00260	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NHBCKBPB@Trade?5Transaction?5?$CI?$CFs?$CJ?$AA@
  00265	6a 00		 push	 0
  00267	c6 83 98 0c 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3224], 1
  0026e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00273	83 c4 10	 add	 esp, 16			; 00000010H
  00276	5f		 pop	 edi
  00277	5e		 pop	 esi

; 7401 : 
; 7402 : 	return TRUE;

  00278	b8 01 00 00 00	 mov	 eax, 1
  0027d	5b		 pop	 ebx

; 7403 : }

  0027e	5d		 pop	 ebp
  0027f	c3		 ret	 0
?gObjInventoryTrans@@YAHH@Z ENDP			; gObjInventoryTrans
_TEXT	ENDS
PUBLIC	??_C@_0BE@GIFOPHN@Trade?5Rollback?5?$CI?$CFs?$CJ?$AA@ ; `string'
PUBLIC	?gObjInventoryRollback@@YAHH@Z			; gObjInventoryRollback
;	COMDAT ??_C@_0BE@GIFOPHN@Trade?5Rollback?5?$CI?$CFs?$CJ?$AA@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\magicinf.h
CONST	SEGMENT
??_C@_0BE@GIFOPHN@Trade?5Rollback?5?$CI?$CFs?$CJ?$AA@ DB 'Trade Rollback '
	DB	'(%s)', 00H					; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
CONST	ENDS
;	COMDAT ?gObjInventoryRollback@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjInventoryRollback@@YAHH@Z PROC			; gObjInventoryRollback, COMDAT

; 7439 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 7440 : 	if(!OBJMAX_RANGE(aIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 0f		 js	 SHORT $LN20@gObjInvent@7
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 1e		 jne	 SHORT $LN8@gObjInvent@7
$LN20@gObjInvent@7:

; 7441 : 	{
; 7442 : 		LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  0001a	68 12 1d 00 00	 push	 7442			; 00001d12H
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00029	6a 00		 push	 0
  0002b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00030	83 c4 10	 add	 esp, 16			; 00000010H

; 7443 : 		return false;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 7469 : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN8@gObjInvent@7:

; 7444 : 	}
; 7445 : 
; 7446 : 	if(gObj[aIndex].pTransaction != 1)

  00038	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0003e	8a 86 98 0c 00
	00		 mov	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3224]
  00044	3c 01		 cmp	 al, 1
  00046	74 26		 je	 SHORT $LN7@gObjInvent@7

; 7447 : 	{
; 7448 : 		LogAdd(LOG_BLACK, "[%s][%s] error-L3 : pTransaction(%d) status2",gObj[aIndex].AccountID,gObj[aIndex].Name,gObj[aIndex].pTransaction);

  00048	0f be c0	 movsx	 eax, al
  0004b	50		 push	 eax
  0004c	8d 8e 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00052	51		 push	 ecx
  00053	8d 96 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  00059	52		 push	 edx
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@FHLLPNOD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransaction@
  0005f	6a 00		 push	 0
  00061	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00066	83 c4 14	 add	 esp, 20			; 00000014H

; 7449 : 		return false;

  00069	33 c0		 xor	 eax, eax
  0006b	5e		 pop	 esi

; 7469 : }

  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN7@gObjInvent@7:
  0006e	53		 push	 ebx

; 7450 : 	}
; 7451 : 
; 7452 : 	for(int n = 0; n < MAX_MAGIC; n++)

  0006f	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00074	57		 push	 edi
  00075	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL6@gObjInvent@7:

; 7453 : 	{
; 7454 : 		gObj[aIndex].Magic[n] = gObj[aIndex].m_lpMagicBack[n];

  00080	8b 8e 34 03 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+820]
  00086	8b be 38 03 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+824]
  0008c	8d 50 d0	 lea	 edx, DWORD PTR [eax-48]
  0008f	0f b6 5c 11 04	 movzx	 ebx, BYTE PTR [ecx+edx+4]
  00094	88 5c 17 04	 mov	 BYTE PTR [edi+edx+4], bl
  00098	0f b6 5c 11 05	 movzx	 ebx, BYTE PTR [ecx+edx+5]
  0009d	88 5c 17 05	 mov	 BYTE PTR [edi+edx+5], bl
  000a1	8b 5c 11 08	 mov	 ebx, DWORD PTR [ecx+edx+8]
  000a5	89 5c 17 08	 mov	 DWORD PTR [edi+edx+8], ebx
  000a9	03 ca		 add	 ecx, edx
  000ab	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  000ae	89 4c 17 0c	 mov	 DWORD PTR [edi+edx+12], ecx
  000b2	8b 8e 34 03 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+820]
  000b8	03 fa		 add	 edi, edx
  000ba	8b be 38 03 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+824]
  000c0	8d 4c 0a 10	 lea	 ecx, DWORD PTR [edx+ecx+16]
  000c4	8d 7c 3a 10	 lea	 edi, DWORD PTR [edx+edi+16]
  000c8	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  000cc	88 57 04	 mov	 BYTE PTR [edi+4], dl
  000cf	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  000d3	88 57 05	 mov	 BYTE PTR [edi+5], dl
  000d6	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d9	89 57 08	 mov	 DWORD PTR [edi+8], edx
  000dc	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  000df	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  000e2	8b 8e 34 03 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+820]
  000e8	8b be 38 03 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+824]
  000ee	8d 50 f0	 lea	 edx, DWORD PTR [eax-16]
  000f1	03 ca		 add	 ecx, edx
  000f3	03 fa		 add	 edi, edx
  000f5	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  000f9	88 57 04	 mov	 BYTE PTR [edi+4], dl
  000fc	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  00100	88 57 05	 mov	 BYTE PTR [edi+5], dl
  00103	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00106	89 57 08	 mov	 DWORD PTR [edi+8], edx
  00109	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0010c	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  0010f	8b 8e 34 03 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+820]
  00115	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  0011a	8b be 38 03 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+824]
  00120	88 54 07 04	 mov	 BYTE PTR [edi+eax+4], dl
  00124	0f b6 54 01 05	 movzx	 edx, BYTE PTR [ecx+eax+5]
  00129	88 54 07 05	 mov	 BYTE PTR [edi+eax+5], dl
  0012d	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00131	03 c8		 add	 ecx, eax
  00133	89 54 07 08	 mov	 DWORD PTR [edi+eax+8], edx
  00137	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0013a	89 4c 07 0c	 mov	 DWORD PTR [edi+eax+12], ecx
  0013e	8b 8e 34 03 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+820]
  00144	03 f8		 add	 edi, eax
  00146	8b be 38 03 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+824]
  0014c	8d 50 10	 lea	 edx, DWORD PTR [eax+16]
  0014f	03 fa		 add	 edi, edx
  00151	03 ca		 add	 ecx, edx
  00153	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00157	88 57 04	 mov	 BYTE PTR [edi+4], dl
  0015a	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  0015e	88 57 05	 mov	 BYTE PTR [edi+5], dl
  00161	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00164	89 57 08	 mov	 DWORD PTR [edi+8], edx
  00167	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0016a	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  0016d	8b 8e 34 03 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+820]
  00173	8b be 38 03 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+824]
  00179	8d 50 20	 lea	 edx, DWORD PTR [eax+32]
  0017c	03 fa		 add	 edi, edx
  0017e	03 ca		 add	 ecx, edx
  00180	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00184	88 57 04	 mov	 BYTE PTR [edi+4], dl
  00187	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  0018b	88 57 05	 mov	 BYTE PTR [edi+5], dl
  0018e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00191	89 57 08	 mov	 DWORD PTR [edi+8], edx
  00194	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00197	83 c0 60	 add	 eax, 96			; 00000060H
  0019a	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  0019d	3d f0 03 00 00	 cmp	 eax, 1008		; 000003f0H
  001a2	0f 8c d8 fe ff
	ff		 jl	 $LL6@gObjInvent@7

; 7455 : 	}
; 7456 : 
; 7457 : 	for(int n = 0; n < INVENTORY_SIZE; n++)

  001a8	33 ff		 xor	 edi, edi
  001aa	8d 9b 00 00 00
	00		 npad	 6
$LL3@gObjInvent@7:

; 7458 : 	{
; 7459 : 		gObj[aIndex].Inventory2[n].Clear();

  001b0	8b 8e a8 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3240]
  001b6	03 cf		 add	 ecx, edi
  001b8	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  001bd	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  001c3	81 ff e0 46 00
	00		 cmp	 edi, 18144		; 000046e0H
  001c9	7c e5		 jl	 SHORT $LL3@gObjInvent@7

; 7460 : 	}
; 7461 : 
; 7462 : 	gObjSetInventory1Pointer(&gObj[aIndex]);

  001cb	8d 96 00 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  001d1	52		 push	 edx
  001d2	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer

; 7463 : 
; 7464 : 	gObj[aIndex].pTransaction = 3;
; 7465 : 
; 7466 : 	LogAdd(LOG_BLACK, "Trade Rollback (%s)",gObj[aIndex].Name);

  001d7	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  001dd	50		 push	 eax
  001de	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GIFOPHN@Trade?5Rollback?5?$CI?$CFs?$CJ?$AA@
  001e3	6a 00		 push	 0
  001e5	c6 86 98 0c 00
	00 03		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3224], 3
  001ec	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001f1	83 c4 10	 add	 esp, 16			; 00000010H
  001f4	5f		 pop	 edi
  001f5	5b		 pop	 ebx

; 7467 : 
; 7468 : 	return true;

  001f6	b8 01 00 00 00	 mov	 eax, 1
  001fb	5e		 pop	 esi

; 7469 : }

  001fc	5d		 pop	 ebp
  001fd	c3		 ret	 0
?gObjInventoryRollback@@YAHH@Z ENDP			; gObjInventoryRollback
_TEXT	ENDS
PUBLIC	?gObjInventoryItemSet@@YAXHHE@Z			; gObjInventoryItemSet
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventoryItemSet@@YAXHHE@Z
_TEXT	SEGMENT
_width$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_height$ = 12						; size = 4
_itempos$ = 12						; size = 4
_set_byte$ = 16						; size = 1
?gObjInventoryItemSet@@YAXHHE@Z PROC			; gObjInventoryItemSet, COMDAT

; 7472 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 7473 : 	int width;
; 7474 : 	int height;
; 7475 : 	if(itempos < INVETORY_WEAR_SIZE)

  00005	8b 75 0c	 mov	 esi, DWORD PTR _itempos$[ebp]
  00008	8d 46 f4	 lea	 eax, DWORD PTR [esi-12]
  0000b	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  0000e	77 6c		 ja	 SHORT $LN5@gObjInvent@8

; 7476 : 	{
; 7477 : 		return;
; 7478 : 	}
; 7479 : 	else if(itempos > (INVENTORY_SIZE-1))
; 7480 : 	{
; 7481 : 		return;
; 7482 : 	}
; 7483 : 
; 7484 : 	if(gObj[aIndex].pInventory[itempos].GetSize((int&)width,(int &)height)==0)

  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00014	8d 4d 0c	 lea	 ecx, DWORD PTR _height$[ebp]
  00017	51		 push	 ecx
  00018	8b c7		 mov	 eax, edi
  0001a	8b ce		 mov	 ecx, esi
  0001c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00022	69 c9 a8 00 00
	00		 imul	 ecx, 168		; 000000a8H
  00028	03 88 8c 0c 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3212]
  0002e	8d 55 fc	 lea	 edx, DWORD PTR _width$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00037	85 c0		 test	 eax, eax
  00039	75 2a		 jne	 SHORT $LN1@gObjInvent@8

; 7485 : 	{
; 7486 : 		LogAdd(LOG_BLACK, lMsg.Get(527),__FILE__,__LINE__);

  0003b	68 3e 1d 00 00	 push	 7486			; 00001d3eH
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00045	68 0f 02 00 00	 push	 527			; 0000020fH
  0004a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0004f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00054	50		 push	 eax
  00055	6a 00		 push	 0
  00057	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0005c	83 c4 10	 add	 esp, 16			; 00000010H
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 7491 : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN1@gObjInvent@8:

; 7487 : 		return;
; 7488 : 	}
; 7489 : 
; 7490 : 	gObjInventoryItemBoxSet(aIndex,itempos,width,height,set_byte);

  00065	8b 4d 10	 mov	 ecx, DWORD PTR _set_byte$[ebp]
  00068	8b 55 0c	 mov	 edx, DWORD PTR _height$[ebp]
  0006b	8b 45 fc	 mov	 eax, DWORD PTR _width$[ebp]
  0006e	51		 push	 ecx
  0006f	52		 push	 edx
  00070	50		 push	 eax
  00071	56		 push	 esi
  00072	57		 push	 edi
  00073	e8 00 00 00 00	 call	 ?gObjInventoryItemBoxSet@@YAXHHHHE@Z ; gObjInventoryItemBoxSet
  00078	83 c4 14	 add	 esp, 20			; 00000014H
  0007b	5f		 pop	 edi
$LN5@gObjInvent@8:
  0007c	5e		 pop	 esi

; 7491 : }

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
?gObjInventoryItemSet@@YAXHHE@Z ENDP			; gObjInventoryItemSet
_TEXT	ENDS
PUBLIC	?gObjInventoryItemSet_PShop@@YAXHHE@Z		; gObjInventoryItemSet_PShop
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventoryItemSet_PShop@@YAXHHE@Z
_TEXT	SEGMENT
_width$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_height$ = 12						; size = 4
_itempos$ = 12						; size = 4
_set_byte$ = 16						; size = 1
?gObjInventoryItemSet_PShop@@YAXHHE@Z PROC		; gObjInventoryItemSet_PShop, COMDAT

; 7564 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 7565 : 	int width;
; 7566 : 	int height;
; 7567 : 	if(itempos < INVETORY_WEAR_SIZE)

  00005	8b 75 0c	 mov	 esi, DWORD PTR _itempos$[ebp]
  00008	8d 46 f4	 lea	 eax, DWORD PTR [esi-12]
  0000b	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  0000e	77 6c		 ja	 SHORT $LN5@gObjInvent@9

; 7568 : 	{
; 7569 : 		return;
; 7570 : 	}
; 7571 : 	else if(itempos > (INVENTORY_SIZE-1))
; 7572 : 	{
; 7573 : 		return;
; 7574 : 	}
; 7575 : 
; 7576 : 	if(gObj[aIndex].Inventory1[itempos].GetSize((int&)width,(int &)height)==0)

  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00014	8d 4d 0c	 lea	 ecx, DWORD PTR _height$[ebp]
  00017	51		 push	 ecx
  00018	8b c7		 mov	 eax, edi
  0001a	8b ce		 mov	 ecx, esi
  0001c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00022	69 c9 a8 00 00
	00		 imul	 ecx, 168		; 000000a8H
  00028	03 88 9c 0c 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3228]
  0002e	8d 55 fc	 lea	 edx, DWORD PTR _width$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00037	85 c0		 test	 eax, eax
  00039	75 2a		 jne	 SHORT $LN1@gObjInvent@9

; 7577 : 	{
; 7578 : 		LogAdd(LOG_BLACK, lMsg.Get(527),__FILE__,__LINE__);

  0003b	68 9a 1d 00 00	 push	 7578			; 00001d9aH
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00045	68 0f 02 00 00	 push	 527			; 0000020fH
  0004a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0004f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00054	50		 push	 eax
  00055	6a 00		 push	 0
  00057	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0005c	83 c4 10	 add	 esp, 16			; 00000010H
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 7583 : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN1@gObjInvent@9:

; 7579 : 		return;
; 7580 : 	}
; 7581 : 
; 7582 : 	gObjInventoryItemBoxSet_PShop(aIndex,itempos,width,height,set_byte);

  00065	8b 4d 10	 mov	 ecx, DWORD PTR _set_byte$[ebp]
  00068	8b 55 0c	 mov	 edx, DWORD PTR _height$[ebp]
  0006b	8b 45 fc	 mov	 eax, DWORD PTR _width$[ebp]
  0006e	51		 push	 ecx
  0006f	52		 push	 edx
  00070	50		 push	 eax
  00071	56		 push	 esi
  00072	57		 push	 edi
  00073	e8 00 00 00 00	 call	 ?gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z ; gObjInventoryItemBoxSet_PShop
  00078	83 c4 14	 add	 esp, 20			; 00000014H
  0007b	5f		 pop	 edi
$LN5@gObjInvent@9:
  0007c	5e		 pop	 esi

; 7583 : }

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
?gObjInventoryItemSet_PShop@@YAXHHE@Z ENDP		; gObjInventoryItemSet_PShop
_TEXT	ENDS
PUBLIC	?gObjInventoryDeleteItem@@YAEHH@Z		; gObjInventoryDeleteItem
EXTRN	?GCMagicListOneDelSend@@YAXHDEEEE@Z:PROC	; GCMagicListOneDelSend
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventoryDeleteItem@@YAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
?gObjInventoryDeleteItem@@YAEHH@Z PROC			; gObjInventoryDeleteItem, COMDAT

; 7614 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 7615 : 	if(itempos < INVETORY_WEAR_SIZE)

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _itempos$[ebp]
  00008	83 ff 0c	 cmp	 edi, 12			; 0000000cH
  0000b	7d 6b		 jge	 SHORT $LN3@gObjInvent@10

; 7616 : 	{
; 7617 : 		int MagicDel = gObjMagicDel(&gObj[aIndex],gObj[aIndex].pInventory[itempos].m_Special[0],gObj[aIndex].pInventory[itempos].m_Level);

  0000d	53		 push	 ebx
  0000e	69 ff a8 00 00
	00		 imul	 edi, 168		; 000000a8H
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00017	8b f3		 mov	 esi, ebx
  00019	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0001f	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  00025	0f b6 4c 38 08	 movzx	 ecx, BYTE PTR [eax+edi+8]
  0002a	0f b6 54 38 31	 movzx	 edx, BYTE PTR [eax+edi+49]
  0002f	51		 push	 ecx
  00030	52		 push	 edx
  00031	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?gObjMagicDel@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicDel
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7618 : 
; 7619 : 		if(MagicDel >= 0)

  00040	85 c0		 test	 eax, eax
  00042	78 20		 js	 SHORT $LN2@gObjInvent@10

; 7620 : 		{
; 7621 : 			GCMagicListOneDelSend(aIndex,MagicDel,
; 7622 : 				gObj[aIndex].pInventory[itempos].m_Special[0],
; 7623 : 				gObj[aIndex].pInventory[itempos].m_Level,0,0);

  00044	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  0004a	0f b6 54 39 08	 movzx	 edx, BYTE PTR [ecx+edi+8]
  0004f	0f b6 4c 39 31	 movzx	 ecx, BYTE PTR [ecx+edi+49]
  00054	6a 00		 push	 0
  00056	6a 00		 push	 0
  00058	52		 push	 edx
  00059	51		 push	 ecx
  0005a	50		 push	 eax
  0005b	53		 push	 ebx
  0005c	e8 00 00 00 00	 call	 ?GCMagicListOneDelSend@@YAXHDEEEE@Z ; GCMagicListOneDelSend
  00061	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@gObjInvent@10:

; 7624 : 		}
; 7625 : 
; 7626 : 		gObj[aIndex].pInventory[itempos].Clear();

  00064	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  0006a	03 cf		 add	 ecx, edi
  0006c	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  00071	5b		 pop	 ebx
  00072	5f		 pop	 edi

; 7632 : 	}
; 7633 : 
; 7634 : 	return true;

  00073	b0 01		 mov	 al, 1
  00075	5e		 pop	 esi

; 7635 : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
$LN3@gObjInvent@10:

; 7627 : 	}
; 7628 : 	else
; 7629 : 	{
; 7630 : 		gObjInventoryItemSet(aIndex,itempos,255);

  00078	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0007b	68 ff 00 00 00	 push	 255			; 000000ffH
  00080	57		 push	 edi
  00081	56		 push	 esi
  00082	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 7631 : 		gObj[aIndex].pInventory[itempos].Clear();

  00087	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0008d	8b cf		 mov	 ecx, edi
  0008f	69 c9 a8 00 00
	00		 imul	 ecx, 168		; 000000a8H
  00095	03 8e 8c 0c 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009e	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  000a3	5f		 pop	 edi

; 7632 : 	}
; 7633 : 
; 7634 : 	return true;

  000a4	b0 01		 mov	 al, 1
  000a6	5e		 pop	 esi

; 7635 : }

  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
?gObjInventoryDeleteItem@@YAEHH@Z ENDP			; gObjInventoryDeleteItem
_TEXT	ENDS
PUBLIC	?gObjWarehouseDeleteItem@@YAEHH@Z		; gObjWarehouseDeleteItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjWarehouseDeleteItem@@YAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
?gObjWarehouseDeleteItem@@YAEHH@Z PROC			; gObjWarehouseDeleteItem, COMDAT

; 7638 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 7639 : 	gObjWarehouseItemSet(aIndex, itempos, -1);

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR _itempos$[ebp]
  0000b	68 ff 00 00 00	 push	 255			; 000000ffH
  00010	57		 push	 edi
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ?gObjWarehouseItemSet@@YAXHHE@Z ; gObjWarehouseItemSet

; 7640 : 	gObj[aIndex].pWarehouse[itempos].Clear();

  00017	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0001d	8b cf		 mov	 ecx, edi
  0001f	69 c9 a8 00 00
	00		 imul	 ecx, 168		; 000000a8H
  00025	03 8e c4 0c 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3268]
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  00033	5f		 pop	 edi

; 7641 : 
; 7642 : 	return true;

  00034	b0 01		 mov	 al, 1
  00036	5e		 pop	 esi

; 7643 : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?gObjWarehouseDeleteItem@@YAEHH@Z ENDP			; gObjWarehouseDeleteItem
_TEXT	ENDS
PUBLIC	?gObjChaosBoxDeleteItem@@YAEHH@Z		; gObjChaosBoxDeleteItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjChaosBoxDeleteItem@@YAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
?gObjChaosBoxDeleteItem@@YAEHH@Z PROC			; gObjChaosBoxDeleteItem, COMDAT

; 7646 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 7647 : 	gObjChaosItemSet(aIndex, itempos, -1);

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR _itempos$[ebp]
  0000b	68 ff 00 00 00	 push	 255			; 000000ffH
  00010	57		 push	 edi
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ?gObjChaosItemSet@@YAXHHE@Z ; gObjChaosItemSet

; 7648 : 	gObj[aIndex].pChaosBox[itempos].Clear();

  00017	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0001d	8b cf		 mov	 ecx, edi
  0001f	69 c9 a8 00 00
	00		 imul	 ecx, 168		; 000000a8H
  00025	03 8e dc 0c 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3292]
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  00033	5f		 pop	 edi

; 7649 : 
; 7650 : 	return true;

  00034	b0 01		 mov	 al, 1
  00036	5e		 pop	 esi

; 7651 : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?gObjChaosBoxDeleteItem@@YAEHH@Z ENDP			; gObjChaosBoxDeleteItem
_TEXT	ENDS
PUBLIC	?gObjInventoryInsertItem@@YAEHH@Z		; gObjInventoryInsertItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventoryInsertItem@@YAEHH@Z
_TEXT	SEGMENT
tv236 = -16						; size = 4
tv231 = -12						; size = 4
_iwidth$ = -8						; size = 4
tv224 = -4						; size = 4
_aIndex$ = 8						; size = 4
_iheight$ = 12						; size = 4
_item_num$ = 12						; size = 4
?gObjInventoryInsertItem@@YAEHH@Z PROC			; gObjInventoryInsertItem, COMDAT

; 7654 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 7655 : 	int w,h,map_num,iwidth,iheight;
; 7656 : 	BYTE blank;
; 7657 : 
; 7658 : 	blank = 0;
; 7659 : 	map_num = gObj[aIndex].MapNumber;
; 7660 : 
; 7661 : 	if(MapC[map_num].m_cItem[item_num].live == 0)

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _item_num$[ebp]
  00009	53		 push	 ebx
  0000a	69 c9 48 04 00
	00		 imul	 ecx, 1096		; 00000448H
  00010	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00013	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  00019	0f b6 83 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+265]
  00020	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  00026	03 c1		 add	 eax, ecx
  00028	80 b8 ce 00 00
	00 00		 cmp	 BYTE PTR ?MapC@@3PAVMapClass@@A[eax+206], 0
  0002f	89 5d fc	 mov	 DWORD PTR tv224[ebp], ebx
  00032	89 45 f4	 mov	 DWORD PTR tv231[ebp], eax

; 7662 : 	{
; 7663 : 		return -1;

  00035	74 3e		 je	 SHORT $LN26@gObjInvent@11

; 7664 : 	}
; 7665 : 
; 7666 : 	if(MapC[map_num].m_cItem[item_num].GetSize((int &)iwidth,(int &)iheight) == 0)

  00037	8d 88 24 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+36]
  0003d	8d 55 0c	 lea	 edx, DWORD PTR _iheight$[ebp]
  00040	52		 push	 edx
  00041	8d 45 f8	 lea	 eax, DWORD PTR _iwidth$[ebp]
  00044	50		 push	 eax
  00045	89 4d f0	 mov	 DWORD PTR tv236[ebp], ecx
  00048	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0004d	85 c0		 test	 eax, eax
  0004f	75 2b		 jne	 SHORT $LN11@gObjInvent@11

; 7667 : 	{
; 7668 : 		LogAdd(LOG_BLACK, lMsg.Get(527),__FILE__,__LINE__);

  00051	68 f4 1d 00 00	 push	 7668			; 00001df4H
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0005b	68 0f 02 00 00	 push	 527			; 0000020fH
  00060	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00065	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0006a	50		 push	 eax
  0006b	6a 00		 push	 0
  0006d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00072	83 c4 10	 add	 esp, 16			; 00000010H
$LN26@gObjInvent@11:

; 7669 : 		return -1;

  00075	0c ff		 or	 al, 255			; 000000ffH
  00077	5b		 pop	 ebx

; 7696 : 
; 7697 : }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN11@gObjInvent@11:
  0007c	57		 push	 edi

; 7670 : 	}
; 7671 : 
; 7672 : 	for(h = 0; h < 8; h++)

  0007d	33 ff		 xor	 edi, edi
  0007f	56		 push	 esi
$LL23@gObjInvent@11:

; 7673 : 	{
; 7674 : 		for(w = 0; w < 8; w++)

  00080	33 f6		 xor	 esi, esi
$LL7@gObjInvent@11:

; 7675 : 		{
; 7676 : 			if(*(BYTE*)(gObj[aIndex].pInventoryMap+h*8+w) == 255)

  00082	8b 93 90 0c 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3216]
  00088	8d 0c fe	 lea	 ecx, DWORD PTR [esi+edi*8]
  0008b	80 3c 11 ff	 cmp	 BYTE PTR [ecx+edx], 255	; 000000ffH
  0008f	75 25		 jne	 SHORT $LN6@gObjInvent@11

; 7677 : 			{
; 7678 : 				blank = gObjInventoryRectCheck(aIndex,w,h,iwidth,iheight);

  00091	8b 45 0c	 mov	 eax, DWORD PTR _iheight$[ebp]
  00094	8b 4d f8	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  00097	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0009a	50		 push	 eax
  0009b	51		 push	 ecx
  0009c	57		 push	 edi
  0009d	56		 push	 esi
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  000a4	8a d8		 mov	 bl, al
  000a6	83 c4 14	 add	 esp, 20			; 00000014H

; 7679 : 
; 7680 : 				if(blank == 254)

  000a9	80 fb fe	 cmp	 bl, 254			; 000000feH
  000ac	74 14		 je	 SHORT $GOTO_EndFunc$164336

; 7681 : 				{
; 7682 : 					goto GOTO_EndFunc;
; 7683 : 				}
; 7684 : 
; 7685 : 				if(blank != 255)

  000ae	80 fb ff	 cmp	 bl, 255			; 000000ffH
  000b1	75 18		 jne	 SHORT $LN20@gObjInvent@11
  000b3	8b 5d fc	 mov	 ebx, DWORD PTR tv224[ebp]
$LN6@gObjInvent@11:

; 7673 : 	{
; 7674 : 		for(w = 0; w < 8; w++)

  000b6	46		 inc	 esi
  000b7	83 fe 08	 cmp	 esi, 8
  000ba	7c c6		 jl	 SHORT $LL7@gObjInvent@11

; 7670 : 	}
; 7671 : 
; 7672 : 	for(h = 0; h < 8; h++)

  000bc	47		 inc	 edi
  000bd	83 ff 08	 cmp	 edi, 8
  000c0	7c be		 jl	 SHORT $LL23@gObjInvent@11
$GOTO_EndFunc$164336:
  000c2	5e		 pop	 esi
  000c3	5f		 pop	 edi

; 7690 : 				}
; 7691 : 			}
; 7692 : 		}
; 7693 : 	}
; 7694 : GOTO_EndFunc:
; 7695 : 	return -1;

  000c4	0c ff		 or	 al, 255			; 000000ffH
  000c6	5b		 pop	 ebx

; 7696 : 
; 7697 : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
$LN20@gObjInvent@11:

; 7686 : 				{
; 7687 : 					gObj[aIndex].pInventory[blank] = MapC[map_num].m_cItem[item_num];

  000cb	8b 75 f4	 mov	 esi, DWORD PTR tv231[ebp]
  000ce	8b 4d fc	 mov	 ecx, DWORD PTR tv224[ebp]
  000d1	8b b9 8c 0c 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3212]
  000d7	8d b6 20 00 00
	00		 lea	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A[esi+32]
  000dd	0f b6 d3	 movzx	 edx, bl
  000e0	f7 de		 neg	 esi
  000e2	1b f6		 sbb	 esi, esi
  000e4	23 75 f0	 and	 esi, DWORD PTR tv236[ebp]
  000e7	8b c2		 mov	 eax, edx
  000e9	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  000ef	03 f8		 add	 edi, eax
  000f1	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000f6	f3 a5		 rep movsd

; 7688 : 					gObjInventoryItemSet(aIndex,blank,gObj[aIndex].pInventory[blank].m_Type);

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR tv224[ebp]
  000fb	8b 89 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3212]
  00101	0f b6 44 01 06	 movzx	 eax, BYTE PTR [ecx+eax+6]
  00106	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00109	50		 push	 eax
  0010a	52		 push	 edx
  0010b	51		 push	 ecx
  0010c	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH
  00114	5e		 pop	 esi
  00115	5f		 pop	 edi

; 7689 : 					return blank;

  00116	8a c3		 mov	 al, bl
  00118	5b		 pop	 ebx

; 7696 : 
; 7697 : }

  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
?gObjInventoryInsertItem@@YAEHH@Z ENDP			; gObjInventoryInsertItem
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	?gObjInventoryInsertItem@@YAEHVCItem@@@Z	; gObjInventoryInsertItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventoryInsertItem@@YAEHVCItem@@@Z
_TEXT	SEGMENT
_iwidth$ = -16						; size = 4
_iheight$ = -12						; size = 4
tv195 = -8						; size = 4
_aIndex$GSCopy$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 168
?gObjInventoryInsertItem@@YAEHVCItem@@@Z PROC		; gObjInventoryInsertItem, COMDAT

; 7710 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 7711 : 	int w,h,iwidth,iheight;
; 7712 : 	BYTE blank = 0;
; 7713 : 
; 7714 : 	if(item.GetSize((int&)iwidth,(int&)iheight)==0)

  0000a	8d 45 f4	 lea	 eax, DWORD PTR _iheight$[ebp]
  0000d	50		 push	 eax
  0000e	8d 4d f0	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00011	51		 push	 ecx
  00012	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]

; 7744 : 					}
; 7745 : 
; 7746 : 					gObj[aIndex].pInventory[blank] = item;

  00015	89 5d fc	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  00018	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0001d	85 c0		 test	 eax, eax
  0001f	75 2b		 jne	 SHORT $LN13@gObjInvent@12

; 7715 : 	{
; 7716 : 		LogAdd(LOG_BLACK, lMsg.Get(527),__FILE__,__LINE__);

  00021	68 24 1e 00 00	 push	 7716			; 00001e24H
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0002b	68 0f 02 00 00	 push	 527			; 0000020fH
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00035	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0003a	50		 push	 eax
  0003b	6a 00		 push	 0
  0003d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 7717 : 		return -1;

  00045	0c ff		 or	 al, 255			; 000000ffH
  00047	5b		 pop	 ebx

; 7757 : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN13@gObjInvent@12:
  0004c	57		 push	 edi

; 7718 : 	}
; 7719 : 
; 7720 : 	for(h = 0; h < 8; h++)

  0004d	8b c3		 mov	 eax, ebx
  0004f	33 ff		 xor	 edi, edi
  00051	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 7744 : 					}
; 7745 : 
; 7746 : 					gObj[aIndex].pInventory[blank] = item;

  00057	89 45 f8	 mov	 DWORD PTR tv195[ebp], eax
  0005a	56		 push	 esi
  0005b	eb 03 8d 49 00	 npad	 5
$LL23@gObjInvent@12:

; 7721 : 	{
; 7722 : 		for( w = 0; w < 8; w++)

  00060	33 f6		 xor	 esi, esi
$LL9@gObjInvent@12:

; 7723 : 		{
; 7724 : 			if(*(BYTE*)(gObj[aIndex].pInventoryMap+h*8+w) == 255)

  00062	8b 88 90 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3216]
  00068	8d 14 fe	 lea	 edx, DWORD PTR [esi+edi*8]
  0006b	80 3c 0a ff	 cmp	 BYTE PTR [edx+ecx], 255	; 000000ffH
  0006f	75 25		 jne	 SHORT $LN8@gObjInvent@12

; 7725 : 			{
; 7726 : 				blank = gObjInventoryRectCheck(aIndex,w,h,iwidth,iheight);

  00071	8b 55 f4	 mov	 edx, DWORD PTR _iheight$[ebp]
  00074	8b 45 f0	 mov	 eax, DWORD PTR _iwidth$[ebp]
  00077	52		 push	 edx
  00078	50		 push	 eax
  00079	57		 push	 edi
  0007a	56		 push	 esi
  0007b	53		 push	 ebx
  0007c	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  00081	8a d8		 mov	 bl, al
  00083	83 c4 14	 add	 esp, 20			; 00000014H

; 7727 : 
; 7728 : 				if(blank == 254)

  00086	80 fb fe	 cmp	 bl, 254			; 000000feH
  00089	74 17		 je	 SHORT $GOTO_EndFunc$164364

; 7729 : 				{
; 7730 : 					goto GOTO_EndFunc;
; 7731 : 				}
; 7732 : 
; 7733 : 				if(blank != 255)

  0008b	80 fb ff	 cmp	 bl, 255			; 000000ffH
  0008e	75 1b		 jne	 SHORT $LN19@gObjInvent@12
  00090	8b 5d fc	 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
  00093	8b 45 f8	 mov	 eax, DWORD PTR tv195[ebp]
$LN8@gObjInvent@12:

; 7721 : 	{
; 7722 : 		for( w = 0; w < 8; w++)

  00096	46		 inc	 esi
  00097	83 fe 08	 cmp	 esi, 8
  0009a	7c c6		 jl	 SHORT $LL9@gObjInvent@12

; 7718 : 	}
; 7719 : 
; 7720 : 	for(h = 0; h < 8; h++)

  0009c	47		 inc	 edi
  0009d	83 ff 08	 cmp	 edi, 8
  000a0	7c be		 jl	 SHORT $LL23@gObjInvent@12
$GOTO_EndFunc$164364:
  000a2	5e		 pop	 esi
  000a3	5f		 pop	 edi

; 7750 : 				}
; 7751 : 			}
; 7752 : 		}
; 7753 : 	}
; 7754 : 
; 7755 : GOTO_EndFunc:
; 7756 : 	return -1;

  000a4	0c ff		 or	 al, 255			; 000000ffH
  000a6	5b		 pop	 ebx

; 7757 : }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
$LN19@gObjInvent@12:

; 7734 : 				{
; 7735 : 					if(gObjCheckSerial0ItemList(&item)!=0)

  000ab	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  000b4	83 c4 04	 add	 esp, 4
  000b7	85 c0		 test	 eax, eax
  000b9	74 25		 je	 SHORT $LN2@gObjInvent@12

; 7736 : 					{
; 7737 : 						MsgOutput(aIndex,lMsg.Get(3354));

  000bb	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  000c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000c5	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000ca	8b 55 fc	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  000cd	50		 push	 eax
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000d4	83 c4 08	 add	 esp, 8
  000d7	5e		 pop	 esi
  000d8	5f		 pop	 edi

; 7750 : 				}
; 7751 : 			}
; 7752 : 		}
; 7753 : 	}
; 7754 : 
; 7755 : GOTO_EndFunc:
; 7756 : 	return -1;

  000d9	0c ff		 or	 al, 255			; 000000ffH
  000db	5b		 pop	 ebx

; 7757 : }

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN2@gObjInvent@12:

; 7738 : 						return -1;
; 7739 : 					}
; 7740 : 
; 7741 : 					if(gObjInventorySearchSerialNumber(&gObj[aIndex],item.m_Number) == 0)

  000e0	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  000e3	8b 75 f8	 mov	 esi, DWORD PTR tv195[ebp]
  000e6	50		 push	 eax
  000e7	8d 8e 00 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000ed	51		 push	 ecx
  000ee	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  000f3	83 c4 08	 add	 esp, 8
  000f6	85 c0		 test	 eax, eax

; 7742 : 					{
; 7743 : 						return -1;

  000f8	74 a8		 je	 SHORT $GOTO_EndFunc$164364

; 7744 : 					}
; 7745 : 
; 7746 : 					gObj[aIndex].pInventory[blank] = item;

  000fa	8b be 8c 0c 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  00100	0f b6 d3	 movzx	 edx, bl
  00103	8b c2		 mov	 eax, edx
  00105	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  0010b	03 f8		 add	 edi, eax
  0010d	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00112	8d 75 0c	 lea	 esi, DWORD PTR _item$[ebp]
  00115	f3 a5		 rep movsd

; 7747 : 
; 7748 : 					gObjInventoryItemSet(aIndex,blank,gObj[aIndex].pInventory[blank].m_Type);

  00117	8b 4d f8	 mov	 ecx, DWORD PTR tv195[ebp]
  0011a	8b 89 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3212]
  00120	0f b6 44 01 06	 movzx	 eax, BYTE PTR [ecx+eax+6]
  00125	8b 4d fc	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00128	50		 push	 eax
  00129	52		 push	 edx
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
  00133	5e		 pop	 esi
  00134	5f		 pop	 edi

; 7749 : 					return blank;

  00135	8a c3		 mov	 al, bl
  00137	5b		 pop	 ebx

; 7757 : }

  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c3		 ret	 0
?gObjInventoryInsertItem@@YAEHVCItem@@@Z ENDP		; gObjInventoryInsertItem
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z	; gObjOnlyInventoryInsertItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z
_TEXT	SEGMENT
_iwidth$ = -16						; size = 4
_iheight$ = -12						; size = 4
tv195 = -8						; size = 4
_aIndex$GSCopy$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 168
?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z PROC	; gObjOnlyInventoryInsertItem, COMDAT

; 7760 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 7761 : 		int w,h,iwidth,iheight;
; 7762 : 	BYTE blank = 0;
; 7763 : 
; 7764 : 	if(item.GetSize((int&)iwidth,(int&)iheight)==0)

  0000a	8d 45 f4	 lea	 eax, DWORD PTR _iheight$[ebp]
  0000d	50		 push	 eax
  0000e	8d 4d f0	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00011	51		 push	 ecx
  00012	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]

; 7794 : 					}
; 7795 : 
; 7796 : 					gObj[aIndex].pInventory[blank] = item;

  00015	89 5d fc	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  00018	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0001d	85 c0		 test	 eax, eax
  0001f	75 2b		 jne	 SHORT $LN13@gObjOnlyIn@2

; 7765 : 	{
; 7766 : 		LogAdd(LOG_BLACK, lMsg.Get(527),__FILE__,__LINE__);

  00021	68 56 1e 00 00	 push	 7766			; 00001e56H
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0002b	68 0f 02 00 00	 push	 527			; 0000020fH
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00035	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0003a	50		 push	 eax
  0003b	6a 00		 push	 0
  0003d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 7767 : 		return -1;

  00045	0c ff		 or	 al, 255			; 000000ffH
  00047	5b		 pop	 ebx

; 7807 : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN13@gObjOnlyIn@2:
  0004c	57		 push	 edi

; 7768 : 	}
; 7769 : 
; 7770 : 	for(h = 0; h < 8; h++)

  0004d	8b c3		 mov	 eax, ebx
  0004f	33 ff		 xor	 edi, edi
  00051	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 7794 : 					}
; 7795 : 
; 7796 : 					gObj[aIndex].pInventory[blank] = item;

  00057	89 45 f8	 mov	 DWORD PTR tv195[ebp], eax
  0005a	56		 push	 esi
  0005b	eb 03 8d 49 00	 npad	 5
$LL23@gObjOnlyIn@2:

; 7771 : 	{
; 7772 : 		for( w = 0; w < 8; w++)

  00060	33 f6		 xor	 esi, esi
$LL9@gObjOnlyIn@2:

; 7773 : 		{
; 7774 : 			if(*(BYTE*)(gObj[aIndex].pInventoryMap+h*8+w) == 255)

  00062	8b 88 90 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3216]
  00068	8d 14 fe	 lea	 edx, DWORD PTR [esi+edi*8]
  0006b	80 3c 0a ff	 cmp	 BYTE PTR [edx+ecx], 255	; 000000ffH
  0006f	75 25		 jne	 SHORT $LN8@gObjOnlyIn@2

; 7775 : 			{
; 7776 : 				blank = gObjOnlyInventoryRectCheck(aIndex,w,h,iwidth,iheight);

  00071	8b 55 f4	 mov	 edx, DWORD PTR _iheight$[ebp]
  00074	8b 45 f0	 mov	 eax, DWORD PTR _iwidth$[ebp]
  00077	52		 push	 edx
  00078	50		 push	 eax
  00079	57		 push	 edi
  0007a	56		 push	 esi
  0007b	53		 push	 ebx
  0007c	e8 00 00 00 00	 call	 ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ; gObjOnlyInventoryRectCheck
  00081	8a d8		 mov	 bl, al
  00083	83 c4 14	 add	 esp, 20			; 00000014H

; 7777 : 
; 7778 : 				if(blank == 254)

  00086	80 fb fe	 cmp	 bl, 254			; 000000feH
  00089	74 17		 je	 SHORT $GOTO_EndFunc$164390

; 7779 : 				{
; 7780 : 					goto GOTO_EndFunc;
; 7781 : 				}
; 7782 : 
; 7783 : 				if(blank != 255)

  0008b	80 fb ff	 cmp	 bl, 255			; 000000ffH
  0008e	75 1b		 jne	 SHORT $LN19@gObjOnlyIn@2
  00090	8b 45 f8	 mov	 eax, DWORD PTR tv195[ebp]
  00093	8b 5d fc	 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
$LN8@gObjOnlyIn@2:

; 7771 : 	{
; 7772 : 		for( w = 0; w < 8; w++)

  00096	46		 inc	 esi
  00097	83 fe 08	 cmp	 esi, 8
  0009a	7c c6		 jl	 SHORT $LL9@gObjOnlyIn@2

; 7768 : 	}
; 7769 : 
; 7770 : 	for(h = 0; h < 8; h++)

  0009c	47		 inc	 edi
  0009d	83 ff 08	 cmp	 edi, 8
  000a0	7c be		 jl	 SHORT $LL23@gObjOnlyIn@2
$GOTO_EndFunc$164390:
  000a2	5e		 pop	 esi
  000a3	5f		 pop	 edi

; 7800 : 				}
; 7801 : 			}
; 7802 : 		}
; 7803 : 	}
; 7804 : 
; 7805 : GOTO_EndFunc:
; 7806 : 	return -1;

  000a4	0c ff		 or	 al, 255			; 000000ffH
  000a6	5b		 pop	 ebx

; 7807 : }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
$LN19@gObjOnlyIn@2:

; 7784 : 				{
; 7785 : 					if(gObjCheckSerial0ItemList(&item)!=0)

  000ab	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  000b4	83 c4 04	 add	 esp, 4
  000b7	85 c0		 test	 eax, eax
  000b9	74 25		 je	 SHORT $LN2@gObjOnlyIn@2

; 7786 : 					{
; 7787 : 						MsgOutput(aIndex,lMsg.Get(3354));

  000bb	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  000c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000c5	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000ca	8b 55 fc	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  000cd	50		 push	 eax
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000d4	83 c4 08	 add	 esp, 8
  000d7	5e		 pop	 esi
  000d8	5f		 pop	 edi

; 7800 : 				}
; 7801 : 			}
; 7802 : 		}
; 7803 : 	}
; 7804 : 
; 7805 : GOTO_EndFunc:
; 7806 : 	return -1;

  000d9	0c ff		 or	 al, 255			; 000000ffH
  000db	5b		 pop	 ebx

; 7807 : }

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN2@gObjOnlyIn@2:

; 7788 : 						return -1;
; 7789 : 					}
; 7790 : 
; 7791 : 					if(gObjInventorySearchSerialNumber(&gObj[aIndex],item.m_Number) == 0)

  000e0	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  000e3	8b 75 f8	 mov	 esi, DWORD PTR tv195[ebp]
  000e6	50		 push	 eax
  000e7	8d 8e 00 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000ed	51		 push	 ecx
  000ee	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  000f3	83 c4 08	 add	 esp, 8
  000f6	85 c0		 test	 eax, eax

; 7792 : 					{
; 7793 : 						return -1;

  000f8	74 a8		 je	 SHORT $GOTO_EndFunc$164390

; 7794 : 					}
; 7795 : 
; 7796 : 					gObj[aIndex].pInventory[blank] = item;

  000fa	8b be 8c 0c 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  00100	0f b6 d3	 movzx	 edx, bl
  00103	8b c2		 mov	 eax, edx
  00105	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  0010b	03 f8		 add	 edi, eax
  0010d	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00112	8d 75 0c	 lea	 esi, DWORD PTR _item$[ebp]
  00115	f3 a5		 rep movsd

; 7797 : 
; 7798 : 					gObjInventoryItemSet(aIndex,blank,gObj[aIndex].pInventory[blank].m_Type);

  00117	8b 4d f8	 mov	 ecx, DWORD PTR tv195[ebp]
  0011a	8b 89 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3212]
  00120	0f b6 44 01 06	 movzx	 eax, BYTE PTR [ecx+eax+6]
  00125	8b 4d fc	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00128	50		 push	 eax
  00129	52		 push	 edx
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
  00133	5e		 pop	 esi
  00134	5f		 pop	 edi

; 7799 : 					return blank;

  00135	8a c3		 mov	 al, bl
  00137	5b		 pop	 ebx

; 7807 : }

  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c3		 ret	 0
?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z ENDP	; gObjOnlyInventoryInsertItem
_TEXT	ENDS
PUBLIC	??_C@_0CB@GBFBGHOP@error?5?3?5Item?5doesn?8t?5exist?5?$CFs?5?$CFd@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z	; gObjInventoryInsertItem
EXTRN	?SetPetItemInfo@CItem@@QAEXHH@Z:PROC		; CItem::SetPetItemInfo
;	COMDAT ??_C@_0CB@GBFBGHOP@error?5?3?5Item?5doesn?8t?5exist?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0CB@GBFBGHOP@error?5?3?5Item?5doesn?8t?5exist?5?$CFs?5?$CFd@ DB 'er'
	DB	'ror : Item doesn''t exist %s %d', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z
_TEXT	SEGMENT
_iwidth$ = -196						; size = 4
tv256 = -192						; size = 4
_iheight$ = -188					; size = 4
_aIndex$GSCopy$ = -184					; size = 4
_h$ = -180						; size = 4
tv260 = -176						; size = 4
_copyitem$ = -172					; size = 168
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 4
?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z PROC	; gObjInventoryInsertItem, COMDAT

; 7810 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _item$[ebp]

; 7811 : 	int w,h,iwidth,iheight;
; 7812 : 	BYTE blank = 0;
; 7813 : 
; 7814 : 	CItem copyitem;

  0001b	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _copyitem$[ebp]

; 7836 : 				{
; 7837 : 					copyitem.m_Level = item->m_Level;

  00021	89 b5 48 ff ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  00027	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  0002c	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _iheight$[ebp]
  00032	50		 push	 eax
  00033	8d 95 3c ff ff
	ff		 lea	 edx, DWORD PTR _iwidth$[ebp]
  00039	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0003c	52		 push	 edx
  0003d	89 8d 40 ff ff
	ff		 mov	 DWORD PTR tv256[ebp], ecx
  00043	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00048	85 c0		 test	 eax, eax
  0004a	75 2a		 jne	 SHORT $LN11@gObjInvent@13

; 7815 : 
; 7816 : 
; 7817 : 	if(item->GetSize((int &)iwidth,(int &)iheight)==0)
; 7818 : 	{
; 7819 : 		LogAdd(LOG_BLACK, "error : Item doesn't exist %s %d",__FILE__,__LINE__);

  0004c	68 8b 1e 00 00	 push	 7819			; 00001e8bH
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GBFBGHOP@error?5?3?5Item?5doesn?8t?5exist?5?$CFs?5?$CFd@
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00061	83 c4 10	 add	 esp, 16			; 00000010H
  00064	5f		 pop	 edi

; 7820 : 		return -1;

  00065	0c ff		 or	 al, 255			; 000000ffH
  00067	5e		 pop	 esi

; 7856 : }

  00068	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006b	33 cd		 xor	 ecx, ebp
  0006d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
$LN11@gObjInvent@13:

; 7821 : 	}
; 7822 : 
; 7823 : 	for(h = 0; h < 8; h++)

  00076	33 c0		 xor	 eax, eax
  00078	8b d6		 mov	 edx, esi
  0007a	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00080	89 85 4c ff ff
	ff		 mov	 DWORD PTR _h$[ebp], eax

; 7836 : 				{
; 7837 : 					copyitem.m_Level = item->m_Level;

  00086	89 95 50 ff ff
	ff		 mov	 DWORD PTR tv260[ebp], edx
  0008c	53		 push	 ebx
  0008d	8d 49 00	 npad	 3
$LL21@gObjInvent@13:

; 7824 : 	{
; 7825 : 		for(w = 0; w < 8; w++)

  00090	33 f6		 xor	 esi, esi
  00092	eb 0c 8d a4 24
	00 00 00 00 eb
	03 8d 49 00	 npad	 14
$LL7@gObjInvent@13:

; 7826 : 		{
; 7827 : 			if(*(BYTE*)(gObj[aIndex].pInventoryMap+h*8+w) == 255)

  000a0	8b 9a 90 0c 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3216]
  000a6	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  000ad	03 d9		 add	 ebx, ecx
  000af	80 3c 33 ff	 cmp	 BYTE PTR [ebx+esi], 255	; 000000ffH
  000b3	75 37		 jne	 SHORT $LN6@gObjInvent@13

; 7828 : 			{
; 7829 : 				blank = gObjOnlyInventoryRectCheck(aIndex,w,h,iwidth,iheight);

  000b5	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _iheight$[ebp]
  000bb	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _iwidth$[ebp]
  000c1	51		 push	 ecx
  000c2	52		 push	 edx
  000c3	50		 push	 eax
  000c4	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  000ca	56		 push	 esi
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ; gObjOnlyInventoryRectCheck
  000d1	8a d8		 mov	 bl, al
  000d3	83 c4 14	 add	 esp, 20			; 00000014H

; 7830 : 				if(blank == 254)

  000d6	80 fb fe	 cmp	 bl, 254			; 000000feH
  000d9	74 23		 je	 SHORT $GOTO_EndFunc$164418

; 7831 : 				{
; 7832 : 					goto GOTO_EndFunc;
; 7833 : 				}
; 7834 : 	
; 7835 : 				if(blank != 255)

  000db	80 fb ff	 cmp	 bl, 255			; 000000ffH
  000de	75 31		 jne	 SHORT $LN17@gObjInvent@13
  000e0	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _h$[ebp]
  000e6	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv260[ebp]
$LN6@gObjInvent@13:

; 7824 : 	{
; 7825 : 		for(w = 0; w < 8; w++)

  000ec	46		 inc	 esi
  000ed	83 fe 08	 cmp	 esi, 8
  000f0	7c ae		 jl	 SHORT $LL7@gObjInvent@13

; 7821 : 	}
; 7822 : 
; 7823 : 	for(h = 0; h < 8; h++)

  000f2	40		 inc	 eax
  000f3	89 85 4c ff ff
	ff		 mov	 DWORD PTR _h$[ebp], eax
  000f9	83 f8 08	 cmp	 eax, 8
  000fc	7c 92		 jl	 SHORT $LL21@gObjInvent@13
$GOTO_EndFunc$164418:
  000fe	5b		 pop	 ebx
  000ff	5f		 pop	 edi

; 7848 : 					return blank;
; 7849 : 				}
; 7850 : 			}
; 7851 : 		}
; 7852 : 	}
; 7853 : 
; 7854 : GOTO_EndFunc:
; 7855 : 	return -1;

  00100	0c ff		 or	 al, 255			; 000000ffH
  00102	5e		 pop	 esi

; 7856 : }

  00103	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
$LN17@gObjInvent@13:

; 7838 : 					copyitem.m_Durability = item->m_Durability;
; 7839 : 	
; 7840 : 					copyitem.Convert(item->m_Type,item->m_Option1,item->m_Option2,item->m_Option3,item->m_NewOption,item->m_SetOption, 0, CURRENT_DB_VERSION);

  00111	0f b6 97 96 00
	00 00		 movzx	 edx, BYTE PTR [edi+150]
  00118	d9 47 28	 fld	 DWORD PTR [edi+40]
  0011b	66 8b 4f 0c	 mov	 cx, WORD PTR [edi+12]
  0011f	d9 9d 78 ff ff
	ff		 fstp	 DWORD PTR _copyitem$[ebp+36]
  00125	0f b6 47 7f	 movzx	 eax, BYTE PTR [edi+127]
  00129	6a 03		 push	 3
  0012b	6a 00		 push	 0
  0012d	52		 push	 edx
  0012e	0f b6 57 7d	 movzx	 edx, BYTE PTR [edi+125]
  00132	66 89 8d 5c ff
	ff ff		 mov	 WORD PTR _copyitem$[ebp+8], cx
  00139	0f b6 4f 7e	 movzx	 ecx, BYTE PTR [edi+126]
  0013d	50		 push	 eax
  0013e	0f b6 47 7c	 movzx	 eax, BYTE PTR [edi+124]
  00142	51		 push	 ecx
  00143	0f bf 4f 0a	 movsx	 ecx, WORD PTR [edi+10]
  00147	52		 push	 edx
  00148	50		 push	 eax
  00149	51		 push	 ecx
  0014a	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _copyitem$[ebp]
  00150	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEE@Z ; CItem::Convert

; 7841 : 					copyitem.SetPetItemInfo(item->m_PetItem_Level,item->m_PetItem_Exp);

  00155	8b 97 a8 00 00
	00		 mov	 edx, DWORD PTR [edi+168]
  0015b	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  00161	52		 push	 edx
  00162	50		 push	 eax
  00163	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _copyitem$[ebp]
  00169	e8 00 00 00 00	 call	 ?SetPetItemInfo@CItem@@QAEXHH@Z ; CItem::SetPetItemInfo

; 7842 : 	
; 7843 : 					copyitem.m_Number = item->m_Number;

  0016e	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv256[ebp]
  00174	8b 11		 mov	 edx, DWORD PTR [ecx]

; 7844 : 	
; 7845 : 					gObj[aIndex].pInventory[blank] = copyitem;

  00176	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv260[ebp]
  0017c	8b b9 8c 0c 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3212]
  00182	89 95 54 ff ff
	ff		 mov	 DWORD PTR _copyitem$[ebp], edx
  00188	0f b6 d3	 movzx	 edx, bl
  0018b	8b c2		 mov	 eax, edx
  0018d	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00193	03 f8		 add	 edi, eax
  00195	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0019a	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _copyitem$[ebp]
  001a0	f3 a5		 rep movsd

; 7846 : 		
; 7847 : 					gObjInventoryItemSet(aIndex,blank,gObj[aIndex].pInventory[blank].m_Type);

  001a2	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv260[ebp]
  001a8	8b 89 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3212]
  001ae	0f b6 44 08 06	 movzx	 eax, BYTE PTR [eax+ecx+6]
  001b3	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  001b9	50		 push	 eax
  001ba	52		 push	 edx
  001bb	51		 push	 ecx
  001bc	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 7856 : }

  001c1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c7	8a c3		 mov	 al, bl
  001c9	5b		 pop	 ebx
  001ca	5f		 pop	 edi
  001cb	33 cd		 xor	 ecx, ebp
  001cd	5e		 pop	 esi
  001ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d3	8b e5		 mov	 esp, ebp
  001d5	5d		 pop	 ebp
  001d6	c3		 ret	 0
?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z ENDP	; gObjInventoryInsertItem
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z	; gObjShopBuyInventoryInsertItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z
_TEXT	SEGMENT
_iwidth$ = -16						; size = 4
_iheight$ = -12						; size = 4
_aIndex$GSCopy$ = -8					; size = 4
tv195 = -4						; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 168
?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z PROC	; gObjShopBuyInventoryInsertItem, COMDAT

; 7908 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 7909 : 	int w,h,iwidth,iheight;
; 7910 : 	BYTE blank = 0;
; 7911 : 
; 7912 : 	if(item.GetSize(iwidth,iheight)==0)

  0000a	8d 45 f4	 lea	 eax, DWORD PTR _iheight$[ebp]
  0000d	50		 push	 eax
  0000e	8d 4d f0	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00011	51		 push	 ecx
  00012	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]

; 7942 : 						gPlusItemNumber();
; 7943 : 					}
; 7944 : 
; 7945 : 					gObjInventoryItemSet(aIndex,blank,gObj[aIndex].pInventory[blank].m_Type);

  00015	89 5d f8	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  00018	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0001d	85 c0		 test	 eax, eax
  0001f	75 1f		 jne	 SHORT $LN13@gObjShopBu

; 7913 : 	{
; 7914 : 		LogAdd(LOG_BLACK, "error : Item doesn't exist %s %d",__FILE__,__LINE__);

  00021	68 ea 1e 00 00	 push	 7914			; 00001eeaH
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GBFBGHOP@error?5?3?5Item?5doesn?8t?5exist?5?$CFs?5?$CFd@
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00036	83 c4 10	 add	 esp, 16			; 00000010H

; 7915 : 		return -1;

  00039	0c ff		 or	 al, 255			; 000000ffH
  0003b	5b		 pop	 ebx

; 7953 : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN13@gObjShopBu:
  00040	57		 push	 edi

; 7916 : 	}
; 7917 : 
; 7918 : 	for(h = 0; h < 8; h++)

  00041	8b c3		 mov	 eax, ebx
  00043	33 ff		 xor	 edi, edi
  00045	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 7942 : 						gPlusItemNumber();
; 7943 : 					}
; 7944 : 
; 7945 : 					gObjInventoryItemSet(aIndex,blank,gObj[aIndex].pInventory[blank].m_Type);

  0004b	89 45 fc	 mov	 DWORD PTR tv195[ebp], eax
  0004e	56		 push	 esi
  0004f	90		 npad	 1
$LL23@gObjShopBu:

; 7919 : 	{
; 7920 : 		for( w = 0; w < 8; w++)

  00050	33 f6		 xor	 esi, esi
$LL9@gObjShopBu:

; 7921 : 		{
; 7922 : 			if(*(BYTE*)(gObj[aIndex].pInventoryMap+h*8+w) == 255)

  00052	8b 88 90 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3216]
  00058	8d 14 fe	 lea	 edx, DWORD PTR [esi+edi*8]
  0005b	80 3c 0a ff	 cmp	 BYTE PTR [edx+ecx], 255	; 000000ffH
  0005f	75 25		 jne	 SHORT $LN8@gObjShopBu

; 7923 : 			{
; 7924 : 				blank = gObjOnlyInventoryRectCheck(aIndex,w,h,iwidth,iheight);

  00061	8b 55 f4	 mov	 edx, DWORD PTR _iheight$[ebp]
  00064	8b 45 f0	 mov	 eax, DWORD PTR _iwidth$[ebp]
  00067	52		 push	 edx
  00068	50		 push	 eax
  00069	57		 push	 edi
  0006a	56		 push	 esi
  0006b	53		 push	 ebx
  0006c	e8 00 00 00 00	 call	 ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ; gObjOnlyInventoryRectCheck
  00071	8a d8		 mov	 bl, al
  00073	83 c4 14	 add	 esp, 20			; 00000014H

; 7925 : 
; 7926 : 				if(blank == 254)

  00076	80 fb fe	 cmp	 bl, 254			; 000000feH
  00079	74 17		 je	 SHORT $GOTO_EndFunc$164467

; 7927 : 				{
; 7928 : 					goto GOTO_EndFunc;
; 7929 : 				}
; 7930 : 
; 7931 : 				if(blank != 255)

  0007b	80 fb ff	 cmp	 bl, 255			; 000000ffH
  0007e	75 1b		 jne	 SHORT $LN19@gObjShopBu
  00080	8b 45 fc	 mov	 eax, DWORD PTR tv195[ebp]
  00083	8b 5d f8	 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
$LN8@gObjShopBu:

; 7919 : 	{
; 7920 : 		for( w = 0; w < 8; w++)

  00086	46		 inc	 esi
  00087	83 fe 08	 cmp	 esi, 8
  0008a	7c c6		 jl	 SHORT $LL9@gObjShopBu

; 7916 : 	}
; 7917 : 
; 7918 : 	for(h = 0; h < 8; h++)

  0008c	47		 inc	 edi
  0008d	83 ff 08	 cmp	 edi, 8
  00090	7c be		 jl	 SHORT $LL23@gObjShopBu
$GOTO_EndFunc$164467:
  00092	5e		 pop	 esi
  00093	5f		 pop	 edi

; 7947 : 				}
; 7948 : 			}
; 7949 : 		}
; 7950 : 	}
; 7951 : GOTO_EndFunc:
; 7952 : 	return -1;

  00094	0c ff		 or	 al, 255			; 000000ffH
  00096	5b		 pop	 ebx

; 7953 : }

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
$LN19@gObjShopBu:

; 7932 : 				{
; 7933 : 					gObj[aIndex].pInventory[blank] = item;

  0009b	8b 4d fc	 mov	 ecx, DWORD PTR tv195[ebp]
  0009e	8b b9 8c 0c 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3212]
  000a4	0f b6 d3	 movzx	 edx, bl
  000a7	69 d2 a8 00 00
	00		 imul	 edx, 168		; 000000a8H
  000ad	03 fa		 add	 edi, edx
  000af	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000b4	8d 75 0c	 lea	 esi, DWORD PTR _item$[ebp]
  000b7	f3 a5		 rep movsd

; 7934 : 
; 7935 : 					if(item.m_serial == 0)

  000b9	80 7d 10 00	 cmp	 BYTE PTR _item$[ebp+4], 0
  000bd	75 12		 jne	 SHORT $LN2@gObjShopBu

; 7936 : 					{
; 7937 : 						gObj[aIndex].pInventory[blank].m_Number = 0;

  000bf	8b 45 fc	 mov	 eax, DWORD PTR tv195[ebp]
  000c2	8b 88 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3212]
  000c8	c7 04 0a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx], 0

; 7938 : 					}
; 7939 : 					else

  000cf	eb 11		 jmp	 SHORT $LN1@gObjShopBu
$LN2@gObjShopBu:

; 7940 : 					{
; 7941 : 						gObj[aIndex].pInventory[blank].m_Number = gGetItemNumber();

  000d1	e8 00 00 00 00	 call	 ?gGetItemNumber@@YAKXZ	; gGetItemNumber
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR tv195[ebp]
  000d9	8b 89 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3212]
  000df	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax
$LN1@gObjShopBu:

; 7942 : 						gPlusItemNumber();
; 7943 : 					}
; 7944 : 
; 7945 : 					gObjInventoryItemSet(aIndex,blank,gObj[aIndex].pInventory[blank].m_Type);

  000e2	8b 45 fc	 mov	 eax, DWORD PTR tv195[ebp]
  000e5	8b 88 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3212]
  000eb	0f b6 54 11 06	 movzx	 edx, BYTE PTR [ecx+edx+6]
  000f0	0f b6 c3	 movzx	 eax, bl
  000f3	52		 push	 edx
  000f4	50		 push	 eax
  000f5	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  000fe	83 c4 0c	 add	 esp, 12			; 0000000cH
  00101	5e		 pop	 esi
  00102	5f		 pop	 edi

; 7946 : 					return blank;

  00103	8a c3		 mov	 al, bl
  00105	5b		 pop	 ebx

; 7953 : }

  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c3		 ret	 0
?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z ENDP	; gObjShopBuyInventoryInsertItem
_TEXT	ENDS
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjShopBuyInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHHHH@Z ; gObjShopBuyInventoryInsertItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjShopBuyInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHHHH@Z
_TEXT	SEGMENT
_iwidth$ = -184						; size = 4
_iheight$ = -180					; size = 4
_lpObj$GSCopy$ = -176					; size = 4
_item$ = -172						; size = 168
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_type$ = 12						; size = 4
_index$ = 16						; size = 4
_level$ = 20						; size = 4
_iSerial$ = 24						; size = 4
_iDur$ = 28						; size = 4
?gObjShopBuyInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHHHH@Z PROC ; gObjShopBuyInventoryInsertItem, COMDAT

; 7956 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]

; 7957 : 	int w,h,iwidth,iheight;
; 7958 : 	BYTE blank = 0;
; 7959 : 	CItem item;

  00017	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]

; 7997 : 						gPlusItemNumber();
; 7998 : 					}
; 7999 : 					
; 8000 : 					gObjInventoryItemSet(lpObj->m_Index,blank,lpObj->pInventory[blank].m_Type);

  0001d	89 9d 50 ff ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$[ebp], ebx
  00023	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  00028	8b 45 10	 mov	 eax, DWORD PTR _index$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  0002e	50		 push	 eax
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00035	db 45 1c	 fild	 DWORD PTR _iDur$[ebp]
  00038	66 8b 55 14	 mov	 dx, WORD PTR _level$[ebp]
  0003c	83 c4 08	 add	 esp, 8
  0003f	6a 03		 push	 3
  00041	d9 9d 78 ff ff
	ff		 fstp	 DWORD PTR _item$[ebp+36]
  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	50		 push	 eax
  00054	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0005a	66 89 95 5c ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], dx
  00061	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEE@Z ; CItem::Convert
  00066	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _iheight$[ebp]
  0006c	50		 push	 eax
  0006d	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00073	51		 push	 ecx
  00074	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0007a	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0007f	85 c0		 test	 eax, eax
  00081	75 29		 jne	 SHORT $LN13@gObjShopBu@2

; 7960 : 
; 7961 : 	int item_type = ItemGetNumberMake(type,index);
; 7962 : 	item.m_Level = level;
; 7963 : 	item.m_Durability = iDur;
; 7964 : 
; 7965 : 	item.Convert(item_type,0,0,0,0,0,0, CURRENT_DB_VERSION);
; 7966 : 
; 7967 : 	if(item.GetSize((int &)iwidth,(int &)iheight)==0)
; 7968 : 	{
; 7969 : 		LogAdd(LOG_BLACK, "error : Item doesn't exist %s %d",__FILE__,__LINE__);

  00083	68 21 1f 00 00	 push	 7969			; 00001f21H
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GBFBGHOP@error?5?3?5Item?5doesn?8t?5exist?5?$CFs?5?$CFd@
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00098	83 c4 10	 add	 esp, 16			; 00000010H

; 7970 : 		return -1;

  0009b	0c ff		 or	 al, 255			; 000000ffH
  0009d	5b		 pop	 ebx

; 8008 : }

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a1	33 cd		 xor	 ecx, ebp
  000a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
$LN13@gObjShopBu@2:
  000ac	57		 push	 edi

; 7971 : 	}
; 7972 : 
; 7973 : 	for(h = 0; h < 8; h++)

  000ad	33 ff		 xor	 edi, edi
  000af	56		 push	 esi
$LL22@gObjShopBu@2:

; 7974 : 	{
; 7975 : 		for(w = 0; w < 8; w++)

  000b0	33 f6		 xor	 esi, esi
$LL9@gObjShopBu@2:

; 7976 : 		{
; 7977 : 			if(*(BYTE*)(lpObj->pInventoryMap+h*8+w) == 255)

  000b2	8b 83 90 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3216]
  000b8	8d 14 fe	 lea	 edx, DWORD PTR [esi+edi*8]
  000bb	80 3c 02 ff	 cmp	 BYTE PTR [edx+eax], 255	; 000000ffH
  000bf	75 2d		 jne	 SHORT $LN8@gObjShopBu@2

; 7978 : 			{
; 7979 : 				blank = gObjOnlyInventoryRectCheck(lpObj->m_Index,w,h,iwidth,iheight);

  000c1	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _iheight$[ebp]
  000c7	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _iwidth$[ebp]
  000cd	8b 03		 mov	 eax, DWORD PTR [ebx]
  000cf	51		 push	 ecx
  000d0	52		 push	 edx
  000d1	57		 push	 edi
  000d2	56		 push	 esi
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ; gObjOnlyInventoryRectCheck
  000d9	8a d8		 mov	 bl, al
  000db	83 c4 14	 add	 esp, 20			; 00000014H

; 7980 : 
; 7981 : 				if(blank == 254)

  000de	80 fb fe	 cmp	 bl, 254			; 000000feH
  000e1	74 17		 je	 SHORT $GOTO_EndFunc$164499

; 7982 : 				{
; 7983 : 					goto GOTO_EndFunc;
; 7984 : 				}
; 7985 : 
; 7986 : 				if(blank != 255)

  000e3	80 fb ff	 cmp	 bl, 255			; 000000ffH
  000e6	75 25		 jne	 SHORT $LN19@gObjShopBu@2
  000e8	8b 9d 50 ff ff
	ff		 mov	 ebx, DWORD PTR _lpObj$GSCopy$[ebp]
$LN8@gObjShopBu@2:

; 7974 : 	{
; 7975 : 		for(w = 0; w < 8; w++)

  000ee	46		 inc	 esi
  000ef	83 fe 08	 cmp	 esi, 8
  000f2	7c be		 jl	 SHORT $LL9@gObjShopBu@2

; 7971 : 	}
; 7972 : 
; 7973 : 	for(h = 0; h < 8; h++)

  000f4	47		 inc	 edi
  000f5	83 ff 08	 cmp	 edi, 8
  000f8	7c b6		 jl	 SHORT $LL22@gObjShopBu@2
$GOTO_EndFunc$164499:
  000fa	5e		 pop	 esi
  000fb	5f		 pop	 edi

; 8001 : 					return blank;
; 8002 : 				}
; 8003 : 			}
; 8004 : 		}
; 8005 : 	}
; 8006 : GOTO_EndFunc:
; 8007 : 	return -1;

  000fc	0c ff		 or	 al, 255			; 000000ffH
  000fe	5b		 pop	 ebx

; 8008 : }

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00102	33 cd		 xor	 ecx, ebp
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
$LN19@gObjShopBu@2:

; 7987 : 				{
; 7988 : 					lpObj->pInventory[blank] = item;

  0010d	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$GSCopy$[ebp]
  00113	8b b9 8c 0c 00
	00		 mov	 edi, DWORD PTR [ecx+3212]
  00119	0f b6 d3	 movzx	 edx, bl
  0011c	69 d2 a8 00 00
	00		 imul	 edx, 168		; 000000a8H
  00122	03 fa		 add	 edi, edx
  00124	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00129	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  0012f	f3 a5		 rep movsd

; 7989 : 
; 7990 : 					if ( !item.m_serial )

  00131	80 bd 58 ff ff
	ff 00		 cmp	 BYTE PTR _item$[ebp+4], 0
  00138	75 15		 jne	 SHORT $LN2@gObjShopBu@2

; 7991 : 					{
; 7992 : 						lpObj->pInventory[blank].m_Number = 0;

  0013a	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$GSCopy$[ebp]
  00140	8b 88 8c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3212]
  00146	c7 04 0a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx], 0

; 7993 : 					}
; 7994 : 					else

  0014d	eb 1a		 jmp	 SHORT $LN1@gObjShopBu@2
$LN2@gObjShopBu@2:

; 7995 : 					{
; 7996 : 						lpObj->pInventory[blank].m_Number = gGetItemNumber();

  0014f	e8 00 00 00 00	 call	 ?gGetItemNumber@@YAKXZ	; gGetItemNumber
  00154	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$GSCopy$[ebp]
  0015a	8b 89 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ecx+3212]
  00160	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax
  00163	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$GSCopy$[ebp]
$LN1@gObjShopBu@2:

; 7997 : 						gPlusItemNumber();
; 7998 : 					}
; 7999 : 					
; 8000 : 					gObjInventoryItemSet(lpObj->m_Index,blank,lpObj->pInventory[blank].m_Type);

  00169	8b 88 8c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3212]
  0016f	0f b6 54 11 06	 movzx	 edx, BYTE PTR [ecx+edx+6]
  00174	8b 00		 mov	 eax, DWORD PTR [eax]
  00176	0f b6 cb	 movzx	 ecx, bl
  00179	52		 push	 edx
  0017a	51		 push	 ecx
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 8008 : }

  00181	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH
  00187	5e		 pop	 esi
  00188	5f		 pop	 edi
  00189	8a c3		 mov	 al, bl
  0018b	33 cd		 xor	 ecx, ebp
  0018d	5b		 pop	 ebx
  0018e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c3		 ret	 0
?gObjShopBuyInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHHHH@Z ENDP ; gObjShopBuyInventoryInsertItem
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjInventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCMapItem@@@Z ; gObjInventoryInsertItemTemp
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCMapItem@@@Z
_TEXT	SEGMENT
_iheight$ = -180					; size = 4
_iwidth$ = -176						; size = 4
_item$ = -172						; size = 168
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_Item$ = 12						; size = 4
?gObjInventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCMapItem@@@Z PROC ; gObjInventoryInsertItemTemp, COMDAT

; 8011 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _Item$[ebp]

; 8012 : 	CItem item;

  0001b	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00021	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 8013 : 	int w,h,iwidth,iheight;
; 8014 : 	BYTE blank = 0;
; 8015 : 
; 8016 : 	if(Item->GetSize((int &)iwidth,(int &)iheight)==0)

  00026	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _iheight$[ebp]
  0002c	50		 push	 eax
  0002d	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00033	51		 push	 ecx
  00034	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00037	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0003c	85 c0		 test	 eax, eax
  0003e	75 2a		 jne	 SHORT $LN11@gObjInvent@14

; 8017 : 	{
; 8018 : 		LogAdd(LOG_BLACK, "error : Item doesn't exist %s %d",__FILE__,__LINE__);

  00040	68 52 1f 00 00	 push	 8018			; 00001f52H
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GBFBGHOP@error?5?3?5Item?5doesn?8t?5exist?5?$CFs?5?$CFd@
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00055	83 c4 10	 add	 esp, 16			; 00000010H
  00058	5e		 pop	 esi

; 8019 : 		return -1;

  00059	0c ff		 or	 al, 255			; 000000ffH
  0005b	5b		 pop	 ebx

; 8044 : }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN11@gObjInvent@14:
  0006a	57		 push	 edi

; 8020 : 	}
; 8021 : 
; 8022 : 	for(h = 0; h < 8; h++)

  0006b	33 ff		 xor	 edi, edi
  0006d	8d 49 00	 npad	 3
$LL20@gObjInvent@14:

; 8023 : 	{
; 8024 : 		for(w = 0; w < 8; w++)

  00070	33 f6		 xor	 esi, esi
$LL7@gObjInvent@14:

; 8025 : 		{
; 8026 : 			if(*(BYTE*)(lpObj->pInventoryMap+h*8+w) == 255)

  00072	8b 83 90 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3216]
  00078	8d 14 fe	 lea	 edx, DWORD PTR [esi+edi*8]
  0007b	80 3c 02 ff	 cmp	 BYTE PTR [edx+eax], 255	; 000000ffH
  0007f	75 23		 jne	 SHORT $LN6@gObjInvent@14

; 8027 : 			{
; 8028 : 				blank = gObjInventoryRectCheck(lpObj->m_Index,w,h,iwidth,iheight);

  00081	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _iheight$[ebp]
  00087	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _iwidth$[ebp]
  0008d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0008f	51		 push	 ecx
  00090	52		 push	 edx
  00091	57		 push	 edi
  00092	56		 push	 esi
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  00099	83 c4 14	 add	 esp, 20			; 00000014H

; 8029 : 
; 8030 : 				if(blank == 254)

  0009c	3c fe		 cmp	 al, 254			; 000000feH
  0009e	74 10		 je	 SHORT $GOTO_EndFunc$164526

; 8031 : 				{
; 8032 : 					goto GOTO_EndFunc;
; 8033 : 				}
; 8034 : 
; 8035 : 				if(blank != 255)

  000a0	3c ff		 cmp	 al, 255			; 000000ffH
  000a2	75 0e		 jne	 SHORT $LN21@gObjInvent@14
$LN6@gObjInvent@14:

; 8023 : 	{
; 8024 : 		for(w = 0; w < 8; w++)

  000a4	46		 inc	 esi
  000a5	83 fe 08	 cmp	 esi, 8
  000a8	7c c8		 jl	 SHORT $LL7@gObjInvent@14

; 8020 : 	}
; 8021 : 
; 8022 : 	for(h = 0; h < 8; h++)

  000aa	47		 inc	 edi
  000ab	83 ff 08	 cmp	 edi, 8
  000ae	7c c0		 jl	 SHORT $LL20@gObjInvent@14
$GOTO_EndFunc$164526:

; 8036 : 				{
; 8037 : 					return blank;
; 8038 : 				}
; 8039 : 			}
; 8040 : 		}
; 8041 : 	}
; 8042 : GOTO_EndFunc:
; 8043 : 	return -1;

  000b0	0c ff		 or	 al, 255			; 000000ffH
$LN21@gObjInvent@14:

; 8044 : }

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	33 cd		 xor	 ecx, ebp
  000b9	5b		 pop	 ebx
  000ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
?gObjInventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCMapItem@@@Z ENDP ; gObjInventoryInsertItemTemp
_TEXT	ENDS
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHH@Z ; gObjInventoryInsertItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_iwidth$ = -184						; size = 4
_iheight$ = -180					; size = 4
_lpObj$GSCopy$ = -176					; size = 4
_item$ = -172						; size = 168
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_type$ = 12						; size = 4
_index$ = 16						; size = 4
_level$ = 20						; size = 4
?gObjInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHH@Z PROC ; gObjInventoryInsertItem, COMDAT

; 8047 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]

; 8048 : 	CItem item;

  00017	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]

; 8079 : 				{
; 8080 : 					lpObj->pInventory[blank] = item;

  0001d	89 9d 50 ff ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$[ebp], ebx
  00023	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  00028	8b 45 10	 mov	 eax, DWORD PTR _index$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  0002e	50		 push	 eax
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00035	66 8b 55 14	 mov	 dx, WORD PTR _level$[ebp]
  00039	83 c4 08	 add	 esp, 8
  0003c	6a 03		 push	 3
  0003e	6a 00		 push	 0
  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	50		 push	 eax
  0004b	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00051	66 89 95 5c ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], dx
  00058	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEE@Z ; CItem::Convert
  0005d	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _iheight$[ebp]
  00063	50		 push	 eax
  00064	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _iwidth$[ebp]
  0006a	51		 push	 ecx
  0006b	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00071	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00076	85 c0		 test	 eax, eax
  00078	75 29		 jne	 SHORT $LN11@gObjInvent@15

; 8049 : 	int w,h,iwidth,iheight;
; 8050 : 	BYTE blank = 0;
; 8051 : 
; 8052 : 	int item_type = ItemGetNumberMake(type,index);
; 8053 : 
; 8054 : 	item.m_Level = level;
; 8055 : 
; 8056 : 	item.Convert(item_type,0,0,0,0,0,0, CURRENT_DB_VERSION);
; 8057 : 
; 8058 : 	if(item.GetSize((int &)iwidth,(int &)iheight)==0)
; 8059 : 	{
; 8060 : 		LogAdd(LOG_BLACK, "error : Item doesn't exist %s %d",__FILE__,__LINE__);

  0007a	68 7c 1f 00 00	 push	 8060			; 00001f7cH
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GBFBGHOP@error?5?3?5Item?5doesn?8t?5exist?5?$CFs?5?$CFd@
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0008f	83 c4 10	 add	 esp, 16			; 00000010H

; 8061 : 		return -1;

  00092	0c ff		 or	 al, 255			; 000000ffH
  00094	5b		 pop	 ebx

; 8092 : }

  00095	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00098	33 cd		 xor	 ecx, ebp
  0009a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
$LN11@gObjInvent@15:
  000a3	57		 push	 edi

; 8062 : 	}
; 8063 : 
; 8064 : 	for(h = 0; h < 8; h++)

  000a4	33 ff		 xor	 edi, edi
  000a6	56		 push	 esi
  000a7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL20@gObjInvent@15:

; 8065 : 	{
; 8066 : 		for( w = 0; w < 8; w++)

  000b0	33 f6		 xor	 esi, esi
  000b2	eb 0c 8d a4 24
	00 00 00 00 eb
	03 8d 49 00	 npad	 14
$LL7@gObjInvent@15:

; 8067 : 		{
; 8068 : 
; 8069 : 			if(*(BYTE*)(lpObj->pInventoryMap+h*8+w) == 255)

  000c0	8b 93 90 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3216]
  000c6	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  000cd	03 d0		 add	 edx, eax
  000cf	80 3c 32 ff	 cmp	 BYTE PTR [edx+esi], 255	; 000000ffH
  000d3	75 2d		 jne	 SHORT $LN6@gObjInvent@15

; 8070 : 			{
; 8071 : 				blank = gObjOnlyInventoryRectCheck(lpObj->m_Index,w,h,iwidth,iheight);

  000d5	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _iheight$[ebp]
  000db	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _iwidth$[ebp]
  000e1	8b 13		 mov	 edx, DWORD PTR [ebx]
  000e3	50		 push	 eax
  000e4	51		 push	 ecx
  000e5	57		 push	 edi
  000e6	56		 push	 esi
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ; gObjOnlyInventoryRectCheck
  000ed	8a d8		 mov	 bl, al
  000ef	83 c4 14	 add	 esp, 20			; 00000014H

; 8072 : 	
; 8073 : 				if(blank == 254)

  000f2	80 fb fe	 cmp	 bl, 254			; 000000feH
  000f5	74 17		 je	 SHORT $GOTO_EndFunc$164554

; 8074 : 				{
; 8075 : 					goto GOTO_EndFunc;
; 8076 : 				}
; 8077 : 	
; 8078 : 				if(blank != 255)

  000f7	80 fb ff	 cmp	 bl, 255			; 000000ffH
  000fa	75 25		 jne	 SHORT $LN17@gObjInvent@15
  000fc	8b 9d 50 ff ff
	ff		 mov	 ebx, DWORD PTR _lpObj$GSCopy$[ebp]
$LN6@gObjInvent@15:

; 8065 : 	{
; 8066 : 		for( w = 0; w < 8; w++)

  00102	46		 inc	 esi
  00103	83 fe 08	 cmp	 esi, 8
  00106	7c b8		 jl	 SHORT $LL7@gObjInvent@15

; 8062 : 	}
; 8063 : 
; 8064 : 	for(h = 0; h < 8; h++)

  00108	47		 inc	 edi
  00109	83 ff 08	 cmp	 edi, 8
  0010c	7c a2		 jl	 SHORT $LL20@gObjInvent@15
$GOTO_EndFunc$164554:
  0010e	5e		 pop	 esi
  0010f	5f		 pop	 edi

; 8085 : 					return blank;
; 8086 : 				}
; 8087 : 			}
; 8088 : 		}
; 8089 : 	}
; 8090 : GOTO_EndFunc:
; 8091 : 	return -1;

  00110	0c ff		 or	 al, 255			; 000000ffH
  00112	5b		 pop	 ebx

; 8092 : }

  00113	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00116	33 cd		 xor	 ecx, ebp
  00118	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
$LN17@gObjInvent@15:

; 8079 : 				{
; 8080 : 					lpObj->pInventory[blank] = item;

  00121	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$GSCopy$[ebp]
  00127	8b b8 8c 0c 00
	00		 mov	 edi, DWORD PTR [eax+3212]
  0012d	0f b6 d3	 movzx	 edx, bl
  00130	69 d2 a8 00 00
	00		 imul	 edx, 168		; 000000a8H
  00136	03 fa		 add	 edi, edx
  00138	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0013d	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  00143	f3 a5		 rep movsd

; 8081 : 					lpObj->pInventory[blank].m_Number = gGetItemNumber();

  00145	e8 00 00 00 00	 call	 ?gGetItemNumber@@YAKXZ	; gGetItemNumber
  0014a	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$GSCopy$[ebp]
  00150	8b b1 8c 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3212]
  00156	89 04 32	 mov	 DWORD PTR [edx+esi], eax

; 8082 : 					gPlusItemNumber();
; 8083 : 
; 8084 : 					gObjInventoryItemSet(lpObj->m_Index,blank,lpObj->pInventory[blank].m_Type);

  00159	8b 81 8c 0c 00
	00		 mov	 eax, DWORD PTR [ecx+3212]
  0015f	0f b6 54 10 06	 movzx	 edx, BYTE PTR [eax+edx+6]
  00164	0f b6 c3	 movzx	 eax, bl
  00167	52		 push	 edx
  00168	50		 push	 eax
  00169	8b 01		 mov	 eax, DWORD PTR [ecx]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 8092 : }

  00171	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00174	83 c4 0c	 add	 esp, 12			; 0000000cH
  00177	5e		 pop	 esi
  00178	5f		 pop	 edi
  00179	8a c3		 mov	 al, bl
  0017b	33 cd		 xor	 ecx, ebp
  0017d	5b		 pop	 ebx
  0017e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c3		 ret	 0
?gObjInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHH@Z ENDP ; gObjInventoryInsertItem
_TEXT	ENDS
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHHHH@Z ; gObjInventoryInsertItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHHHH@Z
_TEXT	SEGMENT
_iwidth$ = -184						; size = 4
_iheight$ = -180					; size = 4
_lpObj$GSCopy$ = -176					; size = 4
_item$ = -172						; size = 168
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_type$ = 12						; size = 4
_index$ = 16						; size = 4
_level$ = 20						; size = 4
_iSerial$ = 24						; size = 4
_iDur$ = 28						; size = 4
?gObjInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHHHH@Z PROC ; gObjInventoryInsertItem, COMDAT

; 8095 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]

; 8096 : 	CItem item;

  00017	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]

; 8126 : 				{
; 8127 : 					lpObj->pInventory[blank] = item;

  0001d	89 9d 50 ff ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$[ebp], ebx
  00023	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  00028	8b 45 10	 mov	 eax, DWORD PTR _index$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  0002e	50		 push	 eax
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00035	db 45 1c	 fild	 DWORD PTR _iDur$[ebp]
  00038	66 8b 55 14	 mov	 dx, WORD PTR _level$[ebp]
  0003c	83 c4 08	 add	 esp, 8
  0003f	6a 03		 push	 3
  00041	d9 9d 78 ff ff
	ff		 fstp	 DWORD PTR _item$[ebp+36]
  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	50		 push	 eax
  00054	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0005a	66 89 95 5c ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], dx
  00061	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEE@Z ; CItem::Convert
  00066	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _iheight$[ebp]
  0006c	50		 push	 eax
  0006d	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00073	51		 push	 ecx
  00074	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0007a	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0007f	85 c0		 test	 eax, eax
  00081	75 29		 jne	 SHORT $LN11@gObjInvent@16

; 8097 : 	int w,h,iwidth,iheight;
; 8098 : 	BYTE blank = 0;
; 8099 : 
; 8100 : 	int item_type = ItemGetNumberMake(type,index);
; 8101 : 	item.m_Level = level;
; 8102 : 	item.m_Durability = iDur;
; 8103 : 
; 8104 : 	item.Convert(item_type,0,0,0,0,0,0, CURRENT_DB_VERSION);
; 8105 : 
; 8106 : 	if(item.GetSize((int &)iwidth,(int &)iheight)==0)
; 8107 : 	{
; 8108 : 		LogAdd(LOG_BLACK, "error : Item doesn't exist %s %d",__FILE__,__LINE__);

  00083	68 ac 1f 00 00	 push	 8108			; 00001facH
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GBFBGHOP@error?5?3?5Item?5doesn?8t?5exist?5?$CFs?5?$CFd@
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00098	83 c4 10	 add	 esp, 16			; 00000010H

; 8109 : 		return -1;

  0009b	0c ff		 or	 al, 255			; 000000ffH
  0009d	5b		 pop	 ebx

; 8139 : }

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a1	33 cd		 xor	 ecx, ebp
  000a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
$LN11@gObjInvent@16:
  000ac	57		 push	 edi

; 8110 : 	}
; 8111 : 
; 8112 : 	for(h = 0; h < 8; h++)

  000ad	33 ff		 xor	 edi, edi
  000af	56		 push	 esi
$LL20@gObjInvent@16:

; 8113 : 	{
; 8114 : 		for(w = 0; w < 8; w++)

  000b0	33 f6		 xor	 esi, esi
$LL7@gObjInvent@16:

; 8115 : 		{
; 8116 : 			if(*(BYTE*)(lpObj->pInventoryMap+h*8+w) == 255)

  000b2	8b 83 90 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3216]
  000b8	8d 14 fe	 lea	 edx, DWORD PTR [esi+edi*8]
  000bb	80 3c 02 ff	 cmp	 BYTE PTR [edx+eax], 255	; 000000ffH
  000bf	75 2d		 jne	 SHORT $LN6@gObjInvent@16

; 8117 : 			{
; 8118 : 				blank = gObjInventoryRectCheck(lpObj->m_Index,w,h,iwidth,iheight);

  000c1	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _iheight$[ebp]
  000c7	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _iwidth$[ebp]
  000cd	8b 03		 mov	 eax, DWORD PTR [ebx]
  000cf	51		 push	 ecx
  000d0	52		 push	 edx
  000d1	57		 push	 edi
  000d2	56		 push	 esi
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  000d9	8a d8		 mov	 bl, al
  000db	83 c4 14	 add	 esp, 20			; 00000014H

; 8119 : 
; 8120 : 				if(blank == 254)

  000de	80 fb fe	 cmp	 bl, 254			; 000000feH
  000e1	74 17		 je	 SHORT $GOTO_EndFunc$164584

; 8121 : 				{
; 8122 : 					goto GOTO_EndFunc;
; 8123 : 				}
; 8124 : 
; 8125 : 				if(blank != 255)

  000e3	80 fb ff	 cmp	 bl, 255			; 000000ffH
  000e6	75 25		 jne	 SHORT $LN17@gObjInvent@16
  000e8	8b 9d 50 ff ff
	ff		 mov	 ebx, DWORD PTR _lpObj$GSCopy$[ebp]
$LN6@gObjInvent@16:

; 8113 : 	{
; 8114 : 		for(w = 0; w < 8; w++)

  000ee	46		 inc	 esi
  000ef	83 fe 08	 cmp	 esi, 8
  000f2	7c be		 jl	 SHORT $LL7@gObjInvent@16

; 8110 : 	}
; 8111 : 
; 8112 : 	for(h = 0; h < 8; h++)

  000f4	47		 inc	 edi
  000f5	83 ff 08	 cmp	 edi, 8
  000f8	7c b6		 jl	 SHORT $LL20@gObjInvent@16
$GOTO_EndFunc$164584:
  000fa	5e		 pop	 esi
  000fb	5f		 pop	 edi

; 8132 : 					return blank;
; 8133 : 				}
; 8134 : 			}
; 8135 : 		}
; 8136 : 	}
; 8137 : GOTO_EndFunc:
; 8138 : 	return -1;

  000fc	0c ff		 or	 al, 255			; 000000ffH
  000fe	5b		 pop	 ebx

; 8139 : }

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00102	33 cd		 xor	 ecx, ebp
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
$LN17@gObjInvent@16:

; 8126 : 				{
; 8127 : 					lpObj->pInventory[blank] = item;

  0010d	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$GSCopy$[ebp]
  00113	8b b9 8c 0c 00
	00		 mov	 edi, DWORD PTR [ecx+3212]
  00119	0f b6 d3	 movzx	 edx, bl
  0011c	8b c2		 mov	 eax, edx
  0011e	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00124	03 f8		 add	 edi, eax
  00126	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0012b	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  00131	f3 a5		 rep movsd

; 8128 : 					lpObj->pInventory[blank].m_Number = iSerial;

  00133	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _lpObj$GSCopy$[ebp]
  00139	8b b1 8c 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3212]
  0013f	8b 7d 18	 mov	 edi, DWORD PTR _iSerial$[ebp]
  00142	89 3c 30	 mov	 DWORD PTR [eax+esi], edi

; 8129 : 					gPlusItemNumber();
; 8130 : 
; 8131 : 					gObjInventoryItemSet(lpObj->m_Index,blank,lpObj->pInventory[blank].m_Type);

  00145	8b b1 8c 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3212]
  0014b	0f b6 44 06 06	 movzx	 eax, BYTE PTR [esi+eax+6]
  00150	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00152	50		 push	 eax
  00153	52		 push	 edx
  00154	51		 push	 ecx
  00155	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 8139 : }

  0015a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	5e		 pop	 esi
  00161	5f		 pop	 edi
  00162	8a c3		 mov	 al, bl
  00164	33 cd		 xor	 ecx, ebp
  00166	5b		 pop	 ebx
  00167	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
?gObjInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHHHH@Z ENDP ; gObjInventoryInsertItem
_TEXT	ENDS
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjMonsterInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHHHHH@Z ; gObjMonsterInventoryInsertItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHHHHH@Z
_TEXT	SEGMENT
tv249 = -180						; size = 4
_lpObj$GSCopy$ = -176					; size = 4
_item$ = -172						; size = 168
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_type$ = 12						; size = 4
_index$ = 16						; size = 4
_level$ = 20						; size = 4
_op1$ = 24						; size = 4
_op2$ = 28						; size = 4
_op3$ = 32						; size = 4
?gObjMonsterInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHHHHH@Z PROC ; gObjMonsterInventoryInsertItem, COMDAT

; 8142 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi

; 8143 : 	CItem item;

  00019	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]

; 8177 : 				{
; 8178 : 					lpObj->pInventory[blank] = item;

  0001f	89 9d 50 ff ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$[ebp], ebx
  00025	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  0002a	8b 45 10	 mov	 eax, DWORD PTR _index$[ebp]
  0002d	8b 7d 0c	 mov	 edi, DWORD PTR _type$[ebp]
  00030	50		 push	 eax
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00037	66 8b 4d 14	 mov	 cx, WORD PTR _level$[ebp]
  0003b	83 c4 08	 add	 esp, 8
  0003e	8b f0		 mov	 esi, eax
  00040	66 89 8d 5c ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], cx
  00047	83 ff 0d	 cmp	 edi, 13			; 0000000dH
  0004a	75 2b		 jne	 SHORT $LN11@gObjMonste@3

; 8144 : 	int w,h,iwidth,iheight;
; 8145 : 	BYTE blank = 0;
; 8146 : 	int item_type;
; 8147 : 	int a = 0;
; 8148 : 
; 8149 : 	item_type = ItemGetNumberMake(type,index);
; 8150 : 	item.m_Level = level;
; 8151 : 
; 8152 : 	if(type == 13 && index == 10)

  0004c	83 7d 10 0a	 cmp	 DWORD PTR _index$[ebp], 10 ; 0000000aH
  00050	75 25		 jne	 SHORT $LN11@gObjMonste@3

; 8153 : 	{
; 8154 : 		item.m_Durability = rand()%100+100.0f;

  00052	e8 00 00 00 00	 call	 _rand
  00057	99		 cdq
  00058	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0005d	f7 f9		 idiv	 ecx
  0005f	89 95 4c ff ff
	ff		 mov	 DWORD PTR tv249[ebp], edx
  00065	db 85 4c ff ff
	ff		 fild	 DWORD PTR tv249[ebp]
  0006b	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4059000000000000
  00071	d9 9d 78 ff ff
	ff		 fstp	 DWORD PTR _item$[ebp+36]
$LN11@gObjMonste@3:

; 8155 : 	}
; 8156 : 
; 8157 : 	item.Convert(item_type,op1,op2,op3,0,0,0, CURRENT_DB_VERSION);

  00077	8b 55 20	 mov	 edx, DWORD PTR _op3$[ebp]
  0007a	8b 45 1c	 mov	 eax, DWORD PTR _op2$[ebp]
  0007d	8b 4d 18	 mov	 ecx, DWORD PTR _op1$[ebp]
  00080	6a 03		 push	 3
  00082	6a 00		 push	 0
  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	52		 push	 edx
  00089	50		 push	 eax
  0008a	51		 push	 ecx
  0008b	56		 push	 esi
  0008c	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00092	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEE@Z ; CItem::Convert

; 8158 : 
; 8159 : 	lpObj->pInventory[blank] = item;

  00097	8b bb 8c 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3212]
  0009d	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000a2	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  000a8	f3 a5		 rep movsd

; 8160 : 	iwidth = 1;
; 8161 : 	iheight = 1;
; 8162 : 
; 8163 : 	for(h = 0; h < 8; h++)

  000aa	33 ff		 xor	 edi, edi
  000ac	8d 64 24 00	 npad	 4
$LL22@gObjMonste@3:

; 8164 : 	{
; 8165 : 		for(w = 0; w <8; w++)

  000b0	33 f6		 xor	 esi, esi
$LL7@gObjMonste@3:

; 8166 : 		{
; 8167 : 			if(*(BYTE*)(lpObj->pInventoryMap+h*8+w) == 255)

  000b2	8b 83 90 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3216]
  000b8	8d 14 fe	 lea	 edx, DWORD PTR [esi+edi*8]
  000bb	80 3c 02 ff	 cmp	 BYTE PTR [edx+eax], 255	; 000000ffH
  000bf	75 23		 jne	 SHORT $LN6@gObjMonste@3

; 8168 : 			{
; 8169 : 				blank = gObjInventoryRectCheck(lpObj->m_Index,w,h,iwidth,iheight);

  000c1	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c3	6a 01		 push	 1
  000c5	6a 01		 push	 1
  000c7	57		 push	 edi
  000c8	56		 push	 esi
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  000cf	8a d8		 mov	 bl, al
  000d1	83 c4 14	 add	 esp, 20			; 00000014H

; 8170 : 
; 8171 : 				if(blank == 254)

  000d4	80 fb fe	 cmp	 bl, 254			; 000000feH
  000d7	74 17		 je	 SHORT $GOTO_EndFunc$164614

; 8172 : 				{
; 8173 : 					goto GOTO_EndFunc;
; 8174 : 				}
; 8175 : 
; 8176 : 				if(blank != 255)

  000d9	80 fb ff	 cmp	 bl, 255			; 000000ffH
  000dc	75 25		 jne	 SHORT $LN17@gObjMonste@3
  000de	8b 9d 50 ff ff
	ff		 mov	 ebx, DWORD PTR _lpObj$GSCopy$[ebp]
$LN6@gObjMonste@3:

; 8164 : 	{
; 8165 : 		for(w = 0; w <8; w++)

  000e4	46		 inc	 esi
  000e5	83 fe 08	 cmp	 esi, 8
  000e8	7c c8		 jl	 SHORT $LL7@gObjMonste@3

; 8160 : 	iwidth = 1;
; 8161 : 	iheight = 1;
; 8162 : 
; 8163 : 	for(h = 0; h < 8; h++)

  000ea	47		 inc	 edi
  000eb	83 ff 08	 cmp	 edi, 8
  000ee	7c c0		 jl	 SHORT $LL22@gObjMonste@3
$GOTO_EndFunc$164614:
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi

; 8182 : 					return blank;
; 8183 : 				}
; 8184 : 			}
; 8185 : 		}
; 8186 : 	}
; 8187 : GOTO_EndFunc:
; 8188 : 	return -1;

  000f2	0c ff		 or	 al, 255			; 000000ffH
  000f4	5b		 pop	 ebx

; 8189 : }

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f8	33 cd		 xor	 ecx, ebp
  000fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
$LN17@gObjMonste@3:

; 8177 : 				{
; 8178 : 					lpObj->pInventory[blank] = item;

  00103	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$GSCopy$[ebp]
  00109	8b ba 8c 0c 00
	00		 mov	 edi, DWORD PTR [edx+3212]
  0010f	0f b6 c3	 movzx	 eax, bl
  00112	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00118	03 f8		 add	 edi, eax
  0011a	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0011f	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  00125	f3 a5		 rep movsd

; 8179 : 					*lpObj->pInventoryCount += 1;

  00127	8b 8a 94 0c 00
	00		 mov	 ecx, DWORD PTR [edx+3220]
  0012d	fe 01		 inc	 BYTE PTR [ecx]

; 8180 : 
; 8181 : 					gObjInventoryItemBoxSet(lpObj->m_Index,blank,iwidth,iwidth,lpObj->pInventory[blank].m_Type);

  0012f	8b 8a 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edx+3212]
  00135	0f b6 44 01 06	 movzx	 eax, BYTE PTR [ecx+eax+6]
  0013a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0013c	50		 push	 eax
  0013d	6a 01		 push	 1
  0013f	0f b6 c3	 movzx	 eax, bl
  00142	6a 01		 push	 1
  00144	50		 push	 eax
  00145	51		 push	 ecx
  00146	e8 00 00 00 00	 call	 ?gObjInventoryItemBoxSet@@YAXHHHHE@Z ; gObjInventoryItemBoxSet

; 8189 : }

  0014b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014e	83 c4 14	 add	 esp, 20			; 00000014H
  00151	5f		 pop	 edi
  00152	5e		 pop	 esi
  00153	8a c3		 mov	 al, bl
  00155	33 cd		 xor	 ecx, ebp
  00157	5b		 pop	 ebx
  00158	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c3		 ret	 0
?gObjMonsterInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHHHHH@Z ENDP ; gObjMonsterInventoryInsertItem
_TEXT	ENDS
PUBLIC	?gObjIsItemPut@@YAHPAUOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
; Function compile flags: /Ogtp
;	COMDAT ?gObjIsItemPut@@YAHPAUOBJECTSTRUCT@@PAVCItem@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
tv555 = 12						; size = 4
_lpItem$ = 12						; size = 4
_pos$ = 16						; size = 4
?gObjIsItemPut@@YAHPAUOBJECTSTRUCT@@PAVCItem@@H@Z PROC	; gObjIsItemPut, COMDAT

; 8319 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 8320 : 	if(lpItem->m_TwoHand == 1)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _lpItem$[ebp]
  00007	80 7b 0c 01	 cmp	 BYTE PTR [ebx+12], 1
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR _pos$[ebp]
  00013	75 76		 jne	 SHORT $LN96@gObjIsItem

; 8321 : 	{
; 8322 : 		if(pos == 0 || pos == 1)

  00015	85 ff		 test	 edi, edi
  00017	74 09		 je	 SHORT $LN77@gObjIsItem
  00019	83 ff 01	 cmp	 edi, 1
  0001c	0f 85 a1 00 00
	00		 jne	 $LN97@gObjIsItem
$LN77@gObjIsItem:

; 8323 : 		{
; 8324 : 			if(lpObj->pInventory[0].IsItem() == 1)

  00022	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	75 22		 jne	 SHORT $LN74@gObjIsItem

; 8325 : 			{
; 8326 : 				if(lpObj->pInventory[0].m_Type == ITEMGET(4,7) || lpObj->pInventory[0].m_Type == ITEMGET(4,15))

  00032	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00038	0f b7 40 06	 movzx	 eax, WORD PTR [eax+6]
  0003c	b9 07 08 00 00	 mov	 ecx, 2055		; 00000807H
  00041	66 3b c1	 cmp	 ax, cx
  00044	74 0e		 je	 SHORT $LN74@gObjIsItem
  00046	ba 0f 08 00 00	 mov	 edx, 2063		; 0000080fH
  0004b	66 3b c2	 cmp	 ax, dx

; 8327 : 				{
; 8328 : 					
; 8329 : 				}
; 8330 : 				else
; 8331 : 				{
; 8332 : 					return false;

  0004e	0f 85 8b 00 00
	00		 jne	 $LN111@gObjIsItem
$LN74@gObjIsItem:

; 8333 : 				}
; 8334 : 			}
; 8335 : 
; 8336 : 			if(lpObj->pInventory[1].IsItem() == 1)

  00054	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0005a	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00060	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00065	83 f8 01	 cmp	 eax, 1
  00068	75 21		 jne	 SHORT $LN96@gObjIsItem

; 8337 : 			{
; 8338 : 				if(lpObj->pInventory[1].m_Type == ITEMGET(4,7) || lpObj->pInventory[1].m_Type == ITEMGET(4,15))

  0006a	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00070	0f b7 80 ae 00
	00 00		 movzx	 eax, WORD PTR [eax+174]
  00077	b9 07 08 00 00	 mov	 ecx, 2055		; 00000807H
  0007c	66 3b c1	 cmp	 ax, cx
  0007f	74 0a		 je	 SHORT $LN96@gObjIsItem
  00081	ba 0f 08 00 00	 mov	 edx, 2063		; 0000080fH
  00086	66 3b c2	 cmp	 ax, dx

; 8339 : 				{
; 8340 : 					
; 8341 : 				}
; 8342 : 				else
; 8343 : 				{
; 8344 : 					return false;

  00089	75 54		 jne	 SHORT $LN111@gObjIsItem
$LN96@gObjIsItem:

; 8345 : 				}
; 8346 : 			}
; 8347 : 		}
; 8348 : 	}
; 8349 : 
; 8350 : 	if(pos == 1)

  0008b	83 ff 01	 cmp	 edi, 1
  0008e	75 33		 jne	 SHORT $LN97@gObjIsItem

; 8351 : 	{
; 8352 : 		if(lpObj->pInventory[0].IsItem() == 1)

  00090	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00096	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0009b	3b c7		 cmp	 eax, edi
  0009d	75 24		 jne	 SHORT $LN97@gObjIsItem

; 8353 : 		{
; 8354 : 			if(lpItem->m_Type == ITEMGET(4,7) || lpItem->m_Type == ITEMGET(4,15))

  0009f	0f b7 43 06	 movzx	 eax, WORD PTR [ebx+6]
  000a3	b9 07 08 00 00	 mov	 ecx, 2055		; 00000807H
  000a8	66 3b c1	 cmp	 ax, cx
  000ab	74 16		 je	 SHORT $LN97@gObjIsItem
  000ad	ba 0f 08 00 00	 mov	 edx, 2063		; 0000080fH
  000b2	66 3b c2	 cmp	 ax, dx
  000b5	74 0c		 je	 SHORT $LN97@gObjIsItem

; 8355 : 			{
; 8356 : 					
; 8357 : 			}
; 8358 : 			else
; 8359 : 			{
; 8360 : 				if(lpObj->pInventory[0].m_TwoHand)

  000b7	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  000bd	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0

; 8361 : 				{
; 8362 : 					return false;

  000c1	75 1c		 jne	 SHORT $LN111@gObjIsItem
$LN97@gObjIsItem:

; 8363 : 				}
; 8364 : 			}
; 8365 : 		}
; 8366 : 	}
; 8367 : 
; 8368 : 	if(lpItem->m_Part != pos)

  000c3	8a 43 0a	 mov	 al, BYTE PTR [ebx+10]
  000c6	0f b6 c8	 movzx	 ecx, al
  000c9	3b cf		 cmp	 ecx, edi
  000cb	74 21		 je	 SHORT $LN107@gObjIsItem

; 8369 : 	{
; 8370 : 		if(pos == 1 || pos == 0)

  000cd	83 ff 01	 cmp	 edi, 1
  000d0	74 14		 je	 SHORT $LN106@gObjIsItem
  000d2	85 ff		 test	 edi, edi
  000d4	74 10		 je	 SHORT $LN106@gObjIsItem

; 8379 : 			}
; 8380 : 		}
; 8381 : 		else if(pos == 11)

  000d6	83 ff 0b	 cmp	 edi, 11			; 0000000bH
  000d9	75 04		 jne	 SHORT $LN111@gObjIsItem

; 8382 : 		{
; 8383 : 			if(lpItem->m_Part == 10)

  000db	3c 0a		 cmp	 al, 10			; 0000000aH
  000dd	74 0f		 je	 SHORT $LN107@gObjIsItem
$LN111@gObjIsItem:
  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi

; 8384 : 			{
; 8385 : 
; 8386 : 			}
; 8387 : 			else
; 8388 : 			{
; 8389 : 				return false;

  000e1	33 c0		 xor	 eax, eax
  000e3	5b		 pop	 ebx

; 8577 : }

  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
$LN106@gObjIsItem:

; 8371 : 		{
; 8372 : 			if(lpItem->m_Part == 1 || lpItem->m_Part == 0)

  000e6	3c 01		 cmp	 al, 1
  000e8	74 04		 je	 SHORT $LN107@gObjIsItem
  000ea	84 c0		 test	 al, al

; 8373 : 			{
; 8374 : 
; 8375 : 			}
; 8376 : 			else
; 8377 : 			{
; 8378 : 				return false;

  000ec	75 f1		 jne	 SHORT $LN111@gObjIsItem
$LN107@gObjIsItem:

; 8390 : 			}
; 8391 : 		}
; 8392 : 		else
; 8393 : 		{
; 8394 : 			return false;
; 8395 : 		}
; 8396 : 	}
; 8397 : 
; 8398 : 	if((lpObj->Strength + lpObj->AddStrength) < lpItem->m_RequireStrength)

  000ee	0f bf 96 e0 00
	00 00		 movsx	 edx, WORD PTR [esi+224]
  000f5	0f b7 86 b4 00
	00 00		 movzx	 eax, WORD PTR [esi+180]
  000fc	0f b7 4b 42	 movzx	 ecx, WORD PTR [ebx+66]
  00100	03 d0		 add	 edx, eax
  00102	3b d1		 cmp	 edx, ecx

; 8399 : 	{
; 8400 : 		return false;

  00104	7c d9		 jl	 SHORT $LN111@gObjIsItem

; 8401 : 	}
; 8402 : 
; 8403 : 	if((lpObj->Dexterity + lpObj->AddDexterity) < lpItem->m_RequireDexterity)

  00106	0f bf 96 e2 00
	00 00		 movsx	 edx, WORD PTR [esi+226]
  0010d	0f b7 86 b6 00
	00 00		 movzx	 eax, WORD PTR [esi+182]
  00114	0f b7 4b 44	 movzx	 ecx, WORD PTR [ebx+68]
  00118	03 d0		 add	 edx, eax
  0011a	3b d1		 cmp	 edx, ecx

; 8404 : 	{
; 8405 : 		return false;

  0011c	7c c1		 jl	 SHORT $LN111@gObjIsItem

; 8406 : 	}
; 8407 : 
; 8408 : 	if(lpObj->Level < lpItem->m_RequireLevel)

  0011e	0f b7 96 9c 00
	00 00		 movzx	 edx, WORD PTR [esi+156]
  00125	0f b7 43 48	 movzx	 eax, WORD PTR [ebx+72]
  00129	0f bf ca	 movsx	 ecx, dx
  0012c	3b c8		 cmp	 ecx, eax

; 8409 : 	{
; 8410 : 		return false;

  0012e	7c af		 jl	 SHORT $LN111@gObjIsItem

; 8411 : 	}
; 8412 : 
; 8413 : 	if(lpItem->m_Type >= 0 && lpItem->m_Type < ITEMGET(12,0))

  00130	0f b7 43 06	 movzx	 eax, WORD PTR [ebx+6]
  00134	66 85 c0	 test	 ax, ax
  00137	78 3e		 js	 SHORT $LN46@gObjIsItem
  00139	b9 00 18 00 00	 mov	 ecx, 6144		; 00001800H
  0013e	66 3b c1	 cmp	 ax, cx
  00141	7d 34		 jge	 SHORT $LN46@gObjIsItem

; 8414 : 	{
; 8415 : 		if((lpObj->Vitality + lpObj->AddVitality) < lpItem->m_RequireVitality)

  00143	0f b7 be b8 00
	00 00		 movzx	 edi, WORD PTR [esi+184]
  0014a	0f bf 8e e4 00
	00 00		 movsx	 ecx, WORD PTR [esi+228]
  00151	03 cf		 add	 ecx, edi
  00153	0f b7 7b 4a	 movzx	 edi, WORD PTR [ebx+74]
  00157	3b cf		 cmp	 ecx, edi

; 8416 : 		{
; 8417 : 			return false;

  00159	7c 84		 jl	 SHORT $LN111@gObjIsItem

; 8418 : 		}
; 8419 : 
; 8420 : 		if((lpObj->Energy + lpObj->AddEnergy) < lpItem->m_RequireEnergy)

  0015b	0f b7 be ba 00
	00 00		 movzx	 edi, WORD PTR [esi+186]
  00162	0f bf 8e e6 00
	00 00		 movsx	 ecx, WORD PTR [esi+230]
  00169	03 cf		 add	 ecx, edi
  0016b	0f b7 7b 46	 movzx	 edi, WORD PTR [ebx+70]
  0016f	3b cf		 cmp	 ecx, edi

; 8421 : 		{
; 8422 : 			return false;

  00171	0f 8c 68 ff ff
	ff		 jl	 $LN111@gObjIsItem
$LN46@gObjIsItem:

; 8423 : 		}
; 8424 : 	}
; 8425 : 
; 8426 : 	if((lpObj->Leadership + lpObj->AddLeadership) < lpItem->m_RequireLeaderShip)

  00177	0f b7 be d8 00
	00 00		 movzx	 edi, WORD PTR [esi+216]
  0017e	0f b7 8e da 00
	00 00		 movzx	 ecx, WORD PTR [esi+218]
  00185	03 cf		 add	 ecx, edi
  00187	0f b7 7b 4c	 movzx	 edi, WORD PTR [ebx+76]
  0018b	3b cf		 cmp	 ecx, edi

; 8427 : 	{
; 8428 : 		return false;

  0018d	0f 8c 4c ff ff
	ff		 jl	 $LN111@gObjIsItem

; 8429 : 	}
; 8430 : 
; 8431 : 	if(lpItem->m_Type >= ITEMGET(12,0) && lpItem->m_Type <= ITEMGET(12,6))
; 8432 : 	{
; 8433 : 		if(lpObj->Level < lpItem->m_RequireLevel)
; 8434 : 		{
; 8435 : 			return false;
; 8436 : 		}
; 8437 : 	}
; 8438 : 	if(NEWWINGS(lpItem->m_Type) )

  00193	b9 64 18 00 00	 mov	 ecx, 6244		; 00001864H
  00198	66 3b c1	 cmp	 ax, cx
  0019b	7c 19		 jl	 SHORT $LN98@gObjIsItem
  0019d	89 55 0c	 mov	 DWORD PTR tv555[ebp], edx
  001a0	33 d2		 xor	 edx, edx
  001a2	b9 7d 18 00 00	 mov	 ecx, 6269		; 0000187dH
  001a7	66 3b c1	 cmp	 ax, cx
  001aa	0f 9e c2	 setle	 dl
  001ad	8b ca		 mov	 ecx, edx
  001af	8b 55 0c	 mov	 edx, DWORD PTR tv555[ebp]
  001b2	85 c9		 test	 ecx, ecx
  001b4	75 70		 jne	 SHORT $LN100@gObjIsItem
$LN98@gObjIsItem:

; 8439 : 	{
; 8440 : 		if(lpObj->Level < lpItem->m_RequireLevel)
; 8441 : 		{
; 8442 : 			return false;
; 8443 : 		}
; 8444 : 	}
; 8445 : 	else if(lpItem->m_Type >= ITEMGET(13,0) && lpItem->m_Type <= ITEMGET(13,15))

  001b6	b9 00 1a 00 00	 mov	 ecx, 6656		; 00001a00H
  001bb	66 3b c1	 cmp	 ax, cx
  001be	7c 66		 jl	 SHORT $LN100@gObjIsItem
  001c0	b9 0f 1a 00 00	 mov	 ecx, 6671		; 00001a0fH
  001c5	66 3b c1	 cmp	 ax, cx
  001c8	7f 5c		 jg	 SHORT $LN100@gObjIsItem

; 8446 : 	{
; 8447 : 		if(lpItem->m_Type == ITEMGET(13,10))

  001ca	b9 0a 1a 00 00	 mov	 ecx, 6666		; 00001a0aH
  001cf	66 3b c1	 cmp	 ax, cx
  001d2	75 21		 jne	 SHORT $LN38@gObjIsItem

; 8448 : 		{
; 8449 : 			if(lpItem->m_Level <= 2)

  001d4	66 83 7b 08 02	 cmp	 WORD PTR [ebx+8], 2
  001d9	7f 0d		 jg	 SHORT $LN37@gObjIsItem

; 8450 : 			{
; 8451 : 				if(lpObj->Level < 20)

  001db	66 83 fa 14	 cmp	 dx, 20			; 00000014H
  001df	7d 45		 jge	 SHORT $LN100@gObjIsItem

; 8452 : 				{
; 8453 : 					return false;

  001e1	5f		 pop	 edi
  001e2	5e		 pop	 esi
  001e3	33 c0		 xor	 eax, eax
  001e5	5b		 pop	 ebx

; 8577 : }

  001e6	5d		 pop	 ebp
  001e7	c3		 ret	 0
$LN37@gObjIsItem:

; 8454 : 				}
; 8455 : 			}
; 8456 : 			else
; 8457 : 			{
; 8458 : 				if(lpObj->Level < 50)

  001e8	66 83 fa 32	 cmp	 dx, 50			; 00000032H
  001ec	7d 38		 jge	 SHORT $LN100@gObjIsItem

; 8459 : 				{
; 8460 : 					return false;

  001ee	5f		 pop	 edi
  001ef	5e		 pop	 esi
  001f0	33 c0		 xor	 eax, eax
  001f2	5b		 pop	 ebx

; 8577 : }

  001f3	5d		 pop	 ebp
  001f4	c3		 ret	 0
$LN38@gObjIsItem:

; 8461 : 				}
; 8462 : 			}
; 8463 : 		}
; 8464 : 		else if(lpItem->m_Type == ITEMGET(13,2))

  001f5	ba 02 1a 00 00	 mov	 edx, 6658		; 00001a02H
  001fa	66 3b c2	 cmp	 ax, dx
  001fd	75 10		 jne	 SHORT $LN32@gObjIsItem

; 8465 : 		{
; 8466 : 			if(lpObj->MapNumber == 7 || lpObj->Level < lpItem->m_RequireLevel)

  001ff	80 be 09 01 00
	00 07		 cmp	 BYTE PTR [esi+265], 7
  00206	75 1e		 jne	 SHORT $LN100@gObjIsItem

; 8467 : 			{
; 8468 : 				return false;

  00208	5f		 pop	 edi
  00209	5e		 pop	 esi
  0020a	33 c0		 xor	 eax, eax
  0020c	5b		 pop	 ebx

; 8577 : }

  0020d	5d		 pop	 ebp
  0020e	c3		 ret	 0
$LN32@gObjIsItem:

; 8469 : 			}
; 8470 : 		}
; 8471 : 		else if(lpItem->m_Type == ITEMGET(13,3))

  0020f	b9 03 1a 00 00	 mov	 ecx, 6659		; 00001a03H
  00214	66 3b c1	 cmp	 ax, cx
  00217	75 0d		 jne	 SHORT $LN100@gObjIsItem

; 8472 : 		{
; 8473 : 			if(lpObj->MapNumber == 7 || lpObj->Level < lpItem->m_RequireLevel)

  00219	80 be 09 01 00
	00 07		 cmp	 BYTE PTR [esi+265], 7

; 8474 : 			{
; 8475 : 				return false;

  00220	0f 84 b9 fe ff
	ff		 je	 $LN111@gObjIsItem
$LN100@gObjIsItem:

; 8476 : 			}
; 8477 : 		}
; 8478 : 		else
; 8479 : 		{
; 8480 : 			if(lpObj->Level < lpItem->m_RequireLevel)
; 8481 : 			{
; 8482 : 				return false;
; 8483 : 			}
; 8484 : 		}
; 8485 : 	}
; 8486 : 
; 8487 : 	if(lpItem->m_Type == ITEMGET(13,20) && lpItem->m_Level == 0)

  00226	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  0022b	66 3b c2	 cmp	 ax, dx
  0022e	75 20		 jne	 SHORT $LN102@gObjIsItem
  00230	66 83 7b 08 00	 cmp	 WORD PTR [ebx+8], 0
  00235	75 19		 jne	 SHORT $LN102@gObjIsItem

; 8488 : 	{
; 8489 : 		int count = gObjGetItemCountInEquipment(lpObj->m_Index,13,20,0);

  00237	8b 06		 mov	 eax, DWORD PTR [esi]
  00239	6a 00		 push	 0
  0023b	6a 14		 push	 20			; 00000014H
  0023d	6a 0d		 push	 13			; 0000000dH
  0023f	50		 push	 eax
  00240	e8 00 00 00 00	 call	 ?gObjGetItemCountInEquipment@@YAHHHHH@Z ; gObjGetItemCountInEquipment
  00245	83 c4 10	 add	 esp, 16			; 00000010H

; 8490 : 
; 8491 : 		if(count != 0)

  00248	85 c0		 test	 eax, eax

; 8492 : 		{
; 8493 : 			return false;

  0024a	0f 85 8f fe ff
	ff		 jne	 $LN111@gObjIsItem
$LN102@gObjIsItem:

; 8494 : 		}
; 8495 : 	}
; 8496 : 
; 8497 : 	if(lpItem->m_Type == ITEMGET(13,10))

  00250	0f b7 4b 06	 movzx	 ecx, WORD PTR [ebx+6]
  00254	ba 0a 1a 00 00	 mov	 edx, 6666		; 00001a0aH
  00259	66 3b ca	 cmp	 cx, dx
  0025c	75 18		 jne	 SHORT $LN103@gObjIsItem

; 8498 : 	{
; 8499 : 		if(CC_MAP_RANGE(lpObj->MapNumber))

  0025e	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00265	3c 12		 cmp	 al, 18			; 00000012H
  00267	72 0d		 jb	 SHORT $LN103@gObjIsItem
  00269	b2 17		 mov	 dl, 23			; 00000017H
  0026b	3a d0		 cmp	 dl, al
  0026d	1b c0		 sbb	 eax, eax
  0026f	40		 inc	 eax

; 8500 : 		{
; 8501 : 			return false;

  00270	0f 85 69 fe ff
	ff		 jne	 $LN111@gObjIsItem
$LN103@gObjIsItem:

; 8502 : 		}
; 8503 : 	}
; 8504 : 
; 8505 : 	if(lpItem->m_Type == ITEMGET(13,37))

  00276	b8 25 1a 00 00	 mov	 eax, 6693		; 00001a25H
  0027b	66 3b c8	 cmp	 cx, ax
  0027e	75 18		 jne	 SHORT $LN104@gObjIsItem

; 8506 : 	{
; 8507 : 		if(CC_MAP_RANGE(lpObj->MapNumber))

  00280	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00287	3c 12		 cmp	 al, 18			; 00000012H
  00289	72 0d		 jb	 SHORT $LN104@gObjIsItem
  0028b	b2 17		 mov	 dl, 23			; 00000017H
  0028d	3a d0		 cmp	 dl, al
  0028f	1b c0		 sbb	 eax, eax
  00291	40		 inc	 eax

; 8508 : 		{
; 8509 : 			return false;

  00292	0f 85 47 fe ff
	ff		 jne	 $LN111@gObjIsItem
$LN104@gObjIsItem:

; 8510 : 		}
; 8511 : 	}
; 8512 : 
; 8513 : 	if(lpItem->m_Type == ITEMGET(13,38))

  00298	b8 26 1a 00 00	 mov	 eax, 6694		; 00001a26H
  0029d	66 3b c8	 cmp	 cx, ax
  002a0	75 19		 jne	 SHORT $LN109@gObjIsItem

; 8514 : 	{
; 8515 : 		int count = gObjGetItemCountInEquipment(lpObj->m_Index,13,38,0);

  002a2	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002a4	6a 00		 push	 0
  002a6	6a 26		 push	 38			; 00000026H
  002a8	6a 0d		 push	 13			; 0000000dH
  002aa	51		 push	 ecx
  002ab	e8 00 00 00 00	 call	 ?gObjGetItemCountInEquipment@@YAHHHHH@Z ; gObjGetItemCountInEquipment
  002b0	83 c4 10	 add	 esp, 16			; 00000010H

; 8516 : 
; 8517 : 		if(count != 0)

  002b3	85 c0		 test	 eax, eax

; 8518 : 		{
; 8519 : 			return false;

  002b5	0f 85 24 fe ff
	ff		 jne	 $LN111@gObjIsItem
$LN109@gObjIsItem:

; 8520 : 		}
; 8521 : 	}
; 8522 : 
; 8523 : 	if(lpItem->m_Type == ITEMGET(13,39))

  002bb	ba 27 1a 00 00	 mov	 edx, 6695		; 00001a27H
  002c0	66 39 53 06	 cmp	 WORD PTR [ebx+6], dx
  002c4	75 50		 jne	 SHORT $LN105@gObjIsItem

; 8524 : 	{
; 8525 : 		if(CC_MAP_RANGE(lpObj->MapNumber))

  002c6	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  002cd	3c 12		 cmp	 al, 18			; 00000012H
  002cf	72 0d		 jb	 SHORT $LN110@gObjIsItem
  002d1	b1 17		 mov	 cl, 23			; 00000017H
  002d3	3a c8		 cmp	 cl, al
  002d5	1b c0		 sbb	 eax, eax
  002d7	40		 inc	 eax

; 8526 : 		{
; 8527 : 			return false;

  002d8	0f 85 01 fe ff
	ff		 jne	 $LN111@gObjIsItem
$LN110@gObjIsItem:

; 8528 : 		}
; 8529 : 
; 8530 : 		int count = 0;
; 8531 : 
; 8532 : 		for(int n = 0; n < 7; n++)

  002de	33 ff		 xor	 edi, edi
$LL13@gObjIsItem:

; 8533 : 		{
; 8534 : 			count = gObjGetItemCountInEquipment(lpObj->m_Index,13,10,n);

  002e0	8b 16		 mov	 edx, DWORD PTR [esi]
  002e2	57		 push	 edi
  002e3	6a 0a		 push	 10			; 0000000aH
  002e5	6a 0d		 push	 13			; 0000000dH
  002e7	52		 push	 edx
  002e8	e8 00 00 00 00	 call	 ?gObjGetItemCountInEquipment@@YAHHHHH@Z ; gObjGetItemCountInEquipment
  002ed	83 c4 10	 add	 esp, 16			; 00000010H

; 8535 : 
; 8536 : 			if(count != 0)

  002f0	85 c0		 test	 eax, eax
  002f2	0f 85 e7 fd ff
	ff		 jne	 $LN111@gObjIsItem

; 8528 : 		}
; 8529 : 
; 8530 : 		int count = 0;
; 8531 : 
; 8532 : 		for(int n = 0; n < 7; n++)

  002f8	47		 inc	 edi
  002f9	83 ff 07	 cmp	 edi, 7
  002fc	7c e2		 jl	 SHORT $LL13@gObjIsItem

; 8537 : 			{
; 8538 : 				return false;
; 8539 : 			}
; 8540 : 		}
; 8541 : 
; 8542 : 		count = gObjGetItemCountInEquipment(lpObj->m_Index,13,39,0);

  002fe	50		 push	 eax
  002ff	8b 06		 mov	 eax, DWORD PTR [esi]
  00301	6a 27		 push	 39			; 00000027H
  00303	6a 0d		 push	 13			; 0000000dH
  00305	50		 push	 eax
  00306	e8 00 00 00 00	 call	 ?gObjGetItemCountInEquipment@@YAHHHHH@Z ; gObjGetItemCountInEquipment
  0030b	83 c4 10	 add	 esp, 16			; 00000010H

; 8543 : 
; 8544 : 		if(count != 0)

  0030e	85 c0		 test	 eax, eax

; 8545 : 		{
; 8546 : 			return false;

  00310	0f 85 c9 fd ff
	ff		 jne	 $LN111@gObjIsItem
$LN105@gObjIsItem:

; 8547 : 		}
; 8548 : 	}
; 8549 : 
; 8550 : 	if(lpItem->m_Type == ITEMGET(13,10))

  00316	0f b7 43 06	 movzx	 eax, WORD PTR [ebx+6]
  0031a	b9 0a 1a 00 00	 mov	 ecx, 6666		; 00001a0aH
  0031f	66 3b c1	 cmp	 ax, cx
  00322	75 3b		 jne	 SHORT $LN8@gObjIsItem

; 8551 : 	{
; 8552 : 		int count = 0;
; 8553 : 
; 8554 : 		for(int n = 0; n < 7; n ++)

  00324	33 ff		 xor	 edi, edi
$LL7@gObjIsItem:

; 8555 : 		{
; 8556 : 			count = gObjGetItemCountInEquipment(lpObj->m_Index,13,10,n);

  00326	8b 16		 mov	 edx, DWORD PTR [esi]
  00328	57		 push	 edi
  00329	6a 0a		 push	 10			; 0000000aH
  0032b	6a 0d		 push	 13			; 0000000dH
  0032d	52		 push	 edx
  0032e	e8 00 00 00 00	 call	 ?gObjGetItemCountInEquipment@@YAHHHHH@Z ; gObjGetItemCountInEquipment
  00333	83 c4 10	 add	 esp, 16			; 00000010H

; 8557 : 
; 8558 : 			if(count != 0)

  00336	85 c0		 test	 eax, eax
  00338	0f 85 a1 fd ff
	ff		 jne	 $LN111@gObjIsItem

; 8551 : 	{
; 8552 : 		int count = 0;
; 8553 : 
; 8554 : 		for(int n = 0; n < 7; n ++)

  0033e	47		 inc	 edi
  0033f	83 ff 07	 cmp	 edi, 7
  00342	7c e2		 jl	 SHORT $LL7@gObjIsItem

; 8559 : 			{
; 8560 : 				return false;
; 8561 : 			}
; 8562 : 		}
; 8563 : 
; 8564 : 		count = gObjGetItemCountInEquipment(lpObj->m_Index,13,39,0);

  00344	50		 push	 eax
  00345	8b 06		 mov	 eax, DWORD PTR [esi]
  00347	6a 27		 push	 39			; 00000027H
  00349	6a 0d		 push	 13			; 0000000dH
  0034b	50		 push	 eax
  0034c	e8 00 00 00 00	 call	 ?gObjGetItemCountInEquipment@@YAHHHHH@Z ; gObjGetItemCountInEquipment
  00351	83 c4 10	 add	 esp, 16			; 00000010H

; 8565 : 
; 8566 : 		if(count != 0)

  00354	85 c0		 test	 eax, eax
  00356	74 15		 je	 SHORT $LN1@gObjIsItem

; 8567 : 		{
; 8568 : 			return false;

  00358	5f		 pop	 edi
  00359	5e		 pop	 esi
  0035a	33 c0		 xor	 eax, eax
  0035c	5b		 pop	 ebx

; 8577 : }

  0035d	5d		 pop	 ebp
  0035e	c3		 ret	 0
$LN8@gObjIsItem:

; 8569 : 		}
; 8570 : 	}
; 8571 : 	else if(lpItem->m_Type >= ITEMGET(14,00))

  0035f	b9 00 1c 00 00	 mov	 ecx, 7168		; 00001c00H
  00364	66 3b c1	 cmp	 ax, cx

; 8572 : 	{
; 8573 : 		return false;

  00367	0f 8d 72 fd ff
	ff		 jge	 $LN111@gObjIsItem
$LN1@gObjIsItem:
  0036d	5f		 pop	 edi
  0036e	5e		 pop	 esi

; 8574 : 	}
; 8575 : 
; 8576 : 	return true;

  0036f	b8 01 00 00 00	 mov	 eax, 1
  00374	5b		 pop	 ebx

; 8577 : }

  00375	5d		 pop	 ebp
  00376	c3		 ret	 0
?gObjIsItemPut@@YAHPAUOBJECTSTRUCT@@PAVCItem@@H@Z ENDP	; gObjIsItemPut
_TEXT	ENDS
PUBLIC	_pos$GSCopy$
PUBLIC	_aIndex$GSCopy$
PUBLIC	?gObjInventoryInsertItemPos@@YAEHVCItem@@HH@Z	; gObjInventoryInsertItemPos
EXTRN	?GCMagicListOneSend@@YAXHDEEEE@Z:PROC		; GCMagicListOneSend
EXTRN	?IsClass@CItem@@QAEHDH@Z:PROC			; CItem::IsClass
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventoryInsertItemPos@@YAEHVCItem@@HH@Z
_TEXT	SEGMENT
_TempInventoryMap$ = -124				; size = 96
_iheight$ = -28						; size = 4
_aIndex$GSCopy$ = -24					; size = 4
_h$ = -20						; size = 4
_iwidth$ = -16						; size = 4
_w$ = -12						; size = 4
tv229 = -8						; size = 4
_pos$GSCopy$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 168
_pos$ = 180						; size = 4
_RequestCheck$ = 184					; size = 4
?gObjInventoryInsertItemPos@@YAEHVCItem@@HH@Z PROC	; gObjInventoryInsertItemPos, COMDAT

; 8933 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	8b b5 b4 00 00
	00		 mov	 esi, DWORD PTR _pos$[ebp]

; 9020 : 			{
; 9021 : 				GCMagicListOneSend(lpObj->m_Index,result,lpItem->m_Special[0],lpItem->m_Level,0,0);

  00011	89 5d e8	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  00014	89 75 fc	 mov	 DWORD PTR _pos$GSCopy$[ebp], esi
  00017	83 fe 6c	 cmp	 esi, 108		; 0000006cH
  0001a	77 27		 ja	 SHORT $LN24@gObjInvent@17

; 8934 : 	if(pos < 0 || pos > INVENTORY_SIZE)
; 8935 : 	{
; 8936 : 		return -1;
; 8937 : 	}
; 8938 : 
; 8939 : 	LPOBJ lpObj;
; 8940 : 	BYTE TempInventoryMap[INVENTORY_MAP_SIZE];
; 8941 : 
; 8942 : 	int w,h,iwidth,iheight;
; 8943 : 
; 8944 : 	int blank,useClass = 0;
; 8945 : 
; 8946 : 	lpObj = &gObj[aIndex];
; 8947 : 
; 8948 : 	if(lpObj->pInventory[pos].IsItem() == 1)

  0001c	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  00022	69 f6 a8 00 00
	00		 imul	 esi, 168		; 000000a8H
  00028	81 c3 00 00 00
	00		 add	 ebx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002e	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  00034	03 ce		 add	 ecx, esi
  00036	89 75 f8	 mov	 DWORD PTR tv229[ebp], esi
  00039	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0003e	83 f8 01	 cmp	 eax, 1
  00041	75 08		 jne	 SHORT $LN14@gObjInvent@17
$LN24@gObjInvent@17:
  00043	5e		 pop	 esi

; 8949 : 	{
; 8950 : 		return -1;

  00044	0c ff		 or	 al, 255			; 000000ffH
  00046	5b		 pop	 ebx

; 9026 : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN14@gObjInvent@17:

; 8951 : 	}
; 8952 : 
; 8953 : 	if(item.IsItem() == 0)

  0004b	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  0004e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00053	85 c0		 test	 eax, eax

; 8954 : 	{
; 8955 : 		return -1;

  00055	74 ec		 je	 SHORT $LN24@gObjInvent@17

; 8956 : 	}
; 8957 : 
; 8958 : 	if(pos < 12)

  00057	8b 45 fc	 mov	 eax, DWORD PTR _pos$GSCopy$[ebp]
  0005a	57		 push	 edi
  0005b	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0005e	7d 6e		 jge	 SHORT $LN12@gObjInvent@17

; 8959 : 	{
; 8960 : 		useClass = item.IsClass(lpObj->Class,lpObj->ChangeUP);
; 8961 : 
; 8962 : 		if(useClass == 0)

  00060	0f b6 83 9b 00
	00 00		 movzx	 eax, BYTE PTR [ebx+155]
  00067	0f b6 8b 98 00
	00 00		 movzx	 ecx, BYTE PTR [ebx+152]
  0006e	50		 push	 eax
  0006f	51		 push	 ecx
  00070	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  00073	e8 00 00 00 00	 call	 ?IsClass@CItem@@QAEHDH@Z ; CItem::IsClass
  00078	85 c0		 test	 eax, eax
  0007a	75 23		 jne	 SHORT $LN11@gObjInvent@17

; 8963 : 		{
; 8964 : 			LogAdd(LOG_BLACK, lMsg.Get(528));

  0007c	68 10 02 00 00	 push	 528			; 00000210H
  00081	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00086	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0008b	50		 push	 eax
  0008c	6a 00		 push	 0
  0008e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00093	83 c4 08	 add	 esp, 8
$LN23@gObjInvent@17:

; 8971 : 			{
; 8972 : 				return -1;

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	0c ff		 or	 al, 255			; 000000ffH
  0009a	5b		 pop	 ebx

; 9026 : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
$LN11@gObjInvent@17:

; 8965 : 			return -1;
; 8966 : 		}
; 8967 : 
; 8968 : 		if(RequestCheck != 0)

  0009f	83 bd b8 00 00
	00 00		 cmp	 DWORD PTR _RequestCheck$[ebp], 0
  000a6	0f 84 d2 00 00
	00		 je	 $LN5@gObjInvent@17

; 8969 : 		{
; 8970 : 			if(gObjIsItemPut(lpObj,&item,pos) == 0)

  000ac	8b 55 fc	 mov	 edx, DWORD PTR _pos$GSCopy$[ebp]
  000af	52		 push	 edx
  000b0	8d 45 0c	 lea	 eax, DWORD PTR _item$[ebp]
  000b3	50		 push	 eax
  000b4	53		 push	 ebx
  000b5	e8 00 00 00 00	 call	 ?gObjIsItemPut@@YAHPAUOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bd	85 c0		 test	 eax, eax
  000bf	0f 85 b9 00 00
	00		 jne	 $LN5@gObjInvent@17

; 8971 : 			{
; 8972 : 				return -1;

  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	0c ff		 or	 al, 255			; 000000ffH
  000c9	5b		 pop	 ebx

; 9026 : }

  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
$LN12@gObjInvent@17:

; 8973 : 			}
; 8974 : 		}
; 8975 : 	}
; 8976 : 	else
; 8977 : 	{
; 8978 : 		w = (pos - 12)%8;

  000ce	83 c0 f4	 add	 eax, -12		; fffffff4H
  000d1	8b c8		 mov	 ecx, eax
  000d3	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H
  000d9	79 05		 jns	 SHORT $LN22@gObjInvent@17
  000db	49		 dec	 ecx
  000dc	83 c9 f8	 or	 ecx, -8			; fffffff8H
  000df	41		 inc	 ecx
$LN22@gObjInvent@17:

; 8979 : 		h = (pos - 12)/8;

  000e0	99		 cdq
  000e1	83 e2 07	 and	 edx, 7

; 8980 : 
; 8981 : 		if(ExtentCheck(w,h,8,12)==0)

  000e4	6a 0c		 push	 12			; 0000000cH
  000e6	03 c2		 add	 eax, edx
  000e8	c1 f8 03	 sar	 eax, 3
  000eb	6a 08		 push	 8
  000ed	50		 push	 eax
  000ee	51		 push	 ecx
  000ef	89 4d f4	 mov	 DWORD PTR _w$[ebp], ecx
  000f2	89 45 ec	 mov	 DWORD PTR _h$[ebp], eax
  000f5	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  000fa	83 c4 10	 add	 esp, 16			; 00000010H
  000fd	85 c0		 test	 eax, eax

; 8982 : 		{
; 8983 : 			return -1;

  000ff	74 95		 je	 SHORT $LN23@gObjInvent@17

; 8984 : 		}
; 8985 : 
; 8986 : 		memcpy(TempInventoryMap,lpObj->pInventoryMap,INVENTORY_MAP_SIZE);

  00101	8b b3 90 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3216]
  00107	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0010c	8d 7d 84	 lea	 edi, DWORD PTR _TempInventoryMap$[ebp]
  0010f	f3 a5		 rep movsd

; 8987 : 		item.GetSize((int &)iwidth,(int &)iheight);

  00111	8d 4d e4	 lea	 ecx, DWORD PTR _iheight$[ebp]
  00114	51		 push	 ecx
  00115	8d 55 f0	 lea	 edx, DWORD PTR _iwidth$[ebp]
  00118	52		 push	 edx
  00119	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  0011c	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 8988 : 
; 8989 : 		if(*(BYTE*)(lpObj->pInventoryMap + h * 8 + w) != 255 )

  00121	8b bb 90 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3216]
  00127	8b 4d ec	 mov	 ecx, DWORD PTR _h$[ebp]
  0012a	8b 45 f4	 mov	 eax, DWORD PTR _w$[ebp]
  0012d	8d 14 cf	 lea	 edx, DWORD PTR [edi+ecx*8]
  00130	80 3c 02 ff	 cmp	 BYTE PTR [edx+eax], 255	; 000000ffH
  00134	74 13		 je	 SHORT $LN6@gObjInvent@17

; 8990 : 		{
; 8991 : 			memcpy(lpObj->pInventoryMap,TempInventoryMap,INVENTORY_MAP_SIZE);

  00136	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0013b	8d 75 84	 lea	 esi, DWORD PTR _TempInventoryMap$[ebp]
  0013e	f3 a5		 rep movsd
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	0c ff		 or	 al, 255			; 000000ffH
  00144	5b		 pop	 ebx

; 9026 : }

  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c3		 ret	 0
$LN6@gObjInvent@17:

; 8992 : 			return -1;
; 8993 : 		}
; 8994 : 
; 8995 : 		blank = gObjInventoryRectCheck(lpObj->m_Index,w,h,iwidth,iheight);

  00149	8b 55 e4	 mov	 edx, DWORD PTR _iheight$[ebp]
  0014c	52		 push	 edx
  0014d	8b 55 f0	 mov	 edx, DWORD PTR _iwidth$[ebp]
  00150	52		 push	 edx
  00151	51		 push	 ecx
  00152	50		 push	 eax
  00153	8b 03		 mov	 eax, DWORD PTR [ebx]
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  0015b	83 c4 14	 add	 esp, 20			; 00000014H

; 8996 : 
; 8997 : 		if(blank >= 254)

  0015e	3c fe		 cmp	 al, 254			; 000000feH
  00160	72 19		 jb	 SHORT $LN19@gObjInvent@17

; 8998 : 		{
; 8999 : 			memcpy(lpObj->pInventoryMap,TempInventoryMap,INVENTORY_MAP_SIZE);

  00162	8b bb 90 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3216]
  00168	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0016d	8d 75 84	 lea	 esi, DWORD PTR _TempInventoryMap$[ebp]
  00170	f3 a5		 rep movsd
  00172	5f		 pop	 edi
  00173	5e		 pop	 esi

; 9000 : 			return false;

  00174	32 c0		 xor	 al, al
  00176	5b		 pop	 ebx

; 9026 : }

  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
$LN19@gObjInvent@17:

; 9000 : 			return false;

  0017b	8b 75 f8	 mov	 esi, DWORD PTR tv229[ebp]
$LN5@gObjInvent@17:

; 9001 : 		}
; 9002 : 	}
; 9003 : 
; 9004 : 	lpObj->pInventory[pos] = item;

  0017e	8b bb 8c 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3212]

; 9005 : 
; 9006 : 	if(pos > 11)

  00184	8b 45 fc	 mov	 eax, DWORD PTR _pos$GSCopy$[ebp]
  00187	03 fe		 add	 edi, esi
  00189	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0018e	8d 75 0c	 lea	 esi, DWORD PTR _item$[ebp]
  00191	f3 a5		 rep movsd
  00193	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00196	7e 0f		 jle	 SHORT $LN4@gObjInvent@17

; 9007 : 	{
; 9008 : 		gObjInventoryItemSet(aIndex,pos,1);

  00198	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0019b	6a 01		 push	 1
  0019d	50		 push	 eax
  0019e	51		 push	 ecx
  0019f	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  001a4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@gObjInvent@17:

; 9009 : 	}
; 9010 : 
; 9011 : 	if(pos < 12)

  001a7	83 7d fc 0c	 cmp	 DWORD PTR _pos$GSCopy$[ebp], 12 ; 0000000cH
  001ab	7d 40		 jge	 SHORT $LN20@gObjInvent@17

; 9012 : 	{
; 9013 : 		CItem * lpItem = &lpObj->pInventory[pos];

  001ad	8b b3 8c 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3212]
  001b3	03 75 f8	 add	 esi, DWORD PTR tv229[ebp]

; 9014 : 
; 9015 : 		if(lpItem->m_Option1)

  001b6	80 7e 78 00	 cmp	 BYTE PTR [esi+120], 0
  001ba	74 31		 je	 SHORT $LN20@gObjInvent@17

; 9016 : 		{
; 9017 : 			int result = gObjWeaponMagicAdd(lpObj,lpItem->m_Special[0],lpItem->m_Level);

  001bc	0f b6 56 08	 movzx	 edx, BYTE PTR [esi+8]
  001c0	0f b6 46 31	 movzx	 eax, BYTE PTR [esi+49]
  001c4	52		 push	 edx
  001c5	50		 push	 eax
  001c6	53		 push	 ebx
  001c7	e8 00 00 00 00	 call	 ?gObjWeaponMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjWeaponMagicAdd
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9018 : 
; 9019 : 			if(result >= 0)

  001cf	85 c0		 test	 eax, eax
  001d1	78 1a		 js	 SHORT $LN20@gObjInvent@17

; 9020 : 			{
; 9021 : 				GCMagicListOneSend(lpObj->m_Index,result,lpItem->m_Special[0],lpItem->m_Level,0,0);

  001d3	0f b6 4e 08	 movzx	 ecx, BYTE PTR [esi+8]
  001d7	0f b6 56 31	 movzx	 edx, BYTE PTR [esi+49]
  001db	6a 00		 push	 0
  001dd	6a 00		 push	 0
  001df	51		 push	 ecx
  001e0	52		 push	 edx
  001e1	50		 push	 eax
  001e2	8b 03		 mov	 eax, DWORD PTR [ebx]
  001e4	50		 push	 eax
  001e5	e8 00 00 00 00	 call	 ?GCMagicListOneSend@@YAXHDEEEE@Z ; GCMagicListOneSend
  001ea	83 c4 18	 add	 esp, 24			; 00000018H
$LN20@gObjInvent@17:

; 9022 : 			}
; 9023 : 		}
; 9024 : 	}
; 9025 : 	return pos;

  001ed	8a 45 fc	 mov	 al, BYTE PTR _pos$GSCopy$[ebp]
  001f0	5f		 pop	 edi
  001f1	5e		 pop	 esi
  001f2	5b		 pop	 ebx

; 9026 : }

  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c3		 ret	 0
?gObjInventoryInsertItemPos@@YAEHVCItem@@HH@Z ENDP	; gObjInventoryInsertItemPos
_TEXT	ENDS
PUBLIC	__real@406f400000000000
PUBLIC	__real@40400000
PUBLIC	__real@41200000
PUBLIC	__real@41a00000
PUBLIC	??_C@_0EA@MOKNMDJN@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLMove@ ; `string'
PUBLIC	__real@406fe00000000000
PUBLIC	??_C@_0EL@PCJJPCHK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Move@ ; `string'
PUBLIC	??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z	; gObjInventoryMoveItem
EXTRN	?GCEquipmentChange@@YAXHH@Z:PROC		; GCEquipmentChange
EXTRN	?gDoPShopOpen@@3HA:DWORD			; gDoPShopOpen
EXTRN	?BufferItemtoConvert3@@YAXPAEAAHAAE2222@Z:PROC	; BufferItemtoConvert3
EXTRN	__except_handler4:PROC
EXTRN	__local_unwind4:PROC
;	COMDAT __real@406f400000000000
CONST	SEGMENT
__real@406f400000000000 DQ 0406f400000000000r	; 250
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT ??_C@_0EA@MOKNMDJN@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLMove@
CONST	SEGMENT
??_C@_0EA@MOKNMDJN@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLMove@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [MoveItem] (%s)(%s) Item(%s) Pos(%d'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT ??_C@_0EL@PCJJPCHK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Move@
CONST	SEGMENT
??_C@_0EL@PCJJPCHK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Move@ DB '['
	DB	'PShop] [%s][%s] PShop Item Move Request Failed : Already Trad'
	DB	'e With Other', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd?$AA@ DB 'error-L1 : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z DD 0fffffffeH
	DD	00H
	DD	0ffffff50H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN241@gObjInvent@18
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z
_TEXT	SEGMENT
_TempInventoryMap$ = -160				; size = 64
_type$165098 = -96					; size = 4
_iwidth$ = -92						; size = 4
_iheight$ = -88						; size = 4
_dur$165097 = -81					; size = 1
tv1887 = -80						; size = 4
tv1867 = -80						; size = 4
_bPersonalShopTrans$ = -76				; size = 4
tv1885 = -69						; size = 1
tv1809 = -68						; size = 4
_dif_dur$165199 = -68					; size = 4
tv1794 = -64						; size = 4
_op2$165095 = -57					; size = 1
tv2383 = -56						; size = 4
tv2010 = -56						; size = 4
tv2003 = -56						; size = 4
tv1988 = -56						; size = 4
_s_num$ = -56						; size = 4
_op3$165096 = -51					; size = 1
_level$165093 = -50					; size = 1
_op1$165094 = -49					; size = 1
_max_count$165172 = -48					; size = 4
tv1891 = -44						; size = 4
_bSourceIsPShop$ = -44					; size = 4
tv1813 = -40						; size = 4
_sitem$ = -36						; size = 4
tv1814 = -32						; size = 4
tv1892 = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_aIndex$ = 8						; size = 4
_res_2$165299 = 11					; size = 1
_res_1$165268 = 11					; size = 1
_source$ = 12						; size = 1
_target$ = 16						; size = 1
_w$ = 20						; size = 4
_durSsend$ = 20						; size = 4
_s_pos$165265 = 24					; size = 4
_h$ = 24						; size = 4
_durTsend$ = 24						; size = 4
_sFlag$ = 28						; size = 1
_tFlag$ = 32						; size = 1
_siteminfo$ = 36					; size = 4
?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z PROC		; gObjInventoryMoveItem, COMDAT

; 9124 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 9125 : 	LPOBJ lpObj;
; 9126 : 	BYTE TempInventoryMap[64];
; 9127 : 	int w,h;
; 9128 : 	int iwidth,iheight;
; 9129 : 	int blank;
; 9130 : 	int s_num;
; 9131 : 
; 9132 : 	CItem * sitem;
; 9133 : 	CItem * titem;
; 9134 : 
; 9135 : 	int bPersonalShopTrans = 0;

  00033	33 f6		 xor	 esi, esi
  00035	89 75 b4	 mov	 DWORD PTR _bPersonalShopTrans$[ebp], esi

; 9136 : 	int bSourceIsPShop = 0;

  00038	89 75 d4	 mov	 DWORD PTR _bSourceIsPShop$[ebp], esi

; 9137 : 
; 9138 : 	durSsend = 0;

  0003b	8b 45 14	 mov	 eax, DWORD PTR _durSsend$[ebp]
  0003e	89 30		 mov	 DWORD PTR [eax], esi

; 9139 : 	durTsend = 0;

  00040	8b 4d 18	 mov	 ecx, DWORD PTR _durTsend$[ebp]
  00043	89 31		 mov	 DWORD PTR [ecx], esi

; 9140 : 
; 9141 : 	lpObj = &gObj[aIndex];

  00045	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00048	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0004e	89 7d c0	 mov	 DWORD PTR tv1794[ebp], edi
  00051	8d 9f 00 00 00
	00		 lea	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]

; 9142 : 
; 9143 : 	int useClass = 0;
; 9144 : 	__try

  00057	9b		 fwait
  00058	89 75 fc	 mov	 DWORD PTR __$SEHRec$[ebp+20], esi

; 9145 : 	{
; 9146 : 		if(sFlag == 2 || tFlag == 2)

  0005b	8a 4d 1c	 mov	 cl, BYTE PTR _sFlag$[ebp]
  0005e	80 f9 02	 cmp	 cl, 2
  00061	74 0a		 je	 SHORT $LN235@gObjInvent@18
  00063	80 7d 20 02	 cmp	 BYTE PTR _tFlag$[ebp], 2
  00067	0f 85 a6 00 00
	00		 jne	 $LN233@gObjInvent@18
$LN235@gObjInvent@18:

; 9147 : 		{
; 9148 : 			if(lpObj->m_IfState.type != 6)

  0006d	8b 83 84 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3204]
  00073	8b d0		 mov	 edx, eax
  00075	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  0007b	81 fa 80 01 00
	00		 cmp	 edx, 384		; 00000180H
  00081	74 46		 je	 SHORT $LN234@gObjInvent@18

; 9149 : 			{
; 9150 : 				LogAdd(LOG_BLACK, lMsg.Get(531),lpObj->AccountID,lpObj->Name);

  00083	8d 43 6f	 lea	 eax, DWORD PTR [ebx+111]
  00086	50		 push	 eax
  00087	83 c3 64	 add	 ebx, 100		; 00000064H
  0008a	53		 push	 ebx
  0008b	68 13 02 00 00	 push	 531			; 00000213H
  00090	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00095	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0009a	50		 push	 eax
  0009b	56		 push	 esi
$LN315@gObjInvent@18:
  0009c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 9151 : 				return -1;

  000a1	6a fe		 push	 -2			; fffffffeH
  000a3	9b		 fwait
  000a4	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  000a7	51		 push	 ecx
$LN317@gObjInvent@18:
  000a8	68 00 00 00 00	 push	 OFFSET ___security_cookie
  000ad	e8 00 00 00 00	 call	 __local_unwind4
  000b2	83 c4 1c	 add	 esp, 28			; 0000001cH
  000b5	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  000b7	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  000ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c1	59		 pop	 ecx
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
$LN234@gObjInvent@18:

; 9152 : 			}
; 9153 : 
; 9154 : 			if(lpObj->m_IfState.state == 0)

  000c9	a8 3c		 test	 al, 60			; 0000003cH
  000cb	75 46		 jne	 SHORT $LN233@gObjInvent@18

; 9155 : 			{
; 9156 : 				LogAdd(LOG_BLACK, lMsg.Get(531),lpObj->AccountID,lpObj->Name);

  000cd	8d 53 6f	 lea	 edx, DWORD PTR [ebx+111]
  000d0	52		 push	 edx
  000d1	83 c3 64	 add	 ebx, 100		; 00000064H
  000d4	53		 push	 ebx
  000d5	68 13 02 00 00	 push	 531			; 00000213H
  000da	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000df	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000e4	50		 push	 eax
$LN318@gObjInvent@18:
  000e5	56		 push	 esi
  000e6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 9157 : 				return -1;

  000eb	6a fe		 push	 -2			; fffffffeH
  000ed	9b		 fwait
  000ee	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  000f1	50		 push	 eax
  000f2	68 00 00 00 00	 push	 OFFSET ___security_cookie
  000f7	e8 00 00 00 00	 call	 __local_unwind4
  000fc	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ff	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  00101	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00104	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010b	59		 pop	 ecx
  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi
  0010e	5b		 pop	 ebx
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c3		 ret	 0
$LN233@gObjInvent@18:

; 9158 : 			}
; 9159 : 		}
; 9160 : 
; 9161 : 		switch(sFlag)

  00113	0f b6 c1	 movzx	 eax, cl
  00116	89 45 bc	 mov	 DWORD PTR tv1809[ebp], eax
  00119	83 f8 09	 cmp	 eax, 9
  0011c	0f 87 2f 0d 00
	00		 ja	 $LN202@gObjInvent@18
  00122	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN246@gObjInvent@18[eax]
  00129	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN326@gObjInvent@18[ecx*4]
$LN230@gObjInvent@18:

; 9162 : 		{
; 9163 : 		case 0:
; 9164 : 			if(source < 0 || source > (MAIN_INVENTORY_SIZE-1))

  00130	80 7d 0c 4b	 cmp	 BYTE PTR _source$[ebp], 75 ; 0000004bH
  00134	0f 87 e5 00 00
	00		 ja	 $LN228@gObjInvent@18

; 9168 : 			}
; 9169 : 
; 9170 : 			if(lpObj->pInventory[source].IsItem() == 0)

  0013a	0f b6 75 0c	 movzx	 esi, BYTE PTR _source$[ebp]
  0013e	89 75 d8	 mov	 DWORD PTR tv1813[ebp], esi
  00141	69 f6 a8 00 00
	00		 imul	 esi, 168		; 000000a8H
  00147	89 75 e0	 mov	 DWORD PTR tv1814[ebp], esi
  0014a	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  00150	03 ce		 add	 ecx, esi
  00152	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00157	85 c0		 test	 eax, eax
  00159	75 0a		 jne	 SHORT $LN227@gObjInvent@18

; 9171 : 			{
; 9172 : 				LogAdd(LOG_BLACK, lMsg.Get(532),lpObj->AccountID,lpObj->Name,__LINE__);

  0015b	68 d4 23 00 00	 push	 9172			; 000023d4H

; 9173 : 				return -1;

  00160	e9 79 02 00 00	 jmp	 $LN320@gObjInvent@18
$LN227@gObjInvent@18:

; 9174 : 			}
; 9175 : 
; 9176 : 			sitem = &lpObj->pInventory[source];

  00165	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3212]
  0016b	03 f0		 add	 esi, eax
  0016d	89 75 dc	 mov	 DWORD PTR _sitem$[ebp], esi

; 9177 : 
; 9178 : 			if(lpObj->MapNumber == MAP_INDEX_ICARUS)

  00170	80 bb 09 01 00
	00 0a		 cmp	 BYTE PTR [ebx+265], 10	; 0000000aH
  00177	0f 85 b6 02 00
	00		 jne	 $LN231@gObjInvent@18

; 9179 : 			{
; 9180 : 				if(source == 8)

  0017d	8a 4d 0c	 mov	 cl, BYTE PTR _source$[ebp]
  00180	80 f9 08	 cmp	 cl, 8
  00183	75 57		 jne	 SHORT $LN225@gObjInvent@18

; 9181 : 				{
; 9182 : 					if(sitem->m_Type == ITEMGET(13,3))

  00185	0f b7 4e 06	 movzx	 ecx, WORD PTR [esi+6]
  00189	ba 03 1a 00 00	 mov	 edx, 6659		; 00001a03H
  0018e	66 3b ca	 cmp	 cx, dx

; 9183 : 					{
; 9184 : 						if(lpObj->pInventory[7].IsItem() == 0)
; 9185 : 						{
; 9186 : 							return -1;

  00191	74 0e		 je	 SHORT $LN323@gObjInvent@18

; 9187 : 						}
; 9188 : 					}
; 9189 : 					else if(sitem->m_Type == ITEMGET(13,37))

  00193	ba 25 1a 00 00	 mov	 edx, 6693		; 00001a25H
  00198	66 3b ca	 cmp	 cx, dx
  0019b	0f 85 92 02 00
	00		 jne	 $LN231@gObjInvent@18
$LN323@gObjInvent@18:

; 9190 : 					{
; 9191 : 						if(lpObj->pInventory[7].IsItem() == 0)

  001a1	8d 88 98 04 00
	00		 lea	 ecx, DWORD PTR [eax+1176]
  001a7	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  001ac	85 c0		 test	 eax, eax
  001ae	0f 85 7f 02 00
	00		 jne	 $LN231@gObjInvent@18

; 9192 : 						{
; 9193 : 							return -1;

  001b4	6a fe		 push	 -2			; fffffffeH
  001b6	9b		 fwait
  001b7	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  001ba	50		 push	 eax
  001bb	68 00 00 00 00	 push	 OFFSET ___security_cookie
  001c0	e8 00 00 00 00	 call	 __local_unwind4
  001c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9151 : 				return -1;

  001c8	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  001ca	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  001cd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d4	59		 pop	 ecx
  001d5	5f		 pop	 edi
  001d6	5e		 pop	 esi
  001d7	5b		 pop	 ebx
  001d8	8b e5		 mov	 esp, ebp
  001da	5d		 pop	 ebp
  001db	c3		 ret	 0
$LN225@gObjInvent@18:

; 9194 : 						}
; 9195 : 					}
; 9196 : 				}
; 9197 : 				else if(source == 7)

  001dc	80 f9 07	 cmp	 cl, 7
  001df	0f 85 4e 02 00
	00		 jne	 $LN231@gObjInvent@18

; 9198 : 				{
; 9199 : 					if(lpObj->pInventory[8].m_Type != ITEMGET(13,3))

  001e5	b9 03 1a 00 00	 mov	 ecx, 6659		; 00001a03H
  001ea	66 39 88 46 05
	00 00		 cmp	 WORD PTR [eax+1350], cx
  001f1	0f 84 3c 02 00
	00		 je	 $LN231@gObjInvent@18

; 9200 : 					{
; 9201 : 						return -1;

  001f7	6a fe		 push	 -2			; fffffffeH
  001f9	9b		 fwait
  001fa	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  001fd	52		 push	 edx
  001fe	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00203	e8 00 00 00 00	 call	 __local_unwind4
  00208	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9151 : 				return -1;

  0020b	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  0020d	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00210	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00217	59		 pop	 ecx
  00218	5f		 pop	 edi
  00219	5e		 pop	 esi
  0021a	5b		 pop	 ebx
  0021b	8b e5		 mov	 esp, ebp
  0021d	5d		 pop	 ebp
  0021e	c3		 ret	 0
$LN228@gObjInvent@18:

; 9165 : 			{
; 9166 : 				LogAdd(LOG_BLACK, "error-L1 : %s %d",__FILE__,__LINE__);

  0021f	68 ce 23 00 00	 push	 9166			; 000023ceH
  00224	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00229	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd?$AA@

; 9167 : 				return -1;

  0022e	e9 b2 fe ff ff	 jmp	 $LN318@gObjInvent@18
$LN216@gObjInvent@18:

; 9202 : 					}
; 9203 : 				}
; 9204 : 			}
; 9205 : 
; 9206 : 			break;
; 9207 : 		case 2:
; 9208 : 			if(source < 0 || source > (WAREHOUSE_SIZE-1))

  00233	80 7d 0c 77	 cmp	 BYTE PTR _source$[ebp], 119 ; 00000077H
  00237	77 78		 ja	 SHORT $LN214@gObjInvent@18

; 9212 : 			}
; 9213 : 
; 9214 : 			if(lpObj->pWarehouse[source].IsItem() == 0)

  00239	0f b6 7d 0c	 movzx	 edi, BYTE PTR _source$[ebp]
  0023d	89 7d d8	 mov	 DWORD PTR tv1813[ebp], edi
  00240	69 ff a8 00 00
	00		 imul	 edi, 168		; 000000a8H
  00246	89 7d e0	 mov	 DWORD PTR tv1814[ebp], edi
  00249	8b 8b c4 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3268]
  0024f	03 cf		 add	 ecx, edi
  00251	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00256	85 c0		 test	 eax, eax
  00258	75 4c		 jne	 SHORT $LN213@gObjInvent@18

; 9215 : 			{
; 9216 : 				LogAdd(LOG_BLACK, lMsg.Get(532),lpObj->AccountID,lpObj->Name,__LINE__);

  0025a	68 00 24 00 00	 push	 9216			; 00002400H
$LN324@gObjInvent@18:
  0025f	8d 4b 6f	 lea	 ecx, DWORD PTR [ebx+111]
  00262	51		 push	 ecx
  00263	83 c3 64	 add	 ebx, 100		; 00000064H
  00266	53		 push	 ebx
  00267	68 14 02 00 00	 push	 532			; 00000214H
  0026c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00271	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00276	50		 push	 eax
  00277	6a 00		 push	 0
  00279	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 9217 : 				return -1;

  0027e	6a fe		 push	 -2			; fffffffeH
  00280	9b		 fwait
  00281	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  00284	52		 push	 edx

; 9272 : 				return -1;

  00285	68 00 00 00 00	 push	 OFFSET ___security_cookie
  0028a	e8 00 00 00 00	 call	 __local_unwind4
  0028f	83 c4 20	 add	 esp, 32			; 00000020H

; 9151 : 				return -1;

  00292	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  00294	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00297	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0029e	59		 pop	 ecx
  0029f	5f		 pop	 edi
  002a0	5e		 pop	 esi
  002a1	5b		 pop	 ebx
  002a2	8b e5		 mov	 esp, ebp
  002a4	5d		 pop	 ebp
  002a5	c3		 ret	 0
$LN213@gObjInvent@18:

; 9218 : 			}
; 9219 : 
; 9220 : 			sitem = &lpObj->pWarehouse[source];

  002a6	8b b3 c4 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3268]

; 9221 : 			break;

  002ac	e9 7a 01 00 00	 jmp	 $LN307@gObjInvent@18
$LN214@gObjInvent@18:

; 9209 : 			{
; 9210 : 				LogAdd(LOG_BLACK, "error-L1 : %s %d",__FILE__,__LINE__);

  002b1	68 fa 23 00 00	 push	 9210			; 000023faH
  002b6	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  002bb	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd?$AA@

; 9211 : 				return -1;

  002c0	e9 20 fe ff ff	 jmp	 $LN318@gObjInvent@18
$LN212@gObjInvent@18:

; 9222 : 		case 3:
; 9223 : 		case 5:
; 9224 : 		case 6:
; 9225 : 		case 7:
; 9226 : 		case 8:
; 9227 : 		case 9:
; 9228 : 			if(source < 0 || source > (CHAOS_BOX_SIZE -1))

  002c5	80 7d 0c 1f	 cmp	 BYTE PTR _source$[ebp], 31 ; 0000001fH
  002c9	77 36		 ja	 SHORT $LN210@gObjInvent@18

; 9232 : 			}
; 9233 : 
; 9234 : 			if(lpObj->pChaosBox[source].IsItem() == 0)

  002cb	0f b6 7d 0c	 movzx	 edi, BYTE PTR _source$[ebp]
  002cf	89 7d d8	 mov	 DWORD PTR tv1813[ebp], edi
  002d2	69 ff a8 00 00
	00		 imul	 edi, 168		; 000000a8H
  002d8	89 7d e0	 mov	 DWORD PTR tv1814[ebp], edi
  002db	8b 8b dc 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3292]
  002e1	03 cf		 add	 ecx, edi
  002e3	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002e8	85 c0		 test	 eax, eax
  002ea	75 0a		 jne	 SHORT $LN209@gObjInvent@18

; 9235 : 			{
; 9236 : 				LogAdd(LOG_BLACK, lMsg.Get(532),lpObj->AccountID,lpObj->Name,__LINE__);

  002ec	68 14 24 00 00	 push	 9236			; 00002414H

; 9237 : 				return -1;

  002f1	e9 69 ff ff ff	 jmp	 $LN324@gObjInvent@18
$LN209@gObjInvent@18:

; 9238 : 			}
; 9239 : 
; 9240 : 			sitem = &lpObj->pChaosBox[source];

  002f6	8b b3 dc 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3292]

; 9241 : 			break;

  002fc	e9 2a 01 00 00	 jmp	 $LN307@gObjInvent@18
$LN210@gObjInvent@18:

; 9229 : 			{
; 9230 : 				LogAdd(LOG_BLACK, "error-L1 : %s %d",__FILE__,__LINE__);

  00301	68 0e 24 00 00	 push	 9230			; 0000240eH
  00306	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0030b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd?$AA@

; 9231 : 				return -1;

  00310	e9 d0 fd ff ff	 jmp	 $LN318@gObjInvent@18
$LN208@gObjInvent@18:

; 9242 : 		case 4:
; 9243 : 			if(gObj[aIndex].m_bPShopOpen == 1)

  00315	be 01 00 00 00	 mov	 esi, 1
  0031a	80 bf 28 0d 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3368], 1

; 9244 : 			{
; 9245 : 				return -1;

  00321	0f 84 24 04 00
	00		 je	 $LN142@gObjInvent@18

; 9246 : 			}
; 9247 : 
; 9248 : 			EnterCriticalSection(&gObj[aIndex].m_critPShopTrade);

  00327	8d 97 64 0d 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3428]
  0032d	52		 push	 edx
  0032e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 9249 : 
; 9250 : 			if(gObj[aIndex].m_bPShopTransaction == 1)

  00334	80 bf 29 0d 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3369], 1
  0033b	75 52		 jne	 SHORT $LN206@gObjInvent@18

; 9251 : 			{
; 9252 : 				LogAdd(LOG_BLACK, "[PShop] [%s][%s] PShop Item Move Request Failed : Already Trade With Other",gObj[aIndex].AccountID,gObj[aIndex].Name);

  0033d	8d 87 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+111]
  00343	50		 push	 eax
  00344	8d 8f 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+100]
  0034a	51		 push	 ecx
  0034b	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@PCJJPCHK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Move@
  00350	6a 00		 push	 0
  00352	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00357	83 c4 10	 add	 esp, 16			; 00000010H

; 9253 : 				LeaveCriticalSection(&lpObj->m_critPShopTrade);

  0035a	81 c3 64 0d 00
	00		 add	 ebx, 3428		; 00000d64H
  00360	53		 push	 ebx
  00361	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 9254 : 				return -1;

  00367	6a fe		 push	 -2			; fffffffeH
  00369	9b		 fwait
  0036a	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  0036d	52		 push	 edx
  0036e	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00373	e8 00 00 00 00	 call	 __local_unwind4
  00378	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9151 : 				return -1;

  0037b	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  0037d	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00380	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00387	59		 pop	 ecx
  00388	5f		 pop	 edi
  00389	5e		 pop	 esi
  0038a	5b		 pop	 ebx
  0038b	8b e5		 mov	 esp, ebp
  0038d	5d		 pop	 ebp
  0038e	c3		 ret	 0
$LN206@gObjInvent@18:

; 9255 : 			}
; 9256 : 
; 9257 : 			lpObj->m_bPShopTransaction = 1;

  0038f	c6 83 29 0d 00
	00 01		 mov	 BYTE PTR [ebx+3369], 1

; 9258 : 			bPersonalShopTrans = 1;

  00396	89 75 b4	 mov	 DWORD PTR _bPersonalShopTrans$[ebp], esi

; 9259 : 			bSourceIsPShop = 1;

  00399	89 75 d4	 mov	 DWORD PTR _bSourceIsPShop$[ebp], esi

; 9260 : 
; 9261 : 			LeaveCriticalSection(&lpObj->m_critPShopTrade);

  0039c	8d 83 64 0d 00
	00		 lea	 eax, DWORD PTR [ebx+3428]
  003a2	50		 push	 eax
  003a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 9262 : 
; 9263 : 			if(source < MAIN_INVENTORY_SIZE || source > (INVENTORY_SIZE - 1))

  003a9	8a 4d 0c	 mov	 cl, BYTE PTR _source$[ebp]
  003ac	80 e9 4c	 sub	 cl, 76			; 0000004cH
  003af	80 f9 1f	 cmp	 cl, 31			; 0000001fH
  003b2	0f 87 39 13 00
	00		 ja	 $LN204@gObjInvent@18

; 9267 : 			}
; 9268 : 
; 9269 : 			if(lpObj->pInventory[source].IsItem() == 0)

  003b8	0f b6 7d 0c	 movzx	 edi, BYTE PTR _source$[ebp]
  003bc	89 7d d8	 mov	 DWORD PTR tv1813[ebp], edi
  003bf	69 ff a8 00 00
	00		 imul	 edi, 168		; 000000a8H
  003c5	89 7d e0	 mov	 DWORD PTR tv1814[ebp], edi
  003c8	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  003ce	03 cf		 add	 ecx, edi
  003d0	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  003d5	85 c0		 test	 eax, eax
  003d7	75 4c		 jne	 SHORT $LN203@gObjInvent@18

; 9270 : 			{
; 9271 : 				LogAdd(LOG_BLACK, lMsg.Get(532),lpObj->AccountID,lpObj->Name,__LINE__);

  003d9	68 37 24 00 00	 push	 9271			; 00002437H
$LN320@gObjInvent@18:
  003de	8d 53 6f	 lea	 edx, DWORD PTR [ebx+111]
  003e1	52		 push	 edx
  003e2	83 c3 64	 add	 ebx, 100		; 00000064H
  003e5	53		 push	 ebx
  003e6	68 14 02 00 00	 push	 532			; 00000214H
  003eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003f0	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003f5	50		 push	 eax
  003f6	6a 00		 push	 0
  003f8	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 9272 : 				return -1;

  003fd	6a fe		 push	 -2			; fffffffeH
  003ff	9b		 fwait
  00400	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00403	50		 push	 eax
  00404	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00409	e8 00 00 00 00	 call	 __local_unwind4
  0040e	83 c4 20	 add	 esp, 32			; 00000020H

; 9151 : 				return -1;

  00411	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  00413	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00416	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0041d	59		 pop	 ecx
  0041e	5f		 pop	 edi
  0041f	5e		 pop	 esi
  00420	5b		 pop	 ebx
  00421	8b e5		 mov	 esp, ebp
  00423	5d		 pop	 ebp
  00424	c3		 ret	 0
$LN203@gObjInvent@18:

; 9273 : 			}
; 9274 : 
; 9275 : 			sitem = &lpObj->pInventory[source];

  00425	8b b3 8c 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3212]
$LN307@gObjInvent@18:
  0042b	03 f7		 add	 esi, edi
  0042d	89 75 dc	 mov	 DWORD PTR _sitem$[ebp], esi
  00430	8b 7d c0	 mov	 edi, DWORD PTR tv1794[ebp]
$LN231@gObjInvent@18:

; 9276 : 
; 9277 : 			break;
; 9278 : 		default: return -1;
; 9279 : 		}
; 9280 : 
; 9281 : 		BYTE level;
; 9282 : 		BYTE op1;
; 9283 : 		BYTE op2;
; 9284 : 		BYTE op3;
; 9285 : 		BYTE dur;
; 9286 : 		int type;
; 9287 : 
; 9288 : 		BufferItemtoConvert3(siteminfo,(int &)type,(BYTE &)level,(BYTE &)op1,(BYTE &)op2,(BYTE &)op3,(BYTE &)dur);

  00433	8d 4d af	 lea	 ecx, DWORD PTR _dur$165097[ebp]
  00436	51		 push	 ecx
  00437	8d 55 cd	 lea	 edx, DWORD PTR _op3$165096[ebp]
  0043a	52		 push	 edx
  0043b	8d 45 c7	 lea	 eax, DWORD PTR _op2$165095[ebp]
  0043e	50		 push	 eax
  0043f	8d 4d cf	 lea	 ecx, DWORD PTR _op1$165094[ebp]
  00442	51		 push	 ecx
  00443	8d 55 ce	 lea	 edx, DWORD PTR _level$165093[ebp]
  00446	52		 push	 edx
  00447	8d 45 a0	 lea	 eax, DWORD PTR _type$165098[ebp]
  0044a	50		 push	 eax
  0044b	8b 4d 24	 mov	 ecx, DWORD PTR _siteminfo$[ebp]
  0044e	51		 push	 ecx
  0044f	e8 00 00 00 00	 call	 ?BufferItemtoConvert3@@YAXPAEAAHAAE2222@Z ; BufferItemtoConvert3
  00454	83 c4 1c	 add	 esp, 28			; 0000001cH

; 9289 : 
; 9290 : 		if(sitem->m_Type != type || sitem->m_Level != level || sitem->m_Option1 != op1 || sitem->m_Option2 != op2 || sitem->m_Option3 != op3)

  00457	0f b7 4e 06	 movzx	 ecx, WORD PTR [esi+6]
  0045b	0f bf c1	 movsx	 eax, cx
  0045e	89 45 b0	 mov	 DWORD PTR tv1867[ebp], eax
  00461	3b 45 a0	 cmp	 eax, DWORD PTR _type$165098[ebp]
  00464	0f 85 18 12 00
	00		 jne	 $LN200@gObjInvent@18
  0046a	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  0046e	89 45 c8	 mov	 DWORD PTR tv2383[ebp], eax
  00471	0f b6 55 ce	 movzx	 edx, BYTE PTR _level$165093[ebp]
  00475	66 3b c2	 cmp	 ax, dx
  00478	0f 85 04 12 00
	00		 jne	 $LN200@gObjInvent@18
  0047e	8a 46 78	 mov	 al, BYTE PTR [esi+120]
  00481	3a 45 cf	 cmp	 al, BYTE PTR _op1$165094[ebp]
  00484	0f 85 f8 11 00
	00		 jne	 $LN200@gObjInvent@18
  0048a	8a 56 79	 mov	 dl, BYTE PTR [esi+121]
  0048d	3a 55 c7	 cmp	 dl, BYTE PTR _op2$165095[ebp]
  00490	0f 85 ec 11 00
	00		 jne	 $LN200@gObjInvent@18
  00496	8a 46 7a	 mov	 al, BYTE PTR [esi+122]
  00499	88 45 bb	 mov	 BYTE PTR tv1885[ebp], al
  0049c	3a 45 cd	 cmp	 al, BYTE PTR _op3$165096[ebp]
  0049f	0f 85 dd 11 00
	00		 jne	 $LN200@gObjInvent@18

; 9294 : 		}
; 9295 : 
; 9296 : 		switch(tFlag)

  004a5	8a 55 20	 mov	 dl, BYTE PTR _tFlag$[ebp]
  004a8	0f b6 c2	 movzx	 eax, dl
  004ab	89 45 b0	 mov	 DWORD PTR tv1887[ebp], eax
  004ae	83 f8 09	 cmp	 eax, 9
  004b1	0f 87 94 02 00
	00		 ja	 $LN142@gObjInvent@18
  004b7	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN247@gObjInvent@18[eax]
  004be	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN327@gObjInvent@18[eax*4]
$LN197@gObjInvent@18:

; 9297 : 		{
; 9298 : 		case 0:
; 9299 : 			if(target < 0 || target > (MAIN_INVENTORY_SIZE - 1))

  004c5	8a 45 10	 mov	 al, BYTE PTR _target$[ebp]
  004c8	3c 4b		 cmp	 al, 75			; 0000004bH
  004ca	77 08		 ja	 SHORT $LN195@gObjInvent@18

; 9303 : 			}
; 9304 : 
; 9305 : 			titem = &lpObj->pInventory[target];

  004cc	0f b6 f0	 movzx	 esi, al

; 9306 : 			break;

  004cf	e9 1d 04 00 00	 jmp	 $LN308@gObjInvent@18
$LN195@gObjInvent@18:

; 9300 : 			{
; 9301 : 				LogAdd(LOG_BLACK, "error-L1 : %s %d",__FILE__,__LINE__);

  004d4	68 55 24 00 00	 push	 9301			; 00002455H
  004d9	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  004de	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd?$AA@
  004e3	6a 00		 push	 0

; 9302 : 				return -1;

  004e5	e9 b2 fb ff ff	 jmp	 $LN315@gObjInvent@18
$LN194@gObjInvent@18:

; 9307 : 		case 2:
; 9308 : 			if(target < 0 || target > (WAREHOUSE_SIZE - 1))

  004ea	8a 45 10	 mov	 al, BYTE PTR _target$[ebp]
  004ed	3c 77		 cmp	 al, 119			; 00000077H
  004ef	77 0e		 ja	 SHORT $LN192@gObjInvent@18

; 9312 : 			}
; 9313 : 
; 9314 : 			titem = &lpObj->pWarehouse[target];

  004f1	0f b6 f0	 movzx	 esi, al
  004f4	8b bb c4 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3268]

; 9315 : 			break;

  004fa	e9 f8 03 00 00	 jmp	 $LN309@gObjInvent@18
$LN192@gObjInvent@18:

; 9309 : 			{
; 9310 : 				LogAdd(LOG_BLACK, "error-L1 : %s %d",__FILE__,__LINE__);

  004ff	68 5e 24 00 00	 push	 9310			; 0000245eH
  00504	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00509	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd?$AA@
  0050e	6a 00		 push	 0
  00510	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 9311 : 				return -1;

  00515	6a fe		 push	 -2			; fffffffeH
  00517	9b		 fwait
  00518	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  0051b	52		 push	 edx
  0051c	e9 87 fb ff ff	 jmp	 $LN317@gObjInvent@18
$LN191@gObjInvent@18:

; 9316 : 		case 3:
; 9317 : 		case 5:
; 9318 : 		case 6:
; 9319 : 		case 7:
; 9320 : 		case 8:
; 9321 : 		case 9:
; 9322 : 			if(target < 0 || target > (CHAOS_BOX_SIZE -1))

  00521	8a 45 10	 mov	 al, BYTE PTR _target$[ebp]
  00524	3c 1f		 cmp	 al, 31			; 0000001fH
  00526	0f 87 7d 02 00
	00		 ja	 $LN189@gObjInvent@18

; 9326 : 			}
; 9327 : 
; 9328 : 			titem = &lpObj->pChaosBox[target];

  0052c	0f b6 f0	 movzx	 esi, al
  0052f	89 75 d4	 mov	 DWORD PTR tv1891[ebp], esi
  00532	69 f6 a8 00 00
	00		 imul	 esi, 168		; 000000a8H
  00538	89 75 e4	 mov	 DWORD PTR tv1892[ebp], esi
  0053b	8b bb dc 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3292]
  00541	03 fe		 add	 edi, esi

; 9329 : 
; 9330 : 			if(sFlag == 0)

  00543	80 7d 1c 00	 cmp	 BYTE PTR _sFlag$[ebp], 0
  00547	0f 85 b8 03 00
	00		 jne	 $LN198@gObjInvent@18

; 9331 : 			{
; 9332 : 				if(tFlag == 5)

  0054d	80 fa 05	 cmp	 dl, 5
  00550	75 7c		 jne	 SHORT $LN187@gObjInvent@18

; 9333 : 				{
; 9334 : 					if(sitem->m_Type == ITEMGET(12,15)	||
; 9335 : 						sitem->m_Type == ITEMGET(14,13) ||
; 9336 : 						sitem->m_Type == ITEMGET(14,14) ||
; 9337 : 						sitem->m_Type == ITEMGET(14,22) ||
; 9338 : 						sitem->m_Type == ITEMGET(13,31) ||
; 9339 : 						sitem->m_Type == ITEMGET(14,53))

  00552	b8 0f 18 00 00	 mov	 eax, 6159		; 0000180fH
  00557	66 3b c8	 cmp	 cx, ax
  0055a	0f 84 a5 03 00
	00		 je	 $LN198@gObjInvent@18
  00560	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  00565	66 3b ca	 cmp	 cx, dx
  00568	0f 84 97 03 00
	00		 je	 $LN198@gObjInvent@18
  0056e	b8 0e 1c 00 00	 mov	 eax, 7182		; 00001c0eH
  00573	66 3b c8	 cmp	 cx, ax
  00576	0f 84 89 03 00
	00		 je	 $LN198@gObjInvent@18
  0057c	ba 16 1c 00 00	 mov	 edx, 7190		; 00001c16H
  00581	66 3b ca	 cmp	 cx, dx
  00584	0f 84 7b 03 00
	00		 je	 $LN198@gObjInvent@18
  0058a	b8 1f 1a 00 00	 mov	 eax, 6687		; 00001a1fH
  0058f	66 3b c8	 cmp	 cx, ax
  00592	0f 84 6d 03 00
	00		 je	 $LN198@gObjInvent@18
  00598	ba 35 1c 00 00	 mov	 edx, 7221		; 00001c35H
  0059d	66 3b ca	 cmp	 cx, dx
  005a0	0f 84 5f 03 00
	00		 je	 $LN198@gObjInvent@18
$LN322@gObjInvent@18:

; 9340 : 					{
; 9341 : 
; 9342 : 					}
; 9343 : 					else
; 9344 : 					{
; 9345 : 						return -1;

  005a6	6a fe		 push	 -2			; fffffffeH
  005a8	9b		 fwait
  005a9	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  005ac	50		 push	 eax
  005ad	68 00 00 00 00	 push	 OFFSET ___security_cookie
  005b2	e8 00 00 00 00	 call	 __local_unwind4
  005b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9151 : 				return -1;

  005ba	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  005bc	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  005bf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005c6	59		 pop	 ecx
  005c7	5f		 pop	 edi
  005c8	5e		 pop	 esi
  005c9	5b		 pop	 ebx
  005ca	8b e5		 mov	 esp, ebp
  005cc	5d		 pop	 ebp
  005cd	c3		 ret	 0
$LN187@gObjInvent@18:

; 9346 : 					}
; 9347 : 				}
; 9348 : 				else
; 9349 : 				{
; 9350 : 					if(sitem->m_Level < 4 && sitem->m_Option3*4 < 4)

  005ce	66 83 7d c8 04	 cmp	 WORD PTR tv2383[ebp], 4
  005d3	0f 8d 9a 01 00
	00		 jge	 $LN182@gObjInvent@18
  005d9	0f b6 55 bb	 movzx	 edx, BYTE PTR tv1885[ebp]
  005dd	03 d2		 add	 edx, edx
  005df	03 d2		 add	 edx, edx
  005e1	83 fa 04	 cmp	 edx, 4
  005e4	0f 8d 89 01 00
	00		 jge	 $LN182@gObjInvent@18

; 9351 : 					{
; 9352 : 						if(sitem->m_Type == ITEMGET(12,15) || sitem->m_Type == ITEMGET(14,13) || sitem->m_Type == ITEMGET(14,14) || sitem->m_Type == ITEMGET(14,22) || sitem->m_Type == ITEMGET(13,14))

  005ea	b8 0f 18 00 00	 mov	 eax, 6159		; 0000180fH
  005ef	66 3b c8	 cmp	 cx, ax
  005f2	0f 84 0d 03 00
	00		 je	 $LN198@gObjInvent@18
  005f8	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  005fd	66 3b ca	 cmp	 cx, dx
  00600	0f 84 ff 02 00
	00		 je	 $LN198@gObjInvent@18
  00606	b8 0e 1c 00 00	 mov	 eax, 7182		; 00001c0eH
  0060b	66 3b c8	 cmp	 cx, ax
  0060e	0f 84 f1 02 00
	00		 je	 $LN198@gObjInvent@18
  00614	ba 16 1c 00 00	 mov	 edx, 7190		; 00001c16H
  00619	66 3b ca	 cmp	 cx, dx
  0061c	0f 84 e3 02 00
	00		 je	 $LN198@gObjInvent@18
  00622	b8 0e 1a 00 00	 mov	 eax, 6670		; 00001a0eH
  00627	66 3b c8	 cmp	 cx, ax
  0062a	0f 84 d5 02 00
	00		 je	 $LN198@gObjInvent@18

; 9353 : 						{
; 9354 : 							
; 9355 : 						}
; 9356 : 						else if(sitem->m_Type >= ITEMGET(12,0) && sitem->m_Type <= ITEMGET(12,2))

  00630	ba 00 18 00 00	 mov	 edx, 6144		; 00001800H
  00635	66 3b ca	 cmp	 cx, dx
  00638	7c 0e		 jl	 SHORT $LN178@gObjInvent@18
  0063a	b8 02 18 00 00	 mov	 eax, 6146		; 00001802H
  0063f	66 3b c8	 cmp	 cx, ax
  00642	0f 8e bd 02 00
	00		 jle	 $LN198@gObjInvent@18
$LN178@gObjInvent@18:

; 9357 : 						{
; 9358 : 
; 9359 : 						}
; 9360 : 						else if(sitem->m_Type == ITEMGET(14,17) || sitem->m_Type == ITEMGET(14,18))

  00648	ba 11 1c 00 00	 mov	 edx, 7185		; 00001c11H
  0064d	66 3b ca	 cmp	 cx, dx
  00650	0f 84 af 02 00
	00		 je	 $LN198@gObjInvent@18
  00656	b8 12 1c 00 00	 mov	 eax, 7186		; 00001c12H
  0065b	66 3b c8	 cmp	 cx, ax
  0065e	0f 84 a1 02 00
	00		 je	 $LN198@gObjInvent@18

; 9361 : 						{
; 9362 : 
; 9363 : 						}
; 9364 : 						else if(sitem->m_Type == ITEMGET(13,2) && sitem->m_Durability == 255.0f)

  00664	ba 02 1a 00 00	 mov	 edx, 6658		; 00001a02H
  00669	66 3b ca	 cmp	 cx, dx
  0066c	75 19		 jne	 SHORT $LN173@gObjInvent@18
  0066e	8b 45 dc	 mov	 eax, DWORD PTR _sitem$[ebp]
  00671	d9 40 24	 fld	 DWORD PTR [eax+36]
  00674	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@406fe00000000000
  0067a	da e9		 fucompp
  0067c	df e0		 fnstsw	 ax
  0067e	f6 c4 44	 test	 ah, 68			; 00000044H
  00681	0f 8b 7e 02 00
	00		 jnp	 $LN198@gObjInvent@18
$LN173@gObjInvent@18:

; 9365 : 						{
; 9366 : 
; 9367 : 						}
; 9368 : 						else if(sitem->m_Type == ITEMGET(13,16) || sitem->m_Type == ITEMGET(13,17))

  00687	ba 10 1a 00 00	 mov	 edx, 6672		; 00001a10H
  0068c	66 3b ca	 cmp	 cx, dx
  0068f	0f 84 70 02 00
	00		 je	 $LN198@gObjInvent@18
  00695	b8 11 1a 00 00	 mov	 eax, 6673		; 00001a11H
  0069a	66 3b c8	 cmp	 cx, ax
  0069d	0f 84 62 02 00
	00		 je	 $LN198@gObjInvent@18

; 9369 : 						{
; 9370 : 
; 9371 : 						}
; 9372 : #if GS_CASTLE == 1
; 9373 : 						else if(sitem->m_Type == ITEMGET(12,30) || sitem->m_Type == ITEMGET(12,31))
; 9374 : 						{
; 9375 : 
; 9376 : 						}
; 9377 : #endif
; 9378 : 						else if(sitem->m_Type == ITEMGET(14,31))

  006a3	ba 1f 1c 00 00	 mov	 edx, 7199		; 00001c1fH
  006a8	66 3b ca	 cmp	 cx, dx
  006ab	0f 84 54 02 00
	00		 je	 $LN198@gObjInvent@18

; 9379 : 						{
; 9380 : 
; 9381 : 						}
; 9382 : 						else if(sitem->m_Type == ITEMGET(12,26))

  006b1	b8 1a 18 00 00	 mov	 eax, 6170		; 0000181aH
  006b6	66 3b c8	 cmp	 cx, ax
  006b9	0f 84 46 02 00
	00		 je	 $LN198@gObjInvent@18

; 9383 : 						{
; 9384 : 
; 9385 : 						}
; 9386 : 						else if(
; 9387 : 							sitem->m_Type == ITEMGET(13,32) ||
; 9388 : 							sitem->m_Type == ITEMGET(13,33) ||
; 9389 : 							sitem->m_Type == ITEMGET(13,34) ||
; 9390 : 							sitem->m_Type == ITEMGET(13,35) ||
; 9391 : 							sitem->m_Type == ITEMGET(13,36) ||
; 9392 : 							sitem->m_Type == ITEMGET(13,37) ||
; 9393 : 							sitem->m_Type == ITEMGET(14,16))

  006bf	ba 20 1a 00 00	 mov	 edx, 6688		; 00001a20H
  006c4	66 3b ca	 cmp	 cx, dx
  006c7	0f 84 38 02 00
	00		 je	 $LN198@gObjInvent@18
  006cd	b8 21 1a 00 00	 mov	 eax, 6689		; 00001a21H
  006d2	66 3b c8	 cmp	 cx, ax
  006d5	0f 84 2a 02 00
	00		 je	 $LN198@gObjInvent@18
  006db	ba 22 1a 00 00	 mov	 edx, 6690		; 00001a22H
  006e0	66 3b ca	 cmp	 cx, dx
  006e3	0f 84 1c 02 00
	00		 je	 $LN198@gObjInvent@18
  006e9	b8 23 1a 00 00	 mov	 eax, 6691		; 00001a23H
  006ee	66 3b c8	 cmp	 cx, ax
  006f1	0f 84 0e 02 00
	00		 je	 $LN198@gObjInvent@18
  006f7	ba 24 1a 00 00	 mov	 edx, 6692		; 00001a24H
  006fc	66 3b ca	 cmp	 cx, dx
  006ff	0f 84 00 02 00
	00		 je	 $LN198@gObjInvent@18
  00705	b8 25 1a 00 00	 mov	 eax, 6693		; 00001a25H
  0070a	66 3b c8	 cmp	 cx, ax
  0070d	0f 84 f2 01 00
	00		 je	 $LN198@gObjInvent@18
  00713	ba 10 1c 00 00	 mov	 edx, 7184		; 00001c10H
  00718	66 3b ca	 cmp	 cx, dx
  0071b	0f 84 e4 01 00
	00		 je	 $LN198@gObjInvent@18

; 9394 : 						{
; 9395 : 
; 9396 : 						}
; 9397 : 						else if(sitem->m_Type == ITEMGET(14,3) || sitem->m_Type == ITEMGET(14,38) || sitem->m_Type == ITEMGET(14,39))

  00721	b8 03 1c 00 00	 mov	 eax, 7171		; 00001c03H
  00726	66 3b c8	 cmp	 cx, ax
  00729	0f 84 d6 01 00
	00		 je	 $LN198@gObjInvent@18
  0072f	ba 26 1c 00 00	 mov	 edx, 7206		; 00001c26H
  00734	66 3b ca	 cmp	 cx, dx
  00737	0f 84 c8 01 00
	00		 je	 $LN198@gObjInvent@18
  0073d	b8 27 1c 00 00	 mov	 eax, 7207		; 00001c27H
  00742	66 3b c8	 cmp	 cx, ax
  00745	0f 84 ba 01 00
	00		 je	 $LN198@gObjInvent@18
$LN142@gObjInvent@18:

; 9398 : 						{
; 9399 : 
; 9400 : 						}
; 9401 : 						else if(sitem->m_Type == ITEMGET(14,31))
; 9402 : 						{
; 9403 : 
; 9404 : 						}
; 9405 : 						else
; 9406 : 						{
; 9407 : 							return -1;

  0074b	6a fe		 push	 -2			; fffffffeH
  0074d	9b		 fwait
  0074e	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00751	51		 push	 ecx
  00752	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00757	e8 00 00 00 00	 call	 __local_unwind4
  0075c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9151 : 				return -1;

  0075f	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  00761	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00764	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0076b	59		 pop	 ecx
  0076c	5f		 pop	 edi
  0076d	5e		 pop	 esi
  0076e	5b		 pop	 ebx
  0076f	8b e5		 mov	 esp, ebp
  00771	5d		 pop	 ebp
  00772	c3		 ret	 0
$LN182@gObjInvent@18:

; 9408 : 						}
; 9409 : 					}
; 9410 : 					else if(sitem->m_Type == ITEMGET(14,11))

  00773	ba 0b 1c 00 00	 mov	 edx, 7179		; 00001c0bH
  00778	66 3b ca	 cmp	 cx, dx
  0077b	0f 85 84 01 00
	00		 jne	 $LN198@gObjInvent@18

; 9411 : 					{
; 9412 : 						return -1;

  00781	6a fe		 push	 -2			; fffffffeH
  00783	9b		 fwait
  00784	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00787	50		 push	 eax
  00788	68 00 00 00 00	 push	 OFFSET ___security_cookie
  0078d	e8 00 00 00 00	 call	 __local_unwind4
  00792	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9151 : 				return -1;

  00795	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  00797	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0079a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  007a1	59		 pop	 ecx
  007a2	5f		 pop	 edi
  007a3	5e		 pop	 esi
  007a4	5b		 pop	 ebx
  007a5	8b e5		 mov	 esp, ebp
  007a7	5d		 pop	 ebp
  007a8	c3		 ret	 0
$LN189@gObjInvent@18:

; 9323 : 			{
; 9324 : 				LogAdd(LOG_BLACK, "error-L1 : %s %d",__FILE__,__LINE__);

  007a9	68 6c 24 00 00	 push	 9324			; 0000246cH
  007ae	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  007b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd?$AA@
  007b8	6a 00		 push	 0

; 9325 : 				return -1;

  007ba	e9 dd f8 ff ff	 jmp	 $LN315@gObjInvent@18
$LN154@gObjInvent@18:

; 9413 : 					}
; 9414 : 				}
; 9415 : 			}
; 9416 : 			break;
; 9417 : 		case 4:
; 9418 : 			if(gDoPShopOpen == 0)

  007bf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen

; 9419 : 			{
; 9420 : 				return -1;

  007c6	0f 84 85 06 00
	00		 je	 $LN202@gObjInvent@18

; 9421 : 			}
; 9422 : 
; 9423 : 			if(gObj[aIndex].m_bPShopOpen == 1)

  007cc	80 bf 28 0d 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3368], 1

; 9424 : 			{
; 9425 : 				return -1;

  007d3	0f 84 cd fd ff
	ff		 je	 $LN322@gObjInvent@18

; 9426 : 			}
; 9427 : 
; 9428 : 			if(sitem->m_Type == ITEMGET(14,11) && sitem->m_Level == 13)

  007d9	ba 0b 1c 00 00	 mov	 edx, 7179		; 00001c0bH
  007de	66 3b ca	 cmp	 cx, dx
  007e1	75 0b		 jne	 SHORT $LN151@gObjInvent@18
  007e3	66 83 7d c8 0d	 cmp	 WORD PTR tv2383[ebp], 13 ; 0000000dH

; 9429 : 			{
; 9430 : 				return -1;

  007e8	0f 84 b8 fd ff
	ff		 je	 $LN322@gObjInvent@18
$LN151@gObjInvent@18:

; 9431 : 			}
; 9432 : 
; 9433 : 			if(sitem->m_Type == ITEMGET(13,38))

  007ee	ba 26 1a 00 00	 mov	 edx, 6694		; 00001a26H
  007f3	66 3b ca	 cmp	 cx, dx
  007f6	75 42		 jne	 SHORT $LN150@gObjInvent@18

; 9434 : 			{
; 9435 : 				GCServerMsgStringSend(lMsg.Get(3390),lpObj->m_Index,1);

  007f8	6a 01		 push	 1
  007fa	8b 03		 mov	 eax, DWORD PTR [ebx]
  007fc	50		 push	 eax
  007fd	68 3e 0d 00 00	 push	 3390			; 00000d3eH
  00802	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00807	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0080c	50		 push	 eax
  0080d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 9436 : 				return -1;

  00812	6a fe		 push	 -2			; fffffffeH
  00814	9b		 fwait
  00815	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00818	51		 push	 ecx
  00819	68 00 00 00 00	 push	 OFFSET ___security_cookie
  0081e	e8 00 00 00 00	 call	 __local_unwind4
  00823	83 c4 18	 add	 esp, 24			; 00000018H

; 9151 : 				return -1;

  00826	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  00828	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0082b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00832	59		 pop	 ecx
  00833	5f		 pop	 edi
  00834	5e		 pop	 esi
  00835	5b		 pop	 ebx
  00836	8b e5		 mov	 esp, ebp
  00838	5d		 pop	 ebp
  00839	c3		 ret	 0
$LN150@gObjInvent@18:

; 9437 : 			}
; 9438 : 
; 9439 : 			if(sitem->m_Type == ITEMGET(13,39))

  0083a	ba 27 1a 00 00	 mov	 edx, 6695		; 00001a27H
  0083f	66 3b ca	 cmp	 cx, dx

; 9440 : 			{
; 9441 : 				return -1;

  00842	0f 84 5e fd ff
	ff		 je	 $LN322@gObjInvent@18

; 9442 : 			}
; 9443 : 
; 9444 : 			EnterCriticalSection(&gObj[aIndex].m_critPShopTrade);

  00848	8d 8f 64 0d 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3428]
  0084e	51		 push	 ecx
  0084f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 9445 : 
; 9446 : 			if(gObj[aIndex].m_bPShopTransaction == 1)

  00855	80 bf 29 0d 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3369], 1
  0085c	75 67		 jne	 SHORT $LN148@gObjInvent@18

; 9447 : 			{
; 9448 : 				if(bSourceIsPShop == 1)

  0085e	b8 01 00 00 00	 mov	 eax, 1
  00863	39 45 d4	 cmp	 DWORD PTR _bSourceIsPShop$[ebp], eax
  00866	75 0b		 jne	 SHORT $LN147@gObjInvent@18

; 9449 : 				{
; 9450 : 					lpObj->m_bPShopTransaction = 1;

  00868	88 83 29 0d 00
	00		 mov	 BYTE PTR [ebx+3369], al

; 9451 : 					bPersonalShopTrans = 1;

  0086e	89 45 b4	 mov	 DWORD PTR _bPersonalShopTrans$[ebp], eax

; 9458 : 				}
; 9459 : 			}
; 9460 : 			else

  00871	eb 60		 jmp	 SHORT $LN145@gObjInvent@18
$LN147@gObjInvent@18:

; 9452 : 				}
; 9453 : 				else
; 9454 : 				{
; 9455 : 					LogAdd(LOG_BLACK, "[PShop] [%s][%s] PShop Item Move Request Failed : Already Trade With Other",gObj[aIndex].AccountID,gObj[aIndex].Name);

  00873	8d 97 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+111]
  00879	52		 push	 edx
  0087a	8d 87 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+100]
  00880	50		 push	 eax
  00881	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@PCJJPCHK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Move@
  00886	6a 00		 push	 0
  00888	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0088d	83 c4 10	 add	 esp, 16			; 00000010H

; 9456 : 					LeaveCriticalSection(&lpObj->m_critPShopTrade);

  00890	81 c3 64 0d 00
	00		 add	 ebx, 3428		; 00000d64H
  00896	53		 push	 ebx
  00897	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 9457 : 					return -1;

  0089d	6a fe		 push	 -2			; fffffffeH
  0089f	9b		 fwait
  008a0	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  008a3	51		 push	 ecx
  008a4	68 00 00 00 00	 push	 OFFSET ___security_cookie
  008a9	e8 00 00 00 00	 call	 __local_unwind4
  008ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9151 : 				return -1;

  008b1	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  008b3	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  008b6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  008bd	59		 pop	 ecx
  008be	5f		 pop	 edi
  008bf	5e		 pop	 esi
  008c0	5b		 pop	 ebx
  008c1	8b e5		 mov	 esp, ebp
  008c3	5d		 pop	 ebp
  008c4	c3		 ret	 0
$LN148@gObjInvent@18:

; 9461 : 			{
; 9462 : 				lpObj->m_bPShopTransaction = 1;

  008c5	c6 83 29 0d 00
	00 01		 mov	 BYTE PTR [ebx+3369], 1

; 9463 : 				bPersonalShopTrans = 1;

  008cc	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _bPersonalShopTrans$[ebp], 1
$LN145@gObjInvent@18:

; 9464 : 			}
; 9465 : 
; 9466 : 			LeaveCriticalSection(&lpObj->m_critPShopTrade);

  008d3	8d 93 64 0d 00
	00		 lea	 edx, DWORD PTR [ebx+3428]
  008d9	52		 push	 edx
  008da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 9467 : 
; 9468 : 			if(target < MAIN_INVENTORY_SIZE || target > (INVENTORY_SIZE - 1))

  008e0	8a 45 10	 mov	 al, BYTE PTR _target$[ebp]
  008e3	2c 4c		 sub	 al, 76			; 0000004cH
  008e5	3c 1f		 cmp	 al, 31			; 0000001fH
  008e7	0f 87 73 0d 00
	00		 ja	 $LN143@gObjInvent@18

; 9472 : 			}
; 9473 : 
; 9474 : 			titem = &lpObj->pInventory[target];

  008ed	0f b6 75 10	 movzx	 esi, BYTE PTR _target$[ebp]
$LN308@gObjInvent@18:
  008f1	8b bb 8c 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3212]
$LN309@gObjInvent@18:
  008f7	89 75 d4	 mov	 DWORD PTR tv1891[ebp], esi
  008fa	69 f6 a8 00 00
	00		 imul	 esi, 168		; 000000a8H
  00900	89 75 e4	 mov	 DWORD PTR tv1892[ebp], esi
  00903	03 fe		 add	 edi, esi
$LN198@gObjInvent@18:

; 9475 : 
; 9476 : 			break;
; 9477 : 		default: return -1;
; 9478 : 		}
; 9479 : 
; 9480 : 		s_num = sitem->GetNumber();

  00905	8b 4d dc	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00908	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  0090d	89 45 c8	 mov	 DWORD PTR _s_num$[ebp], eax

; 9481 : 
; 9482 : 		if(gObjCheckSerial0ItemList(sitem))

  00910	8b 4d dc	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00913	51		 push	 ecx
  00914	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  00919	83 c4 04	 add	 esp, 4
  0091c	85 c0		 test	 eax, eax
  0091e	74 64		 je	 SHORT $LN141@gObjInvent@18

; 9483 : 		{
; 9484 : 			MsgOutput(lpObj->m_Index,lMsg.Get(3354));

  00920	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  00925	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0092a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0092f	50		 push	 eax
  00930	8b 13		 mov	 edx, DWORD PTR [ebx]
  00932	52		 push	 edx
  00933	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00938	83 c4 08	 add	 esp, 8

; 9485 : 			LogAdd(LOG_BLACK, "[ANTI-HACK][Serial 0 Item] [MoveItem] (%s)(%s) Item(%s) Pos(%d)",lpObj->AccountID,lpObj->Name,sitem->GetName(),source);

  0093b	8b 45 d8	 mov	 eax, DWORD PTR tv1813[ebp]
  0093e	50		 push	 eax
  0093f	8b 4d dc	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00942	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00947	50		 push	 eax
  00948	8d 4b 6f	 lea	 ecx, DWORD PTR [ebx+111]
  0094b	51		 push	 ecx
  0094c	83 c3 64	 add	 ebx, 100		; 00000064H
  0094f	53		 push	 ebx
  00950	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@MOKNMDJN@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLMove@
  00955	6a 00		 push	 0
  00957	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 9486 : 			return -1;

  0095c	6a fe		 push	 -2			; fffffffeH
  0095e	9b		 fwait
  0095f	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  00962	52		 push	 edx
  00963	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00968	e8 00 00 00 00	 call	 __local_unwind4
  0096d	83 c4 24	 add	 esp, 36			; 00000024H

; 9151 : 				return -1;

  00970	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  00972	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00975	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0097c	59		 pop	 ecx
  0097d	5f		 pop	 edi
  0097e	5e		 pop	 esi
  0097f	5b		 pop	 ebx
  00980	8b e5		 mov	 esp, ebp
  00982	5d		 pop	 ebp
  00983	c3		 ret	 0
$LN141@gObjInvent@18:

; 9487 : 		}
; 9488 : 
; 9489 : 		if(gObjInventorySearchSerialNumber(lpObj,s_num) == 0)

  00984	8b 45 c8	 mov	 eax, DWORD PTR _s_num$[ebp]
  00987	50		 push	 eax
  00988	53		 push	 ebx
  00989	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  0098e	83 c4 08	 add	 esp, 8
  00991	85 c0		 test	 eax, eax

; 9490 : 		{
; 9491 : 			return -1;

  00993	0f 84 b2 fd ff
	ff		 je	 $LN142@gObjInvent@18

; 9492 : 		}
; 9493 : 
; 9494 : 		if(gObjWarehouseSearchSerialNumber(lpObj,s_num) == 0)

  00999	8b 55 c8	 mov	 edx, DWORD PTR _s_num$[ebp]
  0099c	52		 push	 edx
  0099d	53		 push	 ebx
  0099e	e8 00 00 00 00	 call	 ?gObjWarehouseSearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjWarehouseSearchSerialNumber
  009a3	83 c4 08	 add	 esp, 8
  009a6	85 c0		 test	 eax, eax

; 9495 : 		{
; 9496 : 			return -1;

  009a8	0f 84 f8 fb ff
	ff		 je	 $LN322@gObjInvent@18

; 9497 : 		}
; 9498 : 
; 9499 : 		if(titem->IsItem() == 1)

  009ae	8b cf		 mov	 ecx, edi
  009b0	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  009b5	83 f8 01	 cmp	 eax, 1
  009b8	0f 85 51 03 00
	00		 jne	 $LN138@gObjInvent@18

; 9500 : 		{
; 9501 : 			int max_count = 0;

  009be	33 d2		 xor	 edx, edx
  009c0	89 55 d0	 mov	 DWORD PTR _max_count$165172[ebp], edx

; 9502 : 
; 9503 : 			if(sitem->m_Type == ITEMGET(13,32) && titem->m_Durability < 20.0f)

  009c3	8b 4d dc	 mov	 ecx, DWORD PTR _sitem$[ebp]
  009c6	0f b7 49 06	 movzx	 ecx, WORD PTR [ecx+6]
  009ca	b8 20 1a 00 00	 mov	 eax, 6688		; 00001a20H
  009cf	66 3b c8	 cmp	 cx, ax
  009d2	75 18		 jne	 SHORT $LN137@gObjInvent@18
  009d4	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@41a00000
  009da	d8 5f 24	 fcomp	 DWORD PTR [edi+36]
  009dd	df e0		 fnstsw	 ax
  009df	f6 c4 41	 test	 ah, 65			; 00000041H
  009e2	75 08		 jne	 SHORT $LN137@gObjInvent@18

; 9504 : 			{
; 9505 : 				max_count = 20;

  009e4	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  009e9	89 55 d0	 mov	 DWORD PTR _max_count$165172[ebp], edx
$LN137@gObjInvent@18:

; 9506 : 			}
; 9507 : 
; 9508 : 			if(sitem->m_Type == ITEMGET(13,33) && titem->m_Durability < 20.0f)

  009ec	b8 21 1a 00 00	 mov	 eax, 6689		; 00001a21H
  009f1	66 3b c8	 cmp	 cx, ax
  009f4	75 18		 jne	 SHORT $LN136@gObjInvent@18
  009f6	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@41a00000
  009fc	d8 5f 24	 fcomp	 DWORD PTR [edi+36]
  009ff	df e0		 fnstsw	 ax
  00a01	f6 c4 41	 test	 ah, 65			; 00000041H
  00a04	75 08		 jne	 SHORT $LN136@gObjInvent@18

; 9509 : 			{
; 9510 : 				max_count = 20;

  00a06	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  00a0b	89 55 d0	 mov	 DWORD PTR _max_count$165172[ebp], edx
$LN136@gObjInvent@18:

; 9511 : 			}
; 9512 : 
; 9513 : 			if(sitem->m_Type == ITEMGET(13,34) && titem->m_Durability < 10.0f)

  00a0e	b8 22 1a 00 00	 mov	 eax, 6690		; 00001a22H
  00a13	66 3b c8	 cmp	 cx, ax
  00a16	75 18		 jne	 SHORT $LN135@gObjInvent@18
  00a18	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@41200000
  00a1e	d8 5f 24	 fcomp	 DWORD PTR [edi+36]
  00a21	df e0		 fnstsw	 ax
  00a23	f6 c4 41	 test	 ah, 65			; 00000041H
  00a26	75 08		 jne	 SHORT $LN135@gObjInvent@18

; 9514 : 			{
; 9515 : 				max_count = 10;

  00a28	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
  00a2d	89 55 d0	 mov	 DWORD PTR _max_count$165172[ebp], edx
$LN135@gObjInvent@18:

; 9516 : 			}
; 9517 : 
; 9518 : 			if(sitem->m_Type >= ITEMGET(14,35) || sitem->m_Type >= ITEMGET(14,36) || sitem->m_Type >= ITEMGET(14,37))

  00a30	b8 23 1c 00 00	 mov	 eax, 7203		; 00001c23H
  00a35	66 3b c8	 cmp	 cx, ax
  00a38	7d 14		 jge	 SHORT $LN133@gObjInvent@18
  00a3a	b8 24 1c 00 00	 mov	 eax, 7204		; 00001c24H
  00a3f	66 3b c8	 cmp	 cx, ax
  00a42	7d 0a		 jge	 SHORT $LN133@gObjInvent@18
  00a44	b8 25 1c 00 00	 mov	 eax, 7205		; 00001c25H
  00a49	66 3b c8	 cmp	 cx, ax
  00a4c	7c 14		 jl	 SHORT $LN132@gObjInvent@18
$LN133@gObjInvent@18:

; 9519 : 			{
; 9520 : 				if(titem->m_Durability < 1.0f)

  00a4e	d9 e8		 fld1
  00a50	d8 5f 24	 fcomp	 DWORD PTR [edi+36]
  00a53	df e0		 fnstsw	 ax
  00a55	f6 c4 41	 test	 ah, 65			; 00000041H
  00a58	75 08		 jne	 SHORT $LN132@gObjInvent@18

; 9521 : 				{
; 9522 : 					max_count = 1;

  00a5a	ba 01 00 00 00	 mov	 edx, 1
  00a5f	89 55 d0	 mov	 DWORD PTR _max_count$165172[ebp], edx
$LN132@gObjInvent@18:

; 9523 : 				}
; 9524 : 			}
; 9525 : 
; 9526 : 			if(sitem->m_Type >= ITEMGET(14,46) && sitem->m_Type <= ITEMGET(14,50))

  00a62	b8 2e 1c 00 00	 mov	 eax, 7214		; 00001c2eH
  00a67	66 3b c8	 cmp	 cx, ax
  00a6a	7c 22		 jl	 SHORT $LN130@gObjInvent@18
  00a6c	b8 32 1c 00 00	 mov	 eax, 7218		; 00001c32H
  00a71	66 3b c8	 cmp	 cx, ax
  00a74	7f 18		 jg	 SHORT $LN130@gObjInvent@18

; 9527 : 			{
; 9528 : 				if(titem->m_Durability < 3.0f)

  00a76	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40400000
  00a7c	d8 5f 24	 fcomp	 DWORD PTR [edi+36]
  00a7f	df e0		 fnstsw	 ax
  00a81	f6 c4 41	 test	 ah, 65			; 00000041H
  00a84	75 08		 jne	 SHORT $LN130@gObjInvent@18

; 9529 : 				{
; 9530 : 					max_count = 3;

  00a86	ba 03 00 00 00	 mov	 edx, 3
  00a8b	89 55 d0	 mov	 DWORD PTR _max_count$165172[ebp], edx
$LN130@gObjInvent@18:

; 9531 : 				}
; 9532 : 			}
; 9533 : 
; 9534 : 			if(sitem->m_Type == ITEMGET(14,29))

  00a8e	b8 1d 1c 00 00	 mov	 eax, 7197		; 00001c1dH
  00a93	66 3b c8	 cmp	 cx, ax
  00a96	75 15		 jne	 SHORT $LN128@gObjInvent@18

; 9535 : 			{
; 9536 : 				if(sitem->m_Level == titem->m_Level)

  00a98	8b 45 dc	 mov	 eax, DWORD PTR _sitem$[ebp]
  00a9b	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]
  00a9f	66 3b 47 08	 cmp	 ax, WORD PTR [edi+8]
  00aa3	75 08		 jne	 SHORT $LN128@gObjInvent@18

; 9537 : 				{
; 9538 : 					max_count = 5;

  00aa5	ba 05 00 00 00	 mov	 edx, 5
  00aaa	89 55 d0	 mov	 DWORD PTR _max_count$165172[ebp], edx
$LN128@gObjInvent@18:

; 9539 : 				}
; 9540 : 			}
; 9541 : 
; 9542 : 			if(sitem->m_Type == ITEMGET(14,7))

  00aad	b8 07 1c 00 00	 mov	 eax, 7175		; 00001c07H
  00ab2	66 3b c8	 cmp	 cx, ax
  00ab5	75 19		 jne	 SHORT $LN127@gObjInvent@18

; 9543 : 			{
; 9544 : 				if(titem->m_Durability < 250.0f)

  00ab7	d9 47 24	 fld	 DWORD PTR [edi+36]
  00aba	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@406f400000000000
  00ac0	df e0		 fnstsw	 ax
  00ac2	f6 c4 05	 test	 ah, 5
  00ac5	7a 77		 jp	 SHORT $LN117@gObjInvent@18

; 9545 : 				{
; 9546 : 					max_count = 250;

  00ac7	c7 45 d0 fa 00
	00 00		 mov	 DWORD PTR _max_count$165172[ebp], 250 ; 000000faH

; 9547 : 				}
; 9548 : 			}

  00ace	eb 76		 jmp	 SHORT $LN245@gObjInvent@18
$LN127@gObjInvent@18:

; 9549 : 			else if(sitem->m_Type >= ITEMGET(14,0) && sitem->m_Type <= ITEMGET(14,8) || sitem->m_Type >= ITEMGET(14,38) && sitem->m_Type <= ITEMGET(14,40))

  00ad0	b8 00 1c 00 00	 mov	 eax, 7168		; 00001c00H
  00ad5	66 3b c8	 cmp	 cx, ax
  00ad8	7c 0a		 jl	 SHORT $LN122@gObjInvent@18
  00ada	b8 08 1c 00 00	 mov	 eax, 7176		; 00001c08H
  00adf	66 3b c8	 cmp	 cx, ax
  00ae2	7e 14		 jle	 SHORT $LN123@gObjInvent@18
$LN122@gObjInvent@18:
  00ae4	b8 26 1c 00 00	 mov	 eax, 7206		; 00001c26H
  00ae9	66 3b c8	 cmp	 cx, ax
  00aec	7c 23		 jl	 SHORT $LN124@gObjInvent@18
  00aee	b8 28 1c 00 00	 mov	 eax, 7208		; 00001c28H
  00af3	66 3b c8	 cmp	 cx, ax
  00af6	7f 19		 jg	 SHORT $LN124@gObjInvent@18
$LN123@gObjInvent@18:

; 9550 : 			{
; 9551 : 				if(titem->m_Durability < 3.0f)

  00af8	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40400000
  00afe	d8 5f 24	 fcomp	 DWORD PTR [edi+36]
  00b01	df e0		 fnstsw	 ax
  00b03	f6 c4 41	 test	 ah, 65			; 00000041H
  00b06	75 36		 jne	 SHORT $LN117@gObjInvent@18

; 9552 : 				{
; 9553 : 					max_count = 3;

  00b08	c7 45 d0 03 00
	00 00		 mov	 DWORD PTR _max_count$165172[ebp], 3

; 9554 : 				}
; 9555 : 			}

  00b0f	eb 35		 jmp	 SHORT $LN245@gObjInvent@18
$LN124@gObjInvent@18:

; 9556 : 			else if(sitem->m_Type == ITEMGET(4,15) || sitem->m_Type == ITEMGET(4,7))

  00b11	b8 0f 08 00 00	 mov	 eax, 2063		; 0000080fH
  00b16	66 3b c8	 cmp	 cx, ax
  00b19	74 0a		 je	 SHORT $LN118@gObjInvent@18
  00b1b	b8 07 08 00 00	 mov	 eax, 2055		; 00000807H
  00b20	66 3b c8	 cmp	 cx, ax
  00b23	75 19		 jne	 SHORT $LN117@gObjInvent@18
$LN118@gObjInvent@18:

; 9557 : 			{
; 9558 : 				if(titem->m_Durability < 255.0f)

  00b25	d9 47 24	 fld	 DWORD PTR [edi+36]
  00b28	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@406fe00000000000
  00b2e	df e0		 fnstsw	 ax
  00b30	f6 c4 05	 test	 ah, 5
  00b33	7a 09		 jp	 SHORT $LN117@gObjInvent@18

; 9559 : 				{
; 9560 : 					max_count = 255;

  00b35	c7 45 d0 ff 00
	00 00		 mov	 DWORD PTR _max_count$165172[ebp], 255 ; 000000ffH

; 9561 : 				}
; 9562 : 			}
; 9563 : 
; 9564 : 			if(max_count != 0)

  00b3c	eb 08		 jmp	 SHORT $LN245@gObjInvent@18
$LN117@gObjInvent@18:
  00b3e	85 d2		 test	 edx, edx
  00b40	0f 84 60 fa ff
	ff		 je	 $LN322@gObjInvent@18
$LN245@gObjInvent@18:

; 9565 : 			{
; 9566 : 				if(sFlag != 0)

  00b46	80 7d 1c 00	 cmp	 BYTE PTR _sFlag$[ebp], 0

; 9567 : 				{
; 9568 : 					return -1;

  00b4a	0f 85 fb fb ff
	ff		 jne	 $LN142@gObjInvent@18

; 9569 : 				}
; 9570 : 
; 9571 : 				if(titem->m_Type == sitem->m_Type && titem->m_Level == sitem->m_Level)

  00b50	66 39 4f 06	 cmp	 WORD PTR [edi+6], cx
  00b54	0f 85 4c fa ff
	ff		 jne	 $LN322@gObjInvent@18
  00b5a	66 8b 57 08	 mov	 dx, WORD PTR [edi+8]
  00b5e	8b 45 dc	 mov	 eax, DWORD PTR _sitem$[ebp]
  00b61	66 3b 50 08	 cmp	 dx, WORD PTR [eax+8]
  00b65	0f 85 3b fa ff
	ff		 jne	 $LN322@gObjInvent@18

; 9572 : 				{
; 9573 : 					int t_dur = titem->m_Durability;

  00b6b	d9 47 24	 fld	 DWORD PTR [edi+36]
  00b6e	e8 00 00 00 00	 call	 __ftol2_sse

; 9574 : 
; 9575 : 					if(t_dur < max_count)

  00b73	3b 45 d0	 cmp	 eax, DWORD PTR _max_count$165172[ebp]
  00b76	0f 8d 2a fa ff
	ff		 jge	 $LN322@gObjInvent@18

; 9576 : 					{
; 9577 : 						int dif_dur = max_count - int(titem->m_Durability);

  00b7c	8b 4d d0	 mov	 ecx, DWORD PTR _max_count$165172[ebp]
  00b7f	2b c8		 sub	 ecx, eax
  00b81	89 4d bc	 mov	 DWORD PTR _dif_dur$165199[ebp], ecx

; 9578 : 
; 9579 : 						if(dif_dur > sitem->m_Durability)

  00b84	db 45 bc	 fild	 DWORD PTR _dif_dur$165199[ebp]
  00b87	8b 55 dc	 mov	 edx, DWORD PTR _sitem$[ebp]
  00b8a	d9 42 24	 fld	 DWORD PTR [edx+36]
  00b8d	de d9		 fcompp
  00b8f	df e0		 fnstsw	 ax
  00b91	f6 c4 05	 test	 ah, 5
  00b94	7a 10		 jp	 SHORT $LN112@gObjInvent@18

; 9580 : 						{
; 9581 : 							dif_dur = sitem->m_Durability;

  00b96	8b ca		 mov	 ecx, edx
  00b98	d9 41 24	 fld	 DWORD PTR [ecx+36]
  00b9b	e8 00 00 00 00	 call	 __ftol2_sse
  00ba0	89 45 bc	 mov	 DWORD PTR _dif_dur$165199[ebp], eax
  00ba3	8b 55 dc	 mov	 edx, DWORD PTR _sitem$[ebp]
$LN112@gObjInvent@18:

; 9582 : 						}
; 9583 : 
; 9584 : 						titem->m_Durability += dif_dur;

  00ba6	db 45 bc	 fild	 DWORD PTR _dif_dur$165199[ebp]
  00ba9	d9 5d c8	 fstp	 DWORD PTR tv1988[ebp]
  00bac	d9 45 c8	 fld	 DWORD PTR tv1988[ebp]
  00baf	d9 c0		 fld	 ST(0)
  00bb1	d8 47 24	 fadd	 DWORD PTR [edi+36]
  00bb4	d9 5f 24	 fstp	 DWORD PTR [edi+36]

; 9585 : 						sitem->m_Durability -= dif_dur;

  00bb7	d8 6a 24	 fsubr	 DWORD PTR [edx+36]
  00bba	d9 5a 24	 fstp	 DWORD PTR [edx+36]

; 9586 : 
; 9587 : 						if(titem->m_Type == ITEMGET(14,29) && max_count <= titem->m_Durability)

  00bbd	b8 1d 1c 00 00	 mov	 eax, 7197		; 00001c1dH
  00bc2	66 39 47 06	 cmp	 WORD PTR [edi+6], ax
  00bc6	0f 85 c5 00 00
	00		 jne	 $LN111@gObjInvent@18
  00bcc	db 45 d0	 fild	 DWORD PTR _max_count$165172[ebp]
  00bcf	d9 5d c8	 fstp	 DWORD PTR tv2003[ebp]
  00bd2	d9 45 c8	 fld	 DWORD PTR tv2003[ebp]
  00bd5	d9 47 24	 fld	 DWORD PTR [edi+36]
  00bd8	d8 d9		 fcomp	 ST(1)
  00bda	df e0		 fnstsw	 ax
  00bdc	f6 c4 01	 test	 ah, 1
  00bdf	0f 85 aa 00 00
	00		 jne	 $LN303@gObjInvent@18

; 9588 : 						{
; 9589 : 							titem->m_Durability -= max_count;

  00be5	d8 6f 24	 fsubr	 DWORD PTR [edi+36]
  00be8	d9 5d c8	 fstp	 DWORD PTR tv2010[ebp]
  00beb	d9 45 c8	 fld	 DWORD PTR tv2010[ebp]
  00bee	d9 57 24	 fst	 DWORD PTR [edi+36]

; 9590 : 
; 9591 : 							if(titem->m_Durability == 0)

  00bf1	d9 ee		 fldz
  00bf3	da e9		 fucompp
  00bf5	df e0		 fnstsw	 ax
  00bf7	f6 c4 44	 test	 ah, 68			; 00000044H
  00bfa	7a 3f		 jp	 SHORT $LN110@gObjInvent@18

; 9592 : 							{
; 9593 : 								gObjInventoryItemSet(aIndex,target,255);

  00bfc	68 ff 00 00 00	 push	 255			; 000000ffH
  00c01	8b 4d d4	 mov	 ecx, DWORD PTR tv1891[ebp]
  00c04	51		 push	 ecx
  00c05	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00c08	57		 push	 edi
  00c09	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00c0e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9594 : 								gObj[aIndex].pInventory[target].Clear();

  00c11	8b 55 c0	 mov	 edx, DWORD PTR tv1794[ebp]
  00c14	8b 8a 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3212]
  00c1a	03 ce		 add	 ecx, esi
  00c1c	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 9595 : 								GCInventoryItemDeleteSend(aIndex,target,1);

  00c21	6a 01		 push	 1
  00c23	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  00c26	50		 push	 eax
  00c27	57		 push	 edi
  00c28	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00c2d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9596 : 								durTsend = 0;

  00c30	8b 4d 18	 mov	 ecx, DWORD PTR _durTsend$[ebp]
  00c33	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 9597 : 							}
; 9598 : 							else

  00c39	eb 0c		 jmp	 SHORT $LN109@gObjInvent@18
$LN110@gObjInvent@18:

; 9599 : 							{
; 9600 : 								durTsend = 1;

  00c3b	8b 55 18	 mov	 edx, DWORD PTR _durTsend$[ebp]
  00c3e	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1
  00c44	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
$LN109@gObjInvent@18:

; 9601 : 							}
; 9602 : 
; 9603 : 							ItemSerialCreateSend(aIndex,235,gObj[aIndex].X,gObj[aIndex].Y,ItemGetNumberMake(14,28),sitem->m_Level,0,0,0,0,aIndex,0,0);

  00c47	6a 00		 push	 0
  00c49	6a 00		 push	 0
  00c4b	57		 push	 edi
  00c4c	6a 00		 push	 0
  00c4e	6a 00		 push	 0
  00c50	6a 00		 push	 0
  00c52	6a 00		 push	 0
  00c54	8b 45 dc	 mov	 eax, DWORD PTR _sitem$[ebp]
  00c57	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00c5b	51		 push	 ecx
  00c5c	6a 1c		 push	 28			; 0000001cH
  00c5e	6a 0e		 push	 14			; 0000000eH
  00c60	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00c65	83 c4 08	 add	 esp, 8
  00c68	50		 push	 eax
  00c69	8b 45 c0	 mov	 eax, DWORD PTR tv1794[ebp]
  00c6c	0f b6 90 06 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  00c73	52		 push	 edx
  00c74	0f b6 80 04 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  00c7b	50		 push	 eax
  00c7c	68 eb 00 00 00	 push	 235			; 000000ebH
  00c81	57		 push	 edi
  00c82	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00c87	83 c4 34	 add	 esp, 52			; 00000034H
  00c8a	8b 55 dc	 mov	 edx, DWORD PTR _sitem$[ebp]
  00c8d	eb 02		 jmp	 SHORT $LN111@gObjInvent@18
$LN303@gObjInvent@18:

; 9586 : 
; 9587 : 						if(titem->m_Type == ITEMGET(14,29) && max_count <= titem->m_Durability)

  00c8f	dd d8		 fstp	 ST(0)
$LN111@gObjInvent@18:

; 9604 : 						}
; 9605 : 
; 9606 : 						if(sitem->m_Durability > 0)

  00c91	d9 ee		 fldz
  00c93	d8 5a 24	 fcomp	 DWORD PTR [edx+36]
  00c96	df e0		 fnstsw	 ax
  00c98	f6 c4 05	 test	 ah, 5
  00c9b	7a 17		 jp	 SHORT $LN108@gObjInvent@18

; 9607 : 						{
; 9608 : 							durSsend = 1;

  00c9d	8b 4d 14	 mov	 ecx, DWORD PTR _durSsend$[ebp]
  00ca0	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 9609 : 							durTsend = 1;

  00ca6	8b 55 18	 mov	 edx, DWORD PTR _durTsend$[ebp]
  00ca9	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1

; 9610 : 						}
; 9611 : 						else

  00caf	e9 f2 f8 ff ff	 jmp	 $LN322@gObjInvent@18
$LN108@gObjInvent@18:

; 9612 : 						{
; 9613 : 							switch(sFlag)
; 9614 : 							{
; 9615 : 							case 0:
; 9616 : 								gObjInventoryItemSet(lpObj->m_Index,source,255);

  00cb4	68 ff 00 00 00	 push	 255			; 000000ffH
  00cb9	8b 45 d8	 mov	 eax, DWORD PTR tv1813[ebp]
  00cbc	50		 push	 eax
  00cbd	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00cbf	51		 push	 ecx
  00cc0	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00cc5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9617 : 								sitem->Clear();

  00cc8	8b 4d dc	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00ccb	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 9618 : 								GCInventoryItemDeleteSend(lpObj->m_Index,source,0);

  00cd0	6a 00		 push	 0
  00cd2	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  00cd5	52		 push	 edx
  00cd6	8b 03		 mov	 eax, DWORD PTR [ebx]
  00cd8	50		 push	 eax
  00cd9	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 9619 : 								durTsend = 1;

  00cde	8b 4d 18	 mov	 ecx, DWORD PTR _durTsend$[ebp]
  00ce1	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 9620 : 							default:	return 0;

  00ce7	6a fe		 push	 -2			; fffffffeH
  00ce9	9b		 fwait
  00cea	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  00ced	52		 push	 edx
  00cee	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00cf3	e8 00 00 00 00	 call	 __local_unwind4
  00cf8	83 c4 18	 add	 esp, 24			; 00000018H
$LN244@gObjInvent@18:

; 10005: 		}
; 10006: 	}
; 10007: 	return false;

  00cfb	32 c0		 xor	 al, al

; 10008: }

  00cfd	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00d00	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00d07	59		 pop	 ecx
  00d08	5f		 pop	 edi
  00d09	5e		 pop	 esi
  00d0a	5b		 pop	 ebx
  00d0b	8b e5		 mov	 esp, ebp
  00d0d	5d		 pop	 ebp
  00d0e	c3		 ret	 0
$LN138@gObjInvent@18:

; 9621 : 							}
; 9622 : 						}
; 9623 : 					}
; 9624 : 				}
; 9625 : 			}
; 9626 : 			return -1;
; 9627 : 		}
; 9628 : 
; 9629 : 		switch(tFlag)

  00d0f	8b 4d b0	 mov	 ecx, DWORD PTR tv1887[ebp]
  00d12	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN248@gObjInvent@18[ecx]
  00d19	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN328@gObjInvent@18[edx*4]
$LN100@gObjInvent@18:

; 9630 : 		{
; 9631 : 		case 0:
; 9632 : 		case 4:
; 9633 : 			if(target < INVETORY_WEAR_SIZE)

  00d20	8a 45 10	 mov	 al, BYTE PTR _target$[ebp]
  00d23	3c 0c		 cmp	 al, 12			; 0000000cH
  00d25	0f 83 4e 01 00
	00		 jae	 $LN99@gObjInvent@18

; 9634 : 			{
; 9635 : 				if(lpObj->MapNumber == MAP_INDEX_ICARUS)

  00d2b	8a 8b 09 01 00
	00		 mov	 cl, BYTE PTR [ebx+265]
  00d31	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  00d34	0f 85 df 00 00
	00		 jne	 $LN85@gObjInvent@18

; 9636 : 				{
; 9637 : 					if(target == 10)

  00d3a	3a c1		 cmp	 al, cl
  00d3c	75 3d		 jne	 SHORT $LN97@gObjInvent@18

; 9638 : 					{
; 9639 : 						if(lpObj->pInventory[source].m_Type == ITEMGET(13,10))

  00d3e	8b 93 8c 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3212]
  00d44	be 0a 1a 00 00	 mov	 esi, 6666		; 00001a0aH
  00d49	8b 7d e0	 mov	 edi, DWORD PTR tv1814[ebp]
  00d4c	66 39 74 3a 06	 cmp	 WORD PTR [edx+edi+6], si
  00d51	75 45		 jne	 SHORT $LN93@gObjInvent@18

; 9640 : 						{
; 9641 : 							return -1;

  00d53	6a fe		 push	 -2			; fffffffeH
  00d55	9b		 fwait
  00d56	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00d59	50		 push	 eax
  00d5a	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00d5f	e8 00 00 00 00	 call	 __local_unwind4
  00d64	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9151 : 				return -1;

  00d67	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  00d69	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00d6c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00d73	59		 pop	 ecx
  00d74	5f		 pop	 edi
  00d75	5e		 pop	 esi
  00d76	5b		 pop	 ebx
  00d77	8b e5		 mov	 esp, ebp
  00d79	5d		 pop	 ebp
  00d7a	c3		 ret	 0
$LN97@gObjInvent@18:

; 9642 : 						}
; 9643 : 					}
; 9644 : 					else if(target == 11)

  00d7b	3c 0b		 cmp	 al, 11			; 0000000bH
  00d7d	75 19		 jne	 SHORT $LN93@gObjInvent@18

; 9645 : 					{
; 9646 : 						if(lpObj->pInventory[source].m_Type == ITEMGET(13,10))

  00d7f	8b 93 8c 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3212]
  00d85	be 0a 1a 00 00	 mov	 esi, 6666		; 00001a0aH
  00d8a	8b 7d e0	 mov	 edi, DWORD PTR tv1814[ebp]
  00d8d	66 39 74 3a 06	 cmp	 WORD PTR [edx+edi+6], si

; 9647 : 						{
; 9648 : 							return -1;

  00d92	0f 84 0e f8 ff
	ff		 je	 $LN322@gObjInvent@18
$LN93@gObjInvent@18:

; 9649 : 						}
; 9650 : 					}
; 9651 : 				}
; 9652 : 
; 9653 : 				if(target < INVETORY_WEAR_SIZE)
; 9654 : 				{
; 9655 : 					if(lpObj->MapNumber == MAP_INDEX_ICARUS)

  00d98	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  00d9b	75 7c		 jne	 SHORT $LN85@gObjInvent@18

; 9656 : 					{
; 9657 : 						if(target == 10)

  00d9d	3a c1		 cmp	 al, cl
  00d9f	75 4a		 jne	 SHORT $LN90@gObjInvent@18

; 9658 : 						{
; 9659 : 							if(lpObj->pInventory[source].m_Type == ITEMGET(13,39) ||
; 9660 : 								lpObj->pInventory[source].m_Type == ITEMGET(13,10))

  00da1	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  00da7	8b 55 e0	 mov	 edx, DWORD PTR tv1814[ebp]
  00daa	0f b7 44 11 06	 movzx	 eax, WORD PTR [ecx+edx+6]
  00daf	b9 27 1a 00 00	 mov	 ecx, 6695		; 00001a27H
  00db4	66 3b c1	 cmp	 ax, cx
  00db7	74 0a		 je	 SHORT $LN88@gObjInvent@18
  00db9	ba 0a 1a 00 00	 mov	 edx, 6666		; 00001a0aH
  00dbe	66 3b c2	 cmp	 ax, dx
  00dc1	75 56		 jne	 SHORT $LN85@gObjInvent@18
$LN88@gObjInvent@18:

; 9661 : 							{
; 9662 : 								return -1;

  00dc3	6a fe		 push	 -2			; fffffffeH
  00dc5	9b		 fwait
  00dc6	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00dc9	50		 push	 eax
  00dca	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00dcf	e8 00 00 00 00	 call	 __local_unwind4
  00dd4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9151 : 				return -1;

  00dd7	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  00dd9	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00ddc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00de3	59		 pop	 ecx
  00de4	5f		 pop	 edi
  00de5	5e		 pop	 esi
  00de6	5b		 pop	 ebx
  00de7	8b e5		 mov	 esp, ebp
  00de9	5d		 pop	 ebp
  00dea	c3		 ret	 0
$LN90@gObjInvent@18:

; 9663 : 							}
; 9664 : 						}
; 9665 : 						else if(target == 11)

  00deb	3c 0b		 cmp	 al, 11			; 0000000bH
  00ded	75 2a		 jne	 SHORT $LN85@gObjInvent@18

; 9666 : 						{
; 9667 : 							if(lpObj->pInventory[source].m_Type == ITEMGET(13,39) ||
; 9668 : 								lpObj->pInventory[source].m_Type == ITEMGET(13,10))

  00def	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  00df5	8b 55 e0	 mov	 edx, DWORD PTR tv1814[ebp]
  00df8	0f b7 44 11 06	 movzx	 eax, WORD PTR [ecx+edx+6]
  00dfd	b9 27 1a 00 00	 mov	 ecx, 6695		; 00001a27H
  00e02	66 3b c1	 cmp	 ax, cx
  00e05	0f 84 9b f7 ff
	ff		 je	 $LN322@gObjInvent@18
  00e0b	ba 0a 1a 00 00	 mov	 edx, 6666		; 00001a0aH
  00e10	66 3b c2	 cmp	 ax, dx

; 9669 : 							{
; 9670 : 								return -1;

  00e13	0f 84 8d f7 ff
	ff		 je	 $LN322@gObjInvent@18
$LN85@gObjInvent@18:

; 9671 : 							}
; 9672 : 						}
; 9673 : 					}
; 9674 : 				}
; 9675 : 
; 9676 : 				useClass = sitem->IsClass(lpObj->Class,lpObj->ChangeUP);

  00e19	0f b6 8b 9b 00
	00 00		 movzx	 ecx, BYTE PTR [ebx+155]
  00e20	51		 push	 ecx
  00e21	0f b6 93 98 00
	00 00		 movzx	 edx, BYTE PTR [ebx+152]
  00e28	52		 push	 edx
  00e29	8b 75 dc	 mov	 esi, DWORD PTR _sitem$[ebp]
  00e2c	8b ce		 mov	 ecx, esi
  00e2e	e8 00 00 00 00	 call	 ?IsClass@CItem@@QAEHDH@Z ; CItem::IsClass

; 9677 : 
; 9678 : 				if(useClass == 0)

  00e33	85 c0		 test	 eax, eax

; 9679 : 				{
; 9680 : 					return -1;

  00e35	0f 84 6b f7 ff
	ff		 je	 $LN322@gObjInvent@18

; 9681 : 				}
; 9682 : 
; 9683 : 				if(gObjIsItemPut(lpObj,sitem,target) == 0)

  00e3b	8b 4d d4	 mov	 ecx, DWORD PTR tv1891[ebp]
  00e3e	51		 push	 ecx
  00e3f	56		 push	 esi
  00e40	53		 push	 ebx
  00e41	e8 00 00 00 00	 call	 ?gObjIsItemPut@@YAHPAUOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
  00e46	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e49	85 c0		 test	 eax, eax
  00e4b	0f 85 b0 01 00
	00		 jne	 $LN69@gObjInvent@18
$LN202@gObjInvent@18:

; 9684 : 				{
; 9685 : 					return -1;

  00e51	6a fe		 push	 -2			; fffffffeH
  00e53	9b		 fwait
  00e54	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  00e57	52		 push	 edx
  00e58	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00e5d	e8 00 00 00 00	 call	 __local_unwind4
  00e62	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9151 : 				return -1;

  00e65	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  00e67	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00e6a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00e71	59		 pop	 ecx
  00e72	5f		 pop	 edi
  00e73	5e		 pop	 esi
  00e74	5b		 pop	 ebx
  00e75	8b e5		 mov	 esp, ebp
  00e77	5d		 pop	 ebp
  00e78	c3		 ret	 0
$LN99@gObjInvent@18:

; 9686 : 				}
; 9687 : 			}
; 9688 : 			else 
; 9689 : 			{
; 9690 : 				if(target >= MAIN_INVENTORY_SIZE)

  00e79	3c 4c		 cmp	 al, 76			; 0000004cH
  00e7b	72 4c		 jb	 SHORT $LN78@gObjInvent@18

; 9691 : 				{
; 9692 : 					if(lpObj->pInventory[source].m_Type == ITEMGET(12,26))

  00e7d	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3212]
  00e83	8b 4d e0	 mov	 ecx, DWORD PTR tv1814[ebp]
  00e86	ba 1a 18 00 00	 mov	 edx, 6170		; 0000181aH
  00e8b	66 39 54 08 06	 cmp	 WORD PTR [eax+ecx+6], dx
  00e90	75 37		 jne	 SHORT $LN78@gObjInvent@18

; 9693 : 					{
; 9694 : 						if(lpObj->pInventory[source].m_Level == 1 ||
; 9695 : 							lpObj->pInventory[source].m_Level == 2 ||
; 9696 : 							lpObj->pInventory[source].m_Level == 3 ||
; 9697 : 							lpObj->pInventory[source].m_Level == 4 ||
; 9698 : 							lpObj->pInventory[source].m_Level == 5)

  00e92	0f b7 44 08 08	 movzx	 eax, WORD PTR [eax+ecx+8]
  00e97	66 83 f8 01	 cmp	 ax, 1
  00e9b	0f 84 05 f7 ff
	ff		 je	 $LN322@gObjInvent@18
  00ea1	66 83 f8 02	 cmp	 ax, 2
  00ea5	0f 84 fb f6 ff
	ff		 je	 $LN322@gObjInvent@18
  00eab	66 83 f8 03	 cmp	 ax, 3
  00eaf	0f 84 f1 f6 ff
	ff		 je	 $LN322@gObjInvent@18
  00eb5	66 83 f8 04	 cmp	 ax, 4
  00eb9	0f 84 e7 f6 ff
	ff		 je	 $LN322@gObjInvent@18
  00ebf	66 83 f8 05	 cmp	 ax, 5

; 9699 : 						{
; 9700 : 							return -1;

  00ec3	0f 84 dd f6 ff
	ff		 je	 $LN322@gObjInvent@18
$LN78@gObjInvent@18:

; 9701 : 						}
; 9702 : 					}	
; 9703 : 				}
; 9704 : 
; 9705 : 				w = (target - INVETORY_WEAR_SIZE)%8;

  00ec9	8b 45 d4	 mov	 eax, DWORD PTR tv1891[ebp]
  00ecc	83 c0 f4	 add	 eax, -12		; fffffff4H
  00ecf	8b c8		 mov	 ecx, eax
  00ed1	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H
  00ed7	79 05		 jns	 SHORT $LN305@gObjInvent@18
  00ed9	49		 dec	 ecx
  00eda	83 c9 f8	 or	 ecx, -8			; fffffff8H
  00edd	41		 inc	 ecx
$LN305@gObjInvent@18:
  00ede	89 4d 14	 mov	 DWORD PTR _w$[ebp], ecx

; 9706 : 				h = (target - INVETORY_WEAR_SIZE)/8;

  00ee1	99		 cdq
  00ee2	83 e2 07	 and	 edx, 7
  00ee5	03 c2		 add	 eax, edx
  00ee7	c1 f8 03	 sar	 eax, 3
  00eea	89 45 18	 mov	 DWORD PTR _h$[ebp], eax

; 9707 : 
; 9708 : 				if(ExtentCheck(w,h,8,12) == 0)

  00eed	6a 0c		 push	 12			; 0000000cH
  00eef	6a 08		 push	 8
  00ef1	50		 push	 eax
  00ef2	51		 push	 ecx
  00ef3	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  00ef8	83 c4 10	 add	 esp, 16			; 00000010H
  00efb	85 c0		 test	 eax, eax

; 9709 : 				{
; 9710 : 					return -1;

  00efd	0f 84 48 f8 ff
	ff		 je	 $LN142@gObjInvent@18

; 9711 : 				}
; 9712 : 
; 9713 : 			sitem->GetSize((int &)iwidth,(int &)iheight);

  00f03	8d 55 a8	 lea	 edx, DWORD PTR _iheight$[ebp]
  00f06	52		 push	 edx
  00f07	8d 45 a4	 lea	 eax, DWORD PTR _iwidth$[ebp]
  00f0a	50		 push	 eax
  00f0b	8b 4d dc	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00f0e	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 9714 : 			memcpy(TempInventoryMap,lpObj->pInventoryMap,64);

  00f13	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00f18	8b b3 90 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3216]
  00f1e	8d bd 60 ff ff
	ff		 lea	 edi, DWORD PTR _TempInventoryMap$[ebp]
  00f24	f3 a5		 rep movsd

; 9715 : 
; 9716 : 				switch(sFlag)

  00f26	80 7d 1c 00	 cmp	 BYTE PTR _sFlag$[ebp], 0
  00f2a	74 06		 je	 SHORT $LN73@gObjInvent@18
  00f2c	80 7d 1c 04	 cmp	 BYTE PTR _sFlag$[ebp], 4
  00f30	75 22		 jne	 SHORT $LN72@gObjInvent@18
$LN73@gObjInvent@18:

; 9717 : 				{
; 9718 : 				case 0:
; 9719 : 				case 4:
; 9720 : 					if(source > (INVETORY_WEAR_SIZE - 1))

  00f32	80 7d 0c 0b	 cmp	 BYTE PTR _source$[ebp], 11 ; 0000000bH
  00f36	76 1c		 jbe	 SHORT $LN72@gObjInvent@18

; 9721 : 					{
; 9722 : 						gObjInventoryItemBoxSet(lpObj->m_Index,source,iwidth,iheight,255);

  00f38	68 ff 00 00 00	 push	 255			; 000000ffH
  00f3d	8b 4d a8	 mov	 ecx, DWORD PTR _iheight$[ebp]
  00f40	51		 push	 ecx
  00f41	8b 55 a4	 mov	 edx, DWORD PTR _iwidth$[ebp]
  00f44	52		 push	 edx
  00f45	8b 45 d8	 mov	 eax, DWORD PTR tv1813[ebp]
  00f48	50		 push	 eax
  00f49	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00f4b	51		 push	 ecx
  00f4c	e8 00 00 00 00	 call	 ?gObjInventoryItemBoxSet@@YAXHHHHE@Z ; gObjInventoryItemBoxSet
  00f51	83 c4 14	 add	 esp, 20			; 00000014H
$LN72@gObjInvent@18:

; 9723 : 					}
; 9724 : 					break;
; 9725 : 				default: break;
; 9726 : 				}
; 9727 : 			
; 9728 : 			if(*(BYTE*)(gObj[aIndex].pInventoryMap + h * 8 + w) != 255)

  00f54	8b 55 c0	 mov	 edx, DWORD PTR tv1794[ebp]
  00f57	8b 82 90 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3216]
  00f5d	8b 4d 18	 mov	 ecx, DWORD PTR _h$[ebp]
  00f60	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]
  00f63	8b 45 14	 mov	 eax, DWORD PTR _w$[ebp]
  00f66	80 3c 02 ff	 cmp	 BYTE PTR [edx+eax], 255	; 000000ffH
  00f6a	74 3b		 je	 SHORT $LN70@gObjInvent@18

; 9729 : 			{
; 9730 : 				memcpy(lpObj->pInventoryMap,TempInventoryMap,64);

  00f6c	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00f71	8d b5 60 ff ff
	ff		 lea	 esi, DWORD PTR _TempInventoryMap$[ebp]
  00f77	8b bb 90 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3216]
  00f7d	f3 a5		 rep movsd

; 9731 : 				return -1;

  00f7f	6a fe		 push	 -2			; fffffffeH
  00f81	9b		 fwait
  00f82	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00f85	50		 push	 eax
  00f86	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00f8b	e8 00 00 00 00	 call	 __local_unwind4
  00f90	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9151 : 				return -1;

  00f93	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  00f95	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00f98	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00f9f	59		 pop	 ecx
  00fa0	5f		 pop	 edi
  00fa1	5e		 pop	 esi
  00fa2	5b		 pop	 ebx
  00fa3	8b e5		 mov	 esp, ebp
  00fa5	5d		 pop	 ebp
  00fa6	c3		 ret	 0
$LN70@gObjInvent@18:

; 9732 : 			}
; 9733 : 
; 9734 : 			blank = gObjInventoryRectCheck(lpObj->m_Index,w,h,iwidth,iheight);

  00fa7	8b 55 a8	 mov	 edx, DWORD PTR _iheight$[ebp]
  00faa	52		 push	 edx
  00fab	8b 55 a4	 mov	 edx, DWORD PTR _iwidth$[ebp]
  00fae	52		 push	 edx
  00faf	51		 push	 ecx
  00fb0	50		 push	 eax
  00fb1	8b 03		 mov	 eax, DWORD PTR [ebx]
  00fb3	50		 push	 eax
  00fb4	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  00fb9	83 c4 14	 add	 esp, 20			; 00000014H
  00fbc	0f b6 c0	 movzx	 eax, al

; 9735 : 
; 9736 : 			if(blank >= 254)

  00fbf	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00fc4	7c 3b		 jl	 SHORT $LN69@gObjInvent@18

; 9737 : 			{
; 9738 : 				memcpy(lpObj->pInventoryMap,TempInventoryMap,64);

  00fc6	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00fcb	8d b5 60 ff ff
	ff		 lea	 esi, DWORD PTR _TempInventoryMap$[ebp]
  00fd1	8b bb 90 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3216]
  00fd7	f3 a5		 rep movsd

; 9739 : 				return -1;

  00fd9	6a fe		 push	 -2			; fffffffeH
  00fdb	9b		 fwait
  00fdc	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00fdf	51		 push	 ecx
  00fe0	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00fe5	e8 00 00 00 00	 call	 __local_unwind4
  00fea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9151 : 				return -1;

  00fed	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  00fef	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00ff2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00ff9	59		 pop	 ecx
  00ffa	5f		 pop	 edi
  00ffb	5e		 pop	 esi
  00ffc	5b		 pop	 ebx
  00ffd	8b e5		 mov	 esp, ebp
  00fff	5d		 pop	 ebp
  01000	c3		 ret	 0
$LN69@gObjInvent@18:

; 9740 : 			}
; 9741 : 			}
; 9742 : 
; 9743 : 			s_num = sitem->GetNumber();

  01001	8b 4d dc	 mov	 ecx, DWORD PTR _sitem$[ebp]
  01004	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 9744 : 			titem = sitem;
; 9745 : 
; 9746 : 				switch(sFlag)

  01009	8b 55 bc	 mov	 edx, DWORD PTR tv1809[ebp]
  0100c	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN249@gObjInvent@18[edx]
  01013	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN329@gObjInvent@18[eax*4]
$LN66@gObjInvent@18:

; 9747 : 				{
; 9748 : 				case 0:
; 9749 : 				case 4:
; 9750 : 					lpObj->pInventory[target] = lpObj->pInventory[source];

  0101a	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3212]
  01020	8b 4d e0	 mov	 ecx, DWORD PTR tv1814[ebp]
  01023	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  01026	8b 7d e4	 mov	 edi, DWORD PTR tv1892[ebp]
  01029	03 f8		 add	 edi, eax
  0102b	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  01030	f3 a5		 rep movsd

; 9751 : 					gObjInventoryDeleteItem(aIndex,source);

  01032	8b 45 d8	 mov	 eax, DWORD PTR tv1813[ebp]
  01035	50		 push	 eax
  01036	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01039	51		 push	 ecx
  0103a	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 9752 : 					break;

  0103f	eb 4e		 jmp	 SHORT $LN311@gObjInvent@18
$LN65@gObjInvent@18:

; 9753 : 				case 2:
; 9754 : 					lpObj->pInventory[target] = lpObj->pWarehouse[source];

  01041	8b b3 c4 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3268]
  01047	03 75 e0	 add	 esi, DWORD PTR tv1814[ebp]
  0104a	8b bb 8c 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3212]
  01050	03 7d e4	 add	 edi, DWORD PTR tv1892[ebp]
  01053	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  01058	f3 a5		 rep movsd

; 9755 : 					gObjWarehouseDeleteItem(aIndex,source);

  0105a	8b 55 d8	 mov	 edx, DWORD PTR tv1813[ebp]
  0105d	52		 push	 edx
  0105e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01061	50		 push	 eax
  01062	e8 00 00 00 00	 call	 ?gObjWarehouseDeleteItem@@YAEHH@Z ; gObjWarehouseDeleteItem

; 9756 : 					break;

  01067	eb 26		 jmp	 SHORT $LN311@gObjInvent@18
$LN64@gObjInvent@18:

; 9757 : 				case 3:
; 9758 : 				case 5:
; 9759 : 				case 6:
; 9760 : 				case 7:
; 9761 : 				case 8:
; 9762 : 				case 9:
; 9763 : 					lpObj->pInventory[target] = lpObj->pChaosBox[source];

  01069	8b b3 dc 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3292]
  0106f	03 75 e0	 add	 esi, DWORD PTR tv1814[ebp]
  01072	8b bb 8c 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3212]
  01078	03 7d e4	 add	 edi, DWORD PTR tv1892[ebp]
  0107b	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  01080	f3 a5		 rep movsd

; 9764 : 					gObjChaosBoxDeleteItem(aIndex,source);

  01082	8b 4d d8	 mov	 ecx, DWORD PTR tv1813[ebp]
  01085	51		 push	 ecx
  01086	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01089	52		 push	 edx
  0108a	e8 00 00 00 00	 call	 ?gObjChaosBoxDeleteItem@@YAEHH@Z ; gObjChaosBoxDeleteItem
$LN311@gObjInvent@18:
  0108f	83 c4 08	 add	 esp, 8
$LN63@gObjInvent@18:

; 9765 : 					break;
; 9766 : 				default : break;
; 9767 : 				}
; 9768 : 
; 9769 : 				if(target > (INVETORY_WEAR_SIZE - 1))

  01092	80 7d 10 0b	 cmp	 BYTE PTR _target$[ebp], 11 ; 0000000bH
  01096	76 12		 jbe	 SHORT $LN62@gObjInvent@18

; 9770 : 				{
; 9771 : 					gObjInventoryItemSet(aIndex,target,1);

  01098	6a 01		 push	 1
  0109a	8b 45 d4	 mov	 eax, DWORD PTR tv1891[ebp]
  0109d	50		 push	 eax
  0109e	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  010a1	51		 push	 ecx
  010a2	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  010a7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN62@gObjInvent@18:

; 9772 : 				}
; 9773 : 
; 9774 : 				if(target < INVETORY_WEAR_SIZE)

  010aa	80 7d 10 0c	 cmp	 BYTE PTR _target$[ebp], 12 ; 0000000cH
  010ae	73 44		 jae	 SHORT $LN14@gObjInvent@18

; 9775 : 				{
; 9776 : 					CItem * lpItem = &lpObj->pInventory[target];

  010b0	8b b3 8c 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3212]
  010b6	03 75 e4	 add	 esi, DWORD PTR tv1892[ebp]

; 9777 : 					if(lpItem->m_Option1)

  010b9	80 7e 78 00	 cmp	 BYTE PTR [esi+120], 0
  010bd	74 35		 je	 SHORT $LN14@gObjInvent@18

; 9778 : 					{
; 9779 : 						int s_pos = gObjWeaponMagicAdd(&gObj[aIndex],lpItem->m_Special[0],lpItem->m_Level);

  010bf	0f b6 56 08	 movzx	 edx, BYTE PTR [esi+8]
  010c3	52		 push	 edx
  010c4	0f b6 46 31	 movzx	 eax, BYTE PTR [esi+49]
  010c8	50		 push	 eax
  010c9	53		 push	 ebx
  010ca	e8 00 00 00 00	 call	 ?gObjWeaponMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjWeaponMagicAdd
  010cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  010d2	89 45 18	 mov	 DWORD PTR _s_pos$165265[ebp], eax

; 9780 : 						if(s_pos >= 0)

  010d5	85 c0		 test	 eax, eax
  010d7	78 1b		 js	 SHORT $LN14@gObjInvent@18

; 9781 : 						{
; 9782 : 							GCMagicListOneSend(aIndex,s_pos,lpItem->m_Special[0],lpItem->m_Level,0,0);

  010d9	6a 00		 push	 0
  010db	6a 00		 push	 0
  010dd	0f b6 4e 08	 movzx	 ecx, BYTE PTR [esi+8]
  010e1	51		 push	 ecx
  010e2	0f b6 56 31	 movzx	 edx, BYTE PTR [esi+49]
  010e6	52		 push	 edx
  010e7	50		 push	 eax
  010e8	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  010eb	50		 push	 eax
  010ec	e8 00 00 00 00	 call	 ?GCMagicListOneSend@@YAXHDEEEE@Z ; GCMagicListOneSend
  010f1	83 c4 18	 add	 esp, 24			; 00000018H
$LN14@gObjInvent@18:

; 9943 : 		default: break;
; 9944 : 		}
; 9945 : 
; 9946 : 		if(sFlag == 0 && source < INVETORY_WEAR_SIZE)

  010f4	80 7d 1c 00	 cmp	 BYTE PTR _sFlag$[ebp], 0
  010f8	0f 85 7a 04 00
	00		 jne	 $LN293@gObjInvent@18
  010fe	80 7d 0c 0c	 cmp	 BYTE PTR _source$[ebp], 12 ; 0000000cH
  01102	0f 83 70 04 00
	00		 jae	 $LN293@gObjInvent@18

; 9947 : 		{
; 9948 : 			if(lpObj->pInventory[source].IsItem() == 1)

  01108	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  0110e	8b 7d e0	 mov	 edi, DWORD PTR tv1814[ebp]
  01111	03 cf		 add	 ecx, edi
  01113	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  01118	83 f8 01	 cmp	 eax, 1
  0111b	0f 85 ef 03 00
	00		 jne	 $LN12@gObjInvent@18

; 9949 : 			{
; 9950 : 				if(lpObj->pInventory[source].m_Type == ITEMGET(13,10))

  01121	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3212]
  01127	b9 0a 1a 00 00	 mov	 ecx, 6666		; 00001a0aH

; 9951 : 				{
; 9952 : 					gObjUseSkill.SkillChangeUse(aIndex);

  0112c	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 9949 : 			{
; 9950 : 				if(lpObj->pInventory[source].m_Type == ITEMGET(13,10))

  0112f	66 39 4c 07 06	 cmp	 WORD PTR [edi+eax+6], cx
  01134	75 3b		 jne	 SHORT $LN11@gObjInvent@18

; 9951 : 				{
; 9952 : 					gObjUseSkill.SkillChangeUse(aIndex);

  01136	56		 push	 esi
  01137	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0113c	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 9953 : 					LogAdd(LOG_BLACK, lMsg.Get(534),gObj[aIndex].Name,lpObj->pInventory[source].m_Level);

  01141	8b 93 8c 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3212]
  01147	0f bf 44 17 08	 movsx	 eax, WORD PTR [edi+edx+8]
  0114c	50		 push	 eax
  0114d	8b 4d c0	 mov	 ecx, DWORD PTR tv1794[ebp]
  01150	8d 91 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+111]
  01156	52		 push	 edx
  01157	68 16 02 00 00	 push	 534			; 00000216H
  0115c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01161	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01166	50		 push	 eax
  01167	6a 00		 push	 0
  01169	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0116e	83 c4 10	 add	 esp, 16			; 00000010H
$LN11@gObjInvent@18:

; 9954 : 				}
; 9955 : 
; 9956 : 				if(lpObj->pInventory[source].m_Type == ITEMGET(13,39))

  01171	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3212]
  01177	b9 27 1a 00 00	 mov	 ecx, 6695		; 00001a27H
  0117c	66 39 4c 07 06	 cmp	 WORD PTR [edi+eax+6], cx
  01181	0f 85 d9 03 00
	00		 jne	 $LN298@gObjInvent@18

; 9957 : 				{
; 9958 : 					gObjUseSkill.SkillChangeUse(aIndex);

  01187	56		 push	 esi
  01188	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0118d	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 9959 : 					LogAdd(LOG_BLACK, lMsg.Get(534),gObj[aIndex].Name,lpObj->pInventory[source].m_Level);

  01192	8b 93 8c 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3212]
  01198	0f bf 44 17 08	 movsx	 eax, WORD PTR [edi+edx+8]
  0119d	50		 push	 eax
  0119e	8b 4d c0	 mov	 ecx, DWORD PTR tv1794[ebp]
  011a1	8d 91 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+111]
  011a7	52		 push	 edx
  011a8	68 16 02 00 00	 push	 534			; 00000216H
  011ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  011b2	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  011b7	50		 push	 eax
  011b8	6a 00		 push	 0
  011ba	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  011bf	83 c4 10	 add	 esp, 16			; 00000010H

; 9960 : 				}
; 9961 : 			}
; 9962 : 			else

  011c2	e9 99 03 00 00	 jmp	 $LN298@gObjInvent@18
$LN58@gObjInvent@18:

; 9783 : 						}
; 9784 : 					}
; 9785 : 				}
; 9786 : 			break;
; 9787 : 		case 2:
; 9788 : 			BYTE res_1;
; 9789 : 				switch(sFlag)

  011c7	8b 45 bc	 mov	 eax, DWORD PTR tv1809[ebp]
  011ca	83 e8 00	 sub	 eax, 0
  011cd	74 40		 je	 SHORT $LN55@gObjInvent@18
  011cf	83 e8 02	 sub	 eax, 2
  011d2	0f 85 f1 00 00
	00		 jne	 $LN285@gObjInvent@18

; 9827 : 					break;
; 9828 : 				case 2:
; 9829 : 					res_1 = gObjWarehouseInsertItemPos(aIndex,lpObj->pWarehouse[source],target,source);

  011d8	8b 4d d8	 mov	 ecx, DWORD PTR tv1813[ebp]
  011db	51		 push	 ecx
  011dc	8b 55 d4	 mov	 edx, DWORD PTR tv1891[ebp]
  011df	52		 push	 edx
  011e0	8b b3 c4 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3268]
  011e6	03 75 e0	 add	 esi, DWORD PTR tv1814[ebp]
  011e9	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  011ef	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  011f4	8b fc		 mov	 edi, esp
  011f6	f3 a5		 rep movsd
  011f8	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  011fb	50		 push	 eax
  011fc	e8 00 00 00 00	 call	 ?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z ; gObjWarehouseInsertItemPos
  01201	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H

; 9830 : 					break;

  01207	8b 75 e4	 mov	 esi, DWORD PTR tv1892[ebp]
  0120a	e9 bd 00 00 00	 jmp	 $LN56@gObjInvent@18
$LN55@gObjInvent@18:

; 9790 : 				{
; 9791 : 				case 0:
; 9792 : 					if(lpObj->pInventory[source].m_Type == ITEMGET(13,20))

  0120f	8b b3 8c 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3212]
  01215	03 75 e0	 add	 esi, DWORD PTR tv1814[ebp]
  01218	0f b7 4e 06	 movzx	 ecx, WORD PTR [esi+6]
  0121c	b8 14 1a 00 00	 mov	 eax, 6676		; 00001a14H
  01221	66 3b c8	 cmp	 cx, ax
  01224	75 17		 jne	 SHORT $LN53@gObjInvent@18

; 9793 : 					{
; 9794 : 						if(lpObj->pInventory[source].m_Level == 0 ||
; 9795 : 							lpObj->pInventory[source].m_Level == 1)

  01226	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  0122a	66 85 c0	 test	 ax, ax
  0122d	0f 84 18 f5 ff
	ff		 je	 $LN142@gObjInvent@18
  01233	66 83 f8 01	 cmp	 ax, 1

; 9796 : 						{
; 9797 : 							return -1;

  01237	0f 84 0e f5 ff
	ff		 je	 $LN142@gObjInvent@18
$LN53@gObjInvent@18:

; 9798 : 						}
; 9799 : 					}
; 9800 : 
; 9801 : 					if(lpObj->pInventory[source].m_Type == ITEMGET(14,11))

  0123d	ba 0b 1c 00 00	 mov	 edx, 7179		; 00001c0bH
  01242	66 3b ca	 cmp	 cx, dx
  01245	75 0b		 jne	 SHORT $LN50@gObjInvent@18

; 9802 : 					{
; 9803 : 						if(lpObj->pInventory[source].m_Level == 13)

  01247	66 83 7e 08 0d	 cmp	 WORD PTR [esi+8], 13	; 0000000dH

; 9804 : 						{
; 9805 : 							return -1;

  0124c	0f 84 54 f3 ff
	ff		 je	 $LN322@gObjInvent@18
$LN50@gObjInvent@18:

; 9806 : 						}
; 9807 : 					}
; 9808 : 
; 9809 : 					if(lpObj->pInventory[source].m_Type == ITEMGET(12,26))

  01252	ba 1a 18 00 00	 mov	 edx, 6170		; 0000181aH
  01257	66 3b ca	 cmp	 cx, dx
  0125a	75 36		 jne	 SHORT $LN48@gObjInvent@18

; 9810 : 					{
; 9811 : 						if(lpObj->pInventory[source].m_Level == 1 ||
; 9812 : 							lpObj->pInventory[source].m_Level == 2 ||
; 9813 : 							lpObj->pInventory[source].m_Level == 3 ||
; 9814 : 							lpObj->pInventory[source].m_Level == 4 ||
; 9815 : 							lpObj->pInventory[source].m_Level == 5)

  0125c	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  01260	66 83 f8 01	 cmp	 ax, 1
  01264	0f 84 3c f3 ff
	ff		 je	 $LN322@gObjInvent@18
  0126a	66 83 f8 02	 cmp	 ax, 2
  0126e	0f 84 32 f3 ff
	ff		 je	 $LN322@gObjInvent@18
  01274	66 83 f8 03	 cmp	 ax, 3
  01278	0f 84 28 f3 ff
	ff		 je	 $LN322@gObjInvent@18
  0127e	66 83 f8 04	 cmp	 ax, 4
  01282	0f 84 1e f3 ff
	ff		 je	 $LN322@gObjInvent@18
  01288	66 83 f8 05	 cmp	 ax, 5

; 9816 : 						{
; 9817 : 							return -1;

  0128c	0f 84 14 f3 ff
	ff		 je	 $LN322@gObjInvent@18
$LN48@gObjInvent@18:

; 9818 : 						}
; 9819 : 					}
; 9820 : 
; 9821 : 					if(lpObj->pInventory[source].m_Type == ITEMGET(13,39))

  01292	ba 27 1a 00 00	 mov	 edx, 6695		; 00001a27H
  01297	66 3b ca	 cmp	 cx, dx

; 9822 : 					{
; 9823 : 						return -1;

  0129a	0f 84 06 f3 ff
	ff		 je	 $LN322@gObjInvent@18

; 9824 : 					}
; 9825 : 
; 9826 : 					res_1 = gObjWarehouseInsertItemPos(aIndex,lpObj->pInventory[source],target,-1);

  012a0	6a ff		 push	 -1
  012a2	8b 4d d4	 mov	 ecx, DWORD PTR tv1891[ebp]
  012a5	51		 push	 ecx
  012a6	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  012ac	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  012b1	8b fc		 mov	 edi, esp
  012b3	f3 a5		 rep movsd
  012b5	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  012b8	52		 push	 edx
  012b9	e8 00 00 00 00	 call	 ?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z ; gObjWarehouseInsertItemPos
  012be	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H
  012c4	8b 75 e4	 mov	 esi, DWORD PTR tv1892[ebp]
  012c7	eb 03		 jmp	 SHORT $LN56@gObjInvent@18
$LN285@gObjInvent@18:
  012c9	8a 45 0b	 mov	 al, BYTE PTR _res_1$165268[ebp]
$LN56@gObjInvent@18:

; 9831 : 				default : break;
; 9832 : 				}
; 9833 : 
; 9834 : 				if(res_1 == 255)

  012cc	3c ff		 cmp	 al, 255			; 000000ffH

; 9835 : 				{
; 9836 : 					return -1;

  012ce	0f 84 d2 f2 ff
	ff		 je	 $LN322@gObjInvent@18

; 9837 : 				}
; 9838 : 
; 9839 : 				switch(sFlag)

  012d4	8b 45 bc	 mov	 eax, DWORD PTR tv1809[ebp]
  012d7	83 e8 00	 sub	 eax, 0
  012da	74 2c		 je	 SHORT $LN40@gObjInvent@18
  012dc	83 e8 02	 sub	 eax, 2
  012df	75 53		 jne	 SHORT $LN41@gObjInvent@18

; 9844 : 					break;
; 9845 : 				case 2:
; 9846 : 					lpObj->pWarehouse[target] = lpObj->pWarehouse[source];

  012e1	8b 83 c4 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3268]
  012e7	8b 4d e0	 mov	 ecx, DWORD PTR tv1814[ebp]
  012ea	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  012ed	8b 7d e4	 mov	 edi, DWORD PTR tv1892[ebp]
  012f0	03 f8		 add	 edi, eax
  012f2	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  012f7	f3 a5		 rep movsd

; 9847 : 					gObjWarehouseDeleteItem(aIndex,source);

  012f9	8b 45 d8	 mov	 eax, DWORD PTR tv1813[ebp]
  012fc	50		 push	 eax
  012fd	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01300	51		 push	 ecx
  01301	e8 00 00 00 00	 call	 ?gObjWarehouseDeleteItem@@YAEHH@Z ; gObjWarehouseDeleteItem

; 9848 : 					break;

  01306	eb 26		 jmp	 SHORT $LN312@gObjInvent@18
$LN40@gObjInvent@18:

; 9840 : 				{
; 9841 : 				case 0:
; 9842 : 					lpObj->pWarehouse[target] = lpObj->pInventory[source];

  01308	8b b3 8c 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3212]
  0130e	03 75 e0	 add	 esi, DWORD PTR tv1814[ebp]
  01311	8b bb c4 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3268]
  01317	03 7d e4	 add	 edi, DWORD PTR tv1892[ebp]
  0131a	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0131f	f3 a5		 rep movsd

; 9843 : 					gObjInventoryDeleteItem(aIndex,source);

  01321	8b 55 d8	 mov	 edx, DWORD PTR tv1813[ebp]
  01324	52		 push	 edx
  01325	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01328	50		 push	 eax
  01329	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
$LN312@gObjInvent@18:
  0132e	8b 75 e4	 mov	 esi, DWORD PTR tv1892[ebp]
  01331	83 c4 08	 add	 esp, 8
$LN41@gObjInvent@18:

; 9849 : 				default : break;
; 9850 : 				}
; 9851 : 
; 9852 : 				gObjWarehouseItemSet(aIndex,target,1);

  01334	6a 01		 push	 1
  01336	8b 4d d4	 mov	 ecx, DWORD PTR tv1891[ebp]
  01339	51		 push	 ecx
  0133a	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0133d	57		 push	 edi
  0133e	e8 00 00 00 00	 call	 ?gObjWarehouseItemSet@@YAXHHE@Z ; gObjWarehouseItemSet
  01343	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9853 : 
; 9854 : 				if(sFlag == 0)

  01346	80 7d 1c 00	 cmp	 BYTE PTR _sFlag$[ebp], 0
  0134a	75 3f		 jne	 SHORT $LN36@gObjInvent@18

; 9855 : 				{
; 9856 : 					if(source < INVETORY_WEAR_SIZE)

  0134c	8a 45 0c	 mov	 al, BYTE PTR _source$[ebp]
  0134f	3c 0c		 cmp	 al, 12			; 0000000cH
  01351	73 38		 jae	 SHORT $LN36@gObjInvent@18

; 9857 : 					{
; 9858 : 						if(source == 10 || source == 11)

  01353	3c 0a		 cmp	 al, 10			; 0000000aH
  01355	74 04		 je	 SHORT $LN34@gObjInvent@18
  01357	3c 0b		 cmp	 al, 11			; 0000000bH
  01359	75 1d		 jne	 SHORT $LN33@gObjInvent@18
$LN34@gObjInvent@18:

; 9859 : 						{
; 9860 : 							if(lpObj->pWarehouse[target].m_Type == ITEMGET(13,10))

  0135b	8b 93 c4 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3268]
  01361	b8 0a 1a 00 00	 mov	 eax, 6666		; 00001a0aH
  01366	66 39 44 32 06	 cmp	 WORD PTR [edx+esi+6], ax
  0136b	75 0b		 jne	 SHORT $LN33@gObjInvent@18

; 9861 : 							{
; 9862 : 								gObjUseSkill.SkillChangeUse(aIndex);

  0136d	57		 push	 edi
  0136e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  01373	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN33@gObjInvent@18:

; 9863 : 							}
; 9864 : 						}
; 9865 : 
; 9866 : 						gObjMakePreviewCharSet(aIndex);

  01378	57		 push	 edi
  01379	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 9867 : 						GCEquipmentChange(aIndex,source);

  0137e	8b 4d d8	 mov	 ecx, DWORD PTR tv1813[ebp]
  01381	51		 push	 ecx
  01382	57		 push	 edi
  01383	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange
  01388	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@gObjInvent@18:

; 9868 : 					}
; 9869 : 				}
; 9870 : 			return 2;

  0138b	6a fe		 push	 -2			; fffffffeH
  0138d	9b		 fwait
  0138e	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  01391	52		 push	 edx
  01392	68 00 00 00 00	 push	 OFFSET ___security_cookie
  01397	e8 00 00 00 00	 call	 __local_unwind4
  0139c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0139f	b0 02		 mov	 al, 2

; 10008: }

  013a1	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  013a4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  013ab	59		 pop	 ecx
  013ac	5f		 pop	 edi
  013ad	5e		 pop	 esi
  013ae	5b		 pop	 ebx
  013af	8b e5		 mov	 esp, ebp
  013b1	5d		 pop	 ebp
  013b2	c3		 ret	 0
$LN32@gObjInvent@18:

; 9871 : 		case 3:
; 9872 : 		case 5:
; 9873 : 		case 6:
; 9874 : 		case 7:
; 9875 : 		case 8:
; 9876 : 		case 9:
; 9877 : 			BYTE res_2;
; 9878 : 				switch(sFlag)

  013b3	8b 45 bc	 mov	 eax, DWORD PTR tv1809[ebp]
  013b6	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN250@gObjInvent@18[eax]
  013bd	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN330@gObjInvent@18[ecx*4]
$LN29@gObjInvent@18:

; 9879 : 				{
; 9880 : 				case 0:
; 9881 : 					res_2 = gObjChaosBoxInsertItemPos(aIndex,lpObj->pInventory[source],target,-1);

  013c4	6a ff		 push	 -1
  013c6	8b b3 8c 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3212]
$LN325@gObjInvent@18:
  013cc	8b 55 d4	 mov	 edx, DWORD PTR tv1891[ebp]
  013cf	52		 push	 edx
  013d0	03 75 e0	 add	 esi, DWORD PTR tv1814[ebp]
  013d3	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  013d9	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  013de	8b fc		 mov	 edi, esp
  013e0	f3 a5		 rep movsd
  013e2	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  013e5	50		 push	 eax
  013e6	e8 00 00 00 00	 call	 ?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z ; gObjChaosBoxInsertItemPos
  013eb	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H

; 9882 : 					break;

  013f1	8b 75 e4	 mov	 esi, DWORD PTR tv1892[ebp]
  013f4	eb 0f		 jmp	 SHORT $LN27@gObjInvent@18
$LN28@gObjInvent@18:

; 9883 : 				case 3:
; 9884 : 				case 5:
; 9885 : 				case 6:
; 9886 : 				case 7:
; 9887 : 				case 8:
; 9888 : 				case 9:
; 9889 : 
; 9890 : 					res_2 = gObjChaosBoxInsertItemPos(aIndex,lpObj->pChaosBox[source],target,source);

  013f6	8b 4d d8	 mov	 ecx, DWORD PTR tv1813[ebp]
  013f9	51		 push	 ecx
  013fa	8b b3 dc 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3292]
  01400	eb ca		 jmp	 SHORT $LN325@gObjInvent@18
$LN286@gObjInvent@18:
  01402	8a 45 0b	 mov	 al, BYTE PTR _res_2$165299[ebp]
$LN27@gObjInvent@18:

; 9891 : 					break;
; 9892 : 				default : break;
; 9893 : 				}
; 9894 : 
; 9895 : 				if(res_2 == 255)

  01405	3c ff		 cmp	 al, 255			; 000000ffH

; 9896 : 				{
; 9897 : 					return -1;

  01407	0f 84 3e f3 ff
	ff		 je	 $LN142@gObjInvent@18

; 9898 : 				}
; 9899 : 
; 9900 : 				switch(sFlag)

  0140d	8b 55 bc	 mov	 edx, DWORD PTR tv1809[ebp]
  01410	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN251@gObjInvent@18[edx]
  01417	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN331@gObjInvent@18[eax*4]
$LN23@gObjInvent@18:

; 9901 : 				{
; 9902 : 				case 0:
; 9903 : 					lpObj->pChaosBox[target] = lpObj->pInventory[source];

  0141e	8b b3 8c 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3212]
  01424	03 75 e0	 add	 esi, DWORD PTR tv1814[ebp]
  01427	8b bb dc 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3292]
  0142d	03 7d e4	 add	 edi, DWORD PTR tv1892[ebp]
  01430	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  01435	f3 a5		 rep movsd

; 9904 : 					gObjInventoryDeleteItem(aIndex,source);

  01437	8b 4d d8	 mov	 ecx, DWORD PTR tv1813[ebp]
  0143a	51		 push	 ecx
  0143b	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0143e	52		 push	 edx
  0143f	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 9905 : 					break;

  01444	eb 25		 jmp	 SHORT $LN314@gObjInvent@18
$LN22@gObjInvent@18:

; 9906 : 				case 3:
; 9907 : 				case 5:
; 9908 : 				case 6:
; 9909 : 				case 7:
; 9910 : 				case 8:
; 9911 : 				case 9:
; 9912 : 
; 9913 : 					lpObj->pChaosBox[target] = lpObj->pChaosBox[source];

  01446	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  0144c	8b 4d e0	 mov	 ecx, DWORD PTR tv1814[ebp]
  0144f	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  01452	8b 7d e4	 mov	 edi, DWORD PTR tv1892[ebp]
  01455	03 f8		 add	 edi, eax
  01457	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0145c	f3 a5		 rep movsd

; 9914 : 					gObjChaosBoxDeleteItem(aIndex,source);

  0145e	8b 45 d8	 mov	 eax, DWORD PTR tv1813[ebp]
  01461	50		 push	 eax
  01462	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01465	51		 push	 ecx
  01466	e8 00 00 00 00	 call	 ?gObjChaosBoxDeleteItem@@YAEHH@Z ; gObjChaosBoxDeleteItem
$LN314@gObjInvent@18:
  0146b	8b 75 e4	 mov	 esi, DWORD PTR tv1892[ebp]
  0146e	83 c4 08	 add	 esp, 8
$LN21@gObjInvent@18:

; 9915 : 					break;
; 9916 : 				default : break;
; 9917 : 				}
; 9918 : 
; 9919 : 				gObjChaosItemSet(aIndex,target,1);

  01471	6a 01		 push	 1
  01473	8b 55 d4	 mov	 edx, DWORD PTR tv1891[ebp]
  01476	52		 push	 edx
  01477	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0147a	57		 push	 edi
  0147b	e8 00 00 00 00	 call	 ?gObjChaosItemSet@@YAXHHE@Z ; gObjChaosItemSet
  01480	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9920 : 
; 9921 : 				if(sFlag == 0)

  01483	80 7d 1c 00	 cmp	 BYTE PTR _sFlag$[ebp], 0
  01487	75 5e		 jne	 SHORT $LN19@gObjInvent@18

; 9922 : 				{
; 9923 : 					if(source < INVETORY_WEAR_SIZE)

  01489	80 7d 0c 0c	 cmp	 BYTE PTR _source$[ebp], 12 ; 0000000cH
  0148d	73 58		 jae	 SHORT $LN19@gObjInvent@18

; 9924 : 					{
; 9925 : 						if(source == 10 || source == 11)

  0148f	8a 45 0c	 mov	 al, BYTE PTR _source$[ebp]
  01492	3c 0a		 cmp	 al, 10			; 0000000aH
  01494	74 04		 je	 SHORT $LN17@gObjInvent@18
  01496	3c 0b		 cmp	 al, 11			; 0000000bH
  01498	75 3a		 jne	 SHORT $LN15@gObjInvent@18
$LN17@gObjInvent@18:

; 9926 : 						{
; 9927 : 							if(lpObj->pChaosBox[target].m_Type == ITEMGET(13,10))

  0149a	8b 83 dc 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3292]
  014a0	b9 0a 1a 00 00	 mov	 ecx, 6666		; 00001a0aH
  014a5	66 39 4c 06 06	 cmp	 WORD PTR [esi+eax+6], cx
  014aa	75 0b		 jne	 SHORT $LN16@gObjInvent@18

; 9928 : 							{
; 9929 : 								gObjUseSkill.SkillChangeUse(aIndex);

  014ac	57		 push	 edi
  014ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  014b2	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN16@gObjInvent@18:

; 9930 : 							}
; 9931 : 
; 9932 : 							if(lpObj->pChaosBox[target].m_Type == ITEMGET(13,39))

  014b7	8b 93 dc 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3292]
  014bd	b8 27 1a 00 00	 mov	 eax, 6695		; 00001a27H
  014c2	66 39 44 16 06	 cmp	 WORD PTR [esi+edx+6], ax
  014c7	75 0b		 jne	 SHORT $LN15@gObjInvent@18

; 9933 : 							{
; 9934 : 								gObjUseSkill.SkillChangeUse(aIndex);

  014c9	57		 push	 edi
  014ca	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  014cf	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN15@gObjInvent@18:

; 9935 : 							}
; 9936 : 						}
; 9937 : 
; 9938 : 						gObjMakePreviewCharSet(aIndex);

  014d4	57		 push	 edi
  014d5	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 9939 : 						GCEquipmentChange(aIndex,source);

  014da	8b 4d d8	 mov	 ecx, DWORD PTR tv1813[ebp]
  014dd	51		 push	 ecx
  014de	57		 push	 edi
  014df	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange
  014e4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@gObjInvent@18:

; 9940 : 					}
; 9941 : 				}
; 9942 : 			return tFlag;

  014e7	6a fe		 push	 -2			; fffffffeH
  014e9	9b		 fwait
  014ea	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  014ed	52		 push	 edx
  014ee	68 00 00 00 00	 push	 OFFSET ___security_cookie
  014f3	e8 00 00 00 00	 call	 __local_unwind4
  014f8	83 c4 0c	 add	 esp, 12			; 0000000cH
  014fb	8a 45 20	 mov	 al, BYTE PTR _tFlag$[ebp]

; 10008: }

  014fe	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  01501	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01508	59		 pop	 ecx
  01509	5f		 pop	 edi
  0150a	5e		 pop	 esi
  0150b	5b		 pop	 ebx
  0150c	8b e5		 mov	 esp, ebp
  0150e	5d		 pop	 ebp
  0150f	c3		 ret	 0
$LN12@gObjInvent@18:

; 9963 : 			{
; 9964 : 				if(source == 10 || source == 11)

  01510	8a 45 0c	 mov	 al, BYTE PTR _source$[ebp]
  01513	3c 0a		 cmp	 al, 10			; 0000000aH
  01515	74 04		 je	 SHORT $LN7@gObjInvent@18
  01517	3c 0b		 cmp	 al, 11			; 0000000bH
  01519	75 42		 jne	 SHORT $LN292@gObjInvent@18
$LN7@gObjInvent@18:

; 9965 : 				{
; 9966 : 					if(lpObj->pInventory[target].m_Type == ITEMGET(13,10))

  0151b	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3212]
  01521	b9 0a 1a 00 00	 mov	 ecx, 6666		; 00001a0aH
  01526	8b 7d e4	 mov	 edi, DWORD PTR tv1892[ebp]

; 9967 : 					{
; 9968 : 						gObjUseSkill.SkillChangeUse(aIndex);

  01529	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 9965 : 				{
; 9966 : 					if(lpObj->pInventory[target].m_Type == ITEMGET(13,10))

  0152c	66 39 4c 07 06	 cmp	 WORD PTR [edi+eax+6], cx
  01531	75 0b		 jne	 SHORT $LN6@gObjInvent@18

; 9967 : 					{
; 9968 : 						gObjUseSkill.SkillChangeUse(aIndex);

  01533	56		 push	 esi
  01534	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  01539	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN6@gObjInvent@18:

; 9969 : 					}
; 9970 : 
; 9971 : 					if(lpObj->pInventory[target].m_Type == ITEMGET(13,39))

  0153e	8b 93 8c 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3212]
  01544	b8 27 1a 00 00	 mov	 eax, 6695		; 00001a27H
  01549	66 39 44 17 06	 cmp	 WORD PTR [edi+edx+6], ax
  0154e	75 13		 jne	 SHORT $LN5@gObjInvent@18

; 9972 : 					{
; 9973 : 						gObjUseSkill.SkillChangeUse(aIndex);

  01550	56		 push	 esi
  01551	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  01556	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
  0155b	eb 06		 jmp	 SHORT $LN5@gObjInvent@18
$LN292@gObjInvent@18:
  0155d	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
$LN298@gObjInvent@18:

; 9960 : 				}
; 9961 : 			}
; 9962 : 			else

  01560	8b 7d e4	 mov	 edi, DWORD PTR tv1892[ebp]
$LN5@gObjInvent@18:

; 9974 : 					}
; 9975 : 				}
; 9976 : 			}
; 9977 : 
; 9978 : 			gObjMakePreviewCharSet(aIndex);

  01563	56		 push	 esi
  01564	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 9979 : 			GCEquipmentChange(aIndex,source);

  01569	8b 4d d8	 mov	 ecx, DWORD PTR tv1813[ebp]
  0156c	51		 push	 ecx
  0156d	56		 push	 esi
  0156e	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange
  01573	83 c4 0c	 add	 esp, 12			; 0000000cH
  01576	eb 06		 jmp	 SHORT $LN13@gObjInvent@18
$LN293@gObjInvent@18:
  01578	8b 7d e4	 mov	 edi, DWORD PTR tv1892[ebp]
  0157b	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
$LN13@gObjInvent@18:

; 9980 : 		}
; 9981 : 
; 9982 : 		if(tFlag == 0 && target < INVETORY_WEAR_SIZE)

  0157e	80 7d 20 00	 cmp	 BYTE PTR _tFlag$[ebp], 0
  01582	0f 85 b7 00 00
	00		 jne	 $LN4@gObjInvent@18
  01588	80 7d 10 0c	 cmp	 BYTE PTR _target$[ebp], 12 ; 0000000cH
  0158c	0f 83 ad 00 00
	00		 jae	 $LN4@gObjInvent@18

; 9983 : 		{
; 9984 : 			if(lpObj->pInventory[target].m_Type == ITEMGET(13,10))

  01592	8b 93 8c 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3212]
  01598	b8 0a 1a 00 00	 mov	 eax, 6666		; 00001a0aH
  0159d	66 39 44 17 06	 cmp	 WORD PTR [edi+edx+6], ax
  015a2	75 3b		 jne	 SHORT $LN3@gObjInvent@18

; 9985 : 			{
; 9986 : 				gObjUseSkill.SkillChangeUse(aIndex);

  015a4	56		 push	 esi
  015a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  015aa	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 9987 : 				LogAdd(LOG_BLACK, lMsg.Get(534),gObj[aIndex].Name,lpObj->pInventory[target].m_Level);

  015af	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  015b5	0f bf 54 0f 08	 movsx	 edx, WORD PTR [edi+ecx+8]
  015ba	52		 push	 edx
  015bb	8b 45 c0	 mov	 eax, DWORD PTR tv1794[ebp]
  015be	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  015c4	51		 push	 ecx
  015c5	68 16 02 00 00	 push	 534			; 00000216H
  015ca	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  015cf	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  015d4	50		 push	 eax
  015d5	6a 00		 push	 0
  015d7	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  015dc	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@gObjInvent@18:

; 9988 : 			}
; 9989 : 
; 9990 : 			if(lpObj->pInventory[target].m_Type == ITEMGET(13,39))

  015df	8b 93 8c 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3212]
  015e5	b8 27 1a 00 00	 mov	 eax, 6695		; 00001a27H
  015ea	66 39 44 17 06	 cmp	 WORD PTR [edi+edx+6], ax
  015ef	75 3b		 jne	 SHORT $LN2@gObjInvent@18

; 9991 : 			{
; 9992 : 				gObjUseSkill.SkillChangeUse(aIndex);

  015f1	56		 push	 esi
  015f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  015f7	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 9993 : 				LogAdd(LOG_BLACK, lMsg.Get(534),gObj[aIndex].Name,lpObj->pInventory[target].m_Level);

  015fc	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  01602	0f bf 54 0f 08	 movsx	 edx, WORD PTR [edi+ecx+8]
  01607	52		 push	 edx
  01608	8b 45 c0	 mov	 eax, DWORD PTR tv1794[ebp]
  0160b	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  01611	51		 push	 ecx
  01612	68 16 02 00 00	 push	 534			; 00000216H
  01617	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0161c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01621	50		 push	 eax
  01622	6a 00		 push	 0
  01624	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  01629	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@gObjInvent@18:

; 9994 : 			}
; 9995 : 
; 9996 : 			gObjMakePreviewCharSet(aIndex);

  0162c	56		 push	 esi
  0162d	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 9997 : 			GCEquipmentChange(aIndex,target);

  01632	8b 55 d4	 mov	 edx, DWORD PTR tv1891[ebp]
  01635	52		 push	 edx
  01636	56		 push	 esi
  01637	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange
  0163c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@gObjInvent@18:

; 9998 : 		}
; 9999 : 	}
; 10000: 	__finally

  0163f	9b		 fwait
  01640	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  01647	e8 be 00 00 00	 call	 $LN243@gObjInvent@18

; 10005: 		}
; 10006: 	}
; 10007: 	return false;

  0164c	32 c0		 xor	 al, al

; 10008: }

  0164e	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  01651	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01658	59		 pop	 ecx
  01659	5f		 pop	 edi
  0165a	5e		 pop	 esi
  0165b	5b		 pop	 ebx
  0165c	8b e5		 mov	 esp, ebp
  0165e	5d		 pop	 ebp
  0165f	c3		 ret	 0
$LN143@gObjInvent@18:

; 9469 : 			{
; 9470 : 				LogAdd(LOG_BLACK, "error-L1 : %s %d",__FILE__,__LINE__);

  01660	68 fe 24 00 00	 push	 9470			; 000024feH
  01665	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0166a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd?$AA@
  0166f	6a 00		 push	 0
  01671	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 9471 : 				return -1;

  01676	6a fe		 push	 -2			; fffffffeH
  01678	9b		 fwait
  01679	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0167c	50		 push	 eax
  0167d	e9 26 ea ff ff	 jmp	 $LN317@gObjInvent@18
$LN200@gObjInvent@18:

; 9291 : 		{
; 9292 : 			LogAdd(LOG_RED, lMsg.Get(533),type,level,op1,op2,op3,sitem->m_Type,sitem->m_Level,sitem->m_Option1,sitem->m_Option2,sitem->m_Option3);

  01682	0f b6 56 7a	 movzx	 edx, BYTE PTR [esi+122]
  01686	52		 push	 edx
  01687	0f b6 46 79	 movzx	 eax, BYTE PTR [esi+121]
  0168b	50		 push	 eax
  0168c	0f b6 4e 78	 movzx	 ecx, BYTE PTR [esi+120]
  01690	51		 push	 ecx
  01691	0f bf 56 08	 movsx	 edx, WORD PTR [esi+8]
  01695	52		 push	 edx
  01696	8b 45 b0	 mov	 eax, DWORD PTR tv1867[ebp]
  01699	50		 push	 eax
  0169a	0f b6 4d cd	 movzx	 ecx, BYTE PTR _op3$165096[ebp]
  0169e	51		 push	 ecx
  0169f	0f b6 55 c7	 movzx	 edx, BYTE PTR _op2$165095[ebp]
  016a3	52		 push	 edx
  016a4	0f b6 45 cf	 movzx	 eax, BYTE PTR _op1$165094[ebp]
  016a8	50		 push	 eax
  016a9	0f b6 4d ce	 movzx	 ecx, BYTE PTR _level$165093[ebp]
  016ad	51		 push	 ecx
  016ae	8b 55 a0	 mov	 edx, DWORD PTR _type$165098[ebp]
  016b1	52		 push	 edx
  016b2	68 15 02 00 00	 push	 533			; 00000215H
  016b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  016bc	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  016c1	50		 push	 eax
  016c2	6a 01		 push	 1
  016c4	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 9293 : 			return -1;

  016c9	6a fe		 push	 -2			; fffffffeH
  016cb	9b		 fwait
  016cc	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  016cf	50		 push	 eax
  016d0	68 00 00 00 00	 push	 OFFSET ___security_cookie
  016d5	e8 00 00 00 00	 call	 __local_unwind4
  016da	83 c4 3c	 add	 esp, 60			; 0000003cH

; 9151 : 				return -1;

  016dd	0c ff		 or	 al, 255			; 000000ffH

; 10008: }

  016df	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  016e2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  016e9	59		 pop	 ecx
  016ea	5f		 pop	 edi
  016eb	5e		 pop	 esi
  016ec	5b		 pop	 ebx
  016ed	8b e5		 mov	 esp, ebp
  016ef	5d		 pop	 ebp
  016f0	c3		 ret	 0
$LN204@gObjInvent@18:

; 9264 : 			{
; 9265 : 				LogAdd(LOG_BLACK, "error-L1 : %s %d",__FILE__,__LINE__);

  016f1	68 31 24 00 00	 push	 9265			; 00002431H
  016f6	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  016fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd?$AA@
  01700	6a 00		 push	 0

; 9266 : 				return -1;

  01702	e9 95 e9 ff ff	 jmp	 $LN315@gObjInvent@18
$LN241@gObjInvent@18:
$LN332@gObjInvent@18:

; 9998 : 		}
; 9999 : 	}
; 10000: 	__finally

  01707	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
$LN243@gObjInvent@18:

; 10001: 	{
; 10002: 		if(bPersonalShopTrans == 1)

  0170a	83 7d b4 01	 cmp	 DWORD PTR _bPersonalShopTrans$[ebp], 1
  0170e	75 0d		 jne	 SHORT $LN242@gObjInvent@18

; 10003: 		{
; 10004: 			gObj[aIndex].m_bPShopTransaction = 0;

  01710	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  01716	c6 86 29 0d 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3369], 0
$LN242@gObjInvent@18:
$LN306@gObjInvent@18:
  0171d	c3		 ret	 0
  0171e	8b ff		 npad	 2
$LN326@gObjInvent@18:

; 10008: }

  01720	00 00 00 00	 DD	 $LN230@gObjInvent@18
  01724	00 00 00 00	 DD	 $LN216@gObjInvent@18
  01728	00 00 00 00	 DD	 $LN212@gObjInvent@18
  0172c	00 00 00 00	 DD	 $LN208@gObjInvent@18
  01730	00 00 00 00	 DD	 $LN202@gObjInvent@18
$LN246@gObjInvent@18:
  01734	00		 DB	 0
  01735	04		 DB	 4
  01736	01		 DB	 1
  01737	02		 DB	 2
  01738	03		 DB	 3
  01739	02		 DB	 2
  0173a	02		 DB	 2
  0173b	02		 DB	 2
  0173c	02		 DB	 2
  0173d	02		 DB	 2
  0173e	8b ff		 npad	 2
$LN327@gObjInvent@18:
  01740	00 00 00 00	 DD	 $LN197@gObjInvent@18
  01744	00 00 00 00	 DD	 $LN194@gObjInvent@18
  01748	00 00 00 00	 DD	 $LN191@gObjInvent@18
  0174c	00 00 00 00	 DD	 $LN154@gObjInvent@18
  01750	00 00 00 00	 DD	 $LN142@gObjInvent@18
$LN247@gObjInvent@18:
  01754	00		 DB	 0
  01755	04		 DB	 4
  01756	01		 DB	 1
  01757	02		 DB	 2
  01758	03		 DB	 3
  01759	02		 DB	 2
  0175a	02		 DB	 2
  0175b	02		 DB	 2
  0175c	02		 DB	 2
  0175d	02		 DB	 2
  0175e	8b ff		 npad	 2
$LN328@gObjInvent@18:
  01760	00 00 00 00	 DD	 $LN100@gObjInvent@18
  01764	00 00 00 00	 DD	 $LN58@gObjInvent@18
  01768	00 00 00 00	 DD	 $LN32@gObjInvent@18
  0176c	00 00 00 00	 DD	 $LN14@gObjInvent@18
$LN248@gObjInvent@18:
  01770	00		 DB	 0
  01771	03		 DB	 3
  01772	01		 DB	 1
  01773	02		 DB	 2
  01774	00		 DB	 0
  01775	02		 DB	 2
  01776	02		 DB	 2
  01777	02		 DB	 2
  01778	02		 DB	 2
  01779	02		 DB	 2
  0177a	8b ff		 npad	 2
$LN329@gObjInvent@18:
  0177c	00 00 00 00	 DD	 $LN66@gObjInvent@18
  01780	00 00 00 00	 DD	 $LN65@gObjInvent@18
  01784	00 00 00 00	 DD	 $LN64@gObjInvent@18
  01788	00 00 00 00	 DD	 $LN63@gObjInvent@18
$LN249@gObjInvent@18:
  0178c	00		 DB	 0
  0178d	03		 DB	 3
  0178e	01		 DB	 1
  0178f	02		 DB	 2
  01790	00		 DB	 0
  01791	02		 DB	 2
  01792	02		 DB	 2
  01793	02		 DB	 2
  01794	02		 DB	 2
  01795	02		 DB	 2
  01796	8b ff		 npad	 2
$LN330@gObjInvent@18:
  01798	00 00 00 00	 DD	 $LN29@gObjInvent@18
  0179c	00 00 00 00	 DD	 $LN28@gObjInvent@18
  017a0	00 00 00 00	 DD	 $LN286@gObjInvent@18
$LN250@gObjInvent@18:
  017a4	00		 DB	 0
  017a5	02		 DB	 2
  017a6	02		 DB	 2
  017a7	01		 DB	 1
  017a8	02		 DB	 2
  017a9	01		 DB	 1
  017aa	01		 DB	 1
  017ab	01		 DB	 1
  017ac	01		 DB	 1
  017ad	01		 DB	 1
  017ae	8b ff		 npad	 2
$LN331@gObjInvent@18:
  017b0	00 00 00 00	 DD	 $LN23@gObjInvent@18
  017b4	00 00 00 00	 DD	 $LN22@gObjInvent@18
  017b8	00 00 00 00	 DD	 $LN21@gObjInvent@18
$LN251@gObjInvent@18:
  017bc	00		 DB	 0
  017bd	02		 DB	 2
  017be	02		 DB	 2
  017bf	01		 DB	 1
  017c0	02		 DB	 2
  017c1	01		 DB	 1
  017c2	01		 DB	 1
  017c3	01		 DB	 1
  017c4	01		 DB	 1
  017c5	01		 DB	 1
?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z ENDP		; gObjInventoryMoveItem
_TEXT	ENDS
PUBLIC	??_C@_0DN@CJKEGDHI@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLTrad@ ; `string'
PUBLIC	_target$GSCopy$
PUBLIC	_source$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjTradeInventoryMove@@YAEPAUOBJECTSTRUCT@@EE@Z ; gObjTradeInventoryMove
;	COMDAT ??_C@_0DN@CJKEGDHI@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLTrad@
CONST	SEGMENT
??_C@_0DN@CJKEGDHI@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLTrad@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [Trade] (%s)(%s) Item(%s) Pos(%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjTradeInventoryMove@@YAEPAUOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_iheight$ = -44						; size = 4
_source$GSCopy$ = -40					; size = 1
tv309 = -36						; size = 4
_s_num$ = -32						; size = 4
_iwidth$ = -28						; size = 4
tv294 = -24						; size = 4
tv295 = -20						; size = 4
_target$GSCopy$ = -13					; size = 1
_itembuf$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_source$ = 12						; size = 1
_target$ = 16						; size = 1
?gObjTradeInventoryMove@@YAEPAUOBJECTSTRUCT@@EE@Z PROC	; gObjTradeInventoryMove, COMDAT

; 10090: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8a 45 0c	 mov	 al, BYTE PTR _source$[ebp]
  00013	8a 4d 10	 mov	 cl, BYTE PTR _target$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  0001a	56		 push	 esi
  0001b	57		 push	 edi

; 10091: 	int iwidth,iheight,s_num;
; 10092: 	BYTE itembuf[8];
; 10093: 	if(source > TRADE_BOX_SIZE)

  0001c	88 45 d8	 mov	 BYTE PTR _source$GSCopy$[ebp], al

; 10162: 			}
; 10163: 		}
; 10164: 
; 10165: 		gObjMakePreviewCharSet(lpObj->m_Index);

  0001f	88 4d f3	 mov	 BYTE PTR _target$GSCopy$[ebp], cl
  00022	3c 20		 cmp	 al, 32			; 00000020H
  00024	76 2c		 jbe	 SHORT $LN13@gObjTradeI@2

; 10094: 	{
; 10095: 		LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  00026	68 6f 27 00 00	 push	 10095			; 0000276fH
$LN17@gObjTradeI@2:

; 10100: 	{
; 10101: 		LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00035	6a 00		 push	 0
  00037	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0003c	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@gObjTradeI@2:

; 10116: 	{
; 10117: 		return -1;

  0003f	0c ff		 or	 al, 255			; 000000ffH

; 10167: 	}
; 10168: 
; 10169: 	return false;
; 10170: }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00047	33 cd		 xor	 ecx, ebp
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN13@gObjTradeI@2:

; 10096: 		return -1;
; 10097: 	}
; 10098: 
; 10099: 	if(target > MAIN_INVENTORY_SIZE)

  00052	80 f9 4c	 cmp	 cl, 76			; 0000004cH
  00055	76 07		 jbe	 SHORT $LN12@gObjTradeI@2

; 10100: 	{
; 10101: 		LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  00057	68 75 27 00 00	 push	 10101			; 00002775H

; 10102: 		return -1;

  0005c	eb cd		 jmp	 SHORT $LN17@gObjTradeI@2
$LN12@gObjTradeI@2:

; 10103: 	}
; 10104: 
; 10105: 	if(lpObj->TargetNumber < 0)

  0005e	66 83 bb d4 02
	00 00 00	 cmp	 WORD PTR [ebx+724], 0

; 10106: 	{
; 10107: 		return -1;

  00066	7c d7		 jl	 SHORT $LN8@gObjTradeI@2

; 10108: 	}
; 10109: 
; 10110: 	if(lpObj->Trade[source].IsItem() == 0)

  00068	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3252]
  0006e	0f b6 f8	 movzx	 edi, al
  00071	89 7d e8	 mov	 DWORD PTR tv294[ebp], edi
  00074	69 ff a8 00 00
	00		 imul	 edi, 168		; 000000a8H
  0007a	03 cf		 add	 ecx, edi
  0007c	89 7d ec	 mov	 DWORD PTR tv295[ebp], edi
  0007f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00084	85 c0		 test	 eax, eax

; 10111: 	{
; 10112: 		return -1;

  00086	74 b7		 je	 SHORT $LN8@gObjTradeI@2

; 10113: 	}
; 10114: 
; 10115: 	if(lpObj->m_IfState.use == 0 || lpObj->m_IfState.type != 1)

  00088	8b 83 84 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3204]
  0008e	a8 03		 test	 al, 3
  00090	74 ad		 je	 SHORT $LN8@gObjTradeI@2
  00092	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00097	83 f8 40	 cmp	 eax, 64			; 00000040H
  0009a	75 a3		 jne	 SHORT $LN8@gObjTradeI@2

; 10118: 	}
; 10119: 
; 10120: 	if(gObjInventoryInsertItemPos(lpObj->m_Index,lpObj->Trade[source],target,1) == 255)

  0009c	0f b6 45 f3	 movzx	 eax, BYTE PTR _target$GSCopy$[ebp]
  000a0	8b b3 b4 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3252]
  000a6	6a 01		 push	 1
  000a8	50		 push	 eax
  000a9	89 45 dc	 mov	 DWORD PTR tv309[ebp], eax
  000ac	8b 03		 mov	 eax, DWORD PTR [ebx]
  000ae	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  000b4	03 f7		 add	 esi, edi
  000b6	8b fc		 mov	 edi, esp
  000b8	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000bd	50		 push	 eax
  000be	f3 a5		 rep movsd
  000c0	e8 00 00 00 00	 call	 ?gObjInventoryInsertItemPos@@YAEHVCItem@@HH@Z ; gObjInventoryInsertItemPos
  000c5	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H
  000cb	3c ff		 cmp	 al, 255			; 000000ffH

; 10121: 	{
; 10122: 		return -1;

  000cd	0f 84 6c ff ff
	ff		 je	 $LN8@gObjTradeI@2

; 10123: 	}
; 10124: 
; 10125: 	s_num = 0;
; 10126: 	s_num = lpObj->Trade[source].m_Number;

  000d3	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3252]
  000d9	8b 7d ec	 mov	 edi, DWORD PTR tv295[ebp]
  000dc	8b 14 39	 mov	 edx, DWORD PTR [ecx+edi]
  000df	03 cf		 add	 ecx, edi

; 10127: 
; 10128: 	lpObj->Trade[source].GetSize((int &)iwidth,(int &)iheight);

  000e1	8d 45 d4	 lea	 eax, DWORD PTR _iheight$[ebp]
  000e4	89 55 e0	 mov	 DWORD PTR _s_num$[ebp], edx
  000e7	50		 push	 eax
  000e8	8d 55 e4	 lea	 edx, DWORD PTR _iwidth$[ebp]
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 10129: 
; 10130: 	gObjTradeItemBoxSet(lpObj->m_Index,source,iwidth,iheight,255);

  000f1	8b 45 d4	 mov	 eax, DWORD PTR _iheight$[ebp]
  000f4	8b 4d e4	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  000f7	8b 55 e8	 mov	 edx, DWORD PTR tv294[ebp]
  000fa	68 ff 00 00 00	 push	 255			; 000000ffH
  000ff	50		 push	 eax
  00100	8b 03		 mov	 eax, DWORD PTR [ebx]
  00102	51		 push	 ecx
  00103	52		 push	 edx
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ?gObjTradeItemBoxSet@@YAHHHHHE@Z ; gObjTradeItemBoxSet

; 10131: 	lpObj->Trade[source].Clear();

  0010a	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3252]
  00110	83 c4 14	 add	 esp, 20			; 00000014H
  00113	03 cf		 add	 ecx, edi
  00115	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 10132: 
; 10133: 	ItemByteConvert(itembuf,lpObj->Trade[source]);

  0011a	8b b3 b4 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3252]
  00120	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00126	03 f7		 add	 esi, edi
  00128	8b fc		 mov	 edi, esp
  0012a	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0012f	f3 a5		 rep movsd
  00131	8d 4d f4	 lea	 ecx, DWORD PTR _itembuf$[ebp]
  00134	51		 push	 ecx
  00135	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 10134: 
; 10135: 	GCTradeOtherDel(lpObj->TargetNumber,source);

  0013a	8b 55 d8	 mov	 edx, DWORD PTR _source$GSCopy$[ebp]
  0013d	0f bf 83 d4 02
	00 00		 movsx	 eax, WORD PTR [ebx+724]
  00144	52		 push	 edx
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?GCTradeOtherDel@@YAHHE@Z ; GCTradeOtherDel

; 10136: 
; 10137: 	if(gObjCheckSerial0ItemList(&lpObj->Trade[source]) != 0)

  0014b	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3252]
  00151	8b 75 ec	 mov	 esi, DWORD PTR tv295[ebp]
  00154	03 ce		 add	 ecx, esi
  00156	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  00162	83 c4 04	 add	 esp, 4
  00165	85 c0		 test	 eax, eax
  00167	74 57		 je	 SHORT $LN6@gObjTradeI@2

; 10138: 	{
; 10139: 		MsgOutput(lpObj->m_Index,lMsg.Get(3354));

  00169	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  0016e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00173	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00178	8b 13		 mov	 edx, DWORD PTR [ebx]
  0017a	50		 push	 eax
  0017b	52		 push	 edx
  0017c	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 10140: 		LogAdd(LOG_BLACK, "[ANTI-HACK][Serial 0 Item] [Trade] (%s)(%s) Item(%s) Pos(%d)",lpObj->AccountID,lpObj->Name,lpObj->Trade[source].GetName(),source);

  00181	8b 45 e8	 mov	 eax, DWORD PTR tv294[ebp]
  00184	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3252]
  0018a	83 c4 08	 add	 esp, 8
  0018d	50		 push	 eax
  0018e	03 ce		 add	 ecx, esi
  00190	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00195	50		 push	 eax
  00196	8d 4b 6f	 lea	 ecx, DWORD PTR [ebx+111]
  00199	51		 push	 ecx
  0019a	83 c3 64	 add	 ebx, 100		; 00000064H
  0019d	53		 push	 ebx
  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@CJKEGDHI@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLTrad@
  001a3	6a 00		 push	 0
  001a5	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001aa	83 c4 18	 add	 esp, 24			; 00000018H
  001ad	0c ff		 or	 al, 255			; 000000ffH

; 10167: 	}
; 10168: 
; 10169: 	return false;
; 10170: }

  001af	5f		 pop	 edi
  001b0	5e		 pop	 esi
  001b1	5b		 pop	 ebx
  001b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b5	33 cd		 xor	 ecx, ebp
  001b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c3		 ret	 0
$LN6@gObjTradeI@2:

; 10141: 		return -1;
; 10142: 	}
; 10143: 
; 10144: 	if(gObjInventorySearchSerialNumber(lpObj,s_num) == 0)

  001c0	8b 55 e0	 mov	 edx, DWORD PTR _s_num$[ebp]
  001c3	52		 push	 edx
  001c4	53		 push	 ebx
  001c5	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  001ca	83 c4 08	 add	 esp, 8
  001cd	85 c0		 test	 eax, eax

; 10145: 	{
; 10146: 		return -1;

  001cf	0f 84 6a fe ff
	ff		 je	 $LN8@gObjTradeI@2

; 10147: 	}
; 10148: 
; 10149: 	if(target < INVETORY_WEAR_SIZE)

  001d5	80 7d f3 0c	 cmp	 BYTE PTR _target$GSCopy$[ebp], 12 ; 0000000cH
  001d9	0f 83 c7 00 00
	00		 jae	 $LN4@gObjTradeI@2

; 10150: 	{
; 10151: 		if(lpObj->pInventory[target].IsItem() == 1)

  001df	8b 7d dc	 mov	 edi, DWORD PTR tv309[ebp]
  001e2	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  001e8	8b f7		 mov	 esi, edi
  001ea	69 f6 a8 00 00
	00		 imul	 esi, 168		; 000000a8H
  001f0	03 ce		 add	 ecx, esi
  001f2	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  001f7	83 f8 01	 cmp	 eax, 1
  001fa	0f 85 92 00 00
	00		 jne	 $LN1@gObjTradeI@2

; 10152: 		{
; 10153: 			if(lpObj->pInventory[target].m_Type == ITEMGET(13,10))

  00200	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3212]
  00206	b9 0a 1a 00 00	 mov	 ecx, 6666		; 00001a0aH
  0020b	66 39 4c 30 06	 cmp	 WORD PTR [eax+esi+6], cx
  00210	75 37		 jne	 SHORT $LN16@gObjTradeI@2

; 10154: 			{
; 10155: 				gObjUseSkill.SkillChangeUse(lpObj->m_Index);

  00212	8b 13		 mov	 edx, DWORD PTR [ebx]
  00214	52		 push	 edx
  00215	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0021a	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 10156: 				LogAdd(LOG_BLACK, lMsg.Get(534),lpObj->Name,lpObj->pInventory[target].m_Level);

  0021f	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3212]
  00225	0f bf 4c 30 08	 movsx	 ecx, WORD PTR [eax+esi+8]
  0022a	51		 push	 ecx
  0022b	8d 53 6f	 lea	 edx, DWORD PTR [ebx+111]
  0022e	52		 push	 edx
  0022f	68 16 02 00 00	 push	 534			; 00000216H
  00234	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00239	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0023e	50		 push	 eax
  0023f	6a 00		 push	 0
  00241	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00246	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@gObjTradeI@2:

; 10157: 			}
; 10158: 			if(lpObj->pInventory[target].m_Type == ITEMGET(13,39))

  00249	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3212]
  0024f	b9 27 1a 00 00	 mov	 ecx, 6695		; 00001a27H
  00254	66 39 4c 30 06	 cmp	 WORD PTR [eax+esi+6], cx
  00259	75 37		 jne	 SHORT $LN1@gObjTradeI@2

; 10159: 			{
; 10160: 				gObjUseSkill.SkillChangeUse(lpObj->m_Index);

  0025b	8b 13		 mov	 edx, DWORD PTR [ebx]
  0025d	52		 push	 edx
  0025e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00263	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 10161: 				LogAdd(LOG_BLACK, lMsg.Get(534),lpObj->Name,lpObj->pInventory[target].m_Level);

  00268	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3212]
  0026e	0f bf 4c 30 08	 movsx	 ecx, WORD PTR [eax+esi+8]
  00273	51		 push	 ecx
  00274	8d 53 6f	 lea	 edx, DWORD PTR [ebx+111]
  00277	52		 push	 edx
  00278	68 16 02 00 00	 push	 534			; 00000216H
  0027d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00282	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00287	50		 push	 eax
  00288	6a 00		 push	 0
  0028a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0028f	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@gObjTradeI@2:

; 10162: 			}
; 10163: 		}
; 10164: 
; 10165: 		gObjMakePreviewCharSet(lpObj->m_Index);

  00292	8b 03		 mov	 eax, DWORD PTR [ebx]
  00294	50		 push	 eax
  00295	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 10166: 		GCEquipmentChange(lpObj->m_Index,target);

  0029a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0029c	57		 push	 edi
  0029d	51		 push	 ecx
  0029e	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange
  002a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@gObjTradeI@2:

; 10167: 	}
; 10168: 
; 10169: 	return false;
; 10170: }

  002a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a9	5f		 pop	 edi
  002aa	5e		 pop	 esi
  002ab	33 cd		 xor	 ecx, ebp
  002ad	32 c0		 xor	 al, al
  002af	5b		 pop	 ebx
  002b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b5	8b e5		 mov	 esp, ebp
  002b7	5d		 pop	 ebp
  002b8	c3		 ret	 0
?gObjTradeInventoryMove@@YAEPAUOBJECTSTRUCT@@EE@Z ENDP	; gObjTradeInventoryMove
_TEXT	ENDS
PUBLIC	_source$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjInventoryTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z ; gObjInventoryTradeMove
; Function compile flags: /Ogtp
;	COMDAT ?gObjInventoryTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_iheight$ = -36						; size = 4
_blank$ = -32						; size = 4
tv481 = -28						; size = 4
_iwidth$ = -24						; size = 4
tv417 = -20						; size = 4
_source$GSCopy$ = -13					; size = 1
_itembuf$165443 = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_source$ = 12						; size = 1
_target$ = 16						; size = 1
?gObjInventoryTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z PROC	; gObjInventoryTradeMove, COMDAT

; 10173: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8a 45 0c	 mov	 al, BYTE PTR _source$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi

; 10291: 				}
; 10292: 			}
; 10293: 			gObjMakePreviewCharSet(lpObj->m_Index);

  00019	88 45 f3	 mov	 BYTE PTR _source$GSCopy$[ebp], al
  0001c	3c 4c		 cmp	 al, 76			; 0000004cH
  0001e	76 2c		 jbe	 SHORT $LN26@gObjInvent@19

; 10174: 	int h,w,iwidth,iheight,s_num,blank;
; 10175: 
; 10176: 
; 10177: 	if(source > MAIN_INVENTORY_SIZE)
; 10178: 	{
; 10179: 		LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  00020	68 c3 27 00 00	 push	 10179			; 000027c3H
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  0002f	6a 00		 push	 0
  00031	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00036	83 c4 10	 add	 esp, 16			; 00000010H
$LN22@gObjInvent@19:

; 10194: 	{
; 10195: 		return -1;

  00039	0c ff		 or	 al, 255			; 000000ffH

; 10295: 		}
; 10296: 		return true;
; 10297: 	}
; 10298: 	return -1;
; 10299: }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00041	33 cd		 xor	 ecx, ebp
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN26@gObjInvent@19:

; 10180: 		return -1;
; 10181: 	}
; 10182: 
; 10183: 	if(lpObj->pInventory[source].IsItem() == 0)

  0004c	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  00052	0f b6 f8	 movzx	 edi, al
  00055	89 7d ec	 mov	 DWORD PTR tv417[ebp], edi
  00058	69 ff a8 00 00
	00		 imul	 edi, 168		; 000000a8H
  0005e	03 cf		 add	 ecx, edi
  00060	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00065	85 c0		 test	 eax, eax

; 10184: 	{
; 10185: 		return -1;

  00067	74 d0		 je	 SHORT $LN22@gObjInvent@19

; 10186: 	}
; 10187: 
; 10188: 	if(lpObj->TargetNumber < 0)

  00069	66 83 bb d4 02
	00 00 00	 cmp	 WORD PTR [ebx+724], 0

; 10189: 	{
; 10190: 		return -1;

  00071	7c c6		 jl	 SHORT $LN22@gObjInvent@19

; 10191: 	}
; 10192: 
; 10193: 	if(lpObj->m_IfState.use == 0 || lpObj->m_IfState.type != 1)

  00073	8b 83 84 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3204]
  00079	a8 03		 test	 al, 3
  0007b	74 bc		 je	 SHORT $LN22@gObjInvent@19
  0007d	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00082	83 f8 40	 cmp	 eax, 64			; 00000040H
  00085	75 b2		 jne	 SHORT $LN22@gObjInvent@19

; 10196: 	}
; 10197: 
; 10198: 	if(lpObj->pInventory[source].m_Type == ITEMGET(13,20))

  00087	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  0008d	0f b7 54 39 06	 movzx	 edx, WORD PTR [ecx+edi+6]
  00092	03 cf		 add	 ecx, edi
  00094	b8 14 1a 00 00	 mov	 eax, 6676		; 00001a14H
  00099	66 3b d0	 cmp	 dx, ax
  0009c	75 0f		 jne	 SHORT $LN29@gObjInvent@19

; 10199: 	{
; 10200: 		if(lpObj->pInventory[source].m_Level == 0 ||
; 10201: 			lpObj->pInventory[source].m_Level == 1)

  0009e	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  000a2	66 85 c0	 test	 ax, ax
  000a5	74 92		 je	 SHORT $LN22@gObjInvent@19
  000a7	66 83 f8 01	 cmp	 ax, 1

; 10202: 		{
; 10203: 			return -1;

  000ab	74 8c		 je	 SHORT $LN22@gObjInvent@19
$LN29@gObjInvent@19:

; 10204: 		}
; 10205: 	}
; 10206: 
; 10207: 	if(lpObj->pInventory[source].m_Type == ITEMGET(13,20))

  000ad	b8 14 1a 00 00	 mov	 eax, 6676		; 00001a14H
  000b2	66 3b d0	 cmp	 dx, ax
  000b5	75 0b		 jne	 SHORT $LN17@gObjInvent@19

; 10208: 	{
; 10209: 		if(lpObj->pInventory[source].m_Level == 2)

  000b7	66 83 79 08 02	 cmp	 WORD PTR [ecx+8], 2

; 10210: 		{
; 10211: 			return -1;

  000bc	0f 84 77 ff ff
	ff		 je	 $LN22@gObjInvent@19
$LN17@gObjInvent@19:

; 10212: 		}
; 10213: 	}
; 10214: 
; 10215: 	if(lpObj->pInventory[source].m_Type == ITEMGET(14,11))

  000c2	b8 0b 1c 00 00	 mov	 eax, 7179		; 00001c0bH
  000c7	66 3b d0	 cmp	 dx, ax
  000ca	75 0b		 jne	 SHORT $LN15@gObjInvent@19

; 10216: 	{
; 10217: 		if(lpObj->pInventory[source].m_Level == 13)

  000cc	66 83 79 08 0d	 cmp	 WORD PTR [ecx+8], 13	; 0000000dH

; 10218: 		{
; 10219: 			return -1;

  000d1	0f 84 62 ff ff
	ff		 je	 $LN22@gObjInvent@19
$LN15@gObjInvent@19:

; 10220: 		}
; 10221: 	}
; 10222: 
; 10223: 	if(lpObj->pInventory[source].m_Type == ITEMGET(12,26))

  000d7	b8 1a 18 00 00	 mov	 eax, 6170		; 0000181aH
  000dc	66 3b d0	 cmp	 dx, ax
  000df	75 36		 jne	 SHORT $LN13@gObjInvent@19

; 10224: 	{
; 10225: 		if(lpObj->pInventory[source].m_Level == 1 ||
; 10226: 			lpObj->pInventory[source].m_Level == 2 ||
; 10227: 			lpObj->pInventory[source].m_Level == 3 ||
; 10228: 			lpObj->pInventory[source].m_Level == 4 ||
; 10229: 			lpObj->pInventory[source].m_Level == 5)

  000e1	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  000e5	66 83 f8 01	 cmp	 ax, 1
  000e9	0f 84 4a ff ff
	ff		 je	 $LN22@gObjInvent@19
  000ef	66 83 f8 02	 cmp	 ax, 2
  000f3	0f 84 40 ff ff
	ff		 je	 $LN22@gObjInvent@19
  000f9	66 83 f8 03	 cmp	 ax, 3
  000fd	0f 84 36 ff ff
	ff		 je	 $LN22@gObjInvent@19
  00103	66 83 f8 04	 cmp	 ax, 4
  00107	0f 84 2c ff ff
	ff		 je	 $LN22@gObjInvent@19
  0010d	66 83 f8 05	 cmp	 ax, 5

; 10230: 		{
; 10231: 			return -1;

  00111	0f 84 22 ff ff
	ff		 je	 $LN22@gObjInvent@19
$LN13@gObjInvent@19:

; 10232: 		}
; 10233: 	}
; 10234: 
; 10235: 	if(lpObj->pInventory[source].m_Type == ITEMGET(13,38))

  00117	b8 26 1a 00 00	 mov	 eax, 6694		; 00001a26H
  0011c	66 3b d0	 cmp	 dx, ax

; 10236: 	{
; 10237: 		return -1;

  0011f	0f 84 14 ff ff
	ff		 je	 $LN22@gObjInvent@19

; 10238: 	}
; 10239: 
; 10240: 	if(lpObj->pInventory[source].m_Type == ITEMGET(13,39))

  00125	b8 27 1a 00 00	 mov	 eax, 6695		; 00001a27H
  0012a	66 3b d0	 cmp	 dx, ax

; 10241: 	{
; 10242: 		return -1;

  0012d	0f 84 06 ff ff
	ff		 je	 $LN22@gObjInvent@19

; 10243: 	}
; 10244: 
; 10245: 	lpObj->pInventory[source].GetSize((int &)iwidth,(int &)iheight);

  00133	8d 55 dc	 lea	 edx, DWORD PTR _iheight$[ebp]
  00136	52		 push	 edx
  00137	8d 45 e8	 lea	 eax, DWORD PTR _iwidth$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 10246: 	s_num = lpObj->pInventory[source].GetNumber();

  00140	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  00146	03 cf		 add	 ecx, edi
  00148	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 10247: 
; 10248: 	if(gObjCheckSerial0ItemList(&lpObj->pInventory[source]) != 0)

  0014d	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  00153	03 cf		 add	 ecx, edi
  00155	51		 push	 ecx
  00156	8b f0		 mov	 esi, eax
  00158	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  0015d	83 c4 04	 add	 esp, 4
  00160	85 c0		 test	 eax, eax
  00162	74 57		 je	 SHORT $LN9@gObjInvent@19

; 10249: 	{
; 10250: 		MsgOutput(lpObj->m_Index,lMsg.Get(3354));

  00164	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  00169	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0016e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00173	8b 13		 mov	 edx, DWORD PTR [ebx]
  00175	50		 push	 eax
  00176	52		 push	 edx
  00177	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 10251: 		LogAdd(LOG_BLACK, "[ANTI-HACK][Serial 0 Item] [Trade] (%s)(%s) Item(%s) Pos(%d)",lpObj->AccountID,lpObj->Name,lpObj->pInventory[source].GetName(),source);

  0017c	8b 45 ec	 mov	 eax, DWORD PTR tv417[ebp]
  0017f	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  00185	83 c4 08	 add	 esp, 8
  00188	50		 push	 eax
  00189	03 cf		 add	 ecx, edi
  0018b	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00190	50		 push	 eax
  00191	8d 4b 6f	 lea	 ecx, DWORD PTR [ebx+111]
  00194	51		 push	 ecx
  00195	83 c3 64	 add	 ebx, 100		; 00000064H
  00198	53		 push	 ebx
  00199	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@CJKEGDHI@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLTrad@
  0019e	6a 00		 push	 0
  001a0	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001a5	83 c4 18	 add	 esp, 24			; 00000018H
  001a8	0c ff		 or	 al, 255			; 000000ffH

; 10295: 		}
; 10296: 		return true;
; 10297: 	}
; 10298: 	return -1;
; 10299: }

  001aa	5f		 pop	 edi
  001ab	5e		 pop	 esi
  001ac	5b		 pop	 ebx
  001ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b0	33 cd		 xor	 ecx, ebp
  001b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b7	8b e5		 mov	 esp, ebp
  001b9	5d		 pop	 ebp
  001ba	c3		 ret	 0
$LN9@gObjInvent@19:

; 10252: 		return -1;
; 10253: 	}
; 10254: 
; 10255: 	if(gObjInventorySearchSerialNumber(lpObj,s_num) == 0)

  001bb	56		 push	 esi
  001bc	53		 push	 ebx
  001bd	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  001c2	83 c4 08	 add	 esp, 8
  001c5	85 c0		 test	 eax, eax

; 10256: 	{
; 10257: 		return -1;

  001c7	0f 84 6c fe ff
	ff		 je	 $LN22@gObjInvent@19

; 10258: 	}
; 10259: 
; 10260: 	w = target % 8;

  001cd	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  001d1	8b c8		 mov	 ecx, eax
  001d3	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H
  001d9	79 05		 jns	 SHORT $LN30@gObjInvent@19
  001db	49		 dec	 ecx
  001dc	83 c9 f8	 or	 ecx, -8			; fffffff8H
  001df	41		 inc	 ecx
$LN30@gObjInvent@19:

; 10261: 	h = target / 8;
; 10262: 
; 10263: 	if(ExtentCheck(w,h,8,4) == 0)

  001e0	6a 04		 push	 4
  001e2	c1 e8 03	 shr	 eax, 3
  001e5	8b d0		 mov	 edx, eax
  001e7	6a 08		 push	 8
  001e9	52		 push	 edx
  001ea	51		 push	 ecx
  001eb	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  001f0	83 c4 10	 add	 esp, 16			; 00000010H
  001f3	85 c0		 test	 eax, eax

; 10264: 	{
; 10265: 		return -1;

  001f5	0f 84 3e fe ff
	ff		 je	 $LN22@gObjInvent@19

; 10266: 	}
; 10267: 
; 10268: 	if(*(BYTE*)(lpObj->TradeMap + h * 8 + w) == 255)

  001fb	8b 83 b8 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3256]
  00201	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
  00204	80 3c 08 ff	 cmp	 BYTE PTR [eax+ecx], 255	; 000000ffH
  00208	0f 85 2b fe ff
	ff		 jne	 $LN22@gObjInvent@19

; 10269: 	{
; 10270: 	BYTE itembuf[8];
; 10271: 		blank = gObjTradeRectCheck(lpObj->m_Index,w,h,iwidth,iheight);

  0020e	8b 45 dc	 mov	 eax, DWORD PTR _iheight$[ebp]
  00211	50		 push	 eax
  00212	8b 45 e8	 mov	 eax, DWORD PTR _iwidth$[ebp]
  00215	50		 push	 eax
  00216	52		 push	 edx
  00217	51		 push	 ecx
  00218	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0021a	51		 push	 ecx
  0021b	e8 00 00 00 00	 call	 ?gObjTradeRectCheck@@YAEHHHHH@Z ; gObjTradeRectCheck
  00220	0f b6 c0	 movzx	 eax, al
  00223	83 c4 14	 add	 esp, 20			; 00000014H
  00226	89 45 e0	 mov	 DWORD PTR _blank$[ebp], eax

; 10272: 
; 10273: 		if(blank == 255)

  00229	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH

; 10274: 		{
; 10275: 			return -1;

  0022e	0f 84 05 fe ff
	ff		 je	 $LN22@gObjInvent@19

; 10276: 		}
; 10277: 
; 10278: 		lpObj->Trade[blank] = lpObj->pInventory[source];

  00234	8b b3 8c 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3212]
  0023a	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H

; 10279: 		gObjInventoryDeleteItem(lpObj->m_Index,source);

  00240	8b 55 ec	 mov	 edx, DWORD PTR tv417[ebp]
  00243	03 f7		 add	 esi, edi
  00245	8b bb b4 0c 00
	00		 mov	 edi, DWORD PTR [ebx+3252]
  0024b	03 f8		 add	 edi, eax
  0024d	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00252	89 45 e4	 mov	 DWORD PTR tv481[ebp], eax
  00255	f3 a5		 rep movsd
  00257	8b 03		 mov	 eax, DWORD PTR [ebx]
  00259	52		 push	 edx
  0025a	50		 push	 eax
  0025b	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 10280: 		gObjTradeItemBoxSet(lpObj->m_Index,blank,iwidth,iheight,lpObj->Trade[blank].m_Type);

  00260	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3252]
  00266	8b 7d e4	 mov	 edi, DWORD PTR tv481[ebp]
  00269	0f b6 54 0f 06	 movzx	 edx, BYTE PTR [edi+ecx+6]
  0026e	8b 45 dc	 mov	 eax, DWORD PTR _iheight$[ebp]
  00271	8b 4d e8	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  00274	52		 push	 edx
  00275	8b 55 e0	 mov	 edx, DWORD PTR _blank$[ebp]
  00278	50		 push	 eax
  00279	8b 03		 mov	 eax, DWORD PTR [ebx]
  0027b	51		 push	 ecx
  0027c	52		 push	 edx
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 ?gObjTradeItemBoxSet@@YAHHHHHE@Z ; gObjTradeItemBoxSet

; 10281: 		ItemByteConvert(itembuf,lpObj->Trade[blank]);

  00283	8b b3 b4 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3252]
  00289	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  0028f	03 f7		 add	 esi, edi
  00291	8b fc		 mov	 edi, esp
  00293	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00298	f3 a5		 rep movsd
  0029a	8d 4d f4	 lea	 ecx, DWORD PTR _itembuf$165443[ebp]
  0029d	51		 push	 ecx
  0029e	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 10282: 		GCTradeOtherAdd(lpObj->TargetNumber,blank,itembuf);

  002a3	8b 45 e0	 mov	 eax, DWORD PTR _blank$[ebp]
  002a6	0f bf 8b d4 02
	00 00		 movsx	 ecx, WORD PTR [ebx+724]
  002ad	8d 55 f4	 lea	 edx, DWORD PTR _itembuf$165443[ebp]
  002b0	52		 push	 edx
  002b1	50		 push	 eax
  002b2	51		 push	 ecx
  002b3	e8 00 00 00 00	 call	 ?GCTradeOtherAdd@@YAHHEPAE@Z ; GCTradeOtherAdd

; 10283: 
; 10284: 		if(source < INVETORY_WEAR_SIZE)

  002b8	8a 45 f3	 mov	 al, BYTE PTR _source$GSCopy$[ebp]
  002bb	81 c4 b8 00 00
	00		 add	 esp, 184		; 000000b8H
  002c1	3c 0c		 cmp	 al, 12			; 0000000cH
  002c3	73 41		 jae	 SHORT $LN4@gObjInvent@19

; 10285: 		{
; 10286: 			if(source == 10 || source == 11)

  002c5	3c 0a		 cmp	 al, 10			; 0000000aH
  002c7	74 04		 je	 SHORT $LN2@gObjInvent@19
  002c9	3c 0b		 cmp	 al, 11			; 0000000bH
  002cb	75 22		 jne	 SHORT $LN1@gObjInvent@19
$LN2@gObjInvent@19:

; 10287: 			{
; 10288: 				if(lpObj->Trade[blank].m_Type == ITEMGET(13,10))

  002cd	8b 93 b4 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3252]
  002d3	8b 4d e4	 mov	 ecx, DWORD PTR tv481[ebp]
  002d6	b8 0a 1a 00 00	 mov	 eax, 6666		; 00001a0aH
  002db	66 39 44 11 06	 cmp	 WORD PTR [ecx+edx+6], ax
  002e0	75 0d		 jne	 SHORT $LN1@gObjInvent@19

; 10289: 				{
; 10290: 					gObjUseSkill.SkillChangeUse(lpObj->m_Index);

  002e2	8b 13		 mov	 edx, DWORD PTR [ebx]
  002e4	52		 push	 edx
  002e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  002ea	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN1@gObjInvent@19:

; 10291: 				}
; 10292: 			}
; 10293: 			gObjMakePreviewCharSet(lpObj->m_Index);

  002ef	8b 03		 mov	 eax, DWORD PTR [ebx]
  002f1	50		 push	 eax
  002f2	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 10294: 			GCEquipmentChange(lpObj->m_Index,source);

  002f7	8b 4d ec	 mov	 ecx, DWORD PTR tv417[ebp]
  002fa	8b 13		 mov	 edx, DWORD PTR [ebx]
  002fc	51		 push	 ecx
  002fd	52		 push	 edx
  002fe	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange
  00303	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@gObjInvent@19:

; 10295: 		}
; 10296: 		return true;
; 10297: 	}
; 10298: 	return -1;
; 10299: }

  00306	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00309	5f		 pop	 edi
  0030a	5e		 pop	 esi
  0030b	33 cd		 xor	 ecx, ebp
  0030d	b0 01		 mov	 al, 1
  0030f	5b		 pop	 ebx
  00310	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00315	8b e5		 mov	 esp, ebp
  00317	5d		 pop	 ebp
  00318	c3		 ret	 0
?gObjInventoryTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z ENDP	; gObjInventoryTradeMove
_TEXT	ENDS
PUBLIC	??_C@_0BK@CICIFNII@error?5?3?5index?5error?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	?gObjTradeCancel@@YAXH@Z			; gObjTradeCancel
EXTRN	?GCGuildViewportNowPaint@@YAXHPADPAEH@Z:PROC	; GCGuildViewportNowPaint
EXTRN	?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z:PROC ; GCMagicListMultiSend
EXTRN	?GCEquipmentSend@@YAXH@Z:PROC			; GCEquipmentSend
EXTRN	?GCItemListSend@@YAXH@Z:PROC			; GCItemListSend
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
;	COMDAT ??_C@_0BK@CICIFNII@error?5?3?5index?5error?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BK@CICIFNII@error?5?3?5index?5error?5?$CFs?5?$CFd?$AA@ DB 'error :'
	DB	' index error %s %d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjTradeCancel@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjTradeCancel@@YAXH@Z PROC				; gObjTradeCancel, COMDAT

; 10378: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 10379: 	if(OBJMAX_RANGE(aIndex) == 0)

  00004	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	78 0f		 js	 SHORT $LN11@gObjTradeC
  0000b	33 c0		 xor	 eax, eax
  0000d	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 1c		 jne	 SHORT $LN6@gObjTradeC
$LN11@gObjTradeC:

; 10380: 	{
; 10381: 		LogAdd(LOG_BLACK, "error : index error %s %d",__FILE__,__LINE__);

  0001a	68 8d 28 00 00	 push	 10381			; 0000288dH
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CICIFNII@error?5?3?5index?5error?5?$CFs?5?$CFd?$AA@
  00029	6a 00		 push	 0
  0002b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	5f		 pop	 edi

; 10416: }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN6@gObjTradeC:
  00036	56		 push	 esi

; 10382: 		return;
; 10383: 	}
; 10384: 	if(gObj[aIndex].Type != OBJ_USER || gObj[aIndex].Connected != PLAYER_PLAYING)

  00037	8b f7		 mov	 esi, edi
  00039	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0003f	66 83 be 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+96], 1
  00047	0f 85 00 01 00
	00		 jne	 $LN4@gObjTradeC
  0004d	80 be 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+4], 3
  00054	0f 85 f3 00 00
	00		 jne	 $LN4@gObjTradeC

; 10387: 		return;
; 10388: 	}
; 10389: 	if(gObj[aIndex].m_IfState.use != 1)

  0005a	8b 86 84 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3204]
  00060	8b c8		 mov	 ecx, eax
  00062	80 e1 03	 and	 cl, 3
  00065	80 f9 01	 cmp	 cl, 1
  00068	74 18		 je	 SHORT $LN3@gObjTradeC

; 10390: 	{
; 10391: 		LogAdd(LOG_BLACK, lMsg.Get(536),gObj[aIndex].AccountID,gObj[aIndex].Name);

  0006a	8d 96 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00070	52		 push	 edx
  00071	8d 86 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  00077	50		 push	 eax
  00078	68 18 02 00 00	 push	 536			; 00000218H

; 10392: 		return;

  0007d	e9 de 00 00 00	 jmp	 $LN13@gObjTradeC
$LN3@gObjTradeC:

; 10393: 	}
; 10394: 	if(gObj[aIndex].m_IfState.type != 1)

  00082	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00087	83 f8 40	 cmp	 eax, 64			; 00000040H
  0008a	74 18		 je	 SHORT $LN2@gObjTradeC

; 10395: 	{
; 10396: 		LogAdd(LOG_BLACK, lMsg.Get(537),gObj[aIndex].AccountID,gObj[aIndex].Name);

  0008c	8d 8e 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00092	51		 push	 ecx
  00093	8d 96 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  00099	52		 push	 edx
  0009a	68 19 02 00 00	 push	 537			; 00000219H

; 10397: 		return;

  0009f	e9 bc 00 00 00	 jmp	 $LN13@gObjTradeC
$LN2@gObjTradeC:
  000a4	53		 push	 ebx

; 10398: 	}
; 10399: 	gObjInventoryRollback(aIndex);

  000a5	57		 push	 edi
  000a6	e8 00 00 00 00	 call	 ?gObjInventoryRollback@@YAHH@Z ; gObjInventoryRollback

; 10400: 	gObj[aIndex].TargetNumber = -1;
; 10401: 	gObj[aIndex].m_IfState.use = 0;

  000ab	83 a6 84 0c 00
	00 fc		 and	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3204], -4 ; fffffffcH
  000b2	83 c8 ff	 or	 eax, -1

; 10402: 	gObjCharTradeClear(&gObj[aIndex]);

  000b5	8d 9e 00 00 00
	00		 lea	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000bb	53		 push	 ebx
  000bc	66 89 86 d4 02
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+724], ax
  000c3	e8 00 00 00 00	 call	 ?gObjCharTradeClear@@YAXPAUOBJECTSTRUCT@@@Z ; gObjCharTradeClear

; 10403: 	GCMoneySend(aIndex,gObj[aIndex].Money);

  000c8	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176]
  000ce	51		 push	 ecx
  000cf	57		 push	 edi
  000d0	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 10404: 	GCItemListSend(aIndex);

  000d5	57		 push	 edi
  000d6	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend

; 10405: 	GCEquipmentSend(aIndex);

  000db	57		 push	 edi
  000dc	e8 00 00 00 00	 call	 ?GCEquipmentSend@@YAXH@Z ; GCEquipmentSend

; 10406: 	GCMagicListMultiSend(&gObj[aIndex],0);

  000e1	6a 00		 push	 0
  000e3	53		 push	 ebx
  000e4	e8 00 00 00 00	 call	 ?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicListMultiSend
  000e9	83 c4 20	 add	 esp, 32			; 00000020H

; 10407: 	gObjUseSkill.SkillChangeUse(aIndex);

  000ec	57		 push	 edi
  000ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000f2	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 10408: 
; 10409: 	if(gObj[aIndex].GuildNumber > 0)

  000f7	83 be b0 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+688], 0
  000fe	7e 20		 jle	 SHORT $LN1@gObjTradeC

; 10410: 	{
; 10411: 		GCGuildViewportNowPaint(aIndex,gObj[aIndex].GuildName,0,0);

  00100	6a 00		 push	 0
  00102	6a 00		 push	 0
  00104	8d 96 b8 02 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+696]
  0010a	52		 push	 edx
  0010b	57		 push	 edi
  0010c	e8 00 00 00 00	 call	 ?GCGuildViewportNowPaint@@YAXHPADPAEH@Z ; GCGuildViewportNowPaint

; 10412: 		gObjNotifyUpdateUnionV1(&gObj[aIndex]);

  00111	53		 push	 ebx
  00112	e8 00 00 00 00	 call	 ?gObjNotifyUpdateUnionV1@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNotifyUpdateUnionV1

; 10413: 		gObjNotifyUpdateUnionV2(&gObj[aIndex]);

  00117	53		 push	 ebx
  00118	e8 00 00 00 00	 call	 ?gObjNotifyUpdateUnionV2@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNotifyUpdateUnionV2
  0011d	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@gObjTradeC:

; 10414: 	}
; 10415: 	LogAdd(LOG_BLACK, lMsg.Get(514),gObj[aIndex].AccountID,gObj[aIndex].Name);

  00120	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00126	50		 push	 eax
  00127	8d 8e 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  0012d	51		 push	 ecx
  0012e	68 02 02 00 00	 push	 514			; 00000202H
  00133	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00138	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0013d	50		 push	 eax
  0013e	6a 00		 push	 0
  00140	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00145	83 c4 10	 add	 esp, 16			; 00000010H
  00148	5b		 pop	 ebx
  00149	5e		 pop	 esi
  0014a	5f		 pop	 edi

; 10416: }

  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
$LN4@gObjTradeC:

; 10385: 	{
; 10386: 		LogAdd(LOG_BLACK, lMsg.Get(535),gObj[aIndex].AccountID,gObj[aIndex].Name);

  0014d	8d 96 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00153	52		 push	 edx
  00154	8d 86 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  0015a	50		 push	 eax
  0015b	68 17 02 00 00	 push	 535			; 00000217H
$LN13@gObjTradeC:
  00160	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00165	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0016a	50		 push	 eax
  0016b	6a 00		 push	 0
  0016d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00172	83 c4 10	 add	 esp, 16			; 00000010H
  00175	5e		 pop	 esi
  00176	5f		 pop	 edi

; 10416: }

  00177	5d		 pop	 ebp
  00178	c3		 ret	 0
?gObjTradeCancel@@YAXH@Z ENDP				; gObjTradeCancel
_TEXT	ENDS
PUBLIC	??_C@_0BK@ELKLKHDB@error?5?3?5?$MA?L?$LA?G?5?E?$KL?$MA?O?$LD?$KK?$LE?B?$MA?O?$CB?$CB?$AA@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	??_C@_04BGCMBJDA@Item?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?TradeitemInventoryPut@@YAHH@Z			; TradeitemInventoryPut
;	COMDAT ??_C@_0BK@ELKLKHDB@error?5?3?5?$MA?L?$LA?G?5?E?$KL?$MA?O?$LD?$KK?$LE?B?$MA?O?$CB?$CB?$AA@
CONST	SEGMENT
??_C@_0BK@ELKLKHDB@error?5?3?5?$MA?L?$LA?G?5?E?$KL?$MA?O?$LD?$KK?$LE?B?$MA?O?$CB?$CB?$AA@ DB 'e'
	DB	'rror : ', 0c0H, 0ccH, 0b0H, 0c7H, ' ', 0c5H, 0abH, 0c0H, 0cfH
	DB	0b3H, 0aaH, 0b4H, 0c2H, 0c0H, 0cfH, '!!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGCMBJDA@Item?$AA@
CONST	SEGMENT
??_C@_04BGCMBJDA@Item?$AA@ DB 'Item', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?TradeitemInventoryPut@@YAHH@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -76					; size = 4
tv320 = -72						; size = 4
tv434 = -68						; size = 4
_szItemName$ = -64					; size = 50
_ExOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?TradeitemInventoryPut@@YAHH@Z PROC			; TradeitemInventoryPut, COMDAT

; 10528: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 10529: 	int number;
; 10530: 	BYTE insert;
; 10531: 	char szItemName[50] = "Item";

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_04BGCMBJDA@Item?$AA@
  00015	8a 0d 04 00 00
	00		 mov	 cl, BYTE PTR ??_C@_04BGCMBJDA@Item?$AA@+4
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00020	57		 push	 edi
  00021	6a 2d		 push	 45			; 0000002dH
  00023	8d 55 c5	 lea	 edx, DWORD PTR _szItemName$[ebp+5]
  00026	6a 00		 push	 0
  00028	52		 push	 edx

; 10532: 	BYTE ExOption[8];
; 10533: 
; 10534: 	number = gObj[aIndex].TargetNumber;

  00029	89 75 b4	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0002c	89 45 c0	 mov	 DWORD PTR _szItemName$[ebp], eax
  0002f	88 4d c4	 mov	 BYTE PTR _szItemName$[ebp+4], cl
  00032	e8 00 00 00 00	 call	 _memset
  00037	8b c6		 mov	 eax, esi
  00039	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0003f	0f bf 98 d4 02
	00 00		 movsx	 ebx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+724]

; 10535: 
; 10536: 	if(gObjIsConnected(number) == 0)

  00046	53		 push	 ebx
  00047	89 45 b8	 mov	 DWORD PTR tv320[ebp], eax
  0004a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
  00052	85 c0		 test	 eax, eax

; 10537: 	{
; 10538: 		return false;

  00054	0f 84 8a 01 00
	00		 je	 $LN14@TradeitemI

; 10539: 	}
; 10540: 
; 10541: 	for(int n = 0; n < TRADE_BOX_SIZE; n++)

  0005a	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  00060	33 ff		 xor	 edi, edi
  00062	89 7d bc	 mov	 DWORD PTR tv434[ebp], edi
  00065	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL6@TradeitemI:

; 10542: 	{
; 10543: 		if(gObj[number].Trade[n].IsItem() == 1)

  00070	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3252]
  00076	03 cf		 add	 ecx, edi
  00078	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0007d	83 f8 01	 cmp	 eax, 1
  00080	0f 85 24 01 00
	00		 jne	 $LN5@TradeitemI

; 10544: 		{
; 10545: 			insert = gObjInventoryInsertItem(aIndex,gObj[number].Trade[n]);

  00086	8b b3 b4 0c 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3252]
  0008c	8b 45 b4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0008f	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00095	03 f7		 add	 esi, edi
  00097	8b fc		 mov	 edi, esp
  00099	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0009e	50		 push	 eax
  0009f	f3 a5		 rep movsd
  000a1	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem
  000a6	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 10546: 			if(insert != 255)

  000ac	3c ff		 cmp	 al, 255			; 000000ffH
  000ae	0f 84 21 01 00
	00		 je	 $LN2@TradeitemI

; 10547: 			{
; 10548: 				strcpy(szItemName,gObj[number].Trade[n].GetName());

  000b4	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3252]
  000ba	8b 75 bc	 mov	 esi, DWORD PTR tv434[ebp]
  000bd	03 ce		 add	 ecx, esi
  000bf	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000c4	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$[ebp]
  000c7	2b d0		 sub	 edx, eax
  000c9	8d a4 24 00 00
	00 00		 npad	 7
$LL10@TradeitemI:
  000d0	8a 08		 mov	 cl, BYTE PTR [eax]
  000d2	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000d5	40		 inc	 eax
  000d6	84 c9		 test	 cl, cl
  000d8	75 f6		 jne	 SHORT $LL10@TradeitemI

; 10549: 				ItemIsBufExOption(ExOption,&gObj[number].Trade[n]);

  000da	8b 8b b4 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3252]
  000e0	03 ce		 add	 ecx, esi
  000e2	51		 push	 ecx
  000e3	8d 55 f4	 lea	 edx, DWORD PTR _ExOption$[ebp]
  000e6	52		 push	 edx
  000e7	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 10550: 				LogAdd(LOG_BLACK, lMsg.Get(538),
; 10551: 					gObj[number].AccountID,gObj[number].Name,gObj[number].MapNumber,gObj[number].X,gObj[number].Y,
; 10552: 					gObj[aIndex].AccountID,gObj[aIndex].Name,gObj[aIndex].MapNumber,gObj[aIndex].X,gObj[aIndex].Y,
; 10553: 					szItemName,gObj[number].Trade[n].m_Number,gObj[number].Trade[n].m_Level,gObj[number].Trade[n].m_Option1,gObj[number].Trade[n].m_Option2,gObj[number].Trade[n].m_Option3,
; 10554: 					ExOption[0],ExOption[1],ExOption[2],ExOption[3],ExOption[4],ExOption[5],ExOption[6],gObj[number].Trade[n].m_SetOption);

  000ec	8b 83 b4 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3252]
  000f2	0f b6 8c 30 92
	00 00 00	 movzx	 ecx, BYTE PTR [eax+esi+146]
  000fa	0f b6 55 fa	 movzx	 edx, BYTE PTR _ExOption$[ebp+6]
  000fe	83 c4 08	 add	 esp, 8
  00101	51		 push	 ecx
  00102	0f b6 4d f9	 movzx	 ecx, BYTE PTR _ExOption$[ebp+5]
  00106	52		 push	 edx
  00107	0f b6 55 f8	 movzx	 edx, BYTE PTR _ExOption$[ebp+4]
  0010b	51		 push	 ecx
  0010c	0f b6 4d f7	 movzx	 ecx, BYTE PTR _ExOption$[ebp+3]
  00110	52		 push	 edx
  00111	0f b6 55 f6	 movzx	 edx, BYTE PTR _ExOption$[ebp+2]
  00115	51		 push	 ecx
  00116	0f b6 4d f5	 movzx	 ecx, BYTE PTR _ExOption$[ebp+1]
  0011a	03 c6		 add	 eax, esi
  0011c	52		 push	 edx
  0011d	0f b6 55 f4	 movzx	 edx, BYTE PTR _ExOption$[ebp]
  00121	51		 push	 ecx
  00122	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  00126	52		 push	 edx
  00127	0f b6 50 79	 movzx	 edx, BYTE PTR [eax+121]
  0012b	51		 push	 ecx
  0012c	0f b6 48 78	 movzx	 ecx, BYTE PTR [eax+120]
  00130	52		 push	 edx
  00131	0f bf 50 08	 movsx	 edx, WORD PTR [eax+8]
  00135	8b 00		 mov	 eax, DWORD PTR [eax]
  00137	51		 push	 ecx
  00138	52		 push	 edx
  00139	50		 push	 eax
  0013a	8b 45 b8	 mov	 eax, DWORD PTR tv320[ebp]
  0013d	0f bf 90 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  00144	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$[ebp]
  00147	51		 push	 ecx
  00148	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  0014f	52		 push	 edx
  00150	0f b6 90 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00157	51		 push	 ecx
  00158	52		 push	 edx
  00159	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  0015f	51		 push	 ecx
  00160	0f bf 8b 04 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+260]
  00167	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  0016d	0f bf 83 06 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+262]
  00174	52		 push	 edx
  00175	0f b6 93 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+265]
  0017c	50		 push	 eax
  0017d	51		 push	 ecx
  0017e	52		 push	 edx
  0017f	8d 83 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+111]
  00185	50		 push	 eax
  00186	8d 8b 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+100]
  0018c	51		 push	 ecx
  0018d	68 1a 02 00 00	 push	 538			; 0000021aH
  00192	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00197	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0019c	50		 push	 eax
  0019d	6a 00		 push	 0
  0019f	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001a4	8b 7d bc	 mov	 edi, DWORD PTR tv434[ebp]
  001a7	83 c4 68	 add	 esp, 104		; 00000068H
$LN5@TradeitemI:

; 10539: 	}
; 10540: 
; 10541: 	for(int n = 0; n < TRADE_BOX_SIZE; n++)

  001aa	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  001b0	89 7d bc	 mov	 DWORD PTR tv434[ebp], edi
  001b3	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  001b9	0f 8c b1 fe ff
	ff		 jl	 $LL6@TradeitemI

; 10560: 				return false;
; 10561: 			}
; 10562: 		}
; 10563: 	}
; 10564: 	return true;

  001bf	b8 01 00 00 00	 mov	 eax, 1

; 10565: }

  001c4	5f		 pop	 edi
  001c5	5e		 pop	 esi
  001c6	5b		 pop	 ebx
  001c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ca	33 cd		 xor	 ecx, ebp
  001cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d1	8b e5		 mov	 esp, ebp
  001d3	5d		 pop	 ebp
  001d4	c3		 ret	 0
$LN2@TradeitemI:

; 10555: 
; 10556: 			}
; 10557: 			else
; 10558: 			{
; 10559: 				LogAdd(LOG_BLACK, "error :  !!");

  001d5	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@ELKLKHDB@error?5?3?5?$MA?L?$LA?G?5?E?$KL?$MA?O?$LD?$KK?$LE?B?$MA?O?$CB?$CB?$AA@
  001da	6a 00		 push	 0
  001dc	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001e1	83 c4 08	 add	 esp, 8
$LN14@TradeitemI:

; 10565: }

  001e4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	33 cd		 xor	 ecx, ebp
  001eb	33 c0		 xor	 eax, eax
  001ed	5b		 pop	 ebx
  001ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c3		 ret	 0
?TradeitemInventoryPut@@YAHH@Z ENDP			; TradeitemInventoryPut
_TEXT	ENDS
PUBLIC	??_C@_0BI@CKIBLNIL@Item?5Bloqueado?5no?5Trade?$AA@ ; `string'
PUBLIC	?gObjTradeOkButton@@YAXH@Z			; gObjTradeOkButton
EXTRN	?MsgUser@@YAXHHPADZZ:PROC			; MsgUser
EXTRN	?IsEnableToTrade@CItemBlock@@QAE_NPAUOBJECTSTRUCT@@@Z:PROC ; CItemBlock::IsEnableToTrade
EXTRN	?gItemBlock@@3VCItemBlock@@A:BYTE		; gItemBlock
EXTRN	?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z:PROC ; GJSetCharacterInfo
;	COMDAT ??_C@_0BI@CKIBLNIL@Item?5Bloqueado?5no?5Trade?$AA@
CONST	SEGMENT
??_C@_0BI@CKIBLNIL@Item?5Bloqueado?5no?5Trade?$AA@ DB 'Item Bloqueado no '
	DB	'Trade', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjTradeOkButton@@YAXH@Z
_TEXT	SEGMENT
tv433 = -8						; size = 4
_result$ = -1						; size = 1
_aIndex$ = 8						; size = 4
?gObjTradeOkButton@@YAXH@Z PROC				; gObjTradeOkButton, COMDAT

; 10568: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10569: 	BYTE result = 1;
; 10570: 	int number = gObj[aIndex].TargetNumber;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00013	0f bf 9e d4 02
	00 00		 movsx	 ebx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+724]

; 10571: 
; 10572: 	if(number < 0)

  0001a	85 db		 test	 ebx, ebx
  0001c	0f 88 f2 02 00
	00		 js	 $LN15@gObjTradeO

; 10573: 	{
; 10574: 		return;
; 10575: 	}
; 10576: 
; 10577: 	if(gObjIsConnected(number) == 0)

  00022	53		 push	 ebx
  00023	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00028	83 c4 04	 add	 esp, 4
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 e1 02 00
	00		 je	 $LN15@gObjTradeO

; 10578: 	{
; 10579: 		return;
; 10580: 	}
; 10581: 
; 10582: 	if(gObj[number].TargetNumber != aIndex)

  00033	57		 push	 edi
  00034	8b fb		 mov	 edi, ebx
  00036	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0003c	0f bf 87 d4 02
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+724]
  00043	3b c1		 cmp	 eax, ecx
  00045	74 31		 je	 SHORT $LN17@gObjTradeO

; 10583: 	{
; 10584: 		LogAdd(LOG_BLACK, lMsg.Get(539),gObj[aIndex].AccountID,gObj[aIndex].Name,gObj[number].TargetNumber,gObj[number].TargetNumber);

  00047	50		 push	 eax
  00048	50		 push	 eax
  00049	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  0004f	50		 push	 eax
  00050	8d 8e 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  00056	51		 push	 ecx
  00057	68 1b 02 00 00	 push	 539			; 0000021bH
  0005c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00061	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00066	50		 push	 eax
  00067	6a 00		 push	 0
  00069	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 10652: 		CGTradeResult(number,result);

  0006e	83 c4 18	 add	 esp, 24			; 00000018H
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx

; 10697: }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
$LN17@gObjTradeO:

; 10585: 		return;
; 10586: 	}
; 10587: 
; 10588: 	if(gObj[aIndex].TradeOk != 1 || gObj[number].TradeOk != 1)

  00078	80 be c0 0c 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3264], 1
  0007f	0f 85 8e 02 00
	00		 jne	 $LN25@gObjTradeO
  00085	80 bf c0 0c 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3264], 1
  0008c	0f 85 81 02 00
	00		 jne	 $LN25@gObjTradeO

; 10589: 	{
; 10590: 		return;
; 10591: 	}
; 10592: 
; 10593: 	if(TradeItemInventoryPutTest(aIndex) == 1)

  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 ?TradeItemInventoryPutTest@@YAHH@Z ; TradeItemInventoryPutTest
  00098	83 c4 04	 add	 esp, 4
  0009b	83 f8 01	 cmp	 eax, 1
  0009e	75 16		 jne	 SHORT $LN14@gObjTradeO

; 10594: 	{
; 10595: 		if(TradeItemInventoryPutTest(number) == 1)

  000a0	53		 push	 ebx
  000a1	e8 00 00 00 00	 call	 ?TradeItemInventoryPutTest@@YAHH@Z ; TradeItemInventoryPutTest
  000a6	83 c4 04	 add	 esp, 4
  000a9	83 f8 01	 cmp	 eax, 1
  000ac	0f 95 c0	 setne	 al
  000af	fe c0		 inc	 al
  000b1	88 45 ff	 mov	 BYTE PTR _result$[ebp], al

; 10596: 		{
; 10597: 			result = 1;
; 10598: 		}
; 10599: 		else
; 10600: 		{
; 10601: 			result = 2;
; 10602: 		}
; 10603: 	}
; 10604: 	else

  000b4	eb 04		 jmp	 SHORT $LN11@gObjTradeO
$LN14@gObjTradeO:

; 10605: 	{
; 10606: 		result = 2;

  000b6	c6 45 ff 02	 mov	 BYTE PTR _result$[ebp], 2
$LN11@gObjTradeO:

; 10607: 	}
; 10608: 
; 10609: 	if(gObjCheckMaxZen(aIndex,gObj[number].TradeMoney) == 0)

  000ba	8b 97 bc 0c 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3260]
  000c0	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000c3	52		 push	 edx
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  000ca	83 c4 08	 add	 esp, 8
  000cd	85 c0		 test	 eax, eax
  000cf	75 04		 jne	 SHORT $LN10@gObjTradeO

; 10610: 	{
; 10611: 		result = 2;

  000d1	c6 45 ff 02	 mov	 BYTE PTR _result$[ebp], 2
$LN10@gObjTradeO:

; 10612: 	}
; 10613: 
; 10614: 	if(gObjCheckMaxZen(number,gObj[aIndex].TradeMoney) == 0)

  000d5	8b 8e bc 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3260]
  000db	51		 push	 ecx
  000dc	53		 push	 ebx
  000dd	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  000e2	83 c4 08	 add	 esp, 8
  000e5	85 c0		 test	 eax, eax

; 10615: 	{
; 10616: 		result = 2;
; 10617: 	}
; 10618: 
; 10619: 	if(result == 1)

  000e7	0f 84 04 02 00
	00		 je	 $LN8@gObjTradeO
  000ed	80 7d ff 01	 cmp	 BYTE PTR _result$[ebp], 1
  000f1	0f 85 fa 01 00
	00		 jne	 $LN8@gObjTradeO

; 10620: 	{
; 10621: 		TradeitemInventoryPut(aIndex);

  000f7	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000fa	52		 push	 edx
  000fb	e8 00 00 00 00	 call	 ?TradeitemInventoryPut@@YAHH@Z ; TradeitemInventoryPut

; 10622: 		TradeitemInventoryPut(number);

  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 ?TradeitemInventoryPut@@YAHH@Z ; TradeitemInventoryPut

; 10623: 		gObjInventoryCommit(aIndex);

  00106	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit

; 10624: 		gObjInventoryCommit(number);

  0010f	53		 push	 ebx
  00110	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit

; 10625: 		gObjMakePreviewCharSet(aIndex);

  00115	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00118	51		 push	 ecx
  00119	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 10626: 		gObjMakePreviewCharSet(number);

  0011e	53		 push	 ebx
  0011f	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 10627: 
; 10628: 		gObj[aIndex].Money -= gObj[aIndex].TradeMoney;

  00124	8b 96 bc 0c 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3260]
  0012a	83 c4 18	 add	 esp, 24			; 00000018H
  0012d	29 96 b0 00 00
	00		 sub	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176], edx

; 10629: 		if(gObj[aIndex].Money < 0)

  00133	79 0a		 jns	 SHORT $LN24@gObjTradeO

; 10630: 		{
; 10631: 			gObj[aIndex].Money = 0;

  00135	c7 86 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176], 0
$LN24@gObjTradeO:

; 10632: 		}
; 10633: 		gObj[number].Money -= gObj[number].TradeMoney;

  0013f	8b 87 bc 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3260]
  00145	29 87 b0 00 00
	00		 sub	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+176], eax

; 10634: 		if(gObj[number].Money < 0)

  0014b	79 0a		 jns	 SHORT $LN6@gObjTradeO

; 10635: 		{
; 10636: 			gObj[number].Money = 0;

  0014d	c7 87 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+176], 0
$LN6@gObjTradeO:

; 10637: 		}
; 10638: 
; 10639: 		gObj[aIndex].Money += gObj[number].TradeMoney;

  00157	01 86 b0 00 00
	00		 add	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176], eax

; 10640: 		gObj[number].Money += gObj[aIndex].TradeMoney;

  0015d	8b 86 bc 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3260]
  00163	01 87 b0 00 00
	00		 add	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+176], eax

; 10641: 
; 10642: 		LogAdd(LOG_BLACK, lMsg.Get(540),gObj[aIndex].AccountID,gObj[aIndex].Name,gObj[number].AccountID,gObj[number].Name,gObj[aIndex].TradeMoney,gObj[number].TradeMoney);

  00169	8b 8f bc 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3260]
  0016f	8b 96 bc 0c 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3260]
  00175	51		 push	 ecx
  00176	52		 push	 edx
  00177	8d 87 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+111]
  0017d	50		 push	 eax
  0017e	8d 8f 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+100]
  00184	51		 push	 ecx
  00185	8d 96 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  0018b	52		 push	 edx
  0018c	8d 86 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  00192	50		 push	 eax
  00193	68 1c 02 00 00	 push	 540			; 0000021cH
  00198	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0019d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001a2	50		 push	 eax
  001a3	6a 00		 push	 0
  001a5	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 10643: 		GJSetCharacterInfo(&gObj[aIndex],aIndex,0);

  001aa	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  001ad	6a 00		 push	 0
  001af	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  001b5	51		 push	 ecx
  001b6	50		 push	 eax
  001b7	89 45 f8	 mov	 DWORD PTR tv433[ebp], eax
  001ba	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo

; 10644: 		GJSetCharacterInfo(&gObj[number],number,0);

  001bf	6a 00		 push	 0
  001c1	8d 87 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  001c7	53		 push	 ebx
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  001ce	83 c4 38	 add	 esp, 56			; 00000038H

; 10653: 		return;
; 10654: 	}
; 10655: 
; 10656: 	if(gItemBlock.IsEnableToTrade(&gObj[number]) == 0)

  001d1	8d 87 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  001d7	50		 push	 eax
  001d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gItemBlock@@3VCItemBlock@@A ; gItemBlock
  001dd	e8 00 00 00 00	 call	 ?IsEnableToTrade@CItemBlock@@QAE_NPAUOBJECTSTRUCT@@@Z ; CItemBlock::IsEnableToTrade
  001e2	84 c0		 test	 al, al
  001e4	75 43		 jne	 SHORT $LN4@gObjTradeO

; 10657: 	{
; 10658: 		MsgUser(aIndex, 1, "Item Bloqueado no Trade");

  001e6	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CKIBLNIL@Item?5Bloqueado?5no?5Trade?$AA@
  001ee	6a 01		 push	 1
  001f0	56		 push	 esi
  001f1	e8 00 00 00 00	 call	 ?MsgUser@@YAXHHPADZZ	; MsgUser

; 10659: 		MsgUser(number, 1, "Item Bloqueado no Trade");

  001f6	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CKIBLNIL@Item?5Bloqueado?5no?5Trade?$AA@
  001fb	6a 01		 push	 1
  001fd	53		 push	 ebx
  001fe	e8 00 00 00 00	 call	 ?MsgUser@@YAXHHPADZZ	; MsgUser

; 10660: 		// ---
; 10661: 		result = 0;
; 10662: 		// ---
; 10663: 		gObjTradeCancel(aIndex);

  00203	56		 push	 esi
  00204	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel

; 10664: 		gObjTradeCancel(number);

  00209	53		 push	 ebx
  0020a	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel

; 10665: 		// ---
; 10666: 		CGTradeResult(aIndex, result);

  0020f	6a 00		 push	 0
  00211	56		 push	 esi
  00212	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult

; 10667: 		CGTradeResult(number, result);

  00217	6a 00		 push	 0
  00219	53		 push	 ebx
  0021a	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  0021f	83 c4 30	 add	 esp, 48			; 00000030H
  00222	5f		 pop	 edi
  00223	5e		 pop	 esi
  00224	5b		 pop	 ebx

; 10697: }

  00225	8b e5		 mov	 esp, ebp
  00227	5d		 pop	 ebp
  00228	c3		 ret	 0
$LN4@gObjTradeO:

; 10668: 		// ---
; 10669: 		return;
; 10670: 	}
; 10671: 
; 10672: 	gObj[aIndex].TargetNumber = -1;

  00229	83 ca ff	 or	 edx, -1
  0022c	66 89 96 d4 02
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+724], dx

; 10673: 	gObj[aIndex].m_IfState.use = 0;

  00233	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00238	21 86 84 0c 00
	00		 and	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3204], eax

; 10674: 	gObj[number].TargetNumber = -1;
; 10675: 	gObj[number].m_IfState.use = 0;

  0023e	21 87 84 0c 00
	00		 and	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3204], eax
  00244	0b ca		 or	 ecx, edx
  00246	66 89 8f d4 02
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+724], cx

; 10676: 	gObj[aIndex].TradeOk = 0;
; 10677: 	gObj[number].TradeOk = 0;
; 10678: 	gObj[aIndex].TradeMoney = 0;

  0024d	33 c0		 xor	 eax, eax
  0024f	c6 86 c0 0c 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3264], 0
  00256	c6 87 c0 0c 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3264], 0
  0025d	89 86 bc 0c 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3260], eax

; 10679: 	gObj[number].TradeMoney = 0;

  00263	89 87 bc 0c 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3260], eax

; 10680: 
; 10681: 	GCMoneySend(aIndex,gObj[aIndex].Money);

  00269	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176]
  0026f	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00272	52		 push	 edx
  00273	50		 push	 eax
  00274	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 10682: 	GCMoneySend(number,gObj[number].Money);

  00279	8b 8f b0 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+176]
  0027f	51		 push	 ecx
  00280	53		 push	 ebx
  00281	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 10683: 	CGTradeResult(aIndex,result);

  00286	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00289	6a 01		 push	 1
  0028b	52		 push	 edx
  0028c	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult

; 10684: 	CGTradeResult(number,result);

  00291	6a 01		 push	 1
  00293	53		 push	 ebx
  00294	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult

; 10685: 
; 10686: 	GCItemListSend(aIndex);

  00299	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0029c	50		 push	 eax
  0029d	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend

; 10687: 	GCItemListSend(number);

  002a2	53		 push	 ebx
  002a3	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  002a8	83 c4 28	 add	 esp, 40			; 00000028H
  002ab	33 db		 xor	 ebx, ebx
  002ad	8d 49 00	 npad	 3
$LL3@gObjTradeO:

; 10688: 
; 10689: 	for(int n = 0; n < TRADE_BOX_SIZE; n++)
; 10690: 	{
; 10691: 		gObj[aIndex].Trade[n].Clear();

  002b0	8b 8e b4 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3252]
  002b6	03 cb		 add	 ecx, ebx
  002b8	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 10692: 		gObj[number].Trade[n].Clear();

  002bd	8b 8f b4 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3252]
  002c3	03 cb		 add	 ecx, ebx
  002c5	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  002ca	81 c3 a8 00 00
	00		 add	 ebx, 168		; 000000a8H
  002d0	81 fb 00 15 00
	00		 cmp	 ebx, 5376		; 00001500H
  002d6	7c d8		 jl	 SHORT $LL3@gObjTradeO

; 10693: 	}
; 10694: 
; 10695: 	gObjNotifyUpdateUnionV1(&gObj[aIndex]);

  002d8	8b 75 f8	 mov	 esi, DWORD PTR tv433[ebp]
  002db	56		 push	 esi
  002dc	e8 00 00 00 00	 call	 ?gObjNotifyUpdateUnionV1@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNotifyUpdateUnionV1

; 10696: 	gObjNotifyUpdateUnionV2(&gObj[aIndex]);

  002e1	56		 push	 esi
  002e2	e8 00 00 00 00	 call	 ?gObjNotifyUpdateUnionV2@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNotifyUpdateUnionV2
  002e7	83 c4 08	 add	 esp, 8
  002ea	5f		 pop	 edi
  002eb	5e		 pop	 esi
  002ec	5b		 pop	 ebx

; 10697: }

  002ed	8b e5		 mov	 esp, ebp
  002ef	5d		 pop	 ebp
  002f0	c3		 ret	 0
$LN8@gObjTradeO:

; 10645: 	}
; 10646: 	else
; 10647: 	{
; 10648: 		result = 2;
; 10649: 		gObjTradeCancel(aIndex);

  002f1	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  002f4	56		 push	 esi
  002f5	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel

; 10650: 		gObjTradeCancel(number);

  002fa	53		 push	 ebx
  002fb	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel

; 10651: 		CGTradeResult(aIndex,result);

  00300	6a 02		 push	 2
  00302	56		 push	 esi
  00303	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult

; 10652: 		CGTradeResult(number,result);

  00308	6a 02		 push	 2
  0030a	53		 push	 ebx
  0030b	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  00310	83 c4 18	 add	 esp, 24			; 00000018H
$LN25@gObjTradeO:
  00313	5f		 pop	 edi
$LN15@gObjTradeO:
  00314	5e		 pop	 esi
  00315	5b		 pop	 ebx

; 10697: }

  00316	8b e5		 mov	 esp, ebp
  00318	5d		 pop	 ebp
  00319	c3		 ret	 0
?gObjTradeOkButton@@YAXH@Z ENDP				; gObjTradeOkButton
_TEXT	ENDS
PUBLIC	?gObjViewportListCreate@@YAXF@Z			; gObjViewportListCreate
EXTRN	?gCurPaintPlayer@@3HA:DWORD			; gCurPaintPlayer
; Function compile flags: /Ogtp
;	COMDAT ?gObjViewportListCreate@@YAXF@Z
_TEXT	SEGMENT
_mapnum$ = -8						; size = 4
tv324 = -4						; size = 4
_aIndex$ = 8						; size = 2
?gObjViewportListCreate@@YAXF@Z PROC			; gObjViewportListCreate, COMDAT

; 11227: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11228: 	int result,n;
; 11229: 	LPOBJ lpObj;
; 11230: 	int mapnum;
; 11231: 
; 11232: 	if(OBJMAX_RANGE(aIndex) == 0)

  00003	66 8b 55 08	 mov	 dx, WORD PTR _aIndex$[ebp]
  00007	83 ec 08	 sub	 esp, 8
  0000a	66 85 d2	 test	 dx, dx
  0000d	0f 88 06 02 00
	00		 js	 $LN6@gObjViewpo@5
  00013	33 c9		 xor	 ecx, ecx
  00015	b8 e7 1c 00 00	 mov	 eax, 7399		; 00001ce7H
  0001a	66 3b d0	 cmp	 dx, ax
  0001d	0f 9e c1	 setle	 cl
  00020	8b c1		 mov	 eax, ecx
  00022	85 c0		 test	 eax, eax
  00024	0f 84 ef 01 00
	00		 je	 $LN6@gObjViewpo@5

; 11233: 	{
; 11234: 		return;
; 11235: 	}
; 11236: 
; 11237: 	lpObj = &gObj[aIndex];

  0002a	53		 push	 ebx
  0002b	0f bf da	 movsx	 ebx, dx
  0002e	8b cb		 mov	 ecx, ebx
  00030	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H

; 11238: 
; 11239: 	if(lpObj->Connected < PLAYER_PLAYING)

  00036	80 b9 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], 3
  0003d	89 4d fc	 mov	 DWORD PTR tv324[ebp], ecx
  00040	0f 82 d2 01 00
	00		 jb	 $LN51@gObjViewpo@5

; 11240: 	{
; 11241: 		return;
; 11242: 	}
; 11243: 
; 11244: 	if(lpObj->RegenOk > 0)

  00046	80 b9 03 02 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+515], 0
  0004d	0f 8f c5 01 00
	00		 jg	 $LN51@gObjViewpo@5

; 11245: 	{
; 11246: 		return;
; 11247: 	}
; 11248: 
; 11249: 	mapnum = lpObj->MapNumber;

  00053	0f b6 81 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  0005a	56		 push	 esi

; 11250: 	gItemLoop2 = 0;

  0005b	33 f6		 xor	 esi, esi

; 11251: 
; 11252: 	if(lpObj->Type == OBJ_USER)

  0005d	66 83 b9 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+96], 1
  00065	57		 push	 edi
  00066	89 45 f8	 mov	 DWORD PTR _mapnum$[ebp], eax
  00069	89 35 00 00 00
	00		 mov	 DWORD PTR ?gItemLoop2@@3HA, esi ; gItemLoop2
  0006f	75 6b		 jne	 SHORT $LN25@gObjViewpo@5

; 11253: 	{
; 11254: 		MapClass * lpMap = &MapC[mapnum];

  00071	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  00077	05 00 00 00 00	 add	 eax, OFFSET ?MapC@@3PAVMapClass@@A ; MapC

; 11255: 
; 11256: 		for(int n = 0; n < MAX_MAPITEM; n++)

  0007c	33 ff		 xor	 edi, edi
  0007e	8d b0 d0 00 00
	00		 lea	 esi, DWORD PTR [eax+208]
$LL45@gObjViewpo@5:

; 11257: 		{
; 11258: 			if(lpMap->m_cItem[n].live)

  00084	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  00088	74 39		 je	 SHORT $LN26@gObjViewpo@5

; 11259: 			{
; 11260: 				gItemLoop2++;
; 11261: 
; 11262: 				if(lpMap->m_cItem[n].m_State == 1 || lpMap->m_cItem[n].m_State == 2)

  0008a	8b 06		 mov	 eax, DWORD PTR [esi]
  0008c	ff 05 00 00 00
	00		 inc	 DWORD PTR ?gItemLoop2@@3HA ; gItemLoop2
  00092	83 f8 01	 cmp	 eax, 1
  00095	74 05		 je	 SHORT $LN22@gObjViewpo@5
  00097	83 f8 02	 cmp	 eax, 2
  0009a	75 27		 jne	 SHORT $LN26@gObjViewpo@5
$LN22@gObjViewpo@5:

; 11263: 				{
; 11264: 					if(gObjCheckViewport(aIndex,lpMap->m_cItem[n].px,lpMap->m_cItem[n].py) == 1)

  0009c	0f b6 56 fd	 movzx	 edx, BYTE PTR [esi-3]
  000a0	0f b6 46 fc	 movzx	 eax, BYTE PTR [esi-4]
  000a4	52		 push	 edx
  000a5	50		 push	 eax
  000a6	53		 push	 ebx
  000a7	e8 00 00 00 00	 call	 ?gObjCheckViewport@@YAHHHH@Z ; gObjCheckViewport
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  000af	83 f8 01	 cmp	 eax, 1
  000b2	75 0c		 jne	 SHORT $LN42@gObjViewpo@5

; 11265: 					{
; 11266: 						result = ViewportAdd(aIndex,n,5);

  000b4	6a 05		 push	 5
  000b6	57		 push	 edi
  000b7	53		 push	 ebx
  000b8	e8 00 00 00 00	 call	 ?ViewportAdd@@YAHHHH@Z	; ViewportAdd
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN42@gObjViewpo@5:
  000c0	8b 4d fc	 mov	 ecx, DWORD PTR tv324[ebp]
$LN26@gObjViewpo@5:

; 11255: 
; 11256: 		for(int n = 0; n < MAX_MAPITEM; n++)

  000c3	47		 inc	 edi
  000c4	81 c6 48 04 00
	00		 add	 esi, 1096		; 00000448H
  000ca	81 ff 2c 01 00
	00		 cmp	 edi, 300		; 0000012cH
  000d0	7c b2		 jl	 SHORT $LL45@gObjViewpo@5
  000d2	66 8b 55 08	 mov	 dx, WORD PTR _aIndex$[ebp]
  000d6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gItemLoop2@@3HA ; gItemLoop2
$LN25@gObjViewpo@5:

; 11267: 					}
; 11268: 				}
; 11269: 			}
; 11270: 		}
; 11271: 	}
; 11272: 
; 11273: 	if(aIndex == 0)

  000dc	33 ff		 xor	 edi, edi
  000de	66 3b d7	 cmp	 dx, di
  000e1	75 12		 jne	 SHORT $LN20@gObjViewpo@5

; 11274: 	{
; 11275: 		gItemLoopMax = gItemLoop2;

  000e3	89 35 00 00 00
	00		 mov	 DWORD PTR ?gItemLoopMax@@3HA, esi ; gItemLoopMax

; 11276: 		gItemLoop = gItemLoop2;

  000e9	89 35 00 00 00
	00		 mov	 DWORD PTR ?gItemLoop@@3HA, esi ; gItemLoop

; 11277: 		gCurPaintPlayer = aIndex;

  000ef	89 3d 00 00 00
	00		 mov	 DWORD PTR ?gCurPaintPlayer@@3HA, edi ; gCurPaintPlayer
$LN20@gObjViewpo@5:

; 11278: 	}
; 11279: 
; 11280: 	int a = 1;
; 11281: 	LPOBJ lpTempObj;
; 11282: 
; 11283: 	if(lpObj->Type == OBJ_USER 	)

  000f5	0f b7 81 60 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+96]
  000fc	83 f8 01	 cmp	 eax, 1
  000ff	0f 85 88 00 00
	00		 jne	 $LN19@gObjViewpo@5

; 11284: 	{
; 11285: 		for(int n = 0; n < OBJMAX; n++)

  00105	be bc 01 00 00	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+444
  0010a	8d 9b 00 00 00
	00		 npad	 6
$LL46@gObjViewpo@5:

; 11286: 		{
; 11287: 			lpTempObj = &gObj[n];
; 11288: 
; 11289: 			if(lpTempObj->Connected == PLAYER_PLAYING && aIndex != n)

  00110	80 be 48 fe ff
	ff 03		 cmp	 BYTE PTR [esi-440], 3
  00117	75 5e		 jne	 SHORT $LN17@gObjViewpo@5
  00119	3b df		 cmp	 ebx, edi
  0011b	74 5a		 je	 SHORT $LN17@gObjViewpo@5

; 11290: 			{
; 11291: 				if(lpTempObj->m_State == 1 || lpTempObj->m_State == 2)

  0011d	8b 06		 mov	 eax, DWORD PTR [esi]
  0011f	83 f8 01	 cmp	 eax, 1
  00122	74 05		 je	 SHORT $LN13@gObjViewpo@5
  00124	83 f8 02	 cmp	 eax, 2
  00127	75 4e		 jne	 SHORT $LN17@gObjViewpo@5
$LN13@gObjViewpo@5:

; 11292: 				{
; 11293: 					if(mapnum == lpTempObj->MapNumber)

  00129	0f b6 8e 4d ff
	ff ff		 movzx	 ecx, BYTE PTR [esi-179]
  00130	39 4d f8	 cmp	 DWORD PTR _mapnum$[ebp], ecx
  00133	75 42		 jne	 SHORT $LN17@gObjViewpo@5

; 11294: 					{
; 11295: 						if(gObjCheckViewport(aIndex,lpTempObj->X,lpTempObj->Y) == 1)

  00135	0f bf 96 4a ff
	ff ff		 movsx	 edx, WORD PTR [esi-182]
  0013c	0f bf 86 48 ff
	ff ff		 movsx	 eax, WORD PTR [esi-184]
  00143	52		 push	 edx
  00144	50		 push	 eax
  00145	53		 push	 ebx
  00146	e8 00 00 00 00	 call	 ?gObjCheckViewport@@YAHHHH@Z ; gObjCheckViewport
  0014b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014e	83 f8 01	 cmp	 eax, 1
  00151	75 24		 jne	 SHORT $LN17@gObjViewpo@5

; 11296: 						{
; 11297: 							result = ViewportAdd(aIndex,n,lpTempObj->Type);

  00153	0f b7 8e a4 fe
	ff ff		 movzx	 ecx, WORD PTR [esi-348]
  0015a	51		 push	 ecx
  0015b	57		 push	 edi
  0015c	53		 push	 ebx
  0015d	e8 00 00 00 00	 call	 ?ViewportAdd@@YAHHHH@Z	; ViewportAdd

; 11298: 							result = ViewportAdd2(n,aIndex,gObj[aIndex].Type);

  00162	8b 55 fc	 mov	 edx, DWORD PTR tv324[ebp]
  00165	0f b7 82 60 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+96]
  0016c	50		 push	 eax
  0016d	53		 push	 ebx
  0016e	57		 push	 edi
  0016f	e8 00 00 00 00	 call	 ?ViewportAdd2@@YAHHHH@Z	; ViewportAdd2
  00174	83 c4 18	 add	 esp, 24			; 00000018H
$LN17@gObjViewpo@5:

; 11284: 	{
; 11285: 		for(int n = 0; n < OBJMAX; n++)

  00177	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  0017d	47		 inc	 edi
  0017e	81 fe 5c 54 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522844
  00184	7c 8a		 jl	 SHORT $LL46@gObjViewpo@5
  00186	5f		 pop	 edi
  00187	5e		 pop	 esi
  00188	5b		 pop	 ebx

; 11326: 						}
; 11327: 					}
; 11328: 				}
; 11329: 			}
; 11330: 		}
; 11331: 	}
; 11332: }

  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c3		 ret	 0
$LN19@gObjViewpo@5:

; 11299: 						}
; 11300: 					}
; 11301: 				}
; 11302: 			}
; 11303: 		}
; 11304: 	}
; 11305: 	else if(lpObj->Type == OBJ_MONSTER 
; 11306: #if GS_CASTLE == 1
; 11307: 		|| lpObj->Type == OBJ_NPC 
; 11308: 		|| lpObj->Type == OBJ_NPC
; 11309: #endif
; 11310: 		)

  0018d	83 f8 02	 cmp	 eax, 2
  00190	0f 85 80 00 00
	00		 jne	 $LN52@gObjViewpo@5

; 11311: 	{
; 11312: 		for(n = OBJ_MAXMONSTER; n < OBJMAX; n++)

  00196	bf a8 16 00 00	 mov	 edi, 5800		; 000016a8H
  0019b	be 5c a3 e4 01	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+31761244
$LL47@gObjViewpo@5:

; 11313: 		{
; 11314: 			lpTempObj = &gObj[n];
; 11315: 
; 11316: 			if(lpTempObj->Connected == PLAYER_PLAYING && aIndex != n)

  001a0	80 be 48 fe ff
	ff 03		 cmp	 BYTE PTR [esi-440], 3
  001a7	75 5e		 jne	 SHORT $LN7@gObjViewpo@5
  001a9	3b df		 cmp	 ebx, edi
  001ab	74 5a		 je	 SHORT $LN7@gObjViewpo@5

; 11317: 			{
; 11318: 				if(lpTempObj->m_State == 1 || lpTempObj->m_State == 2)

  001ad	8b 06		 mov	 eax, DWORD PTR [esi]
  001af	83 f8 01	 cmp	 eax, 1
  001b2	74 05		 je	 SHORT $LN3@gObjViewpo@5
  001b4	83 f8 02	 cmp	 eax, 2
  001b7	75 4e		 jne	 SHORT $LN7@gObjViewpo@5
$LN3@gObjViewpo@5:

; 11319: 				{
; 11320: 					if(mapnum == lpTempObj->MapNumber)

  001b9	0f b6 8e 4d ff
	ff ff		 movzx	 ecx, BYTE PTR [esi-179]
  001c0	39 4d f8	 cmp	 DWORD PTR _mapnum$[ebp], ecx
  001c3	75 42		 jne	 SHORT $LN7@gObjViewpo@5

; 11321: 					{
; 11322: 						if(gObjCheckViewport(aIndex,lpTempObj->X,lpTempObj->Y) == 1)

  001c5	0f bf 96 4a ff
	ff ff		 movsx	 edx, WORD PTR [esi-182]
  001cc	0f bf 86 48 ff
	ff ff		 movsx	 eax, WORD PTR [esi-184]
  001d3	52		 push	 edx
  001d4	50		 push	 eax
  001d5	53		 push	 ebx
  001d6	e8 00 00 00 00	 call	 ?gObjCheckViewport@@YAHHHH@Z ; gObjCheckViewport
  001db	83 c4 0c	 add	 esp, 12			; 0000000cH
  001de	83 f8 01	 cmp	 eax, 1
  001e1	75 24		 jne	 SHORT $LN7@gObjViewpo@5

; 11323: 						{
; 11324: 							result = ViewportAdd(aIndex,n,gObj[n].Type);

  001e3	0f b7 8e a4 fe
	ff ff		 movzx	 ecx, WORD PTR [esi-348]
  001ea	51		 push	 ecx
  001eb	57		 push	 edi
  001ec	53		 push	 ebx
  001ed	e8 00 00 00 00	 call	 ?ViewportAdd@@YAHHHH@Z	; ViewportAdd

; 11325: 							result = ViewportAdd2(n,aIndex,gObj[aIndex].Type);

  001f2	8b 55 fc	 mov	 edx, DWORD PTR tv324[ebp]
  001f5	0f b7 82 60 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+96]
  001fc	50		 push	 eax
  001fd	53		 push	 ebx
  001fe	57		 push	 edi
  001ff	e8 00 00 00 00	 call	 ?ViewportAdd2@@YAHHHH@Z	; ViewportAdd2
  00204	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@gObjViewpo@5:

; 11311: 	{
; 11312: 		for(n = OBJ_MAXMONSTER; n < OBJMAX; n++)

  00207	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  0020d	47		 inc	 edi
  0020e	81 fe 5c 54 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522844
  00214	7c 8a		 jl	 SHORT $LL47@gObjViewpo@5
$LN52@gObjViewpo@5:
  00216	5f		 pop	 edi
  00217	5e		 pop	 esi
$LN51@gObjViewpo@5:
  00218	5b		 pop	 ebx
$LN6@gObjViewpo@5:

; 11326: 						}
; 11327: 					}
; 11328: 				}
; 11329: 			}
; 11330: 		}
; 11331: 	}
; 11332: }

  00219	8b e5		 mov	 esp, ebp
  0021b	5d		 pop	 ebp
  0021c	c3		 ret	 0
?gObjViewportListCreate@@YAXF@Z ENDP			; gObjViewportListCreate
_TEXT	ENDS
PUBLIC	?gObjStateSetCreate@@YAXH@Z			; gObjStateSetCreate
EXTRN	?gAppearTamaJJang@@3HA:DWORD			; gAppearTamaJJang
EXTRN	?gTamaJJangEvent@@3HA:DWORD			; gTamaJJangEvent
EXTRN	?CheckGoldDercon@CEledoradoEvent@@QAEXH@Z:PROC	; CEledoradoEvent::CheckGoldDercon
EXTRN	?gEledoradoEvent@@3VCEledoradoEvent@@A:BYTE	; gEledoradoEvent
EXTRN	?GCMapEventStateSend@@YAXHEE@Z:PROC		; GCMapEventStateSend
EXTRN	?DragonEvent@@3PAVCDragonEvent@@A:DWORD		; DragonEvent
; Function compile flags: /Ogtp
;	COMDAT ?gObjStateSetCreate@@YAXH@Z
_TEXT	SEGMENT
_dwNowTick$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?gObjStateSetCreate@@YAXH@Z PROC			; gObjStateSetCreate, COMDAT

; 11824: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 11825: 	LPOBJ lpObj = &gObj[aIndex];

  00006	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00009	8b c7		 mov	 eax, edi
  0000b	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 11826: 
; 11827: 	if(lpObj->Connected < PLAYER_PLAYING)

  00011	80 b8 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 3
  00018	8d b0 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  0001e	0f 82 0f 03 00
	00		 jb	 $LN1@gObjStateS

; 11828: 	{
; 11829: 		return;
; 11830: 	}
; 11831: 
; 11832: 	DWORD dwNowTick = GetTickCount();

  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 11833: 	
; 11834: 	if(lpObj->DieRegen == 1)

  0002a	80 be 02 02 00
	00 01		 cmp	 BYTE PTR [esi+514], 1
  00031	89 45 fc	 mov	 DWORD PTR _dwNowTick$[ebp], eax
  00034	b9 08 00 00 00	 mov	 ecx, 8
  00039	75 23		 jne	 SHORT $LN24@gObjStateS

; 11835: 	{
; 11836: 		if(dwNowTick - lpObj->RegenTime > lpObj->MaxRegenTime + 1000)

  0003b	8b 96 0c 02 00
	00		 mov	 edx, DWORD PTR [esi+524]
  00041	2b 86 08 02 00
	00		 sub	 eax, DWORD PTR [esi+520]
  00047	81 c2 e8 03 00
	00		 add	 edx, 1000		; 000003e8H
  0004d	3b c2		 cmp	 eax, edx
  0004f	76 0d		 jbe	 SHORT $LN24@gObjStateS

; 11837: 		{
; 11838: 			lpObj->DieRegen = 2;

  00051	c6 86 02 02 00
	00 02		 mov	 BYTE PTR [esi+514], 2

; 11839: 			lpObj->m_State = 8;

  00058	89 8e bc 01 00
	00		 mov	 DWORD PTR [esi+444], ecx
$LN24@gObjStateS:

; 11840: 		}
; 11841: 	}
; 11842: 
; 11843: 	if(lpObj->Type == OBJ_USER)

  0005e	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00063	75 20		 jne	 SHORT $LN21@gObjStateS

; 11844: 	{
; 11845: 		if(lpObj->m_State == 8)

  00065	39 8e bc 01 00
	00		 cmp	 DWORD PTR [esi+444], ecx
  0006b	75 0b		 jne	 SHORT $LN22@gObjStateS

; 11846: 		{
; 11847: 			gObjReady4Relife(lpObj);

  0006d	56		 push	 esi
  0006e	e8 00 00 00 00	 call	 ?gObjReady4Relife@@YAXPAUOBJECTSTRUCT@@@Z ; gObjReady4Relife
  00073	83 c4 04	 add	 esp, 4

; 11848: 		}
; 11849: 		else

  00076	eb 0d		 jmp	 SHORT $LN21@gObjStateS
$LN22@gObjStateS:

; 11850: 		{
; 11851: 			gObjCheckTimeOutValue(lpObj,(DWORD &)dwNowTick);

  00078	8d 45 fc	 lea	 eax, DWORD PTR _dwNowTick$[ebp]
  0007b	50		 push	 eax
  0007c	56		 push	 esi
  0007d	e8 00 00 00 00	 call	 ?gObjCheckTimeOutValue@@YAXPAUOBJECTSTRUCT@@AAK@Z ; gObjCheckTimeOutValue
  00082	83 c4 08	 add	 esp, 8
$LN21@gObjStateS:

; 11852: 		}
; 11853: 	}
; 11854: 
; 11855: 	if(lpObj->Teleport == 1)

  00085	8a 86 00 02 00
	00		 mov	 al, BYTE PTR [esi+512]
  0008b	53		 push	 ebx
  0008c	33 db		 xor	 ebx, ebx
  0008e	3c 01		 cmp	 al, 1
  00090	75 34		 jne	 SHORT $LN20@gObjStateS

; 11856: 	{
; 11857: 		if(lpObj->DieRegen != 0)

  00092	38 9e 02 02 00
	00		 cmp	 BYTE PTR [esi+514], bl
  00098	74 0b		 je	 SHORT $LN19@gObjStateS

; 11858: 		{
; 11859: 			lpObj->Teleport = 0;

  0009a	88 9e 00 02 00
	00		 mov	 BYTE PTR [esi+512], bl
  000a0	e9 bb 01 00 00	 jmp	 $LN33@gObjStateS
$LN19@gObjStateS:

; 11860: 		}
; 11861: 		else if(GetTickCount() - lpObj->TeleportTime > 100)

  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000ab	2b 86 fc 01 00
	00		 sub	 eax, DWORD PTR [esi+508]
  000b1	83 f8 64	 cmp	 eax, 100		; 00000064H
  000b4	0f 86 a6 01 00
	00		 jbe	 $LN33@gObjStateS

; 11862: 		{
; 11863: 			lpObj->Teleport = 2;

  000ba	c6 86 00 02 00
	00 02		 mov	 BYTE PTR [esi+512], 2

; 11864: 		}
; 11865: 	}

  000c1	e9 9a 01 00 00	 jmp	 $LN33@gObjStateS
$LN20@gObjStateS:

; 11866: 	else if(lpObj->Teleport == 2)

  000c6	3c 02		 cmp	 al, 2
  000c8	0f 85 92 01 00
	00		 jne	 $LN33@gObjStateS

; 11867: 	{
; 11868: 		lpObj->Teleport = 3;
; 11869: 
; 11870: 		if(lpObj->Type == OBJ_USER)

  000ce	0f b7 46 60	 movzx	 eax, WORD PTR [esi+96]
  000d2	c6 86 00 02 00
	00 03		 mov	 BYTE PTR [esi+512], 3
  000d9	83 f8 01	 cmp	 eax, 1
  000dc	75 65		 jne	 SHORT $LN14@gObjStateS

; 11871: 		{
; 11872: 			lpObj->TX = lpObj->X;
; 11873: 			lpObj->TY = lpObj->Y;

  000de	0f b7 8e 06 01
	00 00		 movzx	 ecx, WORD PTR [esi+262]
  000e5	0f b7 86 04 01
	00 00		 movzx	 eax, WORD PTR [esi+260]
  000ec	66 89 8e 22 01
	00 00		 mov	 WORD PTR [esi+290], cx

; 11874: 
; 11875: 			CreateFrustrum(lpObj->X,lpObj->Y,aIndex);

  000f3	0f bf c9	 movsx	 ecx, cx
  000f6	57		 push	 edi
  000f7	0f bf d0	 movsx	 edx, ax
  000fa	51		 push	 ecx
  000fb	52		 push	 edx
  000fc	66 89 86 20 01
	00 00		 mov	 WORD PTR [esi+288], ax
  00103	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum

; 11876: 			GCTeleportSend(&gObj[aIndex],0,lpObj->MapNumber,lpObj->X,lpObj->Y,lpObj->Dir);

  00108	0f b6 86 08 01
	00 00		 movzx	 eax, BYTE PTR [esi+264]
  0010f	0f b6 8e 06 01
	00 00		 movzx	 ecx, BYTE PTR [esi+262]
  00116	0f b6 96 04 01
	00 00		 movzx	 edx, BYTE PTR [esi+260]
  0011d	50		 push	 eax
  0011e	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00125	51		 push	 ecx
  00126	52		 push	 edx
  00127	50		 push	 eax
  00128	53		 push	 ebx
  00129	56		 push	 esi
  0012a	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend

; 11877: 			gObjViewportListProtocolCreate(lpObj);

  0012f	56		 push	 esi
  00130	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00135	83 c4 28	 add	 esp, 40			; 00000028H

; 11878: 
; 11879: #if GS_CASTLE == 1
; 11880: 			if ( lpObj->MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 11881: 			{
; 11882: 				g_CastleSiege.NotifySelfCsJoinSide(aIndex);
; 11883: 				g_CastleSiege.NotifyCsSelfLeftTime(aIndex);
; 11884: 			}
; 11885: #endif
; 11886: 
; 11887: 			lpObj->Teleport = 0;

  00138	88 9e 00 02 00
	00		 mov	 BYTE PTR [esi+512], bl
  0013e	e9 1d 01 00 00	 jmp	 $LN33@gObjStateS
$LN14@gObjStateS:

; 11888: 		}
; 11889: 		else if(lpObj->Type == OBJ_NPC && lpObj->Class == 229)

  00143	83 f8 03	 cmp	 eax, 3
  00146	75 48		 jne	 SHORT $LN12@gObjStateS
  00148	b9 e5 00 00 00	 mov	 ecx, 229		; 000000e5H
  0014d	66 39 8e 98 00
	00 00		 cmp	 WORD PTR [esi+152], cx
  00154	75 3a		 jne	 SHORT $LN12@gObjStateS

; 11890: 		{
; 11891: 			int x = lpObj->X;
; 11892: 			int y = lpObj->Y;

  00156	0f b7 8e 06 01
	00 00		 movzx	 ecx, WORD PTR [esi+262]
  0015d	0f b7 86 04 01
	00 00		 movzx	 eax, WORD PTR [esi+260]

; 11893: 			
; 11894: 			lpObj->X = x;
; 11895: 			lpObj->Y = y;
; 11896: 
; 11897: 			lpObj->TX = lpObj->X;
; 11898: 			lpObj->TY = lpObj->Y;
; 11899: 
; 11900: 			CreateFrustrum(lpObj->X,lpObj->Y,aIndex);

  00164	0f bf d1	 movsx	 edx, cx
  00167	66 89 86 20 01
	00 00		 mov	 WORD PTR [esi+288], ax
  0016e	57		 push	 edi
  0016f	98		 cwde
  00170	52		 push	 edx
  00171	50		 push	 eax
  00172	66 89 8e 22 01
	00 00		 mov	 WORD PTR [esi+290], cx
  00179	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  0017e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11901: 
; 11902: 			lpObj->m_State = 1;

  00181	c7 86 bc 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+444], 1

; 11903: 			lpObj->PathStartEnd = 0;

  0018b	e9 ca 00 00 00	 jmp	 $LN36@gObjStateS
$LN12@gObjStateS:

; 11904: 		}
; 11905: 		else if(lpObj->Type == OBJ_MONSTER)

  00190	83 f8 02	 cmp	 eax, 2
  00193	75 50		 jne	 SHORT $LN10@gObjStateS

; 11906: 		{
; 11907: 			lpObj->TX = lpObj->X;
; 11908: 			lpObj->TY = lpObj->Y;

  00195	0f b7 8e 06 01
	00 00		 movzx	 ecx, WORD PTR [esi+262]
  0019c	0f b7 86 04 01
	00 00		 movzx	 eax, WORD PTR [esi+260]
  001a3	66 89 8e 22 01
	00 00		 mov	 WORD PTR [esi+290], cx

; 11909: 
; 11910: 			CreateFrustrum(lpObj->X,lpObj->Y,aIndex);

  001aa	0f bf c9	 movsx	 ecx, cx
  001ad	57		 push	 edi
  001ae	0f bf d0	 movsx	 edx, ax
  001b1	51		 push	 ecx
  001b2	52		 push	 edx
  001b3	66 89 86 20 01
	00 00		 mov	 WORD PTR [esi+288], ax
  001ba	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum

; 11911: 
; 11912: 			gObjViewportListCreate(lpObj->m_Index);

  001bf	0f b7 06	 movzx	 eax, WORD PTR [esi]
  001c2	50		 push	 eax
  001c3	e8 00 00 00 00	 call	 ?gObjViewportListCreate@@YAXF@Z ; gObjViewportListCreate

; 11913: 			gObjViewportListProtocolCreate(lpObj);

  001c8	56		 push	 esi
  001c9	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  001ce	83 c4 14	 add	 esp, 20			; 00000014H

; 11914: 
; 11915: 			lpObj->Teleport = 0;

  001d1	88 9e 00 02 00
	00		 mov	 BYTE PTR [esi+512], bl

; 11916: 			lpObj->PathStartEnd = 0;
; 11917: 			lpObj->PathCur = 0;

  001d7	89 9e 2c 01 00
	00		 mov	 DWORD PTR [esi+300], ebx

; 11918: 			lpObj->PathCount = 0;

  001dd	89 9e 28 01 00
	00		 mov	 DWORD PTR [esi+296], ebx

; 11919: 		}
; 11920: 		else 

  001e3	eb 75		 jmp	 SHORT $LN36@gObjStateS
$LN10@gObjStateS:

; 11921: 		{
; 11922: 			int x,y;
; 11923: 
; 11924: 			if(lpObj->m_RecallMon >= 0)

  001e5	39 9e cc 02 00
	00		 cmp	 DWORD PTR [esi+716], ebx
  001eb	7c 10		 jl	 SHORT $LN8@gObjStateS

; 11925: 			{
; 11926: 				x = lpObj->X;

  001ed	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]

; 11927: 				y = lpObj->Y;

  001f4	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]

; 11928: 			}
; 11929: 			else

  001fb	eb 30		 jmp	 SHORT $LN7@gObjStateS
$LN8@gObjStateS:

; 11930: 			{
; 11931: 				x = lpObj->X + rand()%6 - 3;

  001fd	e8 00 00 00 00	 call	 _rand
  00202	99		 cdq
  00203	b9 06 00 00 00	 mov	 ecx, 6
  00208	f7 f9		 idiv	 ecx
  0020a	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR [esi+260]
  00211	8d 7c 02 fd	 lea	 edi, DWORD PTR [edx+eax-3]

; 11932: 				y = lpObj->Y + rand()%6 - 3;

  00215	e8 00 00 00 00	 call	 _rand
  0021a	99		 cdq
  0021b	b9 06 00 00 00	 mov	 ecx, 6
  00220	f7 f9		 idiv	 ecx
  00222	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  00229	8d 44 02 fd	 lea	 eax, DWORD PTR [edx+eax-3]
$LN7@gObjStateS:

; 11933: 			}
; 11934: 
; 11935: 			lpObj->X = x;

  0022d	66 89 be 04 01
	00 00		 mov	 WORD PTR [esi+260], di

; 11936: 			lpObj->Y = y;

  00234	66 89 86 06 01
	00 00		 mov	 WORD PTR [esi+262], ax

; 11937: 
; 11938: 			lpObj->TX = lpObj->X;

  0023b	66 89 be 20 01
	00 00		 mov	 WORD PTR [esi+288], di

; 11939: 			lpObj->TY = lpObj->Y;

  00242	66 89 86 22 01
	00 00		 mov	 WORD PTR [esi+290], ax

; 11940: 
; 11941: 			if(lpObj->m_RecallMon >= 0)

  00249	39 9e cc 02 00
	00		 cmp	 DWORD PTR [esi+716], ebx
  0024f	7c 0f		 jl	 SHORT $LN33@gObjStateS

; 11942: 			{
; 11943: 				gObjViewportListProtocolCreate(lpObj);

  00251	56		 push	 esi
  00252	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00257	83 c4 04	 add	 esp, 4
$LN36@gObjStateS:

; 11944: 				lpObj->PathStartEnd = 0;

  0025a	88 9e 30 01 00
	00		 mov	 BYTE PTR [esi+304], bl
$LN33@gObjStateS:

; 11945: 			}
; 11946: 		}
; 11947: 	}
; 11948: 
; 11949: 	if(lpObj->RegenOk == 2 && lpObj->Type == OBJ_USER)

  00260	80 be 03 02 00
	00 02		 cmp	 BYTE PTR [esi+515], 2
  00267	0f 85 c5 00 00
	00		 jne	 $LN35@gObjStateS
  0026d	b8 01 00 00 00	 mov	 eax, 1
  00272	66 39 46 60	 cmp	 WORD PTR [esi+96], ax
  00276	0f 85 b6 00 00
	00		 jne	 $LN35@gObjStateS

; 11950: 	{
; 11951: 		lpObj->m_State = 1;
; 11952: 		lpObj->RegenOk = 3;
; 11953: 		lpObj->X = lpObj->RegenMapX;
; 11954: 		lpObj->Y = lpObj->RegenMapY;

  0027c	0f b6 8e 06 02
	00 00		 movzx	 ecx, BYTE PTR [esi+518]

; 11955: 		lpObj->MapNumber = lpObj->RegenMapNumber;

  00283	8a 96 04 02 00
	00		 mov	 dl, BYTE PTR [esi+516]
  00289	89 86 bc 01 00
	00		 mov	 DWORD PTR [esi+444], eax
  0028f	0f b6 86 05 02
	00 00		 movzx	 eax, BYTE PTR [esi+517]
  00296	88 96 09 01 00
	00		 mov	 BYTE PTR [esi+265], dl

; 11956: 
; 11957: 		lpObj->TX = lpObj->X;
; 11958: 		lpObj->TY = lpObj->Y;
; 11959: 
; 11960: 		CreateFrustrum(lpObj->X,lpObj->Y,aIndex);

  0029c	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0029f	66 89 8e 06 01
	00 00		 mov	 WORD PTR [esi+262], cx
  002a6	66 89 8e 22 01
	00 00		 mov	 WORD PTR [esi+290], cx
  002ad	52		 push	 edx
  002ae	0f bf c9	 movsx	 ecx, cx
  002b1	0f bf d0	 movsx	 edx, ax
  002b4	51		 push	 ecx
  002b5	52		 push	 edx
  002b6	c6 86 03 02 00
	00 03		 mov	 BYTE PTR [esi+515], 3
  002bd	66 89 86 04 01
	00 00		 mov	 WORD PTR [esi+260], ax
  002c4	66 89 86 20 01
	00 00		 mov	 WORD PTR [esi+288], ax
  002cb	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum

; 11961: 
; 11962: 		if(DragonEvent->GetState() > 0)

  002d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  002d5	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d8	38 58 04	 cmp	 BYTE PTR [eax+4], bl
  002db	76 1b		 jbe	 SHORT $LN3@gObjStateS

; 11963: 		{
; 11964: 			if(DragonEvent->GetMapNumber() == lpObj->MapNumber)

  002dd	8a 8e 09 01 00
	00		 mov	 cl, BYTE PTR [esi+265]
  002e3	38 48 0c	 cmp	 BYTE PTR [eax+12], cl
  002e6	75 10		 jne	 SHORT $LN3@gObjStateS

; 11965: 			{
; 11966: 				GCMapEventStateSend(lpObj->MapNumber,1,1);

  002e8	6a 01		 push	 1
  002ea	0f b6 c1	 movzx	 eax, cl
  002ed	6a 01		 push	 1
  002ef	50		 push	 eax
  002f0	e8 00 00 00 00	 call	 ?GCMapEventStateSend@@YAXHEE@Z ; GCMapEventStateSend
  002f5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@gObjStateS:

; 11967: 			}
; 11968: 		}
; 11969: 
; 11970: #if GS_CASTLE == 1
; 11971: 		if ( lpObj->MapNumber == MAP_INDEX_CASTLESIEGE )
; 11972: 		{
; 11973: 			GCAnsCsNotifyStart(lpObj->m_Index, CHECK_CLASS(g_CastleSiege.GetCastleState(), CASTLESIEGE_STATE_STARTSIEGE));
; 11974: 			
; 11975: 			if ( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 11976: 			{
; 11977: 				g_CastleSiege.NotifySelfCsJoinSide(lpObj->m_Index);
; 11978: 				g_CastleSiege.NotifyCsSelfLeftTime(lpObj->m_Index);
; 11979: 			}
; 11980: 		}
; 11981: #endif
; 11982: 
; 11983: 		gEledoradoEvent.CheckGoldDercon(lpObj->MapNumber);

  002f8	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  002ff	51		 push	 ecx
  00300	b9 00 00 00 00	 mov	 ecx, OFFSET ?gEledoradoEvent@@3VCEledoradoEvent@@A ; gEledoradoEvent
  00305	e8 00 00 00 00	 call	 ?CheckGoldDercon@CEledoradoEvent@@QAEXH@Z ; CEledoradoEvent::CheckGoldDercon

; 11984: 
; 11985: 		if(gTamaJJangEvent != 0 && gAppearTamaJJang != 0)

  0030a	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?gTamaJJangEvent@@3HA, ebx ; gTamaJJangEvent
  00310	74 20		 je	 SHORT $LN35@gObjStateS
  00312	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gAppearTamaJJang@@3HA ; gAppearTamaJJang
  00317	3b c3		 cmp	 eax, ebx
  00319	74 17		 je	 SHORT $LN35@gObjStateS

; 11986: 		{
; 11987: 			if(lpObj->MapNumber == 0)

  0031b	38 9e 09 01 00
	00		 cmp	 BYTE PTR [esi+265], bl
  00321	75 0f		 jne	 SHORT $LN35@gObjStateS

; 11988: 			{
; 11989: 				GCMapEventStateSend(0,gAppearTamaJJang,2);

  00323	0f b6 d0	 movzx	 edx, al
  00326	6a 02		 push	 2
  00328	52		 push	 edx
  00329	53		 push	 ebx
  0032a	e8 00 00 00 00	 call	 ?GCMapEventStateSend@@YAXHEE@Z ; GCMapEventStateSend
  0032f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN35@gObjStateS:
  00332	5b		 pop	 ebx
$LN1@gObjStateS:
  00333	5f		 pop	 edi
  00334	5e		 pop	 esi

; 11990: 			}
; 11991: 		}
; 11992: 	}
; 11993: }

  00335	8b e5		 mov	 esp, ebp
  00337	5d		 pop	 ebp
  00338	c3		 ret	 0
?gObjStateSetCreate@@YAXH@Z ENDP			; gObjStateSetCreate
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjViewportListProtocol@@YAXF@Z		; gObjViewportListProtocol
; Function compile flags: /Ogtp
;	COMDAT ?gObjViewportListProtocol@@YAXF@Z
_TEXT	SEGMENT
tv3280 = -20080						; size = 4
tv3352 = -20076						; size = 4
tv3282 = -20072						; size = 4
tv3278 = -20068						; size = 4
_pGuild$166590 = -20064					; size = 12
_MonlOfs$ = -20052					; size = 4
tv3276 = -20048						; size = 4
_lpObj$ = -20044					; size = 4
tv1786 = -20040						; size = 4
_callMonlOfs$ = -20040					; size = 4
tv1888 = -20036						; size = 4
_pCount$ = -20032					; size = 4
_lOfs_Item$ = -20032					; size = 4
_lOfs$ = -20028						; size = 4
_count_Item$ = -20024					; size = 4
_monstercount$ = -20018					; size = 1
_callmonstercount$ = -20017				; size = 1
tv3397 = -20016						; size = 4
_pCount$166716 = -20016					; size = 5
_pCount$166708 = -20016					; size = 5
_pCount$166700 = -20016					; size = 5
_pCount$166692 = -20016					; size = 5
_pCount$166684 = -20016					; size = 5
_pCount$166676 = -20016					; size = 5
_count$ = -20005					; size = 1
_MonstersendBuf$ = -20004				; size = 5000
_callMonstersendBuf$ = -15004				; size = 5000
_ItemBuf$ = -10004					; size = 5000
_sendBuf$ = -5004					; size = 5000
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 2
?gObjViewportListProtocol@@YAXF@Z PROC			; gObjViewportListProtocol, COMDAT

; 13339: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 70 4e 00 00	 mov	 eax, 20080		; 00004e70H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	0f b7 45 08	 movzx	 eax, WORD PTR _aIndex$[ebp]
  0001b	53		 push	 ebx
  0001c	56		 push	 esi

; 13340: 	if (gObj[aIndex].Connected < PLAYER_PLAYING)

  0001d	0f bf f0	 movsx	 esi, ax
  00020	89 b5 bc b1 ff
	ff		 mov	 DWORD PTR tv1888[ebp], esi
  00026	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0002c	80 be 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+4], 3
  00033	57		 push	 edi
  00034	0f 82 b4 0e 00
	00		 jb	 $LN48@gObjViewpo@6

; 13341: 	{
; 13342: 		return;
; 13343: 	}
; 13344: 
; 13345: 	int n;
; 13346: 	PBMSG_COUNT pCount;
; 13347: 	LPOBJ lpTargetObj, lpObj = &gObj[aIndex];
; 13348: 	int lOfs_Item, count_Item, ItemStructSize = sizeof(PMSG_ITEMVIEWPORTCREATE), lOfs, MonlOfs, callMonlOfs;
; 13349: 	int pMsgSize;
; 13350: 	short tObjNum;
; 13351: 	BYTE count, monstercount, callmonstercount;
; 13352: 
; 13353: 	BYTE sendBuf[5000];
; 13354: 	BYTE MonstersendBuf[5000];
; 13355: 	BYTE callMonstersendBuf[5000];
; 13356: 	BYTE ItemBuf[5000];
; 13357: 
; 13358: 	GuildInfoOfs = 0;
; 13359: 	GuildInfoCount = 0;
; 13360: 	GuildUserOfs = 0;
; 13361: 	GuildUserCount = 0;
; 13362: 	ChangeCount = 0;
; 13363: 	GuildInfoOfs = 5;
; 13364: 	GuildUserOfs = 5;
; 13365: 	lOfsChange = 5;
; 13366: 
; 13367: 	lOfs = 4;
; 13368: 	lOfs_Item = 5;
; 13369: 	count = 0;
; 13370: 	count_Item = 0;
; 13371: 
; 13372: 	if (lpObj->Type == OBJ_USER)

  0003a	0f b7 86 60 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+96]
  00041	8d b6 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00047	33 d2		 xor	 edx, edx
  00049	bb 05 00 00 00	 mov	 ebx, 5
  0004e	b9 04 00 00 00	 mov	 ecx, 4
  00053	83 cf ff	 or	 edi, -1
  00056	89 b5 b4 b1 ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], esi
  0005c	89 15 00 00 00
	00		 mov	 DWORD PTR ?GuildInfoCount@@3HA, edx ; GuildInfoCount
  00062	89 15 00 00 00
	00		 mov	 DWORD PTR ?GuildUserCount@@3HA, edx ; GuildUserCount
  00068	89 15 00 00 00
	00		 mov	 DWORD PTR ?ChangeCount@@3HA, edx ; ChangeCount
  0006e	89 1d 00 00 00
	00		 mov	 DWORD PTR ?GuildInfoOfs@@3HA, ebx ; GuildInfoOfs
  00074	89 1d 00 00 00
	00		 mov	 DWORD PTR ?GuildUserOfs@@3HA, ebx ; GuildUserOfs
  0007a	89 1d 00 00 00
	00		 mov	 DWORD PTR ?lOfsChange@@3HA, ebx ; lOfsChange
  00080	89 8d c4 b1 ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], ecx
  00086	88 95 db b1 ff
	ff		 mov	 BYTE PTR _count$[ebp], dl
  0008c	89 95 c8 b1 ff
	ff		 mov	 DWORD PTR _count_Item$[ebp], edx
  00092	83 f8 01	 cmp	 eax, 1
  00095	0f 85 0d 03 00
	00		 jne	 $LN72@gObjViewpo@6

; 13373: 	{
; 13374: 		for (n = 0; n < MAX_VIEWPORT; n++)

  0009b	8d 86 90 03 00
	00		 lea	 eax, DWORD PTR [esi+912]
  000a1	c7 85 b8 b1 ff
	ff 0f 00 00 00	 mov	 DWORD PTR tv1786[ebp], 15 ; 0000000fH
  000ab	eb 05		 jmp	 SHORT $LN71@gObjViewpo@6
  000ad	8d 49 00	 npad	 3
$LL118@gObjViewpo@6:
  000b0	33 d2		 xor	 edx, edx
$LN71@gObjViewpo@6:

; 13375: 		{
; 13376: 			if (lpObj->VpPlayer[n].state == 3)

  000b2	80 38 03	 cmp	 BYTE PTR [eax], 3
  000b5	0f 85 89 00 00
	00		 jne	 $LN70@gObjViewpo@6

; 13377: 			{
; 13378: 				tObjNum = lpObj->VpPlayer[n].number;

  000bb	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]

; 13379: 
; 13380: 				if (tObjNum >= 0)

  000bf	66 3b ca	 cmp	 cx, dx
  000c2	7c 71		 jl	 SHORT $LN113@gObjViewpo@6

; 13381: 				{
; 13382: 					switch (lpObj->VpPlayer[n].type)

  000c4	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  000c7	84 d2		 test	 dl, dl
  000c9	74 6a		 je	 SHORT $LN113@gObjViewpo@6
  000cb	80 fa 03	 cmp	 dl, 3
  000ce	76 30		 jbe	 SHORT $LN64@gObjViewpo@6
  000d0	80 fa 05	 cmp	 dl, 5
  000d3	75 60		 jne	 SHORT $LN113@gObjViewpo@6

; 13392: 						break;
; 13393: 					case 5:
; 13394: 						pItemViewportDestroy.NumberH = SET_NUMBERH(tObjNum);

  000d5	8b d1		 mov	 edx, ecx
  000d7	c1 ea 08	 shr	 edx, 8
  000da	88 15 00 00 00
	00		 mov	 BYTE PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, dl

; 13395: 						pItemViewportDestroy.NumberL = SET_NUMBERL(tObjNum);

  000e0	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, cl

; 13396: 
; 13397: 						memcpy(&ItemBuf[lOfs_Item], &pItemViewportDestroy, sizeof(pItemViewportDestroy));

  000e6	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pItemViewportDestroy
  000ed	66 89 8c 1d ec
	d8 ff ff	 mov	 WORD PTR _ItemBuf$[ebp+ebx], cx

; 13398: 
; 13399: 						lOfs_Item += sizeof(pItemViewportDestroy);

  000f5	83 c3 02	 add	 ebx, 2

; 13400: 						count_Item += 1;

  000f8	ff 85 c8 b1 ff
	ff		 inc	 DWORD PTR _count_Item$[ebp]

; 13401: 						break;

  000fe	eb 35		 jmp	 SHORT $LN113@gObjViewpo@6
$LN64@gObjViewpo@6:

; 13383: 					{
; 13384: 					case 1:
; 13385: 					case 2:
; 13386: 					case 3:
; 13387: 						pViewportDestroy.NumberH = SET_NUMBERH(tObjNum);

  00100	8b d1		 mov	 edx, ecx
  00102	c1 ea 08	 shr	 edx, 8

; 13388: 						pViewportDestroy.NumberL = SET_NUMBERL(tObjNum);

  00105	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, cl

; 13389: 						memcpy(&sendBuf[lOfs], &pViewportDestroy, sizeof(pViewportDestroy));

  0010b	8b 8d c4 b1 ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  00111	88 15 00 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, dl
  00117	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pViewportDestroy
  0011e	66 89 94 0d 74
	ec ff ff	 mov	 WORD PTR _sendBuf$[ebp+ecx], dx

; 13390: 						lOfs += sizeof(pViewportDestroy);

  00126	83 c1 02	 add	 ecx, 2

; 13391: 						count += 1;

  00129	fe 85 db b1 ff
	ff		 inc	 BYTE PTR _count$[ebp]
  0012f	89 8d c4 b1 ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], ecx
$LN113@gObjViewpo@6:

; 13402: 					}
; 13403: 				}
; 13404: 
; 13405: 				lpObj->VpPlayer[n].state = 0;
; 13406: 				lpObj->VpPlayer[n].number = -1;

  00135	8b cf		 mov	 ecx, edi
  00137	c6 00 00	 mov	 BYTE PTR [eax], 0
  0013a	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 13407: 				lpObj->VPCount -= 1;

  0013e	01 be 98 0a 00
	00		 add	 DWORD PTR [esi+2712], edi
$LN70@gObjViewpo@6:

; 13375: 		{
; 13376: 			if (lpObj->VpPlayer[n].state == 3)

  00144	80 78 0c 03	 cmp	 BYTE PTR [eax+12], 3
  00148	0f 85 8a 00 00
	00		 jne	 $LN94@gObjViewpo@6

; 13377: 			{
; 13378: 				tObjNum = lpObj->VpPlayer[n].number;

  0014e	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]

; 13379: 
; 13380: 				if (tObjNum >= 0)

  00152	66 85 c9	 test	 cx, cx
  00155	78 71		 js	 SHORT $LN114@gObjViewpo@6

; 13381: 				{
; 13382: 					switch (lpObj->VpPlayer[n].type)

  00157	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  0015a	84 d2		 test	 dl, dl
  0015c	74 6a		 je	 SHORT $LN114@gObjViewpo@6
  0015e	80 fa 03	 cmp	 dl, 3
  00161	76 30		 jbe	 SHORT $LN92@gObjViewpo@6
  00163	80 fa 05	 cmp	 dl, 5
  00166	75 60		 jne	 SHORT $LN114@gObjViewpo@6

; 13392: 						break;
; 13393: 					case 5:
; 13394: 						pItemViewportDestroy.NumberH = SET_NUMBERH(tObjNum);

  00168	8b d1		 mov	 edx, ecx
  0016a	c1 ea 08	 shr	 edx, 8
  0016d	88 15 00 00 00
	00		 mov	 BYTE PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, dl

; 13395: 						pItemViewportDestroy.NumberL = SET_NUMBERL(tObjNum);

  00173	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, cl

; 13396: 
; 13397: 						memcpy(&ItemBuf[lOfs_Item], &pItemViewportDestroy, sizeof(pItemViewportDestroy));

  00179	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pItemViewportDestroy
  00180	66 89 8c 1d ec
	d8 ff ff	 mov	 WORD PTR _ItemBuf$[ebp+ebx], cx

; 13398: 
; 13399: 						lOfs_Item += sizeof(pItemViewportDestroy);

  00188	83 c3 02	 add	 ebx, 2

; 13400: 						count_Item += 1;

  0018b	ff 85 c8 b1 ff
	ff		 inc	 DWORD PTR _count_Item$[ebp]

; 13401: 						break;

  00191	eb 35		 jmp	 SHORT $LN114@gObjViewpo@6
$LN92@gObjViewpo@6:

; 13383: 					{
; 13384: 					case 1:
; 13385: 					case 2:
; 13386: 					case 3:
; 13387: 						pViewportDestroy.NumberH = SET_NUMBERH(tObjNum);

  00193	8b d1		 mov	 edx, ecx
  00195	c1 ea 08	 shr	 edx, 8

; 13388: 						pViewportDestroy.NumberL = SET_NUMBERL(tObjNum);

  00198	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, cl

; 13389: 						memcpy(&sendBuf[lOfs], &pViewportDestroy, sizeof(pViewportDestroy));

  0019e	8b 8d c4 b1 ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  001a4	88 15 00 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, dl
  001aa	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pViewportDestroy
  001b1	66 89 94 0d 74
	ec ff ff	 mov	 WORD PTR _sendBuf$[ebp+ecx], dx

; 13390: 						lOfs += sizeof(pViewportDestroy);

  001b9	83 c1 02	 add	 ecx, 2

; 13391: 						count += 1;

  001bc	fe 85 db b1 ff
	ff		 inc	 BYTE PTR _count$[ebp]
  001c2	89 8d c4 b1 ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], ecx
$LN114@gObjViewpo@6:

; 13402: 					}
; 13403: 				}
; 13404: 
; 13405: 				lpObj->VpPlayer[n].state = 0;
; 13406: 				lpObj->VpPlayer[n].number = -1;

  001c8	8b cf		 mov	 ecx, edi
  001ca	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  001ce	66 89 48 0e	 mov	 WORD PTR [eax+14], cx

; 13407: 				lpObj->VPCount -= 1;

  001d2	01 be 98 0a 00
	00		 add	 DWORD PTR [esi+2712], edi
$LN94@gObjViewpo@6:

; 13375: 		{
; 13376: 			if (lpObj->VpPlayer[n].state == 3)

  001d8	80 78 18 03	 cmp	 BYTE PTR [eax+24], 3
  001dc	0f 85 8a 00 00
	00		 jne	 $LN97@gObjViewpo@6

; 13377: 			{
; 13378: 				tObjNum = lpObj->VpPlayer[n].number;

  001e2	0f b7 48 1a	 movzx	 ecx, WORD PTR [eax+26]

; 13379: 
; 13380: 				if (tObjNum >= 0)

  001e6	66 85 c9	 test	 cx, cx
  001e9	78 71		 js	 SHORT $LN115@gObjViewpo@6

; 13381: 				{
; 13382: 					switch (lpObj->VpPlayer[n].type)

  001eb	8a 50 1c	 mov	 dl, BYTE PTR [eax+28]
  001ee	84 d2		 test	 dl, dl
  001f0	74 6a		 je	 SHORT $LN115@gObjViewpo@6
  001f2	80 fa 03	 cmp	 dl, 3
  001f5	76 30		 jbe	 SHORT $LN95@gObjViewpo@6
  001f7	80 fa 05	 cmp	 dl, 5
  001fa	75 60		 jne	 SHORT $LN115@gObjViewpo@6

; 13392: 						break;
; 13393: 					case 5:
; 13394: 						pItemViewportDestroy.NumberH = SET_NUMBERH(tObjNum);

  001fc	8b d1		 mov	 edx, ecx
  001fe	c1 ea 08	 shr	 edx, 8
  00201	88 15 00 00 00
	00		 mov	 BYTE PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, dl

; 13395: 						pItemViewportDestroy.NumberL = SET_NUMBERL(tObjNum);

  00207	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, cl

; 13396: 
; 13397: 						memcpy(&ItemBuf[lOfs_Item], &pItemViewportDestroy, sizeof(pItemViewportDestroy));

  0020d	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pItemViewportDestroy
  00214	66 89 8c 1d ec
	d8 ff ff	 mov	 WORD PTR _ItemBuf$[ebp+ebx], cx

; 13398: 
; 13399: 						lOfs_Item += sizeof(pItemViewportDestroy);

  0021c	83 c3 02	 add	 ebx, 2

; 13400: 						count_Item += 1;

  0021f	ff 85 c8 b1 ff
	ff		 inc	 DWORD PTR _count_Item$[ebp]

; 13401: 						break;

  00225	eb 35		 jmp	 SHORT $LN115@gObjViewpo@6
$LN95@gObjViewpo@6:

; 13383: 					{
; 13384: 					case 1:
; 13385: 					case 2:
; 13386: 					case 3:
; 13387: 						pViewportDestroy.NumberH = SET_NUMBERH(tObjNum);

  00227	8b d1		 mov	 edx, ecx
  00229	c1 ea 08	 shr	 edx, 8

; 13388: 						pViewportDestroy.NumberL = SET_NUMBERL(tObjNum);

  0022c	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, cl

; 13389: 						memcpy(&sendBuf[lOfs], &pViewportDestroy, sizeof(pViewportDestroy));

  00232	8b 8d c4 b1 ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  00238	88 15 00 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, dl
  0023e	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pViewportDestroy
  00245	66 89 94 0d 74
	ec ff ff	 mov	 WORD PTR _sendBuf$[ebp+ecx], dx

; 13390: 						lOfs += sizeof(pViewportDestroy);

  0024d	83 c1 02	 add	 ecx, 2

; 13391: 						count += 1;

  00250	fe 85 db b1 ff
	ff		 inc	 BYTE PTR _count$[ebp]
  00256	89 8d c4 b1 ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], ecx
$LN115@gObjViewpo@6:

; 13402: 					}
; 13403: 				}
; 13404: 
; 13405: 				lpObj->VpPlayer[n].state = 0;
; 13406: 				lpObj->VpPlayer[n].number = -1;

  0025c	8b cf		 mov	 ecx, edi
  0025e	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0
  00262	66 89 48 1a	 mov	 WORD PTR [eax+26], cx

; 13407: 				lpObj->VPCount -= 1;

  00266	01 be 98 0a 00
	00		 add	 DWORD PTR [esi+2712], edi
$LN97@gObjViewpo@6:

; 13375: 		{
; 13376: 			if (lpObj->VpPlayer[n].state == 3)

  0026c	80 78 24 03	 cmp	 BYTE PTR [eax+36], 3
  00270	0f 85 8a 00 00
	00		 jne	 $LN100@gObjViewpo@6

; 13377: 			{
; 13378: 				tObjNum = lpObj->VpPlayer[n].number;

  00276	0f b7 48 26	 movzx	 ecx, WORD PTR [eax+38]

; 13379: 
; 13380: 				if (tObjNum >= 0)

  0027a	66 85 c9	 test	 cx, cx
  0027d	78 71		 js	 SHORT $LN116@gObjViewpo@6

; 13381: 				{
; 13382: 					switch (lpObj->VpPlayer[n].type)

  0027f	8a 50 28	 mov	 dl, BYTE PTR [eax+40]
  00282	84 d2		 test	 dl, dl
  00284	74 6a		 je	 SHORT $LN116@gObjViewpo@6
  00286	80 fa 03	 cmp	 dl, 3
  00289	76 30		 jbe	 SHORT $LN98@gObjViewpo@6
  0028b	80 fa 05	 cmp	 dl, 5
  0028e	75 60		 jne	 SHORT $LN116@gObjViewpo@6

; 13392: 						break;
; 13393: 					case 5:
; 13394: 						pItemViewportDestroy.NumberH = SET_NUMBERH(tObjNum);

  00290	8b d1		 mov	 edx, ecx
  00292	c1 ea 08	 shr	 edx, 8
  00295	88 15 00 00 00
	00		 mov	 BYTE PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, dl

; 13395: 						pItemViewportDestroy.NumberL = SET_NUMBERL(tObjNum);

  0029b	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, cl

; 13396: 
; 13397: 						memcpy(&ItemBuf[lOfs_Item], &pItemViewportDestroy, sizeof(pItemViewportDestroy));

  002a1	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pItemViewportDestroy
  002a8	66 89 8c 1d ec
	d8 ff ff	 mov	 WORD PTR _ItemBuf$[ebp+ebx], cx

; 13398: 
; 13399: 						lOfs_Item += sizeof(pItemViewportDestroy);

  002b0	83 c3 02	 add	 ebx, 2

; 13400: 						count_Item += 1;

  002b3	ff 85 c8 b1 ff
	ff		 inc	 DWORD PTR _count_Item$[ebp]

; 13401: 						break;

  002b9	eb 35		 jmp	 SHORT $LN116@gObjViewpo@6
$LN98@gObjViewpo@6:

; 13383: 					{
; 13384: 					case 1:
; 13385: 					case 2:
; 13386: 					case 3:
; 13387: 						pViewportDestroy.NumberH = SET_NUMBERH(tObjNum);

  002bb	8b d1		 mov	 edx, ecx
  002bd	c1 ea 08	 shr	 edx, 8

; 13388: 						pViewportDestroy.NumberL = SET_NUMBERL(tObjNum);

  002c0	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, cl

; 13389: 						memcpy(&sendBuf[lOfs], &pViewportDestroy, sizeof(pViewportDestroy));

  002c6	8b 8d c4 b1 ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  002cc	88 15 00 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, dl
  002d2	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pViewportDestroy
  002d9	66 89 94 0d 74
	ec ff ff	 mov	 WORD PTR _sendBuf$[ebp+ecx], dx

; 13390: 						lOfs += sizeof(pViewportDestroy);

  002e1	83 c1 02	 add	 ecx, 2

; 13391: 						count += 1;

  002e4	fe 85 db b1 ff
	ff		 inc	 BYTE PTR _count$[ebp]
  002ea	89 8d c4 b1 ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], ecx
$LN116@gObjViewpo@6:

; 13402: 					}
; 13403: 				}
; 13404: 
; 13405: 				lpObj->VpPlayer[n].state = 0;
; 13406: 				lpObj->VpPlayer[n].number = -1;

  002f0	8b cf		 mov	 ecx, edi
  002f2	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
  002f6	66 89 48 26	 mov	 WORD PTR [eax+38], cx

; 13407: 				lpObj->VPCount -= 1;

  002fa	01 be 98 0a 00
	00		 add	 DWORD PTR [esi+2712], edi
$LN100@gObjViewpo@6:

; 13375: 		{
; 13376: 			if (lpObj->VpPlayer[n].state == 3)

  00300	80 78 30 03	 cmp	 BYTE PTR [eax+48], 3
  00304	0f 85 8a 00 00
	00		 jne	 $LN103@gObjViewpo@6

; 13377: 			{
; 13378: 				tObjNum = lpObj->VpPlayer[n].number;

  0030a	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]

; 13379: 
; 13380: 				if (tObjNum >= 0)

  0030e	66 85 c9	 test	 cx, cx
  00311	78 71		 js	 SHORT $LN117@gObjViewpo@6

; 13381: 				{
; 13382: 					switch (lpObj->VpPlayer[n].type)

  00313	8a 50 34	 mov	 dl, BYTE PTR [eax+52]
  00316	84 d2		 test	 dl, dl
  00318	74 6a		 je	 SHORT $LN117@gObjViewpo@6
  0031a	80 fa 03	 cmp	 dl, 3
  0031d	76 30		 jbe	 SHORT $LN101@gObjViewpo@6
  0031f	80 fa 05	 cmp	 dl, 5
  00322	75 60		 jne	 SHORT $LN117@gObjViewpo@6

; 13392: 						break;
; 13393: 					case 5:
; 13394: 						pItemViewportDestroy.NumberH = SET_NUMBERH(tObjNum);

  00324	8b d1		 mov	 edx, ecx
  00326	c1 ea 08	 shr	 edx, 8
  00329	88 15 00 00 00
	00		 mov	 BYTE PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, dl

; 13395: 						pItemViewportDestroy.NumberL = SET_NUMBERL(tObjNum);

  0032f	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, cl

; 13396: 
; 13397: 						memcpy(&ItemBuf[lOfs_Item], &pItemViewportDestroy, sizeof(pItemViewportDestroy));

  00335	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pItemViewportDestroy
  0033c	66 89 8c 1d ec
	d8 ff ff	 mov	 WORD PTR _ItemBuf$[ebp+ebx], cx

; 13398: 
; 13399: 						lOfs_Item += sizeof(pItemViewportDestroy);

  00344	83 c3 02	 add	 ebx, 2

; 13400: 						count_Item += 1;

  00347	ff 85 c8 b1 ff
	ff		 inc	 DWORD PTR _count_Item$[ebp]

; 13401: 						break;

  0034d	eb 35		 jmp	 SHORT $LN117@gObjViewpo@6
$LN101@gObjViewpo@6:

; 13383: 					{
; 13384: 					case 1:
; 13385: 					case 2:
; 13386: 					case 3:
; 13387: 						pViewportDestroy.NumberH = SET_NUMBERH(tObjNum);

  0034f	8b d1		 mov	 edx, ecx
  00351	c1 ea 08	 shr	 edx, 8

; 13388: 						pViewportDestroy.NumberL = SET_NUMBERL(tObjNum);

  00354	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, cl

; 13389: 						memcpy(&sendBuf[lOfs], &pViewportDestroy, sizeof(pViewportDestroy));

  0035a	8b 8d c4 b1 ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  00360	88 15 00 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, dl
  00366	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pViewportDestroy
  0036d	66 89 94 0d 74
	ec ff ff	 mov	 WORD PTR _sendBuf$[ebp+ecx], dx

; 13390: 						lOfs += sizeof(pViewportDestroy);

  00375	83 c1 02	 add	 ecx, 2

; 13391: 						count += 1;

  00378	fe 85 db b1 ff
	ff		 inc	 BYTE PTR _count$[ebp]
  0037e	89 8d c4 b1 ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], ecx
$LN117@gObjViewpo@6:

; 13402: 					}
; 13403: 				}
; 13404: 
; 13405: 				lpObj->VpPlayer[n].state = 0;
; 13406: 				lpObj->VpPlayer[n].number = -1;

  00384	8b cf		 mov	 ecx, edi
  00386	c6 40 30 00	 mov	 BYTE PTR [eax+48], 0
  0038a	66 89 48 32	 mov	 WORD PTR [eax+50], cx

; 13407: 				lpObj->VPCount -= 1;

  0038e	01 be 98 0a 00
	00		 add	 DWORD PTR [esi+2712], edi
$LN103@gObjViewpo@6:

; 13373: 	{
; 13374: 		for (n = 0; n < MAX_VIEWPORT; n++)

  00394	83 c0 3c	 add	 eax, 60			; 0000003cH
  00397	ff 8d b8 b1 ff
	ff		 dec	 DWORD PTR tv1786[ebp]
  0039d	0f 85 0d fd ff
	ff		 jne	 $LL118@gObjViewpo@6

; 13408: 			}
; 13409: 		}
; 13410: 	}
; 13411: 	else if (lpObj->Type == OBJ_MONSTER || lpObj->Type == OBJ_NPC)

  003a3	e9 82 00 00 00	 jmp	 $LN104@gObjViewpo@6
$LN72@gObjViewpo@6:
  003a8	83 f8 02	 cmp	 eax, 2
  003ab	74 05		 je	 SHORT $LN60@gObjViewpo@6
  003ad	83 f8 03	 cmp	 eax, 3
  003b0	75 78		 jne	 SHORT $LN104@gObjViewpo@6
$LN60@gObjViewpo@6:

; 13412: 	{
; 13413: 		for (n = 0; n < MAX_VIEWPORT_MONSTER; n++)

  003b2	8d 86 90 03 00
	00		 lea	 eax, DWORD PTR [esi+912]
$LL59@gObjViewpo@6:

; 13414: 		{
; 13415: 			if (lpObj->VpPlayer[n].state == 3)

  003b8	80 38 03	 cmp	 BYTE PTR [eax], 3
  003bb	75 0f		 jne	 SHORT $LN58@gObjViewpo@6

; 13416: 			{
; 13417: 				lpObj->VpPlayer[n].state = 0;
; 13418: 				lpObj->VpPlayer[n].number = -1;

  003bd	8b d7		 mov	 edx, edi
  003bf	c6 00 00	 mov	 BYTE PTR [eax], 0
  003c2	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 13419: 				lpObj->VPCount -= 1;

  003c6	01 be 98 0a 00
	00		 add	 DWORD PTR [esi+2712], edi
$LN58@gObjViewpo@6:

; 13414: 		{
; 13415: 			if (lpObj->VpPlayer[n].state == 3)

  003cc	80 78 0c 03	 cmp	 BYTE PTR [eax+12], 3
  003d0	75 10		 jne	 SHORT $LN105@gObjViewpo@6

; 13416: 			{
; 13417: 				lpObj->VpPlayer[n].state = 0;
; 13418: 				lpObj->VpPlayer[n].number = -1;

  003d2	8b d7		 mov	 edx, edi
  003d4	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  003d8	66 89 50 0e	 mov	 WORD PTR [eax+14], dx

; 13419: 				lpObj->VPCount -= 1;

  003dc	01 be 98 0a 00
	00		 add	 DWORD PTR [esi+2712], edi
$LN105@gObjViewpo@6:

; 13414: 		{
; 13415: 			if (lpObj->VpPlayer[n].state == 3)

  003e2	80 78 18 03	 cmp	 BYTE PTR [eax+24], 3
  003e6	75 10		 jne	 SHORT $LN106@gObjViewpo@6

; 13416: 			{
; 13417: 				lpObj->VpPlayer[n].state = 0;
; 13418: 				lpObj->VpPlayer[n].number = -1;

  003e8	8b d7		 mov	 edx, edi
  003ea	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0
  003ee	66 89 50 1a	 mov	 WORD PTR [eax+26], dx

; 13419: 				lpObj->VPCount -= 1;

  003f2	01 be 98 0a 00
	00		 add	 DWORD PTR [esi+2712], edi
$LN106@gObjViewpo@6:

; 13414: 		{
; 13415: 			if (lpObj->VpPlayer[n].state == 3)

  003f8	80 78 24 03	 cmp	 BYTE PTR [eax+36], 3
  003fc	75 10		 jne	 SHORT $LN107@gObjViewpo@6

; 13416: 			{
; 13417: 				lpObj->VpPlayer[n].state = 0;
; 13418: 				lpObj->VpPlayer[n].number = -1;

  003fe	8b d7		 mov	 edx, edi
  00400	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
  00404	66 89 50 26	 mov	 WORD PTR [eax+38], dx

; 13419: 				lpObj->VPCount -= 1;

  00408	01 be 98 0a 00
	00		 add	 DWORD PTR [esi+2712], edi
$LN107@gObjViewpo@6:

; 13414: 		{
; 13415: 			if (lpObj->VpPlayer[n].state == 3)

  0040e	80 78 30 03	 cmp	 BYTE PTR [eax+48], 3
  00412	75 10		 jne	 SHORT $LN108@gObjViewpo@6

; 13416: 			{
; 13417: 				lpObj->VpPlayer[n].state = 0;
; 13418: 				lpObj->VpPlayer[n].number = -1;

  00414	8b d7		 mov	 edx, edi
  00416	c6 40 30 00	 mov	 BYTE PTR [eax+48], 0
  0041a	66 89 50 32	 mov	 WORD PTR [eax+50], dx

; 13419: 				lpObj->VPCount -= 1;

  0041e	01 be 98 0a 00
	00		 add	 DWORD PTR [esi+2712], edi
$LN108@gObjViewpo@6:

; 13412: 	{
; 13413: 		for (n = 0; n < MAX_VIEWPORT_MONSTER; n++)

  00424	83 c0 3c	 add	 eax, 60			; 0000003cH
  00427	49		 dec	 ecx
  00428	75 8e		 jne	 SHORT $LL59@gObjViewpo@6
$LN104@gObjViewpo@6:

; 13420: 			}
; 13421: 		}
; 13422: 	}
; 13423: 
; 13424: 	if (lpObj->Type == OBJ_USER)

  0042a	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0042f	0f 85 ae 00 00
	00		 jne	 $LN53@gObjViewpo@6

; 13425: 	{
; 13426: 		if (count > 0)

  00435	80 bd db b1 ff
	ff 00		 cmp	 BYTE PTR _count$[ebp], 0
  0043c	76 49		 jbe	 SHORT $LN54@gObjViewpo@6

; 13427: 		{
; 13428: 			pCount.h.c = 0xC1;
; 13429: 			pCount.h.headcode = 0x14;
; 13430: 			pCount.h.size = lOfs;

  0043e	8b 85 c4 b1 ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]

; 13431: 			pCount.count = count;

  00444	8a 8d db b1 ff
	ff		 mov	 cl, BYTE PTR _count$[ebp]

; 13432: 
; 13433: 			memcpy(sendBuf, &pCount, sizeof(pCount));
; 13434: 			DataSend(aIndex, sendBuf, lOfs);

  0044a	50		 push	 eax
  0044b	88 85 c1 b1 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], al
  00451	88 8d c3 b1 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+3], cl
  00457	8b 8d bc b1 ff
	ff		 mov	 ecx, DWORD PTR tv1888[ebp]
  0045d	8d 85 74 ec ff
	ff		 lea	 eax, DWORD PTR _sendBuf$[ebp]
  00463	50		 push	 eax
  00464	c6 85 c0 b1 ff
	ff c1		 mov	 BYTE PTR _pCount$[ebp], 193 ; 000000c1H
  0046b	c6 85 c2 b1 ff
	ff 14		 mov	 BYTE PTR _pCount$[ebp+2], 20 ; 00000014H
  00472	8b 95 c0 b1 ff
	ff		 mov	 edx, DWORD PTR _pCount$[ebp]
  00478	51		 push	 ecx
  00479	89 95 74 ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp], edx
  0047f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00484	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN54@gObjViewpo@6:

; 13435: 		}
; 13436: 
; 13437: 		if (count_Item > 0)

  00487	83 bd c8 b1 ff
	ff 00		 cmp	 DWORD PTR _count_Item$[ebp], 0
  0048e	7e 53		 jle	 SHORT $LN53@gObjViewpo@6

; 13438: 		{
; 13439: 			pItemCount.h.c = 0xC2;
; 13440: 			pItemCount.h.headcode = 0x21;
; 13441: 			pItemCount.h.sizeH = SET_NUMBERH(lOfs_Item);
; 13442: 			pItemCount.h.sizeL = SET_NUMBERL(lOfs_Item);
; 13443: 			pItemCount.count = count_Item;

  00490	8a 85 c8 b1 ff
	ff		 mov	 al, BYTE PTR _count_Item$[ebp]
  00496	8b d3		 mov	 edx, ebx
  00498	c1 ea 08	 shr	 edx, 8
  0049b	88 15 01 00 00
	00		 mov	 BYTE PTR ?pItemCount@@3UPWMSG_COUNT@@A+1, dl

; 13444: 
; 13445: 			memcpy(ItemBuf, &pItemCount, sizeof(pItemCount));
; 13446: 			DataSend(aIndex, ItemBuf, lOfs_Item);

  004a1	53		 push	 ebx
  004a2	8d 95 ec d8 ff
	ff		 lea	 edx, DWORD PTR _ItemBuf$[ebp]
  004a8	a2 04 00 00 00	 mov	 BYTE PTR ?pItemCount@@3UPWMSG_COUNT@@A+4, al
  004ad	88 85 f0 d8 ff
	ff		 mov	 BYTE PTR _ItemBuf$[ebp+4], al
  004b3	8b 85 bc b1 ff
	ff		 mov	 eax, DWORD PTR tv1888[ebp]
  004b9	c6 05 00 00 00
	00 c2		 mov	 BYTE PTR ?pItemCount@@3UPWMSG_COUNT@@A, 194 ; 000000c2H
  004c0	c6 05 03 00 00
	00 21		 mov	 BYTE PTR ?pItemCount@@3UPWMSG_COUNT@@A+3, 33 ; 00000021H
  004c7	88 1d 02 00 00
	00		 mov	 BYTE PTR ?pItemCount@@3UPWMSG_COUNT@@A+2, bl
  004cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pItemCount@@3UPWMSG_COUNT@@A
  004d3	52		 push	 edx
  004d4	50		 push	 eax
  004d5	89 8d ec d8 ff
	ff		 mov	 DWORD PTR _ItemBuf$[ebp], ecx
  004db	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004e0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN53@gObjViewpo@6:

; 13447: 		}
; 13448: 	}
; 13449: 
; 13450: 	if (lpObj->Type == OBJ_MONSTER || lpObj->Type == OBJ_NPC)

  004e3	0f b7 46 60	 movzx	 eax, WORD PTR [esi+96]
  004e7	83 f8 02	 cmp	 eax, 2
  004ea	0f 84 df 09 00
	00		 je	 $LN51@gObjViewpo@6
  004f0	83 f8 03	 cmp	 eax, 3
  004f3	0f 84 d6 09 00
	00		 je	 $LN51@gObjViewpo@6

; 13457: 			}
; 13458: 		}
; 13459: 	}
; 13460: 	else
; 13461: 	{
; 13462: 		count = 0;

  004f9	32 d2		 xor	 dl, dl

; 13463: 		monstercount = 0;
; 13464: 		count_Item = 0;
; 13465: 		callmonstercount = 0;
; 13466: 		lOfs = 5;

  004fb	b9 05 00 00 00	 mov	 ecx, 5
  00500	88 95 db b1 ff
	ff		 mov	 BYTE PTR _count$[ebp], dl
  00506	88 95 ce b1 ff
	ff		 mov	 BYTE PTR _monstercount$[ebp], dl
  0050c	c7 85 c8 b1 ff
	ff 00 00 00 00	 mov	 DWORD PTR _count_Item$[ebp], 0
  00516	88 95 cf b1 ff
	ff		 mov	 BYTE PTR _callmonstercount$[ebp], dl
  0051c	89 8d c4 b1 ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], ecx

; 13467: 		MonlOfs = lOfs;

  00522	89 8d ac b1 ff
	ff		 mov	 DWORD PTR _MonlOfs$[ebp], ecx

; 13468: 		callMonlOfs = MonlOfs;

  00528	89 8d b8 b1 ff
	ff		 mov	 DWORD PTR _callMonlOfs$[ebp], ecx

; 13469: 		lOfs_Item = 5;

  0052e	89 8d c0 b1 ff
	ff		 mov	 DWORD PTR _lOfs_Item$[ebp], ecx

; 13470: 		pMsgSize = 44;
; 13471: 
; 13472: 		if (lpObj->Type == OBJ_USER)

  00534	83 f8 01	 cmp	 eax, 1
  00537	0f 85 5b 07 00
	00		 jne	 $LN42@gObjViewpo@6

; 13473: 		{
; 13474: 			for (n = 0; n < MAX_VIEWPORT; n++)

  0053d	8d bd f1 d8 ff
	ff		 lea	 edi, DWORD PTR _ItemBuf$[ebp+5]
  00543	8d 9d e1 b1 ff
	ff		 lea	 ebx, DWORD PTR _MonstersendBuf$[ebp+5]
  00549	8d 95 69 c5 ff
	ff		 lea	 edx, DWORD PTR _callMonstersendBuf$[ebp+5]
  0054f	8d 8d 79 ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp+5]
  00555	8d 86 90 03 00
	00		 lea	 eax, DWORD PTR [esi+912]
  0055b	89 bd b0 b1 ff
	ff		 mov	 DWORD PTR tv3276[ebp], edi
  00561	89 9d 9c b1 ff
	ff		 mov	 DWORD PTR tv3278[ebp], ebx
  00567	89 95 90 b1 ff
	ff		 mov	 DWORD PTR tv3280[ebp], edx
  0056d	89 8d 98 b1 ff
	ff		 mov	 DWORD PTR tv3282[ebp], ecx
  00573	89 85 94 b1 ff
	ff		 mov	 DWORD PTR tv3352[ebp], eax
  00579	c7 85 d0 b1 ff
	ff 4b 00 00 00	 mov	 DWORD PTR tv3397[ebp], 75 ; 0000004bH
$LL44@gObjViewpo@6:

; 13475: 			{
; 13476: 				if (lpObj->VpPlayer[n].state == 1)

  00583	80 38 01	 cmp	 BYTE PTR [eax], 1
  00586	0f 85 eb 06 00
	00		 jne	 $LN43@gObjViewpo@6

; 13477: 				{
; 13478: 					tObjNum = lpObj->VpPlayer[n].number;

  0058c	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]

; 13479: 
; 13480: 					if (tObjNum >= 0)

  00590	66 85 c9	 test	 cx, cx
  00593	0f 88 bd 06 00
	00		 js	 $LN11@gObjViewpo@6

; 13481: 					{
; 13482: 						switch (lpObj->VpPlayer[n].type)

  00599	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0059d	48		 dec	 eax
  0059e	83 f8 04	 cmp	 eax, 4
  005a1	0f 87 af 06 00
	00		 ja	 $LN11@gObjViewpo@6
  005a7	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN121@gObjViewpo@6[eax*4]
$LN37@gObjViewpo@6:

; 13483: 						{
; 13484: 						case 1:
; 13485: 							lpTargetObj = &gObj[tObjNum];

  005ae	0f bf f1	 movsx	 esi, cx
  005b1	8b de		 mov	 ebx, esi
  005b3	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  005b9	81 c3 00 00 00
	00		 add	 ebx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13486: 
; 13487: 							if (lpTargetObj->m_Change >= 0)
; 13488: 							{
; 13489: 								pViewportCreateChange.NumberH = SET_NUMBERH(tObjNum);
; 13490: 								pViewportCreateChange.NumberL = SET_NUMBERL(tObjNum);
; 13491: 
; 13492: 								lpTargetObj->CharSet[0] &= 0xF0;

  005bf	80 a3 50 03 00
	00 f0		 and	 BYTE PTR [ebx+848], 240	; 000000f0H
  005c6	8b d6		 mov	 edx, esi
  005c8	33 ff		 xor	 edi, edi
  005ca	c1 ea 08	 shr	 edx, 8
  005cd	39 bb d0 02 00
	00		 cmp	 DWORD PTR [ebx+720], edi
  005d3	0f 8c f8 00 00
	00		 jl	 $LN36@gObjViewpo@6

; 13493: 
; 13494: 								if (lpTargetObj->m_State == 1 && lpTargetObj->Teleport == 0)

  005d9	83 bb bc 01 00
	00 01		 cmp	 DWORD PTR [ebx+444], 1
  005e0	88 15 00 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A, dl
  005e6	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+1, cl
  005ec	75 10		 jne	 SHORT $LN35@gObjViewpo@6
  005ee	80 bb 00 02 00
	00 00		 cmp	 BYTE PTR [ebx+512], 0
  005f5	75 07		 jne	 SHORT $LN35@gObjViewpo@6

; 13495: 								{
; 13496: 									pViewportCreateChange.NumberH |= 0x80;

  005f7	80 0d 00 00 00
	00 80		 or	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A, 128 ; 00000080H
$LN35@gObjViewpo@6:

; 13497: 								}
; 13498: 								pViewportCreateChange.X = lpTargetObj->X;

  005fe	0f b6 83 04 01
	00 00		 movzx	 eax, BYTE PTR [ebx+260]

; 13499: 								pViewportCreateChange.Y = lpTargetObj->Y;

  00605	0f b6 8b 06 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+262]

; 13500: 								pViewportCreateChange.TX = lpTargetObj->TX;

  0060c	0f b6 93 20 01
	00 00		 movzx	 edx, BYTE PTR [ebx+288]
  00613	88 0d 03 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+3, cl

; 13501: 								pViewportCreateChange.TY = lpTargetObj->TY;
; 13502: 								pViewportCreateChange.SkinH = SET_NUMBERH((lpTargetObj->m_Change & 0xFFFF) & 0xFFFF);

  00619	0f b6 8b d1 02
	00 00		 movzx	 ecx, BYTE PTR [ebx+721]
  00620	a2 02 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+2, al
  00625	0f b6 83 22 01
	00 00		 movzx	 eax, BYTE PTR [ebx+290]
  0062c	88 15 16 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+22, dl

; 13503: 								pViewportCreateChange.SkinL = SET_NUMBERL((lpTargetObj->m_Change & 0xFFFF) & 0xFFFF);

  00632	0f b6 93 d0 02
	00 00		 movzx	 edx, BYTE PTR [ebx+720]
  00639	88 0d 04 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+4, cl

; 13504: 								pViewportCreateChange.ViewSkillState = lpTargetObj->m_ViewSkillState;
; 13505: 								pViewportCreateChange.DirAndPkLevel = lpTargetObj->Dir << 4;
; 13506: 								pViewportCreateChange.DirAndPkLevel |= lpTargetObj->m_PK_Level & 0x0F;

  0063f	0f b6 8b fd 00
	00 00		 movzx	 ecx, BYTE PTR [ebx+253]
  00646	a2 17 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+23, al
  0064b	8b 83 c4 01 00
	00		 mov	 eax, DWORD PTR [ebx+452]
  00651	88 15 05 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+5, dl
  00657	0f b6 93 08 01
	00 00		 movzx	 edx, BYTE PTR [ebx+264]
  0065e	a3 08 00 00 00	 mov	 DWORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+8, eax

; 13507: 								if (CC_MAP_RANGE(lpTargetObj->MapNumber))

  00663	0f b6 83 09 01
	00 00		 movzx	 eax, BYTE PTR [ebx+265]
  0066a	80 e1 0f	 and	 cl, 15			; 0000000fH
  0066d	c0 e2 04	 shl	 dl, 4
  00670	0a ca		 or	 cl, dl
  00672	88 0d 18 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+24, cl
  00678	3c 12		 cmp	 al, 18			; 00000012H
  0067a	72 11		 jb	 SHORT $LN34@gObjViewpo@6
  0067c	b1 17		 mov	 cl, 23			; 00000017H
  0067e	3a c8		 cmp	 cl, al
  00680	1b c0		 sbb	 eax, eax
  00682	40		 inc	 eax
  00683	3b c7		 cmp	 eax, edi
  00685	74 06		 je	 SHORT $LN34@gObjViewpo@6

; 13508: 								{
; 13509: 									pViewportCreateChange.ViewSkillState = 0;

  00687	89 3d 08 00 00
	00		 mov	 DWORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+8, edi
$LN34@gObjViewpo@6:

; 13510: 								}
; 13511: 
; 13512: #if(GS_CASTLE==1)
; 13513: 								//CastleSiege ViewPort of ViewSkillState
; 13514: 								if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)
; 13515: 								{
; 13516: 									BYTE btJoinSide = lpTargetObj->m_btCsJoinSide;
; 13517: 
; 13518: 									if (btJoinSide < 0)
; 13519: 									{
; 13520: 										btJoinSide = 0;
; 13521: 									}
; 13522: 
; 13523: 									if (btJoinSide > 2)
; 13524: 									{
; 13525: 										btJoinSide = 2;
; 13526: 									}
; 13527: 
; 13528: 									switch (btJoinSide)
; 13529: 									{
; 13530: 									case 1:
; 13531: 										pViewportCreateChange.ViewSkillState |= 0x40000;
; 13532: 										lpTargetObj->m_ViewSkillState |= 0x40000;
; 13533: 										break;
; 13534: 									case 2:
; 13535: 										{
; 13536: 											int iViewSkillState = 0;
; 13537: 
; 13538: 											if (lpTargetObj->m_btCsJoinSide == 2)
; 13539: 											{
; 13540: 												iViewSkillState = 0x80000;
; 13541: 											}
; 13542: 											else if (lpTargetObj->m_btCsJoinSide == 3)
; 13543: 											{
; 13544: 												iViewSkillState = 0x400000;
; 13545: 											}
; 13546: 											else if (lpTargetObj->m_btCsJoinSide == 4)
; 13547: 											{
; 13548: 												iViewSkillState = 0x800000;
; 13549: 											}
; 13550: 											pViewportCreateChange.ViewSkillState |= iViewSkillState;
; 13551: 											lpTargetObj->m_ViewSkillState |= iViewSkillState;
; 13552: 										}
; 13553: 										break;
; 13554: 									default:
; 13555: 										{
; 13556: 											pViewportCreateChange.ViewSkillState &= 0xFFF3FFFF;
; 13557: 											lpTargetObj->m_ViewSkillState &= 0xFFF3FFFF;
; 13558: 											pViewportCreateChange.ViewSkillState &= 0xFF3FFFFF; //HermeX Fix
; 13559: 											lpTargetObj->m_ViewSkillState &= 0xFF3FFFFF; //HermeX Fix
; 13560: 										}
; 13561: 										break;
; 13562: 									}
; 13563: 								}
; 13564: #endif
; 13565: 
; 13566: 								memcpy(pViewportCreateChange.Id, lpTargetObj->Name, sizeof(pViewportCreateChange.Id));

  0068d	8b 43 73	 mov	 eax, DWORD PTR [ebx+115]
  00690	66 8b 4b 77	 mov	 cx, WORD PTR [ebx+119]
  00694	8b 53 6f	 mov	 edx, DWORD PTR [ebx+111]
  00697	a3 10 00 00 00	 mov	 DWORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+16, eax

; 13567: 								memcpy(&SendGBufChange[lOfsChange], &pViewportCreateChange, sizeof(pViewportCreateChange));

  0069c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lOfsChange@@3HA ; lOfsChange
  006a1	8d b8 00 00 00
	00		 lea	 edi, DWORD PTR ?SendGBufChange@@3PAEA[eax]

; 13568: 								lOfsChange += sizeof(pViewportCreateChange);

  006a7	83 c0 1c	 add	 eax, 28			; 0000001cH

; 13569: 								ChangeCount += 1;

  006aa	ff 05 00 00 00
	00		 inc	 DWORD PTR ?ChangeCount@@3HA ; ChangeCount
  006b0	66 89 0d 14 00
	00 00		 mov	 WORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+20, cx
  006b7	89 15 0c 00 00
	00		 mov	 DWORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+12, edx
  006bd	b9 07 00 00 00	 mov	 ecx, 7
  006c2	be 00 00 00 00	 mov	 esi, OFFSET ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A ; pViewportCreateChange
  006c7	a3 00 00 00 00	 mov	 DWORD PTR ?lOfsChange@@3HA, eax ; lOfsChange

; 13570: 							}
; 13571: 							else

  006cc	e9 33 01 00 00	 jmp	 $LN119@gObjViewpo@6
$LN36@gObjViewpo@6:

; 13572: 							{
; 13573: 								pViewportCreate.NumberH = SET_NUMBERH(tObjNum);
; 13574: 								pViewportCreate.NumberL = SET_NUMBERL(tObjNum);
; 13575: 
; 13576: 								lpTargetObj->CharSet[0] &= 0xF0;
; 13577: 
; 13578: 								if (lpTargetObj->m_State == 1 && lpTargetObj->Teleport == 0)

  006d1	83 bb bc 01 00
	00 01		 cmp	 DWORD PTR [ebx+444], 1
  006d8	8a 83 50 03 00
	00		 mov	 al, BYTE PTR [ebx+848]
  006de	88 15 00 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A, dl
  006e4	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+1, cl
  006ea	75 10		 jne	 SHORT $LN32@gObjViewpo@6
  006ec	80 bb 00 02 00
	00 00		 cmp	 BYTE PTR [ebx+512], 0
  006f3	75 07		 jne	 SHORT $LN32@gObjViewpo@6

; 13579: 								{
; 13580: 									pViewportCreate.NumberH |= 0x80;

  006f5	80 0d 00 00 00
	00 80		 or	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A, 128 ; 00000080H
$LN32@gObjViewpo@6:

; 13581: 								}
; 13582: 
; 13583: 								pViewportCreate.ViewSkillState = lpTargetObj->m_ViewSkillState;
; 13584: 								lpTargetObj->CharSet[0] |= lpTargetObj->m_ViewState & 0x0F;

  006fc	0f b6 93 c2 01
	00 00		 movzx	 edx, BYTE PTR [ebx+450]
  00703	8b 8b c4 01 00
	00		 mov	 ecx, DWORD PTR [ebx+452]
  00709	80 e2 0f	 and	 dl, 15			; 0000000fH
  0070c	0a d0		 or	 dl, al

; 13585: 
; 13586: 								pViewportCreate.X = lpTargetObj->X;

  0070e	0f b6 83 04 01
	00 00		 movzx	 eax, BYTE PTR [ebx+260]
  00715	89 0d 18 00 00
	00		 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+24, ecx

; 13587: 								pViewportCreate.Y = lpTargetObj->Y;

  0071b	0f b6 8b 06 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+262]
  00722	88 93 50 03 00
	00		 mov	 BYTE PTR [ebx+848], dl

; 13588: 								pViewportCreate.TX = lpTargetObj->TX;

  00728	0f b6 93 20 01
	00 00		 movzx	 edx, BYTE PTR [ebx+288]
  0072f	a2 02 00 00 00	 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+2, al

; 13589: 								pViewportCreate.TY = lpTargetObj->TY;

  00734	0f b6 83 22 01
	00 00		 movzx	 eax, BYTE PTR [ebx+290]
  0073b	88 0d 03 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+3, cl

; 13590: 
; 13591: 								pViewportCreate.DirAndPkLevel = lpTargetObj->Dir << 4;
; 13592: 								pViewportCreate.DirAndPkLevel |= lpTargetObj->m_PK_Level & 0x0F;

  00741	0f b6 8b fd 00
	00 00		 movzx	 ecx, BYTE PTR [ebx+253]
  00748	88 15 26 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+38, dl
  0074e	0f b6 93 08 01
	00 00		 movzx	 edx, BYTE PTR [ebx+264]
  00755	a2 27 00 00 00	 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+39, al

; 13593: 								if (CC_MAP_RANGE(lpTargetObj->MapNumber))

  0075a	0f b6 83 09 01
	00 00		 movzx	 eax, BYTE PTR [ebx+265]
  00761	80 e1 0f	 and	 cl, 15			; 0000000fH
  00764	c0 e2 04	 shl	 dl, 4
  00767	0a ca		 or	 cl, dl
  00769	88 0d 28 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+40, cl
  0076f	3c 12		 cmp	 al, 18			; 00000012H
  00771	72 11		 jb	 SHORT $LN31@gObjViewpo@6
  00773	b1 17		 mov	 cl, 23			; 00000017H
  00775	3a c8		 cmp	 cl, al
  00777	1b c0		 sbb	 eax, eax
  00779	40		 inc	 eax
  0077a	3b c7		 cmp	 eax, edi
  0077c	74 06		 je	 SHORT $LN31@gObjViewpo@6

; 13594: 								{
; 13595: 									pViewportCreate.ViewSkillState = 0;

  0077e	89 3d 18 00 00
	00		 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+24, edi
$LN31@gObjViewpo@6:

; 13596: 								}
; 13597: 
; 13598: #if(GS_CASTLE==1)
; 13599: 								//CastleSiege ViewPort of ViewSkillState
; 13600: 								if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)
; 13601: 								{
; 13602: 									BYTE btJoinSide = lpTargetObj->m_btCsJoinSide;
; 13603: 
; 13604: 									if (btJoinSide < 0)
; 13605: 									{
; 13606: 										btJoinSide = 0;
; 13607: 									}
; 13608: 
; 13609: 									if (btJoinSide > 2)
; 13610: 									{
; 13611: 										btJoinSide = 2;
; 13612: 									}
; 13613: 
; 13614: 									switch (btJoinSide)
; 13615: 									{
; 13616: 									case 1:
; 13617: 										pViewportCreate.ViewSkillState |= 0x40000; //HermeX Fix
; 13618: 										lpTargetObj->m_ViewSkillState |= 0x40000;
; 13619: 										break;
; 13620: 									case 2:
; 13621: 										{
; 13622: 											int iViewSkillState = 0;
; 13623: 
; 13624: 											if (lpTargetObj->m_btCsJoinSide == 2)
; 13625: 											{
; 13626: 												iViewSkillState = 0x80000;
; 13627: 											}
; 13628: 											else if (lpTargetObj->m_btCsJoinSide == 3)
; 13629: 											{
; 13630: 												iViewSkillState = 0x400000;
; 13631: 											}
; 13632: 											else if (lpTargetObj->m_btCsJoinSide == 4)
; 13633: 											{
; 13634: 												iViewSkillState = 0x800000;
; 13635: 											}
; 13636: 											pViewportCreate.ViewSkillState |= iViewSkillState; //HermeX Fix
; 13637: 											lpTargetObj->m_ViewSkillState |= iViewSkillState;
; 13638: 										}
; 13639: 										break;
; 13640: 									default:
; 13641: 										{
; 13642: 											pViewportCreate.ViewSkillState &= 0xFFF3FFFF; //HermeX Fix
; 13643: 											lpTargetObj->m_ViewSkillState &= 0xFFF3FFFF;
; 13644: 											pViewportCreate.ViewSkillState &= 0xFF3FFFFF; //HermeX Fix
; 13645: 											lpTargetObj->m_ViewSkillState &= 0xFF3FFFFF; //HermeX Fix
; 13646: 										}
; 13647: 										break;
; 13648: 									}
; 13649: 								}
; 13650: #endif
; 13651: 
; 13652: 								memcpy(pViewportCreate.CharSet, lpTargetObj->CharSet, sizeof(pViewportCreate.CharSet));

  00784	8b 83 54 03 00
	00		 mov	 eax, DWORD PTR [ebx+852]
  0078a	8b 93 50 03 00
	00		 mov	 edx, DWORD PTR [ebx+848]
  00790	8b 8b 58 03 00
	00		 mov	 ecx, DWORD PTR [ebx+856]

; 13653: 								memcpy(pViewportCreate.Id, lpTargetObj->Name, sizeof(pViewportCreate.Id));
; 13654: 								memcpy(&sendBuf[lOfs], &pViewportCreate, sizeof(pViewportCreate));
; 13655: 
; 13656: 								lOfs += sizeof(pViewportCreate);

  00796	83 85 c4 b1 ff
	ff 2c		 add	 DWORD PTR _lOfs$[ebp], 44 ; 0000002cH
  0079d	a3 08 00 00 00	 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+8, eax
  007a2	0f b7 83 60 03
	00 00		 movzx	 eax, WORD PTR [ebx+864]
  007a9	66 a3 14 00 00
	00		 mov	 WORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+20, ax
  007af	0f b7 43 77	 movzx	 eax, WORD PTR [ebx+119]
  007b3	89 15 04 00 00
	00		 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+4, edx
  007b9	8b 93 5c 03 00
	00		 mov	 edx, DWORD PTR [ebx+860]
  007bf	66 a3 24 00 00
	00		 mov	 WORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+36, ax
  007c5	8b 85 98 b1 ff
	ff		 mov	 eax, DWORD PTR tv3282[ebp]
  007cb	89 0d 0c 00 00
	00		 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+12, ecx
  007d1	8b 4b 6f	 mov	 ecx, DWORD PTR [ebx+111]
  007d4	89 15 10 00 00
	00		 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+16, edx
  007da	8b 53 73	 mov	 edx, DWORD PTR [ebx+115]
  007dd	8b f8		 mov	 edi, eax
  007df	83 c0 2c	 add	 eax, 44			; 0000002cH

; 13657: 								count += 1;

  007e2	fe 85 db b1 ff
	ff		 inc	 BYTE PTR _count$[ebp]
  007e8	89 0d 1c 00 00
	00		 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+28, ecx
  007ee	89 15 20 00 00
	00		 mov	 DWORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+32, edx
  007f4	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  007f9	be 00 00 00 00	 mov	 esi, OFFSET ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A ; pViewportCreate
  007fe	89 85 98 b1 ff
	ff		 mov	 DWORD PTR tv3282[ebp], eax
$LN119@gObjViewpo@6:

; 13658: 							}
; 13659: 
; 13660: 							if (lpObj->Type == OBJ_USER)

  00804	f3 a5		 rep movsd
  00806	8b 8d b4 b1 ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0080c	66 83 79 60 01	 cmp	 WORD PTR [ecx+96], 1
  00811	0f 85 3f 04 00
	00		 jne	 $LN11@gObjViewpo@6

; 13661: 							{
; 13662: 								if (lpTargetObj->lpGuild != 0)

  00817	8b 83 b4 02 00
	00		 mov	 eax, DWORD PTR [ebx+692]
  0081d	85 c0		 test	 eax, eax
  0081f	0f 84 31 04 00
	00		 je	 $LN11@gObjViewpo@6

; 13663: 								{
; 13664: 									PMSG_SIMPLE_GUILDVIEWPORT pGuild;
; 13665: 
; 13666: 									pGuild.GuildNumber = lpTargetObj->lpGuild->Number;
; 13667: 									pGuild.NumberH = SET_NUMBERH(lpTargetObj->m_Index) & 0x7F;

  00825	8b 13		 mov	 edx, DWORD PTR [ebx]

; 13668: 									pGuild.NumberL = SET_NUMBERL(lpTargetObj->m_Index);

  00827	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00829	8b 30		 mov	 esi, DWORD PTR [eax]

; 13669: 
; 13670: 									pGuild.btGuildStatus = lpTargetObj->GuildStatus;
; 13671: 									pGuild.btGuildType = lpTargetObj->lpGuild->btGuildType;

  0082b	8a 80 18 07 00
	00		 mov	 al, BYTE PTR [eax+1816]
  00831	c1 ea 08	 shr	 edx, 8
  00834	80 e2 7f	 and	 dl, 127			; 0000007fH
  00837	88 8d a8 b1 ff
	ff		 mov	 BYTE PTR _pGuild$166590[ebp+8], cl

; 13672: 
; 13673: 									if (lpObj->lpGuild != 0)

  0083d	8b 8d b4 b1 ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00843	83 b9 b4 02 00
	00 00		 cmp	 DWORD PTR [ecx+692], 0
  0084a	88 95 a7 b1 ff
	ff		 mov	 BYTE PTR _pGuild$166590[ebp+7], dl
  00850	8a 93 c4 02 00
	00		 mov	 dl, BYTE PTR [ebx+708]
  00856	88 95 a4 b1 ff
	ff		 mov	 BYTE PTR _pGuild$166590[ebp+4], dl
  0085c	88 85 a5 b1 ff
	ff		 mov	 BYTE PTR _pGuild$166590[ebp+5], al
  00862	74 14		 je	 SHORT $LN28@gObjViewpo@6

; 13674: 									{
; 13675: 										pGuild.btGuildRelationShip = gObjGetRelationShip(lpObj, lpTargetObj);

  00864	8b d1		 mov	 edx, ecx
  00866	53		 push	 ebx
  00867	52		 push	 edx
  00868	e8 00 00 00 00	 call	 ?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjGetRelationShip
  0086d	83 c4 08	 add	 esp, 8
  00870	88 85 a6 b1 ff
	ff		 mov	 BYTE PTR _pGuild$166590[ebp+6], al

; 13676: 									}
; 13677: 									else

  00876	eb 07		 jmp	 SHORT $LN27@gObjViewpo@6
$LN28@gObjViewpo@6:

; 13678: 									{
; 13679: 										pGuild.btGuildRelationShip = 0;

  00878	c6 85 a6 b1 ff
	ff 00		 mov	 BYTE PTR _pGuild$166590[ebp+6], 0
$LN27@gObjViewpo@6:

; 13680: 									}
; 13681: 
; 13682: 									if (strcmp(lpTargetObj->lpGuild->Names[0], lpTargetObj->Name) == 0)

  0087f	8d 43 6f	 lea	 eax, DWORD PTR [ebx+111]
  00882	8b 9b b4 02 00
	00		 mov	 ebx, DWORD PTR [ebx+692]
  00888	83 c3 2f	 add	 ebx, 47			; 0000002fH
  0088b	eb 03 8d 49 00	 npad	 5
$LL109@gObjViewpo@6:
  00890	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00892	3a 08		 cmp	 cl, BYTE PTR [eax]
  00894	75 1a		 jne	 SHORT $LN110@gObjViewpo@6
  00896	84 c9		 test	 cl, cl
  00898	74 12		 je	 SHORT $LN111@gObjViewpo@6
  0089a	8a 4b 01	 mov	 cl, BYTE PTR [ebx+1]
  0089d	3a 48 01	 cmp	 cl, BYTE PTR [eax+1]
  008a0	75 0e		 jne	 SHORT $LN110@gObjViewpo@6
  008a2	83 c3 02	 add	 ebx, 2
  008a5	83 c0 02	 add	 eax, 2
  008a8	84 c9		 test	 cl, cl
  008aa	75 e4		 jne	 SHORT $LL109@gObjViewpo@6
$LN111@gObjViewpo@6:
  008ac	33 c0		 xor	 eax, eax
  008ae	eb 05		 jmp	 SHORT $LN112@gObjViewpo@6
$LN110@gObjViewpo@6:
  008b0	1b c0		 sbb	 eax, eax
  008b2	83 d8 ff	 sbb	 eax, -1
$LN112@gObjViewpo@6:
  008b5	85 c0		 test	 eax, eax
  008b7	75 07		 jne	 SHORT $LN26@gObjViewpo@6

; 13683: 									{
; 13684: 										pGuild.NumberH |= 0x80;

  008b9	80 8d a7 b1 ff
	ff 80		 or	 BYTE PTR _pGuild$166590[ebp+7], 128 ; 00000080H
$LN26@gObjViewpo@6:

; 13685: 									}
; 13686: 
; 13687: 									memcpy(&GuildInfoBuf[GuildInfoOfs], &pGuild, sizeof(pGuild));

  008c0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildInfoOfs@@3HA ; GuildInfoOfs
  008c5	8b 8d a4 b1 ff
	ff		 mov	 ecx, DWORD PTR _pGuild$166590[ebp+4]
  008cb	8b 95 a8 b1 ff
	ff		 mov	 edx, DWORD PTR _pGuild$166590[ebp+8]
  008d1	89 b0 00 00 00
	00		 mov	 DWORD PTR ?GuildInfoBuf@@3PAEA[eax], esi
  008d7	89 88 04 00 00
	00		 mov	 DWORD PTR ?GuildInfoBuf@@3PAEA[eax+4], ecx
  008dd	89 90 08 00 00
	00		 mov	 DWORD PTR ?GuildInfoBuf@@3PAEA[eax+8], edx

; 13688: 									GuildInfoOfs += sizeof(pGuild);

  008e3	83 c0 0c	 add	 eax, 12			; 0000000cH

; 13689: 									GuildInfoCount += 1;

  008e6	ff 05 00 00 00
	00		 inc	 DWORD PTR ?GuildInfoCount@@3HA ; GuildInfoCount
  008ec	a3 00 00 00 00	 mov	 DWORD PTR ?GuildInfoOfs@@3HA, eax ; GuildInfoOfs

; 13690: 								}
; 13691: 
; 13692: 								if (false)
; 13693: 								{
; 13694: 									PMSG_GUILDVIEWPORT_USER pGuildUserViewport;
; 13695: 
; 13696: 									if (ViewGuildMng.Add(lpTargetObj->GuildNumber, lpTargetObj->m_Index) == 1 && lpTargetObj->lpGuild != 0)
; 13697: 									{
; 13698: 										PMSG_GUILDVIEWPORT pGuildViewport;
; 13699: 
; 13700: 										pGuildViewport.NumberH = SET_NUMBERH(lpTargetObj->lpGuild->Number);
; 13701: 										pGuildViewport.NumberL = SET_NUMBERL(lpTargetObj->lpGuild->Number);
; 13702: 
; 13703: 										strcpy(pGuildViewport.GuildName, lpTargetObj->lpGuild->Name);
; 13704: 										memcpy(pGuildViewport.Mark, lpTargetObj->lpGuild->Mark, sizeof(pGuildViewport.Mark));
; 13705: 										memcpy(&GuildInfoBuf[GuildInfoOfs], &pGuildViewport, sizeof(pGuildViewport));
; 13706: 
; 13707: 										GuildInfoOfs += sizeof(pGuildViewport);
; 13708: 										GuildInfoCount += 1;
; 13709: 									}
; 13710: 
; 13711: 									pGuildUserViewport.NumberH = SET_NUMBERH(lpTargetObj->m_Index) & 0x7F;
; 13712: 									pGuildUserViewport.NumberL = SET_NUMBERL(lpTargetObj->m_Index);
; 13713: 
; 13714: 									if (lpTargetObj->lpGuild != 0 && strcmp(lpTargetObj->lpGuild->Names[0], lpTargetObj->Name) == 0)
; 13715: 									{
; 13716: 										pGuildUserViewport.NumberH |= 0x80;
; 13717: 									}
; 13718: 
; 13719: 									if (lpTargetObj->lpGuild != 0)
; 13720: 									{
; 13721: 										pGuildUserViewport.GNumberH = SET_NUMBERH(lpTargetObj->lpGuild->Number);
; 13722: 										pGuildUserViewport.GNumberL = SET_NUMBERL(lpTargetObj->lpGuild->Number);
; 13723: 
; 13724: 										memcpy(&GuildUserBuf[GuildUserOfs], &pGuildUserViewport, sizeof(pGuildUserViewport));
; 13725: 
; 13726: 										GuildUserOfs += sizeof(pGuildUserViewport);
; 13727: 										GuildUserCount += 1;
; 13728: 									}
; 13729: 								}
; 13730: 							}
; 13731: 							break;

  008f1	e9 60 03 00 00	 jmp	 $LN11@gObjViewpo@6
$LN21@gObjViewpo@6:

; 13732: 						case 2:
; 13733: 						case 3:
; 13734: 							if (lpObj->Type == OBJ_USER)

  008f6	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  008fb	0f 85 55 03 00
	00		 jne	 $LN11@gObjViewpo@6

; 13735: 							{
; 13736: 								lpTargetObj = &gObj[tObjNum];

  00901	0f bf f9	 movsx	 edi, cx
  00904	8b c7		 mov	 eax, edi
  00906	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0090c	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13737: 
; 13738: 								if (lpTargetObj->m_RecallMon >= 0)

  00911	8b b0 cc 02 00
	00		 mov	 esi, DWORD PTR [eax+716]
  00917	85 f6		 test	 esi, esi
  00919	0f 88 0e 01 00
	00		 js	 $LN19@gObjViewpo@6

; 13739: 								{
; 13740: 									pCallMonsterViewportCreate.NumberH = SET_NUMBERH(tObjNum);

  0091f	8b df		 mov	 ebx, edi
  00921	c1 eb 08	 shr	 ebx, 8

; 13741: 									pCallMonsterViewportCreate.NumberL = SET_NUMBERL(tObjNum);
; 13742: 
; 13743: 									if (lpTargetObj->m_State == 1)

  00924	83 b8 bc 01 00
	00 01		 cmp	 DWORD PTR [eax+444], 1
  0092b	88 1d 00 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A, bl
  00931	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+1, cl
  00937	75 07		 jne	 SHORT $LN18@gObjViewpo@6

; 13744: 									{
; 13745: 										pCallMonsterViewportCreate.NumberH |= 0x80;

  00939	80 0d 00 00 00
	00 80		 or	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A, 128 ; 00000080H
$LN18@gObjViewpo@6:

; 13746: 									}
; 13747: 
; 13748: 									pCallMonsterViewportCreate.Type_HI = SET_NUMBERH(lpTargetObj->Class);

  00940	0f b6 88 99 00
	00 00		 movzx	 ecx, BYTE PTR [eax+153]

; 13749: 									pCallMonsterViewportCreate.Type_LO = SET_NUMBERL(lpTargetObj->Class);
; 13750: 
; 13751: 									pCallMonsterViewportCreate.ViewState = lpTargetObj->m_ViewSkillState;

  00947	8b b8 c4 01 00
	00		 mov	 edi, DWORD PTR [eax+452]
  0094d	88 0d 02 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+2, cl
  00953	0f b6 88 98 00
	00 00		 movzx	 ecx, BYTE PTR [eax+152]
  0095a	88 0d 03 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+3, cl

; 13752: 									pCallMonsterViewportCreate.X = lpTargetObj->X;

  00960	0f b6 88 04 01
	00 00		 movzx	 ecx, BYTE PTR [eax+260]
  00967	88 0d 08 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+8, cl

; 13753: 									pCallMonsterViewportCreate.Y = lpTargetObj->Y;

  0096d	0f b6 88 06 01
	00 00		 movzx	 ecx, BYTE PTR [eax+262]
  00974	88 0d 09 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+9, cl

; 13754: 									pCallMonsterViewportCreate.TX = lpTargetObj->TX;

  0097a	0f b6 88 20 01
	00 00		 movzx	 ecx, BYTE PTR [eax+288]
  00981	88 0d 0a 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+10, cl

; 13755: 									pCallMonsterViewportCreate.TY = lpTargetObj->TY;

  00987	0f b6 88 22 01
	00 00		 movzx	 ecx, BYTE PTR [eax+290]

; 13756: 									pCallMonsterViewportCreate.Path = lpTargetObj->Dir << 4;

  0098e	8a 80 08 01 00
	00		 mov	 al, BYTE PTR [eax+264]
  00994	c0 e0 04	 shl	 al, 4
  00997	89 3d 04 00 00
	00		 mov	 DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+4, edi
  0099d	88 0d 0b 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+11, cl
  009a3	a2 0c 00 00 00	 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+12, al

; 13757: 
; 13758: 									if (lpTargetObj->m_RecallMon >= 0 && lpTargetObj->m_RecallMon < OBJMAX - 1)

  009a8	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  009ae	7d 24		 jge	 SHORT $LN17@gObjViewpo@6

; 13759: 									{
; 13760: 										memcpy(pCallMonsterViewportCreate.Id, gObj[lpTargetObj->m_RecallMon].Name, sizeof(pCallMonsterViewportCreate.Id));

  009b0	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  009b6	81 c6 6f 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+111
  009bc	8b 0e		 mov	 ecx, DWORD PTR [esi]
  009be	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  009c1	89 0d 0d 00 00
	00		 mov	 DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+13, ecx
  009c7	66 8b 4e 08	 mov	 cx, WORD PTR [esi+8]
  009cb	66 89 0d 15 00
	00 00		 mov	 WORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+21, cx

; 13761: 									}
; 13762: 									else

  009d2	eb 0d		 jmp	 SHORT $LN120@gObjViewpo@6
$LN17@gObjViewpo@6:

; 13763: 									{
; 13764: 										memset(pCallMonsterViewportCreate.Id, 0x00, sizeof(pCallMonsterViewportCreate.Id));

  009d4	33 c0		 xor	 eax, eax
  009d6	a3 0d 00 00 00	 mov	 DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+13, eax
  009db	66 a3 15 00 00
	00		 mov	 WORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+21, ax
$LN120@gObjViewpo@6:

; 13765: 									}
; 13766: 
; 13767: 									memcpy(&callMonstersendBuf[callMonlOfs], &pCallMonsterViewportCreate, sizeof(pCallMonsterViewportCreate));

  009e1	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+8

; 13768: 									callMonlOfs += sizeof(pCallMonsterViewportCreate);

  009e7	83 85 b8 b1 ff
	ff 18		 add	 DWORD PTR _callMonlOfs$[ebp], 24 ; 00000018H
  009ee	a3 11 00 00 00	 mov	 DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+17, eax
  009f3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A
  009f8	89 02		 mov	 DWORD PTR [edx], eax
  009fa	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+12
  009ff	89 7a 04	 mov	 DWORD PTR [edx+4], edi
  00a02	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00a05	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+16
  00a0b	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00a0e	a1 14 00 00 00	 mov	 eax, DWORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+20
  00a13	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  00a16	89 42 14	 mov	 DWORD PTR [edx+20], eax
  00a19	83 c2 18	 add	 edx, 24			; 00000018H

; 13769: 									callmonstercount += 1;

  00a1c	fe 85 cf b1 ff
	ff		 inc	 BYTE PTR _callmonstercount$[ebp]
  00a22	89 95 90 b1 ff
	ff		 mov	 DWORD PTR tv3280[ebp], edx

; 13770: 								}
; 13771: 								else

  00a28	e9 29 02 00 00	 jmp	 $LN11@gObjViewpo@6
$LN19@gObjViewpo@6:

; 13772: 								{
; 13773: 									pMonsterViewportCreate.NumberH = SET_NUMBERH(tObjNum);

  00a2d	8b d7		 mov	 edx, edi
  00a2f	c1 ea 08	 shr	 edx, 8

; 13774: 									pMonsterViewportCreate.NumberL = SET_NUMBERL(tObjNum);
; 13775: 
; 13776: 									if (lpTargetObj->m_State == 1)

  00a32	83 b8 bc 01 00
	00 01		 cmp	 DWORD PTR [eax+444], 1
  00a39	88 15 00 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A, dl
  00a3f	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+1, cl
  00a45	75 17		 jne	 SHORT $LN13@gObjViewpo@6

; 13777: 									{
; 13778: 										pMonsterViewportCreate.NumberH |= 0x80;

  00a47	80 0d 00 00 00
	00 80		 or	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A, 128 ; 00000080H

; 13779: 
; 13780: 										if (lpTargetObj->Teleport != 0)

  00a4e	80 b8 00 02 00
	00 00		 cmp	 BYTE PTR [eax+512], 0
  00a55	74 07		 je	 SHORT $LN13@gObjViewpo@6

; 13781: 										{
; 13782: 											pMonsterViewportCreate.NumberH |= 0x40;

  00a57	80 0d 00 00 00
	00 40		 or	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A, 64 ; 00000040H
$LN13@gObjViewpo@6:

; 13783: 										}
; 13784: 									}
; 13785: 
; 13786: 									pMonsterViewportCreate.Type_HI = SET_NUMBERH(lpTargetObj->Class);

  00a5e	0f b6 88 99 00
	00 00		 movzx	 ecx, BYTE PTR [eax+153]

; 13787: 									pMonsterViewportCreate.Type_LO = SET_NUMBERL(lpTargetObj->Class);

  00a65	0f b6 90 98 00
	00 00		 movzx	 edx, BYTE PTR [eax+152]

; 13788: 
; 13789: #if(GS_CASTLE==1)
; 13790: 									if (lpTargetObj->Class == 278) //LifeStone ViewPort of ViewSkillState
; 13791: 									{
; 13792: 										if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)
; 13793: 										{
; 13794: 											if (lpObj->m_btCsJoinSide == lpTargetObj->m_btCsJoinSide) //HermeX Fix
; 13795: 											{
; 13796: 												pMonsterViewportCreate.Type_HI |= 0x80; //HermeX Fix
; 13797: 											}
; 13798: 										}
; 13799: 										if (lpObj->lpGuild && lpTargetObj->lpGuild) //HermeX Fix
; 13800: 										{
; 13801: 											if (lpObj->lpGuild == lpTargetObj->lpGuild) //HermeX Fix
; 13802: 											{
; 13803: 												pMonsterViewportCreate.Type_HI |= 0x80; //HermeX Fix
; 13804: 											}
; 13805: 										}
; 13806: 										pMonsterViewportCreate.Type_HI |= (lpTargetObj->m_btCreationState << 4 & 0x70); //HermeX Fix
; 13807: 									}
; 13808: #endif
; 13809: 
; 13810: 									pMonsterViewportCreate.ViewState = lpTargetObj->m_ViewSkillState;

  00a6c	8b b0 c4 01 00
	00		 mov	 esi, DWORD PTR [eax+452]

; 13811: 									pMonsterViewportCreate.X = lpTargetObj->X;
; 13812: 									pMonsterViewportCreate.Y = lpTargetObj->Y;
; 13813: 									pMonsterViewportCreate.TX = lpTargetObj->TX;
; 13814: 									pMonsterViewportCreate.TY = lpTargetObj->TY;
; 13815: 									pMonsterViewportCreate.Path = lpTargetObj->Dir << 4;
; 13816: 
; 13817: #if(GS_CASTLE==1)
; 13818: 									if (lpTargetObj->Class == 277)
; 13819: 									{
; 13820: 										if (lpTargetObj->m_btCsGateOpen == 0)
; 13821: 										{
; 13822: 											pMonsterViewportCreate.ViewState &= 0xFFFDFFFF;
; 13823: 										}
; 13824: 										else
; 13825: 										{
; 13826: 											pMonsterViewportCreate.ViewState |= 0x20000;
; 13827: 										}
; 13828: 									}
; 13829: 									if (lpTargetObj->Class == 216)
; 13830: 									{
; 13831: 										if (g_CastleSiege.GetRegCrownAvailable() == FALSE)
; 13832: 										{
; 13833: 											pMonsterViewportCreate.ViewState &= 0xFFFDFFFF;
; 13834: 										}
; 13835: 										else
; 13836: 										{
; 13837: 											pMonsterViewportCreate.ViewState |= 0x20000;
; 13838: 										}
; 13839: 									}
; 13840: #endif
; 13841: 
; 13842: 									memcpy(&MonstersendBuf[MonlOfs], &pMonsterViewportCreate, sizeof(pMonsterViewportCreate));
; 13843: 									MonlOfs += sizeof(pMonsterViewportCreate);

  00a72	83 85 ac b1 ff
	ff 10		 add	 DWORD PTR _MonlOfs$[ebp], 16 ; 00000010H
  00a79	88 0d 02 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+2, cl
  00a7f	0f b6 88 04 01
	00 00		 movzx	 ecx, BYTE PTR [eax+260]
  00a86	88 15 03 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+3, dl
  00a8c	0f b6 90 06 01
	00 00		 movzx	 edx, BYTE PTR [eax+262]
  00a93	88 0d 08 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+8, cl
  00a99	0f b6 88 20 01
	00 00		 movzx	 ecx, BYTE PTR [eax+288]
  00aa0	88 15 09 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+9, dl
  00aa6	0f b6 90 22 01
	00 00		 movzx	 edx, BYTE PTR [eax+290]
  00aad	8a 80 08 01 00
	00		 mov	 al, BYTE PTR [eax+264]
  00ab3	88 0d 0a 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+10, cl
  00ab9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A
  00abf	c0 e0 04	 shl	 al, 4
  00ac2	89 0b		 mov	 DWORD PTR [ebx], ecx
  00ac4	88 15 0b 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+11, dl
  00aca	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+8
  00ad0	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  00ad3	a2 0c 00 00 00	 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+12, al
  00ad8	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+12
  00add	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  00ae0	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  00ae3	83 c3 10	 add	 ebx, 16			; 00000010H

; 13844: 									monstercount += 1;

  00ae6	fe 85 ce b1 ff
	ff		 inc	 BYTE PTR _monstercount$[ebp]
  00aec	89 35 04 00 00
	00		 mov	 DWORD PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+4, esi
  00af2	89 9d 9c b1 ff
	ff		 mov	 DWORD PTR tv3278[ebp], ebx

; 13845: 								}
; 13846: 							}
; 13847: 							break;

  00af8	e9 59 01 00 00	 jmp	 $LN11@gObjViewpo@6
$LN12@gObjViewpo@6:

; 13848: 						case 5:
; 13849: 							if (lpObj->Type == OBJ_USER)

  00afd	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00b02	0f 85 4e 01 00
	00		 jne	 $LN11@gObjViewpo@6

; 13850: 							{
; 13851: 								pItemViewportCreate.NumberH = SET_NUMBERH(tObjNum);

  00b08	0f bf c1	 movsx	 eax, cx

; 13852: 								pItemViewportCreate.NumberL = SET_NUMBERL(tObjNum);

  00b0b	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+1, cl

; 13853: 
; 13854: 								if (MapC[lpObj->MapNumber].m_cItem[tObjNum].m_State == 1)

  00b11	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00b18	8b d0		 mov	 edx, eax
  00b1a	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00b20	69 c0 48 04 00
	00		 imul	 eax, 1096		; 00000448H
  00b26	c1 ea 08	 shr	 edx, 8
  00b29	03 c8		 add	 ecx, eax
  00b2b	83 b9 d0 00 00
	00 01		 cmp	 DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+208], 1
  00b32	88 15 00 00 00
	00		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A, dl
  00b38	75 07		 jne	 SHORT $LN10@gObjViewpo@6

; 13855: 								{
; 13856: 									pItemViewportCreate.NumberH |= 0x80;

  00b3a	80 0d 00 00 00
	00 80		 or	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A, 128 ; 00000080H
$LN10@gObjViewpo@6:

; 13857: 								}
; 13858: 
; 13859: 								pItemViewportCreate.px = MapC[lpObj->MapNumber].m_cItem[tObjNum].px;

  00b41	8a 91 cc 00 00
	00		 mov	 dl, BYTE PTR ?MapC@@3PAVMapClass@@A[ecx+204]

; 13860: 								pItemViewportCreate.py = MapC[lpObj->MapNumber].m_cItem[tObjNum].py;

  00b47	8a 81 cd 00 00
	00		 mov	 al, BYTE PTR ?MapC@@3PAVMapClass@@A[ecx+205]
  00b4d	88 15 02 00 00
	00		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+2, dl

; 13861: 
; 13862: 								if (MapC[lpObj->MapNumber].m_cItem[tObjNum].m_Type == ITEMGET(14, 15))

  00b53	ba 0f 1c 00 00	 mov	 edx, 7183		; 00001c0fH
  00b58	a2 03 00 00 00	 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+3, al
  00b5d	66 39 91 2a 00
	00 00		 cmp	 WORD PTR ?MapC@@3PAVMapClass@@A[ecx+42], dx
  00b64	75 7c		 jne	 SHORT $LN9@gObjViewpo@6

; 13863: 								{
; 13864: 									WORD MoneyHW = SET_NUMBERHW(MapC[lpObj->MapNumber].m_cItem[tObjNum].m_BuyMoney);
; 13865: 									WORD MoneyLW = SET_NUMBERLW(MapC[lpObj->MapNumber].m_cItem[tObjNum].m_BuyMoney);
; 13866: 
; 13867: 									pItemViewportCreate.ItemInfo[0] = BYTE(MapC[lpObj->MapNumber].m_cItem[tObjNum].m_Type) % 255;

  00b66	0f b6 81 2a 00
	00 00		 movzx	 eax, BYTE PTR ?MapC@@3PAVMapClass@@A[ecx+42]
  00b6d	99		 cdq
  00b6e	be ff 00 00 00	 mov	 esi, 255		; 000000ffH
  00b73	f7 fe		 idiv	 esi
  00b75	0f b7 99 88 00
	00 00		 movzx	 ebx, WORD PTR ?MapC@@3PAVMapClass@@A[ecx+136]

; 13868: 									pItemViewportCreate.ItemInfo[1] = SET_NUMBERL(MoneyHW);

  00b7c	8a 81 8a 00 00
	00		 mov	 al, BYTE PTR ?MapC@@3PAVMapClass@@A[ecx+138]

; 13869: 									pItemViewportCreate.ItemInfo[2] = SET_NUMBERH(MoneyLW);
; 13870: 									pItemViewportCreate.ItemInfo[4] = SET_NUMBERL(MoneyLW);
; 13871: 									pItemViewportCreate.ItemInfo[3] = 0;
; 13872: 									pItemViewportCreate.ItemInfo[5] = (MapC[lpObj->MapNumber].m_cItem[tObjNum].m_Type & 0x1E00) >> 5;
; 13873: 									pItemViewportCreate.ItemInfo[6] = 0;
; 13874: 
; 13875: 									memcpy(&ItemBuf[lOfs_Item], &pItemViewportCreate, sizeof(pItemViewportCreate));
; 13876: 									lOfs_Item += ItemStructSize;

  00b82	83 85 c0 b1 ff
	ff 0b		 add	 DWORD PTR _lOfs_Item$[ebp], 11 ; 0000000bH
  00b89	8b cb		 mov	 ecx, ebx
  00b8b	c1 e9 08	 shr	 ecx, 8
  00b8e	a2 05 00 00 00	 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+5, al
  00b93	88 0d 06 00 00
	00		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+6, cl
  00b99	c6 05 07 00 00
	00 00		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+7, 0
  00ba0	88 1d 08 00 00
	00		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+8, bl
  00ba6	66 c7 05 09 00
	00 00 e0 00	 mov	 WORD PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+9, 224 ; 000000e0H
  00baf	32 c0		 xor	 al, al
  00bb1	83 c7 0b	 add	 edi, 11			; 0000000bH
  00bb4	89 bd b0 b1 ff
	ff		 mov	 DWORD PTR tv3276[ebp], edi
  00bba	88 15 04 00 00
	00		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+4, dl
  00bc0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A
  00bc6	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+4
  00bcc	89 57 f5	 mov	 DWORD PTR [edi-11], edx
  00bcf	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+8
  00bd6	89 4f f9	 mov	 DWORD PTR [edi-7], ecx
  00bd9	66 89 57 fd	 mov	 WORD PTR [edi-3], dx
  00bdd	88 47 ff	 mov	 BYTE PTR [edi-1], al

; 13877: 								}
; 13878: 								else

  00be0	eb 6e		 jmp	 SHORT $LN8@gObjViewpo@6
$LN9@gObjViewpo@6:

; 13879: 								{
; 13880: 									ItemByteConvert(pItemViewportCreate.ItemInfo, (MapC[lpObj->MapNumber].m_cItem[tObjNum]));

  00be2	8d 81 20 00 00
	00		 lea	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+32]
  00be8	85 c0		 test	 eax, eax
  00bea	74 08		 je	 SHORT $LN81@gObjViewpo@6
  00bec	8d b1 24 00 00
	00		 lea	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+36]
  00bf2	eb 02		 jmp	 SHORT $LN82@gObjViewpo@6
$LN81@gObjViewpo@6:
  00bf4	33 f6		 xor	 esi, esi
$LN82@gObjViewpo@6:
  00bf6	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00bfc	8b fc		 mov	 edi, esp
  00bfe	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00c03	68 04 00 00 00	 push	 OFFSET ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+4
  00c08	f3 a5		 rep movsd
  00c0a	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 13881: 									memcpy(&ItemBuf[lOfs_Item], &pItemViewportCreate, sizeof(pItemViewportCreate));

  00c0f	8b 85 b0 b1 ff
	ff		 mov	 eax, DWORD PTR tv3276[ebp]
  00c15	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A
  00c1b	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+4

; 13882: 									lOfs_Item += ItemStructSize;

  00c21	83 85 c0 b1 ff
	ff 0b		 add	 DWORD PTR _lOfs_Item$[ebp], 11 ; 0000000bH
  00c28	89 08		 mov	 DWORD PTR [eax], ecx
  00c2a	66 8b 0d 08 00
	00 00		 mov	 cx, WORD PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+8
  00c31	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00c34	8a 15 0a 00 00
	00		 mov	 dl, BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+10
  00c3a	66 89 48 08	 mov	 WORD PTR [eax+8], cx
  00c3e	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  00c44	88 50 0a	 mov	 BYTE PTR [eax+10], dl
  00c47	83 c0 0b	 add	 eax, 11			; 0000000bH
  00c4a	89 85 b0 b1 ff
	ff		 mov	 DWORD PTR tv3276[ebp], eax
$LN8@gObjViewpo@6:

; 13883: 								}
; 13884: 
; 13885: 								count_Item += 1;

  00c50	ff 85 c8 b1 ff
	ff		 inc	 DWORD PTR _count_Item$[ebp]
$LN11@gObjViewpo@6:

; 13886: 							}
; 13887: 							break;
; 13888: 						}
; 13889: 					}
; 13890: 					lpObj->VpPlayer[n].state = 2;

  00c56	8b 85 94 b1 ff
	ff		 mov	 eax, DWORD PTR tv3352[ebp]
  00c5c	8b 95 90 b1 ff
	ff		 mov	 edx, DWORD PTR tv3280[ebp]
  00c62	8b 9d 9c b1 ff
	ff		 mov	 ebx, DWORD PTR tv3278[ebp]
  00c68	8b bd b0 b1 ff
	ff		 mov	 edi, DWORD PTR tv3276[ebp]
  00c6e	8b b5 b4 b1 ff
	ff		 mov	 esi, DWORD PTR _lpObj$[ebp]
  00c74	c6 00 02	 mov	 BYTE PTR [eax], 2
$LN43@gObjViewpo@6:

; 13473: 		{
; 13474: 			for (n = 0; n < MAX_VIEWPORT; n++)

  00c77	83 c0 0c	 add	 eax, 12			; 0000000cH
  00c7a	ff 8d d0 b1 ff
	ff		 dec	 DWORD PTR tv3397[ebp]
  00c80	89 85 94 b1 ff
	ff		 mov	 DWORD PTR tv3352[ebp], eax
  00c86	0f 85 f7 f8 ff
	ff		 jne	 $LL44@gObjViewpo@6
  00c8c	8a 95 db b1 ff
	ff		 mov	 dl, BYTE PTR _count$[ebp]
  00c92	8b 8d c4 b1 ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
$LN42@gObjViewpo@6:

; 13891: 				}
; 13892: 			}
; 13893: 		}
; 13894: 		if (lpObj->Type == OBJ_USER)

  00c98	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00c9d	0f 85 4b 02 00
	00		 jne	 $LN48@gObjViewpo@6

; 13895: 		{
; 13896: 			if (count > 0)

  00ca3	84 d2		 test	 dl, dl
  00ca5	74 48		 je	 SHORT $LN6@gObjViewpo@6

; 13897: 			{
; 13898: 				PWMSG_COUNT pCount;
; 13899: 
; 13900: 				pCount.h.c = 0xC2;
; 13901: 				pCount.h.headcode = 0x12;
; 13902: 				pCount.h.sizeH = SET_NUMBERH(lOfs);

  00ca7	8b c1		 mov	 eax, ecx

; 13903: 				pCount.h.sizeL = SET_NUMBERL(lOfs);
; 13904: 				pCount.count = count;
; 13905: 
; 13906: 				memcpy(sendBuf, &pCount, sizeof(pCount));
; 13907: 				DataSend(aIndex, (unsigned char *)&sendBuf, lOfs);

  00ca9	51		 push	 ecx
  00caa	88 8d d2 b1 ff
	ff		 mov	 BYTE PTR _pCount$166676[ebp+2], cl
  00cb0	c1 e8 08	 shr	 eax, 8
  00cb3	8d 8d 74 ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  00cb9	88 95 78 ec ff
	ff		 mov	 BYTE PTR _sendBuf$[ebp+4], dl
  00cbf	8b 95 bc b1 ff
	ff		 mov	 edx, DWORD PTR tv1888[ebp]
  00cc5	88 85 d1 b1 ff
	ff		 mov	 BYTE PTR _pCount$166676[ebp+1], al
  00ccb	51		 push	 ecx
  00ccc	c6 85 d0 b1 ff
	ff c2		 mov	 BYTE PTR _pCount$166676[ebp], 194 ; 000000c2H
  00cd3	c6 85 d3 b1 ff
	ff 12		 mov	 BYTE PTR _pCount$166676[ebp+3], 18 ; 00000012H
  00cda	8b 85 d0 b1 ff
	ff		 mov	 eax, DWORD PTR _pCount$166676[ebp]
  00ce0	52		 push	 edx
  00ce1	89 85 74 ec ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp], eax
  00ce7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00cec	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@gObjViewpo@6:

; 13908: 			}
; 13909: 
; 13910: 			if (ChangeCount > 0)

  00cef	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ChangeCount@@3HA, 0 ; ChangeCount
  00cf6	7e 51		 jle	 SHORT $LN5@gObjViewpo@6

; 13911: 			{
; 13912: 				PWMSG_COUNT pCount;
; 13913: 
; 13914: 				pCount.h.c = 0xC2;
; 13915: 				pCount.h.headcode = 0x45;
; 13916: 				pCount.h.sizeH = SET_NUMBERH(lOfsChange);

  00cf8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lOfsChange@@3HA ; lOfsChange
  00cfd	8b c8		 mov	 ecx, eax
  00cff	c1 e9 08	 shr	 ecx, 8
  00d02	88 8d d1 b1 ff
	ff		 mov	 BYTE PTR _pCount$166684[ebp+1], cl

; 13917: 				pCount.h.sizeL = SET_NUMBERL(lOfsChange);
; 13918: 				pCount.count = ChangeCount;
; 13919: 
; 13920: 				memcpy(SendGBufChange, &pCount, sizeof(pCount));

  00d08	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?ChangeCount@@3HA
  00d0e	88 85 d2 b1 ff
	ff		 mov	 BYTE PTR _pCount$166684[ebp+2], al
  00d14	c6 85 d0 b1 ff
	ff c2		 mov	 BYTE PTR _pCount$166684[ebp], 194 ; 000000c2H
  00d1b	c6 85 d3 b1 ff
	ff 45		 mov	 BYTE PTR _pCount$166684[ebp+3], 69 ; 00000045H
  00d22	8b 95 d0 b1 ff
	ff		 mov	 edx, DWORD PTR _pCount$166684[ebp]

; 13921: 				DataSend(aIndex, (unsigned char *)&SendGBufChange, lOfsChange);

  00d28	50		 push	 eax
  00d29	89 15 00 00 00
	00		 mov	 DWORD PTR ?SendGBufChange@@3PAEA, edx
  00d2f	8b 95 bc b1 ff
	ff		 mov	 edx, DWORD PTR tv1888[ebp]
  00d35	68 00 00 00 00	 push	 OFFSET ?SendGBufChange@@3PAEA ; SendGBufChange
  00d3a	52		 push	 edx
  00d3b	88 0d 04 00 00
	00		 mov	 BYTE PTR ?SendGBufChange@@3PAEA+4, cl
  00d41	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00d46	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@gObjViewpo@6:

; 13922: 			}
; 13923: 
; 13924: 			if (monstercount > 0)

  00d49	80 bd ce b1 ff
	ff 00		 cmp	 BYTE PTR _monstercount$[ebp], 0
  00d50	76 54		 jbe	 SHORT $LN4@gObjViewpo@6

; 13925: 			{
; 13926: 				PWMSG_COUNT pCount;
; 13927: 
; 13928: 				pCount.h.c = 0xC2;
; 13929: 				pCount.h.headcode = 0x13;
; 13930: 				pCount.h.sizeH = SET_NUMBERH(MonlOfs);

  00d52	8b 85 ac b1 ff
	ff		 mov	 eax, DWORD PTR _MonlOfs$[ebp]
  00d58	8b c8		 mov	 ecx, eax
  00d5a	c1 e9 08	 shr	 ecx, 8
  00d5d	88 8d d1 b1 ff
	ff		 mov	 BYTE PTR _pCount$166692[ebp+1], cl

; 13931: 				pCount.h.sizeL = SET_NUMBERL(MonlOfs);
; 13932: 				pCount.count = monstercount;
; 13933: 
; 13934: 				memcpy(MonstersendBuf, &pCount, sizeof(pCount));

  00d63	8a 8d ce b1 ff
	ff		 mov	 cl, BYTE PTR _monstercount$[ebp]
  00d69	88 85 d2 b1 ff
	ff		 mov	 BYTE PTR _pCount$166692[ebp+2], al
  00d6f	c6 85 d0 b1 ff
	ff c2		 mov	 BYTE PTR _pCount$166692[ebp], 194 ; 000000c2H
  00d76	c6 85 d3 b1 ff
	ff 13		 mov	 BYTE PTR _pCount$166692[ebp+3], 19 ; 00000013H
  00d7d	8b 95 d0 b1 ff
	ff		 mov	 edx, DWORD PTR _pCount$166692[ebp]

; 13935: 				DataSend(aIndex, (unsigned char *)&MonstersendBuf, MonlOfs);

  00d83	50		 push	 eax
  00d84	8b 85 bc b1 ff
	ff		 mov	 eax, DWORD PTR tv1888[ebp]
  00d8a	89 95 dc b1 ff
	ff		 mov	 DWORD PTR _MonstersendBuf$[ebp], edx
  00d90	8d 95 dc b1 ff
	ff		 lea	 edx, DWORD PTR _MonstersendBuf$[ebp]
  00d96	52		 push	 edx
  00d97	50		 push	 eax
  00d98	88 8d e0 b1 ff
	ff		 mov	 BYTE PTR _MonstersendBuf$[ebp+4], cl
  00d9e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00da3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@gObjViewpo@6:

; 13936: 			}
; 13937: 
; 13938: 			if (callmonstercount > 0)

  00da6	80 bd cf b1 ff
	ff 00		 cmp	 BYTE PTR _callmonstercount$[ebp], 0
  00dad	76 54		 jbe	 SHORT $LN3@gObjViewpo@6

; 13939: 			{
; 13940: 				PWMSG_COUNT pCount;
; 13941: 
; 13942: 				pCount.h.c = 0xC2;
; 13943: 				pCount.h.headcode = 0x1F;
; 13944: 				pCount.h.sizeH = SET_NUMBERH(callMonlOfs);

  00daf	8b 85 b8 b1 ff
	ff		 mov	 eax, DWORD PTR _callMonlOfs$[ebp]
  00db5	8b c8		 mov	 ecx, eax
  00db7	c1 e9 08	 shr	 ecx, 8
  00dba	88 8d d1 b1 ff
	ff		 mov	 BYTE PTR _pCount$166700[ebp+1], cl

; 13945: 				pCount.h.sizeL = SET_NUMBERL(callMonlOfs);
; 13946: 				pCount.count = callmonstercount;
; 13947: 
; 13948: 				memcpy(callMonstersendBuf, &pCount, sizeof(pCount));

  00dc0	8a 8d cf b1 ff
	ff		 mov	 cl, BYTE PTR _callmonstercount$[ebp]
  00dc6	88 85 d2 b1 ff
	ff		 mov	 BYTE PTR _pCount$166700[ebp+2], al
  00dcc	c6 85 d0 b1 ff
	ff c2		 mov	 BYTE PTR _pCount$166700[ebp], 194 ; 000000c2H
  00dd3	c6 85 d3 b1 ff
	ff 1f		 mov	 BYTE PTR _pCount$166700[ebp+3], 31 ; 0000001fH
  00dda	8b 95 d0 b1 ff
	ff		 mov	 edx, DWORD PTR _pCount$166700[ebp]

; 13949: 				DataSend(aIndex, (unsigned char *)&callMonstersendBuf, callMonlOfs);

  00de0	50		 push	 eax
  00de1	8b 85 bc b1 ff
	ff		 mov	 eax, DWORD PTR tv1888[ebp]
  00de7	89 95 64 c5 ff
	ff		 mov	 DWORD PTR _callMonstersendBuf$[ebp], edx
  00ded	8d 95 64 c5 ff
	ff		 lea	 edx, DWORD PTR _callMonstersendBuf$[ebp]
  00df3	52		 push	 edx
  00df4	50		 push	 eax
  00df5	88 8d 68 c5 ff
	ff		 mov	 BYTE PTR _callMonstersendBuf$[ebp+4], cl
  00dfb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00e00	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@gObjViewpo@6:

; 13950: 			}
; 13951: 
; 13952: 			if (count_Item > 0)

  00e03	83 bd c8 b1 ff
	ff 00		 cmp	 DWORD PTR _count_Item$[ebp], 0
  00e0a	7e 54		 jle	 SHORT $LN2@gObjViewpo@6

; 13953: 			{
; 13954: 				PWMSG_COUNT pCount;
; 13955: 
; 13956: 				pCount.h.c = 0xC2;
; 13957: 				pCount.h.headcode = 0x20;
; 13958: 				pCount.count = count_Item;
; 13959: 				pCount.h.sizeH = SET_NUMBERH(lOfs_Item);

  00e0c	8b 85 c0 b1 ff
	ff		 mov	 eax, DWORD PTR _lOfs_Item$[ebp]
  00e12	8b c8		 mov	 ecx, eax
  00e14	c1 e9 08	 shr	 ecx, 8
  00e17	88 8d d1 b1 ff
	ff		 mov	 BYTE PTR _pCount$166708[ebp+1], cl

; 13960: 				pCount.h.sizeL = SET_NUMBERL(lOfs_Item);
; 13961: 
; 13962: 				memcpy(ItemBuf, &pCount, sizeof(pCount));

  00e1d	8a 8d c8 b1 ff
	ff		 mov	 cl, BYTE PTR _count_Item$[ebp]
  00e23	88 85 d2 b1 ff
	ff		 mov	 BYTE PTR _pCount$166708[ebp+2], al
  00e29	c6 85 d0 b1 ff
	ff c2		 mov	 BYTE PTR _pCount$166708[ebp], 194 ; 000000c2H
  00e30	c6 85 d3 b1 ff
	ff 20		 mov	 BYTE PTR _pCount$166708[ebp+3], 32 ; 00000020H
  00e37	8b 95 d0 b1 ff
	ff		 mov	 edx, DWORD PTR _pCount$166708[ebp]

; 13963: 				DataSend(aIndex, (unsigned char *)&ItemBuf, lOfs_Item);

  00e3d	50		 push	 eax
  00e3e	8b 85 bc b1 ff
	ff		 mov	 eax, DWORD PTR tv1888[ebp]
  00e44	89 95 ec d8 ff
	ff		 mov	 DWORD PTR _ItemBuf$[ebp], edx
  00e4a	8d 95 ec d8 ff
	ff		 lea	 edx, DWORD PTR _ItemBuf$[ebp]
  00e50	52		 push	 edx
  00e51	50		 push	 eax
  00e52	88 8d f0 d8 ff
	ff		 mov	 BYTE PTR _ItemBuf$[ebp+4], cl
  00e58	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00e5d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@gObjViewpo@6:

; 13964: 			}
; 13965: 
; 13966: 			if (GuildInfoCount != 0)

  00e60	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GuildInfoCount@@3HA, 0 ; GuildInfoCount
  00e67	0f 84 81 00 00
	00		 je	 $LN48@gObjViewpo@6

; 13967: 			{
; 13968: 				PWMSG_COUNT pCount;
; 13969: 
; 13970: 				pCount.h.headcode = 0x65;
; 13971: 				pCount.h.c = 0xC2;
; 13972: 				pCount.h.sizeH = SET_NUMBERH(GuildInfoOfs);

  00e6d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildInfoOfs@@3HA ; GuildInfoOfs
  00e72	8b c8		 mov	 ecx, eax
  00e74	c1 e9 08	 shr	 ecx, 8
  00e77	88 8d d1 b1 ff
	ff		 mov	 BYTE PTR _pCount$166716[ebp+1], cl

; 13973: 				pCount.h.sizeL = SET_NUMBERL(GuildInfoOfs);
; 13974: 				pCount.count = GuildInfoCount;
; 13975: 
; 13976: 				memcpy(GuildInfoBuf, &pCount, sizeof(pCount));

  00e7d	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?GuildInfoCount@@3HA
  00e83	88 85 d2 b1 ff
	ff		 mov	 BYTE PTR _pCount$166716[ebp+2], al
  00e89	c6 85 d3 b1 ff
	ff 65		 mov	 BYTE PTR _pCount$166716[ebp+3], 101 ; 00000065H
  00e90	c6 85 d0 b1 ff
	ff c2		 mov	 BYTE PTR _pCount$166716[ebp], 194 ; 000000c2H
  00e97	8b 95 d0 b1 ff
	ff		 mov	 edx, DWORD PTR _pCount$166716[ebp]

; 13977: 				DataSend(aIndex, (unsigned char *)&GuildInfoBuf, GuildInfoOfs);

  00e9d	50		 push	 eax
  00e9e	89 15 00 00 00
	00		 mov	 DWORD PTR ?GuildInfoBuf@@3PAEA, edx
  00ea4	8b 95 bc b1 ff
	ff		 mov	 edx, DWORD PTR tv1888[ebp]
  00eaa	68 00 00 00 00	 push	 OFFSET ?GuildInfoBuf@@3PAEA ; GuildInfoBuf
  00eaf	52		 push	 edx
  00eb0	88 0d 04 00 00
	00		 mov	 BYTE PTR ?GuildInfoBuf@@3PAEA+4, cl
  00eb6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00ebb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13978: 			}
; 13979: 		}
; 13980: 	}
; 13981: }

  00ebe	5f		 pop	 edi
  00ebf	5e		 pop	 esi
  00ec0	5b		 pop	 ebx
  00ec1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ec4	33 cd		 xor	 ecx, ebp
  00ec6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ecb	8b e5		 mov	 esp, ebp
  00ecd	5d		 pop	 ebp
  00ece	c3		 ret	 0
$LN51@gObjViewpo@6:

; 13451: 	{
; 13452: 		for (n = 0; n < MAX_VIEWPORT_MONSTER; n++)

  00ecf	81 c6 90 03 00
	00		 add	 esi, 912		; 00000390H
  00ed5	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00eda	8d 9b 00 00 00
	00		 npad	 6
$LL50@gObjViewpo@6:

; 13453: 		{
; 13454: 			if (lpObj->VpPlayer[n].state == 1)

  00ee0	80 3e 01	 cmp	 BYTE PTR [esi], 1
  00ee3	75 03		 jne	 SHORT $LN49@gObjViewpo@6

; 13455: 			{
; 13456: 				lpObj->VpPlayer[n].state = 2;

  00ee5	c6 06 02	 mov	 BYTE PTR [esi], 2
$LN49@gObjViewpo@6:

; 13451: 	{
; 13452: 		for (n = 0; n < MAX_VIEWPORT_MONSTER; n++)

  00ee8	83 c6 0c	 add	 esi, 12			; 0000000cH
  00eeb	48		 dec	 eax
  00eec	75 f2		 jne	 SHORT $LL50@gObjViewpo@6
$LN48@gObjViewpo@6:

; 13978: 			}
; 13979: 		}
; 13980: 	}
; 13981: }

  00eee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ef1	5f		 pop	 edi
  00ef2	5e		 pop	 esi
  00ef3	33 cd		 xor	 ecx, ebp
  00ef5	5b		 pop	 ebx
  00ef6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00efb	8b e5		 mov	 esp, ebp
  00efd	5d		 pop	 ebp
  00efe	c3		 ret	 0
  00eff	90		 npad	 1
$LN121@gObjViewpo@6:
  00f00	00 00 00 00	 DD	 $LN37@gObjViewpo@6
  00f04	00 00 00 00	 DD	 $LN21@gObjViewpo@6
  00f08	00 00 00 00	 DD	 $LN21@gObjViewpo@6
  00f0c	00 00 00 00	 DD	 $LN11@gObjViewpo@6
  00f10	00 00 00 00	 DD	 $LN12@gObjViewpo@6
?gObjViewportListProtocol@@YAXF@Z ENDP			; gObjViewportListProtocol
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjSkillUseProc@@YAXPAUOBJECTSTRUCT@@@Z	; gObjSkillUseProc
EXTRN	?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMoveCommand::CheckInterfaceToMove
EXTRN	?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMoveCommand::CheckEquipmentToMove
EXTRN	?CheckMainToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMoveCommand::CheckMainToMove
EXTRN	?gMoveCommand@@3VCMoveCommand@@A:BYTE		; gMoveCommand
EXTRN	?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z:PROC ; GCMagicAttackNumberSend
EXTRN	?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@E@Z:PROC ; GCMagicCancelSend
; Function compile flags: /Ogtp
;	COMDAT ?gObjSkillUseProc@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv877 = -264						; size = 4
tv739 = -264						; size = 4
_szMsg$166759 = -260					; size = 256
_szMsg$166755 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjSkillUseProc@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjSkillUseProc, COMDAT

; 13984: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 13985: 	if(lpObj->m_SkillAttackTime > 0)

  00018	8a 86 84 02 00
	00		 mov	 al, BYTE PTR [esi+644]
  0001e	57		 push	 edi
  0001f	84 c0		 test	 al, al
  00021	7e 26		 jle	 SHORT $LN53@gObjSkillU@2

; 13986: 	{
; 13987: 		lpObj->m_SkillAttackTime--;

  00023	fe c8		 dec	 al
  00025	88 86 84 02 00
	00		 mov	 BYTE PTR [esi+644], al

; 13988: 
; 13989: 		if(lpObj->m_SkillAttackTime == 0)

  0002b	75 1c		 jne	 SHORT $LN53@gObjSkillU@2

; 13990: 		{
; 13991: 			lpObj->m_SkillAttack = 0;
; 13992: 			lpObj->m_ViewSkillState &= ~4;

  0002d	83 a6 c4 01 00
	00 fb		 and	 DWORD PTR [esi+452], -5	; fffffffbH

; 13993: 
; 13994: 			GCMagicCancelSend(lpObj,28);

  00034	6a 1c		 push	 28			; 0000001cH
  00036	33 ff		 xor	 edi, edi
  00038	56		 push	 esi
  00039	89 be 80 02 00
	00		 mov	 DWORD PTR [esi+640], edi
  0003f	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  00044	83 c4 08	 add	 esp, 8
  00047	eb 02		 jmp	 SHORT $LN49@gObjSkillU@2
$LN53@gObjSkillU@2:
  00049	33 ff		 xor	 edi, edi
$LN49@gObjSkillU@2:

; 13995: 		}
; 13996: 	}
; 13997: 
; 13998: 	if(lpObj->m_SkillAttackTime2 > 0)

  0004b	8a 86 8c 02 00
	00		 mov	 al, BYTE PTR [esi+652]
  00051	84 c0		 test	 al, al
  00053	7e 19		 jle	 SHORT $LN47@gObjSkillU@2

; 13999: 	{
; 14000: 		lpObj->m_SkillAttackTime2--;

  00055	fe c8		 dec	 al
  00057	88 86 8c 02 00
	00		 mov	 BYTE PTR [esi+652], al

; 14001: 
; 14002: 		if(lpObj->m_SkillAttackTime2 <= 0)

  0005d	84 c0		 test	 al, al
  0005f	7f 0d		 jg	 SHORT $LN47@gObjSkillU@2

; 14003: 		{
; 14004: 			lpObj->m_SkillAttack2 = 0;

  00061	89 be 88 02 00
	00		 mov	 DWORD PTR [esi+648], edi

; 14005: 			lpObj->m_SkillAttackTime2 = 0;

  00067	c6 86 8c 02 00
	00 00		 mov	 BYTE PTR [esi+652], 0
$LN47@gObjSkillU@2:

; 14006: 		}
; 14007: 	}
; 14008: 
; 14009: 	if(lpObj->m_SkillDefenseTime > 0)

  0006e	8a 86 7c 02 00
	00		 mov	 al, BYTE PTR [esi+636]
  00074	84 c0		 test	 al, al
  00076	7e 22		 jle	 SHORT $LN45@gObjSkillU@2

; 14010: 	{
; 14011: 		lpObj->m_SkillDefenseTime--;

  00078	fe c8		 dec	 al
  0007a	88 86 7c 02 00
	00		 mov	 BYTE PTR [esi+636], al

; 14012: 
; 14013: 		if(lpObj->m_SkillDefenseTime == 0)

  00080	75 18		 jne	 SHORT $LN45@gObjSkillU@2

; 14014: 		{
; 14015: 			lpObj->m_SkillDefense = 0;
; 14016: 			lpObj->m_ViewSkillState &= ~8;

  00082	83 a6 c4 01 00
	00 f7		 and	 DWORD PTR [esi+452], -9	; fffffff7H

; 14017: 
; 14018: 			GCMagicCancelSend(lpObj,27);

  00089	6a 1b		 push	 27			; 0000001bH
  0008b	56		 push	 esi
  0008c	89 be 78 02 00
	00		 mov	 DWORD PTR [esi+632], edi
  00092	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  00097	83 c4 08	 add	 esp, 8
$LN45@gObjSkillU@2:

; 14019: 		}
; 14020: 	}
; 14021: 
; 14022: 	if(lpObj->m_WizardSkillDefenseTime > 0)

  0009a	8b 86 08 0f 00
	00		 mov	 eax, DWORD PTR [esi+3848]
  000a0	3b c7		 cmp	 eax, edi
  000a2	7e 26		 jle	 SHORT $LN43@gObjSkillU@2

; 14023: 	{
; 14024: 		lpObj->m_WizardSkillDefenseTime--;

  000a4	48		 dec	 eax
  000a5	89 86 08 0f 00
	00		 mov	 DWORD PTR [esi+3848], eax

; 14025: 
; 14026: 		if(lpObj->m_WizardSkillDefenseTime == 0)

  000ab	3b c7		 cmp	 eax, edi
  000ad	75 1b		 jne	 SHORT $LN43@gObjSkillU@2

; 14027: 		{
; 14028: 			lpObj->m_WizardSkillDefense = 0;
; 14029: 			lpObj->m_ViewSkillState &= ~256;

  000af	81 a6 c4 01 00
	00 ff fe ff ff	 and	 DWORD PTR [esi+452], -257 ; fffffeffH

; 14030: 
; 14031: 			GCMagicCancelSend(lpObj,16);

  000b9	6a 10		 push	 16			; 00000010H
  000bb	56		 push	 esi
  000bc	89 be 04 0f 00
	00		 mov	 DWORD PTR [esi+3844], edi
  000c2	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  000c7	83 c4 08	 add	 esp, 8
$LN43@gObjSkillU@2:

; 14032: 		}
; 14033: 	}
; 14034: 
; 14035: 	if(lpObj->m_SkillAddLifeTime > 0)

  000ca	8b 86 94 02 00
	00		 mov	 eax, DWORD PTR [esi+660]
  000d0	3b c7		 cmp	 eax, edi
  000d2	0f 8e a6 00 00
	00		 jle	 $LN55@gObjSkillU@2

; 14036: 	{
; 14037: 		lpObj->m_SkillAddLifeTime--;

  000d8	48		 dec	 eax
  000d9	89 86 94 02 00
	00		 mov	 DWORD PTR [esi+660], eax

; 14038: 
; 14039: 		if(lpObj->m_SkillAddLifeTime == 0)

  000df	3b c7		 cmp	 eax, edi
  000e1	0f 85 97 00 00
	00		 jne	 $LN55@gObjSkillU@2

; 14040: 		{
; 14041: 			lpObj->AddLife -= lpObj->m_SkillAddLife;

  000e7	8b 86 90 02 00
	00		 mov	 eax, DWORD PTR [esi+656]
  000ed	29 86 0c 01 00
	00		 sub	 DWORD PTR [esi+268], eax

; 14042: 
; 14043: 			if(lpObj->AddLife < 0)

  000f3	79 06		 jns	 SHORT $LN40@gObjSkillU@2

; 14044: 			{
; 14045: 				lpObj->AddLife = 0;

  000f5	89 be 0c 01 00
	00		 mov	 DWORD PTR [esi+268], edi
$LN40@gObjSkillU@2:

; 14046: 			}
; 14047: 
; 14048: 			GCReFillSend(lpObj->m_Index,lpObj->MaxLife+lpObj->AddLife,0xFE,0);

  000fb	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  00101	57		 push	 edi
  00102	68 fe 00 00 00	 push	 254			; 000000feH
  00107	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  0010d	e8 00 00 00 00	 call	 __ftol2_sse
  00112	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00114	50		 push	 eax
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend

; 14049: 
; 14050: 			if(lpObj->Life > lpObj->MaxLife + lpObj->AddLife)

  0011b	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  00121	83 c4 10	 add	 esp, 16			; 00000010H
  00124	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  0012a	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  00130	d8 d9		 fcomp	 ST(1)
  00132	df e0		 fnstsw	 ax
  00134	f6 c4 41	 test	 ah, 65			; 00000041H
  00137	75 2b		 jne	 SHORT $LN61@gObjSkillU@2

; 14051: 			{
; 14052: 				lpObj->Life = lpObj->MaxLife + lpObj->AddLife;

  00139	d9 9d f8 fe ff
	ff		 fstp	 DWORD PTR tv739[ebp]

; 14053: 				GCReFillSend(lpObj->m_Index,lpObj->Life,0xFF,0);

  0013f	57		 push	 edi
  00140	d9 85 f8 fe ff
	ff		 fld	 DWORD PTR tv739[ebp]
  00146	68 ff 00 00 00	 push	 255			; 000000ffH
  0014b	d9 96 bc 00 00
	00		 fst	 DWORD PTR [esi+188]
  00151	e8 00 00 00 00	 call	 __ftol2_sse
  00156	8b 16		 mov	 edx, DWORD PTR [esi]
  00158	50		 push	 eax
  00159	52		 push	 edx
  0015a	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend
  0015f	83 c4 10	 add	 esp, 16			; 00000010H
  00162	eb 02		 jmp	 SHORT $LN54@gObjSkillU@2
$LN61@gObjSkillU@2:
  00164	dd d8		 fstp	 ST(0)
$LN54@gObjSkillU@2:

; 14054: 			}
; 14055: 
; 14056: 			lpObj->m_SkillAddLife = 0;
; 14057: 			lpObj->m_ViewSkillState &= ~16;

  00166	83 a6 c4 01 00
	00 ef		 and	 DWORD PTR [esi+452], -17 ; ffffffefH

; 14058: 
; 14059: 			GCMagicCancelSend(lpObj,48);

  0016d	6a 30		 push	 48			; 00000030H
  0016f	56		 push	 esi
  00170	89 be 90 02 00
	00		 mov	 DWORD PTR [esi+656], edi
  00176	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  0017b	83 c4 08	 add	 esp, 8
$LN55@gObjSkillU@2:

; 14060: 		}
; 14061: 	}
; 14062: 
; 14063: 	if(lpObj->m_SkillHardenTime > 0)

  0017e	8b 86 9c 02 00
	00		 mov	 eax, DWORD PTR [esi+668]
  00184	3b c7		 cmp	 eax, edi
  00186	7e 23		 jle	 SHORT $LN37@gObjSkillU@2

; 14064: 	{
; 14065: 		lpObj->m_SkillHardenTime--;

  00188	48		 dec	 eax
  00189	89 86 9c 02 00
	00		 mov	 DWORD PTR [esi+668], eax

; 14066: 
; 14067: 		if(lpObj->m_SkillHardenTime <= 0)

  0018f	3b c7		 cmp	 eax, edi
  00191	7f 18		 jg	 SHORT $LN37@gObjSkillU@2

; 14068: 		{
; 14069: 			lpObj->m_SkillHarden = 0;
; 14070: 			lpObj->m_ViewSkillState &= ~32;

  00193	83 a6 c4 01 00
	00 df		 and	 DWORD PTR [esi+452], -33 ; ffffffdfH

; 14071: 
; 14072: 			GCMagicCancelSend(lpObj,51);

  0019a	6a 33		 push	 51			; 00000033H
  0019c	56		 push	 esi
  0019d	89 be 98 02 00
	00		 mov	 DWORD PTR [esi+664], edi
  001a3	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  001a8	83 c4 08	 add	 esp, 8
$LN37@gObjSkillU@2:

; 14073: 		}
; 14074: 	}
; 14075: 
; 14076: 	if(lpObj->m_SkillMagumReduceDefenseTime > 0)

  001ab	8b 86 a4 02 00
	00		 mov	 eax, DWORD PTR [esi+676]
  001b1	3b c7		 cmp	 eax, edi
  001b3	7e 23		 jle	 SHORT $LN35@gObjSkillU@2

; 14077: 	{
; 14078: 		lpObj->m_SkillMagumReduceDefenseTime--;

  001b5	48		 dec	 eax
  001b6	89 86 a4 02 00
	00		 mov	 DWORD PTR [esi+676], eax

; 14079: 
; 14080: 		if(lpObj->m_SkillMagumReduceDefenseTime == 0)

  001bc	3b c7		 cmp	 eax, edi
  001be	75 18		 jne	 SHORT $LN35@gObjSkillU@2

; 14081: 		{
; 14082: 			lpObj->m_SkillMagumReduceDefense = 0;
; 14083: 			lpObj->m_ViewSkillState &= ~64;

  001c0	83 a6 c4 01 00
	00 bf		 and	 DWORD PTR [esi+452], -65 ; ffffffbfH

; 14084: 
; 14085: 			GCMagicCancelSend(lpObj,55);

  001c7	6a 37		 push	 55			; 00000037H
  001c9	56		 push	 esi
  001ca	89 be a0 02 00
	00		 mov	 DWORD PTR [esi+672], edi
  001d0	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  001d5	83 c4 08	 add	 esp, 8
$LN35@gObjSkillU@2:

; 14086: 		}
; 14087: 	}
; 14088: 
; 14089: 	if(lpObj->Class == 77)

  001d8	66 83 be 98 00
	00 00 4d	 cmp	 WORD PTR [esi+152], 77	; 0000004dH

; 14090: 	{
; 14091: 		lpObj->m_SkyBossMonSheildTime++;

  001e0	bb 01 00 00 00	 mov	 ebx, 1
  001e5	75 59		 jne	 SHORT $LN31@gObjSkillU@2
  001e7	01 9e fc 0e 00
	00		 add	 DWORD PTR [esi+3836], ebx

; 14092: 
; 14093: 		if(lpObj->m_SkyBossMonSheildTime > 5)

  001ed	83 be fc 0e 00
	00 05		 cmp	 DWORD PTR [esi+3836], 5
  001f4	7e 4a		 jle	 SHORT $LN31@gObjSkillU@2

; 14094: 		{
; 14095: 			lpObj->m_SkyBossMonSheildTime = 0;

  001f6	89 be fc 0e 00
	00		 mov	 DWORD PTR [esi+3836], edi

; 14096: 
; 14097: 			if(lpObj->m_SkyBossMonSheild != 0)

  001fc	39 be f8 0e 00
	00		 cmp	 DWORD PTR [esi+3832], edi
  00202	74 1d		 je	 SHORT $LN32@gObjSkillU@2

; 14098: 			{
; 14099: 				lpObj->m_SkyBossMonSheild = 0;
; 14100: 				lpObj->m_ViewSkillState &= ~128;

  00204	81 a6 c4 01 00
	00 7f ff ff ff	 and	 DWORD PTR [esi+452], -129 ; ffffff7fH

; 14101: 
; 14102: 				GCMagicCancelSend(lpObj,16);

  0020e	6a 10		 push	 16			; 00000010H
  00210	56		 push	 esi
  00211	89 be f8 0e 00
	00		 mov	 DWORD PTR [esi+3832], edi
  00217	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  0021c	83 c4 08	 add	 esp, 8

; 14103: 			}
; 14104: 			else

  0021f	eb 1f		 jmp	 SHORT $LN31@gObjSkillU@2
$LN32@gObjSkillU@2:

; 14105: 			{
; 14106: 				lpObj->m_SkyBossMonSheild = 1;
; 14107: 				lpObj->m_ViewSkillState |= 128;
; 14108: 
; 14109: 				GCMagicAttackNumberSend(lpObj,16,lpObj->m_Index,1);

  00221	8b 06		 mov	 eax, DWORD PTR [esi]
  00223	81 8e c4 01 00
	00 80 00 00 00	 or	 DWORD PTR [esi+452], 128 ; 00000080H
  0022d	53		 push	 ebx
  0022e	50		 push	 eax
  0022f	6a 10		 push	 16			; 00000010H
  00231	56		 push	 esi
  00232	89 9e f8 0e 00
	00		 mov	 DWORD PTR [esi+3832], ebx
  00238	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  0023d	83 c4 10	 add	 esp, 16			; 00000010H
$LN31@gObjSkillU@2:

; 14110: 			}
; 14111: 		}
; 14112: 	}
; 14113: 
; 14114: 	if(lpObj->m_iSkillNPCHelpTime > 0)

  00240	39 be 24 15 00
	00		 cmp	 DWORD PTR [esi+5412], edi
  00246	7e 41		 jle	 SHORT $LN57@gObjSkillU@2

; 14115: 	{
; 14116: 		if(GetTickCount() > lpObj->m_iSkillNPCHelpTime + 1800000)

  00248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0024e	8b 8e 24 15 00
	00		 mov	 ecx, DWORD PTR [esi+5412]
  00254	81 c1 40 77 1b
	00		 add	 ecx, 1800000		; 001b7740H
  0025a	3b c1		 cmp	 eax, ecx
  0025c	76 2b		 jbe	 SHORT $LN57@gObjSkillU@2

; 14117: 		{
; 14118: 			lpObj->m_iSkillNPCHelpTime = 0;
; 14119: 			lpObj->m_iSkillNPCDefense = 0;
; 14120: 			lpObj->m_iSkillNPCAttack = 0;
; 14121: 
; 14122: 			lpObj->m_ViewSkillState &= ~0x2000000;

  0025e	81 a6 c4 01 00
	00 ff ff ff fd	 and	 DWORD PTR [esi+452], -33554433 ; fdffffffH

; 14123: 
; 14124: 			GCStateInfoSend(lpObj,0,0x2000000);

  00268	68 00 00 00 02	 push	 33554432		; 02000000H
  0026d	57		 push	 edi
  0026e	56		 push	 esi
  0026f	89 be 24 15 00
	00		 mov	 DWORD PTR [esi+5412], edi
  00275	89 be 28 15 00
	00		 mov	 DWORD PTR [esi+5416], edi
  0027b	89 be 2c 15 00
	00		 mov	 DWORD PTR [esi+5420], edi
  00281	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  00286	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@gObjSkillU@2:

; 14125: 		}
; 14126: 	}
; 14127: 
; 14128: 	if(lpObj->SkillRecallParty_Time != 0 && lpObj->Type == OBJ_USER)

  00289	0f b7 86 b0 10
	00 00		 movzx	 eax, WORD PTR [esi+4272]
  00290	66 3b c7	 cmp	 ax, di
  00293	0f 84 fd 00 00
	00		 je	 $LN58@gObjSkillU@2
  00299	66 39 5e 60	 cmp	 WORD PTR [esi+96], bx
  0029d	0f 85 f3 00 00
	00		 jne	 $LN58@gObjSkillU@2

; 14129: 	{
; 14130: 		lpObj->SkillRecallParty_Time--;

  002a3	48		 dec	 eax
  002a4	66 89 86 b0 10
	00 00		 mov	 WORD PTR [esi+4272], ax

; 14131: 
; 14132: 		if(lpObj->SkillRecallParty_Time <= 0)

  002ab	66 3b c7	 cmp	 ax, di
  002ae	0f 87 a8 00 00
	00		 ja	 $LN27@gObjSkillU@2

; 14133: 		{
; 14134: 			lpObj->SkillRecallParty_Time = 0;

  002b4	33 d2		 xor	 edx, edx

; 14135: 
; 14136: 			int m_check1 = gMoveCommand.CheckMainToMove(lpObj);

  002b6	56		 push	 esi
  002b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  002bc	66 89 96 b0 10
	00 00		 mov	 WORD PTR [esi+4272], dx
  002c3	e8 00 00 00 00	 call	 ?CheckMainToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckMainToMove
  002c8	8b f8		 mov	 edi, eax

; 14137: 			int m_check2 = gMoveCommand.CheckEquipmentToMove(lpObj,lpObj->SkillRecallParty_MapNumber);

  002ca	0f b6 86 b2 10
	00 00		 movzx	 eax, BYTE PTR [esi+4274]
  002d1	50		 push	 eax
  002d2	56		 push	 esi
  002d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  002d8	e8 00 00 00 00	 call	 ?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMoveCommand::CheckEquipmentToMove

; 14138: 			int m_check3 = gMoveCommand.CheckInterfaceToMove(lpObj);

  002dd	56		 push	 esi
  002de	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  002e3	8b d8		 mov	 ebx, eax
  002e5	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove

; 14139: 
; 14140: 			if(m_check1 == false
; 14141: 				|| m_check2 == false
; 14142: 				|| m_check3 == false)

  002ea	85 ff		 test	 edi, edi
  002ec	74 34		 je	 SHORT $LN25@gObjSkillU@2
  002ee	85 db		 test	 ebx, ebx
  002f0	74 30		 je	 SHORT $LN25@gObjSkillU@2
  002f2	85 c0		 test	 eax, eax
  002f4	74 2c		 je	 SHORT $LN25@gObjSkillU@2

; 14148: 			}
; 14149: 			else
; 14150: 			{
; 14151: 				gObjRecall(lpObj->m_Index,lpObj->SkillRecallParty_MapNumber,lpObj->SkillRecallParty_X,lpObj->SkillRecallParty_Y);

  002f6	0f b6 8e b4 10
	00 00		 movzx	 ecx, BYTE PTR [esi+4276]
  002fd	0f b6 96 b3 10
	00 00		 movzx	 edx, BYTE PTR [esi+4275]
  00304	0f b6 86 b2 10
	00 00		 movzx	 eax, BYTE PTR [esi+4274]
  0030b	51		 push	 ecx
  0030c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0030e	52		 push	 edx
  0030f	50		 push	 eax
  00310	51		 push	 ecx
  00311	e8 00 00 00 00	 call	 ?gObjRecall@@YAXHHHH@Z	; gObjRecall
  00316	83 c4 10	 add	 esp, 16			; 00000010H
  00319	bb 01 00 00 00	 mov	 ebx, 1
  0031e	33 ff		 xor	 edi, edi
  00320	eb 74		 jmp	 SHORT $LN58@gObjSkillU@2
$LN25@gObjSkillU@2:

; 14143: 			{
; 14144: 				char szMsg[256];
; 14145: 				wsprintf(szMsg,lMsg.Get(1254));

  00322	68 e6 04 00 00	 push	 1254			; 000004e6H
  00327	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0032c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00331	50		 push	 eax
  00332	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szMsg$166755[ebp]
  00338	52		 push	 edx
  00339	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 14146: 
; 14147: 				GCServerMsgStringSend(szMsg,lpObj->m_Index,1);

  0033f	8b 06		 mov	 eax, DWORD PTR [esi]
  00341	6a 01		 push	 1
  00343	50		 push	 eax
  00344	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szMsg$166755[ebp]
  0034a	51		 push	 ecx
  0034b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00350	83 c4 14	 add	 esp, 20			; 00000014H

; 14152: 			}

  00353	bb 01 00 00 00	 mov	 ebx, 1
  00358	33 ff		 xor	 edi, edi
  0035a	eb 3a		 jmp	 SHORT $LN58@gObjSkillU@2
$LN27@gObjSkillU@2:

; 14153: 		}
; 14154: 		else if(lpObj->SkillRecallParty_Time <= 5)

  0035c	66 83 f8 05	 cmp	 ax, 5
  00360	77 34		 ja	 SHORT $LN58@gObjSkillU@2

; 14155: 		{
; 14156: 			char szMsg[256];
; 14157: 			wsprintf(szMsg,lMsg.Get(1243),lpObj->SkillRecallParty_Time);

  00362	0f b7 d0	 movzx	 edx, ax
  00365	52		 push	 edx
  00366	68 db 04 00 00	 push	 1243			; 000004dbH
  0036b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00370	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00375	50		 push	 eax
  00376	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$166759[ebp]
  0037c	50		 push	 eax
  0037d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 14158: 
; 14159: 			GCServerMsgStringSend(szMsg,lpObj->m_Index,1);

  00383	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00385	53		 push	 ebx
  00386	51		 push	 ecx
  00387	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szMsg$166759[ebp]
  0038d	52		 push	 edx
  0038e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00393	83 c4 18	 add	 esp, 24			; 00000018H
$LN58@gObjSkillU@2:

; 14160: 		}
; 14161: 	}
; 14162: 
; 14163: 	if(lpObj->SkillAddCriticalDamageTime != 0 && lpObj->Type == OBJ_USER)

  00396	0f b7 86 b6 10
	00 00		 movzx	 eax, WORD PTR [esi+4278]
  0039d	66 3b c7	 cmp	 ax, di
  003a0	74 48		 je	 SHORT $LN20@gObjSkillU@2
  003a2	66 39 5e 60	 cmp	 WORD PTR [esi+96], bx
  003a6	75 42		 jne	 SHORT $LN20@gObjSkillU@2

; 14164: 	{
; 14165: 		lpObj->SkillAddCriticalDamageTime--;

  003a8	48		 dec	 eax
  003a9	66 89 86 b6 10
	00 00		 mov	 WORD PTR [esi+4278], ax

; 14166: 
; 14167: 		if(lpObj->SkillAddCriticalDamageTime <= 0)

  003b0	66 3b c7	 cmp	 ax, di
  003b3	77 35		 ja	 SHORT $LN20@gObjSkillU@2

; 14168: 		{
; 14169: 			lpObj->SkillAddCriticalDamageTime = 0;

  003b5	33 c0		 xor	 eax, eax

; 14170: 			lpObj->SkillAddCriticalDamage = 0;
; 14171: 
; 14172: 			MsgOutput(lpObj->m_Index,lMsg.Get(1242));

  003b7	68 da 04 00 00	 push	 1242			; 000004daH
  003bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003c1	89 86 b6 10 00
	00		 mov	 DWORD PTR [esi+4278], eax
  003c7	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003cc	8b 16		 mov	 edx, DWORD PTR [esi]
  003ce	50		 push	 eax
  003cf	52		 push	 edx
  003d0	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 14173: 
; 14174: 			lpObj->m_ViewSkillState &= ~0x800;

  003d5	81 a6 c4 01 00
	00 ff f7 ff ff	 and	 DWORD PTR [esi+452], -2049 ; fffff7ffH

; 14175: 			GCMagicCancelSend(lpObj,64);

  003df	6a 40		 push	 64			; 00000040H
  003e1	56		 push	 esi
  003e2	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  003e7	83 c4 10	 add	 esp, 16			; 00000010H
$LN20@gObjSkillU@2:

; 14176: 		}
; 14177: 	}
; 14178: 
; 14179: 	if(lpObj->m_iSkillStunTime != 0 && lpObj->Type == OBJ_USER)

  003ea	8b 86 dc 14 00
	00		 mov	 eax, DWORD PTR [esi+5340]
  003f0	3b c7		 cmp	 eax, edi
  003f2	74 48		 je	 SHORT $LN18@gObjSkillU@2
  003f4	66 39 5e 60	 cmp	 WORD PTR [esi+96], bx
  003f8	75 42		 jne	 SHORT $LN18@gObjSkillU@2

; 14180: 	{
; 14181: 		lpObj->m_iSkillStunTime--;

  003fa	48		 dec	 eax
  003fb	89 86 dc 14 00
	00		 mov	 DWORD PTR [esi+5340], eax

; 14182: 
; 14183: 		if(lpObj->m_iSkillStunTime <= 0)

  00401	3b c7		 cmp	 eax, edi
  00403	7f 37		 jg	 SHORT $LN18@gObjSkillU@2

; 14184: 		{
; 14185: 			lpObj->m_iSkillStunTime = 0;
; 14186: 			MsgOutput(lpObj->m_Index,lMsg.Get(1636));

  00405	68 64 06 00 00	 push	 1636			; 00000664H
  0040a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0040f	89 be dc 14 00
	00		 mov	 DWORD PTR [esi+5340], edi
  00415	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0041a	50		 push	 eax
  0041b	8b 06		 mov	 eax, DWORD PTR [esi]
  0041d	50		 push	 eax
  0041e	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 14187: 			lpObj->m_ViewSkillState &= ~0x1000;

  00423	81 a6 c4 01 00
	00 ff ef ff ff	 and	 DWORD PTR [esi+452], -4097 ; ffffefffH

; 14188: 
; 14189: 			GCStateInfoSend(lpObj,0,0x1000);

  0042d	68 00 10 00 00	 push	 4096			; 00001000H
  00432	57		 push	 edi
  00433	56		 push	 esi
  00434	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  00439	83 c4 14	 add	 esp, 20			; 00000014H
$LN18@gObjSkillU@2:

; 14190: 		}
; 14191: 	}
; 14192: 
; 14193: 	if(lpObj->m_iSkillBrandOfSkillTime != 0 && lpObj->Type == OBJ_USER)

  0043c	8b 86 e0 14 00
	00		 mov	 eax, DWORD PTR [esi+5344]
  00442	3b c7		 cmp	 eax, edi
  00444	74 48		 je	 SHORT $LN16@gObjSkillU@2
  00446	66 39 5e 60	 cmp	 WORD PTR [esi+96], bx
  0044a	75 42		 jne	 SHORT $LN16@gObjSkillU@2

; 14194: 	{
; 14195: 		lpObj->m_iSkillBrandOfSkillTime--;

  0044c	48		 dec	 eax
  0044d	89 86 e0 14 00
	00		 mov	 DWORD PTR [esi+5344], eax

; 14196: 
; 14197: 		if(lpObj->m_iSkillBrandOfSkillTime <= 0)

  00453	3b c7		 cmp	 eax, edi
  00455	7f 37		 jg	 SHORT $LN16@gObjSkillU@2

; 14198: 		{
; 14199: 			lpObj->m_iSkillBrandOfSkillTime = 0;
; 14200: 			MsgOutput(lpObj->m_Index,lMsg.Get(1637));

  00457	68 65 06 00 00	 push	 1637			; 00000665H
  0045c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00461	89 be e0 14 00
	00		 mov	 DWORD PTR [esi+5344], edi
  00467	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0046c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0046e	50		 push	 eax
  0046f	51		 push	 ecx
  00470	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 14201: 
; 14202: 			lpObj->m_ViewSkillState &= ~0x200;

  00475	81 a6 c4 01 00
	00 ff fd ff ff	 and	 DWORD PTR [esi+452], -513 ; fffffdffH

; 14203: 			GCStateInfoSend(lpObj,0,0x200);

  0047f	68 00 02 00 00	 push	 512			; 00000200H
  00484	57		 push	 edi
  00485	56		 push	 esi
  00486	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  0048b	83 c4 14	 add	 esp, 20			; 00000014H
$LN16@gObjSkillU@2:

; 14204: 		}
; 14205: 	}
; 14206: 
; 14207: 	if(lpObj->m_iSkillInvisibleTime != 0 && lpObj->Type == OBJ_USER)

  0048e	8b 86 e4 14 00
	00		 mov	 eax, DWORD PTR [esi+5348]
  00494	3b c7		 cmp	 eax, edi
  00496	74 48		 je	 SHORT $LN14@gObjSkillU@2
  00498	66 39 5e 60	 cmp	 WORD PTR [esi+96], bx
  0049c	75 42		 jne	 SHORT $LN14@gObjSkillU@2

; 14208: 	{
; 14209: 		lpObj->m_iSkillInvisibleTime--;

  0049e	48		 dec	 eax
  0049f	89 86 e4 14 00
	00		 mov	 DWORD PTR [esi+5348], eax

; 14210: 
; 14211: 		if(lpObj->m_iSkillInvisibleTime <= 0)

  004a5	3b c7		 cmp	 eax, edi
  004a7	7f 37		 jg	 SHORT $LN14@gObjSkillU@2

; 14212: 		{
; 14213: 			lpObj->m_iSkillInvisibleTime = 0;
; 14214: 			MsgOutput(lpObj->m_Index,lMsg.Get(1638));

  004a9	68 66 06 00 00	 push	 1638			; 00000666H
  004ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004b3	89 be e4 14 00
	00		 mov	 DWORD PTR [esi+5348], edi
  004b9	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  004be	8b 16		 mov	 edx, DWORD PTR [esi]
  004c0	50		 push	 eax
  004c1	52		 push	 edx
  004c2	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 14215: 
; 14216: 			lpObj->m_ViewSkillState &= ~0x4000;

  004c7	81 a6 c4 01 00
	00 ff bf ff ff	 and	 DWORD PTR [esi+452], -16385 ; ffffbfffH

; 14217: 			GCStateInfoSend(lpObj,0,0x4000);

  004d1	68 00 40 00 00	 push	 16384			; 00004000H
  004d6	57		 push	 edi
  004d7	56		 push	 esi
  004d8	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  004dd	83 c4 14	 add	 esp, 20			; 00000014H
$LN14@gObjSkillU@2:

; 14218: 		}
; 14219: 	}
; 14220: 
; 14221: 	if(lpObj->m_iSkillManaSwellTime != 0 && lpObj->Type == OBJ_USER)

  004e0	8b 86 e8 14 00
	00		 mov	 eax, DWORD PTR [esi+5352]
  004e6	3b c7		 cmp	 eax, edi
  004e8	0f 84 e9 00 00
	00		 je	 $LN12@gObjSkillU@2
  004ee	66 39 5e 60	 cmp	 WORD PTR [esi+96], bx
  004f2	0f 85 df 00 00
	00		 jne	 $LN12@gObjSkillU@2

; 14222: 	{
; 14223: 		lpObj->m_iSkillManaSwellTime--;

  004f8	48		 dec	 eax
  004f9	89 86 e8 14 00
	00		 mov	 DWORD PTR [esi+5352], eax

; 14224: 
; 14225: 		if(lpObj->m_iSkillManaSwellTime <= 0)

  004ff	3b c7		 cmp	 eax, edi
  00501	0f 8f d0 00 00
	00		 jg	 $LN12@gObjSkillU@2

; 14226: 		{
; 14227: 			lpObj->AddMana -= lpObj->m_iSkillManaSwell;

  00507	8b 86 ec 14 00
	00		 mov	 eax, DWORD PTR [esi+5356]
  0050d	29 86 10 01 00
	00		 sub	 DWORD PTR [esi+272], eax

; 14228: 
; 14229: 			if(lpObj->AddMana < 0)

  00513	79 06		 jns	 SHORT $LN11@gObjSkillU@2

; 14230: 			{
; 14231: 				lpObj->AddMana = 0;

  00515	89 be 10 01 00
	00		 mov	 DWORD PTR [esi+272], edi
$LN11@gObjSkillU@2:

; 14232: 			}
; 14233: 
; 14234: 			GCManaSend(lpObj->m_Index,lpObj->MaxMana+lpObj->AddMana,0xFE,0,lpObj->MaxBP+lpObj->AddBP);

  0051b	8b 8e f0 00 00
	00		 mov	 ecx, DWORD PTR [esi+240]
  00521	db 86 10 01 00
	00		 fild	 DWORD PTR [esi+272]
  00527	03 8e ec 00 00
	00		 add	 ecx, DWORD PTR [esi+236]
  0052d	d8 86 d4 00 00
	00		 fadd	 DWORD PTR [esi+212]
  00533	51		 push	 ecx
  00534	57		 push	 edi
  00535	68 fe 00 00 00	 push	 254			; 000000feH
  0053a	e8 00 00 00 00	 call	 __ftol2_sse
  0053f	8b 16		 mov	 edx, DWORD PTR [esi]
  00541	50		 push	 eax
  00542	52		 push	 edx
  00543	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend

; 14235: 
; 14236: 			if(lpObj->Mana > lpObj->MaxMana + lpObj->AddMana)

  00548	db 86 10 01 00
	00		 fild	 DWORD PTR [esi+272]
  0054e	83 c4 14	 add	 esp, 20			; 00000014H
  00551	d8 86 d4 00 00
	00		 fadd	 DWORD PTR [esi+212]
  00557	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  0055d	d8 d9		 fcomp	 ST(1)
  0055f	df e0		 fnstsw	 ax
  00561	f6 c4 41	 test	 ah, 65			; 00000041H
  00564	75 32		 jne	 SHORT $LN64@gObjSkillU@2

; 14237: 			{
; 14238: 				lpObj->Mana = lpObj->MaxMana + lpObj->AddMana;
; 14239: 				GCManaSend(lpObj->m_Index,lpObj->Mana,0xFF,0,lpObj->BP);

  00566	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR [esi+232]
  0056c	d9 9d f8 fe ff
	ff		 fstp	 DWORD PTR tv877[ebp]
  00572	d9 85 f8 fe ff
	ff		 fld	 DWORD PTR tv877[ebp]
  00578	50		 push	 eax
  00579	57		 push	 edi
  0057a	d9 96 d0 00 00
	00		 fst	 DWORD PTR [esi+208]
  00580	68 ff 00 00 00	 push	 255			; 000000ffH
  00585	e8 00 00 00 00	 call	 __ftol2_sse
  0058a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0058c	50		 push	 eax
  0058d	51		 push	 ecx
  0058e	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  00593	83 c4 14	 add	 esp, 20			; 00000014H
  00596	eb 02		 jmp	 SHORT $LN10@gObjSkillU@2
$LN64@gObjSkillU@2:
  00598	dd d8		 fstp	 ST(0)
$LN10@gObjSkillU@2:

; 14240: 			}
; 14241: 
; 14242: 			lpObj->m_iSkillManaSwellTime = 0;
; 14243: 			lpObj->m_iSkillManaSwell = 0;
; 14244: 			MsgOutput(lpObj->m_Index,lMsg.Get(1639));

  0059a	68 67 06 00 00	 push	 1639			; 00000667H
  0059f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  005a4	89 be e8 14 00
	00		 mov	 DWORD PTR [esi+5352], edi
  005aa	89 be ec 14 00
	00		 mov	 DWORD PTR [esi+5356], edi
  005b0	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  005b5	8b 16		 mov	 edx, DWORD PTR [esi]
  005b7	50		 push	 eax
  005b8	52		 push	 edx
  005b9	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 14245: 
; 14246: 			lpObj->m_ViewSkillState &= ~0x2000;

  005be	81 a6 c4 01 00
	00 ff df ff ff	 and	 DWORD PTR [esi+452], -8193 ; ffffdfffH

; 14247: 			GCStateInfoSend(lpObj,0,0x2000);

  005c8	68 00 20 00 00	 push	 8192			; 00002000H
  005cd	57		 push	 edi
  005ce	56		 push	 esi
  005cf	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  005d4	83 c4 14	 add	 esp, 20			; 00000014H
$LN12@gObjSkillU@2:

; 14248: 		}
; 14249: 	}
; 14250: 
; 14251: 	if(lpObj->m_iPotionBlessTime != 0 && lpObj->Type == OBJ_USER)

  005d7	8b 86 f4 14 00
	00		 mov	 eax, DWORD PTR [esi+5364]
  005dd	3b c7		 cmp	 eax, edi
  005df	74 48		 je	 SHORT $LN8@gObjSkillU@2
  005e1	66 39 5e 60	 cmp	 WORD PTR [esi+96], bx
  005e5	75 42		 jne	 SHORT $LN8@gObjSkillU@2

; 14252: 	{
; 14253: 		lpObj->m_iPotionBlessTime--;

  005e7	48		 dec	 eax
  005e8	89 86 f4 14 00
	00		 mov	 DWORD PTR [esi+5364], eax

; 14254: 
; 14255: 		if(lpObj->m_iPotionBlessTime <= 0)

  005ee	3b c7		 cmp	 eax, edi
  005f0	7f 37		 jg	 SHORT $LN8@gObjSkillU@2

; 14256: 		{
; 14257: 			lpObj->m_iPotionBlessTime = 0;
; 14258: 			MsgOutput(lpObj->m_Index,lMsg.Get(1634));

  005f2	68 62 06 00 00	 push	 1634			; 00000662H
  005f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  005fc	89 be f4 14 00
	00		 mov	 DWORD PTR [esi+5364], edi
  00602	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00607	50		 push	 eax
  00608	8b 06		 mov	 eax, DWORD PTR [esi]
  0060a	50		 push	 eax
  0060b	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 14259: 
; 14260: 			lpObj->m_ViewSkillState &= ~0x8000;

  00610	81 a6 c4 01 00
	00 ff 7f ff ff	 and	 DWORD PTR [esi+452], -32769 ; ffff7fffH

; 14261: 			GCStateInfoSend(lpObj,0,0x8000);

  0061a	68 00 80 00 00	 push	 32768			; 00008000H
  0061f	57		 push	 edi
  00620	56		 push	 esi
  00621	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  00626	83 c4 14	 add	 esp, 20			; 00000014H
$LN8@gObjSkillU@2:

; 14262: 		}
; 14263: 	}
; 14264: 
; 14265: 	if(lpObj->m_iPotionSoulTime != 0 && lpObj->Type == OBJ_USER)

  00629	8b 86 f8 14 00
	00		 mov	 eax, DWORD PTR [esi+5368]
  0062f	3b c7		 cmp	 eax, edi
  00631	74 48		 je	 SHORT $LN6@gObjSkillU@2
  00633	66 39 5e 60	 cmp	 WORD PTR [esi+96], bx
  00637	75 42		 jne	 SHORT $LN6@gObjSkillU@2

; 14266: 	{
; 14267: 		lpObj->m_iPotionSoulTime--;

  00639	48		 dec	 eax
  0063a	89 86 f8 14 00
	00		 mov	 DWORD PTR [esi+5368], eax

; 14268: 
; 14269: 		if(lpObj->m_iPotionSoulTime <= 0)

  00640	3b c7		 cmp	 eax, edi
  00642	7f 37		 jg	 SHORT $LN6@gObjSkillU@2

; 14270: 		{
; 14271: 			lpObj->m_iPotionSoulTime = 0;
; 14272: 			MsgOutput(lpObj->m_Index,lMsg.Get(1635));

  00644	68 63 06 00 00	 push	 1635			; 00000663H
  00649	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0064e	89 be f8 14 00
	00		 mov	 DWORD PTR [esi+5368], edi
  00654	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00659	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0065b	50		 push	 eax
  0065c	51		 push	 ecx
  0065d	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 14273: 
; 14274: 			lpObj->m_ViewSkillState &= ~0x10000;

  00662	81 a6 c4 01 00
	00 ff ff fe ff	 and	 DWORD PTR [esi+452], -65537 ; fffeffffH

; 14275: 			GCStateInfoSend(lpObj,0,0x10000);

  0066c	68 00 00 01 00	 push	 65536			; 00010000H
  00671	57		 push	 edi
  00672	56		 push	 esi
  00673	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  00678	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@gObjSkillU@2:

; 14276: 		}
; 14277: 	}
; 14278: 
; 14279: 	if(lpObj->m_SkillNumber < 1)

  0067b	0f b7 86 3c 02
	00 00		 movzx	 eax, WORD PTR [esi+572]
  00682	66 3b c3	 cmp	 ax, bx
  00685	7c 57		 jl	 SHORT $LN1@gObjSkillU@2

; 14280: 	{
; 14281: 		return;
; 14282: 	}
; 14283: 
; 14284: 	if(lpObj->m_SkillNumber == 18)

  00687	66 83 f8 12	 cmp	 ax, 18			; 00000012H
  0068b	75 17		 jne	 SHORT $LN3@gObjSkillU@2

; 14285: 	{
; 14286: 		if(GetTickCount() > lpObj->m_SkillTime)

  0068d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00693	3b 86 40 02 00
	00		 cmp	 eax, DWORD PTR [esi+576]
  00699	76 09		 jbe	 SHORT $LN3@gObjSkillU@2

; 14287: 		{
; 14288: 			lpObj->m_SkillNumber = 0;

  0069b	33 d2		 xor	 edx, edx
  0069d	66 89 96 3c 02
	00 00		 mov	 WORD PTR [esi+572], dx
$LN3@gObjSkillU@2:

; 14289: 		}
; 14290: 	}
; 14291: 
; 14292: 	if(lpObj->m_iMuseElfInfinityArrowSkillTime != 0 && lpObj->Type == OBJ_USER)

  006a4	8b 86 30 15 00
	00		 mov	 eax, DWORD PTR [esi+5424]
  006aa	3b c7		 cmp	 eax, edi
  006ac	74 30		 je	 SHORT $LN1@gObjSkillU@2
  006ae	66 39 5e 60	 cmp	 WORD PTR [esi+96], bx
  006b2	75 2a		 jne	 SHORT $LN1@gObjSkillU@2

; 14293: 	{
; 14294: 		lpObj->m_iMuseElfInfinityArrowSkillTime--;

  006b4	48		 dec	 eax
  006b5	89 86 30 15 00
	00		 mov	 DWORD PTR [esi+5424], eax

; 14295: 
; 14296: 		if(lpObj->m_iMuseElfInfinityArrowSkillTime <= 0)

  006bb	3b c7		 cmp	 eax, edi
  006bd	7f 1f		 jg	 SHORT $LN1@gObjSkillU@2

; 14297: 		{
; 14298: 			lpObj->m_iMuseElfInfinityArrowSkillTime = 0;
; 14299: 			lpObj->m_ViewSkillState &= ~0x4000000;

  006bf	81 a6 c4 01 00
	00 ff ff ff fb	 and	 DWORD PTR [esi+452], -67108865 ; fbffffffH

; 14300: 			GCStateInfoSend(lpObj,0,0x4000000);

  006c9	68 00 00 00 04	 push	 67108864		; 04000000H
  006ce	57		 push	 edi
  006cf	56		 push	 esi
  006d0	89 be 30 15 00
	00		 mov	 DWORD PTR [esi+5424], edi
  006d6	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  006db	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjSkillU@2:

; 14301: 		}
; 14302: 	}
; 14303: }

  006de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006e1	5f		 pop	 edi
  006e2	5e		 pop	 esi
  006e3	33 cd		 xor	 ecx, ebp
  006e5	5b		 pop	 ebx
  006e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006eb	8b e5		 mov	 esp, ebp
  006ed	5d		 pop	 ebp
  006ee	c3		 ret	 0
?gObjSkillUseProc@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjSkillUseProc
_TEXT	ENDS
PUBLIC	?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_skillnumber$ = 12					; size = 1
?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@E@Z PROC ; gObjGetMagicSearch, COMDAT

; 15075: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15076: 	if(skillnumber == 58)

  00003	80 7d 0c 3a	 cmp	 BYTE PTR _skillnumber$[ebp], 58 ; 0000003aH
  00007	75 04		 jne	 SHORT $LN8@gObjGetMag@3

; 15077: 	{
; 15078: 		skillnumber = 40;

  00009	c6 45 0c 28	 mov	 BYTE PTR _skillnumber$[ebp], 40 ; 00000028H
$LN8@gObjGetMag@3:
  0000d	53		 push	 ebx

; 15079: 	}
; 15080: 
; 15081: 	for(int n = 0; n < MAGIC_SIZE;n++)

  0000e	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	33 ff		 xor	 edi, edi
  00015	33 f6		 xor	 esi, esi
  00017	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL7@gObjGetMag@3:

; 15082: 	{
; 15083: 		if(lpObj->Magic[n].IsMagic() == 1)

  00020	8b 8b 38 03 00
	00		 mov	 ecx, DWORD PTR [ebx+824]
  00026	03 ce		 add	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0002d	83 f8 01	 cmp	 eax, 1
  00030	75 0f		 jne	 SHORT $LN6@gObjGetMag@3

; 15084: 		{
; 15085: 			if(lpObj->Magic[n].m_Skill == skillnumber)

  00032	8b 83 38 03 00
	00		 mov	 eax, DWORD PTR [ebx+824]
  00038	8a 4d 0c	 mov	 cl, BYTE PTR _skillnumber$[ebp]
  0003b	38 4c 30 05	 cmp	 BYTE PTR [eax+esi+5], cl
  0003f	74 13		 je	 SHORT $LN12@gObjGetMag@3
$LN6@gObjGetMag@3:

; 15079: 	}
; 15080: 
; 15081: 	for(int n = 0; n < MAGIC_SIZE;n++)

  00041	83 c6 10	 add	 esi, 16			; 00000010H
  00044	47		 inc	 edi
  00045	81 fe c0 03 00
	00		 cmp	 esi, 960		; 000003c0H
  0004b	7c d3		 jl	 SHORT $LL7@gObjGetMag@3

; 15095: 				}
; 15096: 			}
; 15097: 		}
; 15098: 	}
; 15099: 	return false;

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	33 c0		 xor	 eax, eax
  00051	5b		 pop	 ebx

; 15100: }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN12@gObjGetMag@3:

; 15086: 			{
; 15087: 				if(gObjMagicEnergyCheck(lpObj,lpObj->Magic[n].m_Skill) == 0)

  00054	c1 e7 04	 shl	 edi, 4
  00057	0f b6 44 38 05	 movzx	 eax, BYTE PTR [eax+edi+5]
  0005c	50		 push	 eax
  0005d	53		 push	 ebx
  0005e	e8 00 00 00 00	 call	 ?gObjMagicEnergyCheck@@YAHPAUOBJECTSTRUCT@@E@Z ; gObjMagicEnergyCheck
  00063	83 c4 08	 add	 esp, 8
  00066	85 c0		 test	 eax, eax
  00068	75 24		 jne	 SHORT $LN2@gObjGetMag@3

; 15088: 				{
; 15089: 					GCServerMsgStringSend(lMsg.Get(1255),lpObj->m_Index,1);

  0006a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0006c	6a 01		 push	 1
  0006e	51		 push	 ecx
  0006f	68 e7 04 00 00	 push	 1255			; 000004e7H
  00074	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00079	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 15095: 				}
; 15096: 			}
; 15097: 		}
; 15098: 	}
; 15099: 	return false;

  00089	33 c0		 xor	 eax, eax
  0008b	5b		 pop	 ebx

; 15100: }

  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
$LN2@gObjGetMag@3:

; 15090: 					return false;
; 15091: 				}
; 15092: 				else
; 15093: 				{
; 15094: 					return &lpObj->Magic[n];

  0008e	8b 83 38 03 00
	00		 mov	 eax, DWORD PTR [ebx+824]
  00094	03 c7		 add	 eax, edi
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx

; 15100: }

  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@E@Z ENDP ; gObjGetMagicSearch
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarItemGive
; Function compile flags: /Ogtp
;	COMDAT ?gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z
_TEXT	SEGMENT
__$ArrayPad$ = -4					; size = 4
_lpWinGuild$ = 8					; size = 4
_lpLoseGuild$ = 12					; size = 4
?gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z PROC ; gObjGuildWarItemGive, COMDAT

; 16166: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00009	33 c5		 xor	 eax, ebp
  0000b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 16167: 	return true;
; 16168: 	int n;
; 16169: 	int r_userindex[MAX_USER_GUILD];
; 16170: 	int r_usercount;
; 16171: 
; 16172: 	for(n = 0; n < MAX_USER_GUILD; n++)
; 16173: 	{
; 16174: 		if(lpLoseGuild->Use[n] > 0)
; 16175: 		{
; 16176: 			r_userindex[r_usercount] = lpLoseGuild->Index[n];
; 16177: 			r_usercount++;
; 16178: 		}
; 16179: 	}
; 16180: 
; 16181: 	if(r_usercount < 1)
; 16182: 	{
; 16183: 		LogAdd(LOG_BLACK, lMsg.Get(560),__FILE__,__LINE__);
; 16184: 		return false;
; 16185: 	}
; 16186: 
; 16187: 	int lose_user = r_userindex[rand()%r_usercount];
; 16188: 
; 16189: 	if(lose_user < 0)
; 16190: 	{
; 16191: 		LogAdd(LOG_BLACK, lMsg.Get(560),__FILE__,__LINE__);
; 16192: 		return false;
; 16193: 	}
; 16194: 
; 16195: 	if(gObj[lose_user].Connected < PLAYER_PLAYING)
; 16196: 	{
; 16197: 		LogAdd(LOG_BLACK, lMsg.Get(560),__FILE__,__LINE__);
; 16198: 		return false;
; 16199: 	}
; 16200: 
; 16201: 	r_usercount = 0;
; 16202: 
; 16203: 	for(n = 0; n < MAX_USER_GUILD;n++)
; 16204: 	{
; 16205: 		if(lpWinGuild->Use[n] > 0)
; 16206: 		{
; 16207: 			r_userindex[r_usercount] = lpWinGuild->Index[n];
; 16208: 			r_usercount++;
; 16209: 		}
; 16210: 	}
; 16211: 
; 16212: 	if(r_usercount < 1)
; 16213: 	{
; 16214: 		LogAdd(LOG_BLACK, lMsg.Get(561));
; 16215: 		return false;
; 16216: 	}
; 16217: 
; 16218: 	int win_user = r_userindex[rand()%r_usercount];
; 16219: 
; 16220: 	if(win_user < 0)
; 16221: 	{
; 16222: 		LogAdd(LOG_BLACK, lMsg.Get(561));
; 16223: 		return false;
; 16224: 	}
; 16225: 
; 16226: 	if(gObj[win_user].Connected < PLAYER_PLAYING)
; 16227: 	{
; 16228: 		LogAdd(LOG_BLACK, lMsg.Get(561));
; 16229: 		return false;
; 16230: 	}
; 16231: 
; 16232: 	LPOBJ lpObj = &gObj[lose_user];
; 16233: 
; 16234: 	int count = 24;
; 16235: 
; 16236: 	int number;
; 16237: 
; 16238: 	while(count--)
; 16239: 	{
; 16240: 		number = rand()%12;
; 16241: 
; 16242: 		if(lpObj->pInventory[number].IsItem()==1)
; 16243: 		{
; 16244: 			if(gObjInventoryInsertItem(win_user,lpObj->pInventory[number]) != 0xFF)
; 16245: 			{
; 16246: 				return true;
; 16247: 			}
; 16248: 			break;
; 16249: 		}
; 16250: 	}
; 16251: 
; 16252: 	count = 64;
; 16253: 
; 16254: 	while(count--)
; 16255: 	{
; 16256: 		number = rand()%64+12;
; 16257: 
; 16258: 		if(lpObj->pInventory[number].IsItem()==1)
; 16259: 		{
; 16260: 			if(gObjInventoryInsertItem(win_user,lpObj->pInventory[number]) != 0xFF)
; 16261: 			{
; 16262: 				return true;
; 16263: 			}
; 16264: 			break;
; 16265: 		}
; 16266: 	}
; 16267: 	return true;
; 16268: }

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00011	33 cd		 xor	 ecx, ebp
  00013	b8 01 00 00 00	 mov	 eax, 1
  00018	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z ENDP ; gObjGuildWarItemGive
_TEXT	ENDS
PUBLIC	??_C@_0CL@IFDDAPIM@?$FL?$CFd?$FN?9?$FL?$CFd?$FN?5Total?5?$CFd?5?$CFs?5?$CFd?5?$CFs?5?$CFd?5?$CF@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?gObjSendUserStatistic@@YAXHHH@Z		; gObjSendUserStatistic
;	COMDAT ??_C@_0CL@IFDDAPIM@?$FL?$CFd?$FN?9?$FL?$CFd?$FN?5Total?5?$CFd?5?$CFs?5?$CFd?5?$CFs?5?$CFd?5?$CF@
CONST	SEGMENT
??_C@_0CL@IFDDAPIM@?$FL?$CFd?$FN?9?$FL?$CFd?$FN?5Total?5?$CFd?5?$CFs?5?$CFd?5?$CFs?5?$CFd?5?$CF@ DB '['
	DB	'%d]-[%d] Total %d %s %d %s %d %s %d %s %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjSendUserStatistic@@YAXHHH@Z
_TEXT	SEGMENT
_sClassCount$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_startLevel$ = 12					; size = 4
_endLevel$ = 16						; size = 4
?gObjSendUserStatistic@@YAXHHH@Z PROC			; gObjSendUserStatistic, COMDAT

; 16589: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx

; 16590: 	if(gDisconnect == 1)

  00011	bb 01 00 00 00	 mov	 ebx, 1
  00016	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?gDisconnect@@3HA, ebx ; gDisconnect
  0001c	0f 84 79 01 00
	00		 je	 $LN8@gObjSendUs

; 16591: 	{
; 16592: 		return;
; 16593: 	}
; 16594: 
; 16595: 	if(endLevel < startLevel)

  00022	56		 push	 esi
  00023	8b 75 0c	 mov	 esi, DWORD PTR _startLevel$[ebp]
  00026	57		 push	 edi
  00027	8b 7d 10	 mov	 edi, DWORD PTR _endLevel$[ebp]
  0002a	3b fe		 cmp	 edi, esi
  0002c	7d 05		 jge	 SHORT $LN6@gObjSendUs

; 16596: 	{
; 16597: 		endLevel = MAX_CHAR_LEVEL;

  0002e	bf 90 01 00 00	 mov	 edi, 400		; 00000190H
$LN6@gObjSendUs:

; 16598: 	}
; 16599: 
; 16600: 	int n;
; 16601: 	LPOBJ lpObj;
; 16602: 	int sClassCount[5];
; 16603: 
; 16604: 	sClassCount[CLASS_WIZARD] = 0;

  00033	33 c0		 xor	 eax, eax
  00035	89 45 e8	 mov	 DWORD PTR _sClassCount$[ebp], eax

; 16605: 	sClassCount[CLASS_KNIGHT] = 0;

  00038	89 45 ec	 mov	 DWORD PTR _sClassCount$[ebp+4], eax

; 16606: 	sClassCount[CLASS_ELF] = 0;

  0003b	89 45 f0	 mov	 DWORD PTR _sClassCount$[ebp+8], eax

; 16607: 	sClassCount[CLASS_MAGUMSA] = 0;

  0003e	89 45 f4	 mov	 DWORD PTR _sClassCount$[ebp+12], eax

; 16608: 	sClassCount[4] = 0;

  00041	89 45 f8	 mov	 DWORD PTR _sClassCount$[ebp+16], eax
  00044	b8 9c c4 16 02	 mov	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046556
  00049	b2 02		 mov	 dl, 2
  0004b	eb 03 8d 49 00	 npad	 5
$LL5@gObjSendUs:

; 16611: 	{
; 16612: 		lpObj = &gObj[n];
; 16613: 
; 16614: 		if(lpObj->Connected > PLAYER_LOGGED)

  00050	38 90 68 ff ff
	ff		 cmp	 BYTE PTR [eax-152], dl
  00056	76 1a		 jbe	 SHORT $LN4@gObjSendUs

; 16615: 		{
; 16616: 			if(lpObj->Level >= startLevel && lpObj->Level <= endLevel)

  00058	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0005b	3b ce		 cmp	 ecx, esi
  0005d	7c 10		 jl	 SHORT $LN1@gObjSendUs
  0005f	3b cf		 cmp	 ecx, edi
  00061	7f 0c		 jg	 SHORT $LN1@gObjSendUs

; 16617: 			{
; 16618: 				sClassCount[lpObj->Class]++;

  00063	0f b7 48 fc	 movzx	 ecx, WORD PTR [eax-4]
  00067	01 5c 8d e8	 add	 DWORD PTR _sClassCount$[ebp+ecx*4], ebx
  0006b	8d 4c 8d e8	 lea	 ecx, DWORD PTR _sClassCount$[ebp+ecx*4]
$LN1@gObjSendUs:

; 16619: 			}
; 16620: 
; 16621: 			sClassCount[4]++;

  0006f	01 5d f8	 add	 DWORD PTR _sClassCount$[ebp+16], ebx
$LN4@gObjSendUs:

; 16611: 	{
; 16612: 		lpObj = &gObj[n];
; 16613: 
; 16614: 		if(lpObj->Connected > PLAYER_LOGGED)

  00072	38 90 cc 14 00
	00		 cmp	 BYTE PTR [eax+5324], dl
  00078	76 21		 jbe	 SHORT $LN14@gObjSendUs

; 16615: 		{
; 16616: 			if(lpObj->Level >= startLevel && lpObj->Level <= endLevel)

  0007a	0f bf 88 64 15
	00 00		 movsx	 ecx, WORD PTR [eax+5476]
  00081	3b ce		 cmp	 ecx, esi
  00083	7c 13		 jl	 SHORT $LN13@gObjSendUs
  00085	3b cf		 cmp	 ecx, edi
  00087	7f 0f		 jg	 SHORT $LN13@gObjSendUs

; 16617: 			{
; 16618: 				sClassCount[lpObj->Class]++;

  00089	0f b7 88 60 15
	00 00		 movzx	 ecx, WORD PTR [eax+5472]
  00090	01 5c 8d e8	 add	 DWORD PTR _sClassCount$[ebp+ecx*4], ebx
  00094	8d 4c 8d e8	 lea	 ecx, DWORD PTR _sClassCount$[ebp+ecx*4]
$LN13@gObjSendUs:

; 16619: 			}
; 16620: 
; 16621: 			sClassCount[4]++;

  00098	01 5d f8	 add	 DWORD PTR _sClassCount$[ebp+16], ebx
$LN14@gObjSendUs:

; 16611: 	{
; 16612: 		lpObj = &gObj[n];
; 16613: 
; 16614: 		if(lpObj->Connected > PLAYER_LOGGED)

  0009b	38 90 30 2a 00
	00		 cmp	 BYTE PTR [eax+10800], dl
  000a1	76 21		 jbe	 SHORT $LN16@gObjSendUs

; 16615: 		{
; 16616: 			if(lpObj->Level >= startLevel && lpObj->Level <= endLevel)

  000a3	0f bf 88 c8 2a
	00 00		 movsx	 ecx, WORD PTR [eax+10952]
  000aa	3b ce		 cmp	 ecx, esi
  000ac	7c 13		 jl	 SHORT $LN15@gObjSendUs
  000ae	3b cf		 cmp	 ecx, edi
  000b0	7f 0f		 jg	 SHORT $LN15@gObjSendUs

; 16617: 			{
; 16618: 				sClassCount[lpObj->Class]++;

  000b2	0f b7 88 c4 2a
	00 00		 movzx	 ecx, WORD PTR [eax+10948]
  000b9	01 5c 8d e8	 add	 DWORD PTR _sClassCount$[ebp+ecx*4], ebx
  000bd	8d 4c 8d e8	 lea	 ecx, DWORD PTR _sClassCount$[ebp+ecx*4]
$LN15@gObjSendUs:

; 16619: 			}
; 16620: 
; 16621: 			sClassCount[4]++;

  000c1	01 5d f8	 add	 DWORD PTR _sClassCount$[ebp+16], ebx
$LN16@gObjSendUs:

; 16611: 	{
; 16612: 		lpObj = &gObj[n];
; 16613: 
; 16614: 		if(lpObj->Connected > PLAYER_LOGGED)

  000c4	38 90 94 3f 00
	00		 cmp	 BYTE PTR [eax+16276], dl
  000ca	76 21		 jbe	 SHORT $LN18@gObjSendUs

; 16615: 		{
; 16616: 			if(lpObj->Level >= startLevel && lpObj->Level <= endLevel)

  000cc	0f bf 88 2c 40
	00 00		 movsx	 ecx, WORD PTR [eax+16428]
  000d3	3b ce		 cmp	 ecx, esi
  000d5	7c 13		 jl	 SHORT $LN17@gObjSendUs
  000d7	3b cf		 cmp	 ecx, edi
  000d9	7f 0f		 jg	 SHORT $LN17@gObjSendUs

; 16617: 			{
; 16618: 				sClassCount[lpObj->Class]++;

  000db	0f b7 88 28 40
	00 00		 movzx	 ecx, WORD PTR [eax+16424]
  000e2	01 5c 8d e8	 add	 DWORD PTR _sClassCount$[ebp+ecx*4], ebx
  000e6	8d 4c 8d e8	 lea	 ecx, DWORD PTR _sClassCount$[ebp+ecx*4]
$LN17@gObjSendUs:

; 16619: 			}
; 16620: 
; 16621: 			sClassCount[4]++;

  000ea	01 5d f8	 add	 DWORD PTR _sClassCount$[ebp+16], ebx
$LN18@gObjSendUs:

; 16611: 	{
; 16612: 		lpObj = &gObj[n];
; 16613: 
; 16614: 		if(lpObj->Connected > PLAYER_LOGGED)

  000ed	38 90 f8 54 00
	00		 cmp	 BYTE PTR [eax+21752], dl
  000f3	76 21		 jbe	 SHORT $LN20@gObjSendUs

; 16615: 		{
; 16616: 			if(lpObj->Level >= startLevel && lpObj->Level <= endLevel)

  000f5	0f bf 88 90 55
	00 00		 movsx	 ecx, WORD PTR [eax+21904]
  000fc	3b ce		 cmp	 ecx, esi
  000fe	7c 13		 jl	 SHORT $LN19@gObjSendUs
  00100	3b cf		 cmp	 ecx, edi
  00102	7f 0f		 jg	 SHORT $LN19@gObjSendUs

; 16617: 			{
; 16618: 				sClassCount[lpObj->Class]++;

  00104	0f b7 88 8c 55
	00 00		 movzx	 ecx, WORD PTR [eax+21900]
  0010b	01 5c 8d e8	 add	 DWORD PTR _sClassCount$[ebp+ecx*4], ebx
  0010f	8d 4c 8d e8	 lea	 ecx, DWORD PTR _sClassCount$[ebp+ecx*4]
$LN19@gObjSendUs:

; 16619: 			}
; 16620: 
; 16621: 			sClassCount[4]++;

  00113	01 5d f8	 add	 DWORD PTR _sClassCount$[ebp+16], ebx
$LN20@gObjSendUs:

; 16598: 	}
; 16599: 
; 16600: 	int n;
; 16601: 	LPOBJ lpObj;
; 16602: 	int sClassCount[5];
; 16603: 
; 16604: 	sClassCount[CLASS_WIZARD] = 0;

  00116	05 f4 6a 00 00	 add	 eax, 27380		; 00006af4H

; 16609: 
; 16610: 	for(n = OBJ_STARTUSERINDEX; n < OBJMAX; n++)

  0011b	3d 3c 53 6a 02	 cmp	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522556
  00120	0f 8c 2a ff ff
	ff		 jl	 $LL5@gObjSendUs

; 16622: 		}
; 16623: 	}
; 16624: 
; 16625: 	MsgOutput(gObj[aIndex].m_Index,"[%d]-[%d] Total %d %s %d %s %d %s %d %s %d",startLevel,endLevel,sClassCount[4],
; 16626: 		lMsg.Get(1900),sClassCount[CLASS_WIZARD],
; 16627: 		lMsg.Get(1901),sClassCount[CLASS_KNIGHT],
; 16628: 		lMsg.Get(1902),sClassCount[CLASS_ELF],
; 16629: 		lMsg.Get(1903),sClassCount[CLASS_MAGUMSA]);

  00126	8b 45 f4	 mov	 eax, DWORD PTR _sClassCount$[ebp+12]
  00129	50		 push	 eax
  0012a	68 6f 07 00 00	 push	 1903			; 0000076fH
  0012f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00134	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00139	8b 4d f0	 mov	 ecx, DWORD PTR _sClassCount$[ebp+8]
  0013c	50		 push	 eax
  0013d	51		 push	 ecx
  0013e	68 6e 07 00 00	 push	 1902			; 0000076eH
  00143	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00148	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0014d	8b 55 ec	 mov	 edx, DWORD PTR _sClassCount$[ebp+4]
  00150	50		 push	 eax
  00151	52		 push	 edx
  00152	68 6d 07 00 00	 push	 1901			; 0000076dH
  00157	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0015c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00161	50		 push	 eax
  00162	8b 45 e8	 mov	 eax, DWORD PTR _sClassCount$[ebp]
  00165	50		 push	 eax
  00166	68 6c 07 00 00	 push	 1900			; 0000076cH
  0016b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00170	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00175	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00178	8b 4d f8	 mov	 ecx, DWORD PTR _sClassCount$[ebp+16]
  0017b	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00181	50		 push	 eax
  00182	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx]
  00188	51		 push	 ecx
  00189	57		 push	 edi
  0018a	56		 push	 esi
  0018b	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@IFDDAPIM@?$FL?$CFd?$FN?9?$FL?$CFd?$FN?5Total?5?$CFd?5?$CFs?5?$CFd?5?$CFs?5?$CFd?5?$CF@
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00196	83 c4 34	 add	 esp, 52			; 00000034H
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
$LN8@gObjSendUs:

; 16630: }

  0019b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019e	33 cd		 xor	 ecx, ebp
  001a0	5b		 pop	 ebx
  001a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a6	8b e5		 mov	 esp, ebp
  001a8	5d		 pop	 ebp
  001a9	c3		 ret	 0
?gObjSendUserStatistic@@YAXHHH@Z ENDP			; gObjSendUserStatistic
_TEXT	ENDS
PUBLIC	??0BILL_CLASS@@QAE@XZ				; BILL_CLASS::BILL_CLASS
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.h
;	COMDAT ??0BILL_CLASS@@QAE@XZ
_TEXT	SEGMENT
??0BILL_CLASS@@QAE@XZ PROC				; BILL_CLASS::BILL_CLASS, COMDAT
; _this$ = ecx

; 816  : 	BILL_CLASS()

  00000	8b c1		 mov	 eax, ecx

; 817  : 	{
; 818  : 		this->Init();

  00002	33 c9		 xor	 ecx, ecx
  00004	66 c7 00 ff 00	 mov	 WORD PTR [eax], 255	; 000000ffH
  00009	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000c	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 819  : 	}

  0000f	c3		 ret	 0
??0BILL_CLASS@@QAE@XZ ENDP				; BILL_CLASS::BILL_CLASS
_TEXT	ENDS
PUBLIC	??_C@_0CG@GHIPHJMP@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Rena@ ; `string'
PUBLIC	?gObjDelete10EventChip@@YAHH@Z			; gObjDelete10EventChip
;	COMDAT ??_C@_0CG@GHIPHJMP@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Rena@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
CONST	SEGMENT
??_C@_0CG@GHIPHJMP@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Rena@ DB '['
	DB	'EventChip] [%s][%s] Delete Rena (%d)', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjDelete10EventChip@@YAHH@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjDelete10EventChip@@YAHH@Z PROC			; gObjDelete10EventChip, COMDAT

; 16686: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 16687: 	LPOBJ lpObj = &gObj[aIndex];

  00006	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00009	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H

; 16688: 	int count = 0;

  0000f	33 db		 xor	 ebx, ebx
  00011	57		 push	 edi
  00012	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	89 5d fc	 mov	 DWORD PTR _count$[ebp], ebx

; 16689: 
; 16690: 	for(int n = 0; n < MAIN_INVENTORY_SIZE;n++)

  0001b	33 ff		 xor	 edi, edi
  0001d	8d 49 00	 npad	 3
$LL6@gObjDelete:

; 16691: 	{
; 16692: 		if(lpObj->pInventory[n].IsItem() == 1)

  00020	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00026	03 cb		 add	 ecx, ebx
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	75 4c		 jne	 SHORT $LN5@gObjDelete

; 16693: 		{
; 16694: 			if(lpObj->pInventory[n].m_Type == ITEMGET(14,21))

  00032	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00038	b9 15 1c 00 00	 mov	 ecx, 7189		; 00001c15H
  0003d	66 39 4c 18 06	 cmp	 WORD PTR [eax+ebx+6], cx
  00042	75 3a		 jne	 SHORT $LN5@gObjDelete

; 16695: 			{
; 16696: 				gObjInventoryDeleteItem(aIndex,n);

  00044	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00047	57		 push	 edi
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 16697: 				GCInventoryItemDeleteSend(aIndex,n,1);

  0004e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00051	6a 01		 push	 1
  00053	57		 push	 edi
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 16698: 				LogAdd(LOG_BLACK, "[EventChip] [%s][%s] Delete Rena (%d)",lpObj->AccountID,lpObj->Name,n);

  0005a	57		 push	 edi
  0005b	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  0005e	51		 push	 ecx
  0005f	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  00062	52		 push	 edx
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GHIPHJMP@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Rena@
  00068	6a 00		 push	 0
  0006a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 16699: 				count++;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00072	40		 inc	 eax
  00073	83 c4 28	 add	 esp, 40			; 00000028H
  00076	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 16700: 
; 16701: 				if(count >= 10)

  00079	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0007c	7d 18		 jge	 SHORT $LN10@gObjDelete
$LN5@gObjDelete:

; 16689: 
; 16690: 	for(int n = 0; n < MAIN_INVENTORY_SIZE;n++)

  0007e	81 c3 a8 00 00
	00		 add	 ebx, 168		; 000000a8H
  00084	47		 inc	 edi
  00085	81 fb e0 31 00
	00		 cmp	 ebx, 12768		; 000031e0H
  0008b	7c 93		 jl	 SHORT $LL6@gObjDelete

; 16704: 				}
; 16705: 			}
; 16706: 		}
; 16707: 	}
; 16708: 	return false;

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	33 c0		 xor	 eax, eax
  00091	5b		 pop	 ebx

; 16709: }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
$LN10@gObjDelete:
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi

; 16702: 				{
; 16703: 					return true;

  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	5b		 pop	 ebx

; 16709: }

  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?gObjDelete10EventChip@@YAHH@Z ENDP			; gObjDelete10EventChip
_TEXT	ENDS
PUBLIC	??_C@_0CJ@FBOHLINL@?$FLDeleteItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5?$CI?$CFd@ ; `string'
PUBLIC	?gObjDelteItemCountInInventory@@YAXHHHH@Z	; gObjDelteItemCountInInventory
;	COMDAT ??_C@_0CJ@FBOHLINL@?$FLDeleteItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5?$CI?$CFd@
CONST	SEGMENT
??_C@_0CJ@FBOHLINL@?$FLDeleteItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5?$CI?$CFd@ DB '['
	DB	'DeleteItem] [%s][%s] Delete (%d,%d)(%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjDelteItemCountInInventory@@YAXHHHH@Z
_TEXT	SEGMENT
tv190 = -4						; size = 4
_aIndex$ = 8						; size = 4
_itemtype$ = 12						; size = 4
_itemindex$ = 16					; size = 4
_count$ = 20						; size = 4
?gObjDelteItemCountInInventory@@YAXHHHH@Z PROC		; gObjDelteItemCountInInventory, COMDAT

; 16830: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 16831: 	LPOBJ lpObj = &gObj[aIndex];

  00006	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00009	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0000f	57		 push	 edi

; 16832: 	int delcount = 0;

  00010	33 ff		 xor	 edi, edi
  00012	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	33 db		 xor	 ebx, ebx
  0001a	89 7d fc	 mov	 DWORD PTR tv190[ebp], edi
  0001d	8d 49 00	 npad	 3
$LL12@gObjDelteI:

; 16835: 	{
; 16836: 		if(lpObj->pInventory[n].IsItem() == 1)

  00020	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00026	03 4d fc	 add	 ecx, DWORD PTR tv190[ebp]
  00029	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002e	83 f8 01	 cmp	 eax, 1
  00031	75 57		 jne	 SHORT $LN5@gObjDelteI

; 16837: 		{
; 16838: 			if(lpObj->pInventory[n].m_Type == itemtype * 512 + itemindex)

  00033	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00039	8b 4d fc	 mov	 ecx, DWORD PTR tv190[ebp]
  0003c	0f bf 54 08 06	 movsx	 edx, WORD PTR [eax+ecx+6]
  00041	8b 45 0c	 mov	 eax, DWORD PTR _itemtype$[ebp]
  00044	c1 e0 09	 shl	 eax, 9
  00047	03 45 10	 add	 eax, DWORD PTR _itemindex$[ebp]
  0004a	3b d0		 cmp	 edx, eax
  0004c	75 3c		 jne	 SHORT $LN5@gObjDelteI

; 16839: 			{
; 16840: 				gObjInventoryDeleteItem(aIndex,n);

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00051	57		 push	 edi
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 16841: 				GCInventoryItemDeleteSend(aIndex,n,1);

  00058	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0005b	6a 01		 push	 1
  0005d	57		 push	 edi
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 16842: 				LogAdd(LOG_BLACK, "[DeleteItem] [%s][%s] Delete (%d,%d)(%d)",lpObj->AccountID,lpObj->Name,itemtype,itemindex,n);

  00064	8b 45 10	 mov	 eax, DWORD PTR _itemindex$[ebp]
  00067	8b 4d 0c	 mov	 ecx, DWORD PTR _itemtype$[ebp]
  0006a	57		 push	 edi
  0006b	50		 push	 eax
  0006c	51		 push	 ecx
  0006d	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  00070	52		 push	 edx
  00071	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  00074	50		 push	 eax
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FBOHLINL@?$FLDeleteItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5?$CI?$CFd@
  0007a	6a 00		 push	 0
  0007c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 16843: 				delcount++;

  00081	43		 inc	 ebx
  00082	83 c4 30	 add	 esp, 48			; 00000030H

; 16844: 
; 16845: 				if(delcount >= count)

  00085	3b 5d 14	 cmp	 ebx, DWORD PTR _count$[ebp]
  00088	7d 13		 jge	 SHORT $LN10@gObjDelteI
$LN5@gObjDelteI:

; 16833: 
; 16834: 	for(int n = 0; n < MAIN_INVENTORY_SIZE; n++)

  0008a	8b 45 fc	 mov	 eax, DWORD PTR tv190[ebp]
  0008d	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  00092	47		 inc	 edi
  00093	89 45 fc	 mov	 DWORD PTR tv190[ebp], eax
  00096	3d e0 31 00 00	 cmp	 eax, 12768		; 000031e0H
  0009b	7c 83		 jl	 SHORT $LL12@gObjDelteI
$LN10@gObjDelteI:
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx

; 16846: 				{
; 16847: 					return;
; 16848: 				}
; 16849: 			}
; 16850: 		}
; 16851: 	}
; 16852: }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?gObjDelteItemCountInInventory@@YAXHHHH@Z ENDP		; gObjDelteItemCountInInventory
_TEXT	ENDS
PUBLIC	??_C@_0BP@DLHDMMOD@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?$FL?$CFd?$FN?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CG@KNEHLHCP@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5?$FL?$CFd?$FN?$FL?$CF@ ; `string'
PUBLIC	__real@3fe999999999999a
PUBLIC	??_C@_0DL@GGMAOOIG@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5StatUpItem@ ; `string'
PUBLIC	?gObjUseCircle@@YAXHH@Z				; gObjUseCircle
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
;	COMDAT ??_C@_0BP@DLHDMMOD@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?$FL?$CFd?$FN?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BP@DLHDMMOD@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?$FL?$CFd?$FN?5?$CFd?$AA@ DB '['
	DB	'StatUp] [%s][%s] Fail [%d] %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KNEHLHCP@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5?$FL?$CFd?$FN?$FL?$CF@
CONST	SEGMENT
??_C@_0CG@KNEHLHCP@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5?$FL?$CFd?$FN?$FL?$CF@ DB '['
	DB	'StatUp] [%s][%s] Success [%d][%d] %d', 00H	; `string'
CONST	ENDS
;	COMDAT __real@3fe999999999999a
CONST	SEGMENT
__real@3fe999999999999a DQ 03fe999999999999ar	; 0.8
CONST	ENDS
;	COMDAT ??_C@_0DL@GGMAOOIG@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5StatUpItem@
CONST	SEGMENT
??_C@_0DL@GGMAOOIG@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5StatUpItem@ DB '['
	DB	'StatUp] [%s][%s] Use StatUpItem Level:%d Pos:%d serial:%d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjUseCircle@@YAXHH@Z
_TEXT	SEGMENT
tv469 = -24						; size = 4
tv468 = -20						; size = 4
_iSerial$ = -16						; size = 4
_pResult$ = -12						; size = 4
tv600 = -8						; size = 4
tv597 = -8						; size = 4
_AddStat$167704 = -8					; size = 4
_iSuccessRate$ = -8					; size = 4
_MinusPoint$ = -8					; size = 2
_MaxMinusPoint$ = -4					; size = 2
tv450 = 8						; size = 4
_MaxAddPoint$ = 8					; size = 2
_aIndex$ = 8						; size = 4
tv618 = 12						; size = 4
_AddPoint$ = 12						; size = 2
_pos$ = 12						; size = 4
?gObjUseCircle@@YAXHH@Z PROC				; gObjUseCircle, COMDAT

; 16977: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 16978: 	int level = gObj[aIndex].pInventory[pos].m_Level;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  00009	53		 push	 ebx
  0000a	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00015	8b f7		 mov	 esi, edi
  00017	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0001d	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]

; 16979: 	int iSerial = gObj[aIndex].pInventory[pos].m_Number;

  00023	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  00026	0f bf 5c 08 08	 movsx	 ebx, WORD PTR [eax+ecx+8]

; 16980: 
; 16981: 	PMSG_DEFRESULT pResult;
; 16982: 
; 16983: 	PHeadSetB((LPBYTE)&pResult,0x2C,sizeof(pResult));

  0002b	6a 04		 push	 4
  0002d	89 45 08	 mov	 DWORD PTR tv450[ebp], eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR _pResult$[ebp]
  00033	6a 2c		 push	 44			; 0000002cH
  00035	50		 push	 eax
  00036	89 55 f0	 mov	 DWORD PTR _iSerial$[ebp], edx
  00039	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16984: 
; 16985: 	pResult.result = 0;
; 16986: 
; 16987: 	if(gObj[aIndex].Level <= 10 || level > 3)

  00041	66 83 be 9c 00
	00 00 0a	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156], 10 ; 0000000aH
  00049	c6 45 f7 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  0004d	0f 8e 13 03 00
	00		 jle	 $LN26@gObjUseCir
  00053	83 fb 03	 cmp	 ebx, 3
  00056	0f 8f 0a 03 00
	00		 jg	 $LN26@gObjUseCir

; 16991: 		return;
; 16992: 	}
; 16993: 
; 16994: 	if(gObjCheckStatPointUp(aIndex)==0)

  0005c	57		 push	 edi
  0005d	e8 00 00 00 00	 call	 ?gObjCheckStatPointUp@@YAHH@Z ; gObjCheckStatPointUp
  00062	83 c4 04	 add	 esp, 4
  00065	85 c0		 test	 eax, eax
  00067	75 1d		 jne	 SHORT $LN25@gObjUseCir

; 16995: 	{
; 16996: 		pResult.result |= 0xC0;
; 16997: 		DataSend(aIndex,(unsigned char*)&pResult,pResult.h.size);

  00069	0f b6 4d f5	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  0006d	80 4d f7 c0	 or	 BYTE PTR _pResult$[ebp+3], 192 ; 000000c0H
  00071	51		 push	 ecx
  00072	8d 55 f4	 lea	 edx, DWORD PTR _pResult$[ebp]
  00075	52		 push	 edx
  00076	57		 push	 edi
  00077	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx

; 17110: }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
$LN25@gObjUseCir:

; 16998: 		return;
; 16999: 	}
; 17000: 
; 17001: 	LogAdd(LOG_BLACK, "[StatUp] [%s][%s] Use StatUpItem Level:%d Pos:%d serial:%d",gObj[aIndex].AccountID,gObj[aIndex].Name,level,pos,iSerial);

  00086	8b 55 f0	 mov	 edx, DWORD PTR _iSerial$[ebp]
  00089	52		 push	 edx
  0008a	8b 55 0c	 mov	 edx, DWORD PTR _pos$[ebp]
  0008d	52		 push	 edx
  0008e	53		 push	 ebx
  0008f	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00095	50		 push	 eax
  00096	8d 8e 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  0009c	51		 push	 ecx
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GGMAOOIG@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5StatUpItem@
  000a2	6a 00		 push	 0
  000a4	89 45 ec	 mov	 DWORD PTR tv468[ebp], eax
  000a7	89 4d e8	 mov	 DWORD PTR tv469[ebp], ecx
  000aa	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 17002: 
; 17003: 	gObjInventoryItemSet(aIndex,pos,0xFF);

  000af	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  000b2	68 ff 00 00 00	 push	 255			; 000000ffH
  000b7	50		 push	 eax
  000b8	57		 push	 edi
  000b9	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 17004: 	gObj[aIndex].pInventory[pos].Clear();

  000be	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  000c4	03 4d 08	 add	 ecx, DWORD PTR tv450[ebp]
  000c7	83 c4 28	 add	 esp, 40			; 00000028H
  000ca	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 17005: 	GCInventoryItemDeleteSend(aIndex,pos,1);

  000cf	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  000d2	6a 01		 push	 1
  000d4	51		 push	 ecx
  000d5	57		 push	 edi
  000d6	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 17006: 
; 17007: 	short AddPoint;
; 17008: 	short MaxAddPoint;
; 17009: 	short MinusPoint;
; 17010: 	short MaxMinusPoint;
; 17011: 
; 17012: 	gObjGetStatPointState(aIndex,(short &)AddPoint,(short &)(MaxAddPoint),(short &)MinusPoint,(short &)MaxMinusPoint);

  000db	8d 55 fc	 lea	 edx, DWORD PTR _MaxMinusPoint$[ebp]
  000de	52		 push	 edx
  000df	8d 45 f8	 lea	 eax, DWORD PTR _MinusPoint$[ebp]
  000e2	50		 push	 eax
  000e3	8d 4d 08	 lea	 ecx, DWORD PTR _MaxAddPoint$[ebp]
  000e6	51		 push	 ecx
  000e7	8d 55 0c	 lea	 edx, DWORD PTR _AddPoint$[ebp]
  000ea	52		 push	 edx
  000eb	57		 push	 edi
  000ec	e8 00 00 00 00	 call	 ?gObjGetStatPointState@@YAXHAAF000@Z ; gObjGetStatPointState

; 17013: 
; 17014: 	int iSuccessRate = 0;
; 17015: 
; 17016: 	if(AddPoint <= 10)

  000f1	66 8b 45 0c	 mov	 ax, WORD PTR _AddPoint$[ebp]
  000f5	83 c4 20	 add	 esp, 32			; 00000020H
  000f8	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  000fc	7f 0c		 jg	 SHORT $LN24@gObjUseCir

; 17017: 	{
; 17018: 		iSuccessRate = 100;

  000fe	c7 45 f8 64 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 100 ; 00000064H
  00105	e9 8b 00 00 00	 jmp	 $LN15@gObjUseCir
$LN24@gObjUseCir:

; 17019: 	}
; 17020: 	else if((AddPoint - 10) < MaxAddPoint * (double)0.1)

  0010a	0f bf 4d 08	 movsx	 ecx, WORD PTR _MaxAddPoint$[ebp]
  0010e	98		 cwde
  0010f	83 e8 0a	 sub	 eax, 10			; 0000000aH
  00112	89 45 f8	 mov	 DWORD PTR tv600[ebp], eax
  00115	db 45 f8	 fild	 DWORD PTR tv600[ebp]
  00118	89 4d f8	 mov	 DWORD PTR tv597[ebp], ecx
  0011b	db 45 f8	 fild	 DWORD PTR tv597[ebp]
  0011e	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fb999999999999a
  00124	d8 c9		 fmul	 ST(0), ST(1)
  00126	d8 da		 fcomp	 ST(2)
  00128	df e0		 fnstsw	 ax
  0012a	f6 c4 41	 test	 ah, 65			; 00000041H
  0012d	75 0d		 jne	 SHORT $LN22@gObjUseCir
  0012f	dd d9		 fstp	 ST(1)

; 17021: 	{
; 17022: 		iSuccessRate = 90;

  00131	c7 45 f8 5a 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 90 ; 0000005aH
  00138	dd d8		 fstp	 ST(0)
  0013a	eb 59		 jmp	 SHORT $LN15@gObjUseCir
$LN22@gObjUseCir:

; 17023: 	}
; 17024: 	else if((AddPoint - 10) < MaxAddPoint * (double)0.3)

  0013c	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fd3333333333333
  00142	d8 c9		 fmul	 ST(0), ST(1)
  00144	d8 da		 fcomp	 ST(2)
  00146	df e0		 fnstsw	 ax
  00148	f6 c4 41	 test	 ah, 65			; 00000041H
  0014b	75 0d		 jne	 SHORT $LN20@gObjUseCir
  0014d	dd d9		 fstp	 ST(1)

; 17025: 	{
; 17026: 		iSuccessRate = 80;

  0014f	c7 45 f8 50 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 80 ; 00000050H
  00156	dd d8		 fstp	 ST(0)
  00158	eb 3b		 jmp	 SHORT $LN15@gObjUseCir
$LN20@gObjUseCir:

; 17027: 	}
; 17028: 	else if((AddPoint - 10) < MaxAddPoint * (double)0.5)

  0015a	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fe0000000000000
  00160	d8 c9		 fmul	 ST(0), ST(1)
  00162	d8 da		 fcomp	 ST(2)
  00164	df e0		 fnstsw	 ax
  00166	f6 c4 41	 test	 ah, 65			; 00000041H
  00169	75 0d		 jne	 SHORT $LN18@gObjUseCir
  0016b	dd d9		 fstp	 ST(1)

; 17029: 	{
; 17030: 		iSuccessRate = 70;

  0016d	c7 45 f8 46 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 70 ; 00000046H
  00174	dd d8		 fstp	 ST(0)
  00176	eb 1d		 jmp	 SHORT $LN15@gObjUseCir
$LN18@gObjUseCir:

; 17031: 	}
; 17032: 	else if((AddPoint - 10) < MaxAddPoint * (double)0.8)

  00178	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe999999999999a

; 17033: 	{
; 17034: 		iSuccessRate = 60;

  0017e	c7 45 f8 3c 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 60 ; 0000003cH
  00185	de d9		 fcompp
  00187	df e0		 fnstsw	 ax
  00189	f6 c4 41	 test	 ah, 65			; 00000041H
  0018c	74 07		 je	 SHORT $LN15@gObjUseCir

; 17035: 	}
; 17036: 	else
; 17037: 	{
; 17038: 		iSuccessRate = 50;

  0018e	c7 45 f8 32 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 50 ; 00000032H
$LN15@gObjUseCir:

; 17039: 	}
; 17040: 
; 17041: 	int incvalue = 0;
; 17042: 
; 17043: 	if(rand()%100 < iSuccessRate)

  00195	e8 00 00 00 00	 call	 _rand
  0019a	99		 cdq
  0019b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001a0	f7 f9		 idiv	 ecx
  001a2	3b 55 f8	 cmp	 edx, DWORD PTR _iSuccessRate$[ebp]
  001a5	0f 8d 7f 01 00
	00		 jge	 $LN14@gObjUseCir

; 17044: 	{
; 17045: 		iSuccessRate = rand()%100;

  001ab	e8 00 00 00 00	 call	 _rand
  001b0	99		 cdq
  001b1	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001b6	f7 f9		 idiv	 ecx

; 17046: 
; 17047: 		int AddStat = 0;
; 17048: 
; 17049: 		if(iSuccessRate < 70)

  001b8	83 fa 46	 cmp	 edx, 70			; 00000046H
  001bb	7d 09		 jge	 SHORT $LN13@gObjUseCir

; 17050: 		{
; 17051: 			AddStat = 1;

  001bd	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _AddStat$167704[ebp], 1
  001c4	eb 0e		 jmp	 SHORT $LN11@gObjUseCir
$LN13@gObjUseCir:

; 17052: 		}
; 17053: 		else if(iSuccessRate < 95)

  001c6	33 c0		 xor	 eax, eax
  001c8	83 fa 5f	 cmp	 edx, 95			; 0000005fH
  001cb	0f 9d c0	 setge	 al
  001ce	83 c0 02	 add	 eax, 2
  001d1	89 45 f8	 mov	 DWORD PTR _AddStat$167704[ebp], eax
$LN11@gObjUseCir:

; 17054: 		{
; 17055: 			AddStat = 2;
; 17056: 		}
; 17057: 		else
; 17058: 		{
; 17059: 			AddStat = 3;
; 17060: 		}
; 17061: 
; 17062: 		if((AddStat + AddPoint) > MaxAddPoint)

  001d4	0f bf 55 0c	 movsx	 edx, WORD PTR _AddPoint$[ebp]
  001d8	0f bf 45 08	 movsx	 eax, WORD PTR _MaxAddPoint$[ebp]
  001dc	03 55 f8	 add	 edx, DWORD PTR _AddStat$167704[ebp]
  001df	3b d0		 cmp	 edx, eax
  001e1	7e 07		 jle	 SHORT $LN9@gObjUseCir

; 17063: 		{
; 17064: 			AddStat = 1;

  001e3	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _AddStat$167704[ebp], 1
$LN9@gObjUseCir:

; 17065: 		}
; 17066: //+28???
; 17067: 		pResult.result |= level << 4; //pResult.result |= level * 16; //old
; 17068: 		pResult.result |= AddStat;
; 17069: 
; 17070: 		DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  001ea	0f b6 55 f5	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  001ee	8a cb		 mov	 cl, bl
  001f0	52		 push	 edx
  001f1	c0 e1 04	 shl	 cl, 4
  001f4	0a 4d f8	 or	 cl, BYTE PTR _AddStat$167704[ebp]
  001f7	8d 45 f4	 lea	 eax, DWORD PTR _pResult$[ebp]
  001fa	08 4d f7	 or	 BYTE PTR _pResult$[ebp+3], cl
  001fd	50		 push	 eax
  001fe	57		 push	 edi
  001ff	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17071: 
; 17072: 		incvalue = AddStat;
; 17073: 
; 17074: 		LogAdd(LOG_BLACK, "[StatUp] [%s][%s] Success [%d][%d] %d",gObj[aIndex].AccountID,gObj[aIndex].Name,level,incvalue,iSerial);

  00204	8b 4d f0	 mov	 ecx, DWORD PTR _iSerial$[ebp]
  00207	8b 55 f8	 mov	 edx, DWORD PTR _AddStat$167704[ebp]
  0020a	8b 45 ec	 mov	 eax, DWORD PTR tv468[ebp]
  0020d	51		 push	 ecx
  0020e	8b 4d e8	 mov	 ecx, DWORD PTR tv469[ebp]
  00211	52		 push	 edx
  00212	53		 push	 ebx
  00213	50		 push	 eax
  00214	51		 push	 ecx
  00215	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KNEHLHCP@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5?$FL?$CFd?$FN?$FL?$CF@
  0021a	6a 00		 push	 0
  0021c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00221	83 c4 28	 add	 esp, 40			; 00000028H

; 17084: 		return;
; 17085: 	}
; 17086: 
; 17087: 	switch(level)

  00224	83 fb 03	 cmp	 ebx, 3
  00227	0f 87 ed 00 00
	00		 ja	 $LN1@gObjUseCir
  0022d	ff 24 9d 00 00
	00 00		 jmp	 DWORD PTR $LN40@gObjUseCir[ebx*4]
$LN5@gObjUseCir:

; 17088: 	{
; 17089: 	case 3:
; 17090: 		gObj[aIndex].Strength += incvalue;

  00234	66 8b 55 f8	 mov	 dx, WORD PTR _AddStat$167704[ebp]
  00238	66 01 96 b4 00
	00 00		 add	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+180], dx

; 17105: 		break;
; 17106: 	default: break;
; 17107: 	}
; 17108: 
; 17109: 	gObjCalCharacter(aIndex);

  0023f	57		 push	 edi
  00240	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00245	83 c4 04	 add	 esp, 4
  00248	5f		 pop	 edi
  00249	5e		 pop	 esi
  0024a	5b		 pop	 ebx

; 17110: }

  0024b	8b e5		 mov	 esp, ebp
  0024d	5d		 pop	 ebp
  0024e	c3		 ret	 0
$LN4@gObjUseCir:

; 17091: 		break;
; 17092: 	case 2:
; 17093: 		gObj[aIndex].Dexterity += incvalue;

  0024f	66 8b 45 f8	 mov	 ax, WORD PTR _AddStat$167704[ebp]
  00253	66 01 86 b6 00
	00 00		 add	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+182], ax

; 17105: 		break;
; 17106: 	default: break;
; 17107: 	}
; 17108: 
; 17109: 	gObjCalCharacter(aIndex);

  0025a	57		 push	 edi
  0025b	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00260	83 c4 04	 add	 esp, 4
  00263	5f		 pop	 edi
  00264	5e		 pop	 esi
  00265	5b		 pop	 ebx

; 17110: }

  00266	8b e5		 mov	 esp, ebp
  00268	5d		 pop	 ebp
  00269	c3		 ret	 0
$LN3@gObjUseCir:

; 17094: 		break;
; 17095: 	case 1:
; 17096: 		gObj[aIndex].Vitality += incvalue;
; 17097: 		gObj[aIndex].MaxLife += gObj[aIndex].VitalityToLife * incvalue;

  0026a	d9 86 f4 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+244]
  00270	66 8b 4d f8	 mov	 cx, WORD PTR _AddStat$167704[ebp]
  00274	da 4d f8	 fimul	 DWORD PTR _AddStat$167704[ebp]
  00277	66 01 8e b8 00
	00 00		 add	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+184], cx

; 17098: 		GCReFillSend(gObj[aIndex].m_Index,gObj[aIndex].MaxLife + gObj[aIndex].AddLife,0xFE,0);

  0027e	6a 00		 push	 0
  00280	68 fe 00 00 00	 push	 254			; 000000feH
  00285	d8 86 c0 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]
  0028b	d9 5d 0c	 fstp	 DWORD PTR tv618[ebp]
  0028e	d9 45 0c	 fld	 DWORD PTR tv618[ebp]
  00291	d9 96 c0 00 00
	00		 fst	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]
  00297	da 86 0c 01 00
	00		 fiadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+268]
  0029d	e8 00 00 00 00	 call	 __ftol2_sse
  002a2	8b 96 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  002a8	50		 push	 eax
  002a9	52		 push	 edx
  002aa	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend
  002af	83 c4 10	 add	 esp, 16			; 00000010H

; 17105: 		break;
; 17106: 	default: break;
; 17107: 	}
; 17108: 
; 17109: 	gObjCalCharacter(aIndex);

  002b2	57		 push	 edi
  002b3	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  002b8	83 c4 04	 add	 esp, 4
  002bb	5f		 pop	 edi
  002bc	5e		 pop	 esi
  002bd	5b		 pop	 ebx

; 17110: }

  002be	8b e5		 mov	 esp, ebp
  002c0	5d		 pop	 ebp
  002c1	c3		 ret	 0
$LN2@gObjUseCir:

; 17099: 		break;
; 17100: 	case 0:
; 17101: 		gObj[aIndex].Energy += incvalue;
; 17102: 		gObj[aIndex].MaxMana += gObj[aIndex].EnergyToMana * incvalue;

  002c2	d9 86 f8 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+248]
  002c8	66 8b 45 f8	 mov	 ax, WORD PTR _AddStat$167704[ebp]
  002cc	da 4d f8	 fimul	 DWORD PTR _AddStat$167704[ebp]
  002cf	66 01 86 ba 00
	00 00		 add	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+186], ax

; 17103: 		gObjSetBP(aIndex);

  002d6	57		 push	 edi
  002d7	d8 86 d4 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  002dd	d9 9e d4 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  002e3	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 17104: 		GCManaSend(gObj[aIndex].m_Index,gObj[aIndex].MaxMana + gObj[aIndex].AddMana,0xFE,0,gObj[aIndex].MaxBP);

  002e8	8b 8e ec 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+236]
  002ee	db 86 10 01 00
	00		 fild	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+272]
  002f4	83 c4 04	 add	 esp, 4
  002f7	51		 push	 ecx
  002f8	d8 86 d4 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  002fe	6a 00		 push	 0
  00300	68 fe 00 00 00	 push	 254			; 000000feH
  00305	e8 00 00 00 00	 call	 __ftol2_sse
  0030a	8b 96 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00310	50		 push	 eax
  00311	52		 push	 edx
  00312	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  00317	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@gObjUseCir:

; 17105: 		break;
; 17106: 	default: break;
; 17107: 	}
; 17108: 
; 17109: 	gObjCalCharacter(aIndex);

  0031a	57		 push	 edi
  0031b	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00320	83 c4 04	 add	 esp, 4
  00323	5f		 pop	 edi
  00324	5e		 pop	 esi
  00325	5b		 pop	 ebx

; 17110: }

  00326	8b e5		 mov	 esp, ebp
  00328	5d		 pop	 ebp
  00329	c3		 ret	 0
$LN14@gObjUseCir:

; 17075: 	}
; 17076: 	else
; 17077: 	{
; 17078: 		pResult.result |= 0x40;
; 17079: 		pResult.result |= level << 4; //pResult.result |= level * 16; //old
; 17080: 		pResult.result = pResult.result;
; 17081: 
; 17082: 		DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  0032a	0f b6 4d f5	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  0032e	8a c3		 mov	 al, bl
  00330	51		 push	 ecx
  00331	8d 55 f4	 lea	 edx, DWORD PTR _pResult$[ebp]
  00334	0c 04		 or	 al, 4
  00336	52		 push	 edx
  00337	c0 e0 04	 shl	 al, 4
  0033a	08 45 f7	 or	 BYTE PTR _pResult$[ebp+3], al
  0033d	57		 push	 edi
  0033e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17083: 		LogAdd(LOG_BLACK, "[StatUp] [%s][%s] Fail [%d] %d",gObj[aIndex].AccountID,gObj[aIndex].Name,level,iSerial);

  00343	8b 45 f0	 mov	 eax, DWORD PTR _iSerial$[ebp]
  00346	8b 4d ec	 mov	 ecx, DWORD PTR tv468[ebp]
  00349	8b 55 e8	 mov	 edx, DWORD PTR tv469[ebp]
  0034c	50		 push	 eax
  0034d	53		 push	 ebx
  0034e	51		 push	 ecx
  0034f	52		 push	 edx
  00350	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DLHDMMOD@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?$FL?$CFd?$FN?5?$CFd?$AA@
  00355	6a 00		 push	 0
  00357	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0035c	83 c4 24	 add	 esp, 36			; 00000024H
  0035f	5f		 pop	 edi
  00360	5e		 pop	 esi
  00361	5b		 pop	 ebx

; 17110: }

  00362	8b e5		 mov	 esp, ebp
  00364	5d		 pop	 ebp
  00365	c3		 ret	 0
$LN26@gObjUseCir:

; 16988: 	{
; 16989: 		pResult.result |= 0xC0;
; 16990: 		DataSend(aIndex,(unsigned char*)&pResult,pResult.h.size);

  00366	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0036a	50		 push	 eax
  0036b	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0036e	51		 push	 ecx
  0036f	57		 push	 edi
  00370	c6 45 f7 c0	 mov	 BYTE PTR _pResult$[ebp+3], 192 ; 000000c0H
  00374	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00379	83 c4 0c	 add	 esp, 12			; 0000000cH
  0037c	5f		 pop	 edi
  0037d	5e		 pop	 esi
  0037e	5b		 pop	 ebx

; 17110: }

  0037f	8b e5		 mov	 esp, ebp
  00381	5d		 pop	 ebp
  00382	c3		 ret	 0
  00383	90		 npad	 1
$LN40@gObjUseCir:
  00384	00 00 00 00	 DD	 $LN2@gObjUseCir
  00388	00 00 00 00	 DD	 $LN3@gObjUseCir
  0038c	00 00 00 00	 DD	 $LN4@gObjUseCir
  00390	00 00 00 00	 DD	 $LN5@gObjUseCir
?gObjUseCircle@@YAXHH@Z ENDP				; gObjUseCircle
_TEXT	ENDS
PUBLIC	?gObjUsePlusStatFruit@@YAXHH@Z			; gObjUsePlusStatFruit
; Function compile flags: /Ogtp
;	COMDAT ?gObjUsePlusStatFruit@@YAXHH@Z
_TEXT	SEGMENT
_pResult$ = -32						; size = 6
tv516 = -24						; size = 4
tv515 = -20						; size = 4
_iItemSerial$ = -16					; size = 4
tv674 = -12						; size = 4
tv671 = -12						; size = 4
tv490 = -12						; size = 4
_AddStat$167787 = -12					; size = 4
_iSuccessRate$ = -12					; size = 4
_MinusPoint$ = -12					; size = 2
_MaxMinusPoint$ = -8					; size = 2
_MaxAddPoint$ = -4					; size = 2
tv713 = 8						; size = 4
_AddPoint$ = 8						; size = 2
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 4
?gObjUsePlusStatFruit@@YAXHH@Z PROC			; gObjUsePlusStatFruit, COMDAT

; 17121: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	57		 push	 edi

; 17122: 	if(!OBJMAX_RANGE(aIndex))

  00007	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000a	85 ff		 test	 edi, edi
  0000c	0f 88 fd 03 00
	00		 js	 $LN35@gObjUsePlu
  00012	33 c0		 xor	 eax, eax
  00014	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 ea 03 00
	00		 je	 $LN35@gObjUsePlu

; 17123: 	{
; 17124: 		return;
; 17125: 	}
; 17126: 
; 17127: 	if(gObj[aIndex].Class >= 5 || gObj[aIndex].Class < 0)

  00025	56		 push	 esi
  00026	8b f7		 mov	 esi, edi
  00028	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0002e	66 83 be 98 00
	00 00 05	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152], 5
  00036	0f 83 d2 03 00
	00		 jae	 $LN47@gObjUsePlu

; 17128: 	{
; 17129: 		return;
; 17130: 	}
; 17131: 
; 17132: 	int iItemLevel = gObj[aIndex].pInventory[pos].m_Level;

  0003c	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  0003f	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  00045	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H

; 17133: 	int iItemSerial = gObj[aIndex].pInventory[pos].m_Number;

  0004b	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  0004e	53		 push	 ebx
  0004f	0f bf 5c 08 08	 movsx	 ebx, WORD PTR [eax+ecx+8]

; 17134: 	int iCharacterClass = gObj[aIndex].Class;
; 17135: 
; 17136: 	PMSG_USE_STAT_FRUIT pResult;
; 17137: 
; 17138: 	PHeadSetB((LPBYTE)&pResult,0x2C,sizeof(pResult));

  00054	6a 06		 push	 6
  00056	89 45 f4	 mov	 DWORD PTR tv490[ebp], eax
  00059	8d 45 e0	 lea	 eax, DWORD PTR _pResult$[ebp]
  0005c	6a 2c		 push	 44			; 0000002cH
  0005e	50		 push	 eax
  0005f	89 55 f0	 mov	 DWORD PTR _iItemSerial$[ebp], edx
  00062	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17139: 
; 17140: 	pResult.result = 2;
; 17141: 	pResult.btFruitType = iItemLevel;
; 17142: 	pResult.btStatValue = 0;
; 17143: 
; 17144: 	if(gObj[aIndex].Level <= 9 || iItemLevel > 4)

  0006a	66 83 be 9c 00
	00 00 09	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156], 9
  00072	88 5d e5	 mov	 BYTE PTR _pResult$[ebp+5], bl
  00075	66 c7 45 e3 02
	00		 mov	 WORD PTR _pResult$[ebp+3], 2
  0007b	0f 8e 76 03 00
	00		 jle	 $LN33@gObjUsePlu
  00081	83 fb 04	 cmp	 ebx, 4
  00084	0f 8f 6d 03 00
	00		 jg	 $LN33@gObjUsePlu

; 17148: 		return;
; 17149: 	}
; 17150: 
; 17151: 	if(iItemLevel == 4 && gObj[aIndex].Class != 4)

  0008a	75 27		 jne	 SHORT $LN32@gObjUsePlu
  0008c	66 83 be 98 00
	00 00 04	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152], 4
  00094	74 1d		 je	 SHORT $LN32@gObjUsePlu

; 17152: 	{
; 17153: 		pResult.result = 2;
; 17154: 		DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  00096	0f b6 4d e1	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  0009a	51		 push	 ecx
  0009b	8d 55 e0	 lea	 edx, DWORD PTR _pResult$[ebp]
  0009e	52		 push	 edx
  0009f	57		 push	 edi
  000a0	c6 45 e3 02	 mov	 BYTE PTR _pResult$[ebp+3], 2
  000a4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	5b		 pop	 ebx
  000ad	5e		 pop	 esi
  000ae	5f		 pop	 edi

; 17292: }

  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
$LN32@gObjUsePlu:

; 17155: 		return;
; 17156: 	}
; 17157: 
; 17158: 	for(int iItemIndex = 0; iItemIndex < INVETORY_WEAR_SIZE; iItemIndex++)

  000b3	c7 45 08 00 00
	00 00		 mov	 DWORD PTR tv713[ebp], 0
  000ba	8d 9b 00 00 00
	00		 npad	 6
$LL46@gObjUsePlu:

; 17159: 	{
; 17160: 		if(gObj[aIndex].pInventory[iItemIndex].IsItem())

  000c0	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  000c6	03 4d 08	 add	 ecx, DWORD PTR tv713[ebp]
  000c9	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ce	85 c0		 test	 eax, eax
  000d0	75 3c		 jne	 SHORT $LN43@gObjUsePlu

; 17155: 		return;
; 17156: 	}
; 17157: 
; 17158: 	for(int iItemIndex = 0; iItemIndex < INVETORY_WEAR_SIZE; iItemIndex++)

  000d2	8b 45 08	 mov	 eax, DWORD PTR tv713[ebp]
  000d5	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  000da	89 45 08	 mov	 DWORD PTR tv713[ebp], eax
  000dd	3d e0 07 00 00	 cmp	 eax, 2016		; 000007e0H
  000e2	7c dc		 jl	 SHORT $LL46@gObjUsePlu

; 17164: 			return;
; 17165: 		}
; 17166: 	}
; 17167: 
; 17168: 	if(gObjCheckStatPointUp(aIndex) == false)

  000e4	57		 push	 edi
  000e5	e8 00 00 00 00	 call	 ?gObjCheckStatPointUp@@YAHH@Z ; gObjCheckStatPointUp
  000ea	83 c4 04	 add	 esp, 4
  000ed	85 c0		 test	 eax, eax
  000ef	75 3a		 jne	 SHORT $LN27@gObjUsePlu

; 17169: 	{
; 17170: 		pResult.result = 33;
; 17171: 		DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  000f1	0f b6 55 e1	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  000f5	52		 push	 edx
  000f6	8d 45 e0	 lea	 eax, DWORD PTR _pResult$[ebp]
  000f9	50		 push	 eax
  000fa	57		 push	 edi
  000fb	c6 45 e3 21	 mov	 BYTE PTR _pResult$[ebp+3], 33 ; 00000021H
  000ff	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00104	83 c4 0c	 add	 esp, 12			; 0000000cH
  00107	5b		 pop	 ebx
  00108	5e		 pop	 esi
  00109	5f		 pop	 edi

; 17292: }

  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
$LN43@gObjUsePlu:

; 17161: 		{
; 17162: 			pResult.result = 16;
; 17163: 			DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  0010e	0f b6 45 e1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00112	50		 push	 eax
  00113	8d 4d e0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00116	51		 push	 ecx
  00117	57		 push	 edi
  00118	c6 45 e3 10	 mov	 BYTE PTR _pResult$[ebp+3], 16 ; 00000010H
  0011c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00121	83 c4 0c	 add	 esp, 12			; 0000000cH
  00124	5b		 pop	 ebx
  00125	5e		 pop	 esi
  00126	5f		 pop	 edi

; 17292: }

  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
$LN27@gObjUsePlu:

; 17172: 		return;
; 17173: 	}
; 17174: 
; 17175: 	LogAdd(LOG_BLACK, "[StatUp] [%s][%s] Use StatUpItem Level:%d Pos:%d serial:%d",
; 17176: 		gObj[aIndex].AccountID,gObj[aIndex].Name,iItemLevel,pos,iItemSerial);

  0012b	8b 55 f0	 mov	 edx, DWORD PTR _iItemSerial$[ebp]
  0012e	52		 push	 edx
  0012f	8b 55 0c	 mov	 edx, DWORD PTR _pos$[ebp]
  00132	52		 push	 edx
  00133	53		 push	 ebx
  00134	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  0013a	50		 push	 eax
  0013b	8d 8e 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  00141	51		 push	 ecx
  00142	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GGMAOOIG@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5StatUpItem@
  00147	6a 00		 push	 0
  00149	89 45 ec	 mov	 DWORD PTR tv515[ebp], eax
  0014c	89 4d e8	 mov	 DWORD PTR tv516[ebp], ecx
  0014f	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 17177: 
; 17178: 	gObjInventoryItemSet(aIndex,pos,0xFF);

  00154	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  00157	68 ff 00 00 00	 push	 255			; 000000ffH
  0015c	50		 push	 eax
  0015d	57		 push	 edi
  0015e	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 17179: 	gObj[aIndex].pInventory[pos].Clear();

  00163	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  00169	03 4d f4	 add	 ecx, DWORD PTR tv490[ebp]
  0016c	83 c4 28	 add	 esp, 40			; 00000028H
  0016f	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 17180: 	GCInventoryItemDeleteSend(aIndex,pos,1);

  00174	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  00177	6a 01		 push	 1
  00179	51		 push	 ecx
  0017a	57		 push	 edi
  0017b	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 17181: 
; 17182: 	short AddPoint;
; 17183: 	short MaxAddPoint;
; 17184: 	short MinusPoint;
; 17185: 	short MaxMinusPoint;
; 17186: 
; 17187: 	gObjGetStatPointState(aIndex,(short &)AddPoint,(short &)MaxAddPoint,(short &)MinusPoint,(short &)MaxMinusPoint);

  00180	8d 55 f8	 lea	 edx, DWORD PTR _MaxMinusPoint$[ebp]
  00183	52		 push	 edx
  00184	8d 45 f4	 lea	 eax, DWORD PTR _MinusPoint$[ebp]
  00187	50		 push	 eax
  00188	8d 4d fc	 lea	 ecx, DWORD PTR _MaxAddPoint$[ebp]
  0018b	51		 push	 ecx
  0018c	8d 55 08	 lea	 edx, DWORD PTR _AddPoint$[ebp]
  0018f	52		 push	 edx
  00190	57		 push	 edi
  00191	e8 00 00 00 00	 call	 ?gObjGetStatPointState@@YAXHAAF000@Z ; gObjGetStatPointState

; 17188: 
; 17189: 	int iSuccessRate = 0;
; 17190: 
; 17191: 	if(AddPoint <= 10)

  00196	66 8b 45 08	 mov	 ax, WORD PTR _AddPoint$[ebp]
  0019a	83 c4 20	 add	 esp, 32			; 00000020H
  0019d	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  001a1	7f 0c		 jg	 SHORT $LN26@gObjUsePlu

; 17192: 	{
; 17193: 		iSuccessRate = 100;

  001a3	c7 45 f4 64 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 100 ; 00000064H
  001aa	e9 8b 00 00 00	 jmp	 $LN17@gObjUsePlu
$LN26@gObjUsePlu:

; 17194: 	}
; 17195: 	else if((AddPoint - 10) < (MaxAddPoint * (double)0.1))

  001af	0f bf 4d fc	 movsx	 ecx, WORD PTR _MaxAddPoint$[ebp]
  001b3	98		 cwde
  001b4	83 e8 0a	 sub	 eax, 10			; 0000000aH
  001b7	89 45 f4	 mov	 DWORD PTR tv674[ebp], eax
  001ba	db 45 f4	 fild	 DWORD PTR tv674[ebp]
  001bd	89 4d f4	 mov	 DWORD PTR tv671[ebp], ecx
  001c0	db 45 f4	 fild	 DWORD PTR tv671[ebp]
  001c3	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fb999999999999a
  001c9	d8 c9		 fmul	 ST(0), ST(1)
  001cb	d8 da		 fcomp	 ST(2)
  001cd	df e0		 fnstsw	 ax
  001cf	f6 c4 41	 test	 ah, 65			; 00000041H
  001d2	75 0d		 jne	 SHORT $LN24@gObjUsePlu
  001d4	dd d9		 fstp	 ST(1)

; 17196: 	{
; 17197: 		iSuccessRate = 90;

  001d6	c7 45 f4 5a 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 90 ; 0000005aH
  001dd	dd d8		 fstp	 ST(0)
  001df	eb 59		 jmp	 SHORT $LN17@gObjUsePlu
$LN24@gObjUsePlu:

; 17198: 	}
; 17199: 	else if((AddPoint - 10) < (MaxAddPoint * (double)0.3))

  001e1	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fd3333333333333
  001e7	d8 c9		 fmul	 ST(0), ST(1)
  001e9	d8 da		 fcomp	 ST(2)
  001eb	df e0		 fnstsw	 ax
  001ed	f6 c4 41	 test	 ah, 65			; 00000041H
  001f0	75 0d		 jne	 SHORT $LN22@gObjUsePlu
  001f2	dd d9		 fstp	 ST(1)

; 17200: 	{
; 17201: 		iSuccessRate = 80;

  001f4	c7 45 f4 50 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 80 ; 00000050H
  001fb	dd d8		 fstp	 ST(0)
  001fd	eb 3b		 jmp	 SHORT $LN17@gObjUsePlu
$LN22@gObjUsePlu:

; 17202: 	}
; 17203: 	else if((AddPoint - 10) < (MaxAddPoint * (double)0.5))

  001ff	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fe0000000000000
  00205	d8 c9		 fmul	 ST(0), ST(1)
  00207	d8 da		 fcomp	 ST(2)
  00209	df e0		 fnstsw	 ax
  0020b	f6 c4 41	 test	 ah, 65			; 00000041H
  0020e	75 0d		 jne	 SHORT $LN20@gObjUsePlu
  00210	dd d9		 fstp	 ST(1)

; 17204: 	{
; 17205: 		iSuccessRate = 70;

  00212	c7 45 f4 46 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 70 ; 00000046H
  00219	dd d8		 fstp	 ST(0)
  0021b	eb 1d		 jmp	 SHORT $LN17@gObjUsePlu
$LN20@gObjUsePlu:

; 17206: 	}
; 17207: 	else if((AddPoint - 10) < (MaxAddPoint * (double)0.8))

  0021d	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe999999999999a

; 17208: 	{
; 17209: 		iSuccessRate = 60;

  00223	c7 45 f4 3c 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 60 ; 0000003cH
  0022a	de d9		 fcompp
  0022c	df e0		 fnstsw	 ax
  0022e	f6 c4 41	 test	 ah, 65			; 00000041H
  00231	74 07		 je	 SHORT $LN17@gObjUsePlu

; 17210: 	}
; 17211: 	else
; 17212: 	{
; 17213: 		iSuccessRate = 50;

  00233	c7 45 f4 32 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 50 ; 00000032H
$LN17@gObjUsePlu:

; 17214: 	}
; 17215: 
; 17216: 	int iIncStat = 0;
; 17217: 	int bSuccess = 0;
; 17218: 
; 17219: 	if(rand()%100 < iSuccessRate)

  0023a	e8 00 00 00 00	 call	 _rand
  0023f	99		 cdq
  00240	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00245	f7 f9		 idiv	 ecx
  00247	3b 55 f4	 cmp	 edx, DWORD PTR _iSuccessRate$[ebp]
  0024a	0f 8d 6c 01 00
	00		 jge	 $LN15@gObjUsePlu

; 17220: 	{
; 17221: 		bSuccess = 1;
; 17222: 	}
; 17223: 
; 17224: 	if(bSuccess != 0)
; 17225: 	{
; 17226: 		iSuccessRate = rand()%100;

  00250	e8 00 00 00 00	 call	 _rand
  00255	99		 cdq
  00256	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0025b	f7 f9		 idiv	 ecx

; 17227: 
; 17228: 		int AddStat = 0;
; 17229: 
; 17230: 		if(iSuccessRate < 70)

  0025d	83 fa 46	 cmp	 edx, 70			; 00000046H
  00260	7d 09		 jge	 SHORT $LN14@gObjUsePlu

; 17231: 		{
; 17232: 			AddStat = 1;

  00262	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _AddStat$167787[ebp], 1
  00269	eb 0e		 jmp	 SHORT $LN12@gObjUsePlu
$LN14@gObjUsePlu:

; 17233: 		}
; 17234: 		else if(iSuccessRate < 95)

  0026b	33 c0		 xor	 eax, eax
  0026d	83 fa 5f	 cmp	 edx, 95			; 0000005fH
  00270	0f 9d c0	 setge	 al
  00273	83 c0 02	 add	 eax, 2
  00276	89 45 f4	 mov	 DWORD PTR _AddStat$167787[ebp], eax
$LN12@gObjUsePlu:

; 17235: 		{
; 17236: 			AddStat = 2;
; 17237: 		}
; 17238: 		else
; 17239: 		{
; 17240: 			AddStat = 3;
; 17241: 		}
; 17242: 
; 17243: 		if((AddStat + AddPoint) > MaxAddPoint)

  00279	0f bf 55 08	 movsx	 edx, WORD PTR _AddPoint$[ebp]
  0027d	0f bf 45 fc	 movsx	 eax, WORD PTR _MaxAddPoint$[ebp]
  00281	03 55 f4	 add	 edx, DWORD PTR _AddStat$167787[ebp]
  00284	3b d0		 cmp	 edx, eax
  00286	7e 07		 jle	 SHORT $LN10@gObjUsePlu

; 17244: 		{
; 17245: 			AddStat = 1;

  00288	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _AddStat$167787[ebp], 1
$LN10@gObjUsePlu:

; 17246: 		}
; 17247: 
; 17248: 		pResult.result = 0;
; 17249: 		pResult.btStatValue = AddStat;
; 17250: 		pResult.btFruitType = iItemLevel;
; 17251: 
; 17252: 		DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  0028f	0f b6 55 e1	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00293	8a 4d f4	 mov	 cl, BYTE PTR _AddStat$167787[ebp]
  00296	52		 push	 edx
  00297	8d 45 e0	 lea	 eax, DWORD PTR _pResult$[ebp]
  0029a	50		 push	 eax
  0029b	57		 push	 edi
  0029c	c6 45 e3 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  002a0	88 4d e4	 mov	 BYTE PTR _pResult$[ebp+4], cl
  002a3	88 5d e5	 mov	 BYTE PTR _pResult$[ebp+5], bl
  002a6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17253: 		iIncStat = AddStat;
; 17254: 
; 17255: 		LogAdd(LOG_BLACK, "[StatUp] [%s][%s] Success [%d][%d] %d",
; 17256: 			gObj[aIndex].AccountID,gObj[aIndex].Name,iItemLevel,iIncStat,iItemSerial);

  002ab	8b 4d f0	 mov	 ecx, DWORD PTR _iItemSerial$[ebp]
  002ae	8b 55 f4	 mov	 edx, DWORD PTR _AddStat$167787[ebp]
  002b1	8b 45 ec	 mov	 eax, DWORD PTR tv515[ebp]
  002b4	51		 push	 ecx
  002b5	8b 4d e8	 mov	 ecx, DWORD PTR tv516[ebp]
  002b8	52		 push	 edx
  002b9	53		 push	 ebx
  002ba	50		 push	 eax
  002bb	51		 push	 ecx
  002bc	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KNEHLHCP@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5?$FL?$CFd?$FN?$FL?$CF@
  002c1	6a 00		 push	 0
  002c3	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  002c8	83 c4 28	 add	 esp, 40			; 00000028H

; 17268: 		return;
; 17269: 	}
; 17270: 
; 17271: 	switch(iItemLevel)

  002cb	83 fb 04	 cmp	 ebx, 4
  002ce	77 79		 ja	 SHORT $LN1@gObjUsePlu
  002d0	ff 24 9d 00 00
	00 00		 jmp	 DWORD PTR $LN60@gObjUsePlu[ebx*4]
$LN6@gObjUsePlu:

; 17272: 	{
; 17273: 	case 4: gObj[aIndex].Leadership += iIncStat;	break;

  002d7	66 8b 55 f4	 mov	 dx, WORD PTR _AddStat$167787[ebp]
  002db	66 01 96 d8 00
	00 00		 add	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+216], dx
  002e2	eb 65		 jmp	 SHORT $LN1@gObjUsePlu
$LN5@gObjUsePlu:

; 17274: 	case 3: gObj[aIndex].Strength += iIncStat;	break;

  002e4	66 8b 45 f4	 mov	 ax, WORD PTR _AddStat$167787[ebp]
  002e8	66 01 86 b4 00
	00 00		 add	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+180], ax
  002ef	eb 58		 jmp	 SHORT $LN1@gObjUsePlu
$LN4@gObjUsePlu:

; 17275: 	case 2: gObj[aIndex].Dexterity += iIncStat;	break;

  002f1	66 8b 4d f4	 mov	 cx, WORD PTR _AddStat$167787[ebp]
  002f5	66 01 8e b6 00
	00 00		 add	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+182], cx
  002fc	eb 4b		 jmp	 SHORT $LN1@gObjUsePlu
$LN3@gObjUsePlu:

; 17276: 	case 1:
; 17277: 		gObj[aIndex].Vitality += iIncStat;
; 17278: 		gObj[aIndex].MaxLife += gObj[aIndex].VitalityToLife * iIncStat;

  002fe	d9 86 f4 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+244]
  00304	66 8b 55 f4	 mov	 dx, WORD PTR _AddStat$167787[ebp]
  00308	da 4d f4	 fimul	 DWORD PTR _AddStat$167787[ebp]
  0030b	66 01 96 b8 00
	00 00		 add	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+184], dx
  00312	d8 86 c0 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]
  00318	d9 9e c0 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]

; 17279: 		break;

  0031e	eb 29		 jmp	 SHORT $LN1@gObjUsePlu
$LN2@gObjUsePlu:

; 17280: 	case 0:
; 17281: 		gObj[aIndex].Energy += iIncStat;
; 17282: 		gObj[aIndex].MaxMana += gObj[aIndex].EnergyToMana * iIncStat;

  00320	d9 86 f8 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+248]
  00326	66 8b 45 f4	 mov	 ax, WORD PTR _AddStat$167787[ebp]
  0032a	da 4d f4	 fimul	 DWORD PTR _AddStat$167787[ebp]
  0032d	66 01 86 ba 00
	00 00		 add	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+186], ax

; 17283: 		gObjSetBP(aIndex);

  00334	57		 push	 edi
  00335	d8 86 d4 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  0033b	d9 9e d4 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  00341	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP
  00346	83 c4 04	 add	 esp, 4
$LN1@gObjUsePlu:

; 17284: 		break;
; 17285: 	default : break;
; 17286: 	}
; 17287: 
; 17288: 	gObjCalCharacter(aIndex);

  00349	57		 push	 edi
  0034a	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 17289: 	GCReFillSend(gObj[aIndex].m_Index,gObj[aIndex].MaxLife + gObj[aIndex].AddLife,0xFE,0);

  0034f	db 86 0c 01 00
	00		 fild	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+268]
  00355	83 c4 04	 add	 esp, 4
  00358	6a 00		 push	 0
  0035a	d8 86 c0 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]
  00360	68 fe 00 00 00	 push	 254			; 000000feH
  00365	e8 00 00 00 00	 call	 __ftol2_sse
  0036a	8b 8e 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00370	50		 push	 eax
  00371	51		 push	 ecx
  00372	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend

; 17290: 	gObjSetBP(aIndex);

  00377	57		 push	 edi
  00378	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 17291: 	GCManaSend(gObj[aIndex].m_Index,gObj[aIndex].MaxMana + gObj[aIndex].AddMana,0xFE,0,gObj[aIndex].MaxBP + gObj[aIndex].AddBP);

  0037d	db 86 10 01 00
	00		 fild	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+272]
  00383	8b 96 f0 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+240]
  00389	03 96 ec 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+236]
  0038f	d8 86 d4 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  00395	83 c4 14	 add	 esp, 20			; 00000014H
  00398	52		 push	 edx
  00399	6a 00		 push	 0
  0039b	68 fe 00 00 00	 push	 254			; 000000feH
  003a0	e8 00 00 00 00	 call	 __ftol2_sse
  003a5	50		 push	 eax
  003a6	8b 86 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  003ac	50		 push	 eax
  003ad	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  003b2	83 c4 14	 add	 esp, 20			; 00000014H
  003b5	5b		 pop	 ebx
  003b6	5e		 pop	 esi
  003b7	5f		 pop	 edi

; 17292: }

  003b8	8b e5		 mov	 esp, ebp
  003ba	5d		 pop	 ebp
  003bb	c3		 ret	 0
$LN15@gObjUsePlu:

; 17257: 	}
; 17258: 	else
; 17259: 	{
; 17260: 		pResult.result = 1;
; 17261: 		pResult.btStatValue = 0;
; 17262: 		pResult.btFruitType = iItemLevel;
; 17263: 
; 17264: 		DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  003bc	0f b6 4d e1	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  003c0	51		 push	 ecx
  003c1	8d 55 e0	 lea	 edx, DWORD PTR _pResult$[ebp]
  003c4	52		 push	 edx
  003c5	57		 push	 edi
  003c6	66 c7 45 e3 01
	00		 mov	 WORD PTR _pResult$[ebp+3], 1
  003cc	88 5d e5	 mov	 BYTE PTR _pResult$[ebp+5], bl
  003cf	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17265: 
; 17266: 		LogAdd(LOG_BLACK, "[StatUp] [%s][%s] Fail [%d] %d",
; 17267: 			gObj[aIndex].AccountID,gObj[aIndex].Name,iItemLevel,iItemSerial);

  003d4	8b 45 f0	 mov	 eax, DWORD PTR _iItemSerial$[ebp]
  003d7	8b 4d ec	 mov	 ecx, DWORD PTR tv515[ebp]
  003da	8b 55 e8	 mov	 edx, DWORD PTR tv516[ebp]
  003dd	50		 push	 eax
  003de	53		 push	 ebx
  003df	51		 push	 ecx
  003e0	52		 push	 edx
  003e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DLHDMMOD@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?$FL?$CFd?$FN?5?$CFd?$AA@
  003e6	6a 00		 push	 0
  003e8	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  003ed	83 c4 24	 add	 esp, 36			; 00000024H
  003f0	5b		 pop	 ebx
  003f1	5e		 pop	 esi
  003f2	5f		 pop	 edi

; 17292: }

  003f3	8b e5		 mov	 esp, ebp
  003f5	5d		 pop	 ebp
  003f6	c3		 ret	 0
$LN33@gObjUsePlu:

; 17145: 	{
; 17146: 		pResult.result = 2;
; 17147: 		DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  003f7	0f b6 45 e1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  003fb	50		 push	 eax
  003fc	8d 4d e0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  003ff	51		 push	 ecx
  00400	57		 push	 edi
  00401	c6 45 e3 02	 mov	 BYTE PTR _pResult$[ebp+3], 2
  00405	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0040a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0040d	5b		 pop	 ebx
$LN47@gObjUsePlu:
  0040e	5e		 pop	 esi
$LN35@gObjUsePlu:
  0040f	5f		 pop	 edi

; 17292: }

  00410	8b e5		 mov	 esp, ebp
  00412	5d		 pop	 ebp
  00413	c3		 ret	 0
$LN60@gObjUsePlu:
  00414	00 00 00 00	 DD	 $LN2@gObjUsePlu
  00418	00 00 00 00	 DD	 $LN3@gObjUsePlu
  0041c	00 00 00 00	 DD	 $LN4@gObjUsePlu
  00420	00 00 00 00	 DD	 $LN5@gObjUsePlu
  00424	00 00 00 00	 DD	 $LN6@gObjUsePlu
?gObjUsePlusStatFruit@@YAXHH@Z ENDP			; gObjUsePlusStatFruit
_TEXT	ENDS
PUBLIC	??_C@_0CB@JMMECNKE@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?$FL?$CFd?$FN?5?$CFd@ ; `string'
PUBLIC	??_C@_0FO@LLOCJMCJ@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5MinusStat?$FL?$CFd@ ; `string'
PUBLIC	??_C@_0CI@IDKIMBEH@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5?$FL?$CFd?$FN@ ; `string'
PUBLIC	??_C@_0DP@FGEMANAJ@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5StatDown@ ; `string'
PUBLIC	?gObjUseMinusStatFruit@@YAXHH@Z			; gObjUseMinusStatFruit
;	COMDAT ??_C@_0CB@JMMECNKE@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?$FL?$CFd?$FN?5?$CFd@
CONST	SEGMENT
??_C@_0CB@JMMECNKE@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?$FL?$CFd?$FN?5?$CFd@ DB '['
	DB	'StatDown] [%s][%s] Fail [%d] %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@LLOCJMCJ@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5MinusStat?$FL?$CFd@
CONST	SEGMENT
??_C@_0FO@LLOCJMCJ@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5MinusStat?$FL?$CFd@ DB '['
	DB	'StatDown] [%s][%s] MinusStat[%d] -> LevelUpPoint Old(%d)/New('
	DB	'%d)  FruitPoint Old(%d)/New(%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IDKIMBEH@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5?$FL?$CFd?$FN@
CONST	SEGMENT
??_C@_0CI@IDKIMBEH@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5?$FL?$CFd?$FN@ DB '['
	DB	'StatDown] [%s][%s] Success [%d][%d] %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@FGEMANAJ@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5StatDown@
CONST	SEGMENT
??_C@_0DP@FGEMANAJ@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5StatDown@ DB '['
	DB	'StatDown] [%s][%s] Use StatDownItem Level:%d Pos:%d serial:%d'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjUseMinusStatFruit@@YAXHH@Z
_TEXT	SEGMENT
_pResult$ = -44						; size = 6
tv618 = -36						; size = 4
_bSuccess$ = -36					; size = 4
tv693 = -32						; size = 4
_iItemSerial$ = -28					; size = 4
_MaxMinusPoint$ = -24					; size = 2
_iDefaultStat$ = -20					; size = 4
_iPresentStat$ = -16					; size = 4
_iItemLevel$ = -12					; size = 4
_iDecStat$ = -8						; size = 4
_AddPoint$ = -8						; size = 2
tv692 = -4						; size = 4
_MaxAddPoint$ = -4					; size = 2
tv870 = 8						; size = 4
_MinusPoint$ = 8					; size = 2
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 4
?gObjUseMinusStatFruit@@YAXHH@Z PROC			; gObjUseMinusStatFruit, COMDAT

; 17297: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	57		 push	 edi

; 17298: 	if(!OBJMAX_RANGE(aIndex))

  00007	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000a	85 ff		 test	 edi, edi
  0000c	0f 88 a9 04 00
	00		 js	 $LN48@gObjUseMin
  00012	33 c0		 xor	 eax, eax
  00014	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 96 04 00
	00		 je	 $LN48@gObjUseMin

; 17299: 	{
; 17300: 		return;
; 17301: 	}
; 17302: 
; 17303: 	if(gObj[aIndex].Class >= 5 || gObj[aIndex].Class < 0)

  00025	56		 push	 esi
  00026	8b f7		 mov	 esi, edi
  00028	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0002e	0f b7 8e 98 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152]
  00035	83 f9 05	 cmp	 ecx, 5
  00038	0f 83 7c 04 00
	00		 jae	 $LN63@gObjUseMin

; 17304: 	{
; 17305: 		return;
; 17306: 	}
; 17307: 
; 17308: 	int iItemLevel = gObj[aIndex].pInventory[pos].m_Level;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  00041	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00047	53		 push	 ebx
  00048	89 45 dc	 mov	 DWORD PTR tv618[ebp], eax
  0004b	03 86 8c 0c 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]

; 17309: 	int iItemSerial = gObj[aIndex].pInventory[pos].m_Number;
; 17310: 	int iCharacterClass = gObj[aIndex].Class;
; 17311: 
; 17312: 	PMSG_USE_STAT_FRUIT pResult;
; 17313: 
; 17314: 	PHeadSetB((LPBYTE)&pResult,0x2C,sizeof(pResult));

  00051	6a 06		 push	 6
  00053	0f bf 50 08	 movsx	 edx, WORD PTR [eax+8]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	8b d9		 mov	 ebx, ecx
  0005b	8d 4d d4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0005e	6a 2c		 push	 44			; 0000002cH
  00060	51		 push	 ecx
  00061	89 55 f4	 mov	 DWORD PTR _iItemLevel$[ebp], edx
  00064	89 45 e4	 mov	 DWORD PTR _iItemSerial$[ebp], eax
  00067	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17315: 
; 17316: 	pResult.result = 5;
; 17317: 	pResult.btFruitType = iItemLevel;

  0006c	8b 45 f4	 mov	 eax, DWORD PTR _iItemLevel$[ebp]
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17318: 	pResult.btStatValue = 0;
; 17319: 
; 17320: 	if(gObj[aIndex].Level <= 9 || iItemLevel > 4)

  00072	66 83 be 9c 00
	00 00 09	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156], 9
  0007a	88 45 d9	 mov	 BYTE PTR _pResult$[ebp+5], al
  0007d	66 c7 45 d7 05
	00		 mov	 WORD PTR _pResult$[ebp+3], 5
  00083	0f 8e 1a 04 00
	00		 jle	 $LN46@gObjUseMin
  00089	83 f8 04	 cmp	 eax, 4
  0008c	0f 8f 11 04 00
	00		 jg	 $LN46@gObjUseMin

; 17324: 		return;
; 17325: 	}
; 17326: 
; 17327: 	if(iItemLevel == 4 && gObj[aIndex].Class != 4)

  00092	75 27		 jne	 SHORT $LN45@gObjUseMin
  00094	66 83 be 98 00
	00 00 04	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152], 4
  0009c	74 1d		 je	 SHORT $LN45@gObjUseMin

; 17328: 	{
; 17329: 		pResult.result = 5;
; 17330: 		DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  0009e	0f b6 55 d5	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  000a2	52		 push	 edx
  000a3	8d 45 d4	 lea	 eax, DWORD PTR _pResult$[ebp]
  000a6	50		 push	 eax
  000a7	57		 push	 edi
  000a8	c6 45 d7 05	 mov	 BYTE PTR _pResult$[ebp+3], 5
  000ac	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	5b		 pop	 ebx
  000b5	5e		 pop	 esi
  000b6	5f		 pop	 edi

; 17535: }

  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
$LN45@gObjUseMin:

; 17331: 		return;
; 17332: 	}
; 17333: 
; 17334: 	for(int iItemIndex = 0; iItemIndex < INVETORY_WEAR_SIZE; iItemIndex++)

  000bb	c7 45 08 00 00
	00 00		 mov	 DWORD PTR tv870[ebp], 0
$LL61@gObjUseMin:

; 17335: 	{
; 17336: 		if(gObj[aIndex].pInventory[iItemIndex].IsItem())

  000c2	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  000c8	03 4d 08	 add	 ecx, DWORD PTR tv870[ebp]
  000cb	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000d0	85 c0		 test	 eax, eax
  000d2	75 3a		 jne	 SHORT $LN56@gObjUseMin

; 17331: 		return;
; 17332: 	}
; 17333: 
; 17334: 	for(int iItemIndex = 0; iItemIndex < INVETORY_WEAR_SIZE; iItemIndex++)

  000d4	8b 45 08	 mov	 eax, DWORD PTR tv870[ebp]
  000d7	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  000dc	89 45 08	 mov	 DWORD PTR tv870[ebp], eax
  000df	3d e0 07 00 00	 cmp	 eax, 2016		; 000007e0H
  000e4	7c dc		 jl	 SHORT $LL61@gObjUseMin

; 17340: 			return;
; 17341: 		}
; 17342: 	}
; 17343: 
; 17344: 	int iDefaultStat = 0;
; 17345: 	int iPresentStat = 0;
; 17346: 	int bEnableUseFruit = 1;
; 17347: 
; 17348: 	if(iItemLevel == 0)

  000e6	8b 45 f4	 mov	 eax, DWORD PTR _iItemLevel$[ebp]
  000e9	33 d2		 xor	 edx, edx
  000eb	89 55 ec	 mov	 DWORD PTR _iDefaultStat$[ebp], edx
  000ee	89 55 f0	 mov	 DWORD PTR _iPresentStat$[ebp], edx
  000f1	3b c2		 cmp	 eax, edx
  000f3	75 36		 jne	 SHORT $LN40@gObjUseMin

; 17349: 	{
; 17350: 		iDefaultStat = DCInfo.DefClass[iCharacterClass].Energy;
; 17351: 		iPresentStat = gObj[aIndex].Energy;

  000f5	0f b7 8e ba 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+186]
  000fc	69 db 60 09 00
	00		 imul	 ebx, 2400		; 00000960H
  00102	0f b7 83 0e 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ebx+14]

; 17352: 
; 17353: 		if(iPresentStat <= iDefaultStat)
; 17354: 		{
; 17355: 			bEnableUseFruit = 0;
; 17356: 		}
; 17357: 	}

  00109	e9 87 00 00 00	 jmp	 $LN68@gObjUseMin
$LN56@gObjUseMin:

; 17337: 		{
; 17338: 			pResult.result = 16;
; 17339: 			DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  0010e	0f b6 4d d5	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00112	51		 push	 ecx
  00113	8d 55 d4	 lea	 edx, DWORD PTR _pResult$[ebp]
  00116	52		 push	 edx
  00117	57		 push	 edi
  00118	c6 45 d7 10	 mov	 BYTE PTR _pResult$[ebp+3], 16 ; 00000010H
  0011c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00121	83 c4 0c	 add	 esp, 12			; 0000000cH
  00124	5b		 pop	 ebx
  00125	5e		 pop	 esi
  00126	5f		 pop	 edi

; 17535: }

  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
$LN40@gObjUseMin:

; 17358: 	else if(iItemLevel == 1)

  0012b	83 f8 01	 cmp	 eax, 1
  0012e	75 16		 jne	 SHORT $LN37@gObjUseMin

; 17359: 	{
; 17360: 		iDefaultStat = DCInfo.DefClass[iCharacterClass].Vitality;
; 17361: 		iPresentStat = gObj[aIndex].Vitality;

  00130	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+184]
  00137	69 db 60 09 00
	00		 imul	 ebx, 2400		; 00000960H
  0013d	0f b7 83 0c 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ebx+12]

; 17362: 
; 17363: 		if(iPresentStat <= iDefaultStat)
; 17364: 		{
; 17365: 			bEnableUseFruit = 0;
; 17366: 		}
; 17367: 	}

  00144	eb 4f		 jmp	 SHORT $LN68@gObjUseMin
$LN37@gObjUseMin:

; 17368: 	else if(iItemLevel == 2)

  00146	83 f8 02	 cmp	 eax, 2
  00149	75 16		 jne	 SHORT $LN34@gObjUseMin

; 17369: 	{
; 17370: 		iDefaultStat = DCInfo.DefClass[iCharacterClass].Dexterity;
; 17371: 		iPresentStat = gObj[aIndex].Dexterity;

  0014b	0f b7 8e b6 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+182]
  00152	69 db 60 09 00
	00		 imul	 ebx, 2400		; 00000960H
  00158	0f b7 83 0a 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ebx+10]

; 17372: 
; 17373: 		if(iPresentStat <= iDefaultStat)
; 17374: 		{
; 17375: 			bEnableUseFruit = 0;
; 17376: 		}
; 17377: 	}

  0015f	eb 34		 jmp	 SHORT $LN68@gObjUseMin
$LN34@gObjUseMin:

; 17378: 	else if(iItemLevel == 3)

  00161	83 f8 03	 cmp	 eax, 3
  00164	75 16		 jne	 SHORT $LN31@gObjUseMin

; 17379: 	{
; 17380: 		iDefaultStat = DCInfo.DefClass[iCharacterClass].Strength;
; 17381: 		iPresentStat = gObj[aIndex].Strength;

  00166	0f b7 8e b4 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+180]
  0016d	69 db 60 09 00
	00		 imul	 ebx, 2400		; 00000960H
  00173	0f b7 83 08 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ebx+8]

; 17382: 
; 17383: 		if(iPresentStat <= iDefaultStat)
; 17384: 		{
; 17385: 			bEnableUseFruit = 0;
; 17386: 		}
; 17387: 	}

  0017a	eb 19		 jmp	 SHORT $LN68@gObjUseMin
$LN31@gObjUseMin:

; 17388: 	else if(iItemLevel == 4)

  0017c	83 f8 04	 cmp	 eax, 4
  0017f	75 3b		 jne	 SHORT $LN60@gObjUseMin

; 17389: 	{
; 17390: 		iDefaultStat = DCInfo.DefClass[iCharacterClass].Leadership;
; 17391: 		iPresentStat = gObj[aIndex].Leadership;

  00181	0f b7 8e d8 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+216]
  00188	69 db 60 09 00
	00		 imul	 ebx, 2400		; 00000960H
  0018e	0f b7 83 60 09
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ebx+2400]
$LN68@gObjUseMin:
  00195	89 45 ec	 mov	 DWORD PTR _iDefaultStat$[ebp], eax
  00198	89 4d f0	 mov	 DWORD PTR _iPresentStat$[ebp], ecx

; 17392: 
; 17393: 		if(iPresentStat <= iDefaultStat)

  0019b	3b c8		 cmp	 ecx, eax
  0019d	7f 1d		 jg	 SHORT $LN60@gObjUseMin

; 17394: 		{
; 17395: 			bEnableUseFruit = 0;
; 17396: 		}
; 17397: 	}
; 17398: 
; 17399: 	if(bEnableUseFruit == 0)
; 17400: 	{
; 17401: 		pResult.result = 38;
; 17402: 		DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  0019f	0f b6 45 d5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001a3	50		 push	 eax
  001a4	8d 4d d4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001a7	51		 push	 ecx
  001a8	57		 push	 edi
  001a9	c6 45 d7 26	 mov	 BYTE PTR _pResult$[ebp+3], 38 ; 00000026H
  001ad	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b5	5b		 pop	 ebx
  001b6	5e		 pop	 esi
  001b7	5f		 pop	 edi

; 17535: }

  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c3		 ret	 0
$LN60@gObjUseMin:

; 17403: 		return;
; 17404: 	}
; 17405: 
; 17406: 	short AddPoint;
; 17407: 	short MaxAddPoint;
; 17408: 	short MinusPoint;
; 17409: 	short MaxMinusPoint = 0;

  001bc	89 55 e8	 mov	 DWORD PTR _MaxMinusPoint$[ebp], edx

; 17410: 
; 17411: 	gObjGetStatPointState(aIndex,(short &)AddPoint,(short &)MaxAddPoint,(short &)MinusPoint,(short &)MaxMinusPoint);

  001bf	8d 55 e8	 lea	 edx, DWORD PTR _MaxMinusPoint$[ebp]
  001c2	52		 push	 edx
  001c3	8d 45 08	 lea	 eax, DWORD PTR _MinusPoint$[ebp]
  001c6	50		 push	 eax
  001c7	8d 4d fc	 lea	 ecx, DWORD PTR _MaxAddPoint$[ebp]
  001ca	51		 push	 ecx
  001cb	8d 55 f8	 lea	 edx, DWORD PTR _AddPoint$[ebp]
  001ce	52		 push	 edx
  001cf	57		 push	 edi
  001d0	e8 00 00 00 00	 call	 ?gObjGetStatPointState@@YAXHAAF000@Z ; gObjGetStatPointState

; 17412: 
; 17413: 	if(MinusPoint >= MaxMinusPoint || MinusPoint < 0)

  001d5	66 8b 45 08	 mov	 ax, WORD PTR _MinusPoint$[ebp]
  001d9	83 c4 14	 add	 esp, 20			; 00000014H
  001dc	66 3b 45 e8	 cmp	 ax, WORD PTR _MaxMinusPoint$[ebp]
  001e0	0f 8d a0 02 00
	00		 jge	 $LN24@gObjUseMin
  001e6	66 85 c0	 test	 ax, ax
  001e9	0f 88 97 02 00
	00		 js	 $LN24@gObjUseMin

; 17417: 		return;
; 17418: 	}
; 17419: 
; 17420: 	LogAdd(LOG_BLACK, "[StatDown] [%s][%s] Use StatDownItem Level:%d Pos:%d serial:%d",
; 17421: 		gObj[aIndex].AccountID,gObj[aIndex].Name,iItemLevel,pos,iItemSerial);

  001ef	8b 55 e4	 mov	 edx, DWORD PTR _iItemSerial$[ebp]
  001f2	8b 5d 0c	 mov	 ebx, DWORD PTR _pos$[ebp]
  001f5	52		 push	 edx
  001f6	8b 55 f4	 mov	 edx, DWORD PTR _iItemLevel$[ebp]
  001f9	53		 push	 ebx
  001fa	52		 push	 edx
  001fb	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00201	50		 push	 eax
  00202	8d 8e 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  00208	51		 push	 ecx
  00209	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@FGEMANAJ@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5StatDown@
  0020e	6a 00		 push	 0
  00210	89 45 fc	 mov	 DWORD PTR tv692[ebp], eax
  00213	89 4d e0	 mov	 DWORD PTR tv693[ebp], ecx
  00216	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 17422: 
; 17423: 	gObjInventoryItemSet(aIndex,pos,0xFF);

  0021b	68 ff 00 00 00	 push	 255			; 000000ffH
  00220	53		 push	 ebx
  00221	57		 push	 edi
  00222	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 17424: 	gObj[aIndex].pInventory[pos].Clear();

  00227	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  0022d	03 4d dc	 add	 ecx, DWORD PTR tv618[ebp]
  00230	83 c4 28	 add	 esp, 40			; 00000028H
  00233	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 17425: 	GCInventoryItemDeleteSend(aIndex,pos,1);

  00238	6a 01		 push	 1
  0023a	53		 push	 ebx
  0023b	57		 push	 edi
  0023c	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 17426: 
; 17427: 	int iDecStat = 0;
; 17428: 	int bSuccess = 0;
; 17429: 
; 17430: 	int iSuccessRate = 100 - gObj[aIndex].Level / 6;

  00241	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156]
  00248	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0024d	f7 e9		 imul	 ecx
  0024f	8b c2		 mov	 eax, edx
  00251	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00254	03 c2		 add	 eax, edx
  00256	bb 64 00 00 00	 mov	 ebx, 100		; 00000064H
  0025b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0025e	2b d8		 sub	 ebx, eax
  00260	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _bSuccess$[ebp], 0

; 17431: 
; 17432: 	if(iSuccessRate < 0)

  00267	79 02		 jns	 SHORT $LN23@gObjUseMin

; 17433: 	{
; 17434: 		iSuccessRate = 0;

  00269	33 db		 xor	 ebx, ebx
$LN23@gObjUseMin:

; 17435: 	}
; 17436: 
; 17437: 	if(rand()%100 < iSuccessRate)

  0026b	e8 00 00 00 00	 call	 _rand
  00270	99		 cdq
  00271	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00276	f7 f9		 idiv	 ecx

; 17438: 	{
; 17439: 		bSuccess = 1;

  00278	8d 41 9d	 lea	 eax, DWORD PTR [ecx-99]
  0027b	3b d3		 cmp	 edx, ebx
  0027d	7c 03		 jl	 SHORT $LN22@gObjUseMin
  0027f	8b 45 dc	 mov	 eax, DWORD PTR _bSuccess$[ebp]
$LN22@gObjUseMin:

; 17440: 	}
; 17441: 
; 17442: 	if(MinusPoint <= 10)

  00282	66 83 7d 08 0a	 cmp	 WORD PTR _MinusPoint$[ebp], 10 ; 0000000aH

; 17443: 	{
; 17444: 		bSuccess = 1;
; 17445: 	}
; 17446: 
; 17447: 	if(bSuccess != 0)

  00287	7e 08		 jle	 SHORT $LN59@gObjUseMin
  00289	85 c0		 test	 eax, eax
  0028b	0f 84 b7 01 00
	00		 je	 $LN20@gObjUseMin
$LN59@gObjUseMin:

; 17448: 	{
; 17449: 		iSuccessRate = rand()%100;

  00291	e8 00 00 00 00	 call	 _rand
  00296	99		 cdq
  00297	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0029c	f7 f9		 idiv	 ecx

; 17450: 
; 17451: 		if(iSuccessRate < 50)

  0029e	83 fa 32	 cmp	 edx, 50			; 00000032H
  002a1	7d 05		 jge	 SHORT $LN19@gObjUseMin

; 17452: 		{
; 17453: 			iDecStat = 1;

  002a3	8d 59 9d	 lea	 ebx, DWORD PTR [ecx-99]
  002a6	eb 24		 jmp	 SHORT $LN69@gObjUseMin
$LN19@gObjUseMin:

; 17454: 		}
; 17455: 		else if(iSuccessRate < 75)

  002a8	83 fa 4b	 cmp	 edx, 75			; 0000004bH
  002ab	7d 07		 jge	 SHORT $LN17@gObjUseMin

; 17456: 		{
; 17457: 			iDecStat = 3;

  002ad	bb 03 00 00 00	 mov	 ebx, 3
  002b2	eb 18		 jmp	 SHORT $LN69@gObjUseMin
$LN17@gObjUseMin:

; 17458: 		}
; 17459: 		else if(iSuccessRate < 91)

  002b4	83 fa 5b	 cmp	 edx, 91			; 0000005bH
  002b7	7d 07		 jge	 SHORT $LN15@gObjUseMin

; 17460: 		{
; 17461: 			iDecStat = 5;

  002b9	bb 05 00 00 00	 mov	 ebx, 5
  002be	eb 0c		 jmp	 SHORT $LN69@gObjUseMin
$LN15@gObjUseMin:

; 17462: 		}
; 17463: 		else if(iSuccessRate < 98)

  002c0	33 db		 xor	 ebx, ebx
  002c2	83 fa 62	 cmp	 edx, 98			; 00000062H
  002c5	0f 9d c3	 setge	 bl
  002c8	8d 5c 1b 07	 lea	 ebx, DWORD PTR [ebx+ebx+7]
$LN69@gObjUseMin:

; 17464: 		{
; 17465: 			iDecStat = 7;
; 17466: 		}
; 17467: 		else
; 17468: 		{
; 17469: 			iDecStat = 9;
; 17470: 		}
; 17471: 
; 17472: 		if((MinusPoint + iDecStat) >= MaxMinusPoint)

  002cc	0f bf 4d 08	 movsx	 ecx, WORD PTR _MinusPoint$[ebp]
  002d0	0f bf 45 e8	 movsx	 eax, WORD PTR _MaxMinusPoint$[ebp]
  002d4	8d 14 19	 lea	 edx, DWORD PTR [ecx+ebx]
  002d7	89 5d f8	 mov	 DWORD PTR _iDecStat$[ebp], ebx
  002da	3b d0		 cmp	 edx, eax
  002dc	7c 07		 jl	 SHORT $LN11@gObjUseMin

; 17473: 		{
; 17474: 			iDecStat = MaxMinusPoint - MinusPoint;

  002de	2b c1		 sub	 eax, ecx
  002e0	8b d8		 mov	 ebx, eax
  002e2	89 5d f8	 mov	 DWORD PTR _iDecStat$[ebp], ebx
$LN11@gObjUseMin:

; 17475: 		}
; 17476: 
; 17477: 		if((iPresentStat - iDecStat) < iDefaultStat)

  002e5	8b 45 f0	 mov	 eax, DWORD PTR _iPresentStat$[ebp]
  002e8	8b 4d ec	 mov	 ecx, DWORD PTR _iDefaultStat$[ebp]
  002eb	8b d0		 mov	 edx, eax
  002ed	2b d3		 sub	 edx, ebx
  002ef	3b d1		 cmp	 edx, ecx
  002f1	7d 07		 jge	 SHORT $LN10@gObjUseMin

; 17478: 		{
; 17479: 			iDecStat = iPresentStat - iDefaultStat;

  002f3	2b c1		 sub	 eax, ecx
  002f5	8b d8		 mov	 ebx, eax
  002f7	89 5d f8	 mov	 DWORD PTR _iDecStat$[ebp], ebx
$LN10@gObjUseMin:

; 17480: 		}
; 17481: 
; 17482: 		pResult.result = 3;
; 17483: 		pResult.btFruitType = iItemLevel;
; 17484: 		pResult.btStatValue = iDecStat;
; 17485: 
; 17486: 		DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  002fa	0f b6 4d d5	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  002fe	8a 45 f4	 mov	 al, BYTE PTR _iItemLevel$[ebp]
  00301	51		 push	 ecx
  00302	8d 55 d4	 lea	 edx, DWORD PTR _pResult$[ebp]
  00305	52		 push	 edx
  00306	57		 push	 edi
  00307	c6 45 d7 03	 mov	 BYTE PTR _pResult$[ebp+3], 3
  0030b	88 45 d9	 mov	 BYTE PTR _pResult$[ebp+5], al
  0030e	88 5d d8	 mov	 BYTE PTR _pResult$[ebp+4], bl
  00311	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17487: 		LogAdd(LOG_BLACK, "[StatDown] [%s][%s] Success [%d][%d] %d",
; 17488: 			gObj[aIndex].AccountID,gObj[aIndex].Name,iItemLevel,iDecStat,iItemSerial);

  00316	8b 45 e4	 mov	 eax, DWORD PTR _iItemSerial$[ebp]
  00319	8b 4d f4	 mov	 ecx, DWORD PTR _iItemLevel$[ebp]
  0031c	8b 55 fc	 mov	 edx, DWORD PTR tv692[ebp]
  0031f	50		 push	 eax
  00320	8b 45 e0	 mov	 eax, DWORD PTR tv693[ebp]
  00323	53		 push	 ebx
  00324	51		 push	 ecx
  00325	52		 push	 edx
  00326	50		 push	 eax
  00327	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@IDKIMBEH@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5?$FL?$CFd?$FN@
  0032c	6a 00		 push	 0
  0032e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 17498: 		return;
; 17499: 	}
; 17500: 
; 17501: 	switch(iItemLevel)

  00333	8b 45 f4	 mov	 eax, DWORD PTR _iItemLevel$[ebp]
  00336	83 c4 28	 add	 esp, 40			; 00000028H
  00339	83 f8 04	 cmp	 eax, 4
  0033c	77 69		 ja	 SHORT $LN1@gObjUseMin
  0033e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN70@gObjUseMin[eax*4]
$LN6@gObjUseMin:

; 17502: 	{
; 17503: 	case 4:	gObj[aIndex].Leadership -= iDecStat;	break;

  00345	66 29 9e d8 00
	00 00		 sub	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+216], bx
  0034c	eb 59		 jmp	 SHORT $LN1@gObjUseMin
$LN5@gObjUseMin:

; 17504: 	case 3: gObj[aIndex].Strength -= iDecStat;	break;

  0034e	66 29 9e b4 00
	00 00		 sub	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+180], bx
  00355	eb 50		 jmp	 SHORT $LN1@gObjUseMin
$LN4@gObjUseMin:

; 17505: 	case 2: gObj[aIndex].Dexterity -= iDecStat;	break;

  00357	66 29 9e b6 00
	00 00		 sub	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+182], bx
  0035e	eb 47		 jmp	 SHORT $LN1@gObjUseMin
$LN3@gObjUseMin:

; 17506: 	case 1:
; 17507: 
; 17508: 		gObj[aIndex].Vitality -= iDecStat;
; 17509: 		gObj[aIndex].MaxLife -= gObj[aIndex].VitalityToLife *iDecStat;

  00360	d9 86 c0 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]
  00366	66 29 9e b8 00
	00 00		 sub	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+184], bx
  0036d	d9 86 f4 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+244]
  00373	da 4d f8	 fimul	 DWORD PTR _iDecStat$[ebp]
  00376	de e9		 fsubp	 ST(1), ST(0)
  00378	d9 9e c0 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]

; 17510: 		break;

  0037e	eb 27		 jmp	 SHORT $LN1@gObjUseMin
$LN2@gObjUseMin:

; 17511: 
; 17512: 	case 0:
; 17513: 		gObj[aIndex].Energy -= iDecStat;
; 17514: 		gObj[aIndex].MaxMana -= gObj[aIndex].EnergyToMana * iDecStat;

  00380	d9 86 d4 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  00386	66 29 9e ba 00
	00 00		 sub	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+186], bx
  0038d	d9 86 f8 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+248]

; 17515: 		gObjSetBP(aIndex);

  00393	57		 push	 edi
  00394	da 4d f8	 fimul	 DWORD PTR _iDecStat$[ebp]
  00397	de e9		 fsubp	 ST(1), ST(0)
  00399	d9 9e d4 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  0039f	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP
  003a4	83 c4 04	 add	 esp, 4
$LN1@gObjUseMin:

; 17516: 		break;
; 17517: 
; 17518: 	default:
; 17519: 		break;
; 17520: 	}
; 17521: 
; 17522: 	int iOldLevelUpPoint = gObj[aIndex].LevelUpPoint;

  003a7	8b 8e a0 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+160]

; 17523: 	gObj[aIndex].LevelUpPoint += iDecStat;
; 17524: 
; 17525: 	int iOldFruitPoint = gObj[aIndex].LevelUpPoint;
; 17526: 	gObj[aIndex].iFruitPoint += iDecStat;

  003ad	01 9e a4 00 00
	00		 add	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+164], ebx
  003b3	8b 96 a4 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+164]

; 17527: 
; 17528: 	LogAdd(LOG_BLACK, "[StatDown] [%s][%s] MinusStat[%d] -> LevelUpPoint Old(%d)/New(%d)  FruitPoint Old(%d)/New(%d)",
; 17529: 		gObj[aIndex].AccountID,gObj[aIndex].Name,iDecStat,iOldLevelUpPoint,gObj[aIndex].LevelUpPoint,iOldFruitPoint,gObj[aIndex].iFruitPoint);

  003b9	52		 push	 edx
  003ba	8b 55 e0	 mov	 edx, DWORD PTR tv693[ebp]
  003bd	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  003c0	50		 push	 eax
  003c1	50		 push	 eax
  003c2	51		 push	 ecx
  003c3	8b 4d fc	 mov	 ecx, DWORD PTR tv692[ebp]
  003c6	53		 push	 ebx
  003c7	51		 push	 ecx
  003c8	52		 push	 edx
  003c9	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@LLOCJMCJ@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5MinusStat?$FL?$CFd@
  003ce	6a 00		 push	 0
  003d0	89 86 a0 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+160], eax
  003d6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 17530: 
; 17531: 	gObjCalCharacter(aIndex);

  003db	57		 push	 edi
  003dc	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 17532: 	GCReFillSend(gObj[aIndex].m_Index,gObj[aIndex].MaxLife + gObj[aIndex].AddLife,0xFE,0);

  003e1	db 86 0c 01 00
	00		 fild	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+268]
  003e7	83 c4 28	 add	 esp, 40			; 00000028H
  003ea	6a 00		 push	 0
  003ec	d8 86 c0 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]
  003f2	68 fe 00 00 00	 push	 254			; 000000feH
  003f7	e8 00 00 00 00	 call	 __ftol2_sse
  003fc	50		 push	 eax
  003fd	8b 86 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00403	50		 push	 eax
  00404	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend

; 17533: 	gObjSetBP(aIndex);

  00409	57		 push	 edi
  0040a	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 17534: 	GCManaSend(gObj[aIndex].m_Index,gObj[aIndex].MaxMana + gObj[aIndex].AddMana,0xFE,0,gObj[aIndex].MaxBP);

  0040f	db 86 10 01 00
	00		 fild	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+272]
  00415	8b 8e ec 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+236]
  0041b	83 c4 14	 add	 esp, 20			; 00000014H
  0041e	d8 86 d4 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  00424	51		 push	 ecx
  00425	6a 00		 push	 0
  00427	68 fe 00 00 00	 push	 254			; 000000feH
  0042c	e8 00 00 00 00	 call	 __ftol2_sse
  00431	8b 96 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00437	50		 push	 eax
  00438	52		 push	 edx
  00439	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  0043e	83 c4 14	 add	 esp, 20			; 00000014H
  00441	5b		 pop	 ebx
  00442	5e		 pop	 esi
  00443	5f		 pop	 edi

; 17535: }

  00444	8b e5		 mov	 esp, ebp
  00446	5d		 pop	 ebp
  00447	c3		 ret	 0
$LN20@gObjUseMin:

; 17489: 	}
; 17490: 	else
; 17491: 	{
; 17492: 		pResult.result = 4;
; 17493: 		pResult.btFruitType = iItemLevel;
; 17494: 		pResult.btStatValue = 0;
; 17495: 		DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  00448	0f b6 45 d5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0044c	8b 5d f4	 mov	 ebx, DWORD PTR _iItemLevel$[ebp]
  0044f	50		 push	 eax
  00450	8d 4d d4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00453	51		 push	 ecx
  00454	57		 push	 edi
  00455	88 5d d9	 mov	 BYTE PTR _pResult$[ebp+5], bl
  00458	66 c7 45 d7 04
	00		 mov	 WORD PTR _pResult$[ebp+3], 4
  0045e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17496: 		LogAdd(LOG_BLACK, "[StatDown] [%s][%s] Fail [%d] %d",
; 17497: 			gObj[aIndex].AccountID,gObj[aIndex].Name,iItemLevel,iItemSerial);

  00463	8b 55 e4	 mov	 edx, DWORD PTR _iItemSerial$[ebp]
  00466	8b 45 fc	 mov	 eax, DWORD PTR tv692[ebp]
  00469	8b 4d e0	 mov	 ecx, DWORD PTR tv693[ebp]
  0046c	52		 push	 edx
  0046d	53		 push	 ebx
  0046e	50		 push	 eax
  0046f	51		 push	 ecx
  00470	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JMMECNKE@?$FLStatDown?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?$FL?$CFd?$FN?5?$CFd@
  00475	6a 00		 push	 0
  00477	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0047c	83 c4 24	 add	 esp, 36			; 00000024H
  0047f	5b		 pop	 ebx
  00480	5e		 pop	 esi
  00481	5f		 pop	 edi

; 17535: }

  00482	8b e5		 mov	 esp, ebp
  00484	5d		 pop	 ebp
  00485	c3		 ret	 0
$LN24@gObjUseMin:

; 17414: 	{
; 17415: 		pResult.result = 37;
; 17416: 		DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  00486	0f b6 55 d5	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0048a	52		 push	 edx
  0048b	8d 45 d4	 lea	 eax, DWORD PTR _pResult$[ebp]
  0048e	50		 push	 eax
  0048f	57		 push	 edi
  00490	c6 45 d7 25	 mov	 BYTE PTR _pResult$[ebp+3], 37 ; 00000025H
  00494	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00499	83 c4 0c	 add	 esp, 12			; 0000000cH
  0049c	5b		 pop	 ebx
  0049d	5e		 pop	 esi
  0049e	5f		 pop	 edi

; 17535: }

  0049f	8b e5		 mov	 esp, ebp
  004a1	5d		 pop	 ebp
  004a2	c3		 ret	 0
$LN46@gObjUseMin:

; 17321: 	{
; 17322: 		pResult.result = 5;
; 17323: 		DataSend(aIndex,(unsigned char *)&pResult,pResult.h.size);

  004a3	0f b6 4d d5	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  004a7	51		 push	 ecx
  004a8	8d 55 d4	 lea	 edx, DWORD PTR _pResult$[ebp]
  004ab	52		 push	 edx
  004ac	57		 push	 edi
  004ad	c6 45 d7 05	 mov	 BYTE PTR _pResult$[ebp+3], 5
  004b1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  004b9	5b		 pop	 ebx
$LN63@gObjUseMin:
  004ba	5e		 pop	 esi
$LN48@gObjUseMin:
  004bb	5f		 pop	 edi

; 17535: }

  004bc	8b e5		 mov	 esp, ebp
  004be	5d		 pop	 ebp
  004bf	c3		 ret	 0
$LN70@gObjUseMin:
  004c0	00 00 00 00	 DD	 $LN2@gObjUseMin
  004c4	00 00 00 00	 DD	 $LN3@gObjUseMin
  004c8	00 00 00 00	 DD	 $LN4@gObjUseMin
  004cc	00 00 00 00	 DD	 $LN5@gObjUseMin
  004d0	00 00 00 00	 DD	 $LN6@gObjUseMin
?gObjUseMinusStatFruit@@YAXHH@Z ENDP			; gObjUseMinusStatFruit
_TEXT	ENDS
PUBLIC	??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5Le@ ; `string'
PUBLIC	?gObjSetExpPetItem@@YAXHH@Z			; gObjSetExpPetItem
EXTRN	?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z:PROC	; CDarkSpirit::SendLevelmsg
EXTRN	?PetItemLevelDown@CItem@@QAEHH@Z:PROC		; CItem::PetItemLevelDown
EXTRN	?AddPetItemExp@CItem@@QAEHH@Z:PROC		; CItem::AddPetItemExp
EXTRN	?gDarkSpiritAddExperience@@3MA:DWORD		; gDarkSpiritAddExperience
;	COMDAT ??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5Le@
CONST	SEGMENT
??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5Le@ DB '['
	DB	'%s][%s][PetItemLevelUp] [%s] Level:[%d]Exp:[%d]AddExp:[%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjSetExpPetItem@@YAXHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_exp$ = 12						; size = 4
?gObjSetExpPetItem@@YAXHH@Z PROC			; gObjSetExpPetItem, COMDAT

; 18008: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 18009: 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0000d	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 18010: 
; 18011: 	if(lpObj->Class != 4)	

  00013	66 83 be 98 00
	00 00 04	 cmp	 WORD PTR [esi+152], 4
  0001b	0f 85 5b 03 00
	00		 jne	 $LN1@gObjSetExp

; 18012: 	{
; 18013: 		return;
; 18014: 	}
; 18015: 
; 18016: 	exp *= gDarkSpiritAddExperience;

  00021	db 45 0c	 fild	 DWORD PTR _exp$[ebp]
  00024	53		 push	 ebx
  00025	57		 push	 edi
  00026	d8 0d 00 00 00
	00		 fmul	 DWORD PTR ?gDarkSpiritAddExperience@@3MA ; gDarkSpiritAddExperience
  0002c	e8 00 00 00 00	 call	 __ftol2_sse

; 18017: 
; 18018: 	if(lpObj->pInventory[8].m_Type == ITEMGET(13,4) && lpObj->pInventory[1].m_Type == ITEMGET(13,5))

  00031	8b 9e 8c 0c 00
	00		 mov	 ebx, DWORD PTR [esi+3212]
  00037	0f b7 8b 46 05
	00 00		 movzx	 ecx, WORD PTR [ebx+1350]
  0003e	ba 04 1a 00 00	 mov	 edx, 6660		; 00001a04H
  00043	66 3b ca	 cmp	 cx, dx
  00046	0f 85 85 01 00
	00		 jne	 $LN17@gObjSetExp
  0004c	ba 05 1a 00 00	 mov	 edx, 6661		; 00001a05H
  00051	66 39 93 ae 00
	00 00		 cmp	 WORD PTR [ebx+174], dx
  00058	0f 85 73 01 00
	00		 jne	 $LN17@gObjSetExp

; 18019: 	{
; 18020: 		int addexp = exp * 10 / 100;

  0005e	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00061	03 c9		 add	 ecx, ecx
  00063	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00068	f7 e9		 imul	 ecx
  0006a	c1 fa 05	 sar	 edx, 5
  0006d	8b fa		 mov	 edi, edx
  0006f	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00072	03 fa		 add	 edi, edx

; 18021: 
; 18022: 		if(lpObj->pInventory[1].AddPetItemExp(addexp))

  00074	57		 push	 edi
  00075	8d 8b a8 00 00
	00		 lea	 ecx, DWORD PTR [ebx+168]
  0007b	e8 00 00 00 00	 call	 ?AddPetItemExp@CItem@@QAEHH@Z ; CItem::AddPetItemExp
  00080	85 c0		 test	 eax, eax
  00082	0f 84 93 00 00
	00		 je	 $LN21@gObjSetExp

; 18023: 		{
; 18024: 			if(gObjIsItemPut(lpObj,&lpObj->pInventory[1],1) == 0)

  00088	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0008e	6a 01		 push	 1
  00090	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  00095	50		 push	 eax
  00096	56		 push	 esi
  00097	e8 00 00 00 00	 call	 ?gObjIsItemPut@@YAHPAUOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18025: 			{
; 18026: 				lpObj->pInventory[1].PetItemLevelDown(addexp);

  0009f	57		 push	 edi
  000a0	85 c0		 test	 eax, eax
  000a2	75 2f		 jne	 SHORT $LN15@gObjSetExp
  000a4	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  000aa	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  000b0	e8 00 00 00 00	 call	 ?PetItemLevelDown@CItem@@QAEHH@Z ; CItem::PetItemLevelDown

; 18027: 				MsgOutput(aIndex,lMsg.Get(1245));

  000b5	68 dd 04 00 00	 push	 1245			; 000004ddH
  000ba	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000bf	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000c7	50		 push	 eax
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000ce	83 c4 08	 add	 esp, 8

; 18028: 			}
; 18029: 			else

  000d1	eb 48		 jmp	 SHORT $LN21@gObjSetExp
$LN15@gObjSetExp:

; 18030: 			{
; 18031: 				LogAdd(LOG_BLACK, "[%s][%s][PetItemLevelUp] [%s] Level:[%d]Exp:[%d]AddExp:[%d]",
; 18032: 					lpObj->AccountID,lpObj->Name,lpObj->pInventory[1].GetName(),lpObj->pInventory[1].m_PetItem_Level,lpObj->pInventory[1].m_PetItem_Exp,addexp);

  000d3	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  000d9	8b 90 4c 01 00
	00		 mov	 edx, DWORD PTR [eax+332]
  000df	8b 88 48 01 00
	00		 mov	 ecx, DWORD PTR [eax+328]
  000e5	52		 push	 edx
  000e6	51		 push	 ecx
  000e7	8d 88 a8 00 00
	00		 lea	 ecx, DWORD PTR [eax+168]
  000ed	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000f2	50		 push	 eax
  000f3	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  000f6	52		 push	 edx
  000f7	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  000fa	50		 push	 eax
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5Le@
  00100	6a 00		 push	 0
  00102	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 18033: 				CDarkSpirit::SendLevelmsg(lpObj->m_Index,1,0,0xFE);

  00107	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00109	68 fe 00 00 00	 push	 254			; 000000feH
  0010e	6a 00		 push	 0
  00110	6a 01		 push	 1
  00112	51		 push	 ecx
  00113	e8 00 00 00 00	 call	 ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ; CDarkSpirit::SendLevelmsg
  00118	83 c4 30	 add	 esp, 48			; 00000030H
$LN21@gObjSetExp:

; 18034: 			}
; 18035: 		}
; 18036: 
; 18037: 		if(lpObj->pInventory[8].AddPetItemExp(addexp))

  0011b	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00121	57		 push	 edi
  00122	81 c1 40 05 00
	00		 add	 ecx, 1344		; 00000540H
  00128	e8 00 00 00 00	 call	 ?AddPetItemExp@CItem@@QAEHH@Z ; CItem::AddPetItemExp
  0012d	85 c0		 test	 eax, eax
  0012f	0f 84 45 02 00
	00		 je	 $LN22@gObjSetExp

; 18038: 		{
; 18039: 			if(gObjIsItemPut(lpObj,&lpObj->pInventory[8],8) == 0)

  00135	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR [esi+3212]
  0013b	6a 08		 push	 8
  0013d	81 c2 40 05 00
	00		 add	 edx, 1344		; 00000540H
  00143	52		 push	 edx
  00144	56		 push	 esi
  00145	e8 00 00 00 00	 call	 ?gObjIsItemPut@@YAHPAUOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
  0014a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18040: 			{
; 18041: 				lpObj->pInventory[8].PetItemLevelDown(addexp);

  0014d	57		 push	 edi
  0014e	85 c0		 test	 eax, eax
  00150	75 32		 jne	 SHORT $LN12@gObjSetExp
  00152	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00158	81 c1 40 05 00
	00		 add	 ecx, 1344		; 00000540H
  0015e	e8 00 00 00 00	 call	 ?PetItemLevelDown@CItem@@QAEHH@Z ; CItem::PetItemLevelDown

; 18042: 				MsgOutput(aIndex,lMsg.Get(1246));

  00163	68 de 04 00 00	 push	 1246			; 000004deH
  00168	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0016d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00172	50		 push	 eax
  00173	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0017c	83 c4 08	 add	 esp, 8
  0017f	5f		 pop	 edi
  00180	5b		 pop	 ebx
  00181	5e		 pop	 esi

; 18087: 			}
; 18088: 		}
; 18089: 	}
; 18090: }

  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
$LN12@gObjSetExp:

; 18043: 			}
; 18044: 			else
; 18045: 			{
; 18046: 				LogAdd(LOG_BLACK, "[%s][%s][PetItemLevelUp] [%s] Level:[%d]Exp:[%d]AddExp:[%d]",
; 18047: 					lpObj->AccountID,lpObj->Name,lpObj->pInventory[8].GetName(),lpObj->pInventory[8].m_PetItem_Level,lpObj->pInventory[8].m_PetItem_Exp,addexp);

  00184	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0018a	8b 88 e4 05 00
	00		 mov	 ecx, DWORD PTR [eax+1508]
  00190	8b 90 e0 05 00
	00		 mov	 edx, DWORD PTR [eax+1504]
  00196	51		 push	 ecx
  00197	52		 push	 edx
  00198	8d 88 40 05 00
	00		 lea	 ecx, DWORD PTR [eax+1344]
  0019e	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  001a3	50		 push	 eax
  001a4	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  001a7	50		 push	 eax
  001a8	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  001ab	51		 push	 ecx
  001ac	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5Le@
  001b1	6a 00		 push	 0
  001b3	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 18048: 				CDarkSpirit::SendLevelmsg(lpObj->m_Index,8,1,0xFE);

  001b8	8b 16		 mov	 edx, DWORD PTR [esi]
  001ba	68 fe 00 00 00	 push	 254			; 000000feH
  001bf	6a 01		 push	 1
  001c1	6a 08		 push	 8
  001c3	52		 push	 edx

; 18086: 				CDarkSpirit::SendLevelmsg(lpObj->m_Index,1,0,0xFE);

  001c4	e8 00 00 00 00	 call	 ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ; CDarkSpirit::SendLevelmsg
  001c9	83 c4 30	 add	 esp, 48			; 00000030H
  001cc	5f		 pop	 edi
  001cd	5b		 pop	 ebx
  001ce	5e		 pop	 esi

; 18087: 			}
; 18088: 		}
; 18089: 	}
; 18090: }

  001cf	5d		 pop	 ebp
  001d0	c3		 ret	 0
$LN17@gObjSetExp:

; 18049: 			}
; 18050: 		}
; 18051: 	}
; 18052: 	else if(lpObj->pInventory[8].m_Type == ITEMGET(13,4))

  001d1	ba 04 1a 00 00	 mov	 edx, 6660		; 00001a04H
  001d6	66 3b ca	 cmp	 cx, dx
  001d9	0f 85 c7 00 00
	00		 jne	 $LN9@gObjSetExp

; 18053: 	{
; 18054: 		int addexp = exp * 20 / 100;

  001df	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  001e2	03 c9		 add	 ecx, ecx
  001e4	03 c9		 add	 ecx, ecx
  001e6	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  001eb	f7 e9		 imul	 ecx
  001ed	c1 fa 05	 sar	 edx, 5
  001f0	8b fa		 mov	 edi, edx
  001f2	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  001f5	03 fa		 add	 edi, edx

; 18055: 
; 18056: 		if(lpObj->pInventory[8].AddPetItemExp(addexp))

  001f7	57		 push	 edi
  001f8	8d 8b 40 05 00
	00		 lea	 ecx, DWORD PTR [ebx+1344]
  001fe	e8 00 00 00 00	 call	 ?AddPetItemExp@CItem@@QAEHH@Z ; CItem::AddPetItemExp
  00203	85 c0		 test	 eax, eax
  00205	0f 84 6f 01 00
	00		 je	 $LN22@gObjSetExp

; 18057: 		{
; 18058: 			if(gObjIsItemPut(lpObj,&lpObj->pInventory[8],8) == 0)

  0020b	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00211	6a 08		 push	 8
  00213	05 40 05 00 00	 add	 eax, 1344		; 00000540H
  00218	50		 push	 eax
  00219	56		 push	 esi
  0021a	e8 00 00 00 00	 call	 ?gObjIsItemPut@@YAHPAUOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
  0021f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18059: 			{
; 18060: 				lpObj->pInventory[8].PetItemLevelDown(addexp);

  00222	57		 push	 edi
  00223	85 c0		 test	 eax, eax
  00225	75 32		 jne	 SHORT $LN7@gObjSetExp
  00227	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0022d	81 c1 40 05 00
	00		 add	 ecx, 1344		; 00000540H
  00233	e8 00 00 00 00	 call	 ?PetItemLevelDown@CItem@@QAEHH@Z ; CItem::PetItemLevelDown

; 18061: 				MsgOutput(aIndex,lMsg.Get(1246));

  00238	68 de 04 00 00	 push	 1246			; 000004deH
  0023d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00242	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00247	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0024a	50		 push	 eax
  0024b	51		 push	 ecx
  0024c	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00251	83 c4 08	 add	 esp, 8
  00254	5f		 pop	 edi
  00255	5b		 pop	 ebx
  00256	5e		 pop	 esi

; 18087: 			}
; 18088: 		}
; 18089: 	}
; 18090: }

  00257	5d		 pop	 ebp
  00258	c3		 ret	 0
$LN7@gObjSetExp:

; 18062: 			}
; 18063: 			else
; 18064: 			{
; 18065: 				LogAdd(LOG_BLACK, "[%s][%s][PetItemLevelUp] [%s] Level:[%d]Exp:[%d]AddExp:[%d]",
; 18066: 					lpObj->AccountID,lpObj->Name,lpObj->pInventory[8].GetName(),lpObj->pInventory[8].m_PetItem_Level,lpObj->pInventory[8].m_PetItem_Exp,addexp);

  00259	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0025f	8b 90 e4 05 00
	00		 mov	 edx, DWORD PTR [eax+1508]
  00265	8b 88 e0 05 00
	00		 mov	 ecx, DWORD PTR [eax+1504]
  0026b	52		 push	 edx
  0026c	51		 push	 ecx
  0026d	8d 88 40 05 00
	00		 lea	 ecx, DWORD PTR [eax+1344]
  00273	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00278	50		 push	 eax
  00279	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  0027c	52		 push	 edx
  0027d	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  00280	50		 push	 eax
  00281	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5Le@
  00286	6a 00		 push	 0
  00288	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 18086: 				CDarkSpirit::SendLevelmsg(lpObj->m_Index,1,0,0xFE);

  0028d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0028f	68 fe 00 00 00	 push	 254			; 000000feH
  00294	6a 01		 push	 1
  00296	6a 08		 push	 8
  00298	51		 push	 ecx
  00299	e8 00 00 00 00	 call	 ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ; CDarkSpirit::SendLevelmsg
  0029e	83 c4 30	 add	 esp, 48			; 00000030H
  002a1	5f		 pop	 edi
  002a2	5b		 pop	 ebx
  002a3	5e		 pop	 esi

; 18087: 			}
; 18088: 		}
; 18089: 	}
; 18090: }

  002a4	5d		 pop	 ebp
  002a5	c3		 ret	 0
$LN9@gObjSetExp:

; 18067: 				CDarkSpirit::SendLevelmsg(lpObj->m_Index,8,1,0xFE);
; 18068: 			}
; 18069: 		}
; 18070: 	}
; 18071: 	else if(lpObj->pInventory[1].m_Type == ITEMGET(13,5))

  002a6	ba 05 1a 00 00	 mov	 edx, 6661		; 00001a05H
  002ab	66 39 93 ae 00
	00 00		 cmp	 WORD PTR [ebx+174], dx
  002b2	0f 85 c2 00 00
	00		 jne	 $LN22@gObjSetExp

; 18072: 	{
; 18073: 		int addexp = exp * 20 / 100;

  002b8	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  002bb	03 c9		 add	 ecx, ecx
  002bd	03 c9		 add	 ecx, ecx
  002bf	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  002c4	f7 e9		 imul	 ecx
  002c6	c1 fa 05	 sar	 edx, 5
  002c9	8b fa		 mov	 edi, edx
  002cb	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  002ce	03 fa		 add	 edi, edx

; 18074: 
; 18075: 		if(lpObj->pInventory[1].AddPetItemExp(addexp))

  002d0	57		 push	 edi
  002d1	8d 8b a8 00 00
	00		 lea	 ecx, DWORD PTR [ebx+168]
  002d7	e8 00 00 00 00	 call	 ?AddPetItemExp@CItem@@QAEHH@Z ; CItem::AddPetItemExp
  002dc	85 c0		 test	 eax, eax
  002de	0f 84 96 00 00
	00		 je	 $LN22@gObjSetExp

; 18076: 		{
; 18077: 			if(gObjIsItemPut(lpObj,&lpObj->pInventory[1],1) == 0)

  002e4	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  002ea	6a 01		 push	 1
  002ec	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  002f1	50		 push	 eax
  002f2	56		 push	 esi
  002f3	e8 00 00 00 00	 call	 ?gObjIsItemPut@@YAHPAUOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
  002f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18078: 			{
; 18079: 				lpObj->pInventory[1].PetItemLevelDown(addexp);

  002fb	57		 push	 edi
  002fc	85 c0		 test	 eax, eax
  002fe	75 32		 jne	 SHORT $LN2@gObjSetExp
  00300	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00306	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  0030c	e8 00 00 00 00	 call	 ?PetItemLevelDown@CItem@@QAEHH@Z ; CItem::PetItemLevelDown

; 18080: 				MsgOutput(aIndex,lMsg.Get(1245));

  00311	68 dd 04 00 00	 push	 1245			; 000004ddH
  00316	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0031b	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00320	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00323	50		 push	 eax
  00324	51		 push	 ecx
  00325	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0032a	83 c4 08	 add	 esp, 8
  0032d	5f		 pop	 edi
  0032e	5b		 pop	 ebx
  0032f	5e		 pop	 esi

; 18087: 			}
; 18088: 		}
; 18089: 	}
; 18090: }

  00330	5d		 pop	 ebp
  00331	c3		 ret	 0
$LN2@gObjSetExp:

; 18081: 			}
; 18082: 			else
; 18083: 			{
; 18084: 				LogAdd(LOG_BLACK, "[%s][%s][PetItemLevelUp] [%s] Level:[%d]Exp:[%d]AddExp:[%d]",
; 18085: 					lpObj->AccountID,lpObj->Name,lpObj->pInventory[1].GetName(),lpObj->pInventory[1].m_PetItem_Level,lpObj->pInventory[1].m_PetItem_Exp,addexp);

  00332	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  00338	8b 90 4c 01 00
	00		 mov	 edx, DWORD PTR [eax+332]
  0033e	8b 88 48 01 00
	00		 mov	 ecx, DWORD PTR [eax+328]
  00344	52		 push	 edx
  00345	51		 push	 ecx
  00346	8d 88 a8 00 00
	00		 lea	 ecx, DWORD PTR [eax+168]
  0034c	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00351	50		 push	 eax
  00352	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  00355	52		 push	 edx
  00356	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  00359	50		 push	 eax
  0035a	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5Le@
  0035f	6a 00		 push	 0
  00361	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 18086: 				CDarkSpirit::SendLevelmsg(lpObj->m_Index,1,0,0xFE);

  00366	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00368	68 fe 00 00 00	 push	 254			; 000000feH
  0036d	6a 00		 push	 0
  0036f	6a 01		 push	 1
  00371	51		 push	 ecx
  00372	e8 00 00 00 00	 call	 ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ; CDarkSpirit::SendLevelmsg
  00377	83 c4 30	 add	 esp, 48			; 00000030H
$LN22@gObjSetExp:
  0037a	5f		 pop	 edi
  0037b	5b		 pop	 ebx
$LN1@gObjSetExp:
  0037c	5e		 pop	 esi

; 18087: 			}
; 18088: 		}
; 18089: 	}
; 18090: }

  0037d	5d		 pop	 ebp
  0037e	c3		 ret	 0
?gObjSetExpPetItem@@YAXHH@Z ENDP			; gObjSetExpPetItem
_TEXT	ENDS
PUBLIC	??_C@_0DE@GDMCBCLE@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5?$CI?5_count?5@ ; `string'
PUBLIC	??_C@_0DF@NOIKLNAL@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5gObjIsCon@ ; `string'
PUBLIC	?gObjSkillUseProcTime500@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSkillUseProcTime500
EXTRN	?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z:PROC	; CGUseItemRecv
EXTRN	?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z:PROC ; CObjUseSkill::RunningSkill
;	COMDAT ??_C@_0DE@GDMCBCLE@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5?$CI?5_count?5@
CONST	SEGMENT
??_C@_0DE@GDMCBCLE@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5?$CI?5_count?5@ DB 0a1H
	DB	0daH, '[CHECK_LOG_INFINITY] ( _count > 100 ) error %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NOIKLNAL@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5gObjIsCon@
CONST	SEGMENT
??_C@_0DF@NOIKLNAL@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5gObjIsCon@ DB 0a1H, 0daH
	DB	'[CHECK_LOG_INFINITY] gObjIsConnected() error %s %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjSkillUseProcTime500@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$161909 = -8					; size = 7
_pMsg$161902 = -8					; size = 6
tv291 = 8						; size = 4
tv276 = 8						; size = 4
_mana$161888 = 8					; size = 4
_lpObj$ = 8						; size = 4
?gObjSkillUseProcTime500@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjSkillUseProcTime500, COMDAT

; 318  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 319  : 	if ( lpObj->SkillHellFire2State != 0 )

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000a	80 be 50 0f 00
	00 00		 cmp	 BYTE PTR [esi+3920], 0
  00011	0f 84 f4 01 00
	00		 je	 $LN2@gObjSkillU@4

; 320  : 	{
; 321  : 		unsigned long dwCurrentTick = GetTickCount();

  00017	57		 push	 edi
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 322  : 		lpObj->SkillHellFire2Count = (dwCurrentTick - lpObj->SkillHellFire2Time) / 500;

  0001e	8b be 54 0f 00
	00		 mov	 edi, DWORD PTR [esi+3924]
  00024	8b c8		 mov	 ecx, eax
  00026	8b d1		 mov	 edx, ecx
  00028	2b d7		 sub	 edx, edi
  0002a	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0002f	f7 e2		 mul	 edx
  00031	c1 ea 05	 shr	 edx, 5
  00034	88 96 51 0f 00
	00		 mov	 BYTE PTR [esi+3921], dl

; 323  : 
; 324  : 		if ( lpObj->SkillHellFire2Count > 12 )

  0003a	80 fa 0c	 cmp	 dl, 12			; 0000000cH
  0003d	76 07		 jbe	 SHORT $LN15@gObjSkillU@4

; 325  : 		{
; 326  : 			lpObj->SkillHellFire2Count = 12;

  0003f	c6 86 51 0f 00
	00 0c		 mov	 BYTE PTR [esi+3921], 12	; 0000000cH
$LN15@gObjSkillU@4:

; 327  : 		}
; 328  : 
; 329  : 		if(dwCurrentTick >= (lpObj->SkillHellFire2Time + 6000))

  00046	81 c7 70 17 00
	00		 add	 edi, 6000		; 00001770H

; 330  : 		{
; 331  : 			CMagicInf * lpMagic = gObjGetMagicSearch(lpObj,0x28);

  0004c	6a 28		 push	 40			; 00000028H
  0004e	3b cf		 cmp	 ecx, edi
  00050	72 29		 jb	 SHORT $LN14@gObjSkillU@4
  00052	56		 push	 esi
  00053	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
  00058	83 c4 08	 add	 esp, 8

; 332  : 
; 333  : 			if(lpMagic != 0)

  0005b	85 c0		 test	 eax, eax
  0005d	0f 84 a7 01 00
	00		 je	 $LN25@gObjSkillU@4

; 334  : 			{
; 335  : 				gObjUseSkill.RunningSkill(lpObj->m_Index,0,lpMagic,0);

  00063	6a 00		 push	 0
  00065	50		 push	 eax
  00066	8b 06		 mov	 eax, DWORD PTR [esi]
  00068	6a 00		 push	 0
  0006a	50		 push	 eax
  0006b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00070	e8 00 00 00 00	 call	 ?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::RunningSkill
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 413  : 			}
; 414  : 		}
; 415  : 	}
; 416  : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN14@gObjSkillU@4:

; 336  : 			}
; 337  : 		}
; 338  : 		else
; 339  : 		{
; 340  : 			int mana = MagicDamageC.SkillGetMana(40);

  0007b	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00080	e8 00 00 00 00	 call	 ?SkillGetMana@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetMana

; 341  : 			mana = mana * 20 / 100;

  00085	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00088	03 c9		 add	 ecx, ecx
  0008a	03 c9		 add	 ecx, ecx
  0008c	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00091	f7 e9		 imul	 ecx
  00093	c1 fa 05	 sar	 edx, 5
  00096	8b ca		 mov	 ecx, edx
  00098	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0009b	03 ca		 add	 ecx, edx
  0009d	89 4d 08	 mov	 DWORD PTR _mana$161888[ebp], ecx

; 342  : 			BOOL bSuccess = TRUE;
; 343  : 
; 344  : 			if ( mana > lpObj->Mana )

  000a0	db 45 08	 fild	 DWORD PTR _mana$161888[ebp]
  000a3	d9 5d 08	 fstp	 DWORD PTR tv276[ebp]
  000a6	d9 45 08	 fld	 DWORD PTR tv276[ebp]
  000a9	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  000af	d8 d9		 fcomp	 ST(1)
  000b1	df e0		 fnstsw	 ax
  000b3	f6 c4 05	 test	 ah, 5
  000b6	0f 8a b6 00 00
	00		 jp	 $LN4@gObjSkillU@4

; 345  : 			{
; 346  : 				bSuccess = FALSE;
; 347  : 				int count = 0;
; 348  : 
; 349  : 				while ( true )
; 350  : 				{
; 351  : 					count++;
; 352  : 
; 353  : 					if ( gObjIsConnected(lpObj) == FALSE )

  000bc	56		 push	 esi
  000bd	dd d8		 fstp	 ST(0)
  000bf	bf 01 00 00 00	 mov	 edi, 1
  000c4	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000c9	83 c4 04	 add	 esp, 4
  000cc	85 c0		 test	 eax, eax
  000ce	74 4d		 je	 SHORT $LN20@gObjSkillU@4
$LL10@gObjSkillU@4:

; 357  : 					}
; 358  : 
; 359  : 					if ( count > 100 )

  000d0	83 ff 64	 cmp	 edi, 100		; 00000064H
  000d3	7f 59		 jg	 SHORT $LN21@gObjSkillU@4

; 362  : 						break;
; 363  : 					}
; 364  : 
; 365  : 					int pos = gObjGetManaItemPos(lpObj->m_Index);

  000d5	8b 16		 mov	 edx, DWORD PTR [esi]
  000d7	52		 push	 edx
  000d8	e8 00 00 00 00	 call	 ?gObjGetManaItemPos@@YAHH@Z ; gObjGetManaItemPos
  000dd	83 c4 04	 add	 esp, 4

; 366  : 
; 367  : 					if ( pos == -1 )

  000e0	83 f8 ff	 cmp	 eax, -1
  000e3	74 62		 je	 SHORT $LN24@gObjSkillU@4

; 368  : 					{
; 369  : 						break;
; 370  : 					}
; 371  : 
; 372  : 					PMSG_USEITEM pMsg;
; 373  : 					pMsg.inventoryPos = pos;

  000e5	88 45 fb	 mov	 BYTE PTR _pMsg$161902[ebp+3], al

; 374  : 					pMsg.invenrotyTarget = 0;
; 375  : 					CGUseItemRecv(&pMsg, lpObj->m_Index);

  000e8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ea	50		 push	 eax
  000eb	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$161902[ebp]
  000ee	51		 push	 ecx
  000ef	c6 45 fc 00	 mov	 BYTE PTR _pMsg$161902[ebp+4], 0
  000f3	e8 00 00 00 00	 call	 ?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z ; CGUseItemRecv

; 376  : 
; 377  : 					if ( mana <= lpObj->Mana )

  000f8	d9 45 08	 fld	 DWORD PTR tv276[ebp]
  000fb	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  00101	83 c4 08	 add	 esp, 8
  00104	d8 d9		 fcomp	 ST(1)
  00106	df e0		 fnstsw	 ax
  00108	f6 c4 01	 test	 ah, 1
  0010b	74 65		 je	 SHORT $LN4@gObjSkillU@4
  0010d	56		 push	 esi
  0010e	dd d8		 fstp	 ST(0)
  00110	47		 inc	 edi
  00111	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00116	83 c4 04	 add	 esp, 4
  00119	85 c0		 test	 eax, eax
  0011b	75 b3		 jne	 SHORT $LL10@gObjSkillU@4
$LN20@gObjSkillU@4:

; 354  : 					{
; 355  : 						LogAdd(LOG_BLACK, "[CHECK_LOG_INFINITY] gObjIsConnected() error %s %d", __FILE__, __LINE__);

  0011d	68 63 01 00 00	 push	 355			; 00000163H
  00122	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@NOIKLNAL@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5gObjIsCon@

; 356  : 						break;

  0012c	eb 0f		 jmp	 SHORT $LN34@gObjSkillU@4
$LN21@gObjSkillU@4:

; 360  : 					{
; 361  : 						LogAdd(LOG_BLACK, "[CHECK_LOG_INFINITY] ( _count > 100 ) error %s %d", __FILE__, __LINE__);

  0012e	68 69 01 00 00	 push	 361			; 00000169H
  00133	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00138	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@GDMCBCLE@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5?$CI?5_count?5@
$LN34@gObjSkillU@4:
  0013d	6a 00		 push	 0
  0013f	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00144	83 c4 10	 add	 esp, 16			; 00000010H
$LN24@gObjSkillU@4:

; 378  : 					{
; 379  : 						bSuccess = TRUE;
; 380  : 						break;
; 381  : 					}
; 382  : 				}
; 383  : 			}
; 384  : 			
; 385  : 			if ( bSuccess == FALSE )
; 386  : 			{
; 387  : 				CMagicInf * lpMagic = gObjGetMagicSearch(lpObj, 40);

  00147	6a 28		 push	 40			; 00000028H
  00149	56		 push	 esi
  0014a	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
  0014f	83 c4 08	 add	 esp, 8

; 388  : 				
; 389  : 				if (lpMagic != NULL )

  00152	85 c0		 test	 eax, eax
  00154	0f 84 b0 00 00
	00		 je	 $LN25@gObjSkillU@4

; 390  : 				{
; 391  : 					gObjUseSkill.RunningSkill(lpObj->m_Index, 0, lpMagic, 0);

  0015a	8b 16		 mov	 edx, DWORD PTR [esi]
  0015c	6a 00		 push	 0
  0015e	50		 push	 eax
  0015f	6a 00		 push	 0
  00161	52		 push	 edx
  00162	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00167	e8 00 00 00 00	 call	 ?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::RunningSkill
  0016c	5f		 pop	 edi
  0016d	5e		 pop	 esi

; 413  : 			}
; 414  : 		}
; 415  : 	}
; 416  : }

  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c3		 ret	 0
$LN4@gObjSkillU@4:

; 392  : 				}
; 393  : 			}
; 394  : 			else
; 395  : 			{
; 396  : 				lpObj->Mana -= mana;

  00172	d8 ae d0 00 00
	00		 fsubr	 DWORD PTR [esi+208]
  00178	d9 5d 08	 fstp	 DWORD PTR tv291[ebp]
  0017b	d9 45 08	 fld	 DWORD PTR tv291[ebp]
  0017e	d9 96 d0 00 00
	00		 fst	 DWORD PTR [esi+208]

; 397  : 
; 398  : 				if ( lpObj->Mana < 0.0f )

  00184	d9 ee		 fldz
  00186	d8 d1		 fcom	 ST(1)
  00188	df e0		 fnstsw	 ax
  0018a	dd d9		 fstp	 ST(1)
  0018c	f6 c4 41	 test	 ah, 65			; 00000041H
  0018f	75 08		 jne	 SHORT $LN30@gObjSkillU@4

; 399  : 				{
; 400  : 					lpObj->Mana = 0.0f;

  00191	d9 9e d0 00 00
	00		 fstp	 DWORD PTR [esi+208]
  00197	eb 02		 jmp	 SHORT $LN1@gObjSkillU@4
$LN30@gObjSkillU@4:
  00199	dd d8		 fstp	 ST(0)
$LN1@gObjSkillU@4:

; 401  : 				}
; 402  : 
; 403  : 				GCManaSend(lpObj->m_Index, lpObj->Mana, -1, 0, lpObj->BP);

  0019b	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR [esi+232]
  001a1	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  001a7	50		 push	 eax
  001a8	6a 00		 push	 0
  001aa	68 ff 00 00 00	 push	 255			; 000000ffH
  001af	e8 00 00 00 00	 call	 __ftol2_sse
  001b4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001b6	50		 push	 eax
  001b7	51		 push	 ecx
  001b8	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend

; 404  : 				PMSG_EX_SKILL_COUNT pMsg;
; 405  : 				PHeadSetB( (LPBYTE)&pMsg, 0xBA, sizeof(pMsg));

  001bd	6a 07		 push	 7
  001bf	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$161909[ebp]
  001c2	68 ba 00 00 00	 push	 186			; 000000baH
  001c7	52		 push	 edx
  001c8	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 406  : 				pMsg.Type = 0x28;
; 407  : 				pMsg.Count = lpObj->SkillHellFire2Count;

  001cd	8a 86 51 0f 00
	00		 mov	 al, BYTE PTR [esi+3921]
  001d3	88 45 fe	 mov	 BYTE PTR _pMsg$161909[ebp+6], al

; 408  : 				pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  001d6	8b 06		 mov	 eax, DWORD PTR [esi]
  001d8	8b c8		 mov	 ecx, eax
  001da	c1 e9 08	 shr	 ecx, 8
  001dd	88 4d fb	 mov	 BYTE PTR _pMsg$161909[ebp+3], cl

; 409  : 				pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 410  : 
; 411  : 				DataSend(lpObj->m_Index, (UCHAR *)&pMsg, pMsg.h.size);

  001e0	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$161909[ebp+1]
  001e4	8a d0		 mov	 dl, al
  001e6	88 55 fc	 mov	 BYTE PTR _pMsg$161909[ebp+4], dl
  001e9	51		 push	 ecx
  001ea	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$161909[ebp]
  001ed	52		 push	 edx
  001ee	50		 push	 eax
  001ef	c6 45 fd 28	 mov	 BYTE PTR _pMsg$161909[ebp+5], 40 ; 00000028H
  001f3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 412  : 				MsgSendV2(lpObj, (UCHAR *)&pMsg, pMsg.h.size);

  001f8	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$161909[ebp+1]
  001fc	50		 push	 eax
  001fd	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$161909[ebp]
  00200	51		 push	 ecx
  00201	56		 push	 esi
  00202	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00207	83 c4 38	 add	 esp, 56			; 00000038H
$LN25@gObjSkillU@4:
  0020a	5f		 pop	 edi
$LN2@gObjSkillU@4:
  0020b	5e		 pop	 esi

; 413  : 			}
; 414  : 		}
; 415  : 	}
; 416  : }

  0020c	8b e5		 mov	 esp, ebp
  0020e	5d		 pop	 ebp
  0020f	c3		 ret	 0
?gObjSkillUseProcTime500@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjSkillUseProcTime500
_TEXT	ENDS
PUBLIC	?gObjEnd@@YAXXZ					; gObjEnd
EXTRN	__imp__DeleteCriticalSection@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?gObjEnd@@YAXXZ
_TEXT	SEGMENT
?gObjEnd@@YAXXZ PROC					; gObjEnd, COMDAT

; 679  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 680  : 	gObjAllDisconnect();

  00003	e8 00 00 00 00	 call	 ?gObjAllDisconnect@@YAXXZ ; gObjAllDisconnect

; 681  : 	gObjAllLogOut();

  00008	e8 00 00 00 00	 call	 ?gObjAllLogOut@@YAXXZ	; gObjAllLogOut
  0000d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DeleteCriticalSection@4

; 682  : 
; 683  : 	for ( int n=0; n< OBJMAX; n++)

  00013	33 ff		 xor	 edi, edi
  00015	be 9c 0c 00 00	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+3228
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL23@gObjEnd:

; 684  : 	{
; 685  : 		if ( gObj[n].m_lpMagicBack != NULL )

  00020	8b 8e 98 f6 ff
	ff		 mov	 ecx, DWORD PTR [esi-2408]
  00026	85 c9		 test	 ecx, ecx
  00028	74 1c		 je	 SHORT $LN18@gObjEnd

; 686  : 		{
; 687  : 			delete [] gObj[n].m_lpMagicBack;

  0002a	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  0002e	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00031	74 0a		 je	 SHORT $LN17@gObjEnd
  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	8b 10		 mov	 edx, DWORD PTR [eax]
  00037	6a 03		 push	 3
  00039	ff d2		 call	 edx
  0003b	eb 09		 jmp	 SHORT $LN18@gObjEnd
$LN17@gObjEnd:
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00043	83 c4 04	 add	 esp, 4
$LN18@gObjEnd:

; 688  : 		}
; 689  : 
; 690  : 		if ( n >= OBJ_STARTUSERINDEX )

  00046	81 ff 00 19 00
	00		 cmp	 edi, 6400		; 00001900H
  0004c	0f 8c 92 00 00
	00		 jl	 $LN1@gObjEnd

; 691  : 		{
; 692  : 			if ( gObj[n].Inventory1 != NULL )

  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	85 c0		 test	 eax, eax
  00056	74 09		 je	 SHORT $LN9@gObjEnd

; 693  : 			{
; 694  : 				delete gObj[n].Inventory1;

  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005e	83 c4 04	 add	 esp, 4
$LN9@gObjEnd:

; 695  : 			}
; 696  : 
; 697  : 			if ( gObj[n].Inventory2 != NULL )

  00061	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00064	85 c0		 test	 eax, eax
  00066	74 09		 je	 SHORT $LN8@gObjEnd

; 698  : 			{
; 699  : 				delete gObj[n].Inventory2;

  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006e	83 c4 04	 add	 esp, 4
$LN8@gObjEnd:

; 700  : 			}
; 701  : 
; 702  : 			if ( gObj[n].InventoryMap1 != NULL )

  00071	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00074	85 c0		 test	 eax, eax
  00076	74 09		 je	 SHORT $LN7@gObjEnd

; 703  : 			{
; 704  : 				delete gObj[n].InventoryMap1;

  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007e	83 c4 04	 add	 esp, 4
$LN7@gObjEnd:

; 705  : 			}
; 706  : 
; 707  : 			if ( gObj[n].InventoryMap2 != NULL )

  00081	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00084	85 c0		 test	 eax, eax
  00086	74 09		 je	 SHORT $LN6@gObjEnd

; 708  : 			{
; 709  : 				delete gObj[n].InventoryMap2;

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008e	83 c4 04	 add	 esp, 4
$LN6@gObjEnd:

; 710  : 			}
; 711  : 
; 712  : 			if ( gObj[n].PerSocketContext != NULL )

  00091	8b 86 70 f3 ff
	ff		 mov	 eax, DWORD PTR [esi-3216]
  00097	85 c0		 test	 eax, eax
  00099	74 09		 je	 SHORT $LN5@gObjEnd

; 713  : 			{
; 714  : 				delete gObj[n].PerSocketContext;

  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a1	83 c4 04	 add	 esp, 4
$LN5@gObjEnd:

; 715  : 			}
; 716  : 
; 717  : 			if ( gObj[n].Trade != NULL )

  000a4	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000a7	85 c0		 test	 eax, eax
  000a9	74 09		 je	 SHORT $LN4@gObjEnd

; 718  : 			{
; 719  : 				delete gObj[n].Trade;

  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b1	83 c4 04	 add	 esp, 4
$LN4@gObjEnd:

; 720  : 			}
; 721  : 
; 722  : 			if ( gObj[n].TradeMap != NULL )

  000b4	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000b7	85 c0		 test	 eax, eax
  000b9	74 09		 je	 SHORT $LN3@gObjEnd

; 723  : 			{
; 724  : 				delete gObj[n].TradeMap;

  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c1	83 c4 04	 add	 esp, 4
$LN3@gObjEnd:

; 725  : 			}
; 726  : 
; 727  : 			if ( gObj[n].pWarehouse != NULL )

  000c4	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000c7	85 c0		 test	 eax, eax
  000c9	74 09		 je	 SHORT $LN2@gObjEnd

; 728  : 			{
; 729  : 				delete gObj[n].pWarehouse;

  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d1	83 c4 04	 add	 esp, 4
$LN2@gObjEnd:

; 730  : 			}
; 731  : 
; 732  : 			if ( gObj[n].pWarehouseMap != NULL )

  000d4	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000d7	85 c0		 test	 eax, eax
  000d9	74 09		 je	 SHORT $LN1@gObjEnd

; 733  : 			{
; 734  : 				delete gObj[n].pWarehouseMap;

  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e1	83 c4 04	 add	 esp, 4
$LN1@gObjEnd:

; 735  : 			}
; 736  : 		}
; 737  : 
; 738  : 		DeleteCriticalSection( &gObj[n].m_critPShopTrade );

  000e4	8d 86 c8 00 00
	00		 lea	 eax, DWORD PTR [esi+200]
  000ea	50		 push	 eax
  000eb	ff d3		 call	 ebx
  000ed	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  000f3	47		 inc	 edi
  000f4	81 fe 3c 5f 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40525628
  000fa	0f 8c 20 ff ff
	ff		 jl	 $LL23@gObjEnd

; 739  : 	}
; 740  : }

  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	c3		 ret	 0
?gObjEnd@@YAXXZ ENDP					; gObjEnd
_TEXT	ENDS
PUBLIC	??_C@_0GK@NPPGCJHE@error?9L2?5?3?5Unknown?5Item?5found?5?$FL?$CF@ ; `string'
PUBLIC	__real@437f0000
PUBLIC	_ItemDbByte$GSCopy$
PUBLIC	_lpMsg$GSCopy$
PUBLIC	_lpObj$GSCopy$
PUBLIC	_bAllItemExist$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?DbItemSetInByte@@YAXPAUOBJECTSTRUCT@@PAUSDHP_DBCHAR_INFORESULT@@HPA_N@Z ; DbItemSetInByte
EXTRN	?gObjRequestPetItemInfo@@YAXHH@Z:PROC		; gObjRequestPetItemInfo
EXTRN	?IsItem@@YAHH@Z:PROC				; IsItem
;	COMDAT ??_C@_0GK@NPPGCJHE@error?9L2?5?3?5Unknown?5Item?5found?5?$FL?$CF@
CONST	SEGMENT
??_C@_0GK@NPPGCJHE@error?9L2?5?3?5Unknown?5Item?5found?5?$FL?$CF@ DB 'err'
	DB	'or-L2 : Unknown Item found [%s][%s] (Type:%d, LEV:%d, DUR:%d '
	DB	'OP1:%d, OP2:%d, OP3:%d, NEWOP:%d, SET:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DbItemSetInByte@@YAXPAUOBJECTSTRUCT@@PAUSDHP_DBCHAR_INFORESULT@@HPA_N@Z
_TEXT	SEGMENT
_bAllItemExist$GSCopy$ = -212				; size = 4
tv1558 = -208						; size = 4
_lpMsg$GSCopy$ = -204					; size = 4
tv1380 = -200						; size = 4
_n$ = -196						; size = 4
tv1382 = -192						; size = 4
_ItemDbByte$GSCopy$ = -188				; size = 4
_lpObj$GSCopy$ = -184					; size = 4
tv950 = -180						; size = 4
_bIsItemExist$ = -173					; size = 1
_item$ = -172						; size = 168
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
_ItemDbByte$ = 16					; size = 4
_bAllItemExist$ = 20					; size = 4
?DbItemSetInByte@@YAXPAUOBJECTSTRUCT@@PAUSDHP_DBCHAR_INFORESULT@@HPA_N@Z PROC ; DbItemSetInByte, COMDAT

; 1347 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1559 : 			}
; 1560 : 		}
; 1561 : 	}
; 1562 : 	// ---
; 1563 : 	gObjRequestPetItemInfo(lpObj->m_Index, 0);

  00013	8b 4d 14	 mov	 ecx, DWORD PTR _bAllItemExist$[ebp]
  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	8b 75 10	 mov	 esi, DWORD PTR _ItemDbByte$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00022	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _bAllItemExist$GSCopy$[ebp], ecx
  00028	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0002e	89 85 48 ff ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$[ebp], eax
  00034	89 bd 34 ff ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], edi
  0003a	89 b5 44 ff ff
	ff		 mov	 DWORD PTR _ItemDbByte$GSCopy$[ebp], esi
  00040	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  00045	33 c0		 xor	 eax, eax
  00047	8d 5f 40	 lea	 ebx, DWORD PTR [edi+64]
  0004a	83 c7 47	 add	 edi, 71			; 00000047H
  0004d	89 85 3c ff ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
  00053	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv950[ebp], eax
  00059	89 bd 38 ff ff
	ff		 mov	 DWORD PTR tv1380[ebp], edi
  0005f	89 bd 40 ff ff
	ff		 mov	 DWORD PTR tv1382[ebp], edi
  00065	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL63@DbItemSetI:

; 1362 : 	{
; 1363 : 		bIsItemExist = true;
; 1364 : 		// ---
; 1365 : 		lpObj->pInventory[n].Clear();

  00070	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$GSCopy$[ebp]
  00076	8b 8a 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edx+3212]
  0007c	03 8d 4c ff ff
	ff		 add	 ecx, DWORD PTR tv950[ebp]
  00082	c6 85 53 ff ff
	ff 01		 mov	 BYTE PTR _bIsItemExist$[ebp], 1
  00089	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 1366 : 		// ---
; 1367 : 		itype = lpMsg->dbInventory[n*ItemDbByte];

  0008e	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00090	0f b6 f9	 movzx	 edi, cl

; 1368 : 		// ---
; 1369 : 		if(ItemDbByte >= 16)

  00093	83 fe 10	 cmp	 esi, 16			; 00000010H
  00096	7c 14		 jl	 SHORT $LN45@DbItemSetI

; 1370 : 		{
; 1371 : 			if(lpMsg->dbInventory[n*ItemDbByte] == 0xFF
; 1372 : 				&& (lpMsg->dbInventory[n*ItemDbByte+DBI_NOPTION_DATA] & 0x80) == 0x80
; 1373 : 				&& (lpMsg->dbInventory[n*ItemDbByte+DBI_OPTION380_DATA] & 0xF0) == 0xF0)

  00098	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  0009b	75 2e		 jne	 SHORT $LN55@DbItemSetI
  0009d	f6 43 07 80	 test	 BYTE PTR [ebx+7], 128	; 00000080H
  000a1	74 28		 je	 SHORT $LN55@DbItemSetI
  000a3	8a 43 09	 mov	 al, BYTE PTR [ebx+9]
  000a6	24 f0		 and	 al, 240			; 000000f0H
  000a8	3c f0		 cmp	 al, 240			; 000000f0H

; 1374 : 			{
; 1375 : 				continue;
; 1376 : 			}
; 1377 : 		}

  000aa	eb 19		 jmp	 SHORT $LN72@DbItemSetI
$LN45@DbItemSetI:

; 1378 : 		else if(ItemDbByte > 7)

  000ac	83 fe 07	 cmp	 esi, 7
  000af	7e 11		 jle	 SHORT $LN42@DbItemSetI

; 1379 : 		{
; 1380 : 			if(lpMsg->dbInventory[n*ItemDbByte] == 0xFF && (lpMsg->dbInventory[n*ItemDbByte+DBI_NOPTION_DATA] & 0x80) == 0x80)

  000b1	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  000b4	75 15		 jne	 SHORT $LN55@DbItemSetI
  000b6	f6 43 07 80	 test	 BYTE PTR [ebx+7], 128	; 00000080H
  000ba	0f 85 8c 03 00
	00		 jne	 $LN47@DbItemSetI

; 1381 : 			{
; 1382 : 				continue;
; 1383 : 			}
; 1384 : 		}
; 1385 : 		else

  000c0	eb 09		 jmp	 SHORT $LN55@DbItemSetI
$LN42@DbItemSetI:

; 1386 : 		{
; 1387 : 			if(lpMsg->dbInventory[n*ItemDbByte+DBI_TYPE] == 0xFF)

  000c2	80 f9 ff	 cmp	 cl, 255			; 000000ffH
$LN72@DbItemSetI:
  000c5	0f 84 81 03 00
	00		 je	 $LN47@DbItemSetI
$LN55@DbItemSetI:

; 1388 : 			{
; 1389 : 				continue;
; 1390 : 			}
; 1391 : 		}
; 1392 : 		// ---
; 1393 : 		if(ItemDbByte == 16)

  000cb	83 fe 10	 cmp	 esi, 16			; 00000010H
  000ce	75 25		 jne	 SHORT $LN38@DbItemSetI

; 1394 : 		{
; 1395 : 			itype |= (lpMsg->dbInventory[n*ItemDbByte+DBI_OPTION380_DATA] & 0xF0) * 32;
; 1396 : 			// ---
; 1397 : 			itype |= (lpMsg->dbInventory[n*ItemDbByte+DBI_NOPTION_DATA] & 0x80) * 2;

  000d0	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv1382[ebp]
  000d6	0f b6 50 02	 movzx	 edx, BYTE PTR [eax+2]
  000da	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000dd	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  000e3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000e8	c1 e2 05	 shl	 edx, 5
  000eb	03 c0		 add	 eax, eax
  000ed	0b d0		 or	 edx, eax
  000ef	0b fa		 or	 edi, edx

; 1398 : 			// ---
; 1399 : 			_type = itype;

  000f1	8b f7		 mov	 esi, edi
  000f3	eb 62		 jmp	 SHORT $LN53@DbItemSetI
$LN38@DbItemSetI:

; 1400 : 		}
; 1401 : 		else if(ItemDbByte == 10)

  000f5	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  000f8	75 32		 jne	 SHORT $LN36@DbItemSetI

; 1402 : 		{
; 1403 : 			if((lpMsg->dbInventory[n*ItemDbByte+DBI_NOPTION_DATA] & 0x80) == 0x80)

  000fa	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR tv1380[ebp]
  00100	f6 02 80	 test	 BYTE PTR [edx], 128	; 00000080H
  00103	74 06		 je	 SHORT $LN56@DbItemSetI

; 1404 : 			{
; 1405 : 				itype += 256;

  00105	81 c7 00 01 00
	00		 add	 edi, 256		; 00000100H
$LN56@DbItemSetI:

; 1406 : 			}
; 1407 : 			// ---
; 1408 : 			_type = ((itype / 32) * 512) + itype % 32;

  0010b	8b c7		 mov	 eax, edi
  0010d	99		 cdq
  0010e	83 e2 1f	 and	 edx, 31			; 0000001fH
  00111	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]
  00114	c1 fe 05	 sar	 esi, 5
  00117	8b c7		 mov	 eax, edi
  00119	c1 e6 09	 shl	 esi, 9
  0011c	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00121	79 05		 jns	 SHORT $LN70@DbItemSetI
  00123	48		 dec	 eax
  00124	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00127	40		 inc	 eax
$LN70@DbItemSetI:
  00128	03 f0		 add	 esi, eax

; 1409 : 		}
; 1410 : 		else

  0012a	eb 44		 jmp	 SHORT $LN54@DbItemSetI
$LN36@DbItemSetI:

; 1411 : 		{
; 1412 : 			_type = ((itype / 16) * 512) + itype % 16;

  0012c	8b c7		 mov	 eax, edi
  0012e	99		 cdq
  0012f	83 e2 0f	 and	 edx, 15			; 0000000fH
  00132	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]
  00135	c1 fe 04	 sar	 esi, 4
  00138	8b d7		 mov	 edx, edi
  0013a	c1 e6 09	 shl	 esi, 9
  0013d	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00143	79 05		 jns	 SHORT $LN71@DbItemSetI
  00145	4a		 dec	 edx
  00146	83 ca f0	 or	 edx, -16		; fffffff0H
  00149	42		 inc	 edx
$LN71@DbItemSetI:

; 1413 : 		}
; 1414 : 		// ---
; 1415 : 		if(ItemDbByte >= 16)

  0014a	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _ItemDbByte$GSCopy$[ebp]
  00150	03 f2		 add	 esi, edx
  00152	83 f8 10	 cmp	 eax, 16			; 00000010H
  00155	7c 14		 jl	 SHORT $LN33@DbItemSetI
$LN53@DbItemSetI:

; 1416 : 		{
; 1417 : 			if(lpMsg->dbInventory[n*ItemDbByte] == 0xFF
; 1418 : 				&& (lpMsg->dbInventory[n*ItemDbByte+DBI_NOPTION_DATA] & 0x80) == 0x80
; 1419 : 				&& (lpMsg->dbInventory[n*ItemDbByte+DBI_OPTION380_DATA] & 0xF0) == 0xF0)

  00157	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  0015a	75 29		 jne	 SHORT $LN57@DbItemSetI
  0015c	f6 43 07 80	 test	 BYTE PTR [ebx+7], 128	; 00000080H
  00160	74 23		 je	 SHORT $LN57@DbItemSetI
  00162	8a 43 09	 mov	 al, BYTE PTR [ebx+9]
  00165	24 f0		 and	 al, 240			; 000000f0H
  00167	3c f0		 cmp	 al, 240			; 000000f0H

; 1420 : 			{
; 1421 : 				itype = -1;
; 1422 : 			}
; 1423 : 		}

  00169	eb 15		 jmp	 SHORT $LN73@DbItemSetI
$LN33@DbItemSetI:

; 1424 : 		else if(ItemDbByte >= 10)

  0016b	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0016e	7c 0d		 jl	 SHORT $LN30@DbItemSetI
$LN54@DbItemSetI:

; 1425 : 		{
; 1426 : 			if(lpMsg->dbInventory[n*ItemDbByte] == 0xFF && (lpMsg->dbInventory[n*ItemDbByte+DBI_NOPTION_DATA] & 0x80) == 0x80)

  00170	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  00173	75 10		 jne	 SHORT $LN57@DbItemSetI
  00175	f6 43 07 80	 test	 BYTE PTR [ebx+7], 128	; 00000080H
  00179	74 0a		 je	 SHORT $LN57@DbItemSetI

; 1427 : 			{
; 1428 : 				itype = -1;
; 1429 : 			}
; 1430 : 		}
; 1431 : 		else

  0017b	eb 05		 jmp	 SHORT $LN74@DbItemSetI
$LN30@DbItemSetI:

; 1432 : 		{
; 1433 : 			if(lpMsg->dbInventory[n*ItemDbByte+DBI_TYPE] == 0xFF)

  0017d	80 f9 ff	 cmp	 cl, 255			; 000000ffH
$LN73@DbItemSetI:
  00180	75 03		 jne	 SHORT $LN57@DbItemSetI
$LN74@DbItemSetI:

; 1434 : 			{
; 1435 : 				itype = -1;

  00182	83 cf ff	 or	 edi, -1
$LN57@DbItemSetI:

; 1436 : 			}
; 1437 : 		}
; 1438 : 		// ---
; 1439 : 		if(IsItem(_type) == false)

  00185	56		 push	 esi
  00186	e8 00 00 00 00	 call	 ?IsItem@@YAHH@Z		; IsItem
  0018b	83 c4 04	 add	 esp, 4
  0018e	85 c0		 test	 eax, eax
  00190	75 13		 jne	 SHORT $LN25@DbItemSetI

; 1440 : 		{
; 1441 : 			bIsItemExist = 0;

  00192	88 85 53 ff ff
	ff		 mov	 BYTE PTR _bIsItemExist$[ebp], al

; 1442 : 			// ---
; 1443 : 			if(bAllItemExist != 0)

  00198	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _bAllItemExist$GSCopy$[ebp]
  0019e	85 c0		 test	 eax, eax
  001a0	74 03		 je	 SHORT $LN25@DbItemSetI

; 1444 : 			{
; 1445 : 				*bAllItemExist = 0;

  001a2	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN25@DbItemSetI:

; 1446 : 			}
; 1447 : 		}
; 1448 : 		// ---
; 1449 : 		if(_type == ITEMGET(14,17) || _type == ITEMGET(14,18))

  001a5	81 fe 11 1c 00
	00		 cmp	 esi, 7185		; 00001c11H
  001ab	74 08		 je	 SHORT $LN23@DbItemSetI
  001ad	81 fe 12 1c 00
	00		 cmp	 esi, 7186		; 00001c12H
  001b3	75 09		 jne	 SHORT $LN61@DbItemSetI
$LN23@DbItemSetI:

; 1450 : 		{
; 1451 : 			if(lpMsg->dbInventory[n*ItemDbByte+DBI_DUR]==0)

  001b5	80 7b 02 00	 cmp	 BYTE PTR [ebx+2], 0
  001b9	75 03		 jne	 SHORT $LN61@DbItemSetI

; 1452 : 			{
; 1453 : 				itype = -1;

  001bb	83 cf ff	 or	 edi, -1
$LN61@DbItemSetI:

; 1454 : 			}
; 1455 : 		}
; 1456 : 		// ---
; 1457 : 		if(_type == ITEMGET(14,19))

  001be	81 fe 13 1c 00
	00		 cmp	 esi, 7187		; 00001c13H
  001c4	75 0a		 jne	 SHORT $LN20@DbItemSetI

; 1458 : 		{
; 1459 : 			if(lpMsg->dbInventory[n*ItemDbByte+DBI_DUR]==(BYTE)-1)

  001c6	80 7b 02 ff	 cmp	 BYTE PTR [ebx+2], 255	; 000000ffH

; 1460 : 			{
; 1461 : 				itype = -1;
; 1462 : 			}
; 1463 : 		}
; 1464 : 		// ---
; 1465 : 		if(itype != -1)

  001ca	0f 84 76 02 00
	00		 je	 $LN62@DbItemSetI
$LN20@DbItemSetI:
  001d0	83 ff ff	 cmp	 edi, -1
  001d3	0f 84 6d 02 00
	00		 je	 $LN62@DbItemSetI

; 1466 : 		{
; 1467 : 			item.m_Level = DBI_GET_LEVEL(lpMsg->dbInventory[n*ItemDbByte+DBI_OPTION_DATA]);

  001d9	8a 43 01	 mov	 al, BYTE PTR [ebx+1]

; 1468 : 			// ---
; 1469 : 			if(lpMsg->DbVersion < 2)

  001dc	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  001e2	8a c8		 mov	 cl, al
  001e4	c0 e9 03	 shr	 cl, 3
  001e7	80 e1 0f	 and	 cl, 15			; 0000000fH
  001ea	80 ba c5 07 00
	00 02		 cmp	 BYTE PTR [edx+1989], 2
  001f1	0f b6 c9	 movzx	 ecx, cl
  001f4	66 89 8d 5c ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], cx
  001fb	73 06		 jae	 SHORT $LN18@DbItemSetI

; 1470 : 			{
; 1471 : 				lpMsg->dbInventory[n*ItemDbByte+DBI_SOPTION_DATA] = -1;

  001fd	66 c7 43 08 ff
	ff		 mov	 WORD PTR [ebx+8], 65535	; 0000ffffH
$LN18@DbItemSetI:

; 1472 : 				lpMsg->dbInventory[n*ItemDbByte+DBI_OPTION380_DATA] = -1;
; 1473 : 			}
; 1474 : 			// ---
; 1475 : 			if(_type != ITEMGET(14,11))

  00203	81 fe 0b 1c 00
	00		 cmp	 esi, 7179		; 00001c0bH
  00209	74 0f		 je	 SHORT $LN16@DbItemSetI

; 1476 : 			{
; 1477 : 				if(item.m_Level > MAX_ITEM_LEVEL)

  0020b	66 83 f9 0f	 cmp	 cx, 15			; 0000000fH
  0020f	7e 09		 jle	 SHORT $LN16@DbItemSetI

; 1478 : 				{
; 1479 : 					item.m_Level = 0;

  00211	33 c9		 xor	 ecx, ecx
  00213	66 89 8d 5c ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], cx
$LN16@DbItemSetI:

; 1480 : 				}
; 1481 : 			}
; 1482 : 			// ---
; 1483 : 			OptionData = lpMsg->dbInventory[n*ItemDbByte+DBI_OPTION_DATA];
; 1484 : 			// ---
; 1485 : 			item.m_Option1 = ( ((OptionData) >> 7) & 0x01);

  0021a	8a d0		 mov	 dl, al

; 1486 : 			item.m_Option2 = DBI_GET_LUCK(OptionData);

  0021c	8a c8		 mov	 cl, al

; 1487 : 			item.m_Option3 = DBI_GET_OPTION(OptionData);

  0021e	24 03		 and	 al, 3
  00220	c0 e9 02	 shr	 cl, 2
  00223	88 45 ce	 mov	 BYTE PTR _item$[ebp+122], al

; 1488 : 			// ---
; 1489 : 			if(ItemDbByte >= 10)

  00226	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _ItemDbByte$GSCopy$[ebp]
  0022c	c0 ea 07	 shr	 dl, 7
  0022f	80 e1 01	 and	 cl, 1
  00232	88 55 cc	 mov	 BYTE PTR _item$[ebp+120], dl
  00235	88 4d cd	 mov	 BYTE PTR _item$[ebp+121], cl
  00238	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0023b	7c 0c		 jl	 SHORT $LN15@DbItemSetI

; 1490 : 			{
; 1491 : 				item.m_Option3 |= DBI_GET_OPTION16(lpMsg->dbInventory[n*ItemDbByte+7]) >> 4;

  0023d	8a 53 07	 mov	 dl, BYTE PTR [ebx+7]
  00240	c0 ea 04	 shr	 dl, 4
  00243	80 e2 04	 and	 dl, 4
  00246	08 55 ce	 or	 BYTE PTR _item$[ebp+122], dl
$LN15@DbItemSetI:

; 1492 : 			}
; 1493 : 			// ---
; 1494 : 			item.m_Durability = lpMsg->dbInventory[n*ItemDbByte+DBI_DUR];

  00249	0f b6 4b 02	 movzx	 ecx, BYTE PTR [ebx+2]
  0024d	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv1558[ebp], ecx
  00253	db 85 30 ff ff
	ff		 fild	 DWORD PTR tv1558[ebp]
  00259	d9 9d 78 ff ff
	ff		 fstp	 DWORD PTR _item$[ebp+36]

; 1495 : 			// ---
; 1496 : 			if(ItemDbByte == 7)

  0025f	83 f8 07	 cmp	 eax, 7
  00262	75 0a		 jne	 SHORT $LN14@DbItemSetI

; 1497 : 			{
; 1498 : 				item.Convert(itype,item.m_Option1,item.m_Option2,item.m_Option3,0,0,0,0);

  00264	6a 00		 push	 0
  00266	6a 00		 push	 0
  00268	6a 00		 push	 0
  0026a	6a 00		 push	 0
  0026c	eb 1b		 jmp	 SHORT $LN75@DbItemSetI
$LN14@DbItemSetI:

; 1499 : 			}
; 1500 : 			else if(ItemDbByte <= 10)
; 1501 : 			{
; 1502 : 				item.Convert(itype,item.m_Option1,item.m_Option2,item.m_Option3,DBI_GET_NOPTION(lpMsg->dbInventory[n*ItemDbByte+DBI_NOPTION_DATA]),lpMsg->dbInventory[n*ItemDbByte+DBI_SOPTION_DATA], 0, 1);

  0026e	0f b6 53 08	 movzx	 edx, BYTE PTR [ebx+8]
  00272	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00275	8a 43 07	 mov	 al, BYTE PTR [ebx+7]
  00278	7f 04		 jg	 SHORT $LN12@DbItemSetI
  0027a	6a 01		 push	 1

; 1503 : 			}
; 1504 : 			else

  0027c	eb 02		 jmp	 SHORT $LN76@DbItemSetI
$LN12@DbItemSetI:

; 1505 : 			{
; 1506 : 				item.Convert(itype,item.m_Option1,item.m_Option2,item.m_Option3,DBI_GET_NOPTION(lpMsg->dbInventory[n*ItemDbByte+DBI_NOPTION_DATA]),lpMsg->dbInventory[n*ItemDbByte+DBI_SOPTION_DATA], 0, 3);

  0027e	6a 03		 push	 3
$LN76@DbItemSetI:
  00280	24 3f		 and	 al, 63			; 0000003fH
  00282	6a 00		 push	 0
  00284	0f b6 c8	 movzx	 ecx, al
  00287	52		 push	 edx
  00288	51		 push	 ecx
$LN75@DbItemSetI:
  00289	8b 55 ce	 mov	 edx, DWORD PTR _item$[ebp+122]
  0028c	8b 45 cd	 mov	 eax, DWORD PTR _item$[ebp+121]
  0028f	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp+120]
  00292	52		 push	 edx
  00293	50		 push	 eax
  00294	51		 push	 ecx
  00295	57		 push	 edi
  00296	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0029c	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEE@Z ; CItem::Convert

; 1507 : 			}
; 1508 : 			// ---
; 1509 : 			if(_type == ITEMGET(14,7))

  002a1	81 fe 07 1c 00
	00		 cmp	 esi, 7175		; 00001c07H
  002a7	0f 84 8e 00 00
	00		 je	 $LN2@DbItemSetI

; 1510 : 			{
; 1511 : 				/* */
; 1512 : 			}
; 1513 : 			else
; 1514 : 			{
; 1515 : 				if(_type >= ITEMGET(14,0) && _type <= ITEMGET(14,8))

  002ad	8d 96 00 e4 ff
	ff		 lea	 edx, DWORD PTR [esi-7168]
  002b3	83 fa 08	 cmp	 edx, 8
  002b6	77 3a		 ja	 SHORT $LN8@DbItemSetI

; 1516 : 				{
; 1517 : 					if(item.m_Durability == 0.0f)

  002b8	d9 85 78 ff ff
	ff		 fld	 DWORD PTR _item$[ebp+36]
  002be	d9 ee		 fldz
  002c0	da e9		 fucompp
  002c2	df e0		 fnstsw	 ax
  002c4	f6 c4 44	 test	 ah, 68			; 00000044H
  002c7	7a 08		 jp	 SHORT $LN7@DbItemSetI

; 1518 : 					{
; 1519 : 						item.m_Durability = 1.0f;

  002c9	d9 e8		 fld1
  002cb	d9 9d 78 ff ff
	ff		 fstp	 DWORD PTR _item$[ebp+36]
$LN7@DbItemSetI:

; 1520 : 					}
; 1521 : 					// ---
; 1522 : 					if(item.m_Durability > 255.0f)

  002d1	d9 85 78 ff ff
	ff		 fld	 DWORD PTR _item$[ebp+36]
  002d7	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@406fe00000000000
  002dd	df e0		 fnstsw	 ax
  002df	f6 c4 41	 test	 ah, 65			; 00000041H
  002e2	75 57		 jne	 SHORT $LN2@DbItemSetI

; 1523 : 					{
; 1524 : 						item.m_Durability = 255.0f;

  002e4	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@437f0000
  002ea	d9 9d 78 ff ff
	ff		 fstp	 DWORD PTR _item$[ebp+36]

; 1525 : 					}
; 1526 : 				}

  002f0	eb 49		 jmp	 SHORT $LN2@DbItemSetI
$LN8@DbItemSetI:

; 1527 : 				else if(_type != ITEMGET(13,10) && _type != ITEMGET(14,29) && _type != ITEMGET(14,21))

  002f2	81 fe 0a 1a 00
	00		 cmp	 esi, 6666		; 00001a0aH
  002f8	74 41		 je	 SHORT $LN2@DbItemSetI
  002fa	81 fe 1d 1c 00
	00		 cmp	 esi, 7197		; 00001c1dH
  00300	74 39		 je	 SHORT $LN2@DbItemSetI
  00302	81 fe 15 1c 00
	00		 cmp	 esi, 7189		; 00001c15H
  00308	74 31		 je	 SHORT $LN2@DbItemSetI

; 1528 : 				{
; 1529 : 					if(item.m_Level == 3)

  0030a	66 83 bd 5c ff
	ff ff 03	 cmp	 WORD PTR _item$[ebp+8], 3
  00312	75 27		 jne	 SHORT $LN2@DbItemSetI

; 1530 : 					{
; 1531 : 						if(item.m_Durability > item.m_BaseDurability && bIsItemExist == 1)

  00314	d9 85 78 ff ff
	ff		 fld	 DWORD PTR _item$[ebp+36]
  0031a	d9 45 80	 fld	 DWORD PTR _item$[ebp+44]
  0031d	d8 d1		 fcom	 ST(1)
  0031f	df e0		 fnstsw	 ax
  00321	dd d9		 fstp	 ST(1)
  00323	f6 c4 05	 test	 ah, 5
  00326	7a 11		 jp	 SHORT $LN68@DbItemSetI
  00328	80 bd 53 ff ff
	ff 01		 cmp	 BYTE PTR _bIsItemExist$[ebp], 1
  0032f	75 08		 jne	 SHORT $LN68@DbItemSetI

; 1532 : 						{
; 1533 : 							item.m_Durability = item.m_BaseDurability;

  00331	d9 9d 78 ff ff
	ff		 fstp	 DWORD PTR _item$[ebp+36]
  00337	eb 02		 jmp	 SHORT $LN2@DbItemSetI
$LN68@DbItemSetI:

; 1530 : 					{
; 1531 : 						if(item.m_Durability > item.m_BaseDurability && bIsItemExist == 1)

  00339	dd d8		 fstp	 ST(0)
$LN2@DbItemSetI:

; 1534 : 						}
; 1535 : 					}
; 1536 : 				}
; 1537 : 			}
; 1538 : 			// ---
; 1539 : 			lpObj->pInventory[n].m_Option1 = item.m_Option1;

  0033b	0f b6 55 cc	 movzx	 edx, BYTE PTR _item$[ebp+120]
  0033f	8b b5 48 ff ff
	ff		 mov	 esi, DWORD PTR _lpObj$GSCopy$[ebp]
  00345	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0034b	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv950[ebp]
  00351	88 54 08 78	 mov	 BYTE PTR [eax+ecx+120], dl

; 1540 : 			lpObj->pInventory[n].m_Option2 = item.m_Option2;

  00355	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  0035b	0f b6 55 cd	 movzx	 edx, BYTE PTR _item$[ebp+121]
  0035f	88 54 08 79	 mov	 BYTE PTR [eax+ecx+121], dl

; 1541 : 			lpObj->pInventory[n].m_Option3 = item.m_Option3;

  00363	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00369	0f b6 55 ce	 movzx	 edx, BYTE PTR _item$[ebp+122]
  0036d	88 54 08 7a	 mov	 BYTE PTR [eax+ecx+122], dl

; 1542 : 			// ---
; 1543 : 			hiWord = ((lpMsg->dbInventory[n*ItemDbByte+DBI_SERIAL2])&0xFF)&0xFF | (((lpMsg->dbInventory[n*ItemDbByte+DBI_SERIAL1])&0xFF)&0xFF) * 256;
; 1544 : 			loWord = ((lpMsg->dbInventory[n*ItemDbByte+DBI_SERIAL4])&0xFF)&0xFF | (((lpMsg->dbInventory[n*ItemDbByte+DBI_SERIAL3])&0xFF)&0xFF) * 256;
; 1545 : 			// ---
; 1546 : 			item.m_Number = ((loWord &0xFFFF)&0xFFFF) | ((hiWord & 0xFFFF)&0xFFFF) << 16;

  00371	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  00375	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0037a	66 0f af c1	 imul	 ax, cx
  0037e	0f b6 4b 05	 movzx	 ecx, BYTE PTR [ebx+5]
  00382	0f b7 d0	 movzx	 edx, ax
  00385	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00389	0b d0		 or	 edx, eax
  0038b	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00390	66 0f af c8	 imul	 cx, ax
  00394	0f b6 43 06	 movzx	 eax, BYTE PTR [ebx+6]
  00398	0f b7 c9	 movzx	 ecx, cx
  0039b	c1 e2 10	 shl	 edx, 16			; 00000010H
  0039e	0b d1		 or	 edx, ecx

; 1547 : 			// ---
; 1548 : 			gObjInventoryInsertItemPos(lpObj->m_Index,item,n,0);

  003a0	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  003a6	0b d0		 or	 edx, eax
  003a8	6a 00		 push	 0
  003aa	51		 push	 ecx
  003ab	89 95 54 ff ff
	ff		 mov	 DWORD PTR _item$[ebp], edx
  003b1	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$GSCopy$[ebp]
  003b7	8b 02		 mov	 eax, DWORD PTR [edx]
  003b9	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  003bf	8b fc		 mov	 edi, esp
  003c1	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  003c6	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  003cc	50		 push	 eax
  003cd	f3 a5		 rep movsd
  003cf	e8 00 00 00 00	 call	 ?gObjInventoryInsertItemPos@@YAEHVCItem@@HH@Z ; gObjInventoryInsertItemPos
  003d4	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H

; 1549 : 			// ---
; 1550 : 			if(bIsItemExist == false)

  003da	80 bd 53 ff ff
	ff 00		 cmp	 BYTE PTR _bIsItemExist$[ebp], 0
  003e1	75 63		 jne	 SHORT $LN62@DbItemSetI

; 1551 : 			{
; 1552 : 				lpObj->pInventory[n].m_bItemExist = 0;

  003e3	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$GSCopy$[ebp]
  003e9	8b 90 8c 0c 00
	00		 mov	 edx, DWORD PTR [eax+3212]
  003ef	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv950[ebp]
  003f5	c6 44 11 6c 00	 mov	 BYTE PTR [ecx+edx+108], 0

; 1553 : 				// ---
; 1554 : 				LogAdd(LOG_BLACK, "error-L2 : Unknown Item found [%s][%s] (Type:%d, LEV:%d, DUR:%d OP1:%d, OP2:%d, OP3:%d, NEWOP:%d, SET:%d)",
; 1555 : 					lpObj->AccountID,lpObj->Name,lpObj->pInventory[n].m_Type,lpObj->pInventory[n].m_Level,
; 1556 : 					lpObj->pInventory[n].m_Durability,lpObj->pInventory[n].m_Option1,
; 1557 : 					lpObj->pInventory[n].m_Option2,lpObj->pInventory[n].m_Option3,
; 1558 : 					lpObj->pInventory[n].m_NewOption,lpObj->pInventory[n].m_SetOption);

  003fa	03 88 8c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3212]
  00400	0f b6 91 92 00
	00 00		 movzx	 edx, BYTE PTR [ecx+146]
  00407	d9 41 24	 fld	 DWORD PTR [ecx+36]
  0040a	52		 push	 edx
  0040b	0f b6 51 7b	 movzx	 edx, BYTE PTR [ecx+123]
  0040f	52		 push	 edx
  00410	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  00414	52		 push	 edx
  00415	0f b6 51 79	 movzx	 edx, BYTE PTR [ecx+121]
  00419	52		 push	 edx
  0041a	0f b6 51 78	 movzx	 edx, BYTE PTR [ecx+120]
  0041e	52		 push	 edx
  0041f	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00423	0f bf 49 06	 movsx	 ecx, WORD PTR [ecx+6]
  00427	83 ec 08	 sub	 esp, 8
  0042a	dd 1c 24	 fstp	 QWORD PTR [esp]
  0042d	52		 push	 edx
  0042e	51		 push	 ecx
  0042f	8d 50 6f	 lea	 edx, DWORD PTR [eax+111]
  00432	52		 push	 edx
  00433	83 c0 64	 add	 eax, 100		; 00000064H
  00436	50		 push	 eax
  00437	68 00 00 00 00	 push	 OFFSET ??_C@_0GK@NPPGCJHE@error?9L2?5?3?5Unknown?5Item?5found?5?$FL?$CF@
  0043c	6a 00		 push	 0
  0043e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00443	83 c4 34	 add	 esp, 52			; 00000034H
$LN62@DbItemSetI:
  00446	8b b5 44 ff ff
	ff		 mov	 esi, DWORD PTR _ItemDbByte$GSCopy$[ebp]
$LN47@DbItemSetI:

; 1348 : 	int n;
; 1349 : 	int itype;
; 1350 : 	int _type;
; 1351 : 	// ---
; 1352 : 	CItem item;
; 1353 : 	// ---
; 1354 : 	BYTE OptionData;
; 1355 : 	// ---
; 1356 : 	WORD hiWord;
; 1357 : 	WORD loWord;
; 1358 : 	// ---
; 1359 : 	bool bIsItemExist = true;
; 1360 : 	// ---
; 1361 : 	for (n = 0; n < INVENTORY_SIZE; n++)

  0044c	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv950[ebp]
  00452	ff 85 3c ff ff
	ff		 inc	 DWORD PTR _n$[ebp]
  00458	83 85 40 ff ff
	ff 10		 add	 DWORD PTR tv1382[ebp], 16 ; 00000010H
  0045f	83 85 38 ff ff
	ff 0a		 add	 DWORD PTR tv1380[ebp], 10 ; 0000000aH
  00466	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  0046b	03 de		 add	 ebx, esi
  0046d	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv950[ebp], eax
  00473	3d e0 46 00 00	 cmp	 eax, 18144		; 000046e0H
  00478	0f 8c f2 fb ff
	ff		 jl	 $LL63@DbItemSetI

; 1559 : 			}
; 1560 : 		}
; 1561 : 	}
; 1562 : 	// ---
; 1563 : 	gObjRequestPetItemInfo(lpObj->m_Index, 0);

  0047e	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$GSCopy$[ebp]
  00484	8b 08		 mov	 ecx, DWORD PTR [eax]
  00486	6a 00		 push	 0
  00488	51		 push	 ecx
  00489	e8 00 00 00 00	 call	 ?gObjRequestPetItemInfo@@YAXHH@Z ; gObjRequestPetItemInfo

; 1564 : }

  0048e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00491	83 c4 08	 add	 esp, 8
  00494	5f		 pop	 edi
  00495	5e		 pop	 esi
  00496	33 cd		 xor	 ecx, ebp
  00498	5b		 pop	 ebx
  00499	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0049e	8b e5		 mov	 esp, ebp
  004a0	5d		 pop	 ebp
  004a1	c3		 ret	 0
?DbItemSetInByte@@YAXPAUOBJECTSTRUCT@@PAUSDHP_DBCHAR_INFORESULT@@HPA_N@Z ENDP ; DbItemSetInByte
_TEXT	ENDS
PUBLIC	??_C@_0BO@HDDGJDLK@SkyLand?5Boss?5Shield?5Setting?$CB?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BP@GCONPPCF@SkyLand?5Boss?5Monster?5Setting?$CB?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BF@DGECBEHF@?C?$LF?$LA?x?$LK?$LI?$LN?$LK?$LI?w?5?$LM?$LD?A?$KE?5?$LN?G?F?P?$AA@ ; `string'
PUBLIC	?gObjSetMonster@@YAHHH@Z			; gObjSetMonster
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?gBSGround@@3PAPAVCBattleSoccer@@A:DWORD	; gBSGround
;	COMDAT ??_C@_0BO@HDDGJDLK@SkyLand?5Boss?5Shield?5Setting?$CB?$CB?$AA@
CONST	SEGMENT
??_C@_0BO@HDDGJDLK@SkyLand?5Boss?5Shield?5Setting?$CB?$CB?$AA@ DB 'SkyLan'
	DB	'd Boss Shield Setting!!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GCONPPCF@SkyLand?5Boss?5Monster?5Setting?$CB?$CB?$AA@
CONST	SEGMENT
??_C@_0BP@GCONPPCF@SkyLand?5Boss?5Monster?5Setting?$CB?$CB?$AA@ DB 'SkyLa'
	DB	'nd Boss Monster Setting!!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DGECBEHF@?C?$LF?$LA?x?$LK?$LI?$LN?$LK?$LI?w?5?$LM?$LD?A?$KE?5?$LN?G?F?P?$AA@
CONST	SEGMENT
??_C@_0BF@DGECBEHF@?C?$LF?$LA?x?$LK?$LI?$LN?$LK?$LI?w?5?$LM?$LD?A?$KE?5?$LN?G?F?P?$AA@ DB 0c3H
	DB	0b5H, 0b0H, 0f8H, 0baH, 0b8H, 0bdH, 0baH, 0b8H, 0f7H, ' ', 0bcH
	DB	0b3H, 0c1H, 0a4H, ' ', 0bdH, 0c7H, 0c6H, 0d0H, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjSetMonster@@YAHHH@Z
_TEXT	SEGMENT
tv643 = -4						; size = 4
_aIndex$ = 8						; size = 4
_MonsterClass$ = 12					; size = 4
?gObjSetMonster@@YAHHH@Z PROC				; gObjSetMonster, COMDAT

; 2417 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2418 : 	int Level;
; 2419 : 	LPOBJ lpObj;
; 2420 : 
; 2421 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00004	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00007	85 c0		 test	 eax, eax
  00009	78 10		 js	 SHORT $LN57@gObjSetMon
  0000b	33 c9		 xor	 ecx, ecx
  0000d	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00012	0f 9e c1	 setle	 cl
  00015	8b c1		 mov	 eax, ecx
  00017	85 c0		 test	 eax, eax
  00019	75 1f		 jne	 SHORT $LN52@gObjSetMon
$LN57@gObjSetMon:

; 2422 : 	{
; 2423 : 		LogAdd(LOG_BLACK, "error : %s %d", __FILE__, __LINE__);

  0001b	68 77 09 00 00	 push	 2423			; 00000977H
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  0002a	6a 00		 push	 0
  0002c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 2424 : 		return false;

  00034	33 c0		 xor	 eax, eax

; 2708 : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN52@gObjSetMon:
  0003a	53		 push	 ebx

; 2425 : 	}
; 2426 : 
; 2427 : 	lpObj = &gObj[aIndex];

  0003b	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0003e	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  00044	56		 push	 esi
  00045	57		 push	 edi
  00046	89 5d fc	 mov	 DWORD PTR tv643[ebp], ebx
  00049	8d b3 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx]

; 2428 : 	lpObj->ConnectCheckTime = GetTickCount();

  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 2429 : 	lpObj->ShopNumber = -1;
; 2430 : 	lpObj->TargetNumber = -1;
; 2431 : 	lpObj->m_RecallMon = -1;
; 2432 : 
; 2433 : 	switch ( MonsterClass )	// Switch COMPLETE REVIEWED (JPN-GSn-1.00.18)

  00055	8b 7d 0c	 mov	 edi, DWORD PTR _MonsterClass$[ebp]
  00058	83 ca ff	 or	 edx, -1
  0005b	89 46 34	 mov	 DWORD PTR [esi+52], eax
  0005e	0b c2		 or	 eax, edx
  00060	66 89 86 d4 02
	00 00		 mov	 WORD PTR [esi+724], ax
  00067	8d 87 38 ff ff
	ff		 lea	 eax, DWORD PTR [edi-200]
  0006d	66 89 96 d8 02
	00 00		 mov	 WORD PTR [esi+728], dx
  00074	89 96 cc 02 00
	00		 mov	 DWORD PTR [esi+716], edx
  0007a	3d aa 00 00 00	 cmp	 eax, 170		; 000000aaH
  0007f	0f 87 fe 00 00
	00		 ja	 $LN59@gObjSetMon
  00085	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN58@gObjSetMon[eax]
  0008c	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN69@gObjSetMon[ecx*4]
$LN49@gObjSetMon:

; 2434 : 	{
; 2435 : 		case 200:
; 2436 : 			gBSGround[0]->m_BallIndex = aIndex;

  00093	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gBSGround@@3PAPAVCBattleSoccer@@A ; gBSGround
  00099	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0009c	89 42 64	 mov	 DWORD PTR [edx+100], eax

; 2437 : 			break;

  0009f	e9 df 00 00 00	 jmp	 $LN59@gObjSetMon
$LN48@gObjSetMon:

; 2438 : 
; 2439 : 		case 251:
; 2440 : 			lpObj->ShopNumber = 0;

  000a4	33 c9		 xor	 ecx, ecx
  000a6	66 89 8e d8 02
	00 00		 mov	 WORD PTR [esi+728], cx

; 2441 : 			break;

  000ad	e9 d1 00 00 00	 jmp	 $LN59@gObjSetMon
$LN47@gObjSetMon:

; 2442 : 
; 2443 : 		case 255:
; 2444 : 			lpObj->ShopNumber = 1;

  000b2	ba 01 00 00 00	 mov	 edx, 1
  000b7	66 89 96 d8 02
	00 00		 mov	 WORD PTR [esi+728], dx

; 2445 : 			break;

  000be	e9 c0 00 00 00	 jmp	 $LN59@gObjSetMon
$LN46@gObjSetMon:

; 2446 : 
; 2447 : 		case 254:
; 2448 : 			lpObj->ShopNumber = 2;

  000c3	b8 02 00 00 00	 mov	 eax, 2

; 2449 : 			break;

  000c8	e9 af 00 00 00	 jmp	 $LN65@gObjSetMon
$LN45@gObjSetMon:

; 2450 : 
; 2451 : 		case 250:
; 2452 : 			lpObj->ShopNumber = 3;

  000cd	b9 03 00 00 00	 mov	 ecx, 3
  000d2	66 89 8e d8 02
	00 00		 mov	 WORD PTR [esi+728], cx

; 2453 : 			break;

  000d9	e9 a5 00 00 00	 jmp	 $LN59@gObjSetMon
$LN44@gObjSetMon:

; 2454 : 
; 2455 : 		case 248:
; 2456 : 		//case 253:
; 2457 : 			lpObj->ShopNumber = 4;

  000de	ba 04 00 00 00	 mov	 edx, 4
  000e3	66 89 96 d8 02
	00 00		 mov	 WORD PTR [esi+728], dx

; 2458 : 			break;

  000ea	e9 94 00 00 00	 jmp	 $LN59@gObjSetMon
$LN43@gObjSetMon:

; 2459 : 
; 2460 : 		case 239:
; 2461 : 		case 253:
; 2462 : 			lpObj->ShopNumber = 5;

  000ef	b8 05 00 00 00	 mov	 eax, 5

; 2463 : 			break;

  000f4	e9 83 00 00 00	 jmp	 $LN65@gObjSetMon
$LN42@gObjSetMon:

; 2464 : 
; 2465 : 		case 244:
; 2466 : 			lpObj->ShopNumber = 6;

  000f9	b9 06 00 00 00	 mov	 ecx, 6
  000fe	66 89 8e d8 02
	00 00		 mov	 WORD PTR [esi+728], cx

; 2467 : 			break;

  00105	eb 7c		 jmp	 SHORT $LN59@gObjSetMon
$LN41@gObjSetMon:

; 2468 : 
; 2469 : 		case 245:
; 2470 : 			lpObj->ShopNumber = 7;

  00107	ba 07 00 00 00	 mov	 edx, 7
  0010c	66 89 96 d8 02
	00 00		 mov	 WORD PTR [esi+728], dx

; 2471 : 			break;

  00113	eb 6e		 jmp	 SHORT $LN59@gObjSetMon
$LN40@gObjSetMon:

; 2472 : 
; 2473 : 		case 246:
; 2474 : 			lpObj->ShopNumber = 8;

  00115	b8 08 00 00 00	 mov	 eax, 8

; 2475 : 			break;

  0011a	eb 60		 jmp	 SHORT $LN65@gObjSetMon
$LN39@gObjSetMon:

; 2476 : 
; 2477 : 		case 243:
; 2478 : 			lpObj->ShopNumber = 9;

  0011c	b9 09 00 00 00	 mov	 ecx, 9
  00121	66 89 8e d8 02
	00 00		 mov	 WORD PTR [esi+728], cx

; 2479 : 			break;

  00128	eb 59		 jmp	 SHORT $LN59@gObjSetMon
$LN38@gObjSetMon:

; 2480 : 
; 2481 : 		case 242:
; 2482 : 			lpObj->ShopNumber = 10;

  0012a	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
  0012f	66 89 96 d8 02
	00 00		 mov	 WORD PTR [esi+728], dx

; 2483 : 			break;

  00136	eb 4b		 jmp	 SHORT $LN59@gObjSetMon
$LN37@gObjSetMon:

; 2484 : 
; 2485 : 		case 231:
; 2486 : 			lpObj->ShopNumber = 12;

  00138	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH

; 2487 : 			break;

  0013d	eb 3d		 jmp	 SHORT $LN65@gObjSetMon
$LN36@gObjSetMon:

; 2488 : 
; 2489 : 		case 230:
; 2490 : 			lpObj->ShopNumber = 11;

  0013f	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00144	66 89 8e d8 02
	00 00		 mov	 WORD PTR [esi+728], cx

; 2491 : 			break;

  0014b	eb 36		 jmp	 SHORT $LN59@gObjSetMon
$LN35@gObjSetMon:

; 2492 : 
; 2493 : 		case 240:
; 2494 : 			lpObj->ShopNumber = 100;

  0014d	ba 64 00 00 00	 mov	 edx, 100		; 00000064H

; 2504 : 		case 259:
; 2505 : 			lpObj->ShopNumber = 5;

  00152	66 89 96 d8 02
	00 00		 mov	 WORD PTR [esi+728], dx

; 2506 : 			break;

  00159	eb 28		 jmp	 SHORT $LN59@gObjSetMon
$LN33@gObjSetMon:

; 2495 : 			break;
; 2496 : 
; 2497 : 		case 238:
; 2498 : 			lpObj->ShopNumber = 101;
; 2499 : 			break;
; 2500 : 
; 2501 : 		case 236:
; 2502 : 			lpObj->ShopNumber = 102;

  0015b	b9 66 00 00 00	 mov	 ecx, 102		; 00000066H
  00160	66 89 8e d8 02
	00 00		 mov	 WORD PTR [esi+728], cx

; 2503 : 			break;

  00167	eb 1a		 jmp	 SHORT $LN59@gObjSetMon
$LN32@gObjSetMon:

; 2504 : 		case 259:
; 2505 : 			lpObj->ShopNumber = 5;

  00169	ba 05 00 00 00	 mov	 edx, 5
  0016e	66 89 96 d8 02
	00 00		 mov	 WORD PTR [esi+728], dx

; 2506 : 			break;

  00175	eb 0c		 jmp	 SHORT $LN59@gObjSetMon
$LN31@gObjSetMon:

; 2507 : 		case 368:
; 2508 : 		case 369:
; 2509 : 		case 370:
; 2510 : 			lpObj->ShopNumber = 101;

  00177	b8 65 00 00 00	 mov	 eax, 101		; 00000065H
$LN65@gObjSetMon:
  0017c	66 89 86 d8 02
	00 00		 mov	 WORD PTR [esi+728], ax
$LN59@gObjSetMon:

; 2511 : 			break;
; 2512 : 	}
; 2513 : 
; 2514 : 	lpObj->Connected = PLAYER_PLAYING;

  00183	c6 46 04 03	 mov	 BYTE PTR [esi+4], 3

; 2515 : 	lpObj->Live = FALSE;

  00187	c6 46 62 00	 mov	 BYTE PTR [esi+98], 0

; 2516 : 	lpObj->m_State = 0;

  0018b	c7 86 bc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+444], 0

; 2517 : 
; 2518 : 	if ( MonsterClass == 44 || MonsterClass == 54 || MonsterClass == 53 || lpObj->Class == 55 || lpObj->Class == 56 || MonsterClass == 76 || MonsterClass == 78 || MonsterClass == 79 || MonsterClass == 80 || MonsterClass == 81 ||	MonsterClass == 82 || MonsterClass == 83 )

  00195	83 ff 2c	 cmp	 edi, 44			; 0000002cH
  00198	74 4c		 je	 SHORT $LN29@gObjSetMon
  0019a	83 ff 36	 cmp	 edi, 54			; 00000036H
  0019d	74 47		 je	 SHORT $LN29@gObjSetMon
  0019f	83 ff 35	 cmp	 edi, 53			; 00000035H
  001a2	74 42		 je	 SHORT $LN29@gObjSetMon
  001a4	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  001ab	83 f8 37	 cmp	 eax, 55			; 00000037H
  001ae	74 36		 je	 SHORT $LN29@gObjSetMon
  001b0	83 f8 38	 cmp	 eax, 56			; 00000038H
  001b3	74 31		 je	 SHORT $LN29@gObjSetMon
  001b5	83 ff 4c	 cmp	 edi, 76			; 0000004cH
  001b8	74 2c		 je	 SHORT $LN29@gObjSetMon
  001ba	83 ff 4e	 cmp	 edi, 78			; 0000004eH
  001bd	74 27		 je	 SHORT $LN29@gObjSetMon
  001bf	83 ff 4f	 cmp	 edi, 79			; 0000004fH
  001c2	74 22		 je	 SHORT $LN29@gObjSetMon
  001c4	83 ff 50	 cmp	 edi, 80			; 00000050H
  001c7	74 1d		 je	 SHORT $LN29@gObjSetMon
  001c9	83 ff 51	 cmp	 edi, 81			; 00000051H
  001cc	74 18		 je	 SHORT $LN29@gObjSetMon
  001ce	83 ff 52	 cmp	 edi, 82			; 00000052H
  001d1	74 13		 je	 SHORT $LN29@gObjSetMon
  001d3	83 ff 53	 cmp	 edi, 83			; 00000053H
  001d6	74 0e		 je	 SHORT $LN29@gObjSetMon

; 2519 : 	{
; 2520 : 
; 2521 : 	}
; 2522 : 	else
; 2523 : 	{
; 2524 : 		lpObj->Live = TRUE;

  001d8	c6 46 62 01	 mov	 BYTE PTR [esi+98], 1

; 2525 : 		lpObj->m_State = 1;

  001dc	c7 86 bc 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+444], 1
$LN29@gObjSetMon:

; 2526 : 	}
; 2527 : 
; 2528 : 	if ( MonsterClass >= 204 && MonsterClass <= 259
; 2529 : 		|| MonsterClass >= 368 && MonsterClass <= 370
; 2530 : #if(GS_CASTLE==0)
; 2531 : 		|| MonsterClass == 367
; 2532 : #endif
; 2533 : 		|| MonsterClass == 375 )

  001e6	81 ff cc 00 00
	00		 cmp	 edi, 204		; 000000ccH
  001ec	7c 08		 jl	 SHORT $LN25@gObjSetMon
  001ee	81 ff 03 01 00
	00		 cmp	 edi, 259		; 00000103H
  001f4	7e 2b		 jle	 SHORT $LN26@gObjSetMon
$LN25@gObjSetMon:
  001f6	81 ff 70 01 00
	00		 cmp	 edi, 368		; 00000170H
  001fc	7c 08		 jl	 SHORT $LN24@gObjSetMon
  001fe	81 ff 72 01 00
	00		 cmp	 edi, 370		; 00000172H
  00204	7e 1b		 jle	 SHORT $LN26@gObjSetMon
$LN24@gObjSetMon:
  00206	81 ff 6f 01 00
	00		 cmp	 edi, 367		; 0000016fH
  0020c	74 13		 je	 SHORT $LN26@gObjSetMon
  0020e	81 ff 77 01 00
	00		 cmp	 edi, 375		; 00000177H
  00214	74 0b		 je	 SHORT $LN26@gObjSetMon

; 2536 : 	}
; 2537 : 	else
; 2538 : 	{
; 2539 : 		lpObj->Type = OBJ_MONSTER;

  00216	b9 02 00 00 00	 mov	 ecx, 2
  0021b	66 89 4e 60	 mov	 WORD PTR [esi+96], cx
  0021f	eb 09		 jmp	 SHORT $LN23@gObjSetMon
$LN26@gObjSetMon:

; 2534 : 	{
; 2535 : 		lpObj->Type = OBJ_NPC;

  00221	ba 03 00 00 00	 mov	 edx, 3
  00226	66 89 56 60	 mov	 WORD PTR [esi+96], dx
$LN23@gObjSetMon:

; 2540 : 	}
; 2541 : 
; 2542 : 	if ( MonsterClass == 77 )

  0022a	83 ff 4d	 cmp	 edi, 77			; 0000004dH
  0022d	75 4d		 jne	 SHORT $LN19@gObjSetMon

; 2543 : 	{
; 2544 : 		int iSL = gObjAddMonster(MAP_INDEX_ICARUS);

  0022f	6a 0a		 push	 10			; 0000000aH
  00231	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00236	0f bf d8	 movsx	 ebx, ax
  00239	83 c4 04	 add	 esp, 4

; 2545 : 
; 2546 : 		if ( iSL >= 0 )

  0023c	85 db		 test	 ebx, ebx
  0023e	78 0f		 js	 SHORT $LN21@gObjSetMon

; 2547 : 		{
; 2548 : 			if ( gObjSetMonster(iSL, 76) == FALSE )

  00240	6a 4c		 push	 76			; 0000004cH
  00242	53		 push	 ebx
  00243	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  00248	83 c4 08	 add	 esp, 8
  0024b	85 c0		 test	 eax, eax
  0024d	75 16		 jne	 SHORT $LN20@gObjSetMon
$LN21@gObjSetMon:

; 2549 : 			{
; 2550 : 				MsgBox("  ");

  0024f	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@DGECBEHF@?C?$LF?$LA?x?$LK?$LI?$LN?$LK?$LI?w?5?$LM?$LD?A?$KE?5?$LN?G?F?P?$AA@
  00254	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00259	83 c4 04	 add	 esp, 4
  0025c	5f		 pop	 edi
  0025d	5e		 pop	 esi

; 2551 : 				return false;

  0025e	33 c0		 xor	 eax, eax
  00260	5b		 pop	 ebx

; 2708 : }

  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
$LN20@gObjSetMon:

; 2552 : 			}
; 2553 : 
; 2554 : 			lpObj->m_SkyBossMonSheildLinkIndex = iSL;
; 2555 : 			LogAdd(LOG_BLACK, "SkyLand Boss Monster Setting!!");

  00265	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@GCONPPCF@SkyLand?5Boss?5Monster?5Setting?$CB?$CB?$AA@
  0026a	6a 00		 push	 0
  0026c	89 9e f4 0e 00
	00		 mov	 DWORD PTR [esi+3828], ebx
  00272	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2556 : 		}
; 2557 : 		else

  00277	8b 5d fc	 mov	 ebx, DWORD PTR tv643[ebp]
  0027a	eb 11		 jmp	 SHORT $LN67@gObjSetMon
$LN19@gObjSetMon:

; 2558 : 		{
; 2559 : 			MsgBox("  ");
; 2560 : 			return false;
; 2561 : 		}
; 2562 : 	}
; 2563 : 
; 2564 : 	if ( MonsterClass == 76 )

  0027c	83 ff 4c	 cmp	 edi, 76			; 0000004cH
  0027f	75 0f		 jne	 SHORT $LN18@gObjSetMon

; 2565 : 	{
; 2566 : 		LogAdd(LOG_BLACK, "SkyLand Boss Shield Setting!!");

  00281	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@HDDGJDLK@SkyLand?5Boss?5Shield?5Setting?$CB?$CB?$AA@
  00286	6a 00		 push	 0
  00288	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
$LN67@gObjSetMon:
  0028d	83 c4 08	 add	 esp, 8
$LN18@gObjSetMon:

; 2567 : 	}
; 2568 : 
; 2569 : 	lpObj->Class = MonsterClass;
; 2570 : 	Level = lpObj->Level;
; 2571 : 	LPMONSTER_ATTRIBUTE lpm = gMAttr.GetAttr( lpObj->Class);

  00290	0f b7 c7	 movzx	 eax, di
  00293	50		 push	 eax
  00294	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00299	66 89 be 98 00
	00 00		 mov	 WORD PTR [esi+152], di
  002a0	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  002a5	8b f8		 mov	 edi, eax

; 2572 : 
; 2573 : 	if ( lpm == NULL )

  002a7	85 ff		 test	 edi, edi
  002a9	75 33		 jne	 SHORT $LN17@gObjSetMon

; 2574 : 	{
; 2575 : 		MsgBox(lMsg.Get(MSGGET(1, 253) ), lpObj->Class, __FILE__, __LINE__);

  002ab	0f b7 8e 98 00
	00 00		 movzx	 ecx, WORD PTR [esi+152]
  002b2	68 0f 0a 00 00	 push	 2575			; 00000a0fH
  002b7	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  002bc	51		 push	 ecx
  002bd	68 fd 01 00 00	 push	 509			; 000001fdH
  002c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002c7	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  002cc	50		 push	 eax
  002cd	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  002d2	83 c4 10	 add	 esp, 16			; 00000010H
  002d5	5f		 pop	 edi
  002d6	5e		 pop	 esi

; 2576 : 		return false;

  002d7	33 c0		 xor	 eax, eax
  002d9	5b		 pop	 ebx

; 2708 : }

  002da	8b e5		 mov	 esp, ebp
  002dc	5d		 pop	 ebp
  002dd	c3		 ret	 0
$LN17@gObjSetMon:

; 2577 : 	}
; 2578 : 
; 2579 : 	strncpy(gObj[aIndex].Name, lpm->m_Name , 10 );

  002de	6a 0a		 push	 10			; 0000000aH
  002e0	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
  002e3	52		 push	 edx
  002e4	8d 83 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+111]
  002ea	50		 push	 eax
  002eb	e8 00 00 00 00	 call	 _strncpy
  002f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2580 : 
; 2581 : 	if (lpm->m_Level == 0)

  002f3	83 7f 1c 00	 cmp	 DWORD PTR [edi+28], 0
  002f7	75 2f		 jne	 SHORT $LN60@gObjSetMon

; 2582 : 	{
; 2583 : 		LogAdd(LOG_BLACK, lMsg.Get( MSGGET(1, 254)), lpObj->Class, __FILE__, __LINE__);

  002f9	0f b7 8e 98 00
	00 00		 movzx	 ecx, WORD PTR [esi+152]
  00300	68 17 0a 00 00	 push	 2583			; 00000a17H
  00305	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0030a	51		 push	 ecx
  0030b	68 fe 01 00 00	 push	 510			; 000001feH
  00310	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00315	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0031a	50		 push	 eax
  0031b	33 db		 xor	 ebx, ebx
  0031d	53		 push	 ebx
  0031e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00323	83 c4 14	 add	 esp, 20			; 00000014H
  00326	eb 02		 jmp	 SHORT $LN16@gObjSetMon
$LN60@gObjSetMon:
  00328	33 db		 xor	 ebx, ebx
$LN16@gObjSetMon:

; 2584 : 	}
; 2585 : 
; 2586 : 	lpObj->Level = lpm->m_Level;

  0032a	0f b7 57 1c	 movzx	 edx, WORD PTR [edi+28]
  0032e	66 89 96 9c 00
	00 00		 mov	 WORD PTR [esi+156], dx

; 2587 : 	lpObj->m_AttackSpeed = lpm->m_AttackSpeed;

  00335	8b 47 5c	 mov	 eax, DWORD PTR [edi+92]
  00338	89 86 08 03 00
	00		 mov	 DWORD PTR [esi+776], eax

; 2588 : 	lpObj->m_AttackDamageMin = lpm->m_DamageMin;

  0033e	8b 4f 30	 mov	 ecx, DWORD PTR [edi+48]
  00341	89 8e dc 02 00
	00		 mov	 DWORD PTR [esi+732], ecx

; 2589 : 	lpObj->m_AttackDamageMax = lpm->m_DamageMax;

  00347	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  0034a	89 96 e0 02 00
	00		 mov	 DWORD PTR [esi+736], edx

; 2590 : 	lpObj->m_Defense = lpm->m_Defense;

  00350	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00353	89 86 10 03 00
	00		 mov	 DWORD PTR [esi+784], eax

; 2591 : 	lpObj->m_MagicDefense = lpm->m_MagicDefense;

  00359	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  0035c	89 8e 14 03 00
	00		 mov	 DWORD PTR [esi+788], ecx

; 2592 : 	lpObj->m_AttackRating = lpm->m_AttackRating;

  00362	8b 57 40	 mov	 edx, DWORD PTR [edi+64]
  00365	89 96 04 03 00
	00		 mov	 DWORD PTR [esi+772], edx

; 2593 : 	lpObj->m_SuccessfulBlocking = lpm->m_Successfulblocking;

  0036b	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  0036e	89 86 18 03 00
	00		 mov	 DWORD PTR [esi+792], eax

; 2594 : 	lpObj->Life = lpm->m_Hp;
; 2595 : 	lpObj->MaxLife = lpm->m_Hp;
; 2596 : 	lpObj->Mana = lpm->m_Mp;
; 2597 : 	lpObj->MaxMana = lpm->m_Mp;
; 2598 : 	lpObj->m_MoveRange = lpm->m_MoveRange;
; 2599 : 	lpObj->m_AttackSpeed = lpm->m_AttackSpeed;
; 2600 : 	lpObj->m_MoveSpeed = lpm->m_MoveSpeed;
; 2601 : 	lpObj->MaxRegenTime = lpm->m_RegenTime * 1000;
; 2602 : 	lpObj->m_AttackRange = lpm->m_AttackRange;
; 2603 : 	lpObj->m_ViewRange = lpm->m_ViewRange;
; 2604 : 	lpObj->m_Attribute = lpm->m_Attribute;
; 2605 : 	lpObj->m_AttackType = lpm->m_AttackType;
; 2606 : 	lpObj->m_ItemRate = lpm->m_ItemRate;
; 2607 : 	lpObj->m_MoneyRate = lpm->m_MoneyRate;
; 2608 : 	lpObj->Dexterity = 0;
; 2609 : 
; 2610 : 	lpObj->m_iScriptMaxLife = lpm->m_iScriptHP;
; 2611 : 	lpObj->m_iGroupNumber = 0;
; 2612 : 	lpObj->m_iSubGroupNumber = 0;
; 2613 : 	lpObj->m_iGroupMemberGuid = -1;
; 2614 : 	lpObj->m_iRegenType = 0;
; 2615 : 
; 2616 : 	lpObj->m_iLastAutomataRuntime = 0;
; 2617 : 	lpObj->m_iLastAutomataDelay = 0;
; 2618 : 
; 2619 : 	lpObj->pInventoryCount[0] = 0;
; 2620 : 	memcpy(lpObj->m_Resistance, lpm->m_Resistance, MAX_RESISTENCE_TYPE );
; 2621 : 	gObjSetInventory1Pointer(lpObj);

  00374	56		 push	 esi
  00375	db 47 28	 fild	 DWORD PTR [edi+40]
  00378	d9 9e bc 00 00
	00		 fstp	 DWORD PTR [esi+188]
  0037e	db 47 28	 fild	 DWORD PTR [edi+40]
  00381	d9 9e c0 00 00
	00		 fstp	 DWORD PTR [esi+192]
  00387	db 47 2c	 fild	 DWORD PTR [edi+44]
  0038a	d9 9e d0 00 00
	00		 fstp	 DWORD PTR [esi+208]
  00390	db 47 2c	 fild	 DWORD PTR [edi+44]
  00393	d9 9e d4 00 00
	00		 fstp	 DWORD PTR [esi+212]
  00399	0f b7 4f 48	 movzx	 ecx, WORD PTR [edi+72]
  0039d	66 89 8e 1e 03
	00 00		 mov	 WORD PTR [esi+798], cx
  003a4	8b 57 5c	 mov	 edx, DWORD PTR [edi+92]
  003a7	89 96 08 03 00
	00		 mov	 DWORD PTR [esi+776], edx
  003ad	0f b7 47 58	 movzx	 eax, WORD PTR [edi+88]
  003b1	66 89 86 1c 03
	00 00		 mov	 WORD PTR [esi+796], ax
  003b8	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  003bb	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  003c1	89 8e 0c 02 00
	00		 mov	 DWORD PTR [esi+524], ecx
  003c7	0f b7 57 4c	 movzx	 edx, WORD PTR [edi+76]
  003cb	66 89 96 20 03
	00 00		 mov	 WORD PTR [esi+800], dx
  003d2	0f b7 47 54	 movzx	 eax, WORD PTR [edi+84]
  003d6	66 89 86 24 03
	00 00		 mov	 WORD PTR [esi+804], ax
  003dd	0f b7 4f 64	 movzx	 ecx, WORD PTR [edi+100]
  003e1	66 89 8e 26 03
	00 00		 mov	 WORD PTR [esi+806], cx
  003e8	0f b7 57 50	 movzx	 edx, WORD PTR [edi+80]
  003ec	66 89 96 22 03
	00 00		 mov	 WORD PTR [esi+802], dx
  003f3	0f b7 47 68	 movzx	 eax, WORD PTR [edi+104]
  003f7	66 89 86 28 03
	00 00		 mov	 WORD PTR [esi+808], ax
  003fe	0f b7 4f 6c	 movzx	 ecx, WORD PTR [edi+108]
  00402	66 89 8e 2a 03
	00 00		 mov	 WORD PTR [esi+810], cx
  00409	8b 8e 94 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3220]
  0040f	33 d2		 xor	 edx, edx
  00411	66 89 96 b6 00
	00 00		 mov	 WORD PTR [esi+182], dx
  00418	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0041b	89 86 c4 00 00
	00		 mov	 DWORD PTR [esi+196], eax
  00421	89 9e 00 15 00
	00		 mov	 DWORD PTR [esi+5376], ebx
  00427	89 9e 04 15 00
	00		 mov	 DWORD PTR [esi+5380], ebx
  0042d	c7 86 08 15 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+5384], -1
  00437	89 9e 0c 15 00
	00		 mov	 DWORD PTR [esi+5388], ebx
  0043d	89 9e 10 15 00
	00		 mov	 DWORD PTR [esi+5392], ebx
  00443	89 9e 14 15 00
	00		 mov	 DWORD PTR [esi+5396], ebx
  00449	88 11		 mov	 BYTE PTR [ecx], dl
  0044b	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  0044e	89 96 62 03 00
	00		 mov	 DWORD PTR [esi+866], edx
  00454	0f b7 4f 78	 movzx	 ecx, WORD PTR [edi+120]
  00458	66 89 8e 66 03
	00 00		 mov	 WORD PTR [esi+870], cx
  0045f	8a 57 7a	 mov	 dl, BYTE PTR [edi+122]
  00462	88 96 68 03 00
	00		 mov	 BYTE PTR [esi+872], dl
  00468	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer

; 2622 : 
; 2623 : 	if ( lpObj->m_AttackType != 0 )

  0046d	0f b7 86 22 03
	00 00		 movzx	 eax, WORD PTR [esi+802]
  00474	83 c4 04	 add	 esp, 4
  00477	66 3b c3	 cmp	 ax, bx
  0047a	0f 84 ad 03 00
	00		 je	 $LN61@gObjSetMon

; 2624 : 	{
; 2625 : 		if ( lpObj->m_AttackType >= 100 )
; 2626 : 		{
; 2627 : 			gObjMonsterMagicAdd(lpObj, lpObj->m_AttackType - 100, 1);

  00480	6a 01		 push	 1
  00482	66 83 f8 64	 cmp	 ax, 100			; 00000064H
  00486	7c 0e		 jl	 SHORT $LN14@gObjSetMon
  00488	8a 86 22 03 00
	00		 mov	 al, BYTE PTR [esi+802]
  0048e	2c 64		 sub	 al, 100			; 00000064H
  00490	0f b6 c8	 movzx	 ecx, al
  00493	51		 push	 ecx

; 2628 : 		}
; 2629 : 		else

  00494	eb 08		 jmp	 SHORT $LN68@gObjSetMon
$LN14@gObjSetMon:

; 2630 : 		{
; 2631 : 			gObjMonsterMagicAdd(lpObj, lpObj->m_AttackType, 1);

  00496	0f b6 96 22 03
	00 00		 movzx	 edx, BYTE PTR [esi+802]
  0049d	52		 push	 edx
$LN68@gObjSetMon:
  0049e	56		 push	 esi
  0049f	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd

; 2632 : 		}
; 2633 : 
; 2634 : 		if ( lpObj->Class == 144 || lpObj->Class == 174 || lpObj->Class == 182 || lpObj->Class == 190 || lpObj->Class == 260 || lpObj->Class == 268 )

  004a4	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  004ab	b9 90 00 00 00	 mov	 ecx, 144		; 00000090H
  004b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  004b3	66 3b c1	 cmp	 ax, cx
  004b6	74 32		 je	 SHORT $LN11@gObjSetMon
  004b8	ba ae 00 00 00	 mov	 edx, 174		; 000000aeH
  004bd	66 3b c2	 cmp	 ax, dx
  004c0	74 28		 je	 SHORT $LN11@gObjSetMon
  004c2	b9 b6 00 00 00	 mov	 ecx, 182		; 000000b6H
  004c7	66 3b c1	 cmp	 ax, cx
  004ca	74 1e		 je	 SHORT $LN11@gObjSetMon
  004cc	ba be 00 00 00	 mov	 edx, 190		; 000000beH
  004d1	66 3b c2	 cmp	 ax, dx
  004d4	74 14		 je	 SHORT $LN11@gObjSetMon
  004d6	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  004db	66 3b c1	 cmp	 ax, cx
  004de	74 0a		 je	 SHORT $LN11@gObjSetMon
  004e0	ba 0c 01 00 00	 mov	 edx, 268		; 0000010cH
  004e5	66 3b c2	 cmp	 ax, dx
  004e8	75 0d		 jne	 SHORT $LN12@gObjSetMon
$LN11@gObjSetMon:

; 2635 : 		{
; 2636 : 			gObjMonsterMagicAdd(lpObj, 17, 1);

  004ea	6a 01		 push	 1
  004ec	6a 11		 push	 17			; 00000011H
  004ee	56		 push	 esi
  004ef	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  004f4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@gObjSetMon:

; 2637 : 		}
; 2638 : 
; 2639 : 		if ( lpObj->Class == 145 
; 2640 : 			|| lpObj->Class == 175 
; 2641 : 			|| lpObj->Class == 183 
; 2642 : 			|| lpObj->Class == 191 
; 2643 : 			|| lpObj->Class == 261 
; 2644 : 			|| lpObj->Class == 269 
; 2645 : 			|| lpObj->Class == 146 
; 2646 : 			|| lpObj->Class == 176 
; 2647 : 			|| lpObj->Class == 184 
; 2648 : 			|| lpObj->Class == 192 
; 2649 : 			|| lpObj->Class == 262 
; 2650 : 			|| lpObj->Class == 270 
; 2651 : 			|| lpObj->Class == 147 
; 2652 : 			|| lpObj->Class == 177 
; 2653 : 			|| lpObj->Class == 185 
; 2654 : 			|| lpObj->Class == 193 
; 2655 : 			|| lpObj->Class == 263 
; 2656 : 			|| lpObj->Class == 271 
; 2657 : 			|| lpObj->Class == 148
; 2658 : 			|| lpObj->Class == 178
; 2659 : 			|| lpObj->Class == 186
; 2660 : 			|| lpObj->Class == 194
; 2661 : 			|| lpObj->Class == 264
; 2662 : 			|| lpObj->Class == 272
; 2663 : 			|| lpObj->Class == 160
; 2664 : 			|| lpObj->Class == 180
; 2665 : 			|| lpObj->Class == 188
; 2666 : 			|| lpObj->Class == 196
; 2667 : 			|| lpObj->Class == 266
; 2668 : 			|| lpObj->Class == 274 )

  004f7	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  004fe	b9 91 00 00 00	 mov	 ecx, 145		; 00000091H
  00503	66 3b c1	 cmp	 ax, cx
  00506	0f 84 62 01 00
	00		 je	 $LN9@gObjSetMon
  0050c	ba af 00 00 00	 mov	 edx, 175		; 000000afH
  00511	66 3b c2	 cmp	 ax, dx
  00514	0f 84 54 01 00
	00		 je	 $LN9@gObjSetMon
  0051a	b9 b7 00 00 00	 mov	 ecx, 183		; 000000b7H
  0051f	66 3b c1	 cmp	 ax, cx
  00522	0f 84 46 01 00
	00		 je	 $LN9@gObjSetMon
  00528	ba bf 00 00 00	 mov	 edx, 191		; 000000bfH
  0052d	66 3b c2	 cmp	 ax, dx
  00530	0f 84 38 01 00
	00		 je	 $LN9@gObjSetMon
  00536	b9 05 01 00 00	 mov	 ecx, 261		; 00000105H
  0053b	66 3b c1	 cmp	 ax, cx
  0053e	0f 84 2a 01 00
	00		 je	 $LN9@gObjSetMon
  00544	ba 0d 01 00 00	 mov	 edx, 269		; 0000010dH
  00549	66 3b c2	 cmp	 ax, dx
  0054c	0f 84 1c 01 00
	00		 je	 $LN9@gObjSetMon
  00552	b9 92 00 00 00	 mov	 ecx, 146		; 00000092H
  00557	66 3b c1	 cmp	 ax, cx
  0055a	0f 84 0e 01 00
	00		 je	 $LN9@gObjSetMon
  00560	ba b0 00 00 00	 mov	 edx, 176		; 000000b0H
  00565	66 3b c2	 cmp	 ax, dx
  00568	0f 84 00 01 00
	00		 je	 $LN9@gObjSetMon
  0056e	b9 b8 00 00 00	 mov	 ecx, 184		; 000000b8H
  00573	66 3b c1	 cmp	 ax, cx
  00576	0f 84 f2 00 00
	00		 je	 $LN9@gObjSetMon
  0057c	ba c0 00 00 00	 mov	 edx, 192		; 000000c0H
  00581	66 3b c2	 cmp	 ax, dx
  00584	0f 84 e4 00 00
	00		 je	 $LN9@gObjSetMon
  0058a	b9 06 01 00 00	 mov	 ecx, 262		; 00000106H
  0058f	66 3b c1	 cmp	 ax, cx
  00592	0f 84 d6 00 00
	00		 je	 $LN9@gObjSetMon
  00598	ba 0e 01 00 00	 mov	 edx, 270		; 0000010eH
  0059d	66 3b c2	 cmp	 ax, dx
  005a0	0f 84 c8 00 00
	00		 je	 $LN9@gObjSetMon
  005a6	b9 93 00 00 00	 mov	 ecx, 147		; 00000093H
  005ab	66 3b c1	 cmp	 ax, cx
  005ae	0f 84 ba 00 00
	00		 je	 $LN9@gObjSetMon
  005b4	ba b1 00 00 00	 mov	 edx, 177		; 000000b1H
  005b9	66 3b c2	 cmp	 ax, dx
  005bc	0f 84 ac 00 00
	00		 je	 $LN9@gObjSetMon
  005c2	b9 b9 00 00 00	 mov	 ecx, 185		; 000000b9H
  005c7	66 3b c1	 cmp	 ax, cx
  005ca	0f 84 9e 00 00
	00		 je	 $LN9@gObjSetMon
  005d0	ba c1 00 00 00	 mov	 edx, 193		; 000000c1H
  005d5	66 3b c2	 cmp	 ax, dx
  005d8	0f 84 90 00 00
	00		 je	 $LN9@gObjSetMon
  005de	b9 07 01 00 00	 mov	 ecx, 263		; 00000107H
  005e3	66 3b c1	 cmp	 ax, cx
  005e6	0f 84 82 00 00
	00		 je	 $LN9@gObjSetMon
  005ec	ba 0f 01 00 00	 mov	 edx, 271		; 0000010fH
  005f1	66 3b c2	 cmp	 ax, dx
  005f4	74 78		 je	 SHORT $LN9@gObjSetMon
  005f6	b9 94 00 00 00	 mov	 ecx, 148		; 00000094H
  005fb	66 3b c1	 cmp	 ax, cx
  005fe	74 6e		 je	 SHORT $LN9@gObjSetMon
  00600	ba b2 00 00 00	 mov	 edx, 178		; 000000b2H
  00605	66 3b c2	 cmp	 ax, dx
  00608	74 64		 je	 SHORT $LN9@gObjSetMon
  0060a	b9 ba 00 00 00	 mov	 ecx, 186		; 000000baH
  0060f	66 3b c1	 cmp	 ax, cx
  00612	74 5a		 je	 SHORT $LN9@gObjSetMon
  00614	ba c2 00 00 00	 mov	 edx, 194		; 000000c2H
  00619	66 3b c2	 cmp	 ax, dx
  0061c	74 50		 je	 SHORT $LN9@gObjSetMon
  0061e	b9 08 01 00 00	 mov	 ecx, 264		; 00000108H
  00623	66 3b c1	 cmp	 ax, cx
  00626	74 46		 je	 SHORT $LN9@gObjSetMon
  00628	ba 10 01 00 00	 mov	 edx, 272		; 00000110H
  0062d	66 3b c2	 cmp	 ax, dx
  00630	74 3c		 je	 SHORT $LN9@gObjSetMon
  00632	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  00637	66 3b c1	 cmp	 ax, cx
  0063a	74 32		 je	 SHORT $LN9@gObjSetMon
  0063c	ba b4 00 00 00	 mov	 edx, 180		; 000000b4H
  00641	66 3b c2	 cmp	 ax, dx
  00644	74 28		 je	 SHORT $LN9@gObjSetMon
  00646	b9 bc 00 00 00	 mov	 ecx, 188		; 000000bcH
  0064b	66 3b c1	 cmp	 ax, cx
  0064e	74 1e		 je	 SHORT $LN9@gObjSetMon
  00650	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  00655	66 3b c2	 cmp	 ax, dx
  00658	74 14		 je	 SHORT $LN9@gObjSetMon
  0065a	b9 0a 01 00 00	 mov	 ecx, 266		; 0000010aH
  0065f	66 3b c1	 cmp	 ax, cx
  00662	74 0a		 je	 SHORT $LN9@gObjSetMon
  00664	ba 12 01 00 00	 mov	 edx, 274		; 00000112H
  00669	66 3b c2	 cmp	 ax, dx
  0066c	75 0d		 jne	 SHORT $LN10@gObjSetMon
$LN9@gObjSetMon:

; 2669 : 		{
; 2670 : 			gObjMonsterMagicAdd(lpObj, 17, 1);

  0066e	6a 01		 push	 1
  00670	6a 11		 push	 17			; 00000011H
  00672	56		 push	 esi
  00673	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  00678	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@gObjSetMon:

; 2671 : 		}
; 2672 : 
; 2673 : 		if ( lpObj->Class == 161 || lpObj->Class == 181 || lpObj->Class == 189 || lpObj->Class == 197 || lpObj->Class == 267 || lpObj->Class == 275 )

  0067b	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00682	b9 a1 00 00 00	 mov	 ecx, 161		; 000000a1H
  00687	66 3b c1	 cmp	 ax, cx
  0068a	74 32		 je	 SHORT $LN7@gObjSetMon
  0068c	ba b5 00 00 00	 mov	 edx, 181		; 000000b5H
  00691	66 3b c2	 cmp	 ax, dx
  00694	74 28		 je	 SHORT $LN7@gObjSetMon
  00696	b9 bd 00 00 00	 mov	 ecx, 189		; 000000bdH
  0069b	66 3b c1	 cmp	 ax, cx
  0069e	74 1e		 je	 SHORT $LN7@gObjSetMon
  006a0	ba c5 00 00 00	 mov	 edx, 197		; 000000c5H
  006a5	66 3b c2	 cmp	 ax, dx
  006a8	74 14		 je	 SHORT $LN7@gObjSetMon
  006aa	b9 0b 01 00 00	 mov	 ecx, 267		; 0000010bH
  006af	66 3b c1	 cmp	 ax, cx
  006b2	74 0a		 je	 SHORT $LN7@gObjSetMon
  006b4	ba 13 01 00 00	 mov	 edx, 275		; 00000113H
  006b9	66 3b c2	 cmp	 ax, dx
  006bc	75 48		 jne	 SHORT $LN8@gObjSetMon
$LN7@gObjSetMon:

; 2674 : 		{
; 2675 : 			gObjMonsterMagicAdd(lpObj, 200, 1);

  006be	6a 01		 push	 1
  006c0	68 c8 00 00 00	 push	 200			; 000000c8H
  006c5	56		 push	 esi
  006c6	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd

; 2676 : 			gObjMonsterMagicAdd(lpObj, 17, 1);

  006cb	6a 01		 push	 1
  006cd	6a 11		 push	 17			; 00000011H
  006cf	56		 push	 esi
  006d0	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd

; 2677 : 			gObjMonsterMagicAdd(lpObj, 1, 1);

  006d5	6a 01		 push	 1
  006d7	6a 01		 push	 1
  006d9	56		 push	 esi
  006da	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd

; 2678 : 			gObjMonsterMagicAdd(lpObj, 201, 1);

  006df	6a 01		 push	 1
  006e1	68 c9 00 00 00	 push	 201			; 000000c9H
  006e6	56		 push	 esi
  006e7	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd

; 2679 : 			gObjMonsterMagicAdd(lpObj, 202, 1);

  006ec	6a 01		 push	 1
  006ee	68 ca 00 00 00	 push	 202			; 000000caH
  006f3	56		 push	 esi
  006f4	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd

; 2680 : 			gObjMonsterMagicAdd(lpObj, 55, 1);

  006f9	6a 01		 push	 1
  006fb	6a 37		 push	 55			; 00000037H
  006fd	56		 push	 esi
  006fe	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  00703	83 c4 48	 add	 esp, 72			; 00000048H
$LN8@gObjSetMon:

; 2681 : 		}
; 2682 : 
; 2683 : 		if (  lpObj->Class == 149 || lpObj->Class == 179 || lpObj->Class == 187 || lpObj->Class == 195 || lpObj->Class == 265 || lpObj->Class == 273 )

  00706	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  0070d	b9 95 00 00 00	 mov	 ecx, 149		; 00000095H
  00712	66 3b c1	 cmp	 ax, cx
  00715	74 32		 je	 SHORT $LN5@gObjSetMon
  00717	ba b3 00 00 00	 mov	 edx, 179		; 000000b3H
  0071c	66 3b c2	 cmp	 ax, dx
  0071f	74 28		 je	 SHORT $LN5@gObjSetMon
  00721	b9 bb 00 00 00	 mov	 ecx, 187		; 000000bbH
  00726	66 3b c1	 cmp	 ax, cx
  00729	74 1e		 je	 SHORT $LN5@gObjSetMon
  0072b	ba c3 00 00 00	 mov	 edx, 195		; 000000c3H
  00730	66 3b c2	 cmp	 ax, dx
  00733	74 14		 je	 SHORT $LN5@gObjSetMon
  00735	b9 09 01 00 00	 mov	 ecx, 265		; 00000109H
  0073a	66 3b c1	 cmp	 ax, cx
  0073d	74 0a		 je	 SHORT $LN5@gObjSetMon
  0073f	ba 11 01 00 00	 mov	 edx, 273		; 00000111H
  00744	66 3b c2	 cmp	 ax, dx
  00747	75 17		 jne	 SHORT $LN6@gObjSetMon
$LN5@gObjSetMon:

; 2684 : 		{
; 2685 : 			gObjMonsterMagicAdd(lpObj, 17, 1);

  00749	6a 01		 push	 1
  0074b	6a 11		 push	 17			; 00000011H
  0074d	56		 push	 esi
  0074e	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd

; 2686 : 			gObjMonsterMagicAdd(lpObj, 1, 1);

  00753	6a 01		 push	 1
  00755	6a 01		 push	 1
  00757	56		 push	 esi
  00758	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  0075d	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@gObjSetMon:

; 2687 : 		}
; 2688 : 
; 2689 : 		if ( lpObj->Class == 66 || lpObj->Class == 73 || lpObj->Class == 77 || lpObj->Class == 89 || lpObj->Class == 95 || lpObj->Class == 112 || lpObj->Class == 118 || lpObj->Class == 124 || lpObj->Class == 130 || lpObj->Class == 143 || lpObj->Class == 163 || lpObj->Class == 165 || lpObj->Class == 167 || lpObj->Class == 169 || lpObj->Class == 171 || lpObj->Class == 173 )

  00760	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00767	83 f8 42	 cmp	 eax, 66			; 00000042H
  0076a	74 73		 je	 SHORT $LN3@gObjSetMon
  0076c	83 f8 49	 cmp	 eax, 73			; 00000049H
  0076f	74 6e		 je	 SHORT $LN3@gObjSetMon
  00771	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00774	74 69		 je	 SHORT $LN3@gObjSetMon
  00776	83 f8 59	 cmp	 eax, 89			; 00000059H
  00779	74 64		 je	 SHORT $LN3@gObjSetMon
  0077b	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  0077e	74 5f		 je	 SHORT $LN3@gObjSetMon
  00780	83 f8 70	 cmp	 eax, 112		; 00000070H
  00783	74 5a		 je	 SHORT $LN3@gObjSetMon
  00785	83 f8 76	 cmp	 eax, 118		; 00000076H
  00788	74 55		 je	 SHORT $LN3@gObjSetMon
  0078a	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  0078d	74 50		 je	 SHORT $LN3@gObjSetMon
  0078f	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00794	66 3b c1	 cmp	 ax, cx
  00797	74 46		 je	 SHORT $LN3@gObjSetMon
  00799	ba 8f 00 00 00	 mov	 edx, 143		; 0000008fH
  0079e	66 3b c2	 cmp	 ax, dx
  007a1	74 3c		 je	 SHORT $LN3@gObjSetMon
  007a3	b9 a3 00 00 00	 mov	 ecx, 163		; 000000a3H
  007a8	66 3b c1	 cmp	 ax, cx
  007ab	74 32		 je	 SHORT $LN3@gObjSetMon
  007ad	ba a5 00 00 00	 mov	 edx, 165		; 000000a5H
  007b2	66 3b c2	 cmp	 ax, dx
  007b5	74 28		 je	 SHORT $LN3@gObjSetMon
  007b7	b9 a7 00 00 00	 mov	 ecx, 167		; 000000a7H
  007bc	66 3b c1	 cmp	 ax, cx
  007bf	74 1e		 je	 SHORT $LN3@gObjSetMon
  007c1	ba a9 00 00 00	 mov	 edx, 169		; 000000a9H
  007c6	66 3b c2	 cmp	 ax, dx
  007c9	74 14		 je	 SHORT $LN3@gObjSetMon
  007cb	b9 ab 00 00 00	 mov	 ecx, 171		; 000000abH
  007d0	66 3b c1	 cmp	 ax, cx
  007d3	74 0a		 je	 SHORT $LN3@gObjSetMon
  007d5	ba ad 00 00 00	 mov	 edx, 173		; 000000adH
  007da	66 3b c2	 cmp	 ax, dx
  007dd	75 0d		 jne	 SHORT $LN4@gObjSetMon
$LN3@gObjSetMon:

; 2690 : 		{
; 2691 : 			gObjMonsterMagicAdd(lpObj, 17, 1);

  007df	6a 01		 push	 1
  007e1	6a 11		 push	 17			; 00000011H
  007e3	56		 push	 esi
  007e4	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  007e9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@gObjSetMon:

; 2692 : 		}
; 2693 : 		
; 2694 : 		if( lpObj->Class == 89 || lpObj->Class == 95 || lpObj->Class == 112 || lpObj->Class == 118 || lpObj->Class == 124 || lpObj->Class == 130 || lpObj->Class == 143 )

  007ec	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  007f3	83 f8 59	 cmp	 eax, 89			; 00000059H
  007f6	74 28		 je	 SHORT $LN1@gObjSetMon
  007f8	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  007fb	74 23		 je	 SHORT $LN1@gObjSetMon
  007fd	83 f8 70	 cmp	 eax, 112		; 00000070H
  00800	74 1e		 je	 SHORT $LN1@gObjSetMon
  00802	83 f8 76	 cmp	 eax, 118		; 00000076H
  00805	74 19		 je	 SHORT $LN1@gObjSetMon
  00807	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  0080a	74 14		 je	 SHORT $LN1@gObjSetMon
  0080c	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00811	66 3b c1	 cmp	 ax, cx
  00814	74 0a		 je	 SHORT $LN1@gObjSetMon
  00816	ba 8f 00 00 00	 mov	 edx, 143		; 0000008fH
  0081b	66 3b c2	 cmp	 ax, dx
  0081e	75 0d		 jne	 SHORT $LN61@gObjSetMon
$LN1@gObjSetMon:

; 2695 : 		{
; 2696 : 			gObjMonsterMagicAdd(lpObj, 3, 1);

  00820	6a 01		 push	 1
  00822	6a 03		 push	 3
  00824	56		 push	 esi
  00825	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  0082a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN61@gObjSetMon:

; 2697 : 		}
; 2698 : 	}
; 2699 : 
; 2700 : 	gObjGiveItemSearch(lpObj, lpm->m_MaxItemLevel);
; 2701 : 	gObjGiveItemWarehouseSearch(lpObj, lpm->m_MaxItemLevel);
; 2702 : 	CreateFrustrum(lpObj->X, lpObj->Y, aIndex);

  0082d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00830	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR [esi+262]
  00837	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  0083e	50		 push	 eax
  0083f	51		 push	 ecx
  00840	52		 push	 edx
  00841	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum

; 2703 : 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->X, lpObj->Y);

  00846	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  0084d	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  00854	83 c4 0c	 add	 esp, 12			; 0000000cH
  00857	50		 push	 eax
  00858	51		 push	 ecx
  00859	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00860	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00866	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0086c	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 2704 : 	lpObj->m_OldX = lpObj->X;
; 2705 : 	lpObj->m_OldY = lpObj->Y;

  00871	66 8b 86 06 01
	00 00		 mov	 ax, WORD PTR [esi+262]
  00878	66 8b 96 04 01
	00 00		 mov	 dx, WORD PTR [esi+260]

; 2706 : 	lpObj->LastAttackerID = -1;

  0087f	83 c9 ff	 or	 ecx, -1
  00882	5f		 pop	 edi
  00883	66 89 86 1e 01
	00 00		 mov	 WORD PTR [esi+286], ax
  0088a	66 89 96 1c 01
	00 00		 mov	 WORD PTR [esi+284], dx
  00891	66 89 8e da 02
	00 00		 mov	 WORD PTR [esi+730], cx
  00898	5e		 pop	 esi

; 2707 : 	return true;

  00899	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  0089c	5b		 pop	 ebx

; 2708 : }

  0089d	8b e5		 mov	 esp, ebp
  0089f	5d		 pop	 ebp
  008a0	c3		 ret	 0
  008a1	8d 49 00	 npad	 3
$LN69@gObjSetMon:
  008a4	00 00 00 00	 DD	 $LN49@gObjSetMon
  008a8	00 00 00 00	 DD	 $LN36@gObjSetMon
  008ac	00 00 00 00	 DD	 $LN37@gObjSetMon
  008b0	00 00 00 00	 DD	 $LN33@gObjSetMon
  008b4	00 00 00 00	 DD	 $LN31@gObjSetMon
  008b8	00 00 00 00	 DD	 $LN43@gObjSetMon
  008bc	00 00 00 00	 DD	 $LN35@gObjSetMon
  008c0	00 00 00 00	 DD	 $LN38@gObjSetMon
  008c4	00 00 00 00	 DD	 $LN39@gObjSetMon
  008c8	00 00 00 00	 DD	 $LN42@gObjSetMon
  008cc	00 00 00 00	 DD	 $LN41@gObjSetMon
  008d0	00 00 00 00	 DD	 $LN40@gObjSetMon
  008d4	00 00 00 00	 DD	 $LN44@gObjSetMon
  008d8	00 00 00 00	 DD	 $LN45@gObjSetMon
  008dc	00 00 00 00	 DD	 $LN48@gObjSetMon
  008e0	00 00 00 00	 DD	 $LN46@gObjSetMon
  008e4	00 00 00 00	 DD	 $LN47@gObjSetMon
  008e8	00 00 00 00	 DD	 $LN32@gObjSetMon
  008ec	00 00 00 00	 DD	 $LN59@gObjSetMon
$LN58@gObjSetMon:
  008f0	00		 DB	 0
  008f1	12		 DB	 18			; 00000012H
  008f2	12		 DB	 18			; 00000012H
  008f3	12		 DB	 18			; 00000012H
  008f4	12		 DB	 18			; 00000012H
  008f5	12		 DB	 18			; 00000012H
  008f6	12		 DB	 18			; 00000012H
  008f7	12		 DB	 18			; 00000012H
  008f8	12		 DB	 18			; 00000012H
  008f9	12		 DB	 18			; 00000012H
  008fa	12		 DB	 18			; 00000012H
  008fb	12		 DB	 18			; 00000012H
  008fc	12		 DB	 18			; 00000012H
  008fd	12		 DB	 18			; 00000012H
  008fe	12		 DB	 18			; 00000012H
  008ff	12		 DB	 18			; 00000012H
  00900	12		 DB	 18			; 00000012H
  00901	12		 DB	 18			; 00000012H
  00902	12		 DB	 18			; 00000012H
  00903	12		 DB	 18			; 00000012H
  00904	12		 DB	 18			; 00000012H
  00905	12		 DB	 18			; 00000012H
  00906	12		 DB	 18			; 00000012H
  00907	12		 DB	 18			; 00000012H
  00908	12		 DB	 18			; 00000012H
  00909	12		 DB	 18			; 00000012H
  0090a	12		 DB	 18			; 00000012H
  0090b	12		 DB	 18			; 00000012H
  0090c	12		 DB	 18			; 00000012H
  0090d	12		 DB	 18			; 00000012H
  0090e	01		 DB	 1
  0090f	02		 DB	 2
  00910	12		 DB	 18			; 00000012H
  00911	12		 DB	 18			; 00000012H
  00912	12		 DB	 18			; 00000012H
  00913	12		 DB	 18			; 00000012H
  00914	03		 DB	 3
  00915	12		 DB	 18			; 00000012H
  00916	04		 DB	 4
  00917	05		 DB	 5
  00918	06		 DB	 6
  00919	12		 DB	 18			; 00000012H
  0091a	07		 DB	 7
  0091b	08		 DB	 8
  0091c	09		 DB	 9
  0091d	0a		 DB	 10			; 0000000aH
  0091e	0b		 DB	 11			; 0000000bH
  0091f	12		 DB	 18			; 00000012H
  00920	0c		 DB	 12			; 0000000cH
  00921	12		 DB	 18			; 00000012H
  00922	0d		 DB	 13			; 0000000dH
  00923	0e		 DB	 14			; 0000000eH
  00924	12		 DB	 18			; 00000012H
  00925	05		 DB	 5
  00926	0f		 DB	 15			; 0000000fH
  00927	10		 DB	 16			; 00000010H
  00928	12		 DB	 18			; 00000012H
  00929	12		 DB	 18			; 00000012H
  0092a	12		 DB	 18			; 00000012H
  0092b	11		 DB	 17			; 00000011H
  0092c	12		 DB	 18			; 00000012H
  0092d	12		 DB	 18			; 00000012H
  0092e	12		 DB	 18			; 00000012H
  0092f	12		 DB	 18			; 00000012H
  00930	12		 DB	 18			; 00000012H
  00931	12		 DB	 18			; 00000012H
  00932	12		 DB	 18			; 00000012H
  00933	12		 DB	 18			; 00000012H
  00934	12		 DB	 18			; 00000012H
  00935	12		 DB	 18			; 00000012H
  00936	12		 DB	 18			; 00000012H
  00937	12		 DB	 18			; 00000012H
  00938	12		 DB	 18			; 00000012H
  00939	12		 DB	 18			; 00000012H
  0093a	12		 DB	 18			; 00000012H
  0093b	12		 DB	 18			; 00000012H
  0093c	12		 DB	 18			; 00000012H
  0093d	12		 DB	 18			; 00000012H
  0093e	12		 DB	 18			; 00000012H
  0093f	12		 DB	 18			; 00000012H
  00940	12		 DB	 18			; 00000012H
  00941	12		 DB	 18			; 00000012H
  00942	12		 DB	 18			; 00000012H
  00943	12		 DB	 18			; 00000012H
  00944	12		 DB	 18			; 00000012H
  00945	12		 DB	 18			; 00000012H
  00946	12		 DB	 18			; 00000012H
  00947	12		 DB	 18			; 00000012H
  00948	12		 DB	 18			; 00000012H
  00949	12		 DB	 18			; 00000012H
  0094a	12		 DB	 18			; 00000012H
  0094b	12		 DB	 18			; 00000012H
  0094c	12		 DB	 18			; 00000012H
  0094d	12		 DB	 18			; 00000012H
  0094e	12		 DB	 18			; 00000012H
  0094f	12		 DB	 18			; 00000012H
  00950	12		 DB	 18			; 00000012H
  00951	12		 DB	 18			; 00000012H
  00952	12		 DB	 18			; 00000012H
  00953	12		 DB	 18			; 00000012H
  00954	12		 DB	 18			; 00000012H
  00955	12		 DB	 18			; 00000012H
  00956	12		 DB	 18			; 00000012H
  00957	12		 DB	 18			; 00000012H
  00958	12		 DB	 18			; 00000012H
  00959	12		 DB	 18			; 00000012H
  0095a	12		 DB	 18			; 00000012H
  0095b	12		 DB	 18			; 00000012H
  0095c	12		 DB	 18			; 00000012H
  0095d	12		 DB	 18			; 00000012H
  0095e	12		 DB	 18			; 00000012H
  0095f	12		 DB	 18			; 00000012H
  00960	12		 DB	 18			; 00000012H
  00961	12		 DB	 18			; 00000012H
  00962	12		 DB	 18			; 00000012H
  00963	12		 DB	 18			; 00000012H
  00964	12		 DB	 18			; 00000012H
  00965	12		 DB	 18			; 00000012H
  00966	12		 DB	 18			; 00000012H
  00967	12		 DB	 18			; 00000012H
  00968	12		 DB	 18			; 00000012H
  00969	12		 DB	 18			; 00000012H
  0096a	12		 DB	 18			; 00000012H
  0096b	12		 DB	 18			; 00000012H
  0096c	12		 DB	 18			; 00000012H
  0096d	12		 DB	 18			; 00000012H
  0096e	12		 DB	 18			; 00000012H
  0096f	12		 DB	 18			; 00000012H
  00970	12		 DB	 18			; 00000012H
  00971	12		 DB	 18			; 00000012H
  00972	12		 DB	 18			; 00000012H
  00973	12		 DB	 18			; 00000012H
  00974	12		 DB	 18			; 00000012H
  00975	12		 DB	 18			; 00000012H
  00976	12		 DB	 18			; 00000012H
  00977	12		 DB	 18			; 00000012H
  00978	12		 DB	 18			; 00000012H
  00979	12		 DB	 18			; 00000012H
  0097a	12		 DB	 18			; 00000012H
  0097b	12		 DB	 18			; 00000012H
  0097c	12		 DB	 18			; 00000012H
  0097d	12		 DB	 18			; 00000012H
  0097e	12		 DB	 18			; 00000012H
  0097f	12		 DB	 18			; 00000012H
  00980	12		 DB	 18			; 00000012H
  00981	12		 DB	 18			; 00000012H
  00982	12		 DB	 18			; 00000012H
  00983	12		 DB	 18			; 00000012H
  00984	12		 DB	 18			; 00000012H
  00985	12		 DB	 18			; 00000012H
  00986	12		 DB	 18			; 00000012H
  00987	12		 DB	 18			; 00000012H
  00988	12		 DB	 18			; 00000012H
  00989	12		 DB	 18			; 00000012H
  0098a	12		 DB	 18			; 00000012H
  0098b	12		 DB	 18			; 00000012H
  0098c	12		 DB	 18			; 00000012H
  0098d	12		 DB	 18			; 00000012H
  0098e	12		 DB	 18			; 00000012H
  0098f	12		 DB	 18			; 00000012H
  00990	12		 DB	 18			; 00000012H
  00991	12		 DB	 18			; 00000012H
  00992	12		 DB	 18			; 00000012H
  00993	12		 DB	 18			; 00000012H
  00994	12		 DB	 18			; 00000012H
  00995	12		 DB	 18			; 00000012H
  00996	12		 DB	 18			; 00000012H
  00997	12		 DB	 18			; 00000012H
  00998	04		 DB	 4
  00999	04		 DB	 4
  0099a	04		 DB	 4
?gObjSetMonster@@YAHHH@Z ENDP				; gObjSetMonster
_TEXT	ENDS
PUBLIC	?gObjMonsterRecall@@YAFH@Z			; gObjMonsterRecall
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterRecall@@YAFH@Z
_TEXT	SEGMENT
_iMapNumber$ = 8					; size = 4
?gObjMonsterRecall@@YAFH@Z PROC				; gObjMonsterRecall, COMDAT

; 2799 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2800 : 	int number = gObjAddMonster(iMapNumber);

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0000c	83 c4 04	 add	 esp, 4

; 2801 : 
; 2802 : 	if ( number < 0 )
; 2803 : 	{
; 2804 : 		return -1;
; 2805 : 	}
; 2806 : 	return -1;

  0000f	83 c8 ff	 or	 eax, -1

; 2807 : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?gObjMonsterRecall@@YAFH@Z ENDP				; gObjMonsterRecall
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjTradeSave@@YAXPAUOBJECTSTRUCT@@H@Z		; gObjTradeSave
; Function compile flags: /Ogtp
;	COMDAT ?gObjTradeSave@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_szTemp$162681 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_index$ = 12						; size = 4
?gObjTradeSave@@YAXPAUOBJECTSTRUCT@@H@Z PROC		; gObjTradeSave, COMDAT

; 2942 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]

; 2943 : 	if ( lpObj->m_IfState.use != 0 && lpObj->m_IfState.type == 1 )

  00017	8b 87 84 0c 00
	00		 mov	 eax, DWORD PTR [edi+3204]
  0001d	a8 03		 test	 al, 3
  0001f	0f 84 bb 00 00
	00		 je	 $LN2@gObjTradeS
  00025	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0002a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0002d	0f 85 ad 00 00
	00		 jne	 $LN2@gObjTradeS

; 2944 : 	{
; 2945 : 		int tObjNum = lpObj->TargetNumber;

  00033	56		 push	 esi
  00034	0f bf b7 d4 02
	00 00		 movsx	 esi, WORD PTR [edi+724]

; 2946 : 
; 2947 : 		if ( tObjNum > 0 )

  0003b	85 f6		 test	 esi, esi
  0003d	7e 72		 jle	 SHORT $LN1@gObjTradeS

; 2948 : 		{
; 2949 : 			char szTemp[256];
; 2950 : 
; 2951 : 			CGTradeResult(tObjNum, 0);

  0003f	6a 00		 push	 0
  00041	56		 push	 esi
  00042	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  00047	83 c4 08	 add	 esp, 8

; 2952 : 			wsprintf(szTemp, lMsg.Get(MSGGET(4, 77)), lpObj->Name);

  0004a	8d 47 6f	 lea	 eax, DWORD PTR [edi+111]
  0004d	50		 push	 eax
  0004e	68 4d 04 00 00	 push	 1101			; 0000044dH
  00053	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00058	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0005d	50		 push	 eax
  0005e	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$162681[ebp]
  00064	51		 push	 ecx
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 2953 : 			GCServerMsgStringSend((char*)szTemp, tObjNum, 1);

  0006b	6a 01		 push	 1
  0006d	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$162681[ebp]
  00073	56		 push	 esi
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 2954 : 			gObjTradeCancel(tObjNum);

  0007a	56		 push	 esi
  0007b	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel

; 2955 : 			LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2, 1)), gObj[tObjNum].AccountID, gObj[tObjNum].Name);

  00080	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00086	83 c4 1c	 add	 esp, 28			; 0000001cH
  00089	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  0008f	50		 push	 eax
  00090	8d 8e 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  00096	51		 push	 ecx
  00097	68 01 02 00 00	 push	 513			; 00000201H
  0009c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000a1	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000a6	50		 push	 eax
  000a7	6a 00		 push	 0
  000a9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000ae	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@gObjTradeS:

; 2956 : 		}
; 2957 : 
; 2958 : 		gObjTradeCancel( index );

  000b1	8b 55 0c	 mov	 edx, DWORD PTR _index$[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel
  000ba	83 c4 04	 add	 esp, 4

; 2959 : 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2,2)), lpObj->AccountID, lpObj->Name);

  000bd	8d 47 6f	 lea	 eax, DWORD PTR [edi+111]
  000c0	50		 push	 eax
  000c1	83 c7 64	 add	 edi, 100		; 00000064H
  000c4	57		 push	 edi
  000c5	68 02 02 00 00	 push	 514			; 00000202H
  000ca	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000cf	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000d4	50		 push	 eax
  000d5	6a 00		 push	 0
  000d7	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000dc	83 c4 10	 add	 esp, 16			; 00000010H
  000df	5e		 pop	 esi
$LN2@gObjTradeS:

; 2960 : 	}
; 2961 : }

  000e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e3	33 cd		 xor	 ecx, ebp
  000e5	5f		 pop	 edi
  000e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
?gObjTradeSave@@YAXPAUOBJECTSTRUCT@@H@Z ENDP		; gObjTradeSave
_TEXT	ENDS
PUBLIC	??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	?gObjMemFree@@YAFH@Z				; gObjMemFree
EXTRN	?GJPUserClose@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; GJPUserClose
;	COMDAT ??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd?$CJ@ DB '('
	DB	'%s)(%d) = index over error (%d)', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjMemFree@@YAFH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?gObjMemFree@@YAFH@Z PROC				; gObjMemFree, COMDAT

; 3056 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3057 : 	int i = 0;
; 3058 : 	LPOBJ lpObj;
; 3059 : 
; 3060 : 	if ( gDisconnect == TRUE )

  00003	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect
  0000a	75 05		 jne	 SHORT $LN8@gObjMemFre

; 3061 : 	{
; 3062 : 		return -1;

  0000c	83 c8 ff	 or	 eax, -1

; 3101 : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN8@gObjMemFre:
  00011	57		 push	 edi

; 3063 : 	}
; 3064 : 
; 3065 : 	if ( index < 0 || index > OBJMAX )

  00012	8b 7d 08	 mov	 edi, DWORD PTR _index$[ebp]
  00015	81 ff e8 1c 00
	00		 cmp	 edi, 7400		; 00001ce8H
  0001b	0f 87 83 00 00
	00		 ja	 $LN6@gObjMemFre

; 3069 : 	}
; 3070 : 
; 3071 : 	lpObj = &gObj[index];

  00021	56		 push	 esi
  00022	8b f7		 mov	 esi, edi
  00024	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0002a	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3072 : 
; 3073 : 	if ( lpObj->Connected < PLAYER_CONNECTED )

  00030	80 7e 04 01	 cmp	 BYTE PTR [esi+4], 1
  00034	73 06		 jae	 SHORT $LN5@gObjMemFre

; 3074 : 	{
; 3075 : 		return false;

  00036	5e		 pop	 esi
  00037	33 c0		 xor	 eax, eax
  00039	5f		 pop	 edi

; 3101 : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN5@gObjMemFre:

; 3076 : 	}
; 3077 : 
; 3078 : 	gObjTradeSave(lpObj, index);

  0003c	57		 push	 edi
  0003d	56		 push	 esi
  0003e	e8 00 00 00 00	 call	 ?gObjTradeSave@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjTradeSave

; 3079 : 
; 3080 : 	if ( lpObj->Connected >= PLAYER_LOGGED )

  00043	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  00046	83 c4 08	 add	 esp, 8
  00049	3c 02		 cmp	 al, 2
  0004b	72 41		 jb	 SHORT $LN3@gObjMemFre

; 3081 : 	{
; 3082 : 		if ( lpObj->Type == OBJ_USER )

  0004d	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00052	75 3a		 jne	 SHORT $LN3@gObjMemFre

; 3083 : 		{
; 3084 : 			if ( lpObj->Connected == PLAYER_PLAYING )

  00054	3c 03		 cmp	 al, 3
  00056	75 2d		 jne	 SHORT $LN2@gObjMemFre

; 3085 : 			{
; 3086 : 				if (  BC_MAP_RANGE(lpObj->MapNumber) )

  00058	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  0005f	3c 0b		 cmp	 al, 11			; 0000000bH
  00061	72 16		 jb	 SHORT $LN13@gObjMemFre
  00063	b1 11		 mov	 cl, 17			; 00000011H
  00065	3a c8		 cmp	 cl, al
  00067	1b c0		 sbb	 eax, eax
  00069	40		 inc	 eax
  0006a	74 0d		 je	 SHORT $LN13@gObjMemFre

; 3087 : 				{
; 3088 : 					g_BloodCastle.SearchUserDropQuestItem(lpObj->m_Index);

  0006c	8b 16		 mov	 edx, DWORD PTR [esi]
  0006e	52		 push	 edx
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00074	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem
$LN13@gObjMemFre:

; 3089 : 				}
; 3090 : 
; 3091 : 				GJSetCharacterInfo(lpObj, index, 0);

  00079	6a 00		 push	 0
  0007b	57		 push	 edi
  0007c	56		 push	 esi
  0007d	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@gObjMemFre:

; 3092 : 			}
; 3093 : 			
; 3094 : 			GJPUserClose(lpObj);

  00085	56		 push	 esi
  00086	e8 00 00 00 00	 call	 ?GJPUserClose@@YAXPAUOBJECTSTRUCT@@@Z ; GJPUserClose
  0008b	83 c4 04	 add	 esp, 4
$LN3@gObjMemFre:

; 3095 : 		}
; 3096 : 	}
; 3097 : 
; 3098 : 	gObjViewportClose(lpObj);

  0008e	56		 push	 esi
  0008f	e8 00 00 00 00	 call	 ?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportClose
  00094	83 c4 04	 add	 esp, 4

; 3099 : 	lpObj->Connected = PLAYER_EMPTY;

  00097	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  0009b	5e		 pop	 esi

; 3100 : 	return 1;

  0009c	b8 01 00 00 00	 mov	 eax, 1
  000a1	5f		 pop	 edi

; 3101 : }

  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
$LN6@gObjMemFre:

; 3066 : 	{
; 3067 : 		LogAdd(LOG_BLACK, "(%s)(%d) = index over error (%d)", __FILE__, __LINE__, index);

  000a4	57		 push	 edi
  000a5	68 fb 0b 00 00	 push	 3067			; 00000bfbH
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd?$CJ@
  000b4	6a 00		 push	 0
  000b6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000bb	83 c4 14	 add	 esp, 20			; 00000014H

; 3068 : 		return false;

  000be	33 c0		 xor	 eax, eax
  000c0	5f		 pop	 edi

; 3101 : }

  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
?gObjMemFree@@YAFH@Z ENDP				; gObjMemFree
_TEXT	ENDS
PUBLIC	?gObjSometimeClose@@YAFH@Z			; gObjSometimeClose
EXTRN	?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z:PROC ; CGPartyDelUser
EXTRN	?GetIndex@PartyClass@@QAEHHHH@Z:PROC		; PartyClass::GetIndex
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
; Function compile flags: /Ogtp
;	COMDAT ?gObjSometimeClose@@YAFH@Z
_TEXT	SEGMENT
_pMsg$162793 = -4					; size = 4
_index$ = 8						; size = 4
?gObjSometimeClose@@YAFH@Z PROC				; gObjSometimeClose, COMDAT

; 3297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3298 : 	if ( gDisconnect == 1 )

  00004	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect
  0000b	75 07		 jne	 SHORT $LN8@gObjSometi

; 3299 : 	{
; 3300 : 		return -1;

  0000d	83 c8 ff	 or	 eax, -1

; 3334 : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
$LN8@gObjSometi:

; 3301 : 	}
; 3302 : 
; 3303 : 	if ( index < 0 || index > OBJMAX )	// deathway fix needed

  00014	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00017	3d e8 1c 00 00	 cmp	 eax, 7400		; 00001ce8H
  0001c	77 67		 ja	 SHORT $LN6@gObjSometi

; 3307 : 	}
; 3308 : 
; 3309 : 	LPOBJ lpObj = &gObj[index];

  0001e	56		 push	 esi
  0001f	8b f0		 mov	 esi, eax
  00021	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H

; 3310 : 	gObjTradeSave(lpObj, index);

  00027	50		 push	 eax
  00028	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 ?gObjTradeSave@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjTradeSave

; 3311 : 
; 3312 : 	if ( lpObj->Connected > PLAYER_CONNECTED )

  00034	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  00037	83 c4 08	 add	 esp, 8
  0003a	3c 01		 cmp	 al, 1
  0003c	76 3d		 jbe	 SHORT $LN1@gObjSometi

; 3313 : 	{
; 3314 : 		if ( lpObj->Type == OBJ_USER )

  0003e	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00043	75 36		 jne	 SHORT $LN1@gObjSometi

; 3315 : 		{
; 3316 : 			if ( lpObj->Connected == PLAYER_PLAYING )

  00045	3c 03		 cmp	 al, 3
  00047	75 32		 jne	 SHORT $LN1@gObjSometi

; 3317 : 			{
; 3318 : 				if ( lpObj->PartyNumber >= 0 )

  00049	8b 86 a8 02 00
	00		 mov	 eax, DWORD PTR [esi+680]
  0004f	85 c0		 test	 eax, eax
  00051	78 28		 js	 SHORT $LN1@gObjSometi

; 3319 : 				{
; 3320 : 					PMSG_PARTYDELUSER pMsg;
; 3321 : 					int iPartyIndex = gParty.GetIndex(lpObj->PartyNumber, lpObj->m_Index, lpObj->DBNumber);

  00053	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00056	8b 16		 mov	 edx, DWORD PTR [esi]
  00058	51		 push	 ecx
  00059	52		 push	 edx
  0005a	50		 push	 eax
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00060	e8 00 00 00 00	 call	 ?GetIndex@PartyClass@@QAEHHHH@Z ; PartyClass::GetIndex

; 3322 : 
; 3323 : 					if ( iPartyIndex >= 0 )

  00065	85 c0		 test	 eax, eax
  00067	78 12		 js	 SHORT $LN1@gObjSometi

; 3324 : 					{
; 3325 : 						pMsg.Number = iPartyIndex;

  00069	88 45 ff	 mov	 BYTE PTR _pMsg$162793[ebp+3], al

; 3326 : 						CGPartyDelUser(&pMsg, lpObj->m_Index);

  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	50		 push	 eax
  0006f	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$162793[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  00078	83 c4 08	 add	 esp, 8
$LN1@gObjSometi:

; 3327 : 					}
; 3328 : 				}
; 3329 : 			}
; 3330 : 		}
; 3331 : 	}
; 3332 : 
; 3333 : 	return 1;

  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	5e		 pop	 esi

; 3334 : }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
$LN6@gObjSometi:

; 3304 : 	{
; 3305 : 		LogAdd(LOG_BLACK, "(%s)(%d) = index over error (%d)", __FILE__, __LINE__, index);

  00085	50		 push	 eax
  00086	68 e9 0c 00 00	 push	 3305			; 00000ce9H
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd?$CJ@
  00095	6a 00		 push	 0
  00097	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0009c	83 c4 14	 add	 esp, 20			; 00000014H

; 3306 : 		return 0;

  0009f	33 c0		 xor	 eax, eax

; 3334 : }

  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?gObjSometimeClose@@YAFH@Z ENDP				; gObjSometimeClose
_TEXT	ENDS
PUBLIC	?gObjMsgProc@@YAXPAUOBJECTSTRUCT@@@Z		; gObjMsgProc
EXTRN	?gObjMonsterStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z:PROC ; gObjMonsterStateProc
; Function compile flags: /Ogtp
;	COMDAT ?gObjMsgProc@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjMsgProc@@YAXPAUOBJECTSTRUCT@@@Z PROC		; gObjMsgProc, COMDAT

; 3961 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 3962 : 	int aIndex = lpObj->m_Index;

  00006	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00009	8b 07		 mov	 eax, DWORD PTR [edi]
  0000b	8d 34 80	 lea	 esi, DWORD PTR [eax+eax*4]
  0000e	c1 e6 05	 shl	 esi, 5
  00011	81 c6 0c 00 00
	00		 add	 esi, OFFSET ?gSMMsg@@3PAY09UMessageStateMachine@@A+12
  00017	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
  0001c	8d 64 24 00	 npad	 4
$LL8@gObjMsgPro:

; 3965 : 	{
; 3966 : 		if ( gSMMsg[aIndex][n].MsgCode >= 0 )

  00020	83 7e f4 00	 cmp	 DWORD PTR [esi-12], 0
  00024	7c 47		 jl	 SHORT $LN7@gObjMsgPro

; 3967 : 		{
; 3968 : 			if ( GetTickCount() > gSMMsg[aIndex][n].MsgTime )

  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002c	3b 46 fc	 cmp	 eax, DWORD PTR [esi-4]
  0002f	76 3c		 jbe	 SHORT $LN7@gObjMsgPro

; 3969 : 			{
; 3970 : 				if ( lpObj->Type == OBJ_MONSTER || lpObj->Type == OBJ_NPC )

  00031	0f b7 47 60	 movzx	 eax, WORD PTR [edi+96]
  00035	83 f8 02	 cmp	 eax, 2
  00038	74 18		 je	 SHORT $LN2@gObjMsgPro
  0003a	83 f8 03	 cmp	 eax, 3
  0003d	74 13		 je	 SHORT $LN2@gObjMsgPro

; 3973 : 				}
; 3974 : 				else
; 3975 : 				{
; 3976 : 					gObjStateProc(lpObj, gSMMsg[aIndex][n].MsgCode, gSMMsg[aIndex][n].SendUser, gSMMsg[aIndex][n].SubCode);

  0003f	8b 06		 mov	 eax, DWORD PTR [esi]
  00041	8b 4e f8	 mov	 ecx, DWORD PTR [esi-8]
  00044	8b 56 f4	 mov	 edx, DWORD PTR [esi-12]
  00047	50		 push	 eax
  00048	51		 push	 ecx
  00049	52		 push	 edx
  0004a	57		 push	 edi
  0004b	e8 00 00 00 00	 call	 ?gObjStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z ; gObjStateProc
  00050	eb 11		 jmp	 SHORT $LN13@gObjMsgPro
$LN2@gObjMsgPro:

; 3971 : 				{
; 3972 : 					gObjMonsterStateProc(lpObj, gSMMsg[aIndex][n].MsgCode, gSMMsg[aIndex][n].SendUser, gSMMsg[aIndex][n].SubCode);

  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	8b 4e f8	 mov	 ecx, DWORD PTR [esi-8]
  00057	8b 56 f4	 mov	 edx, DWORD PTR [esi-12]
  0005a	50		 push	 eax
  0005b	51		 push	 ecx
  0005c	52		 push	 edx
  0005d	57		 push	 edi
  0005e	e8 00 00 00 00	 call	 ?gObjMonsterStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z ; gObjMonsterStateProc
$LN13@gObjMsgPro:
  00063	83 c4 10	 add	 esp, 16			; 00000010H

; 3977 : 				}
; 3978 : 
; 3979 : 				gSMMsg[aIndex][n].MsgCode = -1;

  00066	c7 46 f4 ff ff
	ff ff		 mov	 DWORD PTR [esi-12], -1
$LN7@gObjMsgPro:

; 3963 : 
; 3964 : 	for ( int n=0;n<MAX_MONSTER_SEND_MSG;n++)

  0006d	83 c6 10	 add	 esi, 16			; 00000010H
  00070	4b		 dec	 ebx
  00071	75 ad		 jne	 SHORT $LL8@gObjMsgPro
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx

; 3980 : 			}
; 3981 : 		}
; 3982 : 	}
; 3983 : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?gObjMsgProc@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; gObjMsgProc
_TEXT	ENDS
PUBLIC	?gObjStateAttackProc@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjStateAttackProc
EXTRN	?Attack@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HH@Z:PROC ; CDarkSpirit::Attack
; Function compile flags: /Ogtp
;	COMDAT ?gObjStateAttackProc@@YAXPAUOBJECTSTRUCT@@HHHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
_SubCode$ = 20						; size = 4
_SubCode2$ = 24						; size = 4
?gObjStateAttackProc@@YAXPAUOBJECTSTRUCT@@HHHH@Z PROC	; gObjStateAttackProc, COMDAT

; 4054 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4055 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00004	8b 75 10	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 0f		 js	 SHORT $LN13@gObjStateA
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 1c		 jne	 SHORT $LN8@gObjStateA
$LN13@gObjStateA:

; 4056 : 	{
; 4057 : 		LogAdd(LOG_BLACK, "error : %s %d", __FILE__, __LINE__ );

  0001a	68 d9 0f 00 00	 push	 4057			; 00000fd9H
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00029	6a 00		 push	 0
  0002b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	5e		 pop	 esi

; 4079 : 			break;
; 4080 : 	}
; 4081 : 
; 4082 : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN8@gObjStateA:

; 4058 : 		return;
; 4059 : 	}
; 4060 : 
; 4061 : 	switch ( aMsgCode )

  00036	8b 45 0c	 mov	 eax, DWORD PTR _aMsgCode$[ebp]
  00039	83 e8 32	 sub	 eax, 50			; 00000032H
  0003c	57		 push	 edi
  0003d	74 58		 je	 SHORT $LN5@gObjStateA
  0003f	48		 dec	 eax
  00040	74 25		 je	 SHORT $LN1@gObjStateA
  00042	83 e8 02	 sub	 eax, 2
  00045	0f 85 80 00 00
	00		 jne	 $LN14@gObjStateA

; 4068 : 			}
; 4069 : 			break;
; 4070 : 		case 53:
; 4071 : 			if( lpObj->Live )

  0004b	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0004e	38 47 62	 cmp	 BYTE PTR [edi+98], al
  00051	74 78		 je	 SHORT $LN14@gObjStateA

; 4072 : 			{
; 4073 : 				CMagicInf * lpMagic = gObjGetMagicSearch(lpObj, SubCode);

  00053	8b 45 14	 mov	 eax, DWORD PTR _SubCode$[ebp]
  00056	50		 push	 eax
  00057	57		 push	 edi
  00058	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch

; 4074 : 				gObjAttack(lpObj, &gObj[aIndex], lpMagic, 1, 1, 0, 0);

  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	6a 01		 push	 1
  00063	6a 01		 push	 1

; 4075 : 			}
; 4076 : 			break;

  00065	eb 4d		 jmp	 SHORT $LN15@gObjStateA
$LN1@gObjStateA:

; 4077 : 		case 51:
; 4078 : 			gDarkSpirit[lpObj->m_Index].Attack(lpObj, &gObj[aIndex], NULL, SubCode, SubCode2);

  00067	8b 4d 18	 mov	 ecx, DWORD PTR _SubCode2$[ebp]
  0006a	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00070	8b 55 14	 mov	 edx, DWORD PTR _SubCode$[ebp]
  00073	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00076	51		 push	 ecx
  00077	52		 push	 edx
  00078	6a 00		 push	 0
  0007a	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00080	56		 push	 esi
  00081	50		 push	 eax
  00082	8b 00		 mov	 eax, DWORD PTR [eax]
  00084	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00087	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gDarkSpirit@@3PAVCDarkSpirit@@A[ecx*8]
  0008e	e8 00 00 00 00	 call	 ?Attack@CDarkSpirit@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HH@Z ; CDarkSpirit::Attack
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi

; 4079 : 			break;
; 4080 : 	}
; 4081 : 
; 4082 : }

  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
$LN5@gObjStateA:

; 4062 : 	{
; 4063 : 		case 50:
; 4064 : 			if ( lpObj->Live != FALSE )

  00097	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0009a	80 7f 62 00	 cmp	 BYTE PTR [edi+98], 0
  0009e	74 2b		 je	 SHORT $LN14@gObjStateA

; 4065 : 			{
; 4066 : 				CMagicInf * lpMagic = gObjGetMagicSearch(lpObj, SubCode);

  000a0	8b 45 14	 mov	 eax, DWORD PTR _SubCode$[ebp]
  000a3	50		 push	 eax
  000a4	57		 push	 edi
  000a5	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch

; 4067 : 				gObjAttack(lpObj, &gObj[aIndex], lpMagic, 0, 1, 0, SubCode2);

  000aa	8b 4d 18	 mov	 ecx, DWORD PTR _SubCode2$[ebp]
  000ad	51		 push	 ecx
  000ae	6a 00		 push	 0
  000b0	6a 01		 push	 1
  000b2	6a 00		 push	 0
$LN15@gObjStateA:
  000b4	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000ba	50		 push	 eax
  000bb	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c1	56		 push	 esi
  000c2	57		 push	 edi
  000c3	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  000c8	83 c4 24	 add	 esp, 36			; 00000024H
$LN14@gObjStateA:
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi

; 4079 : 			break;
; 4080 : 	}
; 4081 : 
; 4082 : }

  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
?gObjStateAttackProc@@YAXPAUOBJECTSTRUCT@@HHHH@Z ENDP	; gObjStateAttackProc
_TEXT	ENDS
PUBLIC	??_C@_0EO@BHGJFFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?9?5Add?5Infinity?5Arr@ ; `string'
PUBLIC	??_C@_0EH@BDBNPHEJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Add?5Infinity?5Arrow?5Skil@ ; `string'
PUBLIC	??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ ; `string'
PUBLIC	??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ ; `string'
PUBLIC	?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@HHH@Z	; gObjLevelUp
EXTRN	?GCLevelUpMsgSend@@YAXHH@Z:PROC			; GCLevelUpMsgSend
EXTRN	?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A:BYTE ; g_SkillAdditionInfo
;	COMDAT ??_C@_0EO@BHGJFFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?9?5Add?5Infinity?5Arr@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\skilladditioninfo.h
CONST	SEGMENT
??_C@_0EO@BHGJFFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?9?5Add?5Infinity?5Arr@ DB '['
	DB	'%s][%s] Fail - Add Infinity Arrow Skill (Character Level : %d'
	DB	')(ChangeUp: %d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@BDBNPHEJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Add?5Infinity?5Arrow?5Skil@
CONST	SEGMENT
??_C@_0EH@BDBNPHEJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Add?5Infinity?5Arrow?5Skil@ DB '['
	DB	'%s][%s] Add Infinity Arrow Skill (Character Level : %d)(Chang'
	DB	'eUp: %d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
CONST	SEGMENT
??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ DB '['
	DB	'%s][%s] LevelUp PlusStatQuest Clear AddStat %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ DB 'E'
	DB	'xperience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex :'
	DB	' %d, EventType : %d', 00H			; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
CONST	ENDS
;	COMDAT ?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
tv473 = 12						; size = 4
_addexp$ = 12						; size = 4
_iMonsterType$ = 16					; size = 4
_iEventType$ = 20					; size = 4
?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@HHH@Z PROC		; gObjLevelUp, COMDAT

; 4340 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4341 : 	LogAdd(LOG_BLACK, "Experience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex : %d, EventType : %d",
; 4342 : 		lpObj->MapNumber,lpObj->X,lpObj->Y,lpObj->AccountID,lpObj->Name,lpObj->Level,lpObj->Experience - addexp,addexp,iMonsterType,iEventType);

  00003	8b 45 14	 mov	 eax, DWORD PTR _iEventType$[ebp]
  00006	8b 4d 10	 mov	 ecx, DWORD PTR _iMonsterType$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000e	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [esi+168]
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	8b 45 0c	 mov	 eax, DWORD PTR _addexp$[ebp]
  00019	51		 push	 ecx
  0001a	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR [esi+262]
  00021	50		 push	 eax
  00022	2b d0		 sub	 edx, eax
  00024	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  0002b	52		 push	 edx
  0002c	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  00033	50		 push	 eax
  00034	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  0003b	8d 7e 6f	 lea	 edi, DWORD PTR [esi+111]
  0003e	57		 push	 edi
  0003f	8d 5e 64	 lea	 ebx, DWORD PTR [esi+100]
  00042	53		 push	 ebx
  00043	51		 push	 ecx
  00044	52		 push	 edx
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
  0004b	6a 00		 push	 0
  0004d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 4343 : 
; 4344 : 	if ( lpObj->Level >= MAX_CHAR_LEVEL && lpObj->Experience >= gLevelExperience[-1+lpObj->Level] )

  00052	0f b7 86 9c 00
	00 00		 movzx	 eax, WORD PTR [esi+156]
  00059	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  0005e	83 c4 30	 add	 esp, 48			; 00000030H
  00061	66 3b c1	 cmp	 ax, cx
  00064	7c 3c		 jl	 SHORT $LN17@gObjLevelU@2
  00066	0f bf d0	 movsx	 edx, ax
  00069	8b 04 95 fc ff
	ff ff		 mov	 eax, DWORD PTR ?gLevelExperience@@3PAKA[edx*4-4]
  00070	39 86 a8 00 00
	00		 cmp	 DWORD PTR [esi+168], eax
  00076	72 2a		 jb	 SHORT $LN17@gObjLevelU@2

; 4345 : 	{
; 4346 : 		lpObj->Experience = gLevelExperience[-1+lpObj->Level];

  00078	89 86 a8 00 00
	00		 mov	 DWORD PTR [esi+168], eax

; 4347 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 112)), lpObj->m_Index, 1);

  0007e	8b 06		 mov	 eax, DWORD PTR [esi]
  00080	6a 01		 push	 1
  00082	50		 push	 eax
  00083	68 70 04 00 00	 push	 1136			; 00000470H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0008d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi

; 4348 : 		return false;

  0009d	32 c0		 xor	 al, al
  0009f	5b		 pop	 ebx

; 4440 : }

  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
$LN17@gObjLevelU@2:

; 4349 : 	}
; 4350 : 
; 4351 : 	gObjSetExpPetItem(lpObj->m_Index, addexp);

  000a2	8b 4d 0c	 mov	 ecx, DWORD PTR _addexp$[ebp]
  000a5	8b 16		 mov	 edx, DWORD PTR [esi]
  000a7	51		 push	 ecx
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 ?gObjSetExpPetItem@@YAXHH@Z ; gObjSetExpPetItem

; 4352 : 
; 4353 : 	if ( lpObj->Experience < lpObj->NextExp )

  000ae	8b 86 ac 00 00
	00		 mov	 eax, DWORD PTR [esi+172]
  000b4	83 c4 08	 add	 esp, 8
  000b7	39 86 a8 00 00
	00		 cmp	 DWORD PTR [esi+168], eax

; 4354 : 	{
; 4355 : 		return true;

  000bd	0f 82 0f 02 00
	00		 jb	 $LN23@gObjLevelU@2

; 4356 : 	}
; 4357 : 
; 4358 : 	lpObj->Experience = lpObj->NextExp;
; 4359 : 	lpObj->Level ++;

  000c3	66 ff 86 9c 00
	00 00		 inc	 WORD PTR [esi+156]
  000ca	89 86 a8 00 00
	00		 mov	 DWORD PTR [esi+168], eax

; 4360 : 
; 4361 : 	if(lpObj->Class == CLASS_WIZARD)

  000d0	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  000d7	66 85 c0	 test	 ax, ax
  000da	75 0d		 jne	 SHORT $LN15@gObjLevelU@2

; 4362 : 	{
; 4363 : 		lpObj->LevelUpPoint += gServerInfo.m_Data.iLevelUp[0];

  000dc	a1 98 00 00 00	 mov	 eax, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+152
  000e1	01 86 a0 00 00
	00		 add	 DWORD PTR [esi+160], eax
  000e7	eb 43		 jmp	 SHORT $LN7@gObjLevelU@2
$LN15@gObjLevelU@2:

; 4364 : 	}
; 4365 : 	// ---
; 4366 : 	else if(lpObj->Class == CLASS_KNIGHT)

  000e9	83 f8 01	 cmp	 eax, 1
  000ec	75 08		 jne	 SHORT $LN13@gObjLevelU@2

; 4367 : 	{
; 4368 : 		lpObj->LevelUpPoint += gServerInfo.m_Data.iLevelUp[1];

  000ee	8b 0d 9c 00 00
	00		 mov	 ecx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+156
  000f4	eb 30		 jmp	 SHORT $LN24@gObjLevelU@2
$LN13@gObjLevelU@2:

; 4369 : 	}
; 4370 : 	// ---
; 4371 : 	else if(lpObj->Class == CLASS_ELF)

  000f6	83 f8 02	 cmp	 eax, 2
  000f9	75 0e		 jne	 SHORT $LN11@gObjLevelU@2

; 4372 : 	{
; 4373 : 		lpObj->LevelUpPoint += gServerInfo.m_Data.iLevelUp[2];

  000fb	8b 15 a0 00 00
	00		 mov	 edx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+160
  00101	01 96 a0 00 00
	00		 add	 DWORD PTR [esi+160], edx
  00107	eb 23		 jmp	 SHORT $LN7@gObjLevelU@2
$LN11@gObjLevelU@2:

; 4374 : 	}
; 4375 : 	// ---
; 4376 : 	else if(lpObj->Class == CLASS_MAGUMSA)

  00109	83 f8 03	 cmp	 eax, 3
  0010c	75 0d		 jne	 SHORT $LN9@gObjLevelU@2

; 4377 : 	{
; 4378 : 		lpObj->LevelUpPoint += gServerInfo.m_Data.iLevelUp[3];

  0010e	a1 a4 00 00 00	 mov	 eax, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+164
  00113	01 86 a0 00 00
	00		 add	 DWORD PTR [esi+160], eax
  00119	eb 11		 jmp	 SHORT $LN7@gObjLevelU@2
$LN9@gObjLevelU@2:

; 4379 : 	}
; 4380 : 	// ---
; 4381 : 	else if(lpObj->Class == CLASS_DARKLORD)

  0011b	83 f8 04	 cmp	 eax, 4
  0011e	75 0c		 jne	 SHORT $LN7@gObjLevelU@2

; 4382 : 	{
; 4383 : 		lpObj->LevelUpPoint += gServerInfo.m_Data.iLevelUp[4];

  00120	8b 0d a8 00 00
	00		 mov	 ecx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+168
$LN24@gObjLevelU@2:
  00126	01 8e a0 00 00
	00		 add	 DWORD PTR [esi+160], ecx
$LN7@gObjLevelU@2:

; 4384 : 	}
; 4385 : 
; 4386 : 	if ( lpObj->PlusStatQuestClear != false )

  0012c	80 be 88 00 00
	00 00		 cmp	 BYTE PTR [esi+136], 0
  00133	74 24		 je	 SHORT $LN6@gObjLevelU@2

; 4387 : 	{
; 4388 : 		lpObj->LevelUpPoint += gServerInfo.m_Data.iLevelUp[5];

  00135	8b 15 ac 00 00
	00		 mov	 edx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+172
  0013b	01 96 a0 00 00
	00		 add	 DWORD PTR [esi+160], edx
  00141	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]

; 4389 : 		LogAdd(LOG_BLACK, "[%s][%s] LevelUp PlusStatQuest Clear AddStat %d",
; 4390 : 			lpObj->AccountID, lpObj->Name, lpObj->LevelUpPoint);

  00147	50		 push	 eax
  00148	57		 push	 edi
  00149	53		 push	 ebx
  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
  0014f	6a 00		 push	 0
  00151	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00156	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@gObjLevelU@2:

; 4391 : 	}
; 4392 : 
; 4393 : 	gObjCalCharacter(lpObj->m_Index);

  00159	8b 06		 mov	 eax, DWORD PTR [esi]
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 4394 : 
; 4395 : 	lpObj->MaxLife += DCInfo.DefClass[ lpObj->Class ].LevelLife;

  00161	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00168	69 c0 60 09 00
	00		 imul	 eax, 2400		; 00000960H
  0016e	83 c4 04	 add	 esp, 4

; 4396 : 	lpObj->MaxMana += DCInfo.DefClass[ lpObj->Class ].LevelMana;
; 4397 : 	lpObj->Life = lpObj->MaxLife;
; 4398 : 	lpObj->Mana = lpObj->MaxMana;
; 4399 : 
; 4400 : 	lpObj->Life = lpObj->MaxLife + lpObj->AddLife;
; 4401 : 	lpObj->Mana = lpObj->MaxMana + lpObj->AddMana;
; 4402 : 	
; 4403 : 	GCReFillSend(lpObj->m_Index,lpObj->Life,0xFF,0);

  00171	6a 00		 push	 0
  00173	d9 80 10 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  00179	68 ff 00 00 00	 push	 255			; 000000ffH
  0017e	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  00184	d9 9e c0 00 00
	00		 fstp	 DWORD PTR [esi+192]
  0018a	d9 80 1c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  00190	d8 86 d4 00 00
	00		 fadd	 DWORD PTR [esi+212]
  00196	d9 9e d4 00 00
	00		 fstp	 DWORD PTR [esi+212]
  0019c	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]
  001a2	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  001a8	d9 5d 0c	 fstp	 DWORD PTR tv473[ebp]
  001ab	d9 45 0c	 fld	 DWORD PTR tv473[ebp]
  001ae	d9 96 bc 00 00
	00		 fst	 DWORD PTR [esi+188]
  001b4	db 86 10 01 00
	00		 fild	 DWORD PTR [esi+272]
  001ba	d8 86 d4 00 00
	00		 fadd	 DWORD PTR [esi+212]
  001c0	d9 9e d0 00 00
	00		 fstp	 DWORD PTR [esi+208]
  001c6	e8 00 00 00 00	 call	 __ftol2_sse
  001cb	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001cd	50		 push	 eax
  001ce	51		 push	 ecx
  001cf	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEE@Z ; GCReFillSend

; 4404 : 
; 4405 : 	gObjNextExpCal(lpObj);	

  001d4	56		 push	 esi
  001d5	e8 00 00 00 00	 call	 ?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNextExpCal

; 4406 : 	LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2, 8)), lpObj->AccountID, lpObj->Name, lpObj->Level);

  001da	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  001e1	83 c4 14	 add	 esp, 20			; 00000014H
  001e4	52		 push	 edx
  001e5	57		 push	 edi
  001e6	53		 push	 ebx
  001e7	68 08 02 00 00	 push	 520			; 00000208H
  001ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001f1	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001f6	50		 push	 eax
  001f7	6a 00		 push	 0
  001f9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001fe	83 c4 14	 add	 esp, 20			; 00000014H

; 4407 : 
; 4408 : 	if(lpObj->Class == CLASS_ELF)

  00201	66 83 be 98 00
	00 00 02	 cmp	 WORD PTR [esi+152], 2
  00209	0f 85 81 00 00
	00		 jne	 $LN22@gObjLevelU@2

; 4409 : 	{
; 4410 : 		if(lpObj->Level >= g_SkillAdditionInfo.GetInfinityArrowUseLevel() && lpObj->ChangeUP == 1)

  0020f	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  00216	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+8
  0021c	7c 72		 jl	 SHORT $LN22@gObjLevelU@2
  0021e	80 be 9b 00 00
	00 01		 cmp	 BYTE PTR [esi+155], 1
  00225	75 69		 jne	 SHORT $LN22@gObjLevelU@2

; 4411 : 		{
; 4412 : 			int iAddSkillPosition = gObjMagicAdd(lpObj,0x4D,0);

  00227	6a 00		 push	 0
  00229	6a 4d		 push	 77			; 0000004dH
  0022b	56		 push	 esi
  0022c	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  00231	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4413 : 
; 4414 : 			if(iAddSkillPosition >= 0)

  00234	85 c0		 test	 eax, eax
  00236	78 37		 js	 SHORT $LN3@gObjLevelU@2

; 4415 : 			{
; 4416 : 				GCMagicListOneSend(lpObj->m_Index,iAddSkillPosition,0x4D,0xDC,0,0);

  00238	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0023a	6a 00		 push	 0
  0023c	6a 00		 push	 0
  0023e	68 dc 00 00 00	 push	 220			; 000000dcH
  00243	6a 4d		 push	 77			; 0000004dH
  00245	50		 push	 eax
  00246	51		 push	 ecx
  00247	e8 00 00 00 00	 call	 ?GCMagicListOneSend@@YAXHDEEEE@Z ; GCMagicListOneSend

; 4417 : 				LogAdd(LOG_BLACK, "[%s][%s] Add Infinity Arrow Skill (Character Level : %d)(ChangeUp: %d)",
; 4418 : 					lpObj->AccountID,lpObj->Name,lpObj->Level,lpObj->ChangeUP);

  0024c	0f b6 96 9b 00
	00 00		 movzx	 edx, BYTE PTR [esi+155]
  00253	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  0025a	52		 push	 edx
  0025b	50		 push	 eax
  0025c	57		 push	 edi
  0025d	53		 push	 ebx
  0025e	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@BDBNPHEJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Add?5Infinity?5Arrow?5Skil@
  00263	6a 00		 push	 0
  00265	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0026a	83 c4 30	 add	 esp, 48			; 00000030H

; 4419 : 			}
; 4420 : 			else

  0026d	eb 21		 jmp	 SHORT $LN22@gObjLevelU@2
$LN3@gObjLevelU@2:

; 4421 : 			{
; 4422 : 				LogAdd(LOG_BLACK, "[%s][%s] Fail - Add Infinity Arrow Skill (Character Level : %d)(ChangeUp: %d)",
; 4423 : 					lpObj->AccountID,lpObj->Name,lpObj->Level,lpObj->ChangeUP);

  0026f	0f b6 8e 9b 00
	00 00		 movzx	 ecx, BYTE PTR [esi+155]
  00276	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  0027d	51		 push	 ecx
  0027e	52		 push	 edx
  0027f	57		 push	 edi
  00280	53		 push	 ebx
  00281	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@BHGJFFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?9?5Add?5Infinity?5Arr@
  00286	6a 00		 push	 0
  00288	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0028d	83 c4 18	 add	 esp, 24			; 00000018H
$LN22@gObjLevelU@2:

; 4424 : 			}
; 4425 : 		}
; 4426 : 	}
; 4427 : 
; 4428 : 
; 4429 : 	if((GetTickCount()-lpObj->AutoSaveTime) > 30000)

  00290	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  00296	ff d7		 call	 edi
  00298	2b 46 30	 sub	 eax, DWORD PTR [esi+48]
  0029b	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  002a0	76 13		 jbe	 SHORT $LN1@gObjLevelU@2

; 4430 : 	{
; 4431 : 		lpObj->AutoSaveTime = GetTickCount();

  002a2	ff d7		 call	 edi
  002a4	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 4432 : 		GJSetCharacterInfo(lpObj, lpObj->m_Index, 0);

  002a7	8b 06		 mov	 eax, DWORD PTR [esi]
  002a9	6a 00		 push	 0
  002ab	50		 push	 eax
  002ac	56		 push	 esi
  002ad	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  002b2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjLevelU@2:

; 4433 : 	}
; 4434 : 
; 4435 : 	gObjSetBP(lpObj->m_Index);

  002b5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002b7	51		 push	 ecx
  002b8	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 4436 : 	GCLevelUpMsgSend(lpObj->m_Index, 1);

  002bd	8b 16		 mov	 edx, DWORD PTR [esi]
  002bf	6a 01		 push	 1
  002c1	52		 push	 edx
  002c2	e8 00 00 00 00	 call	 ?GCLevelUpMsgSend@@YAXHH@Z ; GCLevelUpMsgSend

; 4437 : 	gObjCalcMaxLifePower(lpObj->m_Index);

  002c7	8b 06		 mov	 eax, DWORD PTR [esi]
  002c9	50		 push	 eax
  002ca	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower
  002cf	83 c4 10	 add	 esp, 16			; 00000010H
$LN23@gObjLevelU@2:

; 4438 : 
; 4439 : 	return true;

  002d2	5f		 pop	 edi
  002d3	5e		 pop	 esi
  002d4	b0 01		 mov	 al, 1
  002d6	5b		 pop	 ebx

; 4440 : }

  002d7	5d		 pop	 ebp
  002d8	c3		 ret	 0
?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@HHH@Z ENDP		; gObjLevelUp
_TEXT	ENDS
PUBLIC	??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?gObjMonsterItemLoadScript@@YAXPAUOBJECTSTRUCT@@PAD@Z ; gObjMonsterItemLoadScript
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
;	COMDAT ??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs?$AA@ DB 'file open error %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjMonsterItemLoadScript@@YAXPAUOBJECTSTRUCT@@PAD@Z
_TEXT	SEGMENT
_op1$ = -12						; size = 4
_op2$ = -8						; size = 4
_incount$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_script_file$ = 12					; size = 4
?gObjMonsterItemLoadScript@@YAXPAUOBJECTSTRUCT@@PAD@Z PROC ; gObjMonsterItemLoadScript, COMDAT

; 4525 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 4526 : 	int Token;
; 4527 : 	int type;
; 4528 : 	int index;
; 4529 : 	int level;
; 4530 : 	int op1;
; 4531 : 	int op2;
; 4532 : 	int op3;
; 4533 : 	int incount;
; 4534 : 	
; 4535 : 	SMDFile=fopen(script_file, "r");

  00007	8b 75 0c	 mov	 esi, DWORD PTR _script_file$[ebp]
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _fopen
  00015	83 c4 08	 add	 esp, 8
  00018	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 4536 : 
; 4537 : 	if (SMDFile == 0)

  0001d	85 c0		 test	 eax, eax
  0001f	75 13		 jne	 SHORT $LN7@gObjMonste@4

; 4538 : 	{
; 4539 : 		MsgBox("file open error %s", script_file);

  00021	56		 push	 esi
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs?$AA@
  00027	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0002c	83 c4 08	 add	 esp, 8
  0002f	5e		 pop	 esi

; 4587 : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN7@gObjMonste@4:

; 4540 : 		return;
; 4541 : 	}
; 4542 : 	incount=0;

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _incount$[ebp], 0

; 4543 : 
; 4544 : 	while ( true )
; 4545 : 	{
; 4546 : 		Token=GetToken();

  0003b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 4547 : 		
; 4548 : 		if (Token == 2)

  00040	83 f8 02	 cmp	 eax, 2
  00043	0f 84 af 00 00
	00		 je	 $LN12@gObjMonste@4
  00049	53		 push	 ebx
  0004a	57		 push	 edi
  0004b	eb 03 8d 49 00	 npad	 5
$LL6@gObjMonste@4:

; 4549 : 		{
; 4550 : 			break;
; 4551 : 		}
; 4552 : 
; 4553 : 		if (Token == 1)

  00050	83 f8 01	 cmp	 eax, 1
  00053	0f 85 8f 00 00
	00		 jne	 $LN14@gObjMonste@4

; 4554 : 		{
; 4555 : 			type=TokenNumber;

  00059	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0005f	e8 00 00 00 00	 call	 __ftol2_sse
  00064	8b f0		 mov	 esi, eax

; 4556 : 
; 4557 : 			Token=GetToken();

  00066	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 4558 : 			index=TokenNumber;

  0006b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00071	e8 00 00 00 00	 call	 __ftol2_sse
  00076	8b f8		 mov	 edi, eax

; 4559 : 
; 4560 : 			Token=GetToken();

  00078	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 4561 : 			level=TokenNumber;

  0007d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00083	e8 00 00 00 00	 call	 __ftol2_sse
  00088	8b d8		 mov	 ebx, eax

; 4562 : 
; 4563 : 			Token=GetToken();

  0008a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 4564 : 			op1=TokenNumber;

  0008f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00095	e8 00 00 00 00	 call	 __ftol2_sse
  0009a	89 45 f4	 mov	 DWORD PTR _op1$[ebp], eax

; 4565 : 
; 4566 : 			Token=GetToken();

  0009d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 4567 : 			op2=TokenNumber;

  000a2	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000a8	e8 00 00 00 00	 call	 __ftol2_sse
  000ad	89 45 f8	 mov	 DWORD PTR _op2$[ebp], eax

; 4568 : 
; 4569 : 			Token=GetToken();

  000b0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 4570 : 			op3=TokenNumber;

  000b5	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000bb	e8 00 00 00 00	 call	 __ftol2_sse

; 4571 : 
; 4572 : 			if (  gObjMonsterInventoryInsertItem(lpObj, type, index, level, op1, op2, op3)  != 0xFF)

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR _op1$[ebp]
  000c3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000c6	50		 push	 eax
  000c7	8b 45 f8	 mov	 eax, DWORD PTR _op2$[ebp]
  000ca	50		 push	 eax
  000cb	51		 push	 ecx
  000cc	53		 push	 ebx
  000cd	57		 push	 edi
  000ce	56		 push	 esi
  000cf	52		 push	 edx
  000d0	e8 00 00 00 00	 call	 ?gObjMonsterInventoryInsertItem@@YAEPAUOBJECTSTRUCT@@HHHHHH@Z ; gObjMonsterInventoryInsertItem
  000d5	83 c4 1c	 add	 esp, 28			; 0000001cH
  000d8	3c ff		 cmp	 al, 255			; 000000ffH
  000da	74 0c		 je	 SHORT $LN14@gObjMonste@4

; 4573 : 			{
; 4574 : 				incount++;

  000dc	8b 45 fc	 mov	 eax, DWORD PTR _incount$[ebp]
  000df	40		 inc	 eax
  000e0	89 45 fc	 mov	 DWORD PTR _incount$[ebp], eax

; 4575 : 
; 4576 : 				if (incount > 75)

  000e3	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  000e6	7f 0e		 jg	 SHORT $LN15@gObjMonste@4
$LN14@gObjMonste@4:

; 4543 : 
; 4544 : 	while ( true )
; 4545 : 	{
; 4546 : 		Token=GetToken();

  000e8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 4547 : 		
; 4548 : 		if (Token == 2)

  000ed	83 f8 02	 cmp	 eax, 2
  000f0	0f 85 5a ff ff
	ff		 jne	 $LL6@gObjMonste@4
$LN15@gObjMonste@4:
  000f6	5f		 pop	 edi
  000f7	5b		 pop	 ebx
$LN12@gObjMonste@4:

; 4577 : 				{
; 4578 : 					break;
; 4579 : 				}
; 4580 : 			}
; 4581 : 		}
; 4582 : 		
; 4583 : 	}
; 4584 : 
; 4585 : 
; 4586 : 	fclose(SMDFile);

  000f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 _fclose
  00103	83 c4 04	 add	 esp, 4
  00106	5e		 pop	 esi

; 4587 : }

  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c3		 ret	 0
?gObjMonsterItemLoadScript@@YAXPAUOBJECTSTRUCT@@PAD@Z ENDP ; gObjMonsterItemLoadScript
_TEXT	ENDS
PUBLIC	?gObjMonsterExpSingle@@YAHPAUOBJECTSTRUCT@@0HHAA_N@Z ; gObjMonsterExpSingle
EXTRN	?GetExperience@CVip@@QAEMH@Z:PROC		; CVip::GetExperience
EXTRN	?gVip@@3VCVip@@A:BYTE				; gVip
EXTRN	?gObjMonsterExpSingle@CDevilSquare@@QAEHPAUOBJECTSTRUCT@@0HH@Z:PROC ; CDevilSquare::gObjMonsterExpSingle
EXTRN	?g_DevilSquare@@3VCDevilSquare@@A:BYTE		; g_DevilSquare
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterExpSingle@@YAHPAUOBJECTSTRUCT@@0HHAA_N@Z
_TEXT	SEGMENT
_exp$ = 8						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_dmg$ = 16						; size = 4
_tot_dmg$ = 20						; size = 4
_bSendExp$ = 24						; size = 4
?gObjMonsterExpSingle@@YAHPAUOBJECTSTRUCT@@0HHAA_N@Z PROC ; gObjMonsterExpSingle, COMDAT

; 6586 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 6587 : 
; 6588 : 	if(DS_MAP_RANGE(lpObj->MapNumber))

  00004	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00007	8a 87 09 01 00
	00		 mov	 al, BYTE PTR [edi+265]
  0000d	3c 09		 cmp	 al, 9
  0000f	74 0d		 je	 SHORT $LN19@gObjMonste@5
  00011	33 c9		 xor	 ecx, ecx
  00013	3c 20		 cmp	 al, 32			; 00000020H
  00015	0f 94 c1	 sete	 cl
  00018	8b c1		 mov	 eax, ecx
  0001a	85 c0		 test	 eax, eax
  0001c	74 1a		 je	 SHORT $LN12@gObjMonste@5
$LN19@gObjMonste@5:

; 6589 : 	{
; 6590 : 		return g_DevilSquare.gObjMonsterExpSingle(lpObj,lpTargetObj,dmg,tot_dmg);

  0001e	8b 55 14	 mov	 edx, DWORD PTR _tot_dmg$[ebp]
  00021	8b 45 10	 mov	 eax, DWORD PTR _dmg$[ebp]
  00024	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00027	52		 push	 edx
  00028	50		 push	 eax
  00029	51		 push	 ecx
  0002a	57		 push	 edi
  0002b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  00030	e8 00 00 00 00	 call	 ?gObjMonsterExpSingle@CDevilSquare@@QAEHPAUOBJECTSTRUCT@@0HH@Z ; CDevilSquare::gObjMonsterExpSingle
  00035	5f		 pop	 edi

; 6655 : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN12@gObjMonste@5:

; 6591 : 	}
; 6592 : 
; 6593 : 	int exp;
; 6594 : 	int maxexp = 0;
; 6595 : 	int level = (lpTargetObj->Level+25)*lpTargetObj->Level/3;

  00038	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0003b	0f bf 8a 9c 00
	00 00		 movsx	 ecx, WORD PTR [edx+156]
  00042	8d 51 19	 lea	 edx, DWORD PTR [ecx+25]
  00045	0f af d1	 imul	 edx, ecx
  00048	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0004d	f7 ea		 imul	 edx
  0004f	53		 push	 ebx

; 6596 : 
; 6597 : 	if((lpTargetObj->Level+10) < lpObj->Level)

  00050	0f bf 9f 9c 00
	00 00		 movsx	 ebx, WORD PTR [edi+156]
  00057	56		 push	 esi
  00058	8b f2		 mov	 esi, edx
  0005a	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0005d	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00060	03 f2		 add	 esi, edx
  00062	3b cb		 cmp	 ecx, ebx

; 6598 : 	{
; 6599 : 		level = level*(lpTargetObj->Level+10)/lpObj->Level;

  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00067	7d 12		 jge	 SHORT $LN11@gObjMonste@5
  00069	0f bf 81 9c 00
	00 00		 movsx	 eax, WORD PTR [ecx+156]
  00070	83 c0 0a	 add	 eax, 10			; 0000000aH
  00073	0f af c6	 imul	 eax, esi
  00076	99		 cdq
  00077	f7 fb		 idiv	 ebx
  00079	8b f0		 mov	 esi, eax
$LN11@gObjMonste@5:

; 6600 : 	}
; 6601 : 
; 6602 : 	if(lpTargetObj->Level >= 65)

  0007b	66 83 b9 9c 00
	00 00 41	 cmp	 WORD PTR [ecx+156], 65	; 00000041H
  00083	7c 18		 jl	 SHORT $LN10@gObjMonste@5

; 6603 : 	{
; 6604 : 		level = level + (lpTargetObj->Level-64)*(lpTargetObj->Level/4);

  00085	0f bf 81 9c 00
	00 00		 movsx	 eax, WORD PTR [ecx+156]
  0008c	8d 48 c0	 lea	 ecx, DWORD PTR [eax-64]
  0008f	99		 cdq
  00090	83 e2 03	 and	 edx, 3
  00093	03 c2		 add	 eax, edx
  00095	c1 f8 02	 sar	 eax, 2
  00098	0f af c8	 imul	 ecx, eax
  0009b	03 f1		 add	 esi, ecx
$LN10@gObjMonste@5:

; 6605 : 	}
; 6606 : 
; 6607 : 	if(level > 0)

  0009d	85 f6		 test	 esi, esi
  0009f	7e 12		 jle	 SHORT $LN9@gObjMonste@5

; 6608 : 	{
; 6609 : 		maxexp = level/2;

  000a1	8b c6		 mov	 eax, esi
  000a3	99		 cdq
  000a4	2b c2		 sub	 eax, edx
  000a6	8b d8		 mov	 ebx, eax
  000a8	d1 fb		 sar	 ebx, 1

; 6614 : 	}
; 6615 : 
; 6616 : 	if(maxexp < 1)

  000aa	83 fb 01	 cmp	 ebx, 1
  000ad	7d 0a		 jge	 SHORT $LN7@gObjMonste@5

; 6617 : 	{
; 6618 : 		exp = level;

  000af	8b d6		 mov	 edx, esi

; 6619 : 	}
; 6620 : 	else

  000b1	eb 10		 jmp	 SHORT $LN6@gObjMonste@5
$LN9@gObjMonste@5:

; 6610 : 	}
; 6611 : 	else
; 6612 : 	{
; 6613 : 		level = 0;

  000b3	33 f6		 xor	 esi, esi

; 6617 : 	{
; 6618 : 		exp = level;

  000b5	8b d6		 mov	 edx, esi

; 6619 : 	}
; 6620 : 	else

  000b7	eb 0a		 jmp	 SHORT $LN6@gObjMonste@5
$LN7@gObjMonste@5:

; 6621 : 	{
; 6622 : 		exp = level + rand()%maxexp;

  000b9	e8 00 00 00 00	 call	 _rand
  000be	99		 cdq
  000bf	f7 fb		 idiv	 ebx
  000c1	03 d6		 add	 edx, esi
$LN6@gObjMonste@5:

; 6623 : 	}
; 6624 : 
; 6625 : 	exp = dmg * exp / tot_dmg;

  000c3	8b c2		 mov	 eax, edx
  000c5	0f af 45 10	 imul	 eax, DWORD PTR _dmg$[ebp]
  000c9	99		 cdq
  000ca	f7 7d 14	 idiv	 DWORD PTR _tot_dmg$[ebp]

; 6626 : 
; 6627 : 	if(BC_MAP_RANGE(lpObj->MapNumber))

  000cd	8a 8f 09 01 00
	00		 mov	 cl, BYTE PTR [edi+265]
  000d3	89 45 08	 mov	 DWORD PTR _exp$[ebp], eax
  000d6	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  000d9	72 25		 jb	 SHORT $LN22@gObjMonste@5
  000db	ba 11 00 00 00	 mov	 edx, 17			; 00000011H
  000e0	3a d1		 cmp	 dl, cl
  000e2	1b d2		 sbb	 edx, edx
  000e4	42		 inc	 edx
  000e5	74 19		 je	 SHORT $LN22@gObjMonste@5

; 6628 : 	{
; 6629 : 		exp = exp * 50 / 100;

  000e7	8b c8		 mov	 ecx, eax
  000e9	6b c9 32	 imul	 ecx, 50			; 00000032H
  000ec	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000f1	f7 e9		 imul	 ecx
  000f3	c1 fa 05	 sar	 edx, 5
  000f6	8b c2		 mov	 eax, edx
  000f8	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000fb	03 c2		 add	 eax, edx
  000fd	89 45 08	 mov	 DWORD PTR _exp$[ebp], eax
$LN22@gObjMonste@5:

; 6630 : 	}
; 6631 : 
; 6632 : 	DWORD mymaxexp = gLevelExperience[lpObj->Level];

  00100	0f bf 8f 9c 00
	00 00		 movsx	 ecx, WORD PTR [edi+156]
  00107	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR ?gLevelExperience@@3PAKA[ecx*4]

; 6633 : 
; 6634 : 	if(exp > mymaxexp)

  0010e	3b c1		 cmp	 eax, ecx
  00110	76 03		 jbe	 SHORT $LN4@gObjMonste@5

; 6635 : 	{
; 6636 : 		exp = mymaxexp;

  00112	89 4d 08	 mov	 DWORD PTR _exp$[ebp], ecx
$LN4@gObjMonste@5:

; 6637 : 	}
; 6638 : 
; 6639 : 	exp = int(exp * gVip.GetExperience(lpObj->m_Vip));

  00115	8b 97 3c 15 00
	00		 mov	 edx, DWORD PTR [edi+5436]
  0011b	52		 push	 edx
  0011c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gVip@@3VCVip@@A ; gVip
  00121	e8 00 00 00 00	 call	 ?GetExperience@CVip@@QAEMH@Z ; CVip::GetExperience
  00126	da 4d 08	 fimul	 DWORD PTR _exp$[ebp]
  00129	e8 00 00 00 00	 call	 __ftol2_sse
  0012e	8b f0		 mov	 esi, eax

; 6640 : 
; 6641 : 	if(exp > 0)

  00130	85 f6		 test	 esi, esi
  00132	7e 2d		 jle	 SHORT $LN1@gObjMonste@5

; 6642 : 	{
; 6643 : 		if(lpObj->Type == OBJ_USER)

  00134	66 83 7f 60 01	 cmp	 WORD PTR [edi+96], 1
  00139	75 26		 jne	 SHORT $LN1@gObjMonste@5

; 6644 : 		{
; 6645 : 			lpObj->Experience += exp;
; 6646 : 
; 6647 : 			if(gObjLevelUp(lpObj,exp,lpTargetObj->Class,0) == 0)

  0013b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0013e	01 b7 a8 00 00
	00		 add	 DWORD PTR [edi+168], esi
  00144	0f b7 88 98 00
	00 00		 movzx	 ecx, WORD PTR [eax+152]
  0014b	6a 00		 push	 0
  0014d	51		 push	 ecx
  0014e	56		 push	 esi
  0014f	57		 push	 edi
  00150	e8 00 00 00 00	 call	 ?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@HHH@Z ; gObjLevelUp
  00155	83 c4 10	 add	 esp, 16			; 00000010H
  00158	84 c0		 test	 al, al
  0015a	75 05		 jne	 SHORT $LN1@gObjMonste@5

; 6648 : 			{
; 6649 : 				bSendExp = 0;

  0015c	8b 55 18	 mov	 edx, DWORD PTR _bSendExp$[ebp]
  0015f	88 02		 mov	 BYTE PTR [edx], al
$LN1@gObjMonste@5:

; 6650 : 			}
; 6651 : 		}
; 6652 : 	}
; 6653 : 
; 6654 : 	return exp;

  00161	8b c6		 mov	 eax, esi
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx
  00165	5f		 pop	 edi

; 6655 : }

  00166	5d		 pop	 ebp
  00167	c3		 ret	 0
?gObjMonsterExpSingle@@YAHPAUOBJECTSTRUCT@@0HHAA_N@Z ENDP ; gObjMonsterExpSingle
_TEXT	ENDS
PUBLIC	__real@4069000000000000
PUBLIC	_lpTargetObj$GSCopy$
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjExpParty@@YAXPAUOBJECTSTRUCT@@0HH@Z	; gObjExpParty
EXTRN	?GCKillPlayerExpSend@@YAXHHHHH@Z:PROC		; GCKillPlayerExpSend
EXTRN	?gObjExpParty@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@0HH@Z:PROC ; CDevilSquare::gObjExpParty
;	COMDAT __real@4069000000000000
CONST	SEGMENT
__real@4069000000000000 DQ 04069000000000000r	; 200
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjExpParty@@YAXPAUOBJECTSTRUCT@@0HH@Z
_TEXT	SEGMENT
tv914 = -68						; size = 4
_lpObj$GSCopy$ = -64					; size = 4
_lpTargetObj$GSCopy$ = -60				; size = 4
tv953 = -56						; size = 4
tv906 = -56						; size = 4
_totallevel$ = -52					; size = 4
tv852 = -48						; size = 4
_n$164032 = -48						; size = 4
_bApplaySetParty$ = -48					; size = 4
_viewpercent$ = -44					; size = 4
_exp$ = -40						; size = 4
_viewplayer$ = -40					; size = 4
_totalexp$ = -36					; size = 4
_level$ = -36						; size = 4
_dis$ = -32						; size = 20
_bCheckSetParty$ = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_AttackDamage$ = 16					; size = 4
_MSBFlag$ = 20						; size = 4
?gObjExpParty@@YAXPAUOBJECTSTRUCT@@0HH@Z PROC		; gObjExpParty, COMDAT

; 6660 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]

; 6661 : 	if(DS_MAP_RANGE(lpObj->MapNumber))

  00014	8a 83 09 01 00
	00		 mov	 al, BYTE PTR [ebx+265]
  0001a	56		 push	 esi
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]
  0001e	57		 push	 edi

; 6710 : 
; 6711 : 	partycount = gParty.m_PartyS[partynum].Count;
; 6712 : 
; 6713 : 	for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  0001f	89 5d c0	 mov	 DWORD PTR _lpObj$GSCopy$[ebp], ebx
  00022	89 75 c4	 mov	 DWORD PTR _lpTargetObj$GSCopy$[ebp], esi
  00025	3c 09		 cmp	 al, 9
  00027	74 0f		 je	 SHORT $LN81@gObjExpPar

; 6661 : 	if(DS_MAP_RANGE(lpObj->MapNumber))

  00029	33 c9		 xor	 ecx, ecx
  0002b	3c 20		 cmp	 al, 32			; 00000020H
  0002d	0f 94 c1	 sete	 cl
  00030	33 ff		 xor	 edi, edi
  00032	8b c1		 mov	 eax, ecx
  00034	3b c7		 cmp	 eax, edi
  00036	74 25		 je	 SHORT $LN55@gObjExpPar
$LN81@gObjExpPar:

; 6662 : 	{
; 6663 : 		g_DevilSquare.gObjExpParty(lpObj,lpTargetObj,AttackDamage,MSBFlag);

  00038	8b 55 14	 mov	 edx, DWORD PTR _MSBFlag$[ebp]
  0003b	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  0003e	52		 push	 edx
  0003f	50		 push	 eax
  00040	56		 push	 esi
  00041	53		 push	 ebx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  00047	e8 00 00 00 00	 call	 ?gObjExpParty@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@0HH@Z ; CDevilSquare::gObjExpParty
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx

; 6887 : 				}
; 6888 : 			}
; 6889 : 		}
; 6890 : 	}
; 6891 : }

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00052	33 cd		 xor	 ecx, ebp
  00054	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
$LN55@gObjExpPar:

; 6664 : 		return;
; 6665 : 	}
; 6666 : 
; 6667 : 	int n;
; 6668 : 	int exp;
; 6669 : 	int maxexp = 0;
; 6670 : 	int totalexp;
; 6671 : 	int level = (lpTargetObj->Level+25)*lpTargetObj->Level / 3;

  0005d	0f b7 86 9c 00
	00 00		 movzx	 eax, WORD PTR [esi+156]
  00064	98		 cwde
  00065	8d 48 19	 lea	 ecx, DWORD PTR [eax+25]
  00068	0f af c8	 imul	 ecx, eax
  0006b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00070	f7 e9		 imul	 ecx
  00072	8b f2		 mov	 esi, edx
  00074	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00077	03 f2		 add	 esi, edx

; 6672 : 	int number;
; 6673 : 	int partynum = 0;
; 6674 : 	int totallevel = 0;
; 6675 : 	int partylevel;
; 6676 : 	int partycount;
; 6677 : 	int dis[5];
; 6678 : 	int viewplayer = 0;
; 6679 : 	int viewpercent = 100;
; 6680 : 	int bApplaySetParty = 0;
; 6681 : 	BYTE bCheckSetParty[5];
; 6682 : 	LPOBJ lpPartyObj;
; 6683 : 
; 6684 : 	partynum = lpObj->PartyNumber;

  00079	8b 93 a8 02 00
	00		 mov	 edx, DWORD PTR [ebx+680]

; 6685 : 
; 6686 : 	int toplevel = 0;
; 6687 : 
; 6688 : 	for(int n = 0; n < MAX_USER_IN_PARTY; n++)
; 6689 : 	{
; 6690 : 		number = gParty.m_PartyS[partynum].Number[n];

  0007f	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  00082	c1 e0 04	 shl	 eax, 4
  00085	8b 88 0c 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+12]
  0008b	33 db		 xor	 ebx, ebx
  0008d	89 75 dc	 mov	 DWORD PTR _level$[ebp], esi
  00090	89 7d cc	 mov	 DWORD PTR _totallevel$[ebp], edi
  00093	89 7d d8	 mov	 DWORD PTR _viewplayer$[ebp], edi
  00096	c7 45 d4 64 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 100 ; 00000064H
  0009d	89 7d d0	 mov	 DWORD PTR _bApplaySetParty$[ebp], edi

; 6691 : 
; 6692 : 		if(number >= 0)

  000a0	3b cf		 cmp	 ecx, edi
  000a2	7c 19		 jl	 SHORT $LN53@gObjExpPar

; 6693 : 		{
; 6694 : 			lpPartyObj = &gObj[number];

  000a4	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000aa	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 6695 : 
; 6696 : 			if(lpPartyObj->Level > toplevel)

  000b0	0f bf 89 9c 00
	00 00		 movsx	 ecx, WORD PTR [ecx+156]
  000b7	3b cf		 cmp	 ecx, edi
  000b9	7e 02		 jle	 SHORT $LN53@gObjExpPar

; 6697 : 			{
; 6698 : 				toplevel = lpPartyObj->Level;

  000bb	8b d9		 mov	 ebx, ecx
$LN53@gObjExpPar:

; 6685 : 
; 6686 : 	int toplevel = 0;
; 6687 : 
; 6688 : 	for(int n = 0; n < MAX_USER_IN_PARTY; n++)
; 6689 : 	{
; 6690 : 		number = gParty.m_PartyS[partynum].Number[n];

  000bd	8b 88 10 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+16]

; 6691 : 
; 6692 : 		if(number >= 0)

  000c3	3b cf		 cmp	 ecx, edi
  000c5	7c 19		 jl	 SHORT $LN74@gObjExpPar

; 6693 : 		{
; 6694 : 			lpPartyObj = &gObj[number];

  000c7	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000cd	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 6695 : 
; 6696 : 			if(lpPartyObj->Level > toplevel)

  000d3	0f bf 89 9c 00
	00 00		 movsx	 ecx, WORD PTR [ecx+156]
  000da	3b cb		 cmp	 ecx, ebx
  000dc	7e 02		 jle	 SHORT $LN74@gObjExpPar

; 6697 : 			{
; 6698 : 				toplevel = lpPartyObj->Level;

  000de	8b d9		 mov	 ebx, ecx
$LN74@gObjExpPar:

; 6685 : 
; 6686 : 	int toplevel = 0;
; 6687 : 
; 6688 : 	for(int n = 0; n < MAX_USER_IN_PARTY; n++)
; 6689 : 	{
; 6690 : 		number = gParty.m_PartyS[partynum].Number[n];

  000e0	8b 88 14 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+20]

; 6691 : 
; 6692 : 		if(number >= 0)

  000e6	3b cf		 cmp	 ecx, edi
  000e8	7c 19		 jl	 SHORT $LN76@gObjExpPar

; 6693 : 		{
; 6694 : 			lpPartyObj = &gObj[number];

  000ea	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000f0	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 6695 : 
; 6696 : 			if(lpPartyObj->Level > toplevel)

  000f6	0f bf 89 9c 00
	00 00		 movsx	 ecx, WORD PTR [ecx+156]
  000fd	3b cb		 cmp	 ecx, ebx
  000ff	7e 02		 jle	 SHORT $LN76@gObjExpPar

; 6697 : 			{
; 6698 : 				toplevel = lpPartyObj->Level;

  00101	8b d9		 mov	 ebx, ecx
$LN76@gObjExpPar:

; 6685 : 
; 6686 : 	int toplevel = 0;
; 6687 : 
; 6688 : 	for(int n = 0; n < MAX_USER_IN_PARTY; n++)
; 6689 : 	{
; 6690 : 		number = gParty.m_PartyS[partynum].Number[n];

  00103	8b 88 18 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+24]

; 6691 : 
; 6692 : 		if(number >= 0)

  00109	3b cf		 cmp	 ecx, edi
  0010b	7c 19		 jl	 SHORT $LN78@gObjExpPar

; 6693 : 		{
; 6694 : 			lpPartyObj = &gObj[number];

  0010d	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00113	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 6695 : 
; 6696 : 			if(lpPartyObj->Level > toplevel)

  00119	0f bf 89 9c 00
	00 00		 movsx	 ecx, WORD PTR [ecx+156]
  00120	3b cb		 cmp	 ecx, ebx
  00122	7e 02		 jle	 SHORT $LN78@gObjExpPar

; 6697 : 			{
; 6698 : 				toplevel = lpPartyObj->Level;

  00124	8b d9		 mov	 ebx, ecx
$LN78@gObjExpPar:

; 6685 : 
; 6686 : 	int toplevel = 0;
; 6687 : 
; 6688 : 	for(int n = 0; n < MAX_USER_IN_PARTY; n++)
; 6689 : 	{
; 6690 : 		number = gParty.m_PartyS[partynum].Number[n];

  00126	8b 80 1c 00 00
	00		 mov	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[eax+28]

; 6691 : 
; 6692 : 		if(number >= 0)

  0012c	3b c7		 cmp	 eax, edi
  0012e	7c 18		 jl	 SHORT $LN80@gObjExpPar

; 6693 : 		{
; 6694 : 			lpPartyObj = &gObj[number];

  00130	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00136	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 6695 : 
; 6696 : 			if(lpPartyObj->Level > toplevel)

  0013b	0f bf 80 9c 00
	00 00		 movsx	 eax, WORD PTR [eax+156]
  00142	3b c3		 cmp	 eax, ebx
  00144	7e 02		 jle	 SHORT $LN80@gObjExpPar

; 6697 : 			{
; 6698 : 				toplevel = lpPartyObj->Level;

  00146	8b d8		 mov	 ebx, eax
$LN80@gObjExpPar:

; 6699 : 			}
; 6700 : 		}
; 6701 : 	}
; 6702 : 
; 6703 : 	if(!OBJMAX_RANGE(partynum))

  00148	3b d7		 cmp	 edx, edi
  0014a	7c 0f		 jl	 SHORT $LN82@gObjExpPar
  0014c	33 c0		 xor	 eax, eax
  0014e	81 fa e7 1c 00
	00		 cmp	 edx, 7399		; 00001ce7H
  00154	0f 9e c0	 setle	 al
  00157	3b c7		 cmp	 eax, edi
  00159	75 29		 jne	 SHORT $LN49@gObjExpPar
$LN82@gObjExpPar:

; 6704 : 	{
; 6705 : 		LogAdd(LOG_BLACK, "error : %s %d",__FILE__,__LINE__);

  0015b	68 31 1a 00 00	 push	 6705			; 00001a31H
  00160	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00165	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  0016a	57		 push	 edi
  0016b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00170	83 c4 10	 add	 esp, 16			; 00000010H
  00173	5f		 pop	 edi
  00174	5e		 pop	 esi
  00175	5b		 pop	 ebx

; 6887 : 				}
; 6888 : 			}
; 6889 : 		}
; 6890 : 	}
; 6891 : }

  00176	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00179	33 cd		 xor	 ecx, ebp
  0017b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
$LN49@gObjExpPar:

; 6706 : 		return;
; 6707 : 	}
; 6708 : 
; 6709 : 	memset(bCheckSetParty,0,sizeof(bCheckSetParty));

  00184	33 c0		 xor	 eax, eax
  00186	89 45 f4	 mov	 DWORD PTR _bCheckSetParty$[ebp], eax
  00189	88 45 f8	 mov	 BYTE PTR _bCheckSetParty$[ebp+4], al
  0018c	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  0018f	c1 e0 04	 shl	 eax, 4
  00192	8d 80 0c 00 00
	00		 lea	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[eax+12]
  00198	89 45 bc	 mov	 DWORD PTR tv914[ebp], eax
  0019b	89 45 c8	 mov	 DWORD PTR tv906[ebp], eax
  0019e	8b ff		 npad	 2
$LL48@gObjExpPar:

; 6714 : 	{
; 6715 : 		number = gParty.m_PartyS[partynum].Number[n];

  001a0	8b 00		 mov	 eax, DWORD PTR [eax]

; 6716 : 
; 6717 : 		if(number >= 0)

  001a2	85 c0		 test	 eax, eax
  001a4	78 67		 js	 SHORT $LN47@gObjExpPar

; 6718 : 		{
; 6719 : 			lpPartyObj = &gObj[number];
; 6720 : 
; 6721 : 			if(lpTargetObj->MapNumber == lpPartyObj->MapNumber)

  001a6	8b 4d c4	 mov	 ecx, DWORD PTR _lpTargetObj$GSCopy$[ebp]
  001a9	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  001af	8a 91 09 01 00
	00		 mov	 dl, BYTE PTR [ecx+265]
  001b5	3a 90 09 01 00
	00		 cmp	 dl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  001bb	75 50		 jne	 SHORT $LN47@gObjExpPar

; 6722 : 			{
; 6723 : 				dis[n] = gObjCalDistance(lpTargetObj,&gObj[number]);

  001bd	8d b0 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  001c3	8b c1		 mov	 eax, ecx
  001c5	56		 push	 esi
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  001cc	83 c4 08	 add	 esp, 8
  001cf	89 44 bd e0	 mov	 DWORD PTR _dis$[ebp+edi*4], eax

; 6724 : 
; 6725 : 				if(dis[n] < 10)

  001d3	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  001d6	7d 32		 jge	 SHORT $LN87@gObjExpPar

; 6726 : 				{
; 6727 : 					lpPartyObj = &gObj[number];
; 6728 : 
; 6729 : 					if(toplevel >= (lpPartyObj->Level+200))

  001d8	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  001df	8d 88 c8 00 00
	00		 lea	 ecx, DWORD PTR [eax+200]
  001e5	3b d9		 cmp	 ebx, ecx
  001e7	7c 0f		 jl	 SHORT $LN42@gObjExpPar

; 6730 : 					{
; 6731 : 						totallevel += lpPartyObj->Level+200;

  001e9	8b 55 cc	 mov	 edx, DWORD PTR _totallevel$[ebp]
  001ec	8d 84 02 c8 00
	00 00		 lea	 eax, DWORD PTR [edx+eax+200]
  001f3	89 45 cc	 mov	 DWORD PTR _totallevel$[ebp], eax

; 6732 : 					}
; 6733 : 					else

  001f6	eb 03		 jmp	 SHORT $LN41@gObjExpPar
$LN42@gObjExpPar:

; 6734 : 					{
; 6735 : 						totallevel += lpPartyObj->Level;

  001f8	01 45 cc	 add	 DWORD PTR _totallevel$[ebp], eax
$LN41@gObjExpPar:

; 6736 : 					}
; 6737 : 					viewplayer += 1;
; 6738 : 					bCheckSetParty[lpPartyObj->Class] = 1;

  001fb	0f b7 8e 98 00
	00 00		 movzx	 ecx, WORD PTR [esi+152]
  00202	ff 45 d8	 inc	 DWORD PTR _viewplayer$[ebp]
  00205	c6 44 0d f4 01	 mov	 BYTE PTR _bCheckSetParty$[ebp+ecx], 1
$LN87@gObjExpPar:
  0020a	8b 75 dc	 mov	 esi, DWORD PTR _level$[ebp]
$LN47@gObjExpPar:

; 6710 : 
; 6711 : 	partycount = gParty.m_PartyS[partynum].Count;
; 6712 : 
; 6713 : 	for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  0020d	8b 45 c8	 mov	 eax, DWORD PTR tv906[ebp]
  00210	47		 inc	 edi
  00211	83 c0 04	 add	 eax, 4
  00214	89 45 c8	 mov	 DWORD PTR tv906[ebp], eax
  00217	83 ff 05	 cmp	 edi, 5
  0021a	7c 84		 jl	 SHORT $LL48@gObjExpPar

; 6739 : 				}
; 6740 : 			}
; 6741 : 		}
; 6742 : 	}
; 6743 : 
; 6744 : 	if(bCheckSetParty[0] != 0 && bCheckSetParty[1] != 0 && bCheckSetParty[2]!= 0)

  0021c	80 7d f4 00	 cmp	 BYTE PTR _bCheckSetParty$[ebp], 0
  00220	74 13		 je	 SHORT $LN89@gObjExpPar
  00222	80 7d f5 00	 cmp	 BYTE PTR _bCheckSetParty$[ebp+1], 0
  00226	74 0d		 je	 SHORT $LN89@gObjExpPar
  00228	80 7d f6 00	 cmp	 BYTE PTR _bCheckSetParty$[ebp+2], 0
  0022c	74 07		 je	 SHORT $LN89@gObjExpPar

; 6745 : 	{
; 6746 : 		bApplaySetParty = 1;

  0022e	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _bApplaySetParty$[ebp], 1
$LN89@gObjExpPar:

; 6747 : 	}
; 6748 : 
; 6749 : 	if(viewplayer > 1)

  00235	8b 55 d8	 mov	 edx, DWORD PTR _viewplayer$[ebp]
  00238	83 fa 01	 cmp	 edx, 1
  0023b	0f 8e 01 01 00
	00		 jle	 $LN39@gObjExpPar

; 6750 : 	{
; 6751 : 		if(bApplaySetParty != 0)

  00241	83 7d d0 00	 cmp	 DWORD PTR _bApplaySetParty$[ebp], 0
  00245	74 76		 je	 SHORT $LN38@gObjExpPar

; 6752 : 		{
; 6753 : 			if(viewplayer == 3)

  00247	83 fa 03	 cmp	 edx, 3
  0024a	75 1a		 jne	 SHORT $LN37@gObjExpPar

; 6754 : 			{
; 6755 : 				viewpercent = gServerInfo.m_Data.iExpParty[0];

  0024c	8b 15 f4 00 00
	00		 mov	 edx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+244

; 6787 : 			}
; 6788 : 			else
; 6789 : 			{
; 6790 : 				viewpercent = gServerInfo.m_Data.iExpParty[8];
; 6791 : 			}
; 6792 : 		}
; 6793 : 		partylevel = totallevel / viewplayer;

  00252	8b 45 cc	 mov	 eax, DWORD PTR _totallevel$[ebp]
  00255	89 55 d4	 mov	 DWORD PTR _viewpercent$[ebp], edx
  00258	99		 cdq
  00259	f7 7d d8	 idiv	 DWORD PTR _viewplayer$[ebp]

; 6794 : 	}
; 6795 : 	else

  0025c	8b 55 d8	 mov	 edx, DWORD PTR _viewplayer$[ebp]
  0025f	8b f8		 mov	 edi, eax
  00261	e9 df 00 00 00	 jmp	 $LN22@gObjExpPar
$LN37@gObjExpPar:

; 6756 : 			}
; 6757 : 			else if(viewplayer == 4)

  00266	83 fa 04	 cmp	 edx, 4
  00269	75 19		 jne	 SHORT $LN35@gObjExpPar

; 6758 : 			{
; 6759 : 				viewpercent = gServerInfo.m_Data.iExpParty[1];

  0026b	a1 f8 00 00 00	 mov	 eax, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+248
  00270	89 45 d4	 mov	 DWORD PTR _viewpercent$[ebp], eax

; 6787 : 			}
; 6788 : 			else
; 6789 : 			{
; 6790 : 				viewpercent = gServerInfo.m_Data.iExpParty[8];
; 6791 : 			}
; 6792 : 		}
; 6793 : 		partylevel = totallevel / viewplayer;

  00273	8b 45 cc	 mov	 eax, DWORD PTR _totallevel$[ebp]
  00276	99		 cdq
  00277	f7 7d d8	 idiv	 DWORD PTR _viewplayer$[ebp]

; 6794 : 	}
; 6795 : 	else

  0027a	8b 55 d8	 mov	 edx, DWORD PTR _viewplayer$[ebp]
  0027d	8b f8		 mov	 edi, eax
  0027f	e9 c1 00 00 00	 jmp	 $LN22@gObjExpPar
$LN35@gObjExpPar:

; 6760 : 			}
; 6761 : 			else if(viewplayer >= 5)

  00284	83 fa 05	 cmp	 edx, 5
  00287	7c 1a		 jl	 SHORT $LN33@gObjExpPar

; 6787 : 			}
; 6788 : 			else
; 6789 : 			{
; 6790 : 				viewpercent = gServerInfo.m_Data.iExpParty[8];
; 6791 : 			}
; 6792 : 		}
; 6793 : 		partylevel = totallevel / viewplayer;

  00289	8b 45 cc	 mov	 eax, DWORD PTR _totallevel$[ebp]
  0028c	99		 cdq
  0028d	f7 7d d8	 idiv	 DWORD PTR _viewplayer$[ebp]
  00290	8b 0d fc 00 00
	00		 mov	 ecx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+252

; 6794 : 	}
; 6795 : 	else

  00296	8b 55 d8	 mov	 edx, DWORD PTR _viewplayer$[ebp]
  00299	89 4d d4	 mov	 DWORD PTR _viewpercent$[ebp], ecx
  0029c	8b f8		 mov	 edi, eax
  0029e	e9 a2 00 00 00	 jmp	 $LN22@gObjExpPar
$LN33@gObjExpPar:

; 6762 : 			{
; 6763 : 				viewpercent = gServerInfo.m_Data.iExpParty[2];
; 6764 : 			}
; 6765 : 			else
; 6766 : 			{
; 6767 : 				viewpercent = gServerInfo.m_Data.iExpParty[3];

  002a3	8b 15 00 01 00
	00		 mov	 edx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+256

; 6787 : 			}
; 6788 : 			else
; 6789 : 			{
; 6790 : 				viewpercent = gServerInfo.m_Data.iExpParty[8];
; 6791 : 			}
; 6792 : 		}
; 6793 : 		partylevel = totallevel / viewplayer;

  002a9	8b 45 cc	 mov	 eax, DWORD PTR _totallevel$[ebp]
  002ac	89 55 d4	 mov	 DWORD PTR _viewpercent$[ebp], edx
  002af	99		 cdq
  002b0	f7 7d d8	 idiv	 DWORD PTR _viewplayer$[ebp]

; 6794 : 	}
; 6795 : 	else

  002b3	8b 55 d8	 mov	 edx, DWORD PTR _viewplayer$[ebp]
  002b6	8b f8		 mov	 edi, eax
  002b8	e9 88 00 00 00	 jmp	 $LN22@gObjExpPar
$LN38@gObjExpPar:

; 6768 : 			}
; 6769 : 		}
; 6770 : 		else
; 6771 : 		{
; 6772 : 			if(viewplayer == 2)

  002bd	83 fa 02	 cmp	 edx, 2
  002c0	75 16		 jne	 SHORT $LN30@gObjExpPar

; 6773 : 			{
; 6774 : 				viewpercent = gServerInfo.m_Data.iExpParty[4];

  002c2	a1 04 01 00 00	 mov	 eax, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+260
  002c7	89 45 d4	 mov	 DWORD PTR _viewpercent$[ebp], eax

; 6787 : 			}
; 6788 : 			else
; 6789 : 			{
; 6790 : 				viewpercent = gServerInfo.m_Data.iExpParty[8];
; 6791 : 			}
; 6792 : 		}
; 6793 : 		partylevel = totallevel / viewplayer;

  002ca	8b 45 cc	 mov	 eax, DWORD PTR _totallevel$[ebp]
  002cd	99		 cdq
  002ce	f7 7d d8	 idiv	 DWORD PTR _viewplayer$[ebp]

; 6794 : 	}
; 6795 : 	else

  002d1	8b 55 d8	 mov	 edx, DWORD PTR _viewplayer$[ebp]
  002d4	8b f8		 mov	 edi, eax
  002d6	eb 6d		 jmp	 SHORT $LN22@gObjExpPar
$LN30@gObjExpPar:

; 6775 : 			}
; 6776 : 			else if(viewplayer == 3)

  002d8	83 fa 03	 cmp	 edx, 3
  002db	75 17		 jne	 SHORT $LN28@gObjExpPar

; 6787 : 			}
; 6788 : 			else
; 6789 : 			{
; 6790 : 				viewpercent = gServerInfo.m_Data.iExpParty[8];
; 6791 : 			}
; 6792 : 		}
; 6793 : 		partylevel = totallevel / viewplayer;

  002dd	8b 45 cc	 mov	 eax, DWORD PTR _totallevel$[ebp]
  002e0	99		 cdq
  002e1	f7 7d d8	 idiv	 DWORD PTR _viewplayer$[ebp]
  002e4	8b 0d 08 01 00
	00		 mov	 ecx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+264

; 6794 : 	}
; 6795 : 	else

  002ea	8b 55 d8	 mov	 edx, DWORD PTR _viewplayer$[ebp]
  002ed	89 4d d4	 mov	 DWORD PTR _viewpercent$[ebp], ecx
  002f0	8b f8		 mov	 edi, eax
  002f2	eb 51		 jmp	 SHORT $LN22@gObjExpPar
$LN28@gObjExpPar:

; 6777 : 			{
; 6778 : 				viewpercent = gServerInfo.m_Data.iExpParty[5];
; 6779 : 			}
; 6780 : 			else if(viewplayer == 4)

  002f4	83 fa 04	 cmp	 edx, 4
  002f7	75 17		 jne	 SHORT $LN26@gObjExpPar

; 6781 : 			{
; 6782 : 				viewpercent = gServerInfo.m_Data.iExpParty[6];

  002f9	8b 15 0c 01 00
	00		 mov	 edx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+268

; 6787 : 			}
; 6788 : 			else
; 6789 : 			{
; 6790 : 				viewpercent = gServerInfo.m_Data.iExpParty[8];
; 6791 : 			}
; 6792 : 		}
; 6793 : 		partylevel = totallevel / viewplayer;

  002ff	8b 45 cc	 mov	 eax, DWORD PTR _totallevel$[ebp]
  00302	89 55 d4	 mov	 DWORD PTR _viewpercent$[ebp], edx
  00305	99		 cdq
  00306	f7 7d d8	 idiv	 DWORD PTR _viewplayer$[ebp]

; 6794 : 	}
; 6795 : 	else

  00309	8b 55 d8	 mov	 edx, DWORD PTR _viewplayer$[ebp]
  0030c	8b f8		 mov	 edi, eax
  0030e	eb 35		 jmp	 SHORT $LN22@gObjExpPar
$LN26@gObjExpPar:

; 6783 : 			}
; 6784 : 			else if(viewplayer >= 5)

  00310	83 fa 05	 cmp	 edx, 5
  00313	7c 16		 jl	 SHORT $LN24@gObjExpPar

; 6785 : 			{
; 6786 : 				viewpercent = gServerInfo.m_Data.iExpParty[7];

  00315	a1 10 01 00 00	 mov	 eax, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+272
  0031a	89 45 d4	 mov	 DWORD PTR _viewpercent$[ebp], eax

; 6787 : 			}
; 6788 : 			else
; 6789 : 			{
; 6790 : 				viewpercent = gServerInfo.m_Data.iExpParty[8];
; 6791 : 			}
; 6792 : 		}
; 6793 : 		partylevel = totallevel / viewplayer;

  0031d	8b 45 cc	 mov	 eax, DWORD PTR _totallevel$[ebp]
  00320	99		 cdq
  00321	f7 7d d8	 idiv	 DWORD PTR _viewplayer$[ebp]

; 6794 : 	}
; 6795 : 	else

  00324	8b 55 d8	 mov	 edx, DWORD PTR _viewplayer$[ebp]
  00327	8b f8		 mov	 edi, eax
  00329	eb 1a		 jmp	 SHORT $LN22@gObjExpPar
$LN24@gObjExpPar:

; 6787 : 			}
; 6788 : 			else
; 6789 : 			{
; 6790 : 				viewpercent = gServerInfo.m_Data.iExpParty[8];
; 6791 : 			}
; 6792 : 		}
; 6793 : 		partylevel = totallevel / viewplayer;

  0032b	8b 45 cc	 mov	 eax, DWORD PTR _totallevel$[ebp]
  0032e	99		 cdq
  0032f	f7 7d d8	 idiv	 DWORD PTR _viewplayer$[ebp]
  00332	8b 0d 14 01 00
	00		 mov	 ecx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+276

; 6794 : 	}
; 6795 : 	else

  00338	8b 55 d8	 mov	 edx, DWORD PTR _viewplayer$[ebp]
  0033b	89 4d d4	 mov	 DWORD PTR _viewpercent$[ebp], ecx
  0033e	8b f8		 mov	 edi, eax
  00340	eb 03		 jmp	 SHORT $LN22@gObjExpPar
$LN39@gObjExpPar:

; 6796 : 	{
; 6797 : 		partylevel = totallevel;

  00342	8b 7d cc	 mov	 edi, DWORD PTR _totallevel$[ebp]
$LN22@gObjExpPar:

; 6798 : 	}
; 6799 : 
; 6800 : 	if((lpTargetObj->Level+10) < partylevel)

  00345	8b 45 c4	 mov	 eax, DWORD PTR _lpTargetObj$GSCopy$[ebp]
  00348	0f b7 98 9c 00
	00 00		 movzx	 ebx, WORD PTR [eax+156]
  0034f	0f bf cb	 movsx	 ecx, bx
  00352	8d 41 0a	 lea	 eax, DWORD PTR [ecx+10]
  00355	3b c7		 cmp	 eax, edi
  00357	7d 0e		 jge	 SHORT $LN21@gObjExpPar

; 6801 : 	{
; 6802 : 		level = level * (lpTargetObj->Level+10) / partylevel;

  00359	0f af c6	 imul	 eax, esi
  0035c	99		 cdq
  0035d	f7 ff		 idiv	 edi
  0035f	8b 55 d8	 mov	 edx, DWORD PTR _viewplayer$[ebp]
  00362	89 45 dc	 mov	 DWORD PTR _level$[ebp], eax
  00365	8b f0		 mov	 esi, eax
$LN21@gObjExpPar:

; 6803 : 	}
; 6804 : 
; 6805 : 	if(lpTargetObj->Level >= 65)

  00367	66 83 fb 41	 cmp	 bx, 65			; 00000041H
  0036b	7c 43		 jl	 SHORT $LN18@gObjExpPar

; 6806 : 	{
; 6807 : 		if(viewplayer == 1)

  0036d	83 fa 01	 cmp	 edx, 1
  00370	75 15		 jne	 SHORT $LN19@gObjExpPar

; 6808 : 		{
; 6809 : 			level = level + (lpTargetObj->Level-64)*(lpTargetObj->Level/4);

  00372	8b c1		 mov	 eax, ecx
  00374	99		 cdq
  00375	83 e2 03	 and	 edx, 3
  00378	03 c2		 add	 eax, edx
  0037a	c1 f8 02	 sar	 eax, 2
  0037d	8d 79 c0	 lea	 edi, DWORD PTR [ecx-64]
  00380	0f af f8	 imul	 edi, eax
  00383	03 f7		 add	 esi, edi

; 6810 : 		}
; 6811 : 		else

  00385	eb 29		 jmp	 SHORT $LN18@gObjExpPar
$LN19@gObjExpPar:

; 6812 : 		{
; 6813 : 			level += (200.0 - (lpObj->Level * 0.2));

  00387	8b 4d c0	 mov	 ecx, DWORD PTR _lpObj$GSCopy$[ebp]
  0038a	0f bf 91 9c 00
	00 00		 movsx	 edx, WORD PTR [ecx+156]
  00391	89 55 d0	 mov	 DWORD PTR tv852[ebp], edx
  00394	db 45 d0	 fild	 DWORD PTR tv852[ebp]
  00397	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fc999999999999a
  0039d	dc 2d 00 00 00
	00		 fsubr	 QWORD PTR __real@4069000000000000
  003a3	da 45 dc	 fiadd	 DWORD PTR _level$[ebp]
  003a6	e8 00 00 00 00	 call	 __ftol2_sse
  003ab	89 45 dc	 mov	 DWORD PTR _level$[ebp], eax
  003ae	8b f0		 mov	 esi, eax
$LN18@gObjExpPar:

; 6814 : 		}
; 6815 : 	}
; 6816 : 
; 6817 : 	if(level > 0)

  003b0	85 f6		 test	 esi, esi
  003b2	7e 13		 jle	 SHORT $LN17@gObjExpPar

; 6818 : 	{
; 6819 : 		maxexp = level / 2;

  003b4	8b c6		 mov	 eax, esi
  003b6	99		 cdq
  003b7	2b c2		 sub	 eax, edx
  003b9	8b f8		 mov	 edi, eax
  003bb	d1 ff		 sar	 edi, 1

; 6824 : 	}
; 6825 : 
; 6826 : 	if(maxexp < 1)

  003bd	83 ff 01	 cmp	 edi, 1
  003c0	7d 14		 jge	 SHORT $LN15@gObjExpPar

; 6827 : 	{
; 6828 : 		totalexp = level;

  003c2	89 75 dc	 mov	 DWORD PTR _totalexp$[ebp], esi

; 6829 : 	}
; 6830 : 	else

  003c5	eb 1c		 jmp	 SHORT $LN14@gObjExpPar
$LN17@gObjExpPar:

; 6820 : 	}
; 6821 : 	else
; 6822 : 	{
; 6823 : 		level = 0;

  003c7	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 6824 : 	}
; 6825 : 
; 6826 : 	if(maxexp < 1)

  003ce	8b 75 dc	 mov	 esi, DWORD PTR _level$[ebp]

; 6827 : 	{
; 6828 : 		totalexp = level;

  003d1	89 75 dc	 mov	 DWORD PTR _totalexp$[ebp], esi

; 6829 : 	}
; 6830 : 	else

  003d4	eb 0d		 jmp	 SHORT $LN14@gObjExpPar
$LN15@gObjExpPar:

; 6831 : 	{
; 6832 : 		totalexp = level + rand()%maxexp;

  003d6	e8 00 00 00 00	 call	 _rand
  003db	99		 cdq
  003dc	f7 ff		 idiv	 edi
  003de	03 d6		 add	 edx, esi
  003e0	89 55 dc	 mov	 DWORD PTR _totalexp$[ebp], edx
$LN14@gObjExpPar:

; 6833 : 	}
; 6834 : 
; 6835 : 	if(lpTargetObj->Type == OBJ_MONSTER)

  003e3	8b 45 c4	 mov	 eax, DWORD PTR _lpTargetObj$GSCopy$[ebp]
  003e6	66 83 78 60 02	 cmp	 WORD PTR [eax+96], 2
  003eb	75 09		 jne	 SHORT $LN91@gObjExpPar

; 6836 : 	{
; 6837 : 		lpTargetObj->Money = totalexp;

  003ed	8b 4d dc	 mov	 ecx, DWORD PTR _totalexp$[ebp]
  003f0	89 88 b0 00 00
	00		 mov	 DWORD PTR [eax+176], ecx
$LN91@gObjExpPar:

; 6838 : 	}
; 6839 : 
; 6840 : 	for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  003f6	8b 55 bc	 mov	 edx, DWORD PTR tv914[ebp]
  003f9	33 c0		 xor	 eax, eax
  003fb	89 45 d0	 mov	 DWORD PTR _n$164032[ebp], eax
  003fe	89 55 c8	 mov	 DWORD PTR tv953[ebp], edx
$LL92@gObjExpPar:

; 6841 : 	{
; 6842 : 		number = gParty.m_PartyS[partynum].Number[n];

  00401	8b 4d c8	 mov	 ecx, DWORD PTR tv953[ebp]
  00404	8b 31		 mov	 esi, DWORD PTR [ecx]

; 6843 : 
; 6844 : 		if(number >= 0)

  00406	85 f6		 test	 esi, esi
  00408	0f 88 07 01 00
	00		 js	 $LN11@gObjExpPar

; 6845 : 		{
; 6846 : 			lpPartyObj = &gObj[number];
; 6847 : 
; 6848 : 			if(lpTargetObj->MapNumber == lpPartyObj->MapNumber && dis[n] < 10)

  0040e	8b 5d c4	 mov	 ebx, DWORD PTR _lpTargetObj$GSCopy$[ebp]
  00411	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00417	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0041d	8a 8e 09 01 00
	00		 mov	 cl, BYTE PTR [esi+265]
  00423	38 8b 09 01 00
	00		 cmp	 BYTE PTR [ebx+265], cl
  00429	0f 85 e6 00 00
	00		 jne	 $LN11@gObjExpPar
  0042f	83 7c 85 e0 0a	 cmp	 DWORD PTR _dis$[ebp+eax*4], 10 ; 0000000aH
  00434	0f 8d db 00 00
	00		 jge	 $LN11@gObjExpPar

; 6849 : 			{
; 6850 : 				DWORD mymaxexp = gLevelExperience[lpPartyObj->Level];

  0043a	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  00441	8b 3c 85 00 00
	00 00		 mov	 edi, DWORD PTR ?gLevelExperience@@3PAKA[eax*4]

; 6851 : 
; 6852 : 				exp = (totalexp * viewpercent * lpPartyObj->Level)/totallevel / 100;

  00448	0f af 45 dc	 imul	 eax, DWORD PTR _totalexp$[ebp]
  0044c	0f af 45 d4	 imul	 eax, DWORD PTR _viewpercent$[ebp]
  00450	99		 cdq
  00451	f7 7d cc	 idiv	 DWORD PTR _totallevel$[ebp]
  00454	8b d0		 mov	 edx, eax
  00456	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0045b	f7 ea		 imul	 edx
  0045d	c1 fa 05	 sar	 edx, 5
  00460	8b c2		 mov	 eax, edx
  00462	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00465	03 c2		 add	 eax, edx
  00467	89 45 d8	 mov	 DWORD PTR _exp$[ebp], eax

; 6853 : 
; 6854 : 				if(BC_MAP_RANGE(lpPartyObj->MapNumber))

  0046a	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0046d	72 22		 jb	 SHORT $LN84@gObjExpPar
  0046f	b2 11		 mov	 dl, 17			; 00000011H
  00471	3a d1		 cmp	 dl, cl
  00473	1b c9		 sbb	 ecx, ecx
  00475	41		 inc	 ecx
  00476	74 19		 je	 SHORT $LN84@gObjExpPar

; 6855 : 				{
; 6856 : 					exp = exp * 50 / 100;

  00478	8b c8		 mov	 ecx, eax
  0047a	6b c9 32	 imul	 ecx, 50			; 00000032H
  0047d	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00482	f7 e9		 imul	 ecx
  00484	c1 fa 05	 sar	 edx, 5
  00487	8b c2		 mov	 eax, edx
  00489	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0048c	03 c2		 add	 eax, edx
  0048e	89 45 d8	 mov	 DWORD PTR _exp$[ebp], eax
$LN84@gObjExpPar:

; 6857 : 				}
; 6858 : 
; 6859 : 				if(exp > mymaxexp)

  00491	3b c7		 cmp	 eax, edi
  00493	76 03		 jbe	 SHORT $LN6@gObjExpPar

; 6860 : 				{
; 6861 : 					exp = mymaxexp;

  00495	89 7d d8	 mov	 DWORD PTR _exp$[ebp], edi
$LN6@gObjExpPar:

; 6862 : 				}
; 6863 : 
; 6864 : 				if(lpPartyObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_USER)

  00498	b8 01 00 00 00	 mov	 eax, 1
  0049d	66 39 46 60	 cmp	 WORD PTR [esi+96], ax
  004a1	75 0d		 jne	 SHORT $LN5@gObjExpPar
  004a3	66 39 43 60	 cmp	 WORD PTR [ebx+96], ax
  004a7	75 07		 jne	 SHORT $LN5@gObjExpPar

; 6865 : 				{
; 6866 : 					exp = 0;

  004a9	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _exp$[ebp], 0
$LN5@gObjExpPar:

; 6867 : 				}
; 6868 : 
; 6869 : 				exp = int(exp * gVip.GetExperience(lpObj->m_Vip));

  004b0	8b 4d c0	 mov	 ecx, DWORD PTR _lpObj$GSCopy$[ebp]
  004b3	8b 91 3c 15 00
	00		 mov	 edx, DWORD PTR [ecx+5436]
  004b9	52		 push	 edx
  004ba	b9 00 00 00 00	 mov	 ecx, OFFSET ?gVip@@3VCVip@@A ; gVip
  004bf	e8 00 00 00 00	 call	 ?GetExperience@CVip@@QAEMH@Z ; CVip::GetExperience
  004c4	da 4d d8	 fimul	 DWORD PTR _exp$[ebp]
  004c7	e8 00 00 00 00	 call	 __ftol2_sse
  004cc	8b f8		 mov	 edi, eax

; 6870 : 
; 6871 : 				if(exp > 0)

  004ce	85 ff		 test	 edi, edi
  004d0	7e 25		 jle	 SHORT $LN90@gObjExpPar

; 6872 : 				{
; 6873 : 					if(lpPartyObj->Type == OBJ_USER)

  004d2	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  004d7	75 3c		 jne	 SHORT $LN11@gObjExpPar

; 6874 : 					{
; 6875 : 						lpPartyObj->Experience += exp;

  004d9	01 be a8 00 00
	00		 add	 DWORD PTR [esi+168], edi

; 6876 : 
; 6877 : 						if(gObjLevelUp(lpPartyObj,exp,lpTargetObj->Class,1) == 0)

  004df	0f b7 83 98 00
	00 00		 movzx	 eax, WORD PTR [ebx+152]
  004e6	6a 01		 push	 1
  004e8	50		 push	 eax
  004e9	57		 push	 edi
  004ea	56		 push	 esi
  004eb	e8 00 00 00 00	 call	 ?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@HHH@Z ; gObjLevelUp
  004f0	83 c4 10	 add	 esp, 16			; 00000010H
  004f3	84 c0		 test	 al, al
  004f5	74 1e		 je	 SHORT $LN11@gObjExpPar
$LN90@gObjExpPar:

; 6878 : 						{
; 6879 : 							continue;
; 6880 : 						}
; 6881 : 					}
; 6882 : 				}
; 6883 : 
; 6884 : 				if(lpPartyObj->Type == OBJ_USER)

  004f7	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  004fc	75 17		 jne	 SHORT $LN11@gObjExpPar

; 6885 : 				{
; 6886 : 					GCKillPlayerExpSend(lpPartyObj->m_Index,lpTargetObj->m_Index,exp,AttackDamage,MSBFlag);

  004fe	8b 4d 14	 mov	 ecx, DWORD PTR _MSBFlag$[ebp]
  00501	8b 55 10	 mov	 edx, DWORD PTR _AttackDamage$[ebp]
  00504	8b 03		 mov	 eax, DWORD PTR [ebx]
  00506	51		 push	 ecx
  00507	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00509	52		 push	 edx
  0050a	57		 push	 edi
  0050b	50		 push	 eax
  0050c	51		 push	 ecx
  0050d	e8 00 00 00 00	 call	 ?GCKillPlayerExpSend@@YAXHHHHH@Z ; GCKillPlayerExpSend
  00512	83 c4 14	 add	 esp, 20			; 00000014H
$LN11@gObjExpPar:

; 6838 : 	}
; 6839 : 
; 6840 : 	for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00515	8b 45 d0	 mov	 eax, DWORD PTR _n$164032[ebp]
  00518	83 45 c8 04	 add	 DWORD PTR tv953[ebp], 4
  0051c	40		 inc	 eax
  0051d	89 45 d0	 mov	 DWORD PTR _n$164032[ebp], eax
  00520	83 f8 05	 cmp	 eax, 5
  00523	0f 8c d8 fe ff
	ff		 jl	 $LL92@gObjExpPar

; 6887 : 				}
; 6888 : 			}
; 6889 : 		}
; 6890 : 	}
; 6891 : }

  00529	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0052c	5f		 pop	 edi
  0052d	5e		 pop	 esi
  0052e	33 cd		 xor	 ecx, ebp
  00530	5b		 pop	 ebx
  00531	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00536	8b e5		 mov	 esp, ebp
  00538	5d		 pop	 ebp
  00539	c3		 ret	 0
?gObjExpParty@@YAXPAUOBJECTSTRUCT@@0HH@Z ENDP		; gObjExpParty
_TEXT	ENDS
PUBLIC	?gObjGuildWarEndSend@@YAXPAUOBJECTSTRUCT@@EE@Z	; gObjGuildWarEndSend
; Function compile flags: /Ogtp
;	COMDAT ?gObjGuildWarEndSend@@YAXPAUOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_Result1$ = 12						; size = 1
_Result2$ = 16						; size = 1
?gObjGuildWarEndSend@@YAXPAUOBJECTSTRUCT@@EE@Z PROC	; gObjGuildWarEndSend, COMDAT

; 15922: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 15923: 	if(lpObj == 0)

  00004	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	75 1b		 jne	 SHORT $LN17@gObjGuildW@4

; 15924: 	{
; 15925: 		LogAdd(LOG_BLACK, "error-L3 : %s %d",__FILE__,__LINE__);

  0000b	68 35 3e 00 00	 push	 15925			; 00003e35H
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	5f		 pop	 edi

; 15975: 		}
; 15976: 	}
; 15977: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
$LN17@gObjGuildW@4:

; 15926: 		return;
; 15927: 	}
; 15928: 
; 15929: 	if(lpObj->lpGuild == 0)

  00026	8b 87 b4 02 00
	00		 mov	 eax, DWORD PTR [edi+692]
  0002c	85 c0		 test	 eax, eax
  0002e	75 1b		 jne	 SHORT $LN16@gObjGuildW@4

; 15930: 	{
; 15931: 		LogAdd(LOG_BLACK, "error-L3 : %s %d",__FILE__,__LINE__);

  00030	68 3b 3e 00 00	 push	 15931			; 00003e3bH
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00045	83 c4 10	 add	 esp, 16			; 00000010H
  00048	5f		 pop	 edi

; 15975: 		}
; 15976: 	}
; 15977: }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN16@gObjGuildW@4:

; 15932: 		return;
; 15933: 	}
; 15934: 
; 15935: 	if(lpObj->lpGuild->WarState != 1)

  0004b	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  00052	74 1c		 je	 SHORT $LN15@gObjGuildW@4

; 15936: 	{
; 15937: 		LogAdd(LOG_BLACK, "error-L3 : %s %d",__FILE__,__LINE__);

  00054	68 41 3e 00 00	 push	 15937			; 00003e41H
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  00063	6a 00		 push	 0
  00065	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0006a	83 c4 10	 add	 esp, 16			; 00000010H
  0006d	5f		 pop	 edi

; 15975: 		}
; 15976: 	}
; 15977: }

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
$LN15@gObjGuildW@4:

; 15938: 		return;
; 15939: 	}
; 15940: 
; 15941: 	if(lpObj->lpGuild->lpTargetGuildNode == 0)

  00070	83 b8 8c 05 00
	00 00		 cmp	 DWORD PTR [eax+1420], 0
  00077	75 1c		 jne	 SHORT $LN14@gObjGuildW@4

; 15942: 	{
; 15943: 		LogAdd(LOG_BLACK, "error-L3 : %s %d",__FILE__,__LINE__);

  00079	68 47 3e 00 00	 push	 15943			; 00003e47H
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  00088	6a 00		 push	 0
  0008a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0008f	83 c4 10	 add	 esp, 16			; 00000010H
  00092	5f		 pop	 edi

; 15975: 		}
; 15976: 	}
; 15977: }

  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
$LN14@gObjGuildW@4:

; 15944: 		return;
; 15945: 	}
; 15946: 
; 15947: 	if(Result1 == 1)

  00095	8b 55 0c	 mov	 edx, DWORD PTR _Result1$[ebp]
  00098	80 fa 01	 cmp	 dl, 1
  0009b	75 09		 jne	 SHORT $LN13@gObjGuildW@4

; 15948: 	{
; 15949: 		gObjGuildWarItemGive(lpObj->lpGuild,lpObj->lpGuild->lpTargetGuildNode);

  0009d	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  000a3	51		 push	 ecx
  000a4	eb 0c		 jmp	 SHORT $LN24@gObjGuildW@4
$LN13@gObjGuildW@4:

; 15950: 	}
; 15951: 	else if(Result1 == 3)

  000a6	80 fa 03	 cmp	 dl, 3
  000a9	75 10		 jne	 SHORT $LN11@gObjGuildW@4

; 15952: 	{
; 15953: 		gObjGuildWarItemGive(lpObj->lpGuild->lpTargetGuildNode,lpObj->lpGuild);

  000ab	50		 push	 eax
  000ac	8b 80 8c 05 00
	00		 mov	 eax, DWORD PTR [eax+1420]
$LN24@gObjGuildW@4:
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarItemGive
  000b8	83 c4 08	 add	 esp, 8
$LN11@gObjGuildW@4:

; 15954: 	}
; 15955: 	else if(Result1 == 1)
; 15956: 	{
; 15957: 		gObjGuildWarItemGive(lpObj->lpGuild->lpTargetGuildNode,lpObj->lpGuild);
; 15958: 	}
; 15959: 
; 15960: 	for(int n = 0; n < MAX_USER_GUILD;n++)

  000bb	53		 push	 ebx
  000bc	56		 push	 esi
  000bd	33 db		 xor	 ebx, ebx
  000bf	be a0 03 00 00	 mov	 esi, 928		; 000003a0H
  000c4	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL8@gObjGuildW@4:

; 15961: 	{
; 15962: 		if(lpObj->lpGuild->Use[n] && lpObj->lpGuild->Index[n] >= 0)

  000d0	8b 87 b4 02 00
	00		 mov	 eax, DWORD PTR [edi+692]
  000d6	80 bc 18 40 04
	00 00 00	 cmp	 BYTE PTR [eax+ebx+1088], 0
  000de	74 39		 je	 SHORT $LN7@gObjGuildW@4
  000e0	66 83 3c 06 00	 cmp	 WORD PTR [esi+eax], 0
  000e5	7c 32		 jl	 SHORT $LN7@gObjGuildW@4

; 15963: 		{
; 15964: 			gObj[lpObj->lpGuild->Index[n]].IsInBattleGround = 0;

  000e7	0f bf 04 06	 movsx	 eax, WORD PTR [esi+eax]
  000eb	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000f1	c6 80 aa 0e 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3754], 0

; 15965: 			GCGuildWarEnd(lpObj->lpGuild->Index[n],Result1,lpObj->lpGuild->lpTargetGuildNode->Name);

  000f8	8b 87 b4 02 00
	00		 mov	 eax, DWORD PTR [edi+692]
  000fe	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00104	83 c1 04	 add	 ecx, 4
  00107	51		 push	 ecx
  00108	52		 push	 edx
  00109	0f bf 14 06	 movsx	 edx, WORD PTR [esi+eax]
  0010d	52		 push	 edx
  0010e	e8 00 00 00 00	 call	 ?GCGuildWarEnd@@YAXHEPAD@Z ; GCGuildWarEnd
  00113	8b 55 0c	 mov	 edx, DWORD PTR _Result1$[ebp]
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@gObjGuildW@4:

; 15954: 	}
; 15955: 	else if(Result1 == 1)
; 15956: 	{
; 15957: 		gObjGuildWarItemGive(lpObj->lpGuild->lpTargetGuildNode,lpObj->lpGuild);
; 15958: 	}
; 15959: 
; 15960: 	for(int n = 0; n < MAX_USER_GUILD;n++)

  00119	83 c6 02	 add	 esi, 2
  0011c	43		 inc	 ebx
  0011d	81 fe 40 04 00
	00		 cmp	 esi, 1088		; 00000440H
  00123	7c ab		 jl	 SHORT $LL8@gObjGuildW@4

; 15966: 		}
; 15967: 	}
; 15968: 
; 15969: 	for(int n = 0; n < MAX_USER_GUILD;n++)

  00125	33 db		 xor	 ebx, ebx
  00127	be a0 03 00 00	 mov	 esi, 928		; 000003a0H
  0012c	8d 64 24 00	 npad	 4
$LL4@gObjGuildW@4:

; 15970: 	{
; 15971: 		if(lpObj->lpGuild->lpTargetGuildNode->Use[n] && lpObj->lpGuild->lpTargetGuildNode->Index[n] >= 0)

  00130	8b 87 b4 02 00
	00		 mov	 eax, DWORD PTR [edi+692]
  00136	8b 80 8c 05 00
	00		 mov	 eax, DWORD PTR [eax+1420]
  0013c	80 bc 18 40 04
	00 00 00	 cmp	 BYTE PTR [eax+ebx+1088], 0
  00144	74 45		 je	 SHORT $LN3@gObjGuildW@4
  00146	66 83 3c 06 00	 cmp	 WORD PTR [esi+eax], 0
  0014b	7c 3e		 jl	 SHORT $LN3@gObjGuildW@4

; 15972: 		{
; 15973: 			gObj[lpObj->lpGuild->lpTargetGuildNode->Index[n]].IsInBattleGround = 0;

  0014d	8b 8f b4 02 00
	00		 mov	 ecx, DWORD PTR [edi+692]
  00153	8b 91 8c 05 00
	00		 mov	 edx, DWORD PTR [ecx+1420]
  00159	0f bf 04 32	 movsx	 eax, WORD PTR [edx+esi]

; 15974: 			GCGuildWarEnd(lpObj->lpGuild->lpTargetGuildNode->Index[n],Result2,lpObj->lpGuild->Name);

  0015d	8b 55 10	 mov	 edx, DWORD PTR _Result2$[ebp]
  00160	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00166	c6 80 aa 0e 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3754], 0
  0016d	8b 87 b4 02 00
	00		 mov	 eax, DWORD PTR [edi+692]
  00173	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00176	8b 80 8c 05 00
	00		 mov	 eax, DWORD PTR [eax+1420]
  0017c	51		 push	 ecx
  0017d	0f bf 0c 30	 movsx	 ecx, WORD PTR [eax+esi]
  00181	52		 push	 edx
  00182	51		 push	 ecx
  00183	e8 00 00 00 00	 call	 ?GCGuildWarEnd@@YAXHEPAD@Z ; GCGuildWarEnd
  00188	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@gObjGuildW@4:

; 15966: 		}
; 15967: 	}
; 15968: 
; 15969: 	for(int n = 0; n < MAX_USER_GUILD;n++)

  0018b	83 c6 02	 add	 esi, 2
  0018e	43		 inc	 ebx
  0018f	81 fe 40 04 00
	00		 cmp	 esi, 1088		; 00000440H
  00195	7c 99		 jl	 SHORT $LL4@gObjGuildW@4
  00197	5e		 pop	 esi
  00198	5b		 pop	 ebx
  00199	5f		 pop	 edi

; 15975: 		}
; 15976: 	}
; 15977: }

  0019a	5d		 pop	 ebp
  0019b	c3		 ret	 0
?gObjGuildWarEndSend@@YAXPAUOBJECTSTRUCT@@EE@Z ENDP	; gObjGuildWarEndSend
_TEXT	ENDS
PUBLIC	?gObjGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z	; gObjGuildWarCheck
EXTRN	?gBattleGroundEnable@@YAXHH@Z:PROC		; gBattleGroundEnable
; Function compile flags: /Ogtp
;	COMDAT ?gObjGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_score$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z PROC	; gObjGuildWarCheck, COMDAT

; 16108: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 16109: 	int score = 1;
; 16110: 
; 16111: 	if(gObjTargetGuildWarCheck(lpObj,lpTargetObj)==0)

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00008	56		 push	 esi
  00009	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]
  0000c	56		 push	 esi
  0000d	53		 push	 ebx
  0000e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _score$[ebp], 1
  00015	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0001a	83 c4 08	 add	 esp, 8
  0001d	85 c0		 test	 eax, eax
  0001f	75 06		 jne	 SHORT $LN5@gObjGuildW@5
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx

; 16140: }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN5@gObjGuildW@5:
  00027	57		 push	 edi

; 16112: 	{
; 16113: 		return false;
; 16114: 	}
; 16115: 
; 16116: 	if(strcmp(lpTargetObj->Name,lpTargetObj->lpGuild->Names[0])==0)

  00028	8b be b4 02 00
	00		 mov	 edi, DWORD PTR [esi+692]
  0002e	8d 4f 2f	 lea	 ecx, DWORD PTR [edi+47]
  00031	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
$LL8@gObjGuildW@5:
  00034	8a 10		 mov	 dl, BYTE PTR [eax]
  00036	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00038	75 1a		 jne	 SHORT $LN9@gObjGuildW@5
  0003a	84 d2		 test	 dl, dl
  0003c	74 12		 je	 SHORT $LN10@gObjGuildW@5
  0003e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00041	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00044	75 0e		 jne	 SHORT $LN9@gObjGuildW@5
  00046	83 c0 02	 add	 eax, 2
  00049	83 c1 02	 add	 ecx, 2
  0004c	84 d2		 test	 dl, dl
  0004e	75 e4		 jne	 SHORT $LL8@gObjGuildW@5
$LN10@gObjGuildW@5:
  00050	33 c0		 xor	 eax, eax
  00052	eb 05		 jmp	 SHORT $LN11@gObjGuildW@5
$LN9@gObjGuildW@5:
  00054	1b c0		 sbb	 eax, eax
  00056	83 d8 ff	 sbb	 eax, -1
$LN11@gObjGuildW@5:
  00059	85 c0		 test	 eax, eax

; 16117: 	{
; 16118: 		score = 2;

  0005b	b8 02 00 00 00	 mov	 eax, 2
  00060	74 03		 je	 SHORT $LN4@gObjGuildW@5
  00062	8b 45 fc	 mov	 eax, DWORD PTR _score$[ebp]
$LN4@gObjGuildW@5:

; 16119: 	}
; 16120: 
; 16121: 	_GUILD_INFO_STRUCT * lpGuild = lpObj->lpGuild;

  00065	8b b3 b4 02 00
	00		 mov	 esi, DWORD PTR [ebx+692]

; 16122: 	_GUILD_INFO_STRUCT * lpTargetGuild = lpTargetObj->lpGuild;
; 16123: 
; 16124: 	if(gObjGuildWarProc(lpGuild,lpTargetGuild,score)==1)

  0006b	50		 push	 eax
  0006c	57		 push	 edi
  0006d	56		 push	 esi
  0006e	e8 00 00 00 00	 call	 ?gObjGuildWarProc@@YAHPAU_GUILD_INFO_STRUCT@@0H@Z ; gObjGuildWarProc
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	83 f8 01	 cmp	 eax, 1
  00079	0f 85 80 00 00
	00		 jne	 $LN1@gObjGuildW@5

; 16125: 	{
; 16126: 		if(lpGuild->WarType == 1)
; 16127: 		{
; 16128: 			gObjGuildWarEndSend(lpGuild,lpTargetGuild,1,0);

  0007f	6a 00		 push	 0
  00081	50		 push	 eax
  00082	38 86 92 05 00
	00		 cmp	 BYTE PTR [esi+1426], al
  00088	75 5a		 jne	 SHORT $LN2@gObjGuildW@5
  0008a	57		 push	 edi
  0008b	56		 push	 esi
  0008c	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ; gObjGuildWarEndSend

; 16129: 			gBattleGroundEnable(lpGuild->BattleGroundIndex,0);

  00091	0f b6 86 93 05
	00 00		 movzx	 eax, BYTE PTR [esi+1427]
  00098	6a 00		 push	 0
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ?gBattleGroundEnable@@YAXHH@Z ; gBattleGroundEnable

; 16130: 			gObjGuildWarEnd(lpGuild,lpTargetGuild);

  000a0	57		 push	 edi
  000a1	56		 push	 esi
  000a2	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  000a7	83 c4 20	 add	 esp, 32			; 00000020H

; 16131: 			cManager.BattleInfoSend(GetBattleTeamName(0,0),255,GetBattleTeamName(0,1),255);

  000aa	68 ff 00 00 00	 push	 255			; 000000ffH
  000af	6a 01		 push	 1
  000b1	6a 00		 push	 0
  000b3	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  000b8	83 c4 08	 add	 esp, 8
  000bb	50		 push	 eax
  000bc	68 ff 00 00 00	 push	 255			; 000000ffH
  000c1	6a 00		 push	 0
  000c3	6a 00		 push	 0
  000c5	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  000ca	83 c4 08	 add	 esp, 8
  000cd	50		 push	 eax
  000ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  000d3	e8 00 00 00 00	 call	 ?BattleInfoSend@CGMMng@@QAEXPADE0E@Z ; CGMMng::BattleInfoSend
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi

; 16137: 		}
; 16138: 	}
; 16139: 	return true;

  000da	b8 01 00 00 00	 mov	 eax, 1
  000df	5b		 pop	 ebx

; 16140: }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN2@gObjGuildW@5:

; 16132: 		}
; 16133: 		else
; 16134: 		{
; 16135: 			gObjGuildWarEndSend(lpObj,1,0);

  000e4	53		 push	 ebx
  000e5	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAUOBJECTSTRUCT@@EE@Z ; gObjGuildWarEndSend

; 16136: 			gObjAddMsgSendDelay(lpObj,4,lpObj->m_Index,2000,0);

  000ea	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000ec	6a 00		 push	 0
  000ee	68 d0 07 00 00	 push	 2000			; 000007d0H
  000f3	51		 push	 ecx
  000f4	6a 04		 push	 4
  000f6	53		 push	 ebx
  000f7	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  000fc	83 c4 20	 add	 esp, 32			; 00000020H
$LN1@gObjGuildW@5:

; 16137: 		}
; 16138: 	}
; 16139: 	return true;

  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	b8 01 00 00 00	 mov	 eax, 1
  00106	5b		 pop	 ebx

; 16140: }

  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c3		 ret	 0
?gObjGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ENDP	; gObjGuildWarCheck
_TEXT	ENDS
PUBLIC	?gObjGuildWarMasterClose@@YAHPAUOBJECTSTRUCT@@@Z ; gObjGuildWarMasterClose
; Function compile flags: /Ogtp
;	COMDAT ?gObjGuildWarMasterClose@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjGuildWarMasterClose@@YAHPAUOBJECTSTRUCT@@@Z PROC	; gObjGuildWarMasterClose, COMDAT

; 16143: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 16144: 	if(lpObj->GuildNumber < 1)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	83 be b0 02 00
	00 01		 cmp	 DWORD PTR [esi+688], 1
  0000e	7d 05		 jge	 SHORT $LN3@gObjGuildW@6
$LN10@gObjGuildW@6:

; 16145: 	{
; 16146: 		return false;

  00010	33 c0		 xor	 eax, eax
  00012	5e		 pop	 esi

; 16163: }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
$LN3@gObjGuildW@6:

; 16147: 	}
; 16148: 
; 16149: 	if(strcmp(lpObj->lpGuild->Names[0],lpObj->Name))

  00015	8b 86 b4 02 00
	00		 mov	 eax, DWORD PTR [esi+692]
  0001b	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  0001e	83 c0 2f	 add	 eax, 47			; 0000002fH
$LL6@gObjGuildW@6:
  00021	8a 10		 mov	 dl, BYTE PTR [eax]
  00023	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00025	75 1a		 jne	 SHORT $LN7@gObjGuildW@6
  00027	84 d2		 test	 dl, dl
  00029	74 12		 je	 SHORT $LN8@gObjGuildW@6
  0002b	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002e	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00031	75 0e		 jne	 SHORT $LN7@gObjGuildW@6
  00033	83 c0 02	 add	 eax, 2
  00036	83 c1 02	 add	 ecx, 2
  00039	84 d2		 test	 dl, dl
  0003b	75 e4		 jne	 SHORT $LL6@gObjGuildW@6
$LN8@gObjGuildW@6:
  0003d	33 c0		 xor	 eax, eax
  0003f	eb 05		 jmp	 SHORT $LN9@gObjGuildW@6
$LN7@gObjGuildW@6:
  00041	1b c0		 sbb	 eax, eax
  00043	83 d8 ff	 sbb	 eax, -1
$LN9@gObjGuildW@6:
  00046	85 c0		 test	 eax, eax

; 16150: 	{
; 16151: 		return false;

  00048	75 c6		 jne	 SHORT $LN10@gObjGuildW@6

; 16152: 	}
; 16153: 
; 16154: 	gObjGuildWarEndSend(lpObj,3,2);

  0004a	6a 02		 push	 2
  0004c	6a 03		 push	 3
  0004e	56		 push	 esi
  0004f	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAUOBJECTSTRUCT@@EE@Z ; gObjGuildWarEndSend

; 16155: 
; 16156: 	if(lpObj->lpGuild->WarType == 1 && lpObj->lpGuild->BattleGroundIndex < 1)

  00054	8b 86 b4 02 00
	00		 mov	 eax, DWORD PTR [esi+692]
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	80 b8 92 05 00
	00 01		 cmp	 BYTE PTR [eax+1426], 1
  00064	75 46		 jne	 SHORT $LN1@gObjGuildW@6
  00066	8a 80 93 05 00
	00		 mov	 al, BYTE PTR [eax+1427]
  0006c	3c 01		 cmp	 al, 1
  0006e	73 3c		 jae	 SHORT $LN1@gObjGuildW@6

; 16157: 	{
; 16158: 		gBattleGroundEnable(lpObj->lpGuild->BattleGroundIndex,0);

  00070	0f b6 c0	 movzx	 eax, al
  00073	6a 00		 push	 0
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?gBattleGroundEnable@@YAXHH@Z ; gBattleGroundEnable
  0007b	83 c4 08	 add	 esp, 8

; 16159: 		cManager.BattleInfoSend(GetBattleTeamName(0,0),255,GetBattleTeamName(0,1),255);

  0007e	68 ff 00 00 00	 push	 255			; 000000ffH
  00083	6a 01		 push	 1
  00085	6a 00		 push	 0
  00087	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  0008c	83 c4 08	 add	 esp, 8
  0008f	50		 push	 eax
  00090	68 ff 00 00 00	 push	 255			; 000000ffH
  00095	6a 00		 push	 0
  00097	6a 00		 push	 0
  00099	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  0009e	83 c4 08	 add	 esp, 8
  000a1	50		 push	 eax
  000a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  000a7	e8 00 00 00 00	 call	 ?BattleInfoSend@CGMMng@@QAEXPADE0E@Z ; CGMMng::BattleInfoSend
$LN1@gObjGuildW@6:

; 16160: 	}
; 16161: 	gObjGuildWarEnd(lpObj->lpGuild,lpObj->lpGuild->lpTargetGuildNode);

  000ac	8b 86 b4 02 00
	00		 mov	 eax, DWORD PTR [esi+692]
  000b2	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  000b8	51		 push	 ecx
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  000bf	83 c4 08	 add	 esp, 8

; 16162: 	return true;

  000c2	b8 01 00 00 00	 mov	 eax, 1
  000c7	5e		 pop	 esi

; 16163: }

  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
?gObjGuildWarMasterClose@@YAHPAUOBJECTSTRUCT@@@Z ENDP	; gObjGuildWarMasterClose
_TEXT	ENDS
PUBLIC	?MonsterAndMsgProc@@YAXXZ			; MonsterAndMsgProc
EXTRN	?Run@CDarkSpirit@@QAEXXZ:PROC			; CDarkSpirit::Run
EXTRN	?gObjMonsterProcess@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterProcess
EXTRN	?Info@CHealthBar@@QAEXPAUOBJECTSTRUCT@@@Z:PROC	; CHealthBar::Info
EXTRN	?gHealthBar@@3VCHealthBar@@A:BYTE		; gHealthBar
; Function compile flags: /Ogtp
;	COMDAT ?MonsterAndMsgProc@@YAXXZ
_TEXT	SEGMENT
tv673 = -4						; size = 4
tv307 = -4						; size = 4
?MonsterAndMsgProc@@YAXXZ PROC				; MonsterAndMsgProc, COMDAT

; 420  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 421  : 	LPOBJ lpObj;
; 422  : 	int n;
; 423  : 	int aIndex;
; 424  : 
; 425  : 	for (int n=0;n<OBJMAX;n++)

  00007	33 db		 xor	 ebx, ebx
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv307[ebp], OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  00010	be 60 00 00 00	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+96
$LL21@MonsterAnd:

; 426  : 	{
; 427  : 		lpObj = &gObj[n];
; 428  : 
; 429  : 		if ( lpObj->Connected == PLAYER_PLAYING  )

  00015	8a 46 a4	 mov	 al, BYTE PTR [esi-92]
  00018	3c 03		 cmp	 al, 3
  0001a	75 5e		 jne	 SHORT $LN18@MonsterAnd

; 430  : 		{
; 431  : 			if ( lpObj->Type == OBJ_MONSTER || lpObj->Type == OBJ_NPC) 

  0001c	0f b7 06	 movzx	 eax, WORD PTR [esi]
  0001f	83 f8 02	 cmp	 eax, 2
  00022	74 3a		 je	 SHORT $LN16@MonsterAnd
  00024	83 f8 03	 cmp	 eax, 3
  00027	74 35		 je	 SHORT $LN16@MonsterAnd

; 434  : 			}
; 435  : 			else
; 436  : 			{
; 437  : 				gObjSkillUseProcTime500(lpObj);

  00029	8d 7e a0	 lea	 edi, DWORD PTR [esi-96]
  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 ?gObjSkillUseProcTime500@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSkillUseProcTime500

; 438  : 				gObjMsgProc(lpObj);

  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ?gObjMsgProc@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMsgProc

; 439  : 				CreateFrustrum(lpObj->X, lpObj->Y, n);

  00038	0f bf 86 a6 00
	00 00		 movsx	 eax, WORD PTR [esi+166]
  0003f	0f bf 8e a4 00
	00 00		 movsx	 ecx, WORD PTR [esi+164]
  00046	53		 push	 ebx
  00047	50		 push	 eax
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  0004e	83 c4 14	 add	 esp, 20			; 00000014H

; 440  : 				// ---
; 441  : 				gHealthBar.Info(lpObj);

  00051	57		 push	 edi
  00052	b9 00 00 00 00	 mov	 ecx, OFFSET ?gHealthBar@@3VCHealthBar@@A ; gHealthBar
  00057	e8 00 00 00 00	 call	 ?Info@CHealthBar@@QAEXPAUOBJECTSTRUCT@@@Z ; CHealthBar::Info
  0005c	eb 0c		 jmp	 SHORT $LN15@MonsterAnd
$LN16@MonsterAnd:

; 432  : 			{
; 433  : 				gObjMonsterProcess(lpObj);

  0005e	8d 56 a0	 lea	 edx, DWORD PTR [esi-96]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?gObjMonsterProcess@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMonsterProcess
  00067	83 c4 04	 add	 esp, 4
$LN15@MonsterAnd:

; 442  : 			}
; 443  : 
; 444  : 			if ( lpObj->Type == OBJ_USER )

  0006a	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  0006e	75 3f		 jne	 SHORT $LN20@MonsterAnd

; 445  : 			{
; 446  : 				gDarkSpirit[n].Run();

  00070	8b 4d fc	 mov	 ecx, DWORD PTR tv307[ebp]
  00073	e8 00 00 00 00	 call	 ?Run@CDarkSpirit@@QAEXXZ ; CDarkSpirit::Run

; 447  : 			}
; 448  : 		}

  00078	eb 35		 jmp	 SHORT $LN20@MonsterAnd
$LN18@MonsterAnd:

; 449  : 		else if ( lpObj->Connected >= PLAYER_LOGGED )

  0007a	3c 02		 cmp	 al, 2
  0007c	72 31		 jb	 SHORT $LN20@MonsterAnd

; 450  : 		{
; 451  : 			if ( lpObj->Type == OBJ_USER )

  0007e	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  00082	75 2b		 jne	 SHORT $LN20@MonsterAnd

; 452  : 			{
; 453  : 				gObjMsgProc(lpObj);

  00084	8d 46 a0	 lea	 eax, DWORD PTR [esi-96]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?gObjMsgProc@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMsgProc
  0008d	83 c4 04	 add	 esp, 4

; 454  : 
; 455  : 				if ( lpObj->Connected == PLAYER_PLAYING )

  00090	80 7e a4 03	 cmp	 BYTE PTR [esi-92], 3
  00094	75 19		 jne	 SHORT $LN20@MonsterAnd

; 456  : 				{
; 457  : 					CreateFrustrum(lpObj->X, lpObj->Y, n);

  00096	0f bf 8e a6 00
	00 00		 movsx	 ecx, WORD PTR [esi+166]
  0009d	0f bf 96 a4 00
	00 00		 movsx	 edx, WORD PTR [esi+164]
  000a4	53		 push	 ebx
  000a5	51		 push	 ecx
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@MonsterAnd:

; 421  : 	LPOBJ lpObj;
; 422  : 	int n;
; 423  : 	int aIndex;
; 424  : 
; 425  : 	for (int n=0;n<OBJMAX;n++)

  000af	83 45 fc 28	 add	 DWORD PTR tv307[ebp], 40 ; 00000028H
  000b3	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  000b9	43		 inc	 ebx
  000ba	81 fe 00 53 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522496
  000c0	0f 8c 4f ff ff
	ff		 jl	 $LL21@MonsterAnd

; 458  : 				}
; 459  : 			}
; 460  : 		}
; 461  : 	}
; 462  : 
; 463  : 	for (int n=0;n<OBJMAXUSER;n++)

  000c6	be 10 00 00 00	 mov	 esi, OFFSET ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A+16
  000cb	89 75 fc	 mov	 DWORD PTR tv673[ebp], esi
  000ce	bf 00 c4 16 02	 mov	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046400
$LL9@MonsterAnd:

; 464  : 	{
; 465  : 		lpObj = &gObj[n+OBJ_STARTUSERINDEX];
; 466  : 
; 467  : 		if ( lpObj->Connected == PLAYER_PLAYING  )

  000d3	80 7f 04 03	 cmp	 BYTE PTR [edi+4], 3
  000d7	75 3d		 jne	 SHORT $LN8@MonsterAnd

; 468  : 		{
; 469  : 			aIndex = lpObj->m_Index;
; 470  : 
; 471  : 			for ( int i=0;i<MAX_MONSTER_SEND_ATTACK_MSG;i++)

  000d9	bb 32 00 00 00	 mov	 ebx, 50			; 00000032H
  000de	8b ff		 npad	 2
$LL5@MonsterAnd:

; 472  : 			{
; 473  : 				if ( gSMAttackProcMsg[n][i].MsgCode >= 0 )

  000e0	83 7e f0 00	 cmp	 DWORD PTR [esi-16], 0
  000e4	7c 2a		 jl	 SHORT $LN4@MonsterAnd

; 474  : 				{
; 475  : 					if ( GetTickCount() > gSMAttackProcMsg[n][i].MsgTime )

  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000ec	3b 46 f8	 cmp	 eax, DWORD PTR [esi-8]
  000ef	76 1f		 jbe	 SHORT $LN4@MonsterAnd

; 476  : 					{
; 477  : 						gObjStateAttackProc(lpObj, gSMAttackProcMsg[n][i].MsgCode, gSMAttackProcMsg[n][i].SendUser,
; 478  : 							gSMAttackProcMsg[n][i].SubCode, gSMAttackProcMsg[n][i].SubCode2);

  000f1	8b 06		 mov	 eax, DWORD PTR [esi]
  000f3	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  000f6	8b 56 f4	 mov	 edx, DWORD PTR [esi-12]
  000f9	50		 push	 eax
  000fa	8b 46 f0	 mov	 eax, DWORD PTR [esi-16]
  000fd	51		 push	 ecx
  000fe	52		 push	 edx
  000ff	50		 push	 eax
  00100	57		 push	 edi
  00101	e8 00 00 00 00	 call	 ?gObjStateAttackProc@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjStateAttackProc
  00106	83 c4 14	 add	 esp, 20			; 00000014H

; 479  : 						gSMAttackProcMsg[n][i].MsgCode = -1;

  00109	c7 46 f0 ff ff
	ff ff		 mov	 DWORD PTR [esi-16], -1
$LN4@MonsterAnd:

; 468  : 		{
; 469  : 			aIndex = lpObj->m_Index;
; 470  : 
; 471  : 			for ( int i=0;i<MAX_MONSTER_SEND_ATTACK_MSG;i++)

  00110	83 c6 14	 add	 esi, 20			; 00000014H
  00113	4b		 dec	 ebx
  00114	75 ca		 jne	 SHORT $LL5@MonsterAnd
$LN8@MonsterAnd:

; 458  : 				}
; 459  : 			}
; 460  : 		}
; 461  : 	}
; 462  : 
; 463  : 	for (int n=0;n<OBJMAXUSER;n++)

  00116	8b 75 fc	 mov	 esi, DWORD PTR tv673[ebp]
  00119	81 c7 64 15 00
	00		 add	 edi, 5476		; 00001564H
  0011f	81 c6 e8 03 00
	00		 add	 esi, 1000		; 000003e8H
  00125	89 75 fc	 mov	 DWORD PTR tv673[ebp], esi
  00128	81 ff a0 52 6a
	02		 cmp	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522400
  0012e	7c a3		 jl	 SHORT $LL9@MonsterAnd
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	5b		 pop	 ebx

; 480  : 					}
; 481  : 				}
; 482  : 			}
; 483  : 		}
; 484  : 	}
; 485  : }

  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c3		 ret	 0
?MonsterAndMsgProc@@YAXXZ ENDP				; MonsterAndMsgProc
_TEXT	ENDS
PUBLIC	??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@ ; `string'
PUBLIC	?gObjMonsterCallKill@@YAXH@Z			; gObjMonsterCallKill
PUBLIC	?gObjGameClose@@YAHH@Z				; gObjGameClose
EXTRN	?Delete@CLoginCount@@QAEXXZ:PROC		; CLoginCount::Delete
EXTRN	?gLCount@@3PAVCLoginCount@@A:BYTE		; gLCount
EXTRN	?DelCash@CWhisperCash@@QAEXPAD@Z:PROC		; CWhisperCash::DelCash
EXTRN	?WhisperCash@@3VCWhisperCash@@A:BYTE		; WhisperCash
EXTRN	?GDSetWarehouseList@@YAXH@Z:PROC		; GDSetWarehouseList
EXTRN	?GDCharClose@@YAXHPAD0@Z:PROC			; GDCharClose
EXTRN	?ManagerDel@CGMMng@@QAEXPAD@Z:PROC		; CGMMng::ManagerDel
EXTRN	?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A:BYTE	; gQeustNpcTeleport
;	COMDAT ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.h
CONST	SEGMENT
??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@ DB '['
	DB	'Fix Inv.Ptr] False Location - %s, %d', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
CONST	ENDS
;	COMDAT ?gObjGameClose@@YAHH@Z
_TEXT	SEGMENT
_pMsg$162755 = 8					; size = 4
_aIndex$ = 8						; size = 4
?gObjGameClose@@YAHH@Z PROC				; gObjGameClose, COMDAT

; 3104 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 3105 : 	if ( aIndex < 0 || aIndex > OBJMAX )	// Deathway fix

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00007	81 fb e8 1c 00
	00		 cmp	 ebx, 7400		; 00001ce8H
  0000d	0f 87 d4 02 00
	00		 ja	 $LN24@gObjGameCl

; 3110 : 	}
; 3111 : 
; 3112 : 	LPOBJ lpObj = &gObj[aIndex];

  00013	56		 push	 esi
  00014	8b f3		 mov	 esi, ebx
  00016	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0001c	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3113 : 
; 3114 : 	if ( lpObj->Connected != PLAYER_PLAYING )

  00022	80 7e 04 03	 cmp	 BYTE PTR [esi+4], 3

; 3115 : 	{
; 3116 : 		return FALSE;

  00026	75 29		 jne	 SHORT $LN41@gObjGameCl

; 3117 : 	}
; 3118 : 
; 3119 : 	if ( lpObj->Type != OBJ_USER )

  00028	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0002d	74 28		 je	 SHORT $LN22@gObjGameCl

; 3120 : 	{
; 3121 : 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2, 3)), lpObj->AccountID, lpObj->Name);

  0002f	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00032	50		 push	 eax
  00033	83 c6 64	 add	 esi, 100		; 00000064H
  00036	56		 push	 esi
  00037	68 03 02 00 00	 push	 515			; 00000203H
  0003c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00041	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00046	50		 push	 eax
  00047	6a 00		 push	 0
  00049	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
$LN41@gObjGameCl:

; 3122 : 		return FALSE;

  00051	5e		 pop	 esi
  00052	33 c0		 xor	 eax, eax
  00054	5b		 pop	 ebx

; 3240 : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN22@gObjGameCl:

; 3123 : 	}
; 3124 : 
; 3125 : 	if ( lpObj->m_RecallMon >= 0 )

  00057	83 be cc 02 00
	00 00		 cmp	 DWORD PTR [esi+716], 0
  0005e	7c 0b		 jl	 SHORT $LN21@gObjGameCl

; 3126 : 	{
; 3127 : 		gObjMonsterCallKill(lpObj->m_Index);

  00060	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  00068	83 c4 04	 add	 esp, 4
$LN21@gObjGameCl:

; 3128 : 	}
; 3129 : 
; 3130 : 	gObjMagicTextSave(lpObj);

  0006b	56		 push	 esi
  0006c	e8 00 00 00 00	 call	 ?gObjMagicTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMagicTextSave

; 3131 : 
; 3132 : 	if ( (   (lpObj->m_IfState.use != 0 )
; 3133 : 		&&  (lpObj->m_IfState.type == 7 )) 
; 3134 : 		|| ((lpObj->m_IfState.use != 0)  
; 3135 : 		&& (lpObj->m_IfState.type == 13)))

  00071	8b 86 84 0c 00
	00		 mov	 eax, DWORD PTR [esi+3204]
  00077	8b c8		 mov	 ecx, eax
  00079	83 c4 04	 add	 esp, 4
  0007c	83 e1 03	 and	 ecx, 3
  0007f	74 10		 je	 SHORT $LN18@gObjGameCl
  00081	8b d0		 mov	 edx, eax
  00083	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00089	81 fa c0 01 00
	00		 cmp	 edx, 448		; 000001c0H
  0008f	74 10		 je	 SHORT $LN19@gObjGameCl
$LN18@gObjGameCl:
  00091	85 c9		 test	 ecx, ecx
  00093	74 2f		 je	 SHORT $LN15@gObjGameCl
  00095	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0009a	3d 40 03 00 00	 cmp	 eax, 832		; 00000340H
  0009f	75 23		 jne	 SHORT $LN15@gObjGameCl
$LN19@gObjGameCl:

; 3136 : 	{
; 3137 : 		if ( lpObj->bIsChaosMixCompleted == true || lpObj->m_bIsCastleNPCUpgradeCompleted == true)

  000a1	80 be ba 10 00
	00 01		 cmp	 BYTE PTR [esi+4282], 1
  000a8	74 11		 je	 SHORT $LN16@gObjGameCl
  000aa	80 be d2 14 00
	00 01		 cmp	 BYTE PTR [esi+5330], 1
  000b1	74 08		 je	 SHORT $LN16@gObjGameCl

; 3140 : 		}
; 3141 : 		else
; 3142 : 		{
; 3143 : 			gObjInventoryRollback(aIndex);

  000b3	53		 push	 ebx
  000b4	e8 00 00 00 00	 call	 ?gObjInventoryRollback@@YAHH@Z ; gObjInventoryRollback
  000b9	eb 06		 jmp	 SHORT $LN39@gObjGameCl
$LN16@gObjGameCl:

; 3138 : 		{
; 3139 : 			gObjInventoryCommit(aIndex);

  000bb	53		 push	 ebx
  000bc	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
$LN39@gObjGameCl:
  000c1	83 c4 04	 add	 esp, 4
$LN15@gObjGameCl:

; 3144 : 		}
; 3145 : 	}
; 3146 : 
; 3147 : 	gObjTradeSave(lpObj, aIndex);

  000c4	53		 push	 ebx
  000c5	56		 push	 esi
  000c6	e8 00 00 00 00	 call	 ?gObjTradeSave@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjTradeSave

; 3148 : 
; 3149 : 	if ( (lpObj->m_IfState.use != 0 )
; 3150 : 		&&  (lpObj->m_IfState.type == 10 ) 
; 3151 : 		&& lpObj->TargetShopNumber == 229)

  000cb	8b 86 84 0c 00
	00		 mov	 eax, DWORD PTR [esi+3204]
  000d1	83 c4 08	 add	 esp, 8
  000d4	a8 03		 test	 al, 3
  000d6	74 24		 je	 SHORT $LN14@gObjGameCl
  000d8	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000dd	3d 80 02 00 00	 cmp	 eax, 640		; 00000280H
  000e2	75 18		 jne	 SHORT $LN14@gObjGameCl
  000e4	b8 e5 00 00 00	 mov	 eax, 229		; 000000e5H
  000e9	66 39 86 d6 02
	00 00		 cmp	 WORD PTR [esi+726], ax
  000f0	75 0a		 jne	 SHORT $LN14@gObjGameCl

; 3152 : 	{
; 3153 : 		gQeustNpcTeleport.TalkRefDel();

  000f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A ; gQeustNpcTeleport
  000f7	e8 00 00 00 00	 call	 ?TalkRefDel@CQeustNpcTeleport@@QAEXXZ ; CQeustNpcTeleport::TalkRefDel
$LN14@gObjGameCl:

; 3154 : 	}
; 3155 : 
; 3156 : 	if ( (lpObj->Authority&2) == 2 )

  000fc	f6 86 a4 01 00
	00 02		 test	 BYTE PTR [esi+420], 2
  00103	74 0e		 je	 SHORT $LN13@gObjGameCl

; 3157 : 	{
; 3158 : 		cManager.ManagerDel(lpObj->Name);

  00105	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  00108	51		 push	 ecx
  00109	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  0010e	e8 00 00 00 00	 call	 ?ManagerDel@CGMMng@@QAEXPAD@Z ; CGMMng::ManagerDel
$LN13@gObjGameCl:

; 3159 : 	}
; 3160 : 
; 3161 : 	if ( OBJMAX_RANGE(lpObj->m_iDuelUserRequested) )

  00113	8b 86 18 0d 00
	00		 mov	 eax, DWORD PTR [esi+3352]
  00119	85 c0		 test	 eax, eax
  0011b	78 22		 js	 SHORT $LN12@gObjGameCl
  0011d	33 c9		 xor	 ecx, ecx
  0011f	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00124	0f 9e c1	 setle	 cl
  00127	85 c9		 test	 ecx, ecx
  00129	74 14		 je	 SHORT $LN12@gObjGameCl

; 3162 : 	{
; 3163 : 		gObjSendDuelEnd(&gObj[lpObj->m_iDuelUserRequested]);

  0012b	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00131	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 ?gObjSendDuelEnd@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSendDuelEnd
  0013c	83 c4 04	 add	 esp, 4
$LN12@gObjGameCl:

; 3164 : 	}
; 3165 : 
; 3166 : 
; 3167 : 	if ( gObjDuelCheck(lpObj) != FALSE )

  0013f	56		 push	 esi
  00140	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z ; gObjDuelCheck
  00145	83 c4 04	 add	 esp, 4
  00148	85 c0		 test	 eax, eax
  0014a	74 1b		 je	 SHORT $LN11@gObjGameCl

; 3168 : 	{
; 3169 : 		gObjSendDuelEnd(&gObj[lpObj->m_iDuelUser]);

  0014c	8b 96 1c 0d 00
	00		 mov	 edx, DWORD PTR [esi+3356]
  00152	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00158	81 c2 00 00 00
	00		 add	 edx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0015e	52		 push	 edx
  0015f	e8 00 00 00 00	 call	 ?gObjSendDuelEnd@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSendDuelEnd
  00164	83 c4 04	 add	 esp, 4
$LN11@gObjGameCl:

; 3170 : 	}
; 3171 : 
; 3172 : 	gObjResetDuel(lpObj);

  00167	56		 push	 esi
  00168	e8 00 00 00 00	 call	 ?gObjResetDuel@@YAXPAUOBJECTSTRUCT@@@Z ; gObjResetDuel

; 3173 : 
; 3174 : 	if ( lpObj->PartyNumber >= 0 )

  0016d	8b 86 a8 02 00
	00		 mov	 eax, DWORD PTR [esi+680]
  00173	83 c4 04	 add	 esp, 4
  00176	85 c0		 test	 eax, eax
  00178	78 28		 js	 SHORT $LN9@gObjGameCl

; 3175 : 	{
; 3176 : 		int iPartyIndex= gParty.GetIndex(lpObj->PartyNumber, lpObj->m_Index, lpObj->DBNumber);

  0017a	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0017d	8b 16		 mov	 edx, DWORD PTR [esi]
  0017f	51		 push	 ecx
  00180	52		 push	 edx
  00181	50		 push	 eax
  00182	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00187	e8 00 00 00 00	 call	 ?GetIndex@PartyClass@@QAEHHHH@Z ; PartyClass::GetIndex

; 3177 : 
; 3178 : 		if ( iPartyIndex >= 0 )

  0018c	85 c0		 test	 eax, eax
  0018e	78 12		 js	 SHORT $LN9@gObjGameCl

; 3179 : 		{
; 3180 : 			PMSG_PARTYDELUSER pMsg;
; 3181 : 
; 3182 : 			pMsg.Number = iPartyIndex;

  00190	88 45 0b	 mov	 BYTE PTR _pMsg$162755[ebp+3], al

; 3183 : 
; 3184 : 			CGPartyDelUser(&pMsg, lpObj->m_Index);

  00193	8b 06		 mov	 eax, DWORD PTR [esi]
  00195	50		 push	 eax
  00196	8d 4d 08	 lea	 ecx, DWORD PTR _pMsg$162755[ebp]
  00199	51		 push	 ecx
  0019a	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  0019f	83 c4 08	 add	 esp, 8
$LN9@gObjGameCl:

; 3185 : 		}
; 3186 : 	}
; 3187 : 
; 3188 : 	if ( lpObj->GuildNumber > 0 )

  001a2	83 be b0 02 00
	00 00		 cmp	 DWORD PTR [esi+688], 0
  001a9	57		 push	 edi
  001aa	7e 2a		 jle	 SHORT $LN8@gObjGameCl

; 3189 : 	{
; 3190 : 		if ( lpObj->lpGuild->WarState == 1 )

  001ac	8b 96 b4 02 00
	00		 mov	 edx, DWORD PTR [esi+692]
  001b2	80 ba 91 05 00
	00 01		 cmp	 BYTE PTR [edx+1425], 1
  001b9	75 09		 jne	 SHORT $LN7@gObjGameCl

; 3191 : 		{
; 3192 : 			gObjGuildWarMasterClose(lpObj);

  001bb	56		 push	 esi
  001bc	e8 00 00 00 00	 call	 ?gObjGuildWarMasterClose@@YAHPAUOBJECTSTRUCT@@@Z ; gObjGuildWarMasterClose
  001c1	83 c4 04	 add	 esp, 4
$LN7@gObjGameCl:

; 3193 : 		}
; 3194 : 
; 3195 : 		GDCharClose(0, lpObj->lpGuild->Name, lpObj->Name);

  001c4	8b 86 b4 02 00
	00		 mov	 eax, DWORD PTR [esi+692]
  001ca	8d 7e 6f	 lea	 edi, DWORD PTR [esi+111]
  001cd	57		 push	 edi
  001ce	83 c0 04	 add	 eax, 4
  001d1	50		 push	 eax
  001d2	6a 00		 push	 0

; 3196 : 	}
; 3197 : 	else

  001d4	eb 08		 jmp	 SHORT $LN40@gObjGameCl
$LN8@gObjGameCl:

; 3198 : 	{
; 3199 : 		GDCharClose(1, NULL, lpObj->Name);

  001d6	8d 7e 6f	 lea	 edi, DWORD PTR [esi+111]
  001d9	57		 push	 edi
  001da	6a 00		 push	 0
  001dc	6a 01		 push	 1
$LN40@gObjGameCl:
  001de	e8 00 00 00 00	 call	 ?GDCharClose@@YAXHPAD0@Z ; GDCharClose
  001e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3200 : 	}
; 3201 : 
; 3202 : 	if ( lpObj->WarehouseSave == 1 )

  001e6	83 be d8 0c 00
	00 01		 cmp	 DWORD PTR [esi+3288], 1
  001ed	75 0b		 jne	 SHORT $LN5@gObjGameCl

; 3203 : 	{
; 3204 : 		GDSetWarehouseList(lpObj->m_Index);

  001ef	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001f1	51		 push	 ecx
  001f2	e8 00 00 00 00	 call	 ?GDSetWarehouseList@@YAXH@Z ; GDSetWarehouseList
  001f7	83 c4 04	 add	 esp, 4
$LN5@gObjGameCl:

; 3205 : 	}
; 3206 : 
; 3207 : 	if ( (lpObj->MapNumber<11)?FALSE:(lpObj->MapNumber>17)?FALSE:TRUE )

  001fa	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00201	3c 0b		 cmp	 al, 11			; 0000000bH
  00203	72 16		 jb	 SHORT $LN4@gObjGameCl
  00205	b2 11		 mov	 dl, 17			; 00000011H
  00207	3a d0		 cmp	 dl, al
  00209	1b c0		 sbb	 eax, eax
  0020b	40		 inc	 eax
  0020c	74 0d		 je	 SHORT $LN4@gObjGameCl

; 3208 : 	{
; 3209 : 		g_BloodCastle.SearchUserDropQuestItem(lpObj->m_Index);

  0020e	8b 06		 mov	 eax, DWORD PTR [esi]
  00210	50		 push	 eax
  00211	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00216	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem
$LN4@gObjGameCl:

; 3210 : 	}
; 3211 : 
; 3212 : 	gObjSaveChaosBoxItemList(lpObj);

  0021b	56		 push	 esi
  0021c	e8 00 00 00 00	 call	 ?gObjSaveChaosBoxItemList@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSaveChaosBoxItemList

; 3213 : 
; 3214 : 	if ( gObjFixInventoryPointer(aIndex) == false )

  00221	53		 push	 ebx
  00222	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00227	83 c4 08	 add	 esp, 8
  0022a	84 c0		 test	 al, al
  0022c	75 19		 jne	 SHORT $LN3@gObjGameCl

; 3215 : 	{
; 3216 : 		LogAdd(LOG_BLACK, "[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  0022e	68 90 0c 00 00	 push	 3216			; 00000c90H
  00233	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00238	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  0023d	6a 00		 push	 0
  0023f	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00244	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@gObjGameCl:

; 3217 : 	}
; 3218 : 
; 3219 : 	GJSetCharacterInfo(lpObj, aIndex, 0);

  00247	6a 00		 push	 0
  00249	53		 push	 ebx
  0024a	56		 push	 esi
  0024b	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo

; 3220 : 	gObjViewportClose(lpObj);

  00250	56		 push	 esi
  00251	e8 00 00 00 00	 call	 ?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportClose

; 3221 : 	LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2, 4)), lpObj->m_Index, lpObj->AccountID, lpObj->Name);

  00256	8b 16		 mov	 edx, DWORD PTR [esi]
  00258	83 c4 10	 add	 esp, 16			; 00000010H
  0025b	57		 push	 edi
  0025c	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  0025f	51		 push	 ecx
  00260	52		 push	 edx
  00261	68 04 02 00 00	 push	 516			; 00000204H
  00266	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0026b	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00270	50		 push	 eax
  00271	6a 00		 push	 0
  00273	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00278	83 c4 14	 add	 esp, 20			; 00000014H

; 3222 : 
; 3223 : 	if(lpObj->Name)

  0027b	85 ff		 test	 edi, edi
  0027d	74 0b		 je	 SHORT $LN2@gObjGameCl

; 3224 : 	{
; 3225 : 		WhisperCash.DelCash(lpObj->Name);

  0027f	57		 push	 edi
  00280	b9 00 00 00 00	 mov	 ecx, OFFSET ?WhisperCash@@3VCWhisperCash@@A ; WhisperCash
  00285	e8 00 00 00 00	 call	 ?DelCash@CWhisperCash@@QAEXPAD@Z ; CWhisperCash::DelCash
$LN2@gObjGameCl:

; 3226 : 	}
; 3227 : 
; 3228 : 	memcpy(lpObj->BackName, lpObj->Name, sizeof(lpObj->Name)-1);

  0028a	8b 07		 mov	 eax, DWORD PTR [edi]
  0028c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0028f	66 8b 57 08	 mov	 dx, WORD PTR [edi+8]
  00293	89 86 15 0f 00
	00		 mov	 DWORD PTR [esi+3861], eax

; 3229 : 	lpObj->BackName[10] = 0;
; 3230 : 
; 3231 : 	memset(lpObj->Name, 0, sizeof(lpObj->Name)-1);

  00299	33 c0		 xor	 eax, eax
  0029b	89 8e 19 0f 00
	00		 mov	 DWORD PTR [esi+3865], ecx
  002a1	66 89 96 1d 0f
	00 00		 mov	 WORD PTR [esi+3869], dx
  002a8	c6 86 1f 0f 00
	00 00		 mov	 BYTE PTR [esi+3871], 0
  002af	89 07		 mov	 DWORD PTR [edi], eax
  002b1	89 47 04	 mov	 DWORD PTR [edi+4], eax
  002b4	66 89 47 08	 mov	 WORD PTR [edi+8], ax

; 3232 : 	lpObj->Connected = PLAYER_LOGGED;
; 3233 : 
; 3234 : 	if ( m_ObjBill[aIndex].GetCertify() >= 0 && m_ObjBill[aIndex].GetCertify() < 3)

  002b8	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  002bb	8a 04 c5 00 00
	00 00		 mov	 al, BYTE PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[eax*8]
  002c2	c6 46 04 02	 mov	 BYTE PTR [esi+4], 2
  002c6	5f		 pop	 edi
  002c7	84 c0		 test	 al, al
  002c9	78 13		 js	 SHORT $LN1@gObjGameCl
  002cb	3c 03		 cmp	 al, 3
  002cd	7d 0f		 jge	 SHORT $LN1@gObjGameCl

; 3235 : 	{
; 3236 : 		gLCount[m_ObjBill[aIndex].GetCertify()].Delete();

  002cf	0f be c8	 movsx	 ecx, al
  002d2	8d 0c 8d 00 00
	00 00		 lea	 ecx, DWORD PTR ?gLCount@@3PAVCLoginCount@@A[ecx*4]
  002d9	e8 00 00 00 00	 call	 ?Delete@CLoginCount@@QAEXXZ ; CLoginCount::Delete
$LN1@gObjGameCl:

; 3237 : 	}
; 3238 : 
; 3239 : 	return TRUE;

  002de	5e		 pop	 esi
  002df	b8 01 00 00 00	 mov	 eax, 1
  002e4	5b		 pop	 ebx

; 3240 : }

  002e5	5d		 pop	 ebp
  002e6	c3		 ret	 0
$LN24@gObjGameCl:

; 3106 : 	{
; 3107 : 		LogAdd(LOG_BLACK, "(%s)(%d) = index over error (%d)", __FILE__, __LINE__, aIndex);

  002e7	53		 push	 ebx
  002e8	68 23 0c 00 00	 push	 3107			; 00000c23H
  002ed	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd?$CJ@
  002f7	6a 00		 push	 0
  002f9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  002fe	83 c4 14	 add	 esp, 20			; 00000014H

; 3108 : 
; 3109 : 		return FALSE;

  00301	33 c0		 xor	 eax, eax
  00303	5b		 pop	 ebx

; 3240 : }

  00304	5d		 pop	 ebp
  00305	c3		 ret	 0
?gObjGameClose@@YAHH@Z ENDP				; gObjGameClose
_TEXT	ENDS
PUBLIC	??_C@_0BF@FJCKJIOE@?$CI?$CFd?$CJlogout?5?3?5?$CFs?5?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_0EB@IHJPBNAD@?$FLMapServerMng?$FN?5User?5Quit?5without@ ; `string'
PUBLIC	??_C@_0BK@FHEGNDKC@?$CI?$CFd?$CJlogout?9send?5?3?5?$CFs?5?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	?gObjDel@@YAFH@Z				; gObjDel
EXTRN	?DelIp@CIpCache@@QAEXPAD@Z:PROC			; CIpCache::DelIp
EXTRN	?IpCache@@3VCIpCache@@A:BYTE			; IpCache
;	COMDAT ??_C@_0BF@FJCKJIOE@?$CI?$CFd?$CJlogout?5?3?5?$CFs?5?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BF@FJCKJIOE@?$CI?$CFd?$CJlogout?5?3?5?$CFs?5?$FL?$CFs?$FN?$AA@ DB '('
	DB	'%d)logout : %s [%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@IHJPBNAD@?$FLMapServerMng?$FN?5User?5Quit?5without@
CONST	SEGMENT
??_C@_0EB@IHJPBNAD@?$FLMapServerMng?$FN?5User?5Quit?5without@ DB '[MapSer'
	DB	'verMng] User Quit without JoinServer logout-send [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FHEGNDKC@?$CI?$CFd?$CJlogout?9send?5?3?5?$CFs?5?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BK@FHEGNDKC@?$CI?$CFd?$CJlogout?9send?5?3?5?$CFs?5?$FL?$CFs?$FN?$AA@ DB '('
	DB	'%d)logout-send : %s [%s]', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjDel@@YAFH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?gObjDel@@YAFH@Z PROC					; gObjDel, COMDAT

; 3243 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 3244 : 	int i = 0;
; 3245 : 
; 3246 : 	if ( index < 0 || index > OBJMAX )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _index$[ebp]
  00007	81 fb e8 1c 00
	00		 cmp	 ebx, 7400		; 00001ce8H
  0000d	0f 87 26 01 00
	00		 ja	 $LN7@gObjDel

; 3250 : 	}
; 3251 : 
; 3252 : 	LPOBJ lpObj = &gObj[index];

  00013	56		 push	 esi
  00014	8b f3		 mov	 esi, ebx
  00016	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0001c	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3253 : 
; 3254 : 	if ( lpObj->Connected < PLAYER_CONNECTED )

  00022	80 7e 04 01	 cmp	 BYTE PTR [esi+4], 1
  00026	73 06		 jae	 SHORT $LN6@gObjDel

; 3255 : 	{
; 3256 : 		return 0;

  00028	5e		 pop	 esi
  00029	33 c0		 xor	 eax, eax
  0002b	5b		 pop	 ebx

; 3294 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN6@gObjDel:

; 3257 : 	}
; 3258 : 
; 3259 : 	if ( MAX_MAP_RANGE(lpObj->MapNumber) )

  0002e	8a 8e 09 01 00
	00		 mov	 cl, BYTE PTR [esi+265]
  00034	b8 27 00 00 00	 mov	 eax, 39			; 00000027H
  00039	3a c1		 cmp	 al, cl
  0003b	1b c0		 sbb	 eax, eax
  0003d	40		 inc	 eax
  0003e	74 4c		 je	 SHORT $LN5@gObjDel

; 3260 : 	{
; 3261 : 		MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  00040	0f bf 96 1e 01
	00 00		 movsx	 edx, WORD PTR [esi+286]
  00047	0f bf 86 1c 01
	00 00		 movsx	 eax, WORD PTR [esi+284]
  0004e	0f b6 c9	 movzx	 ecx, cl
  00051	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00057	52		 push	 edx
  00058	50		 push	 eax
  00059	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0005f	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 3262 : 		MapC[lpObj->MapNumber].ClearStandAttr(lpObj->X, lpObj->Y);

  00064	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR [esi+262]
  0006b	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  00072	51		 push	 ecx
  00073	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  0007a	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00080	52		 push	 edx
  00081	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00087	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr
$LN5@gObjDel:

; 3263 : 	}
; 3264 : 
; 3265 : 	int UserConnectState = lpObj->Connected;
; 3266 : 
; 3267 : 	if ( lpObj->Type == OBJ_USER )

  0008c	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00091	57		 push	 edi
  00092	0f b6 7e 04	 movzx	 edi, BYTE PTR [esi+4]
  00096	0f 85 8f 00 00
	00		 jne	 $LN4@gObjDel

; 3268 : 	{
; 3269 : 		gObjGameClose(index);

  0009c	53		 push	 ebx
  0009d	e8 00 00 00 00	 call	 ?gObjGameClose@@YAHH@Z	; gObjGameClose
  000a2	83 c4 04	 add	 esp, 4

; 3270 : 
; 3271 : 		if ( UserConnectState >= PLAYER_LOGGED )

  000a5	83 ff 02	 cmp	 edi, 2
  000a8	7c 5e		 jl	 SHORT $LN13@gObjDel

; 3272 : 		{
; 3273 : 			if ( lpObj->m_bMapSvrMoveQuit == false )

  000aa	80 be c4 14 00
	00 00		 cmp	 BYTE PTR [esi+5316], 0
  000b1	75 20		 jne	 SHORT $LN2@gObjDel

; 3274 : 			{
; 3275 : 				GJPUserClose(lpObj);

  000b3	56		 push	 esi
  000b4	e8 00 00 00 00	 call	 ?GJPUserClose@@YAXPAUOBJECTSTRUCT@@@Z ; GJPUserClose

; 3276 : 				LogAdd(LOG_BLACK, "(%d)logout-send : %s [%s]", index, lpObj->AccountID, lpObj->Ip_addr);

  000b9	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  000bc	50		 push	 eax
  000bd	8d 7e 64	 lea	 edi, DWORD PTR [esi+100]
  000c0	57		 push	 edi
  000c1	53		 push	 ebx
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FHEGNDKC@?$CI?$CFd?$CJlogout?9send?5?3?5?$CFs?5?$FL?$CFs?$FN?$AA@
  000c7	6a 00		 push	 0
  000c9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000ce	83 c4 18	 add	 esp, 24			; 00000018H

; 3277 : 			}
; 3278 : 			else

  000d1	eb 17		 jmp	 SHORT $LN1@gObjDel
$LN2@gObjDel:

; 3279 : 			{
; 3280 : 				LogAdd(LOG_BLACK, "[MapServerMng] User Quit without JoinServer logout-send [%s][%s]",
; 3281 : 					lpObj->AccountID, lpObj->Name);

  000d3	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  000d6	51		 push	 ecx
  000d7	8d 7e 64	 lea	 edi, DWORD PTR [esi+100]
  000da	57		 push	 edi
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@IHJPBNAD@?$FLMapServerMng?$FN?5User?5Quit?5without@
  000e0	6a 00		 push	 0
  000e2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000e7	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@gObjDel:

; 3282 : 			}
; 3283 : 
; 3284 : 			memset(lpObj->AccountID, 0, sizeof(lpObj->AccountID) -1);

  000ea	33 c0		 xor	 eax, eax
  000ec	89 07		 mov	 DWORD PTR [edi], eax
  000ee	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000f1	66 89 47 08	 mov	 WORD PTR [edi+8], ax

; 3285 : 			memset(lpObj->LastJoominNumber, 0, sizeof(lpObj->LastJoominNumber));

  000f5	89 46 7a	 mov	 DWORD PTR [esi+122], eax
  000f8	89 46 7e	 mov	 DWORD PTR [esi+126], eax
  000fb	89 86 82 00 00
	00		 mov	 DWORD PTR [esi+130], eax
  00101	66 89 86 86 00
	00 00		 mov	 WORD PTR [esi+134], ax
$LN13@gObjDel:

; 3286 : 		}
; 3287 : 
; 3288 : 		LogAdd(LOG_BLACK, "(%d)logout : %s [%s]", index, lpObj->AccountID, lpObj->Ip_addr);

  00108	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  0010b	57		 push	 edi
  0010c	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  0010f	52		 push	 edx
  00110	53		 push	 ebx
  00111	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FJCKJIOE@?$CI?$CFd?$CJlogout?5?3?5?$CFs?5?$FL?$CFs?$FN?$AA@
  00116	6a 00		 push	 0
  00118	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0011d	83 c4 14	 add	 esp, 20			; 00000014H

; 3289 : 		IpCache.DelIp(lpObj->Ip_addr);

  00120	57		 push	 edi
  00121	b9 00 00 00 00	 mov	 ecx, OFFSET ?IpCache@@3VCIpCache@@A ; IpCache
  00126	e8 00 00 00 00	 call	 ?DelIp@CIpCache@@QAEXPAD@Z ; CIpCache::DelIp
$LN4@gObjDel:

; 3290 : 	}
; 3291 : 
; 3292 : 	lpObj->Connected = PLAYER_EMPTY;

  0012b	5f		 pop	 edi
  0012c	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  00130	5e		 pop	 esi

; 3293 : 	return 1;

  00131	b8 01 00 00 00	 mov	 eax, 1
  00136	5b		 pop	 ebx

; 3294 : }

  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
$LN7@gObjDel:

; 3247 : 	{
; 3248 : 		LogAdd(LOG_RED, "(%s)(%d) = index over error (%d)", __FILE__, __LINE__, index);

  00139	53		 push	 ebx
  0013a	68 b0 0c 00 00	 push	 3248			; 00000cb0H
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd?$CJ@
  00149	6a 01		 push	 1
  0014b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00150	83 c4 14	 add	 esp, 20			; 00000014H

; 3249 : 		return 0;

  00153	33 c0		 xor	 eax, eax
  00155	5b		 pop	 ebx

; 3294 : }

  00156	5d		 pop	 ebp
  00157	c3		 ret	 0
?gObjDel@@YAFH@Z ENDP					; gObjDel
_TEXT	ENDS
PUBLIC	?gObjMonsterExpDivision@@YAXPAUOBJECTSTRUCT@@0HH@Z ; gObjMonsterExpDivision
EXTRN	?gObjMonsterHitDamageUserDel@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterHitDamageUserDel
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterExpDivision@@YAXPAUOBJECTSTRUCT@@0HH@Z
_TEXT	SEGMENT
tv143 = -8						; size = 4
tv264 = -4						; size = 4
_lpMonObj$ = 8						; size = 4
_bSendExp$163937 = 11					; size = 1
_lpObj$ = 12						; size = 4
_AttackDamage$ = 16					; size = 4
_MSBFlag$ = 20						; size = 4
?gObjMonsterExpDivision@@YAXPAUOBJECTSTRUCT@@0HH@Z PROC	; gObjMonsterExpDivision, COMDAT

; 6544 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 6545 : 
; 6546 : 	gObjMonsterHitDamageUserDel(lpMonObj);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _lpMonObj$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	53		 push	 ebx
  0000d	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageUserDel@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageUserDel
  00012	8d 8b a4 0a 00
	00		 lea	 ecx, DWORD PTR [ebx+2724]
  00018	83 c4 04	 add	 esp, 4

; 6547 : 	lpMonObj->Money = 0;

  0001b	c7 83 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+176], 0
  00025	89 4d fc	 mov	 DWORD PTR tv264[ebp], ecx
  00028	c7 45 f8 28 00
	00 00		 mov	 DWORD PTR tv143[ebp], 40 ; 00000028H
  0002f	90		 npad	 1
$LL14@gObjMonste@6:

; 6555 : 	{
; 6556 : 		if(lpMonObj->sHD[n].number >= 0)

  00030	0f b7 41 fc	 movzx	 eax, WORD PTR [ecx-4]
  00034	66 85 c0	 test	 ax, ax
  00037	78 64		 js	 SHORT $LN7@gObjMonste@6

; 6557 : 		{
; 6558 : 			tObjNum = lpMonObj->sHD[n].number;
; 6559 : 			lpTargetObj = &gObj[tObjNum];
; 6560 : 
; 6561 : 			if(lpMonObj->sHD[n].HitDamage > 0)

  00039	8b 39		 mov	 edi, DWORD PTR [ecx]
  0003b	0f bf f0	 movsx	 esi, ax
  0003e	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00044	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004a	85 ff		 test	 edi, edi
  0004c	7e 4f		 jle	 SHORT $LN7@gObjMonste@6

; 6562 : 			{
; 6563 : 				bool bSendExp = 1;
; 6564 : 
; 6565 : 				exp = gObjMonsterExpSingle(lpTargetObj,lpMonObj,lpMonObj->sHD[n].HitDamage,lpMonObj->MaxLife,bSendExp);

  0004e	d9 83 c0 00 00
	00		 fld	 DWORD PTR [ebx+192]
  00054	8d 45 0b	 lea	 eax, DWORD PTR _bSendExp$163937[ebp]
  00057	50		 push	 eax
  00058	c6 45 0b 01	 mov	 BYTE PTR _bSendExp$163937[ebp], 1
  0005c	e8 00 00 00 00	 call	 __ftol2_sse
  00061	50		 push	 eax
  00062	57		 push	 edi
  00063	53		 push	 ebx
  00064	56		 push	 esi
  00065	e8 00 00 00 00	 call	 ?gObjMonsterExpSingle@@YAHPAUOBJECTSTRUCT@@0HHAA_N@Z ; gObjMonsterExpSingle
  0006a	8b f8		 mov	 edi, eax
  0006c	83 c4 14	 add	 esp, 20			; 00000014H

; 6566 : 
; 6567 : 				if(exp > 0)

  0006f	85 ff		 test	 edi, edi
  00071	7e 2a		 jle	 SHORT $LN7@gObjMonste@6

; 6568 : 				{
; 6569 : 					if(bSendExp == 1)

  00073	80 7d 0b 01	 cmp	 BYTE PTR _bSendExp$163937[ebp], 1
  00077	75 1e		 jne	 SHORT $LN1@gObjMonste@6

; 6570 : 					{
; 6571 : 						if(lpTargetObj->m_Index == lpObj->m_Index)

  00079	8b 36		 mov	 esi, DWORD PTR [esi]
  0007b	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0007e	3b 31		 cmp	 esi, DWORD PTR [ecx]
  00080	75 15		 jne	 SHORT $LN1@gObjMonste@6

; 6572 : 						{
; 6573 : 							GCKillPlayerExpSend(lpTargetObj->m_Index,lpMonObj->m_Index,exp,AttackDamage,MSBFlag);

  00082	8b 55 14	 mov	 edx, DWORD PTR _MSBFlag$[ebp]
  00085	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00088	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0008a	52		 push	 edx
  0008b	50		 push	 eax
  0008c	57		 push	 edi
  0008d	51		 push	 ecx
  0008e	56		 push	 esi
  0008f	e8 00 00 00 00	 call	 ?GCKillPlayerExpSend@@YAXHHHHH@Z ; GCKillPlayerExpSend
  00094	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@gObjMonste@6:

; 6574 : 						}
; 6575 : 					}
; 6576 : 
; 6577 : 					lpMonObj->Money += exp;

  00097	01 bb b0 00 00
	00		 add	 DWORD PTR [ebx+176], edi
$LN7@gObjMonste@6:

; 6548 : 
; 6549 : 
; 6550 : 	int tObjNum;
; 6551 : 	int exp;
; 6552 : 	LPOBJ lpTargetObj;
; 6553 : 
; 6554 : 	for(int n = 0; n < MAX_ST_HIT_DAMAGE;n++)

  0009d	8b 4d fc	 mov	 ecx, DWORD PTR tv264[ebp]
  000a0	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000a3	ff 4d f8	 dec	 DWORD PTR tv143[ebp]
  000a6	89 4d fc	 mov	 DWORD PTR tv264[ebp], ecx
  000a9	75 85		 jne	 SHORT $LL14@gObjMonste@6
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx

; 6578 : 				}
; 6579 : 			}
; 6580 : 		}
; 6581 : 	}
; 6582 : }

  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?gObjMonsterExpDivision@@YAXPAUOBJECTSTRUCT@@0HH@Z ENDP	; gObjMonsterExpDivision
_TEXT	ENDS
PUBLIC	??_C@_0DE@KDNIOEPF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Ultimate?5Wea@ ; `string'
PUBLIC	??_C@_05DEBCIJNP@Staff?$AA@			; `string'
PUBLIC	??_C@_08OMHMMHKG@Crossbow?$AA@			; `string'
PUBLIC	??_C@_05LKHEONBC@Sword?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?gObjSetState@@YAXXZ				; gObjSetState
EXTRN	?StateSetDestroy@MapClass@@QAEXXZ:PROC		; MapClass::StateSetDestroy
EXTRN	?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjMonsterRegen
EXTRN	?GetMapPos@MapClass@@QAEXFAAF0@Z:PROC		; MapClass::GetMapPos
EXTRN	?DieProcDevilSquare@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CDevilSquare::DieProcDevilSquare
EXTRN	?gBattleGetTeamPosition@@YAXHHAAF0@Z:PROC	; gBattleGetTeamPosition
EXTRN	?GetRandomLengthPos@MapClass@@QAEXAAF0H@Z:PROC	; MapClass::GetRandomLengthPos
EXTRN	?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z:PROC ; CDarkSpirit::SetMode
EXTRN	?g_iCharacterRecuperationMaxLevel@@3HA:DWORD	; g_iCharacterRecuperationMaxLevel
EXTRN	?g_iUseCharacterAutoRecuperationSystem@@3HA:DWORD ; g_iUseCharacterAutoRecuperationSystem
EXTRN	?DeleteMercenary@CMercenary@@QAEHH@Z:PROC	; CMercenary::DeleteMercenary
EXTRN	?g_CsNPC_Mercenary@@3VCMercenary@@A:QWORD	; g_CsNPC_Mercenary
EXTRN	?ChangeMonsterState@CBloodCastle@@QAEXHH@Z:PROC	; CBloodCastle::ChangeMonsterState
EXTRN	?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterTopHitDamageUser
EXTRN	?SetBossMonster@CBloodCastle@@QAEXH@Z:PROC	; CBloodCastle::SetBossMonster
EXTRN	?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z:PROC	; CBloodCastle::ReleaseCastleDoor
EXTRN	?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z:PROC ; CBloodCastle::SendCastleDoorBlockInfo
EXTRN	?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z:PROC ; CBloodCastle::GetCurrentLiveUserCount
EXTRN	?gDevilSquareMonsterRegen@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CDevilSquare::gDevilSquareMonsterRegen
;	COMDAT ??_C@_0DE@KDNIOEPF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Ultimate?5Wea@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\dragonevent.h
CONST	SEGMENT
??_C@_0DE@KDNIOEPF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Ultimate?5Wea@ DB '['
	DB	'Blood Castle] (%d) Ultimate Weapon Dropped -> (%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05DEBCIJNP@Staff?$AA@
CONST	SEGMENT
??_C@_05DEBCIJNP@Staff?$AA@ DB 'Staff', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OMHMMHKG@Crossbow?$AA@
CONST	SEGMENT
??_C@_08OMHMMHKG@Crossbow?$AA@ DB 'Crossbow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LKHEONBC@Sword?$AA@
CONST	SEGMENT
??_C@_05LKHEONBC@Sword?$AA@ DB 'Sword', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
CONST	ENDS
;	COMDAT ?gObjSetState@@YAXXZ
_TEXT	SEGMENT
_x$166113 = -48						; size = 4
_mapnum$166112 = -44					; size = 4
_n$166103 = -40						; size = 4
__y$166212 = -36					; size = 4
_TopHitUser$166125 = -36				; size = 4
tv1399 = -34						; size = 2
tv1390 = -34						; size = 2
tv1396 = -32						; size = 4
tv1394 = -32						; size = 4
tv1387 = -32						; size = 4
tv1385 = -32						; size = 4
_y$166114 = -32						; size = 4
_pMsg$166148 = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
?gObjSetState@@YAXXZ PROC				; gObjSetState, COMDAT

; 12011: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 12012: 	int n;
; 12013: 	LPOBJ lpObj;
; 12014: 
; 12015: 	for(int n = 0; n < OBJMAX; n++)

  00012	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _n$166103[ebp], 0
  00019	57		 push	 edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL75@gObjSetSta:

; 12016: 	{
; 12017: 		lpObj = &gObj[n];

  00020	8b 75 d8	 mov	 esi, DWORD PTR _n$166103[ebp]
  00023	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00029	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 12018: 
; 12019: 		if(lpObj->Connected > PLAYER_LOGGED)

  0002f	80 7e 04 02	 cmp	 BYTE PTR [esi+4], 2
  00033	0f 86 53 08 00
	00		 jbe	 $LN74@gObjSetSta

; 12020: 		{
; 12021: 			if(lpObj->m_State == 1)

  00039	83 be bc 01 00
	00 01		 cmp	 DWORD PTR [esi+444], 1
  00040	75 1a		 jne	 SHORT $LN70@gObjSetSta

; 12022: 			{
; 12023: 				lpObj->m_State = 2;
; 12024: 				if(lpObj->RegenOk == 3)

  00042	80 be 03 02 00
	00 03		 cmp	 BYTE PTR [esi+515], 3
  00049	c7 86 bc 01 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+444], 2
  00053	75 07		 jne	 SHORT $LN70@gObjSetSta

; 12025: 				{
; 12026: 					lpObj->RegenOk = 0;

  00055	c6 86 03 02 00
	00 00		 mov	 BYTE PTR [esi+515], 0
$LN70@gObjSetSta:

; 12027: 				}
; 12028: 			}
; 12029: 	
; 12030: 			if(lpObj->Teleport == 3)

  0005c	80 be 00 02 00
	00 03		 cmp	 BYTE PTR [esi+512], 3
  00063	75 07		 jne	 SHORT $LN69@gObjSetSta

; 12031: 			{
; 12032: 				lpObj->Teleport = 0;

  00065	c6 86 00 02 00
	00 00		 mov	 BYTE PTR [esi+512], 0
$LN69@gObjSetSta:

; 12033: 			}
; 12034: 	
; 12035: 			if(lpObj->DieRegen == 2)

  0006c	80 be 02 02 00
	00 02		 cmp	 BYTE PTR [esi+514], 2
  00073	0f 85 13 08 00
	00		 jne	 $LN74@gObjSetSta

; 12036: 			{
; 12037: 				int mapnum = lpObj->MapNumber;
; 12038: 				int x = lpObj->X;

  00079	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  00080	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00086	8d be 04 01 00
	00		 lea	 edi, DWORD PTR [esi+260]
  0008c	89 55 d0	 mov	 DWORD PTR _x$166113[ebp], edx

; 12039: 				int y = lpObj->Y;

  0008f	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  00096	0f b6 c8	 movzx	 ecx, al
  00099	89 4d d4	 mov	 DWORD PTR _mapnum$166112[ebp], ecx
  0009c	89 55 e0	 mov	 DWORD PTR _y$166114[ebp], edx

; 12040: 	
; 12041: 				lpObj->m_bAttackerKilled = 0;

  0009f	c6 86 44 02 00
	00 00		 mov	 BYTE PTR [esi+580], 0

; 12042: 	
; 12043: 				if(DS_MAP_RANGE(lpObj->MapNumber))

  000a6	3c 09		 cmp	 al, 9
  000a8	74 0b		 je	 SHORT $LN122@gObjSetSta
  000aa	33 d2		 xor	 edx, edx
  000ac	3c 20		 cmp	 al, 32			; 00000020H
  000ae	0f 94 c2	 sete	 dl
  000b1	85 d2		 test	 edx, edx
  000b3	74 17		 je	 SHORT $LN128@gObjSetSta
$LN122@gObjSetSta:

; 12044: 				{
; 12045: 					if(lpObj->Type >= OBJ_MONSTER)

  000b5	66 83 7e 60 02	 cmp	 WORD PTR [esi+96], 2
  000ba	72 10		 jb	 SHORT $LN128@gObjSetSta

; 12046: 					{
; 12047: 						g_DevilSquare.gDevilSquareMonsterRegen(lpObj);

  000bc	56		 push	 esi
  000bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  000c2	e8 00 00 00 00	 call	 ?gDevilSquareMonsterRegen@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@@Z ; CDevilSquare::gDevilSquareMonsterRegen

; 12048: 						continue;

  000c7	e9 c0 07 00 00	 jmp	 $LN74@gObjSetSta
$LN128@gObjSetSta:

; 12049: 					}
; 12050: 				}
; 12051: 
; 12052: #if GS_CASTLE == 0
; 12053: 				if(lpObj->m_iRegenType != 0)

  000cc	83 be 0c 15 00
	00 00		 cmp	 DWORD PTR [esi+5388], 0
  000d3	0f 85 b3 07 00
	00		 jne	 $LN74@gObjSetSta

; 12054: 				{
; 12055: 					continue;
; 12056: 				}
; 12057: #endif
; 12058: 				if(lpObj->m_bIsInMonsterHerd != 0)

  000d9	83 be 24 0f 00
	00 00		 cmp	 DWORD PTR [esi+3876], 0
  000e0	74 1b		 je	 SHORT $LN64@gObjSetSta

; 12059: 				{
; 12060: 					if(lpObj->m_lpMonsterHerd != 0)

  000e2	8b 8e 2c 0f 00
	00		 mov	 ecx, DWORD PTR [esi+3884]
  000e8	85 c9		 test	 ecx, ecx
  000ea	0f 84 9c 07 00
	00		 je	 $LN74@gObjSetSta

; 12061: 					{
; 12062: 						lpObj->m_lpMonsterHerd->MonsterRegenAction(lpObj);

  000f0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f2	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  000f5	56		 push	 esi
  000f6	ff d2		 call	 edx

; 12063: 					}
; 12064: 					continue;

  000f8	e9 8f 07 00 00	 jmp	 $LN74@gObjSetSta
$LN64@gObjSetSta:

; 12065: 				}
; 12066: 	
; 12067: 				if(BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Type >= OBJ_MONSTER)

  000fd	3c 0b		 cmp	 al, 11			; 0000000bH
  000ff	0f 82 0b 02 00
	00		 jb	 $LN55@gObjSetSta
  00105	b2 11		 mov	 dl, 17			; 00000011H
  00107	3a d0		 cmp	 dl, al
  00109	1b c0		 sbb	 eax, eax
  0010b	40		 inc	 eax
  0010c	0f 84 fe 01 00
	00		 je	 $LN55@gObjSetSta
  00112	66 83 7e 60 02	 cmp	 WORD PTR [esi+96], 2
  00117	0f 82 f3 01 00
	00		 jb	 $LN55@gObjSetSta

; 12068: 				{
; 12069: 					if(lpObj->Class == 131)

  0011d	b8 83 00 00 00	 mov	 eax, 131		; 00000083H
  00122	66 39 86 98 00
	00 00		 cmp	 WORD PTR [esi+152], ax
  00129	0f 85 aa 00 00
	00		 jne	 $LN120@gObjSetSta

; 12070: 					{
; 12071: 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_bCASTLE_DOOR_LIVE = 0;

  0012f	0f be 86 02 0d
	00 00		 movsx	 eax, BYTE PTR [esi+3330]

; 12072: 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_bBC_DOOR_TERMINATE_COMPLETE = 1;
; 12073: 						g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT = g_BloodCastle.GetCurrentLiveUserCount(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1) * 2;

  00136	0f b6 9e 09 01
	00 00		 movzx	 ebx, BYTE PTR [esi+265]
  0013d	83 c1 f5	 add	 ecx, -11		; fffffff5H
  00140	c1 e0 09	 shl	 eax, 9
  00143	51		 push	 ecx
  00144	c7 80 4c 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+332], 0
  0014e	83 eb 0b	 sub	 ebx, 11			; 0000000bH
  00151	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00156	c6 80 62 01 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+354], 1
  0015d	c1 e3 09	 shl	 ebx, 9
  00160	e8 00 00 00 00	 call	 ?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentLiveUserCount
  00165	03 c0		 add	 eax, eax
  00167	89 83 84 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ebx+388], eax

; 12074: 	
; 12075: 						g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT = 0;

  0016d	c7 83 88 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ebx+392], 0

; 12076: 	
; 12077: 						if(g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT > 10)

  00177	83 bb 84 01 00
	00 0a		 cmp	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ebx+388], 10 ; 0000000aH
  0017e	7e 0a		 jle	 SHORT $LN60@gObjSetSta

; 12078: 						{
; 12079: 							g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT = 10;

  00180	c7 83 84 01 00
	00 0a 00 00 00	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ebx+388], 10 ; 0000000aH
$LN60@gObjSetSta:

; 12080: 						}
; 12081: 	
; 12082: 						g_BloodCastle.SendCastleDoorBlockInfo(lpObj->m_cBloodCastleIndex,0);

  0018a	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  00191	6a 00		 push	 0
  00193	51		 push	 ecx
  00194	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00199	e8 00 00 00 00	 call	 ?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleDoorBlockInfo

; 12083: 						g_BloodCastle.ReleaseCastleDoor(lpObj->m_cBloodCastleIndex);

  0019e	0f be 96 02 0d
	00 00		 movsx	 edx, BYTE PTR [esi+3330]
  001a5	52		 push	 edx
  001a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001ab	e8 00 00 00 00	 call	 ?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleDoor

; 12084: 	
; 12085: 						if(g_BloodCastle.GetCurrentState(lpObj->m_cBloodCastleIndex) == 2)

  001b0	0f be 86 02 0d
	00 00		 movsx	 eax, BYTE PTR [esi+3330]
  001b7	50		 push	 eax
  001b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001bd	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  001c2	83 f8 02	 cmp	 eax, 2
  001c5	75 12		 jne	 SHORT $LN120@gObjSetSta

; 12086: 						{
; 12087: 							g_BloodCastle.SetBossMonster(lpObj->m_cBloodCastleIndex);

  001c7	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  001ce	51		 push	 ecx
  001cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001d4	e8 00 00 00 00	 call	 ?SetBossMonster@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetBossMonster
$LN120@gObjSetSta:

; 12088: 						}
; 12089: 					}
; 12090: 	
; 12091: 					if(BC_STATUE_RANGE(lpObj->Class - 132) && BC_MAP_RANGE(lpObj->MapNumber))

  001d9	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  001e0	05 7c ff ff ff	 add	 eax, -132		; ffffff7cH
  001e5	0f 88 c6 00 00
	00		 js	 $LN58@gObjSetSta
  001eb	33 d2		 xor	 edx, edx
  001ed	83 f8 02	 cmp	 eax, 2
  001f0	0f 9e c2	 setle	 dl
  001f3	8b c2		 mov	 eax, edx
  001f5	85 c0		 test	 eax, eax
  001f7	0f 84 b4 00 00
	00		 je	 $LN58@gObjSetSta
  001fd	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00204	3c 0b		 cmp	 al, 11			; 0000000bH
  00206	0f 82 a5 00 00
	00		 jb	 $LN58@gObjSetSta
  0020c	b1 11		 mov	 cl, 17			; 00000011H
  0020e	3a c8		 cmp	 cl, al
  00210	1b c0		 sbb	 eax, eax
  00212	40		 inc	 eax
  00213	0f 84 98 00 00
	00		 je	 $LN58@gObjSetSta

; 12092: 					{
; 12093: 						int TopHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00219	56		 push	 esi
  0021a	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 12094: 						int level = lpObj->Class - 132;

  0021f	0f b7 9e 98 00
	00 00		 movzx	 ebx, WORD PTR [esi+152]

; 12095: 	
; 12096: 						int type = ItemGetNumberMake(13,19);

  00226	6a 13		 push	 19			; 00000013H
  00228	6a 0d		 push	 13			; 0000000dH
  0022a	89 45 dc	 mov	 DWORD PTR _TopHitUser$166125[ebp], eax
  0022d	81 eb 84 00 00
	00		 sub	 ebx, 132		; 00000084H
  00233	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 12097: 	
; 12098: 						ItemSerialCreateSend(lpObj->m_Index,lpObj->MapNumber + 236,lpObj->X,lpObj->Y,type,level,0,0,0,0,TopHitUser,0,0);

  00238	8b 55 dc	 mov	 edx, DWORD PTR _TopHitUser$166125[ebp]
  0023b	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0023e	6a 00		 push	 0
  00240	6a 00		 push	 0
  00242	52		 push	 edx
  00243	8a 96 09 01 00
	00		 mov	 dl, BYTE PTR [esi+265]
  00249	6a 00		 push	 0
  0024b	6a 00		 push	 0
  0024d	6a 00		 push	 0
  0024f	6a 00		 push	 0
  00251	53		 push	 ebx
  00252	50		 push	 eax
  00253	0f b6 86 06 01
	00 00		 movzx	 eax, BYTE PTR [esi+262]
  0025a	50		 push	 eax
  0025b	80 ea 14	 sub	 dl, 20			; 00000014H
  0025e	51		 push	 ecx
  0025f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00261	0f b6 c2	 movzx	 eax, dl
  00264	50		 push	 eax
  00265	51		 push	 ecx
  00266	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 12099: 	
; 12100: 						g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_btBC_QUEST_ITEM_NUMBER = level;

  0026b	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00272	8d 50 f5	 lea	 edx, DWORD PTR [eax-11]
  00275	c1 e2 09	 shl	 edx, 9
  00278	83 c4 40	 add	 esp, 64			; 00000040H
  0027b	88 9a 98 01 00
	00		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+408], bl

; 12101: 	
; 12102: 						LogAdd(LOG_BLACK, "[Blood Castle] (%d) Ultimate Weapon Dropped -> (%s)",
; 12103: 							lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1+1, (level !=0)?((level==1)?"Sword":"Crossbow"):"Staff");

  00281	85 db		 test	 ebx, ebx
  00283	74 13		 je	 SHORT $LN88@gObjSetSta
  00285	83 fb 01	 cmp	 ebx, 1
  00288	75 07		 jne	 SHORT $LN86@gObjSetSta
  0028a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05LKHEONBC@Sword?$AA@
  0028f	eb 0c		 jmp	 SHORT $LN89@gObjSetSta
$LN86@gObjSetSta:
  00291	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08OMHMMHKG@Crossbow?$AA@
  00296	eb 05		 jmp	 SHORT $LN89@gObjSetSta
$LN88@gObjSetSta:
  00298	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05DEBCIJNP@Staff?$AA@
$LN89@gObjSetSta:
  0029d	51		 push	 ecx
  0029e	83 c0 f6	 add	 eax, -10		; fffffff6H
  002a1	50		 push	 eax
  002a2	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@KDNIOEPF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Ultimate?5Wea@
  002a7	6a 00		 push	 0
  002a9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  002ae	83 c4 10	 add	 esp, 16			; 00000010H
$LN58@gObjSetSta:

; 12104: 					}
; 12105: 
; 12106: 					if(lpObj->m_PosNum == -1)

  002b1	66 83 be 10 02
	00 00 ff	 cmp	 WORD PTR [esi+528], -1
  002b9	75 10		 jne	 SHORT $LN57@gObjSetSta

; 12107: 					{
; 12108: 						gObjDel(lpObj->m_Index);

  002bb	8b 06		 mov	 eax, DWORD PTR [esi]
  002bd	50		 push	 eax
  002be	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  002c3	83 c4 04	 add	 esp, 4

; 12109: 						continue;

  002c6	e9 c1 05 00 00	 jmp	 $LN74@gObjSetSta
$LN57@gObjSetSta:

; 12110: 					}
; 12111: 
; 12112: 					if(lpObj->Type == OBJ_MONSTER)

  002cb	66 83 7e 60 02	 cmp	 WORD PTR [esi+96], 2
  002d0	75 3e		 jne	 SHORT $LN55@gObjSetSta

; 12113: 					{
; 12114: 						if(lpObj->Class != 131 && BC_STATUE_RANGE(lpObj->Class - 132)== 0)

  002d2	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  002d9	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  002de	66 3b c1	 cmp	 ax, cx
  002e1	74 2d		 je	 SHORT $LN55@gObjSetSta
  002e3	05 7c ff ff ff	 add	 eax, -132		; ffffff7cH
  002e8	78 0e		 js	 SHORT $LN115@gObjSetSta
  002ea	33 d2		 xor	 edx, edx
  002ec	83 f8 02	 cmp	 eax, 2
  002ef	0f 9e c2	 setle	 dl
  002f2	8b c2		 mov	 eax, edx
  002f4	85 c0		 test	 eax, eax
  002f6	75 18		 jne	 SHORT $LN55@gObjSetSta
$LN115@gObjSetSta:

; 12115: 						{
; 12116: 							g_BloodCastle.ChangeMonsterState(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1,lpObj->m_Index);

  002f8	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  002ff	8b 06		 mov	 eax, DWORD PTR [esi]
  00301	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00304	50		 push	 eax
  00305	51		 push	 ecx
  00306	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0030b	e8 00 00 00 00	 call	 ?ChangeMonsterState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::ChangeMonsterState
$LN55@gObjSetSta:

; 12117: 						}
; 12118: 					}
; 12119: 				}
; 12120: 
; 12121: 				if(lpObj->m_Attribute == 60)

  00310	66 83 be 26 03
	00 00 3c	 cmp	 WORD PTR [esi+806], 60	; 0000003cH
  00318	75 10		 jne	 SHORT $LN54@gObjSetSta

; 12122: 				{
; 12123: 					gObjDel(lpObj->m_Index);

  0031a	8b 16		 mov	 edx, DWORD PTR [esi]
  0031c	52		 push	 edx
  0031d	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00322	83 c4 04	 add	 esp, 4

; 12124: 					continue;

  00325	e9 62 05 00 00	 jmp	 $LN74@gObjSetSta
$LN54@gObjSetSta:

; 12125: 				}
; 12126: 
; 12127: #if GS_CASTLE == 1
; 12128: 				if(lpObj->m_Attribute == 61)
; 12129: 				{
; 12130: 					gObjDel(lpObj->m_Index);
; 12131: 					continue;
; 12132: 				}
; 12133: 
; 12134: 				if(lpObj->m_Attribute == 62)
; 12135: 				{
; 12136: 					switch ( lpObj->Class )
; 12137: 					{
; 12138: 						case 300:	case 301:	case 302:	case 303:	
; 12139: 							gObjDel(lpObj->m_Index);
; 12140: 							continue;
; 12141: 					}
; 12142: 
; 12143: 					if ( (lpObj->m_dwLastCheckTick+600000) < GetTickCount() )
; 12144: 					{
; 12145: 						gObjDel(lpObj->m_Index);
; 12146: 						continue;
; 12147: 					}
; 12148: 				}
; 12149: #endif
; 12150: 
; 12151: 				if(lpObj->Type >= OBJ_MONSTER)

  0032a	0f b7 4e 60	 movzx	 ecx, WORD PTR [esi+96]
  0032e	83 f9 02	 cmp	 ecx, 2
  00331	72 38		 jb	 SHORT $LN52@gObjSetSta

; 12152: 				{
; 12153: 					if(lpObj->Class == 287 || lpObj->Class == 286)

  00333	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  0033a	ba 1f 01 00 00	 mov	 edx, 287		; 0000011fH
  0033f	66 3b c2	 cmp	 ax, dx
  00342	74 0a		 je	 SHORT $LN51@gObjSetSta
  00344	ba 1e 01 00 00	 mov	 edx, 286		; 0000011eH
  00349	66 3b c2	 cmp	 ax, dx
  0034c	75 1d		 jne	 SHORT $LN52@gObjSetSta
$LN51@gObjSetSta:

; 12154: 					{
; 12155: 						g_CsNPC_Mercenary.DeleteMercenary(lpObj->m_Index);

  0034e	8b 06		 mov	 eax, DWORD PTR [esi]
  00350	50		 push	 eax
  00351	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Mercenary@@3VCMercenary@@A ; g_CsNPC_Mercenary
  00356	e8 00 00 00 00	 call	 ?DeleteMercenary@CMercenary@@QAEHH@Z ; CMercenary::DeleteMercenary

; 12156: 						gObjDel(lpObj->m_Index);

  0035b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0035d	51		 push	 ecx
  0035e	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00363	83 c4 04	 add	 esp, 4

; 12157: 						continue;

  00366	e9 21 05 00 00	 jmp	 $LN74@gObjSetSta
$LN52@gObjSetSta:

; 12158: 					}
; 12159: 				}
; 12160: 
; 12161: #if GS_CASTLE == 1
; 12162: 				if ( lpObj->Type >= OBJ_MONSTER && lpObj->Class == 278 )
; 12163: 				{
; 12164: 					g_CsNPC_LifeStone.DeleteLifeStone(lpObj->m_Index);
; 12165: 					gObjDel(lpObj->m_Index);
; 12166: 					continue;
; 12167: 				}
; 12168: #endif
; 12169: 
; 12170: 				int State = 1;

  0036b	ba 01 00 00 00	 mov	 edx, 1

; 12171: 
; 12172: 				if(lpObj->Type >= OBJ_MONSTER)

  00370	83 f9 02	 cmp	 ecx, 2
  00373	0f 82 92 00 00
	00		 jb	 $LN126@gObjSetSta

; 12173: 				{
; 12174: 					if(lpObj->Class == 44 && DragonEvent->GetState() == 0)

  00379	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00380	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00383	75 12		 jne	 SHORT $LN124@gObjSetSta
  00385	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  0038b	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  0038f	75 06		 jne	 SHORT $LN124@gObjSetSta

; 12175: 					{
; 12176: 						State = 0;

  00391	33 db		 xor	 ebx, ebx
  00393	33 d2		 xor	 edx, edx
  00395	eb 02		 jmp	 SHORT $LN49@gObjSetSta
$LN124@gObjSetSta:
  00397	33 db		 xor	 ebx, ebx
$LN49@gObjSetSta:

; 12177: 					}
; 12178: 
; 12179: 					if(lpObj->Class == 53	||
; 12180: 						lpObj->Class == 54	||
; 12181: 						lpObj->Class == 55	||
; 12182: 						lpObj->Class == 56)

  00399	83 f8 35	 cmp	 eax, 53			; 00000035H
  0039c	74 0f		 je	 SHORT $LN47@gObjSetSta
  0039e	83 f8 36	 cmp	 eax, 54			; 00000036H
  003a1	74 0a		 je	 SHORT $LN47@gObjSetSta
  003a3	83 f8 37	 cmp	 eax, 55			; 00000037H
  003a6	74 05		 je	 SHORT $LN47@gObjSetSta
  003a8	83 f8 38	 cmp	 eax, 56			; 00000038H
  003ab	75 14		 jne	 SHORT $LN48@gObjSetSta
$LN47@gObjSetSta:

; 12183: 					{
; 12184: 						State = 0;
; 12185: 						lpObj->Life = lpObj->MaxLife;

  003ad	d9 86 c0 00 00
	00		 fld	 DWORD PTR [esi+192]
  003b3	33 d2		 xor	 edx, edx
  003b5	d9 9e bc 00 00
	00		 fstp	 DWORD PTR [esi+188]

; 12186: 						lpObj->DieRegen = 0;

  003bb	88 96 02 02 00
	00		 mov	 BYTE PTR [esi+514], dl
$LN48@gObjSetSta:

; 12187: 					}
; 12188: 	
; 12189: 					if(lpObj->Class >= 78 && lpObj->Class <= 83)

  003c1	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  003c4	72 19		 jb	 SHORT $LN46@gObjSetSta
  003c6	83 f8 53	 cmp	 eax, 83			; 00000053H
  003c9	77 14		 ja	 SHORT $LN46@gObjSetSta

; 12190: 					{
; 12191: 						State = 0;
; 12192: 						lpObj->Life = lpObj->MaxLife;

  003cb	d9 86 c0 00 00
	00		 fld	 DWORD PTR [esi+192]
  003d1	33 d2		 xor	 edx, edx
  003d3	d9 9e bc 00 00
	00		 fstp	 DWORD PTR [esi+188]

; 12193: 						lpObj->DieRegen = 0;

  003d9	88 96 02 02 00
	00		 mov	 BYTE PTR [esi+514], dl
$LN46@gObjSetSta:

; 12194: 					}
; 12195: 	
; 12196: 					if(lpObj->Class == 77)

  003df	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  003e2	75 1d		 jne	 SHORT $LN125@gObjSetSta

; 12197: 					{
; 12198: 						int i_shield = lpObj->m_SkyBossMonSheildLinkIndex;

  003e4	8b 86 f4 0e 00
	00		 mov	 eax, DWORD PTR [esi+3828]

; 12199: 	
; 12200: 						if(i_shield != -1)

  003ea	83 f8 ff	 cmp	 eax, -1
  003ed	74 12		 je	 SHORT $LN125@gObjSetSta

; 12201: 						{	
; 12202: 							gObj[i_shield].Life = gObj[i_shield].MaxLife;

  003ef	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  003f5	d9 80 c0 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+192]
  003fb	d9 98 bc 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+188]
$LN125@gObjSetSta:

; 12203: 						}	
; 12204: 					}
; 12205: 				}
; 12206: 
; 12207: 				PMSG_CHARREGEN pMsg;
; 12208: 
; 12209: 				if(State != 0)

  00401	3b d3		 cmp	 edx, ebx
  00403	0f 84 83 04 00
	00		 je	 $LN74@gObjSetSta
  00409	eb 02		 jmp	 SHORT $LN116@gObjSetSta
$LN126@gObjSetSta:
  0040b	33 db		 xor	 ebx, ebx
$LN116@gObjSetSta:

; 12210: 				{
; 12211: 					lpObj->Life = lpObj->MaxLife + lpObj->AddLife;

  0040d	db 86 0c 01 00
	00		 fild	 DWORD PTR [esi+268]

; 12212: 					lpObj->Mana = lpObj->MaxMana + lpObj->AddMana;
; 12213: 
; 12214: 					lpObj->Live = 1;
; 12215: 					lpObj->m_PoisonBeattackCount = 0;
; 12216: 					lpObj->m_ColdBeattackCount = 0;
; 12217: 					lpObj->m_ViewState = 0;
; 12218: 					lpObj->Teleport = 0;
; 12219: 
; 12220: 					for(int i = 0; i < MAX_SELF_DEFENSE; i++)
; 12221: 					{
; 12222: 						lpObj->SelfDefenseTime[i] = 0;

  00413	33 c0		 xor	 eax, eax
  00415	c6 46 62 01	 mov	 BYTE PTR [esi+98], 1
  00419	66 c7 86 27 02
	00 00 00 00	 mov	 WORD PTR [esi+551], 0
  00422	d8 86 c0 00 00
	00		 fadd	 DWORD PTR [esi+192]
  00428	c6 86 c2 01 00
	00 00		 mov	 BYTE PTR [esi+450], 0
  0042f	c6 86 00 02 00
	00 00		 mov	 BYTE PTR [esi+512], 0

; 12223: 					}
; 12224: 
; 12225: 					gObjTimeCheckSelfDefense(lpObj);

  00436	56		 push	 esi
  00437	d9 9e bc 00 00
	00		 fstp	 DWORD PTR [esi+188]
  0043d	db 86 10 01 00
	00		 fild	 DWORD PTR [esi+272]
  00443	d8 86 d4 00 00
	00		 fadd	 DWORD PTR [esi+212]
  00449	d9 9e d0 00 00
	00		 fstp	 DWORD PTR [esi+208]
  0044f	89 86 5c 02 00
	00		 mov	 DWORD PTR [esi+604], eax
  00455	89 86 60 02 00
	00		 mov	 DWORD PTR [esi+608], eax
  0045b	89 86 64 02 00
	00		 mov	 DWORD PTR [esi+612], eax
  00461	89 86 68 02 00
	00		 mov	 DWORD PTR [esi+616], eax
  00467	89 86 6c 02 00
	00		 mov	 DWORD PTR [esi+620], eax
  0046d	e8 00 00 00 00	 call	 ?gObjTimeCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@@Z ; gObjTimeCheckSelfDefense

; 12226: 
; 12227: 					lpObj->m_ViewSkillState &= 0xFFFFFFFE;
; 12228: 					lpObj->m_ViewSkillState &= 0xFFFFFFFD;

  00472	83 a6 c4 01 00
	00 fc		 and	 DWORD PTR [esi+452], -4	; fffffffcH

; 12229: 
; 12230: 					gObjClearViewport(lpObj);

  00479	56		 push	 esi
  0047a	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport
  0047f	83 c4 08	 add	 esp, 8

; 12231: 
; 12232: 					if(lpObj->Type == OBJ_USER)

  00482	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00487	0f 85 c9 03 00
	00		 jne	 $LN39@gObjSetSta

; 12233: 					{
; 12234: 						if(g_iUseCharacterAutoRecuperationSystem != 0 && lpObj->Level <= g_iCharacterRecuperationMaxLevel)

  0048d	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?g_iUseCharacterAutoRecuperationSystem@@3HA, ebx ; g_iUseCharacterAutoRecuperationSystem
  00493	74 1d		 je	 SHORT $LN38@gObjSetSta
  00495	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  0049c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iCharacterRecuperationMaxLevel@@3HA ; g_iCharacterRecuperationMaxLevel
  004a2	7f 0e		 jg	 SHORT $LN38@gObjSetSta

; 12235: 						{
; 12236: 							lpObj->m_iAutoRecuperationTime = GetTickCount();

  004a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  004aa	89 86 20 15 00
	00		 mov	 DWORD PTR [esi+5408], eax

; 12237: 						}
; 12238: 						else

  004b0	eb 06		 jmp	 SHORT $LN37@gObjSetSta
$LN38@gObjSetSta:

; 12239: 						{
; 12240: 							lpObj->m_iAutoRecuperationTime = 0;

  004b2	89 9e 20 15 00
	00		 mov	 DWORD PTR [esi+5408], ebx
$LN37@gObjSetSta:

; 12241: 						}
; 12242: 
; 12243: 						if(lpObj->m_iSkillNPCHelpTime > 0)

  004b8	39 9e 24 15 00
	00		 cmp	 DWORD PTR [esi+5412], ebx
  004be	7e 2b		 jle	 SHORT $LN36@gObjSetSta

; 12244: 						{
; 12245: 							lpObj->m_iSkillNPCHelpTime = 0;
; 12246: 							lpObj->m_iSkillNPCDefense = 0;
; 12247: 							lpObj->m_iSkillNPCAttack = 0;
; 12248: 
; 12249: 							lpObj->m_ViewSkillState &= 0xFDFFFFFF;

  004c0	81 a6 c4 01 00
	00 ff ff ff fd	 and	 DWORD PTR [esi+452], -33554433 ; fdffffffH

; 12250: 
; 12251: 							GCStateInfoSend(lpObj,0,0x02000000);

  004ca	68 00 00 00 02	 push	 33554432		; 02000000H
  004cf	53		 push	 ebx
  004d0	56		 push	 esi
  004d1	89 9e 24 15 00
	00		 mov	 DWORD PTR [esi+5412], ebx
  004d7	89 9e 28 15 00
	00		 mov	 DWORD PTR [esi+5416], ebx
  004dd	89 9e 2c 15 00
	00		 mov	 DWORD PTR [esi+5420], ebx
  004e3	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  004e8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@gObjSetSta:

; 12252: 						}
; 12253: 
; 12254: 						gDarkSpirit[lpObj->m_Index].SetMode(CDarkSpirit::ePetItem_Mode::PetItem_Mode_Normal,-1);

  004eb	8b 06		 mov	 eax, DWORD PTR [esi]
  004ed	6a ff		 push	 -1
  004ef	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  004f2	53		 push	 ebx
  004f3	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gDarkSpirit@@3PAVCDarkSpirit@@A[ecx*8]
  004fa	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode

; 12255: 
; 12256: 						if(lpObj->KillerType == 3)

  004ff	8a 86 01 02 00
	00		 mov	 al, BYTE PTR [esi+513]
  00505	3c 03		 cmp	 al, 3
  00507	75 27		 jne	 SHORT $LN35@gObjSetSta
$LN117@gObjSetSta:

; 12257: 						{
; 12258: 							MapC[lpObj->MapNumber].GetRandomLengthPos((short &)lpObj->X,(short &)lpObj->Y,18);

  00509	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00510	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00516	6a 12		 push	 18			; 00000012H
  00518	8d 86 06 01 00
	00		 lea	 eax, DWORD PTR [esi+262]
  0051e	50		 push	 eax
  0051f	57		 push	 edi
  00520	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00526	e8 00 00 00 00	 call	 ?GetRandomLengthPos@MapClass@@QAEXAAF0H@Z ; MapClass::GetRandomLengthPos
  0052b	e9 30 01 00 00	 jmp	 $LN12@gObjSetSta
$LN35@gObjSetSta:

; 12259: 						}
; 12260: 						else if(lpObj->KillerType == 2)

  00530	3c 02		 cmp	 al, 2
  00532	75 45		 jne	 SHORT $LN33@gObjSetSta

; 12261: 						{
; 12262: 							int w_Type = 0;
; 12263: 
; 12264: 							if(lpObj->lpGuild != 0)

  00534	8b 86 b4 02 00
	00		 mov	 eax, DWORD PTR [esi+692]
  0053a	3b c3		 cmp	 eax, ebx
  0053c	74 cb		 je	 SHORT $LN117@gObjSetSta

; 12265: 							{
; 12266: 								if(lpObj->lpGuild->WarType == 1)

  0053e	80 b8 92 05 00
	00 01		 cmp	 BYTE PTR [eax+1426], 1

; 12267: 								{
; 12268: 									w_Type = 1;
; 12269: 								}
; 12270: 							}
; 12271: 
; 12272: 							if(w_Type == 0)
; 12273: 							{
; 12274: 								MapC[lpObj->MapNumber].GetRandomLengthPos((short &)lpObj->X,(short &)lpObj->Y,18);

  00545	75 c2		 jne	 SHORT $LN117@gObjSetSta

; 12275: 							}
; 12276: 							else if(lpObj->lpGuild->WarState)

  00547	80 b8 91 05 00
	00 00		 cmp	 BYTE PTR [eax+1425], 0
  0054e	0f 84 0c 01 00
	00		 je	 $LN12@gObjSetSta

; 12277: 							{
; 12278: 								int BattleGroundIndex = lpObj->lpGuild->BattleGroundIndex;
; 12279: 								gBattleGetTeamPosition(BattleGroundIndex,lpObj->lpGuild->BattleTeamCode,(short &)lpObj->X,(short &)lpObj->Y);

  00554	0f b6 90 93 05
	00 00		 movzx	 edx, BYTE PTR [eax+1427]
  0055b	8d 8e 06 01 00
	00		 lea	 ecx, DWORD PTR [esi+262]
  00561	51		 push	 ecx
  00562	0f b6 88 94 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1428]
  00569	57		 push	 edi
  0056a	51		 push	 ecx
  0056b	52		 push	 edx
  0056c	e8 00 00 00 00	 call	 ?gBattleGetTeamPosition@@YAXHHAAF0@Z ; gBattleGetTeamPosition
  00571	83 c4 10	 add	 esp, 16			; 00000010H

; 12280: 							}
; 12281: 						}

  00574	e9 e7 00 00 00	 jmp	 $LN12@gObjSetSta
$LN33@gObjSetSta:

; 12282: 						else if(lpObj->MapNumber == MAP_INDEX_LORENCIA || lpObj->MapNumber == MAP_INDEX_DUNGEON)

  00579	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  0057f	84 c0		 test	 al, al
  00581	0f 84 bf 00 00
	00		 je	 $LN25@gObjSetSta
  00587	3c 01		 cmp	 al, 1
  00589	0f 84 b7 00 00
	00		 je	 $LN25@gObjSetSta

; 12286: 						}
; 12287: 						else if(DS_MAP_RANGE(lpObj->MapNumber))

  0058f	3c 09		 cmp	 al, 9
  00591	74 0b		 je	 SHORT $LN118@gObjSetSta
  00593	33 c9		 xor	 ecx, ecx
  00595	3c 20		 cmp	 al, 32			; 00000020H
  00597	0f 94 c1	 sete	 cl
  0059a	3b cb		 cmp	 ecx, ebx
  0059c	74 26		 je	 SHORT $LN23@gObjSetSta
$LN118@gObjSetSta:

; 12288: 						{
; 12289: 							g_DevilSquare.DieProcDevilSquare(lpObj);

  0059e	56		 push	 esi
  0059f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  005a4	e8 00 00 00 00	 call	 ?DieProcDevilSquare@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@@Z ; CDevilSquare::DieProcDevilSquare

; 12290: 							lpObj->MapNumber = MAP_INDEX_NORIA;
; 12291: 							MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber,(short &)lpObj->X,(short &)lpObj->Y);

  005a9	8d 86 06 01 00
	00		 lea	 eax, DWORD PTR [esi+262]
  005af	50		 push	 eax
  005b0	57		 push	 edi
  005b1	c6 86 09 01 00
	00 03		 mov	 BYTE PTR [esi+265], 3
  005b8	6a 03		 push	 3
  005ba	b9 18 15 0f 00	 mov	 ecx, OFFSET ?MapC@@3PAVMapClass@@A+988440
  005bf	e9 97 00 00 00	 jmp	 $LN129@gObjSetSta
$LN23@gObjSetSta:

; 12292: 						}
; 12293: 						else if(lpObj->MapNumber == MAP_INDEX_ICARUS)

  005c4	3c 0a		 cmp	 al, 10			; 0000000aH
  005c6	75 18		 jne	 SHORT $LN21@gObjSetSta
$LN130@gObjSetSta:

; 12294: 						{
; 12295: 							lpObj->MapNumber = MAP_INDEX_DEVIAS;
; 12296: 							MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber,(short &)lpObj->X,(short &)lpObj->Y);

  005c8	8d 86 06 01 00
	00		 lea	 eax, DWORD PTR [esi+262]
  005ce	50		 push	 eax
  005cf	57		 push	 edi
  005d0	c6 86 09 01 00
	00 02		 mov	 BYTE PTR [esi+265], 2
  005d7	6a 02		 push	 2
  005d9	b9 10 0e 0a 00	 mov	 ecx, OFFSET ?MapC@@3PAVMapClass@@A+658960
  005de	eb 7b		 jmp	 SHORT $LN129@gObjSetSta
$LN21@gObjSetSta:

; 12297: 						}
; 12298: 						else if(BC_MAP_RANGE(lpObj->MapNumber))

  005e0	3c 0b		 cmp	 al, 11			; 0000000bH
  005e2	72 0e		 jb	 SHORT $LN19@gObjSetSta
  005e4	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  005e9	3a c8		 cmp	 cl, al
  005eb	1b c9		 sbb	 ecx, ecx
  005ed	41		 inc	 ecx
  005ee	3b cb		 cmp	 ecx, ebx

; 12299: 						{
; 12300: 							lpObj->MapNumber = MAP_INDEX_DEVIAS;
; 12301: 							MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber,(short &)lpObj->X,(short &)lpObj->Y);

  005f0	75 d6		 jne	 SHORT $LN130@gObjSetSta
$LN19@gObjSetSta:

; 12302: 						}
; 12303: 						else if(CC_MAP_RANGE(lpObj->MapNumber))

  005f2	3c 12		 cmp	 al, 18			; 00000012H
  005f4	72 0b		 jb	 SHORT $LN17@gObjSetSta
  005f6	b2 17		 mov	 dl, 23			; 00000017H
  005f8	3a d0		 cmp	 dl, al
  005fa	1b c9		 sbb	 ecx, ecx
  005fc	41		 inc	 ecx
  005fd	3b cb		 cmp	 ecx, ebx

; 12304: 						{
; 12305: 							lpObj->MapNumber = MAP_INDEX_DEVIAS;
; 12306: 							MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber,(short &)lpObj->X,(short &)lpObj->Y);

  005ff	75 c7		 jne	 SHORT $LN130@gObjSetSta
$LN17@gObjSetSta:

; 12307: 						}
; 12308: 						else if(KALIMA_MAP_RANGE(lpObj->MapNumber))

  00601	3c 18		 cmp	 al, 24			; 00000018H
  00603	72 0f		 jb	 SHORT $LN15@gObjSetSta
  00605	3c 1d		 cmp	 al, 29			; 0000001dH
  00607	76 bf		 jbe	 SHORT $LN130@gObjSetSta
  00609	33 c9		 xor	 ecx, ecx
  0060b	3c 24		 cmp	 al, 36			; 00000024H
  0060d	0f 94 c1	 sete	 cl
  00610	3b cb		 cmp	 ecx, ebx

; 12309: 						{
; 12310: 							lpObj->MapNumber = MAP_INDEX_DEVIAS;
; 12311: 							MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber,(short &)lpObj->X,(short &)lpObj->Y);

  00612	75 b4		 jne	 SHORT $LN130@gObjSetSta
$LN15@gObjSetSta:

; 12312: 						}
; 12313: #if GS_CASTLE == 1
; 12314: 						else if(lpObj->MapNumber == MAP_INDEX_CASTLEHUNTZONE)
; 12315: 						{
; 12316: 							int mgt = 106;
; 12317: 							short x,y,level;
; 12318: 							BYTE map = lpObj->MapNumber,dir;
; 12319: 							int result = gGateC.GetGate(mgt,(short &)x,(short &)y,(BYTE &)map,(BYTE &)dir,(short &)level);
; 12320: 
; 12321: 							if(result >= 0)
; 12322: 							{
; 12323: 								lpObj->MapNumber = map;
; 12324: 								lpObj->X = x;
; 12325: 								lpObj->Y = y;
; 12326: 							}
; 12327: 						}
; 12328: 						else if(lpObj->MapNumber == MAP_INDEX_CASTLESIEGE)
; 12329: 						{
; 12330: 							if ( g_CsNPC_LifeStone.SetReSpawnUserXY(lpObj->m_Index) == FALSE )
; 12331: 							{
; 12332: 								int mgt = 100;
; 12333: 								if ( lpObj->m_btCsJoinSide == 1 )
; 12334: 									mgt = 105;
; 12335: 								else
; 12336: 									mgt = 100;
; 12337: 
; 12338: 								short x,y,level;
; 12339: 								BYTE map = lpObj->MapNumber,dir;
; 12340: 								int result = gGateC.GetGate(mgt,(short &)x,(short &)y,(BYTE &)map,(BYTE &)dir,(short &)level);
; 12341: 
; 12342: 								if(result >= 0)
; 12343: 								{
; 12344: 									lpObj->MapNumber = map;
; 12345: 									lpObj->X = x;
; 12346: 									lpObj->Y = y;
; 12347: 								}
; 12348: 							}
; 12349: 						}
; 12350: #endif
; 12351: 						else if(lpObj->MapNumber == MAP_INDEX_AIDA)

  00614	3c 21		 cmp	 al, 33			; 00000021H
  00616	75 11		 jne	 SHORT $LN13@gObjSetSta

; 12352: 						{
; 12353: 							MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber,(short &)lpObj->X,(short &)lpObj->Y);

  00618	8d 86 06 01 00
	00		 lea	 eax, DWORD PTR [esi+262]
  0061e	50		 push	 eax
  0061f	57		 push	 edi
  00620	6a 21		 push	 33			; 00000021H
  00622	b9 08 e8 a5 00	 mov	 ecx, OFFSET ?MapC@@3PAVMapClass@@A+10872840

; 12354: 						}
; 12355: 						else

  00627	eb 32		 jmp	 SHORT $LN129@gObjSetSta
$LN13@gObjSetSta:

; 12356: 						{
; 12357: 							MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber,(short &)lpObj->X,(short &)lpObj->Y);

  00629	8d 8e 06 01 00
	00		 lea	 ecx, DWORD PTR [esi+262]
  0062f	51		 push	 ecx
  00630	0f b6 c8	 movzx	 ecx, al
  00633	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00639	0f b6 d0	 movzx	 edx, al
  0063c	57		 push	 edi
  0063d	52		 push	 edx
  0063e	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00644	eb 15		 jmp	 SHORT $LN129@gObjSetSta
$LN25@gObjSetSta:

; 12283: 						{
; 12284: 							lpObj->MapNumber = MAP_INDEX_LORENCIA;
; 12285: 							MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber,(short &)lpObj->X,(short &)lpObj->Y);

  00646	8d 86 06 01 00
	00		 lea	 eax, DWORD PTR [esi+262]
  0064c	50		 push	 eax
  0064d	57		 push	 edi
  0064e	c6 86 09 01 00
	00 00		 mov	 BYTE PTR [esi+265], 0
  00655	53		 push	 ebx
  00656	b9 00 00 00 00	 mov	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
$LN129@gObjSetSta:
  0065b	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos
$LN12@gObjSetSta:

; 12358: 						}
; 12359: 
; 12360: 						short m_Result = g_MapServerManager.CheckMoveMapSvr(lpObj->m_Index,lpObj->MapNumber,lpObj->m_sPrevMapSvrCode);

  00660	0f b7 86 cc 14
	00 00		 movzx	 eax, WORD PTR [esi+5324]
  00667	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  0066e	8b 16		 mov	 edx, DWORD PTR [esi]
  00670	50		 push	 eax
  00671	51		 push	 ecx
  00672	52		 push	 edx
  00673	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  00678	e8 00 00 00 00	 call	 ?CheckMoveMapSvr@CMapServerManager@@QAEFHHF@Z ; CMapServerManager::CheckMoveMapSvr
  0067d	0f b7 d8	 movzx	 ebx, ax

; 12361: 
; 12362: 						if(m_Result != gGameServerCode )

  00680	66 3b 1d 00 00
	00 00		 cmp	 bx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00687	0f 84 86 00 00
	00		 je	 $LN11@gObjSetSta

; 12363: 						{
; 12364: 							if(m_Result == -1)

  0068d	66 83 fb ff	 cmp	 bx, -1
  00691	75 1f		 jne	 SHORT $LN10@gObjSetSta

; 12365: 							{
; 12366: 								LogAdd(LOG_RED, "[MapServerMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s][%s] (%d)",lpObj->AccountID,lpObj->Name,lpObj->m_Index);

  00693	8b 06		 mov	 eax, DWORD PTR [esi]
  00695	50		 push	 eax
  00696	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  00699	51		 push	 ecx
  0069a	83 c6 64	 add	 esi, 100		; 00000064H
  0069d	56		 push	 esi
  0069e	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@
  006a3	6a 01		 push	 1
  006a5	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  006aa	83 c4 14	 add	 esp, 20			; 00000014H

; 12367: 								continue;

  006ad	e9 da 01 00 00	 jmp	 $LN74@gObjSetSta
$LN10@gObjSetSta:

; 12368: 							}
; 12369: 
; 12370: 							int _map = lpObj->MapNumber;
; 12371: 							int _x = lpObj->X;
; 12372: 							int _y = lpObj->Y;

  006b2	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  006b9	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  006c0	0f bf 0f	 movsx	 ecx, WORD PTR [edi]
  006c3	89 55 dc	 mov	 DWORD PTR __y$166212[ebp], edx

; 12373: 
; 12374: 							lpObj->MapNumber = mapnum;

  006c6	8a 55 d4	 mov	 dl, BYTE PTR _mapnum$166112[ebp]
  006c9	88 96 09 01 00
	00		 mov	 BYTE PTR [esi+265], dl

; 12375: 							lpObj->X = x;

  006cf	0f b7 55 d0	 movzx	 edx, WORD PTR _x$166113[ebp]
  006d3	66 89 17	 mov	 WORD PTR [edi], dx

; 12376: 							lpObj->Y = y;

  006d6	0f b7 55 e0	 movzx	 edx, WORD PTR _y$166114[ebp]
  006da	66 89 96 06 01
	00 00		 mov	 WORD PTR [esi+262], dx

; 12377: 
; 12378: 							GJReqMapSvrMove(lpObj->m_Index,m_Result,_map,_x,_y);

  006e1	8b 55 dc	 mov	 edx, DWORD PTR __y$166212[ebp]
  006e4	52		 push	 edx
  006e5	51		 push	 ecx
  006e6	50		 push	 eax
  006e7	8b 06		 mov	 eax, DWORD PTR [esi]
  006e9	53		 push	 ebx
  006ea	50		 push	 eax
  006eb	e8 00 00 00 00	 call	 ?GJReqMapSvrMove@@YAXHGGEE@Z ; GJReqMapSvrMove

; 12379: 							LogAdd(LOG_BLACK, "[MapServerMng] Request to Move Map Server : (%d) - [%s][%s] (%d)",m_Result,lpObj->AccountID,lpObj->Name,lpObj->m_Index);

  006f0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  006f2	51		 push	 ecx
  006f3	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  006f6	52		 push	 edx
  006f7	0f bf c3	 movsx	 eax, bx
  006fa	83 c6 64	 add	 esi, 100		; 00000064H
  006fd	56		 push	 esi
  006fe	50		 push	 eax
  006ff	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@
  00704	6a 00		 push	 0
  00706	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0070b	83 c4 2c	 add	 esp, 44			; 0000002cH

; 12380: 							continue;

  0070e	e9 79 01 00 00	 jmp	 $LN74@gObjSetSta
$LN11@gObjSetSta:

; 12381: 						}
; 12382: 
; 12383: 						lpObj->TX = lpObj->X;
; 12384: 						lpObj->TY = lpObj->Y;

  00713	0f b7 8e 06 01
	00 00		 movzx	 ecx, WORD PTR [esi+262]
  0071a	0f b7 07	 movzx	 eax, WORD PTR [edi]

; 12385: 
; 12386: 						CreateFrustrum(lpObj->X,lpObj->Y,n);

  0071d	8b 5d d8	 mov	 ebx, DWORD PTR _n$166103[ebp]
  00720	66 89 8e 22 01
	00 00		 mov	 WORD PTR [esi+290], cx
  00727	0f bf c9	 movsx	 ecx, cx
  0072a	53		 push	 ebx
  0072b	0f bf d0	 movsx	 edx, ax
  0072e	51		 push	 ecx
  0072f	52		 push	 edx
  00730	66 89 86 20 01
	00 00		 mov	 WORD PTR [esi+288], ax
  00737	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum

; 12387: 
; 12388: 						pMsg.h.c = 0xC3;
; 12389: 						pMsg.h.headcode = 0xF3;
; 12390: 						pMsg.h.size = 0x18;
; 12391: 						pMsg.subcode = 0x04;
; 12392: 						pMsg.Dir = lpObj->Dir;

  0073c	0f b6 86 08 01
	00 00		 movzx	 eax, BYTE PTR [esi+264]

; 12393: 						pMsg.MapX = lpObj->X;
; 12394: 						pMsg.MapY = lpObj->Y;
; 12395: 						pMsg.Life = lpObj->Life;

  00743	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  00749	88 45 eb	 mov	 BYTE PTR _pMsg$166148[ebp+7], al
  0074c	d9 7d de	 fnstcw	 WORD PTR tv1399[ebp]
  0074f	0f b7 45 de	 movzx	 eax, WORD PTR tv1399[ebp]
  00753	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00758	89 45 e0	 mov	 DWORD PTR tv1396[ebp], eax
  0075b	8a 0f		 mov	 cl, BYTE PTR [edi]
  0075d	8a 96 06 01 00
	00		 mov	 dl, BYTE PTR [esi+262]
  00763	d9 6d e0	 fldcw	 WORD PTR tv1396[ebp]
  00766	88 4d e8	 mov	 BYTE PTR _pMsg$166148[ebp+4], cl
  00769	88 55 e9	 mov	 BYTE PTR _pMsg$166148[ebp+5], dl

; 12396: 						pMsg.Mana = lpObj->Mana;
; 12397: 						pMsg.Exp = lpObj->Experience;

  0076c	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [esi+168]

; 12398: 						pMsg.MapNumber = lpObj->MapNumber;
; 12399: 						pMsg.Money = lpObj->Money;
; 12400: 						pMsg.BP = lpObj->BP;
; 12401: 
; 12402: 						lpObj->PathCount = 0;
; 12403: 
; 12404: 						DataSend(n,(unsigned char *)&pMsg,pMsg.h.size);

  00772	6a 18		 push	 24			; 00000018H
  00774	89 55 f4	 mov	 DWORD PTR _pMsg$166148[ebp+16], edx
  00777	db 5d e0	 fistp	 DWORD PTR tv1394[ebp]
  0077a	66 8b 96 e8 00
	00 00		 mov	 dx, WORD PTR [esi+232]
  00781	66 8b 45 e0	 mov	 ax, WORD PTR tv1394[ebp]
  00785	66 89 45 ec	 mov	 WORD PTR _pMsg$166148[ebp+8], ax
  00789	c6 45 e4 c3	 mov	 BYTE PTR _pMsg$166148[ebp], 195 ; 000000c3H
  0078d	66 c7 45 e5 18
	f3		 mov	 WORD PTR _pMsg$166148[ebp+1], 62232 ; 0000f318H
  00793	c6 45 e7 04	 mov	 BYTE PTR _pMsg$166148[ebp+3], 4
  00797	d9 6d de	 fldcw	 WORD PTR tv1399[ebp]
  0079a	66 89 55 f0	 mov	 WORD PTR _pMsg$166148[ebp+12], dx
  0079e	c7 86 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+296], 0
  007a8	d9 86 d0 00 00
	00		 fld	 DWORD PTR [esi+208]
  007ae	d9 7d de	 fnstcw	 WORD PTR tv1390[ebp]
  007b1	0f b7 45 de	 movzx	 eax, WORD PTR tv1390[ebp]
  007b5	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  007ba	89 45 e0	 mov	 DWORD PTR tv1387[ebp], eax
  007bd	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  007c4	d9 6d e0	 fldcw	 WORD PTR tv1387[ebp]
  007c7	88 45 ea	 mov	 BYTE PTR _pMsg$166148[ebp+6], al
  007ca	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$166148[ebp]
  007cd	50		 push	 eax
  007ce	53		 push	 ebx
  007cf	db 5d e0	 fistp	 DWORD PTR tv1385[ebp]
  007d2	66 8b 4d e0	 mov	 cx, WORD PTR tv1385[ebp]
  007d6	66 89 4d ee	 mov	 WORD PTR _pMsg$166148[ebp+10], cx
  007da	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  007e0	d9 6d de	 fldcw	 WORD PTR tv1390[ebp]
  007e3	89 4d f8	 mov	 DWORD PTR _pMsg$166148[ebp+20], ecx
  007e6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 12405: 
; 12406: 						gObjViewportListProtocolCreate(lpObj);

  007eb	56		 push	 esi
  007ec	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate

; 12407: 
; 12408: 						if(DragonEvent->GetState())

  007f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  007f6	83 c4 1c	 add	 esp, 28			; 0000001cH
  007f9	80 78 04 00	 cmp	 BYTE PTR [eax+4], 0
  007fd	74 1b		 je	 SHORT $LN127@gObjSetSta

; 12409: 						{
; 12410: 							if(DragonEvent->GetMapNumber() == lpObj->MapNumber)

  007ff	8a 8e 09 01 00
	00		 mov	 cl, BYTE PTR [esi+265]
  00805	38 48 0c	 cmp	 BYTE PTR [eax+12], cl
  00808	75 10		 jne	 SHORT $LN127@gObjSetSta

; 12411: 							{
; 12412: 								GCMapEventStateSend(lpObj->MapNumber,1,1);

  0080a	6a 01		 push	 1
  0080c	0f b6 c9	 movzx	 ecx, cl
  0080f	6a 01		 push	 1
  00811	51		 push	 ecx
  00812	e8 00 00 00 00	 call	 ?GCMapEventStateSend@@YAXHEE@Z ; GCMapEventStateSend
  00817	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN127@gObjSetSta:

; 12413: 							}
; 12414: 						}
; 12415: 
; 12416: 						gEledoradoEvent.CheckGoldDercon(lpObj->MapNumber);

  0081a	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR [esi+265]
  00821	52		 push	 edx
  00822	b9 00 00 00 00	 mov	 ecx, OFFSET ?gEledoradoEvent@@3VCEledoradoEvent@@A ; gEledoradoEvent
  00827	e8 00 00 00 00	 call	 ?CheckGoldDercon@CEledoradoEvent@@QAEXH@Z ; CEledoradoEvent::CheckGoldDercon

; 12417: 
; 12418: #if GS_CASTLE == 1
; 12419: 						if ( lpObj->MapNumber == MAP_INDEX_CASTLESIEGE )
; 12420: 						{
; 12421: 							GCAnsCsNotifyStart(lpObj->m_Index, CHECK_CLASS(g_CastleSiege.GetCastleState(), CASTLESIEGE_STATE_STARTSIEGE));
; 12422: 
; 12423: 							if ( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 12424: 							{
; 12425: 								g_CastleSiege.NotifySelfCsJoinSide(lpObj->m_Index);
; 12426: 								g_CastleSiege.NotifyCsSelfLeftTime(lpObj->m_Index);
; 12427: 							}
; 12428: 						}
; 12429: #endif
; 12430: 
; 12431: 						if(gTamaJJangEvent!=0 && gAppearTamaJJang!=0)

  0082c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gTamaJJangEvent@@3HA, 0 ; gTamaJJangEvent
  00833	74 46		 je	 SHORT $LN5@gObjSetSta
  00835	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gAppearTamaJJang@@3HA ; gAppearTamaJJang
  0083a	85 c0		 test	 eax, eax
  0083c	74 3d		 je	 SHORT $LN5@gObjSetSta

; 12432: 						{
; 12433: 							if(lpObj->MapNumber == MAP_INDEX_LORENCIA)

  0083e	80 be 09 01 00
	00 00		 cmp	 BYTE PTR [esi+265], 0
  00845	75 34		 jne	 SHORT $LN5@gObjSetSta

; 12434: 							{
; 12435: 								GCMapEventStateSend(0,gAppearTamaJJang,2);

  00847	0f b6 c0	 movzx	 eax, al
  0084a	6a 02		 push	 2
  0084c	50		 push	 eax
  0084d	6a 00		 push	 0
  0084f	e8 00 00 00 00	 call	 ?GCMapEventStateSend@@YAXHEE@Z ; GCMapEventStateSend

; 12436: 							}
; 12437: 						}
; 12438: 					}
; 12439: 					else

  00854	eb 22		 jmp	 SHORT $LN131@gObjSetSta
$LN39@gObjSetSta:

; 12440: 					{
; 12441: 						if(gObjMonsterRegen(lpObj)==0)

  00856	56		 push	 esi
  00857	e8 00 00 00 00	 call	 ?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterRegen
  0085c	83 c4 04	 add	 esp, 4
  0085f	85 c0		 test	 eax, eax
  00861	74 29		 je	 SHORT $LN74@gObjSetSta

; 12442: 						{
; 12443: 							continue;
; 12444: 						}
; 12445: 						CreateFrustrum(lpObj->X,lpObj->Y,n);

  00863	8b 4d d8	 mov	 ecx, DWORD PTR _n$166103[ebp]
  00866	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  0086d	0f bf 07	 movsx	 eax, WORD PTR [edi]
  00870	51		 push	 ecx
  00871	52		 push	 edx
  00872	50		 push	 eax
  00873	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
$LN131@gObjSetSta:
  00878	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@gObjSetSta:

; 12446: 					}
; 12447: 
; 12448: 					lpObj->DieRegen = 0;

  0087b	c6 86 02 02 00
	00 00		 mov	 BYTE PTR [esi+514], 0

; 12449: 					lpObj->m_State = 1;

  00882	c7 86 bc 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+444], 1
$LN74@gObjSetSta:

; 12012: 	int n;
; 12013: 	LPOBJ lpObj;
; 12014: 
; 12015: 	for(int n = 0; n < OBJMAX; n++)

  0088c	8b 45 d8	 mov	 eax, DWORD PTR _n$166103[ebp]
  0088f	40		 inc	 eax
  00890	89 45 d8	 mov	 DWORD PTR _n$166103[ebp], eax
  00893	3d e8 1c 00 00	 cmp	 eax, 7400		; 00001ce8H
  00898	0f 8c 82 f7 ff
	ff		 jl	 $LL75@gObjSetSta

; 12450: 				}
; 12451: 			}
; 12452: 		}
; 12453: 	}
; 12454: 
; 12455: 	for(int n = 0; n < MAX_NUMBER_MAP; n++)

  0089e	be 00 00 00 00	 mov	 esi, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
$LL3@gObjSetSta:

; 12456: 	{
; 12457: 		MapC[n].StateSetDestroy();

  008a3	8b ce		 mov	 ecx, esi
  008a5	e8 00 00 00 00	 call	 ?StateSetDestroy@MapClass@@QAEXXZ ; MapClass::StateSetDestroy
  008aa	81 c6 08 07 05
	00		 add	 esi, 329480		; 00050708H
  008b0	81 fe 40 19 c9
	00		 cmp	 esi, OFFSET ?MapC@@3PAVMapClass@@A+13179200
  008b6	7c eb		 jl	 SHORT $LL3@gObjSetSta

; 12458: 	}
; 12459: }

  008b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008bb	5f		 pop	 edi
  008bc	5e		 pop	 esi
  008bd	33 cd		 xor	 ecx, ebp
  008bf	5b		 pop	 ebx
  008c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008c5	8b e5		 mov	 esp, ebp
  008c7	5d		 pop	 ebp
  008c8	c3		 ret	 0
?gObjSetState@@YAXXZ ENDP				; gObjSetState
_TEXT	ENDS
PUBLIC	??_C@_0GM@NPKLGGJP@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@ ; `string'
PUBLIC	??_C@_0GB@CGCBNNKJ@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@ ; `string'
PUBLIC	??_C@_0DH@LJCMNCCO@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@ ; `string'
;	COMDAT ??_C@_0GM@NPKLGGJP@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@
CONST	SEGMENT
??_C@_0GM@NPKLGGJP@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@ DB '['
	DB	'Summon Monster] [%s][%s] Try to Kill Summoned Monster - Finis'
	DB	'hed to Kill Summoned Monster (SummonIndex:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@CGCBNNKJ@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@
CONST	SEGMENT
??_C@_0GB@CGCBNNKJ@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@ DB '['
	DB	'Summon Monster] [%s][%s] Try to Kill Summoned Monster - Found'
	DB	' Summoned Monster (SummonIndex:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@LJCMNCCO@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@
CONST	SEGMENT
??_C@_0DH@LJCMNCCO@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@ DB '['
	DB	'Summon Monster] [%s][%s] Try to Kill Summoned Monster', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjMonsterCallKill@@YAXH@Z
_TEXT	SEGMENT
tv194 = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjMonsterCallKill@@YAXH@Z PROC			; gObjMonsterCallKill, COMDAT

; 16355: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 16356: 	LogAdd(LOG_BLACK, "[Summon Monster] [%s][%s] Try to Kill Summoned Monster",gObj[aIndex].AccountID,gObj[aIndex].Name);

  00006	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00009	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0000f	57		 push	 edi
  00010	8d 9e 6f 00 00
	00		 lea	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00016	8d 86 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  0001c	53		 push	 ebx
  0001d	50		 push	 eax
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@LJCMNCCO@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@
  00023	6a 00		 push	 0
  00025	89 45 fc	 mov	 DWORD PTR tv194[ebp], eax
  00028	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 16357: 
; 16358: 	if(gObj[aIndex].m_RecallMon < 0)

  0002d	8b be cc 02 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+716]
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	85 ff		 test	 edi, edi
  00038	0f 88 83 00 00
	00		 js	 $LN5@gObjMonste@7

; 16359: 	{
; 16360: 		return;
; 16361: 	}
; 16362: 
; 16363: 	int callmon = gObj[aIndex].m_RecallMon;
; 16364: 
; 16365: 	if(callmon < 0 || callmon > OBJMAX -1 )

  0003e	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  00044	77 7b		 ja	 SHORT $LN5@gObjMonste@7

; 16366: 	{
; 16367: 		return;
; 16368: 	}
; 16369: 
; 16370: 	if(gObj[callmon].Type != OBJ_MONSTER)

  00046	8b c7		 mov	 eax, edi
  00048	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0004e	66 83 b8 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 2
  00056	75 69		 jne	 SHORT $LN5@gObjMonste@7

; 16371: 	{
; 16372: 		return;
; 16373: 	}
; 16374: 
; 16375: 	if(gObj[callmon].m_RecallMon != aIndex)

  00058	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0005b	39 88 cc 02 00
	00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716], ecx
  00061	75 5e		 jne	 SHORT $LN5@gObjMonste@7

; 16376: 	{
; 16377: 		return;
; 16378: 	}
; 16379: 
; 16380: 	if(gObj[aIndex].m_RecallMon >= 0)
; 16381: 	{
; 16382: 		if(gObjIsConnected(gObj[aIndex].m_RecallMon)==1)

  00063	57		 push	 edi
  00064	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00069	83 c4 04	 add	 esp, 4
  0006c	83 f8 01	 cmp	 eax, 1
  0006f	75 2b		 jne	 SHORT $LN10@gObjMonste@7

; 16383: 		{
; 16384: 			LogAdd(LOG_BLACK, "[Summon Monster] [%s][%s] Try to Kill Summoned Monster - Found Summoned Monster (SummonIndex:%d)",gObj[aIndex].AccountID,gObj[aIndex].Name,gObj[aIndex].m_RecallMon);

  00071	8b 55 fc	 mov	 edx, DWORD PTR tv194[ebp]
  00074	57		 push	 edi
  00075	53		 push	 ebx
  00076	52		 push	 edx
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0GB@CGCBNNKJ@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@
  0007c	6a 00		 push	 0
  0007e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 16385: 			gObj[gObj[aIndex].m_RecallMon].m_RecallMon = -1;

  00083	8b 86 cc 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+716]
  00089	83 c4 14	 add	 esp, 20			; 00000014H
  0008c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00092	c7 80 cc 02 00
	00 ff ff ff ff	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716], -1
$LN10@gObjMonste@7:

; 16386: 		}
; 16387: 	}
; 16388: 
; 16389: 	gObj[aIndex].m_RecallMon = -1;
; 16390: 	gObjDel(callmon);

  0009c	57		 push	 edi
  0009d	c7 86 cc 02 00
	00 ff ff ff ff	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+716], -1
  000a7	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel

; 16391: 
; 16392: 	LogAdd(LOG_BLACK, "[Summon Monster] [%s][%s] Try to Kill Summoned Monster - Finished to Kill Summoned Monster (SummonIndex:%d)",gObj[aIndex].AccountID,gObj[aIndex].Name,callmon);

  000ac	8b 4d fc	 mov	 ecx, DWORD PTR tv194[ebp]
  000af	57		 push	 edi
  000b0	53		 push	 ebx
  000b1	51		 push	 ecx
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0GM@NPKLGGJP@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@
  000b7	6a 00		 push	 0
  000b9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000be	83 c4 18	 add	 esp, 24			; 00000018H
$LN5@gObjMonste@7:
  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx

; 16393: }

  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
?gObjMonsterCallKill@@YAXH@Z ENDP			; gObjMonsterCallKill
_TEXT	ENDS
PUBLIC	??_C@_0BD@BLMMKPFO@Item?5not?5found?5?$CB?$CB?$CB?$AA@ ; `string'
PUBLIC	??_C@_0CC@GOGGAFJG@Penalty?5?3?5Item?5Don?8t?5touch?5?5?$CFs?5?$CF@ ; `string'
PUBLIC	??_C@_0BG@DNBFMJJP@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Set?5Event?5GM?$AA@ ; `string'
PUBLIC	??_C@_0CF@PDDCMPCL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Find?5Invalid?5QuestInfo?5@ ; `string'
PUBLIC	??_C@_0BD@DHOELAFE@error?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0DO@LEOKHNJP@?$FLMapServerMng?$FN?5Dest?5Map?5Server?5d@ ; `string'
PUBLIC	??_C@_0CD@JILLGNNC@error?5?3?5Map?5Number?5max?5over?4?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0BG@PGPOOLHE@error?5?3?5?$CFs?5Level?5Zero?$AA@ ; `string'
PUBLIC	??_C@_0CF@CDKKBDHM@error?9L1?5?3?5ChaosBox?5Init?5error?5?$CF@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	_lpdata$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjSetCharacter@@YAHPAEH@Z			; gObjSetCharacter
EXTRN	?SendMain@CServerInfo@@QAEXH@Z:PROC		; CServerInfo::SendMain
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
EXTRN	?Add@CLoginCount@@QAEXXZ:PROC			; CLoginCount::Add
EXTRN	?GCCheckMainExeKeySend@@YAXH@Z:PROC		; GCCheckMainExeKeySend
EXTRN	?CGWeatherSend@@YAXHE@Z:PROC			; CGWeatherSend
EXTRN	?GetWeather@MapClass@@QAEEXZ:PROC		; MapClass::GetWeather
EXTRN	?ManagerAdd@CGMMng@@QAEHPADH@Z:PROC		; CGMMng::ManagerAdd
EXTRN	?ReSetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z:PROC ; CQuestInfo::ReSetQuestState
EXTRN	?gApplyHeroSystem@@3HA:DWORD			; gApplyHeroSystem
EXTRN	?GetLevelPos@MapClass@@QAEXFAAF0@Z:PROC		; MapClass::GetLevelPos
EXTRN	?GetGate@CGate@@QAEHHAAF0AAE10@Z:PROC		; CGate::GetGate
EXTRN	?gGateC@@3VCGate@@A:BYTE			; gGateC
EXTRN	?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; ChaosBoxInit
;	COMDAT ??_C@_0BD@BLMMKPFO@Item?5not?5found?5?$CB?$CB?$CB?$AA@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.h
CONST	SEGMENT
??_C@_0BD@BLMMKPFO@Item?5not?5found?5?$CB?$CB?$CB?$AA@ DB 'Item not found'
	DB	' !!!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GOGGAFJG@Penalty?5?3?5Item?5Don?8t?5touch?5?5?$CFs?5?$CF@
CONST	SEGMENT
??_C@_0CC@GOGGAFJG@Penalty?5?3?5Item?5Don?8t?5touch?5?5?$CFs?5?$CF@ DB 'P'
	DB	'enalty : Item Don''t touch  %s %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DNBFMJJP@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Set?5Event?5GM?$AA@
CONST	SEGMENT
??_C@_0BG@DNBFMJJP@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Set?5Event?5GM?$AA@ DB '(%'
	DB	's)(%s) Set Event GM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PDDCMPCL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Find?5Invalid?5QuestInfo?5@
CONST	SEGMENT
??_C@_0CF@PDDCMPCL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Find?5Invalid?5QuestInfo?5@ DB '['
	DB	'%s][%s] Find Invalid QuestInfo (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DHOELAFE@error?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@DHOELAFE@error?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ?$AA@ DB 'error '
	DB	': %d (%s %d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@LEOKHNJP@?$FLMapServerMng?$FN?5Dest?5Map?5Server?5d@
CONST	SEGMENT
??_C@_0DO@LEOKHNJP@?$FLMapServerMng?$FN?5Dest?5Map?5Server?5d@ DB '[MapSe'
	DB	'rverMng] Dest Map Server doesn''t have Map [%s][%s] : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JILLGNNC@error?5?3?5Map?5Number?5max?5over?4?5?$CFs?5@
CONST	SEGMENT
??_C@_0CD@JILLGNNC@error?5?3?5Map?5Number?5max?5over?4?5?$CFs?5@ DB 'erro'
	DB	'r : Map Number max over. %s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PGPOOLHE@error?5?3?5?$CFs?5Level?5Zero?$AA@
CONST	SEGMENT
??_C@_0BG@PGPOOLHE@error?5?3?5?$CFs?5Level?5Zero?$AA@ DB 'error : %s Leve'
	DB	'l Zero', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CDKKBDHM@error?9L1?5?3?5ChaosBox?5Init?5error?5?$CF@
CONST	SEGMENT
??_C@_0CF@CDKKBDHM@error?9L1?5?3?5ChaosBox?5Init?5error?5?$CF@ DB 'error-'
	DB	'L1 : ChaosBox Init error %s %d', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\user.cpp
CONST	ENDS
;	COMDAT ?gObjSetCharacter@@YAHPAEH@Z
_TEXT	SEGMENT
_y$ = -332						; size = 2
_x$ = -328						; size = 2
tv830 = -324						; size = 4
_bEnergyBall$162386 = -320				; size = 4
tv1577 = -316						; size = 4
_bForceSkill$162387 = -316				; size = 4
_weather$ = -312					; size = 1
_aIndex$GSCopy$ = -312					; size = 4
_level$ = -308						; size = 2
_mapNumber$ = -302					; size = 1
_dir$ = -301						; size = 1
_lpdata$GSCopy$ = -300					; size = 4
tv2265 = -296						; size = 4
tv2263 = -296						; size = 4
tv2261 = -296						; size = 4
tv2259 = -296						; size = 4
tv2242 = -296						; size = 4
tv2239 = -296						; size = 4
tv2235 = -296						; size = 4
_IsGetInitinityArrowSkill$162388 = -296			; size = 4
_bAllItemExist$ = -289					; size = 1
_pNotice$162443 = -288					; size = 272
_szCharName$ = -16					; size = 11
__$ArrayPad$ = -4					; size = 4
_lpdata$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?gObjSetCharacter@@YAHPAEH@Z PROC			; gObjSetCharacter, COMDAT

; 1585 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR _lpdata$[ebp]

; 2174 : 	{
; 2175 : 		lpObj->m_ViewSkillState |= 0x1000000;

  0001a	89 b5 d4 fe ff
	ff		 mov	 DWORD PTR _lpdata$GSCopy$[ebp], esi
  00020	89 8d c8 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ecx
  00026	85 c9		 test	 ecx, ecx
  00028	78 0f		 js	 SHORT $LN125@gObjSetCha

; 1586 : 	int itype;
; 1587 : 	int n;
; 1588 : 	char szCharName[MAX_ACCOUNT_LEN+1];
; 1589 : 	// ---
; 1590 : 	SDHP_DBCHAR_INFORESULT * lpMsg = (SDHP_DBCHAR_INFORESULT *)lpdata;
; 1591 : 	// ---
; 1592 : 	if(OBJMAX_RANGE(aIndex) == FALSE)

  0002a	33 c0		 xor	 eax, eax
  0002c	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  00032	0f 9e c0	 setle	 al
  00035	85 c0		 test	 eax, eax
  00037	75 2a		 jne	 SHORT $LN94@gObjSetCha
$LN125@gObjSetCha:

; 1593 : 	{
; 1594 : 		LogAdd(LOG_BLACK, "error : %s %d", __FILE__, __LINE__);

  00039	68 3a 06 00 00	 push	 1594			; 0000063aH
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00048	6a 00		 push	 0
  0004a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0004f	83 c4 10	 add	 esp, 16			; 00000010H

; 1595 : 		return FALSE;

  00052	33 c0		 xor	 eax, eax
  00054	5e		 pop	 esi

; 2180 : 
; 2181 : 	return TRUE;
; 2182 : }

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	33 cd		 xor	 ecx, ebp
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
$LN94@gObjSetCha:

; 1596 : 	}
; 1597 : 	// ---
; 1598 : 	LPOBJ lpObj = &gObj[aIndex];

  00063	8b c1		 mov	 eax, ecx
  00065	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H

; 1599 : 	// ---
; 1600 : 	if(lpObj->Connected < PLAYER_LOGGED)

  0006b	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  00072	53		 push	 ebx
  00073	8d 98 00 00 00
	00		 lea	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]

; 1601 : 	{
; 1602 : 		return FALSE;

  00079	72 31		 jb	 SHORT $LN160@gObjSetCha

; 1603 : 	}
; 1604 : 	// ---
; 1605 : 	if(gObj[aIndex].Connected == PLAYER_PLAYING)

  0007b	80 b8 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 3
  00082	75 3a		 jne	 SHORT $LN92@gObjSetCha

; 1606 : 	{
; 1607 : 		LogAdd(LOG_RED,  lMsg.Get(MSGGET(1, 242)), gObj[aIndex].AccountID, gObj[aIndex].Name);

  00084	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  0008a	51		 push	 ecx
  0008b	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00091	52		 push	 edx
  00092	68 f2 01 00 00	 push	 498			; 000001f2H
  00097	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0009c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000a1	50		 push	 eax
  000a2	6a 01		 push	 1
  000a4	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000a9	83 c4 10	 add	 esp, 16			; 00000010H
$LN160@gObjSetCha:

; 1608 : 		return FALSE;

  000ac	5b		 pop	 ebx
  000ad	33 c0		 xor	 eax, eax
  000af	5e		 pop	 esi

; 2180 : 
; 2181 : 	return TRUE;
; 2182 : }

  000b0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b3	33 cd		 xor	 ecx, ebp
  000b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
$LN92@gObjSetCha:

; 1609 : 	}
; 1610 : 	// ---
; 1611 : 	if(lpMsg->Class == 0x00 || lpMsg->Class == 0x10 || lpMsg->Class == 0x20 || lpMsg->Class == 0x30 || lpMsg->Class == 0x01 || lpMsg->Class == 0x11 || lpMsg->Class == 0x21 || lpMsg->Class == 0x40)

  000be	8a 46 1d	 mov	 al, BYTE PTR [esi+29]
  000c1	84 c0		 test	 al, al
  000c3	74 1c		 je	 SHORT $LN90@gObjSetCha
  000c5	3c 10		 cmp	 al, 16			; 00000010H
  000c7	74 18		 je	 SHORT $LN90@gObjSetCha
  000c9	3c 20		 cmp	 al, 32			; 00000020H
  000cb	74 14		 je	 SHORT $LN90@gObjSetCha
  000cd	3c 30		 cmp	 al, 48			; 00000030H
  000cf	74 10		 je	 SHORT $LN90@gObjSetCha
  000d1	3c 01		 cmp	 al, 1
  000d3	74 0c		 je	 SHORT $LN90@gObjSetCha
  000d5	3c 11		 cmp	 al, 17			; 00000011H
  000d7	74 08		 je	 SHORT $LN90@gObjSetCha
  000d9	3c 21		 cmp	 al, 33			; 00000021H
  000db	74 04		 je	 SHORT $LN90@gObjSetCha
  000dd	3c 40		 cmp	 al, 64			; 00000040H

; 1612 : 	{
; 1613 : 
; 1614 : 	}
; 1615 : 	else
; 1616 : 	{
; 1617 : 		return FALSE;

  000df	75 cb		 jne	 SHORT $LN160@gObjSetCha
$LN90@gObjSetCha:

; 1618 : 	}
; 1619 : 	// ---
; 1620 : 	gObjCharZeroSet(aIndex);

  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 ?gObjCharZeroSet@@YAXH@Z ; gObjCharZeroSet

; 1621 : 	// ---
; 1622 : 	if(ChaosBoxInit(lpObj) == FALSE)

  000e7	53		 push	 ebx
  000e8	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit
  000ed	83 c4 08	 add	 esp, 8
  000f0	85 c0		 test	 eax, eax
  000f2	75 18		 jne	 SHORT $LN88@gObjSetCha

; 1623 : 	{
; 1624 : 		LogAdd(LOG_BLACK, "error-L1 : ChaosBox Init error %s %d", __FILE__, __LINE__);

  000f4	68 58 06 00 00	 push	 1624			; 00000658H
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CDKKBDHM@error?9L1?5?3?5ChaosBox?5Init?5error?5?$CF@
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00109	83 c4 10	 add	 esp, 16			; 00000010H
$LN88@gObjSetCha:

; 1625 : 	}
; 1626 : 	// ---
; 1627 : 	lpObj->m_PosNum		= 0;

  0010c	33 c0		 xor	 eax, eax
  0010e	66 89 83 10 02
	00 00		 mov	 WORD PTR [ebx+528], ax

; 1628 : 	lpObj->Level		= lpMsg->Level;

  00115	0f b7 4e 1e	 movzx	 ecx, WORD PTR [esi+30]
  00119	66 89 8b 9c 00
	00 00		 mov	 WORD PTR [ebx+156], cx

; 1629 : 	lpObj->LevelUpPoint = lpMsg->LevelUpPoint;

  00120	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00123	89 93 a0 00 00
	00		 mov	 DWORD PTR [ebx+160], edx

; 1630 : 	lpObj->DbClass		= lpMsg->Class;

  00129	0f b6 46 1d	 movzx	 eax, BYTE PTR [esi+29]
  0012d	88 83 9a 00 00
	00		 mov	 BYTE PTR [ebx+154], al

; 1631 : 	lpObj->Class		= lpMsg->Class >> 4;

  00133	8a 4e 1d	 mov	 cl, BYTE PTR [esi+29]
  00136	c0 e9 04	 shr	 cl, 4
  00139	0f b6 d1	 movzx	 edx, cl
  0013c	66 89 93 98 00
	00 00		 mov	 WORD PTR [ebx+152], dx

; 1632 : 	lpObj->ChangeUP		= lpMsg->Class & 0x07;

  00143	0f b6 46 1d	 movzx	 eax, BYTE PTR [esi+29]
  00147	24 07		 and	 al, 7
  00149	88 83 9b 00 00
	00		 mov	 BYTE PTR [ebx+155], al

; 1633 : 	// ---
; 1634 : 	szCharName[MAX_ACCOUNT_LEN] = 0;
; 1635 : 	// ---
; 1636 : 	memcpy(szCharName, lpMsg->Name, MAX_ACCOUNT_LEN);

  0014f	8b 4e 12	 mov	 ecx, DWORD PTR [esi+18]
  00152	8b 46 16	 mov	 eax, DWORD PTR [esi+22]
  00155	8d 56 12	 lea	 edx, DWORD PTR [esi+18]
  00158	89 4d f0	 mov	 DWORD PTR _szCharName$[ebp], ecx
  0015b	0f b7 4a 08	 movzx	 ecx, WORD PTR [edx+8]
  0015f	89 45 f4	 mov	 DWORD PTR _szCharName$[ebp+4], eax
  00162	57		 push	 edi

; 1637 : 	// ---
; 1638 : 	strcpy(lpObj->Name, szCharName);

  00163	8d 45 f0	 lea	 eax, DWORD PTR _szCharName$[ebp]
  00166	66 89 4d f8	 mov	 WORD PTR _szCharName$[ebp+8], cx
  0016a	8d 7b 6f	 lea	 edi, DWORD PTR [ebx+111]
  0016d	8b c8		 mov	 ecx, eax
  0016f	c6 45 fa 00	 mov	 BYTE PTR _szCharName$[ebp+10], 0
  00173	2b f9		 sub	 edi, ecx
$LL99@gObjSetCha:
  00175	8a 08		 mov	 cl, BYTE PTR [eax]
  00177	88 0c 07	 mov	 BYTE PTR [edi+eax], cl
  0017a	40		 inc	 eax
  0017b	84 c9		 test	 cl, cl
  0017d	75 f6		 jne	 SHORT $LL99@gObjSetCha

; 1639 : 	// ---
; 1640 : 	if(lpObj->Level < 1)

  0017f	66 83 bb 9c 00
	00 00 01	 cmp	 WORD PTR [ebx+156], 1
  00187	7d 23		 jge	 SHORT $LN87@gObjSetCha

; 1641 : 	{
; 1642 : 		LogAdd(LOG_RED,  "error : %s Level Zero", lpMsg->Name);

  00189	52		 push	 edx
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PGPOOLHE@error?5?3?5?$CFs?5Level?5Zero?$AA@
  0018f	6a 01		 push	 1
  00191	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00196	83 c4 0c	 add	 esp, 12			; 0000000cH
  00199	5f		 pop	 edi
  0019a	5b		 pop	 ebx

; 1643 : 		return FALSE;

  0019b	33 c0		 xor	 eax, eax
  0019d	5e		 pop	 esi

; 2180 : 
; 2181 : 	return TRUE;
; 2182 : }

  0019e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a1	33 cd		 xor	 ecx, ebp
  001a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c3		 ret	 0
$LN87@gObjSetCha:

; 1644 : 	}
; 1645 : 	// ---
; 1646 : 	lpObj->X			= lpMsg->MapX;

  001ac	0f b6 96 b5 07
	00 00		 movzx	 edx, BYTE PTR [esi+1973]
  001b3	8d bb 04 01 00
	00		 lea	 edi, DWORD PTR [ebx+260]
  001b9	66 89 17	 mov	 WORD PTR [edi], dx

; 1647 : 	lpObj->Y			= lpMsg->MapY;

  001bc	0f b6 86 b6 07
	00 00		 movzx	 eax, BYTE PTR [esi+1974]
  001c3	66 89 83 06 01
	00 00		 mov	 WORD PTR [ebx+262], ax

; 1648 : 	lpObj->MapNumber	= lpMsg->MapNumber;

  001ca	8a 8e b4 07 00
	00		 mov	 cl, BYTE PTR [esi+1972]
  001d0	88 8b 09 01 00
	00		 mov	 BYTE PTR [ebx+265], cl

; 1649 : 	lpObj->StartX		= lpObj->X;
; 1650 : 	lpObj->StartY		= lpObj->Y;

  001d6	0f b6 c0	 movzx	 eax, al

; 1651 : 	// ---
; 1652 : 	if(MAX_MAP_RANGE(lpObj->MapNumber) == FALSE)

  001d9	b1 27		 mov	 cl, 39			; 00000027H
  001db	3a 8b 09 01 00
	00		 cmp	 cl, BYTE PTR [ebx+265]
  001e1	88 83 1b 01 00
	00		 mov	 BYTE PTR [ebx+283], al
  001e7	1b c0		 sbb	 eax, eax
  001e9	40		 inc	 eax
  001ea	88 93 1a 01 00
	00		 mov	 BYTE PTR [ebx+282], dl
  001f0	75 33		 jne	 SHORT $LN86@gObjSetCha

; 1653 : 	{
; 1654 : 		LogAdd(LOG_BLACK, "error : Map Number max over. %s %d", __FILE__, __LINE__);

  001f2	68 76 06 00 00	 push	 1654			; 00000676H
  001f7	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  001fc	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JILLGNNC@error?5?3?5Map?5Number?5max?5over?4?5?$CFs?5@
  00201	50		 push	 eax
  00202	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00207	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 : 		// ---
; 1656 : 		lpObj->MapNumber = MAP_INDEX_LORENCIA;
; 1657 : 		// ---
; 1658 : 		MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y);

  0020a	8d 83 06 01 00
	00		 lea	 eax, DWORD PTR [ebx+262]
  00210	50		 push	 eax
  00211	57		 push	 edi
  00212	6a 00		 push	 0
  00214	b9 00 00 00 00	 mov	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00219	c6 83 09 01 00
	00 00		 mov	 BYTE PTR [ebx+265], 0
  00220	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos
$LN86@gObjSetCha:

; 1659 : 	}
; 1660 : 	// ---
; 1661 : 	if(lpObj->Level < 6 || DS_MAP_RANGE(lpObj->MapNumber) != FALSE)

  00225	66 83 bb 9c 00
	00 00 06	 cmp	 WORD PTR [ebx+156], 6
  0022d	7c 17		 jl	 SHORT $LN84@gObjSetCha
  0022f	8a 83 09 01 00
	00		 mov	 al, BYTE PTR [ebx+265]
  00235	3c 09		 cmp	 al, 9
  00237	74 0d		 je	 SHORT $LN84@gObjSetCha
  00239	33 d2		 xor	 edx, edx
  0023b	3c 20		 cmp	 al, 32			; 00000020H
  0023d	0f 94 c2	 sete	 dl
  00240	8b c2		 mov	 eax, edx
  00242	85 c0		 test	 eax, eax
  00244	74 34		 je	 SHORT $LN85@gObjSetCha
$LN84@gObjSetCha:

; 1662 : 	{
; 1663 : 		lpObj->MapNumber = gServerInfo.m_Data.iStartMap[lpObj->Class];

  00246	0f b7 83 98 00
	00 00		 movzx	 eax, WORD PTR [ebx+152]
  0024d	8a 04 85 84 00
	00 00		 mov	 al, BYTE PTR ?gServerInfo@@3VCServerInfo@@A[eax*4+132]

; 1664 : 		// ---
; 1665 : 		MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y);

  00254	8d 8b 06 01 00
	00		 lea	 ecx, DWORD PTR [ebx+262]
  0025a	51		 push	 ecx
  0025b	0f b6 c8	 movzx	 ecx, al
  0025e	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00264	0f b6 d0	 movzx	 edx, al
  00267	57		 push	 edi
  00268	52		 push	 edx
  00269	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0026f	88 83 09 01 00
	00		 mov	 BYTE PTR [ebx+265], al
  00275	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos
$LN85@gObjSetCha:

; 1666 : 	}
; 1667 : 	// ---
; 1668 : 	if(BC_MAP_RANGE(lpObj->MapNumber) != FALSE)

  0027a	0f b6 83 09 01
	00 00		 movzx	 eax, BYTE PTR [ebx+265]
  00281	3c 0b		 cmp	 al, 11			; 0000000bH
  00283	72 24		 jb	 SHORT $LN83@gObjSetCha
  00285	b1 11		 mov	 cl, 17			; 00000011H
  00287	3a c8		 cmp	 cl, al
  00289	1b c0		 sbb	 eax, eax
  0028b	40		 inc	 eax
  0028c	74 1b		 je	 SHORT $LN83@gObjSetCha

; 1669 : 	{
; 1670 : 		lpObj->MapNumber = MAP_INDEX_DEVIAS;
; 1671 : 		// ---
; 1672 : 		MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y);

  0028e	8d 83 06 01 00
	00		 lea	 eax, DWORD PTR [ebx+262]
  00294	50		 push	 eax
  00295	57		 push	 edi
  00296	6a 02		 push	 2
  00298	b9 10 0e 0a 00	 mov	 ecx, OFFSET ?MapC@@3PAVMapClass@@A+658960
  0029d	c6 83 09 01 00
	00 02		 mov	 BYTE PTR [ebx+265], 2
  002a4	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos
$LN83@gObjSetCha:

; 1673 : 	}
; 1674 : 	// ---
; 1675 : 	lpObj->m_cBloodCastleIndex		= -1;
; 1676 : 	lpObj->m_cBloodCastleSubIndex	= -1;
; 1677 : 	lpObj->m_iBloodCastleEXP		= 0;
; 1678 : 	lpObj->m_bBloodCastleComplete	= 0;
; 1679 : 	// ---
; 1680 : 	if(CC_MAP_RANGE(lpObj->MapNumber) != FALSE)

  002a9	0f b6 83 09 01
	00 00		 movzx	 eax, BYTE PTR [ebx+265]
  002b0	66 c7 83 02 0d
	00 00 ff ff	 mov	 WORD PTR [ebx+3330], 65535 ; 0000ffffH
  002b9	c7 83 04 0d 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+3332], 0
  002c3	c6 83 08 0d 00
	00 00		 mov	 BYTE PTR [ebx+3336], 0
  002ca	3c 12		 cmp	 al, 18			; 00000012H
  002cc	72 24		 jb	 SHORT $LN82@gObjSetCha
  002ce	b2 17		 mov	 dl, 23			; 00000017H
  002d0	3a d0		 cmp	 dl, al
  002d2	1b c0		 sbb	 eax, eax
  002d4	40		 inc	 eax
  002d5	74 1b		 je	 SHORT $LN82@gObjSetCha

; 1681 : 	{
; 1682 : 		lpObj->MapNumber = MAP_INDEX_DEVIAS;
; 1683 : 		// ---
; 1684 : 		MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y);

  002d7	8d 83 06 01 00
	00		 lea	 eax, DWORD PTR [ebx+262]
  002dd	50		 push	 eax
  002de	57		 push	 edi
  002df	6a 02		 push	 2
  002e1	b9 10 0e 0a 00	 mov	 ecx, OFFSET ?MapC@@3PAVMapClass@@A+658960
  002e6	c6 83 09 01 00
	00 02		 mov	 BYTE PTR [ebx+265], 2
  002ed	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos
$LN82@gObjSetCha:

; 1685 : 	}
; 1686 : 	// ---
; 1687 : 	lpObj->m_cChaosCastleIndex		= -1;
; 1688 : 	lpObj->m_cChaosCastleSubIndex	= -1;
; 1689 : 	lpObj->m_iChaosCastleBlowTime	= 0;
; 1690 : 	// ---
; 1691 : 	lpObj->m_cKillUserCount			= 0;
; 1692 : 	lpObj->m_cKillMonsterCount		= 0;
; 1693 : 	// ---
; 1694 : 	#if(GS_CASTLE == 1)
; 1695 : 	// ---
; 1696 : 	if(lpObj->MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)
; 1697 : 	{
; 1698 : 		short sX;
; 1699 : 		short sY;
; 1700 : 		short sLVL;
; 1701 : 		// ---
; 1702 : 		unsigned char btMAPNUM = lpObj->MapNumber;
; 1703 : 		// ---
; 1704 : 		unsigned char btDIR;
; 1705 : 		// ---
; 1706 : 		int iMapNumber = gGateC.GetGate(100, (short &)sX, (short &)sY, (BYTE &)btMAPNUM,(BYTE &)btDIR, (short &)sLVL);
; 1707 : 		// ---
; 1708 : 		if(iMapNumber >= 0)
; 1709 : 		{
; 1710 : 			lpObj->MapNumber	= btMAPNUM;
; 1711 : 			lpObj->X			= sX;
; 1712 : 			lpObj->Y			= sY;
; 1713 : 			// ---
; 1714 : 			lpObj->m_sDestMapNumber = btMAPNUM;
; 1715 : 			lpObj->m_btDestX		= sX;
; 1716 : 			lpObj->m_btDestY		= sY;
; 1717 : 		}
; 1718 : 	}
; 1719 : 	// ---
; 1720 : 	if(lpObj->MapNumber == MAP_INDEX_CASTLEHUNTZONE)
; 1721 : 	{
; 1722 : 		short sX;
; 1723 : 		short sY;
; 1724 : 		short sLVL;
; 1725 : 		unsigned char btMAPNUM = lpObj->MapNumber;
; 1726 : 		unsigned char btDIR;
; 1727 : 
; 1728 : 		int iMapNumber = gGateC.GetGate(106,(short &)sX,(short &)sY,(BYTE &)btMAPNUM,(BYTE &)btDIR,(short &)sLVL);
; 1729 : 
; 1730 : 		if(iMapNumber >= 0)
; 1731 : 		{
; 1732 : 			lpObj->MapNumber = btMAPNUM;
; 1733 : 			lpObj->X = sX;
; 1734 : 			lpObj->Y = sY;
; 1735 : 			lpObj->m_sDestMapNumber = btMAPNUM;
; 1736 : 			lpObj->m_btDestX = sX;
; 1737 : 			lpObj->m_btDestY = sY;
; 1738 : 		}
; 1739 : 	}
; 1740 : #endif
; 1741 : 
; 1742 : 	if ( lpObj->m_bMapSvrMoveReq == true )

  002f2	80 bb c5 14 00
	00 01		 cmp	 BYTE PTR [ebx+5317], 1
  002f9	66 c7 83 09 0d
	00 00 ff ff	 mov	 WORD PTR [ebx+3337], 65535 ; 0000ffffH
  00302	c7 83 0c 0d 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+3340], 0
  0030c	66 c7 83 10 0d
	00 00 00 00	 mov	 WORD PTR [ebx+3344], 0
  00315	75 63		 jne	 SHORT $LN79@gObjSetCha

; 1743 : 	{
; 1744 : 		short sSVR_CODE = ::g_MapServerManager.CheckMoveMapSvr(lpObj->m_Index, lpObj->m_sDestMapNumber, lpObj->m_sPrevMapSvrCode);

  00317	0f b7 83 cc 14
	00 00		 movzx	 eax, WORD PTR [ebx+5324]
  0031e	0f bf 8b ce 14
	00 00		 movsx	 ecx, WORD PTR [ebx+5326]
  00325	8b 13		 mov	 edx, DWORD PTR [ebx]
  00327	50		 push	 eax
  00328	51		 push	 ecx
  00329	52		 push	 edx
  0032a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  0032f	e8 00 00 00 00	 call	 ?CheckMoveMapSvr@CMapServerManager@@QAEFHHF@Z ; CMapServerManager::CheckMoveMapSvr
  00334	0f b7 c0	 movzx	 eax, ax

; 1745 : 
; 1746 : 		if ( sSVR_CODE == gGameServerCode )

  00337	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  0033e	0f 85 e4 00 00
	00		 jne	 $LN80@gObjSetCha

; 1747 : 		{
; 1748 : 			lpObj->MapNumber = lpObj->m_sDestMapNumber;

  00344	0f b6 83 ce 14
	00 00		 movzx	 eax, BYTE PTR [ebx+5326]

; 1749 : 			lpObj->X = lpObj->m_btDestX;

  0034b	0f b6 8b d0 14
	00 00		 movzx	 ecx, BYTE PTR [ebx+5328]

; 1750 : 			lpObj->Y = lpObj->m_btDestY;

  00352	0f b6 93 d1 14
	00 00		 movzx	 edx, BYTE PTR [ebx+5329]
  00359	88 83 09 01 00
	00		 mov	 BYTE PTR [ebx+265], al

; 1751 : 			lpObj->StartX = lpObj->X;

  0035f	0f b6 c1	 movzx	 eax, cl
  00362	66 89 0f	 mov	 WORD PTR [edi], cx

; 1752 : 			lpObj->StartY = lpObj->Y;

  00365	8a ca		 mov	 cl, dl
  00367	66 89 93 06 01
	00 00		 mov	 WORD PTR [ebx+262], dx
  0036e	88 83 1a 01 00
	00		 mov	 BYTE PTR [ebx+282], al
  00374	88 8b 1b 01 00
	00		 mov	 BYTE PTR [ebx+283], cl
$LN79@gObjSetCha:

; 1761 : 		}
; 1762 : 	}
; 1763 : 
; 1764 : 	BYTE attr = MapC[lpObj->MapNumber].GetAttr(lpObj->X, lpObj->Y);

  0037a	0f b6 8b 09 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+265]
  00381	0f bf 93 06 01
	00 00		 movsx	 edx, WORD PTR [ebx+262]
  00388	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  0038e	0f bf 07	 movsx	 eax, WORD PTR [edi]
  00391	52		 push	 edx
  00392	50		 push	 eax
  00393	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00399	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 1765 : 	int result;
; 1766 : 	short x;
; 1767 : 	short y;
; 1768 : 	BYTE mapNumber;
; 1769 : 	BYTE dir;
; 1770 : 	short level;
; 1771 : 	int gt;
; 1772 : 	int userlevel;
; 1773 : 
; 1774 : 	if ( (attr&4) == 4 || (attr&8) == 8 )

  0039e	a8 0c		 test	 al, 12			; 0000000cH
  003a0	74 40		 je	 SHORT $LN78@gObjSetCha

; 1775 : 	{
; 1776 : 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(1, 243)));

  003a2	68 f3 01 00 00	 push	 499			; 000001f3H
  003a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003ac	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003b1	50		 push	 eax
  003b2	6a 00		 push	 0
  003b4	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 1777 : 		MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y);

  003b9	8a 83 09 01 00
	00		 mov	 al, BYTE PTR [ebx+265]
  003bf	83 c4 08	 add	 esp, 8
  003c2	8d 8b 06 01 00
	00		 lea	 ecx, DWORD PTR [ebx+262]
  003c8	51		 push	 ecx
  003c9	0f b6 c8	 movzx	 ecx, al
  003cc	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  003d2	0f b6 d0	 movzx	 edx, al
  003d5	57		 push	 edi
  003d6	52		 push	 edx
  003d7	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  003dd	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos
$LN78@gObjSetCha:

; 1778 : 	}
; 1779 : 
; 1780 : 	mapNumber = MAP_INDEX_LORENCIA;
; 1781 : 	userlevel = gObj[aIndex].Level;
; 1782 : 	x = lpObj->X;

  003e2	0f b7 07	 movzx	 eax, WORD PTR [edi]

; 1783 : 	y = lpObj->Y;

  003e5	0f b7 8b 06 01
	00 00		 movzx	 ecx, WORD PTR [ebx+262]

; 1784 : 	dir = lpObj->Dir;

  003ec	8a 93 08 01 00
	00		 mov	 dl, BYTE PTR [ebx+264]
  003f2	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _x$[ebp], eax

; 1785 : 	level = lpObj->Level;

  003f8	0f b7 83 9c 00
	00 00		 movzx	 eax, WORD PTR [ebx+156]
  003ff	89 85 cc fe ff
	ff		 mov	 DWORD PTR _level$[ebp], eax

; 1786 : 	mapNumber = lpObj->MapNumber;

  00405	8a 83 09 01 00
	00		 mov	 al, BYTE PTR [ebx+265]
  0040b	89 8d b4 fe ff
	ff		 mov	 DWORD PTR _y$[ebp], ecx
  00411	88 95 d3 fe ff
	ff		 mov	 BYTE PTR _dir$[ebp], dl
  00417	88 85 d2 fe ff
	ff		 mov	 BYTE PTR _mapNumber$[ebp], al

; 1787 : 	gt = 0;
; 1788 : 
; 1789 : 	if ( lpObj->MapNumber == MAP_INDEX_DEVIAS )

  0041d	3c 02		 cmp	 al, 2
  0041f	75 41		 jne	 SHORT $LN76@gObjSetCha

; 1790 : 	{
; 1791 : 		gt = 22;

  00421	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00426	eb 52		 jmp	 SHORT $LN126@gObjSetCha
$LN80@gObjSetCha:

; 1753 : 		}
; 1754 : 		else	
; 1755 : 		{
; 1756 : 			LogAdd(LOG_RED,  "[MapServerMng] Dest Map Server doesn't have Map [%s][%s] : %d",
; 1757 : 				lpObj->AccountID, lpObj->Name, lpObj->m_sDestMapNumber);

  00428	0f bf 93 ce 14
	00 00		 movsx	 edx, WORD PTR [ebx+5326]
  0042f	52		 push	 edx
  00430	8d 43 6f	 lea	 eax, DWORD PTR [ebx+111]
  00433	50		 push	 eax
  00434	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  00437	50		 push	 eax
  00438	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@LEOKHNJP@?$FLMapServerMng?$FN?5Dest?5Map?5Server?5d@
  0043d	6a 01		 push	 1
  0043f	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 1758 : 			gObjDel(lpObj->m_Index);

  00444	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00446	51		 push	 ecx
  00447	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0044c	83 c4 18	 add	 esp, 24			; 00000018H
  0044f	5f		 pop	 edi
  00450	5b		 pop	 ebx

; 1759 : 
; 1760 : 			return FALSE;

  00451	33 c0		 xor	 eax, eax
  00453	5e		 pop	 esi

; 2180 : 
; 2181 : 	return TRUE;
; 2182 : }

  00454	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00457	33 cd		 xor	 ecx, ebp
  00459	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0045e	8b e5		 mov	 esp, ebp
  00460	5d		 pop	 ebp
  00461	c3		 ret	 0
$LN76@gObjSetCha:

; 1792 : 	}
; 1793 : 	else if ( lpObj->MapNumber == MAP_INDEX_NORIA )

  00462	3c 03		 cmp	 al, 3
  00464	75 07		 jne	 SHORT $LN74@gObjSetCha

; 1794 : 	{
; 1795 : 		gt = 27;

  00466	b8 1b 00 00 00	 mov	 eax, 27			; 0000001bH
  0046b	eb 0d		 jmp	 SHORT $LN126@gObjSetCha
$LN74@gObjSetCha:

; 1796 : 	}
; 1797 : 	else if ( lpObj->MapNumber == MAP_INDEX_LOSTTOWER )

  0046d	3c 04		 cmp	 al, 4
  0046f	0f 85 dc 00 00
	00		 jne	 $LN63@gObjSetCha

; 1798 : 	{
; 1799 : 		gt = 42;

  00475	b8 2a 00 00 00	 mov	 eax, 42			; 0000002aH
$LN126@gObjSetCha:

; 1800 : 	}
; 1801 : 
; 1802 : 	if ( gt > 0 )
; 1803 : 	{
; 1804 : 		result = gGateC.GetGate(gt, x, y, mapNumber, dir, level);

  0047a	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _level$[ebp]
  00480	51		 push	 ecx
  00481	8d 95 d3 fe ff
	ff		 lea	 edx, DWORD PTR _dir$[ebp]
  00487	52		 push	 edx
  00488	8d 8d d2 fe ff
	ff		 lea	 ecx, DWORD PTR _mapNumber$[ebp]
  0048e	51		 push	 ecx
  0048f	8d 95 b4 fe ff
	ff		 lea	 edx, DWORD PTR _y$[ebp]
  00495	52		 push	 edx
  00496	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _x$[ebp]
  0049c	51		 push	 ecx
  0049d	50		 push	 eax
  0049e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  004a3	e8 00 00 00 00	 call	 ?GetGate@CGate@@QAEHHAAF0AAE10@Z ; CGate::GetGate

; 1805 : 
; 1806 : 		if ( result >= 0 )

  004a8	85 c0		 test	 eax, eax
  004aa	0f 88 87 00 00
	00		 js	 $LN70@gObjSetCha

; 1807 : 		{
; 1808 : 			if ( lpObj->Class == 4 || lpObj->Class == 3 )

  004b0	0f b7 8b 98 00
	00 00		 movzx	 ecx, WORD PTR [ebx+152]
  004b7	83 f9 04	 cmp	 ecx, 4
  004ba	74 05		 je	 SHORT $LN68@gObjSetCha
  004bc	83 f9 03	 cmp	 ecx, 3
  004bf	75 29		 jne	 SHORT $LN140@gObjSetCha
$LN68@gObjSetCha:

; 1809 : 			{
; 1810 : 				if ( level > 0 )

  004c1	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _level$[ebp]
  004c7	66 85 c0	 test	 ax, ax
  004ca	7e 27		 jle	 SHORT $LN157@gObjSetCha

; 1811 : 				{
; 1812 : 					level = level / 3 * 2;

  004cc	0f bf d0	 movsx	 edx, ax
  004cf	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  004d4	f7 ea		 imul	 edx
  004d6	8b c2		 mov	 eax, edx
  004d8	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  004db	03 c2		 add	 eax, edx
  004dd	03 c0		 add	 eax, eax
  004df	0f b7 c0	 movzx	 eax, ax
  004e2	89 85 cc fe ff
	ff		 mov	 DWORD PTR _level$[ebp], eax
  004e8	eb 06		 jmp	 SHORT $LN67@gObjSetCha
$LN140@gObjSetCha:
  004ea	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _level$[ebp]
$LN67@gObjSetCha:

; 1813 : 				}
; 1814 : 			}
; 1815 : 
; 1816 : 			if ( level != 0 && lpObj->Level < level)

  004f0	66 85 c0	 test	 ax, ax
$LN157@gObjSetCha:
  004f3	74 5c		 je	 SHORT $LN63@gObjSetCha
  004f5	0f b7 93 9c 00
	00 00		 movzx	 edx, WORD PTR [ebx+156]
  004fc	66 3b d0	 cmp	 dx, ax
  004ff	7d 50		 jge	 SHORT $LN63@gObjSetCha

; 1817 : 			{
; 1818 : 				if ( lpObj->Class == 2 ) // Elf
; 1819 : 				{
; 1820 : 					lpObj->MapNumber = MAP_INDEX_NORIA;
; 1821 : 					MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y);

  00501	8d 83 06 01 00
	00		 lea	 eax, DWORD PTR [ebx+262]
  00507	50		 push	 eax
  00508	57		 push	 edi
  00509	83 f9 02	 cmp	 ecx, 2
  0050c	75 15		 jne	 SHORT $LN65@gObjSetCha
  0050e	6a 03		 push	 3
  00510	b9 18 15 0f 00	 mov	 ecx, OFFSET ?MapC@@3PAVMapClass@@A+988440
  00515	c6 83 09 01 00
	00 03		 mov	 BYTE PTR [ebx+265], 3
  0051c	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos

; 1822 : 				}
; 1823 : 				else

  00521	eb 2e		 jmp	 SHORT $LN63@gObjSetCha
$LN65@gObjSetCha:

; 1824 : 				{
; 1825 : 					lpObj->MapNumber = MAP_INDEX_LORENCIA;
; 1826 : 					MapC[lpObj->MapNumber].GetLevelPos(lpObj->Level, lpObj->X, lpObj->Y);

  00523	52		 push	 edx
  00524	b9 00 00 00 00	 mov	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00529	c6 83 09 01 00
	00 00		 mov	 BYTE PTR [ebx+265], 0
  00530	e8 00 00 00 00	 call	 ?GetLevelPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetLevelPos

; 1827 : 				}
; 1828 : 			}
; 1829 : 		}
; 1830 : 		else

  00535	eb 1a		 jmp	 SHORT $LN63@gObjSetCha
$LN70@gObjSetCha:

; 1831 : 		{
; 1832 : 			LogAdd(LOG_BLACK, "error : %d (%s %d)", result, __FILE__, __LINE__);

  00537	68 28 07 00 00	 push	 1832			; 00000728H
  0053c	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00541	50		 push	 eax
  00542	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DHOELAFE@error?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ?$AA@
  00547	6a 00		 push	 0
  00549	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0054e	83 c4 14	 add	 esp, 20			; 00000014H
$LN63@gObjSetCha:

; 1833 : 		}
; 1834 : 	}
; 1835 : 
; 1836 : 	lpMsg->MapX = lpObj->X;

  00551	8a 0f		 mov	 cl, BYTE PTR [edi]
  00553	88 8e b5 07 00
	00		 mov	 BYTE PTR [esi+1973], cl

; 1837 : 	lpMsg->MapY = lpObj->Y;

  00559	8a 93 06 01 00
	00		 mov	 dl, BYTE PTR [ebx+262]
  0055f	88 96 b6 07 00
	00		 mov	 BYTE PTR [esi+1974], dl

; 1838 : 	lpObj->TX = lpMsg->MapX;
; 1839 : 	lpObj->TY = lpMsg->MapY;
; 1840 : 	lpObj->m_OldX = lpObj->X;

  00565	0f b7 17	 movzx	 edx, WORD PTR [edi]
  00568	0f b6 c1	 movzx	 eax, cl
  0056b	66 89 83 20 01
	00 00		 mov	 WORD PTR [ebx+288], ax
  00572	0f b6 8e b6 07
	00 00		 movzx	 ecx, BYTE PTR [esi+1974]

; 1841 : 	lpObj->m_OldY = lpObj->Y;

  00579	0f b7 83 06 01
	00 00		 movzx	 eax, WORD PTR [ebx+262]
  00580	66 89 83 1e 01
	00 00		 mov	 WORD PTR [ebx+286], ax
  00587	66 89 8b 22 01
	00 00		 mov	 WORD PTR [ebx+290], cx
  0058e	66 89 93 1c 01
	00 00		 mov	 WORD PTR [ebx+284], dx

; 1842 : 	lpObj->Experience = lpMsg->Exp;

  00595	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00598	89 8b a8 00 00
	00		 mov	 DWORD PTR [ebx+168], ecx

; 1843 : 	lpObj->Strength = lpMsg->Str ;

  0059e	0f b7 56 30	 movzx	 edx, WORD PTR [esi+48]
  005a2	66 89 93 b4 00
	00 00		 mov	 WORD PTR [ebx+180], dx

; 1844 : 	lpObj->Dexterity = lpMsg->Dex ;

  005a9	0f b7 46 32	 movzx	 eax, WORD PTR [esi+50]
  005ad	66 89 83 b6 00
	00 00		 mov	 WORD PTR [ebx+182], ax

; 1845 : 	lpObj->Vitality = lpMsg->Vit ;

  005b4	0f b7 4e 34	 movzx	 ecx, WORD PTR [esi+52]
  005b8	66 89 8b b8 00
	00 00		 mov	 WORD PTR [ebx+184], cx

; 1846 : 	lpObj->Energy = lpMsg->Energy ;

  005bf	0f b7 56 36	 movzx	 edx, WORD PTR [esi+54]
  005c3	66 89 93 ba 00
	00 00		 mov	 WORD PTR [ebx+186], dx

; 1847 : 	lpObj->Life = lpMsg->Life;
; 1848 : 	lpObj->Life /= 10.0f;

  005ca	0f b7 46 38	 movzx	 eax, WORD PTR [esi+56]
  005ce	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv2265[ebp], eax
  005d4	db 85 d8 fe ff
	ff		 fild	 DWORD PTR tv2265[ebp]
  005da	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  005e0	dc f9		 fdiv	 ST(1), ST(0)
  005e2	d9 c9		 fxch	 ST(1)
  005e4	d9 9b bc 00 00
	00		 fstp	 DWORD PTR [ebx+188]

; 1849 : 	lpObj->MaxLife = lpMsg->MaxLife;
; 1850 : 	lpObj->MaxLife /= 10.0f;

  005ea	0f b7 4e 3a	 movzx	 ecx, WORD PTR [esi+58]
  005ee	89 8d d8 fe ff
	ff		 mov	 DWORD PTR tv2263[ebp], ecx
  005f4	db 85 d8 fe ff
	ff		 fild	 DWORD PTR tv2263[ebp]
  005fa	d8 f1		 fdiv	 ST(0), ST(1)
  005fc	d9 9b c0 00 00
	00		 fstp	 DWORD PTR [ebx+192]

; 1851 : 	lpObj->Mana = lpMsg->Mana;
; 1852 : 	lpObj->Mana /= 10.0f;

  00602	0f b7 56 3c	 movzx	 edx, WORD PTR [esi+60]
  00606	89 95 d8 fe ff
	ff		 mov	 DWORD PTR tv2261[ebp], edx
  0060c	db 85 d8 fe ff
	ff		 fild	 DWORD PTR tv2261[ebp]
  00612	d8 f1		 fdiv	 ST(0), ST(1)
  00614	d9 9b d0 00 00
	00		 fstp	 DWORD PTR [ebx+208]

; 1853 : 	lpObj->MaxMana = lpMsg->MaxMana;
; 1854 : 	lpObj->MaxMana /= 10.0f;

  0061a	0f b7 46 3e	 movzx	 eax, WORD PTR [esi+62]
  0061e	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv2259[ebp], eax
  00624	db 85 d8 fe ff
	ff		 fild	 DWORD PTR tv2259[ebp]
  0062a	de f1		 fdivrp	 ST(1), ST(0)
  0062c	d9 9b d4 00 00
	00		 fstp	 DWORD PTR [ebx+212]

; 1855 : 	lpObj->Money = lpMsg->Money;
; 1856 : 	lpObj->Leadership = lpMsg->Leadership;
; 1857 : 	lpObj->ChatLimitTime = lpMsg->ChatLitmitTime;
; 1858 : 	lpObj->iFruitPoint = lpMsg->iFruitPoint;
; 1859 : 
; 1860 : 	if ( lpObj->Mana < 1.0f )

  00632	d9 e8		 fld1
  00634	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00637	d8 93 d0 00 00
	00		 fcom	 DWORD PTR [ebx+208]
  0063d	89 8b b0 00 00
	00		 mov	 DWORD PTR [ebx+176], ecx
  00643	0f b7 96 fa 07
	00 00		 movzx	 edx, WORD PTR [esi+2042]
  0064a	66 89 93 d8 00
	00 00		 mov	 WORD PTR [ebx+216], dx
  00651	0f b7 86 fc 07
	00 00		 movzx	 eax, WORD PTR [esi+2044]
  00658	66 89 83 dc 00
	00 00		 mov	 WORD PTR [ebx+220], ax
  0065f	8b 8e 00 08 00
	00		 mov	 ecx, DWORD PTR [esi+2048]
  00665	df e0		 fnstsw	 ax
  00667	89 8b a4 00 00
	00		 mov	 DWORD PTR [ebx+164], ecx
  0066d	f6 c4 41	 test	 ah, 65			; 00000041H
  00670	75 06		 jne	 SHORT $LN62@gObjSetCha

; 1861 : 	{
; 1862 : 		lpObj->Mana = 1.0f;

  00672	d9 93 d0 00 00
	00		 fst	 DWORD PTR [ebx+208]
$LN62@gObjSetCha:

; 1863 : 	}
; 1864 : 
; 1865 : 	if ( lpObj->Life < 1.0f )

  00678	d8 93 bc 00 00
	00		 fcom	 DWORD PTR [ebx+188]
  0067e	df e0		 fnstsw	 ax
  00680	f6 c4 41	 test	 ah, 65			; 00000041H
  00683	75 08		 jne	 SHORT $LN155@gObjSetCha

; 1866 : 	{
; 1867 : 		lpObj->Life = 1.0f;

  00685	d9 9b bc 00 00
	00		 fstp	 DWORD PTR [ebx+188]
  0068b	eb 02		 jmp	 SHORT $LN61@gObjSetCha
$LN155@gObjSetCha:
  0068d	dd d8		 fstp	 ST(0)
$LN61@gObjSetCha:

; 1868 : 	}
; 1869 : 
; 1870 : 	lpObj->MaxLife = DCInfo.DefClass[lpObj->Class].Life + (lpObj->Level - 1) * DCInfo.DefClass[lpObj->Class].LevelLife  + ((lpObj->Vitality - DCInfo.DefClass[lpObj->Class].Vitality ) * DCInfo.DefClass[lpObj->Class].VitalityToLife);

  0068f	0f b7 83 98 00
	00 00		 movzx	 eax, WORD PTR [ebx+152]
  00696	0f bf 93 9c 00
	00 00		 movsx	 edx, WORD PTR [ebx+156]
  0069d	69 c0 60 09 00
	00		 imul	 eax, 2400		; 00000960H
  006a3	0f b7 88 0c 00
	00 00		 movzx	 ecx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+12]
  006aa	4a		 dec	 edx
  006ab	89 95 d8 fe ff
	ff		 mov	 DWORD PTR tv2242[ebp], edx
  006b1	0f b7 93 b8 00
	00 00		 movzx	 edx, WORD PTR [ebx+184]
  006b8	db 85 d8 fe ff
	ff		 fild	 DWORD PTR tv2242[ebp]
  006be	2b d1		 sub	 edx, ecx

; 1871 : 	lpObj->MaxMana = DCInfo.DefClass[lpObj->Class].Mana + (lpObj->Level - 1) * DCInfo.DefClass[lpObj->Class].LevelMana  + ((lpObj->Energy - DCInfo.DefClass[lpObj->Class].Energy ) * DCInfo.DefClass[lpObj->Class].EnergyToMana);

  006c0	0f b7 88 0e 00
	00 00		 movzx	 ecx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+14]
  006c7	d9 9d c4 fe ff
	ff		 fstp	 DWORD PTR tv1577[ebp]
  006cd	89 95 d8 fe ff
	ff		 mov	 DWORD PTR tv2239[ebp], edx
  006d3	0f b7 93 ba 00
	00 00		 movzx	 edx, WORD PTR [ebx+186]
  006da	db 85 d8 fe ff
	ff		 fild	 DWORD PTR tv2239[ebp]

; 1872 : 
; 1873 : 	lpObj->VitalityToLife = DCInfo.DefClass[lpObj->Class].VitalityToLife;
; 1874 : 	lpObj->EnergyToMana = DCInfo.DefClass[lpObj->Class].EnergyToMana;
; 1875 : 
; 1876 : 	::gObjSetBP(aIndex);

  006e0	8b bd c8 fe ff
	ff		 mov	 edi, DWORD PTR _aIndex$GSCopy$[ebp]
  006e6	2b d1		 sub	 edx, ecx
  006e8	d8 88 28 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  006ee	89 95 d8 fe ff
	ff		 mov	 DWORD PTR tv2235[ebp], edx
  006f4	d9 80 10 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  006fa	57		 push	 edi
  006fb	d9 85 c4 fe ff
	ff		 fld	 DWORD PTR tv1577[ebp]
  00701	d9 c0		 fld	 ST(0)
  00703	de ca		 fmulp	 ST(2), ST(0)
  00705	d9 80 14 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+20]
  0070b	de c2		 faddp	 ST(2), ST(0)
  0070d	d9 ca		 fxch	 ST(2)
  0070f	de c1		 faddp	 ST(1), ST(0)
  00711	d9 9b c0 00 00
	00		 fstp	 DWORD PTR [ebx+192]
  00717	db 85 d8 fe ff
	ff		 fild	 DWORD PTR tv2235[ebp]
  0071d	d8 88 2c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  00723	d9 80 1c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  00729	de ca		 fmulp	 ST(2), ST(0)
  0072b	d9 80 20 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+32]
  00731	de c2		 faddp	 ST(2), ST(0)
  00733	de c1		 faddp	 ST(1), ST(0)
  00735	d9 9b d4 00 00
	00		 fstp	 DWORD PTR [ebx+212]
  0073b	d9 80 28 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  00741	d9 9b f4 00 00
	00		 fstp	 DWORD PTR [ebx+244]
  00747	d9 80 2c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  0074d	d9 9b f8 00 00
	00		 fstp	 DWORD PTR [ebx+248]
  00753	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 1877 : 	lpObj->BP = lpObj->MaxBP / 2;

  00758	8b 83 ec 00 00
	00		 mov	 eax, DWORD PTR [ebx+236]
  0075e	99		 cdq
  0075f	2b c2		 sub	 eax, edx
  00761	d1 f8		 sar	 eax, 1

; 1878 : 	::gObjCalcMaxLifePower(aIndex);

  00763	57		 push	 edi
  00764	89 83 e8 00 00
	00		 mov	 DWORD PTR [ebx+232], eax
  0076a	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower

; 1879 : 	lpObj->m_PK_Count = lpMsg->PkCount;

  0076f	8a 86 b8 07 00
	00		 mov	 al, BYTE PTR [esi+1976]
  00775	88 83 fc 00 00
	00		 mov	 BYTE PTR [ebx+252], al

; 1880 : 	lpObj->m_PK_Level = lpMsg->PkLevel;

  0077b	8a 8e bc 07 00
	00		 mov	 cl, BYTE PTR [esi+1980]
  00781	88 8b fd 00 00
	00		 mov	 BYTE PTR [ebx+253], cl

; 1881 : 	lpObj->m_PK_Time  = lpMsg->PkTime;

  00787	8b 96 c0 07 00
	00		 mov	 edx, DWORD PTR [esi+1984]
  0078d	83 c4 08	 add	 esp, 8

; 1882 : 
; 1883 : 	if ( ::gApplyHeroSystem != FALSE )

  00790	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gApplyHeroSystem@@3HA, 0 ; gApplyHeroSystem
  00797	89 93 00 01 00
	00		 mov	 DWORD PTR [ebx+256], edx
  0079d	74 0c		 je	 SHORT $LN59@gObjSetCha

; 1884 : 	{
; 1885 : 		if ( lpObj->m_PK_Level <= 3 )

  0079f	80 f9 03	 cmp	 cl, 3
  007a2	7f 07		 jg	 SHORT $LN59@gObjSetCha

; 1886 : 		{
; 1887 : 			lpObj->m_PK_Level = 2;

  007a4	c6 83 fd 00 00
	00 02		 mov	 BYTE PTR [ebx+253], 2
$LN59@gObjSetCha:

; 1888 : 		}
; 1889 : 	}
; 1890 : 
; 1891 : 	if ( lpObj->m_PK_Level == 3 )

  007ab	80 bb fd 00 00
	00 03		 cmp	 BYTE PTR [ebx+253], 3
  007b2	75 11		 jne	 SHORT $LN58@gObjSetCha

; 1892 : 	{
; 1893 : 		lpObj->m_PK_Count = 0;

  007b4	c6 83 fc 00 00
	00 00		 mov	 BYTE PTR [ebx+252], 0

; 1894 : 		lpObj->m_PK_Time = 0;

  007bb	c7 83 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+256], 0
$LN58@gObjSetCha:

; 1895 : 	}
; 1896 : 
; 1897 : 	lpObj->MaxRegenTime = 4000;	// Resurrection of the player if die
; 1898 : 	lpObj->m_MoveSpeed = 1000;

  007c5	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  007ca	66 89 83 1c 03
	00 00		 mov	 WORD PTR [ebx+796], ax

; 1899 : 
; 1900 : 	memcpy(lpObj->m_Quest, lpMsg->dbQuest, sizeof(lpObj->m_Quest));

  007d1	8d 83 c0 0e 00
	00		 lea	 eax, DWORD PTR [ebx+3776]
  007d7	81 c6 c7 07 00
	00		 add	 esi, 1991		; 000007c7H
  007dd	c7 83 0c 02 00
	00 a0 0f 00 00	 mov	 DWORD PTR [ebx+524], 4000 ; 00000fa0H
  007e7	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  007ec	8b f8		 mov	 edi, eax
  007ee	f3 a5		 rep movsd
  007f0	66 a5		 movsw

; 1901 : 
; 1902 : 	if ( lpObj->m_Quest[0] == 0 )

  007f2	80 38 00	 cmp	 BYTE PTR [eax], 0
  007f5	75 10		 jne	 SHORT $LN57@gObjSetCha

; 1903 : 	{
; 1904 : 		memset(lpObj->m_Quest, (BYTE)-1, sizeof(lpObj->m_Quest));

  007f7	6a 32		 push	 50			; 00000032H
  007f9	68 ff 00 00 00	 push	 255			; 000000ffH
  007fe	50		 push	 eax
  007ff	e8 00 00 00 00	 call	 _memset
  00804	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@gObjSetCha:

; 1905 : 	}
; 1906 : 
; 1907 : 	if ( ::g_QuestInfo.GetQuestState(lpObj, 2) == 2 )	// Ring of Honor

  00807	6a 02		 push	 2
  00809	53		 push	 ebx
  0080a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0080f	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState

; 1908 : 	{
; 1909 : 		if ( lpObj->Level < QUEST_MINLEVEL_PLUSSTAT )

  00814	be 01 00 00 00	 mov	 esi, 1
  00819	83 f8 02	 cmp	 eax, 2
  0081c	75 37		 jne	 SHORT $LN54@gObjSetCha
  0081e	66 39 b3 9c 00
	00 00		 cmp	 WORD PTR [ebx+156], si
  00825	7d 27		 jge	 SHORT $LN55@gObjSetCha

; 1910 : 		{
; 1911 : 			::g_QuestInfo.ReSetQuestState(lpObj, 2);

  00827	50		 push	 eax
  00828	53		 push	 ebx
  00829	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0082e	e8 00 00 00 00	 call	 ?ReSetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::ReSetQuestState

; 1912 : 			LogAdd(LOG_BLACK, "[%s][%s] Find Invalid QuestInfo (%d)",
; 1913 : 				lpObj->AccountID, lpObj->Name, 2);

  00833	6a 02		 push	 2
  00835	8d 43 6f	 lea	 eax, DWORD PTR [ebx+111]
  00838	50		 push	 eax
  00839	8d 4b 64	 lea	 ecx, DWORD PTR [ebx+100]
  0083c	51		 push	 ecx
  0083d	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PDDCMPCL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Find?5Invalid?5QuestInfo?5@
  00842	6a 00		 push	 0
  00844	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00849	83 c4 14	 add	 esp, 20			; 00000014H

; 1914 : 		}
; 1915 : 		else

  0084c	eb 07		 jmp	 SHORT $LN54@gObjSetCha
$LN55@gObjSetCha:

; 1916 : 		{
; 1917 : 			lpObj->PlusStatQuestClear = true;

  0084e	c6 83 88 00 00
	00 01		 mov	 BYTE PTR [ebx+136], 1
$LN54@gObjSetCha:

; 1918 : 		}
; 1919 : 	}
; 1920 : 
; 1921 : 	if ( ::g_QuestInfo.GetQuestState(lpObj, 3) == 2 )	// Dark Stone

  00855	6a 03		 push	 3
  00857	53		 push	 ebx
  00858	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0085d	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  00862	83 f8 02	 cmp	 eax, 2
  00865	75 38		 jne	 SHORT $LN146@gObjSetCha

; 1922 : 	{
; 1923 : 		if ( lpObj->Level < QUEST_MINLEVEL_PLUSSTAT )

  00867	66 39 b3 9c 00
	00 00		 cmp	 WORD PTR [ebx+156], si
  0086e	7d 28		 jge	 SHORT $LN52@gObjSetCha

; 1924 : 		{
; 1925 : 			::g_QuestInfo.ReSetQuestState(lpObj, 3);

  00870	6a 03		 push	 3
  00872	53		 push	 ebx
  00873	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00878	e8 00 00 00 00	 call	 ?ReSetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::ReSetQuestState

; 1926 : 			LogAdd(LOG_BLACK, "[%s][%s] Find Invalid QuestInfo (%d)",
; 1927 : 				lpObj->AccountID, lpObj->Name, 3);

  0087d	6a 03		 push	 3
  0087f	8d 43 6f	 lea	 eax, DWORD PTR [ebx+111]
  00882	50		 push	 eax
  00883	8d 53 64	 lea	 edx, DWORD PTR [ebx+100]
  00886	52		 push	 edx
  00887	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PDDCMPCL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Find?5Invalid?5QuestInfo?5@
  0088c	6a 00		 push	 0
  0088e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00893	83 c4 14	 add	 esp, 20			; 00000014H

; 1928 : 		}
; 1929 : 		else

  00896	eb 07		 jmp	 SHORT $LN146@gObjSetCha
$LN52@gObjSetCha:

; 1930 : 		{
; 1931 : 			lpObj->ComboSkillquestClear = true;

  00898	c6 83 89 00 00
	00 01		 mov	 BYTE PTR [ebx+137], 1
$LN146@gObjSetCha:

; 1932 : 		}
; 1933 : 	}
; 1934 : 
; 1935 : 	::gObjSetInventory1Pointer(lpObj);

  0089f	53		 push	 ebx
  008a0	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer

; 1936 : 	lpObj->GuildNumber = 0;
; 1937 : 	lpObj->lpGuild = NULL;
; 1938 : 
; 1939 : 	if ( lpObj->Class == 0 || lpObj->Class == 2 || lpObj->Class == 1 || lpObj->Class == 4 || lpObj->Class == 3 )

  008a5	0f b7 83 98 00
	00 00		 movzx	 eax, WORD PTR [ebx+152]
  008ac	33 c9		 xor	 ecx, ecx
  008ae	83 c4 04	 add	 esp, 4
  008b1	89 8b b0 02 00
	00		 mov	 DWORD PTR [ebx+688], ecx
  008b7	89 8b b4 02 00
	00		 mov	 DWORD PTR [ebx+692], ecx
  008bd	66 3b c1	 cmp	 ax, cx
  008c0	74 18		 je	 SHORT $LN142@gObjSetCha
  008c2	83 f8 02	 cmp	 eax, 2
  008c5	74 13		 je	 SHORT $LN142@gObjSetCha
  008c7	66 3b c6	 cmp	 ax, si
  008ca	74 0e		 je	 SHORT $LN142@gObjSetCha
  008cc	83 f8 04	 cmp	 eax, 4
  008cf	74 09		 je	 SHORT $LN142@gObjSetCha
  008d1	83 f8 03	 cmp	 eax, 3
  008d4	0f 85 52 02 00
	00		 jne	 $LN143@gObjSetCha
$LN142@gObjSetCha:

; 1940 : 	{
; 1941 : 		BOOL bEnergyBall = TRUE;
; 1942 : 		BOOL bForceSkill = TRUE;
; 1943 : 		BOOL IsGetInitinityArrowSkill = FALSE;// DarkLord
; 1944 : 
; 1945 : 		gObjMagicAddEnergyCheckOnOff(0);

  008da	51		 push	 ecx
  008db	89 b5 c0 fe ff
	ff		 mov	 DWORD PTR _bEnergyBall$162386[ebp], esi
  008e1	89 b5 c4 fe ff
	ff		 mov	 DWORD PTR _bForceSkill$162387[ebp], esi
  008e7	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _IsGetInitinityArrowSkill$162388[ebp], ecx
  008ed	e8 00 00 00 00	 call	 ?gObjMagicAddEnergyCheckOnOff@@YAXH@Z ; gObjMagicAddEnergyCheckOnOff
  008f2	8b bd d4 fe ff
	ff		 mov	 edi, DWORD PTR _lpdata$GSCopy$[ebp]
  008f8	83 c4 04	 add	 esp, 4
  008fb	81 c7 01 07 00
	00		 add	 edi, 1793		; 00000701H
  00901	c7 85 bc fe ff
	ff 3c 00 00 00	 mov	 DWORD PTR tv830[ebp], 60 ; 0000003cH
  0090b	eb 03 8d 49 00	 npad	 5
$LL48@gObjSetCha:

; 1948 : 		{
; 1949 : 			itype = lpMsg->dbMagicList[n*3];

  00910	0f b6 77 ff	 movzx	 esi, BYTE PTR [edi-1]

; 1950 : 
; 1951 : 			if ( itype != (BYTE)-1 )

  00914	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  0091a	0f 84 99 00 00
	00		 je	 $LN47@gObjSetCha

; 1952 : 			{
; 1953 : 				if ( itype == 17 )

  00920	83 fe 11	 cmp	 esi, 17			; 00000011H
  00923	75 0c		 jne	 SHORT $LN44@gObjSetCha

; 1954 : 				{
; 1955 : 					bEnergyBall = FALSE;

  00925	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _bEnergyBall$162386[ebp], 0

; 1956 : 				}
; 1957 : 
; 1958 : 				if ( itype == 60 )

  0092f	eb 75		 jmp	 SHORT $LN139@gObjSetCha
$LN44@gObjSetCha:
  00931	83 fe 3c	 cmp	 esi, 60			; 0000003cH
  00934	75 0c		 jne	 SHORT $LN43@gObjSetCha

; 1959 : 				{
; 1960 : 					bForceSkill = FALSE;

  00936	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _bForceSkill$162387[ebp], 0

; 1961 : 				}
; 1962 : 
; 1963 : 				if ( itype == 77 )

  00940	eb 64		 jmp	 SHORT $LN139@gObjSetCha
$LN43@gObjSetCha:
  00942	83 fe 4d	 cmp	 esi, 77			; 0000004dH
  00945	75 1e		 jne	 SHORT $LN42@gObjSetCha

; 1964 : 				{
; 1965 : 					IsGetInitinityArrowSkill = 1;
; 1966 : 					gObjMagicAdd(lpObj,itype,lpMsg->dbMagicList[n*3+DBM_LEVEL]&0xF);

  00947	8a 07		 mov	 al, BYTE PTR [edi]
  00949	24 0f		 and	 al, 15			; 0000000fH
  0094b	0f b6 c8	 movzx	 ecx, al
  0094e	51		 push	 ecx
  0094f	56		 push	 esi
  00950	53		 push	 ebx
  00951	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _IsGetInitinityArrowSkill$162388[ebp], 1
  0095b	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  00960	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1967 : 				}
; 1968 : 
; 1969 : 				// Main Engine of Add Skills
; 1970 : 				if ( itype != 18 && itype != 19 && itype != 20 && itype != 21 && itype != 22 && itype != 23 && itype != 24 && itype != 25 && itype != 49 && itype != 56 && itype != 62 && itype != 76 && itype != 54 )

  00963	eb 41		 jmp	 SHORT $LN139@gObjSetCha
$LN42@gObjSetCha:
  00965	83 fe 12	 cmp	 esi, 18			; 00000012H
  00968	74 4f		 je	 SHORT $LN47@gObjSetCha
  0096a	83 fe 13	 cmp	 esi, 19			; 00000013H
  0096d	74 4a		 je	 SHORT $LN47@gObjSetCha
  0096f	83 fe 14	 cmp	 esi, 20			; 00000014H
  00972	74 45		 je	 SHORT $LN47@gObjSetCha
  00974	83 fe 15	 cmp	 esi, 21			; 00000015H
  00977	74 40		 je	 SHORT $LN47@gObjSetCha
  00979	83 fe 16	 cmp	 esi, 22			; 00000016H
  0097c	74 3b		 je	 SHORT $LN47@gObjSetCha
  0097e	83 fe 17	 cmp	 esi, 23			; 00000017H
  00981	74 36		 je	 SHORT $LN47@gObjSetCha
  00983	83 fe 18	 cmp	 esi, 24			; 00000018H
  00986	74 31		 je	 SHORT $LN47@gObjSetCha
  00988	83 fe 19	 cmp	 esi, 25			; 00000019H
  0098b	74 2c		 je	 SHORT $LN47@gObjSetCha
  0098d	83 fe 31	 cmp	 esi, 49			; 00000031H
  00990	74 27		 je	 SHORT $LN47@gObjSetCha
  00992	83 fe 38	 cmp	 esi, 56			; 00000038H
  00995	74 22		 je	 SHORT $LN47@gObjSetCha
  00997	83 fe 3e	 cmp	 esi, 62			; 0000003eH
  0099a	74 1d		 je	 SHORT $LN47@gObjSetCha
  0099c	83 fe 4c	 cmp	 esi, 76			; 0000004cH
  0099f	74 18		 je	 SHORT $LN47@gObjSetCha
  009a1	83 fe 36	 cmp	 esi, 54			; 00000036H
  009a4	74 13		 je	 SHORT $LN47@gObjSetCha
$LN139@gObjSetCha:

; 1971 : 				{
; 1972 : 					gObjMagicAdd(lpObj, itype, lpMsg->dbMagicList[n*3+DBM_LEVEL] & 0x0F);

  009a6	8a 17		 mov	 dl, BYTE PTR [edi]
  009a8	80 e2 0f	 and	 dl, 15			; 0000000fH
  009ab	0f b6 c2	 movzx	 eax, dl
  009ae	50		 push	 eax
  009af	56		 push	 esi
  009b0	53		 push	 ebx
  009b1	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  009b6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN47@gObjSetCha:

; 1946 : 
; 1947 : 		for (int n=0;n<MAX_MAGIC;n++)

  009b9	b8 01 00 00 00	 mov	 eax, 1
  009be	83 c7 03	 add	 edi, 3
  009c1	29 85 bc fe ff
	ff		 sub	 DWORD PTR tv830[ebp], eax
  009c7	0f 85 43 ff ff
	ff		 jne	 $LL48@gObjSetCha

; 1973 : 				}
; 1974 : 			}
; 1975 : 		}
; 1976 : 
; 1977 : 		if ( lpObj->Class == 0 )	// Wizard

  009cd	66 83 bb 98 00
	00 00 00	 cmp	 WORD PTR [ebx+152], 0
  009d5	75 15		 jne	 SHORT $LN39@gObjSetCha

; 1978 : 		{
; 1979 : 			if ( bEnergyBall == TRUE )

  009d7	39 85 c0 fe ff
	ff		 cmp	 DWORD PTR _bEnergyBall$162386[ebp], eax
  009dd	75 0d		 jne	 SHORT $LN39@gObjSetCha

; 1980 : 			{
; 1981 : 				gObjMagicAdd(lpObj, 17, 0);

  009df	6a 00		 push	 0
  009e1	6a 11		 push	 17			; 00000011H
  009e3	53		 push	 ebx
  009e4	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  009e9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@gObjSetCha:

; 1982 : 				bEnergyBall = FALSE;
; 1983 : 			}
; 1984 : 		}
; 1985 : 
; 1986 : 		if ( lpObj->Class == 4 )	// Dark Lord

  009ec	66 83 bb 98 00
	00 00 04	 cmp	 WORD PTR [ebx+152], 4
  009f4	75 16		 jne	 SHORT $LN37@gObjSetCha

; 1987 : 		{
; 1988 : 			if ( bForceSkill == TRUE )

  009f6	83 bd c4 fe ff
	ff 01		 cmp	 DWORD PTR _bForceSkill$162387[ebp], 1
  009fd	75 0d		 jne	 SHORT $LN37@gObjSetCha

; 1989 : 			{
; 1990 : 				gObjMagicAdd(lpObj, 60, 0);

  009ff	6a 00		 push	 0
  00a01	6a 3c		 push	 60			; 0000003cH
  00a03	53		 push	 ebx
  00a04	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  00a09	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN37@gObjSetCha:

; 1991 : 				bForceSkill = FALSE;
; 1992 : 			}
; 1993 : 		}
; 1994 : 
; 1995 : 		if ( IsGetInitinityArrowSkill == 0 && lpObj->Class == 2)

  00a0c	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _IsGetInitinityArrowSkill$162388[ebp], 0
  00a13	75 5a		 jne	 SHORT $LN33@gObjSetCha
  00a15	66 83 bb 98 00
	00 00 02	 cmp	 WORD PTR [ebx+152], 2
  00a1d	75 50		 jne	 SHORT $LN33@gObjSetCha

; 1996 : 		{
; 1997 : 			if(lpObj->Level >= g_SkillAdditionInfo.GetInfinityArrowUseLevel())

  00a1f	0f bf 8b 9c 00
	00 00		 movsx	 ecx, WORD PTR [ebx+156]
  00a26	3b 0d 08 00 00
	00		 cmp	 ecx, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+8
  00a2c	7c 41		 jl	 SHORT $LN33@gObjSetCha

; 1998 : 			{
; 1999 : 				if(lpObj->ChangeUP == 1)

  00a2e	80 bb 9b 00 00
	00 01		 cmp	 BYTE PTR [ebx+155], 1
  00a35	75 38		 jne	 SHORT $LN33@gObjSetCha

; 2000 : 				{
; 2001 : 					int iAddSkillPosition = gObjMagicAdd(lpObj,77,0);

  00a37	6a 00		 push	 0
  00a39	6a 4d		 push	 77			; 0000004dH
  00a3b	53		 push	 ebx
  00a3c	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  00a41	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2002 : 
; 2003 : 					if(iAddSkillPosition > 0)

  00a44	85 c0		 test	 eax, eax
  00a46	7e 27		 jle	 SHORT $LN33@gObjSetCha

; 2004 : 					{
; 2005 : 						LogAdd(LOG_BLACK, "[%s][%s] Add Infinity Arrow Skill (Character Level : %d)(ChangeUp: %d)",
; 2006 : 							lpObj->AccountID,lpObj->Name,lpObj->Level,lpObj->ChangeUP);

  00a48	0f b6 93 9b 00
	00 00		 movzx	 edx, BYTE PTR [ebx+155]
  00a4f	0f bf 83 9c 00
	00 00		 movsx	 eax, WORD PTR [ebx+156]
  00a56	52		 push	 edx
  00a57	50		 push	 eax
  00a58	8d 43 6f	 lea	 eax, DWORD PTR [ebx+111]
  00a5b	50		 push	 eax
  00a5c	8d 4b 64	 lea	 ecx, DWORD PTR [ebx+100]
  00a5f	51		 push	 ecx
  00a60	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@BDBNPHEJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Add?5Infinity?5Arrow?5Skil@
  00a65	6a 00		 push	 0
  00a67	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00a6c	83 c4 18	 add	 esp, 24			; 00000018H
$LN33@gObjSetCha:

; 2007 : 					}
; 2008 : 				}
; 2009 : 			}
; 2010 : 		}
; 2011 : 
; 2012 : 		if ( lpObj->Class == 0 )

  00a6f	0f b7 83 98 00
	00 00		 movzx	 eax, WORD PTR [ebx+152]
  00a76	66 85 c0	 test	 ax, ax
  00a79	75 0f		 jne	 SHORT $LN32@gObjSetCha

; 2013 : 		{
; 2014 : 			gObjMagicAdd(lpObj, 45, 0);

  00a7b	6a 00		 push	 0
  00a7d	6a 2d		 push	 45			; 0000002dH
  00a7f	53		 push	 ebx
  00a80	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  00a85	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a88	eb 59		 jmp	 SHORT $LN24@gObjSetCha
$LN32@gObjSetCha:

; 2015 : 		}
; 2016 : 		else if ( lpObj->Class == 1 )

  00a8a	83 f8 01	 cmp	 eax, 1
  00a8d	75 0f		 jne	 SHORT $LN30@gObjSetCha

; 2017 : 		{
; 2018 : 			gObjMagicAdd(lpObj, 44, 0);

  00a8f	6a 00		 push	 0
  00a91	6a 2c		 push	 44			; 0000002cH
  00a93	53		 push	 ebx
  00a94	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  00a99	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a9c	eb 45		 jmp	 SHORT $LN24@gObjSetCha
$LN30@gObjSetCha:

; 2019 : 		}
; 2020 : 		else if ( lpObj->Class == 2 )

  00a9e	83 f8 02	 cmp	 eax, 2
  00aa1	75 0f		 jne	 SHORT $LN28@gObjSetCha

; 2021 : 		{
; 2022 : 			gObjMagicAdd(lpObj, 46, 0);

  00aa3	6a 00		 push	 0
  00aa5	6a 2e		 push	 46			; 0000002eH
  00aa7	53		 push	 ebx
  00aa8	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  00aad	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ab0	eb 31		 jmp	 SHORT $LN24@gObjSetCha
$LN28@gObjSetCha:

; 2023 : 		}
; 2024 : 		else if ( lpObj->Class == 3 )	// Magic Gladiator

  00ab2	83 f8 03	 cmp	 eax, 3
  00ab5	75 10		 jne	 SHORT $LN26@gObjSetCha

; 2025 : 		{
; 2026 : 			gObjMagicAdd(lpObj, 57, 0);

  00ab7	6a 00		 push	 0
  00ab9	6a 39		 push	 57			; 00000039H
  00abb	53		 push	 ebx
  00abc	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd

; 2027 : 			gObjMagicAdd(lpObj, 73, 0);

  00ac1	6a 00		 push	 0
  00ac3	6a 49		 push	 73			; 00000049H
  00ac5	eb 13		 jmp	 SHORT $LN158@gObjSetCha
$LN26@gObjSetCha:

; 2028 : 		}
; 2029 : 		else if ( lpObj->Class == 4 )	// Dark Lord

  00ac7	83 f8 04	 cmp	 eax, 4
  00aca	75 17		 jne	 SHORT $LN24@gObjSetCha

; 2030 : 		{
; 2031 : 			gObjMagicAdd(lpObj, 74, 0);	// Fire Blast

  00acc	6a 00		 push	 0
  00ace	6a 4a		 push	 74			; 0000004aH
  00ad0	53		 push	 ebx
  00ad1	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd

; 2032 : 			gObjMagicAdd(lpObj, 75, 0);	// Sacrifice - BUG Apply Fix in Skill.vtm coz is not created

  00ad6	6a 00		 push	 0
  00ad8	6a 4b		 push	 75			; 0000004bH
$LN158@gObjSetCha:
  00ada	53		 push	 ebx
  00adb	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  00ae0	83 c4 18	 add	 esp, 24			; 00000018H
$LN24@gObjSetCha:

; 2033 : 		}
; 2034 : 
; 2035 : 		gObjMagicAdd(lpObj,67,0);

  00ae3	6a 00		 push	 0
  00ae5	6a 43		 push	 67			; 00000043H
  00ae7	53		 push	 ebx
  00ae8	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd

; 2036 : 		gObjMagicAdd(lpObj,68,0);

  00aed	6a 00		 push	 0
  00aef	6a 44		 push	 68			; 00000044H
  00af1	53		 push	 ebx
  00af2	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd

; 2037 : 		gObjMagicAdd(lpObj,69,0);

  00af7	6a 00		 push	 0
  00af9	6a 45		 push	 69			; 00000045H
  00afb	53		 push	 ebx
  00afc	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd

; 2038 : 		gObjMagicAdd(lpObj,70,0);

  00b01	6a 00		 push	 0
  00b03	6a 46		 push	 70			; 00000046H
  00b05	53		 push	 ebx
  00b06	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd

; 2039 : 		gObjMagicAdd(lpObj,71,0);

  00b0b	6a 00		 push	 0
  00b0d	6a 47		 push	 71			; 00000047H
  00b0f	53		 push	 ebx
  00b10	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd

; 2040 : 		gObjMagicAdd(lpObj,72,0);

  00b15	6a 00		 push	 0
  00b17	6a 48		 push	 72			; 00000048H
  00b19	53		 push	 ebx
  00b1a	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  00b1f	83 c4 48	 add	 esp, 72			; 00000048H

; 2041 : 
; 2042 : 
; 2043 : 		::gObjMagicAddEnergyCheckOnOff(TRUE);

  00b22	6a 01		 push	 1
  00b24	e8 00 00 00 00	 call	 ?gObjMagicAddEnergyCheckOnOff@@YAXH@Z ; gObjMagicAddEnergyCheckOnOff
  00b29	83 c4 04	 add	 esp, 4
$LN143@gObjSetCha:
  00b2c	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpdata$GSCopy$[ebp]

; 2044 : 	}
; 2045 : 
; 2046 : 	bool bAllItemExist = true;
; 2047 : 
; 2048 : 	if ( lpMsg->DbVersion == 0 ) 

  00b32	8a 81 c5 07 00
	00		 mov	 al, BYTE PTR [ecx+1989]
  00b38	c6 85 df fe ff
	ff 01		 mov	 BYTE PTR _bAllItemExist$[ebp], 1
  00b3f	84 c0		 test	 al, al
  00b41	75 5b		 jne	 SHORT $LN23@gObjSetCha

; 2049 : 	{
; 2050 : 		::DbItemSetInByte(lpObj, lpMsg, 7, &bAllItemExist);

  00b43	8d 95 df fe ff
	ff		 lea	 edx, DWORD PTR _bAllItemExist$[ebp]
  00b49	52		 push	 edx
  00b4a	6a 07		 push	 7
  00b4c	8b c1		 mov	 eax, ecx
  00b4e	50		 push	 eax
  00b4f	53		 push	 ebx
  00b50	e8 00 00 00 00	 call	 ?DbItemSetInByte@@YAXPAUOBJECTSTRUCT@@PAUSDHP_DBCHAR_INFORESULT@@HPA_N@Z ; DbItemSetInByte
  00b55	83 c4 10	 add	 esp, 16			; 00000010H
  00b58	be e0 31 00 00	 mov	 esi, 12768		; 000031e0H
  00b5d	8d 49 00	 npad	 3
$LL22@gObjSetCha:

; 2051 : 
; 2052 : 		for ( int i=MAIN_INVENTORY_SIZE;i<INVENTORY_SIZE;i++)
; 2053 : 		{
; 2054 : 			lpObj->Inventory1[i].Clear();

  00b60	8b 8b 9c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3228]
  00b66	03 ce		 add	 ecx, esi
  00b68	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  00b6d	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00b73	81 fe e0 46 00
	00		 cmp	 esi, 18144		; 000046e0H
  00b79	7c e5		 jl	 SHORT $LL22@gObjSetCha

; 2055 : 		}
; 2056 : 
; 2057 : 		memset(lpObj->InventoryMap1+64, (BYTE)-1, PSHOP_MAP_SIZE);	

  00b7b	8b 83 a0 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3232]
  00b81	83 c9 ff	 or	 ecx, -1
  00b84	89 48 40	 mov	 DWORD PTR [eax+64], ecx
  00b87	89 48 44	 mov	 DWORD PTR [eax+68], ecx
  00b8a	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  00b8d	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
  00b90	89 48 50	 mov	 DWORD PTR [eax+80], ecx
  00b93	89 48 54	 mov	 DWORD PTR [eax+84], ecx
  00b96	89 48 58	 mov	 DWORD PTR [eax+88], ecx
  00b99	89 48 5c	 mov	 DWORD PTR [eax+92], ecx
  00b9c	eb 22		 jmp	 SHORT $LN17@gObjSetCha
$LN23@gObjSetCha:

; 2058 : 	}
; 2059 : 	else if(lpMsg->DbVersion < 3)

  00b9e	3c 03		 cmp	 al, 3
  00ba0	73 0b		 jae	 SHORT $LN18@gObjSetCha

; 2060 : 	{
; 2061 : 		::DbItemSetInByte(lpObj, lpMsg, 10, &bAllItemExist);

  00ba2	8d 95 df fe ff
	ff		 lea	 edx, DWORD PTR _bAllItemExist$[ebp]
  00ba8	52		 push	 edx
  00ba9	6a 0a		 push	 10			; 0000000aH

; 2062 : 	}
; 2063 : 	else

  00bab	eb 09		 jmp	 SHORT $LN159@gObjSetCha
$LN18@gObjSetCha:

; 2064 : 	{
; 2065 : 		::DbItemSetInByte(lpObj, lpMsg, 16, &bAllItemExist);

  00bad	8d 85 df fe ff
	ff		 lea	 eax, DWORD PTR _bAllItemExist$[ebp]
  00bb3	50		 push	 eax
  00bb4	6a 10		 push	 16			; 00000010H
$LN159@gObjSetCha:
  00bb6	51		 push	 ecx
  00bb7	53		 push	 ebx
  00bb8	e8 00 00 00 00	 call	 ?DbItemSetInByte@@YAXPAUOBJECTSTRUCT@@PAUSDHP_DBCHAR_INFORESULT@@HPA_N@Z ; DbItemSetInByte
  00bbd	83 c4 10	 add	 esp, 16			; 00000010H
$LN17@gObjSetCha:

; 2066 : 	}
; 2067 : 
; 2068 : 	lpObj->Live = TRUE;
; 2069 : 	lpObj->Type = OBJ_USER;
; 2070 : 	lpObj->TargetNumber = -1;
; 2071 : 	lpObj->Connected = PLAYER_PLAYING;
; 2072 : 	::gObjMakePreviewCharSet(aIndex);

  00bc0	8b bd c8 fe ff
	ff		 mov	 edi, DWORD PTR _aIndex$GSCopy$[ebp]
  00bc6	b9 01 00 00 00	 mov	 ecx, 1
  00bcb	83 ca ff	 or	 edx, -1
  00bce	57		 push	 edi
  00bcf	c6 43 62 01	 mov	 BYTE PTR [ebx+98], 1
  00bd3	66 89 4b 60	 mov	 WORD PTR [ebx+96], cx
  00bd7	66 89 93 d4 02
	00 00		 mov	 WORD PTR [ebx+724], dx
  00bde	c6 43 04 03	 mov	 BYTE PTR [ebx+4], 3
  00be2	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 2073 : 	CreateFrustrum(lpObj->X, lpObj->Y, aIndex);

  00be7	0f bf 83 06 01
	00 00		 movsx	 eax, WORD PTR [ebx+262]
  00bee	0f bf 8b 04 01
	00 00		 movsx	 ecx, WORD PTR [ebx+260]
  00bf5	57		 push	 edi
  00bf6	50		 push	 eax
  00bf7	51		 push	 ecx
  00bf8	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum

; 2074 : 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->X, lpObj->Y);

  00bfd	0f b6 8b 09 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+265]
  00c04	0f bf 93 06 01
	00 00		 movsx	 edx, WORD PTR [ebx+262]
  00c0b	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00c11	0f bf 83 04 01
	00 00		 movsx	 eax, WORD PTR [ebx+260]
  00c18	83 c4 10	 add	 esp, 16			; 00000010H
  00c1b	52		 push	 edx
  00c1c	50		 push	 eax
  00c1d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00c23	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 2075 : 	lpObj->m_OldX = lpObj->X;

  00c28	66 8b 8b 04 01
	00 00		 mov	 cx, WORD PTR [ebx+260]

; 2076 : 	lpObj->m_OldY = lpObj->Y;

  00c2f	66 8b 93 06 01
	00 00		 mov	 dx, WORD PTR [ebx+262]

; 2077 : 	lpMsg->NextExp = lpObj->NextExp;

  00c36	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [ebx+172]
  00c3c	8b b5 d4 fe ff
	ff		 mov	 esi, DWORD PTR _lpdata$GSCopy$[ebp]
  00c42	66 89 8b 1c 01
	00 00		 mov	 WORD PTR [ebx+284], cx
  00c49	66 89 93 1e 01
	00 00		 mov	 WORD PTR [ebx+286], dx
  00c50	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 2078 : 
; 2079 : 	if ( lpObj->Life == 0.0f )

  00c53	d9 83 bc 00 00
	00		 fld	 DWORD PTR [ebx+188]
  00c59	d9 ee		 fldz
  00c5b	da e9		 fucompp
  00c5d	df e0		 fnstsw	 ax
  00c5f	f6 c4 44	 test	 ah, 68			; 00000044H
  00c62	7a 23		 jp	 SHORT $LN16@gObjSetCha

; 2080 : 	{
; 2081 : 		lpObj->Live = TRUE;

  00c64	c6 43 62 01	 mov	 BYTE PTR [ebx+98], 1

; 2082 : 		lpObj->m_State = 4;

  00c68	c7 83 bc 01 00
	00 04 00 00 00	 mov	 DWORD PTR [ebx+444], 4

; 2083 : 		lpObj->DieRegen = TRUE;

  00c72	c6 83 02 02 00
	00 01		 mov	 BYTE PTR [ebx+514], 1

; 2084 : 		lpObj->RegenTime = GetTickCount();

  00c79	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00c7f	89 83 08 02 00
	00		 mov	 DWORD PTR [ebx+520], eax

; 2085 : 	}
; 2086 : 	else

  00c85	eb 0a		 jmp	 SHORT $LN15@gObjSetCha
$LN16@gObjSetCha:

; 2087 : 	{
; 2088 : 		lpObj->m_State = 1;

  00c87	c7 83 bc 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ebx+444], 1
$LN15@gObjSetCha:

; 2089 : 	}
; 2090 : 
; 2091 : 	if ( (lpMsg->CtlCode & 8) == 8 )

  00c91	f6 86 c4 07 00
	00 08		 test	 BYTE PTR [esi+1988], 8
  00c98	74 42		 je	 SHORT $LN14@gObjSetCha

; 2092 : 	{
; 2093 : 		lpObj->Authority = 2;
; 2094 : 		LogAdd(LOG_RED,  lMsg.Get(MSGGET(1, 245)), lpObj->AccountID, lpObj->Name);

  00c9a	8d 73 6f	 lea	 esi, DWORD PTR [ebx+111]
  00c9d	56		 push	 esi
  00c9e	8d 4b 64	 lea	 ecx, DWORD PTR [ebx+100]
  00ca1	51		 push	 ecx
  00ca2	68 f5 01 00 00	 push	 501			; 000001f5H
  00ca7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00cac	c7 83 a4 01 00
	00 02 00 00 00	 mov	 DWORD PTR [ebx+420], 2
  00cb6	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00cbb	50		 push	 eax
  00cbc	6a 01		 push	 1
  00cbe	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2095 : 		cManager.ManagerAdd(lpObj->Name, lpObj->m_Index);

  00cc3	8b 13		 mov	 edx, DWORD PTR [ebx]
  00cc5	83 c4 10	 add	 esp, 16			; 00000010H
  00cc8	52		 push	 edx
  00cc9	56		 push	 esi
  00cca	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  00ccf	e8 00 00 00 00	 call	 ?ManagerAdd@CGMMng@@QAEHPADH@Z ; CGMMng::ManagerAdd

; 2096 : 	}
; 2097 : 	else

  00cd4	8b b5 d4 fe ff
	ff		 mov	 esi, DWORD PTR _lpdata$GSCopy$[ebp]
  00cda	eb 0a		 jmp	 SHORT $LN13@gObjSetCha
$LN14@gObjSetCha:

; 2098 : 	{
; 2099 : 		lpObj->Authority = 1;

  00cdc	c7 83 a4 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ebx+420], 1
$LN13@gObjSetCha:

; 2100 : 	}
; 2101 : 
; 2102 : 	if ( (lpMsg->CtlCode & 0x20 ) == 0x20 )

  00ce6	f6 86 c4 07 00
	00 20		 test	 BYTE PTR [esi+1988], 32	; 00000020H
  00ced	74 21		 je	 SHORT $LN12@gObjSetCha

; 2103 : 	{
; 2104 : 		lpObj->Authority = 0x20;
; 2105 : 		LogAdd(LOG_RED,  "(%s)(%s) Set Event GM", lpObj->AccountID, lpObj->Name);

  00cef	8d 43 6f	 lea	 eax, DWORD PTR [ebx+111]
  00cf2	50		 push	 eax
  00cf3	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  00cf6	50		 push	 eax
  00cf7	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DNBFMJJP@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Set?5Event?5GM?$AA@
  00cfc	6a 01		 push	 1
  00cfe	c7 83 a4 01 00
	00 20 00 00 00	 mov	 DWORD PTR [ebx+420], 32	; 00000020H
  00d08	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00d0d	83 c4 10	 add	 esp, 16			; 00000010H
$LN12@gObjSetCha:

; 2106 : 	}
; 2107 : 
; 2108 : 	lpObj->Penalty = 0;
; 2109 : 
; 2110 : 	if ( lpObj->m_cAccountItemBlock != 0 )

  00d10	80 bb b0 01 00
	00 00		 cmp	 BYTE PTR [ebx+432], 0
  00d17	c7 83 ac 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+428], 0
  00d21	74 0a		 je	 SHORT $LN11@gObjSetCha

; 2111 : 	{
; 2112 : 		lpObj->Penalty |= 8;

  00d23	c7 83 ac 01 00
	00 08 00 00 00	 mov	 DWORD PTR [ebx+428], 8
$LN11@gObjSetCha:

; 2113 : 	}
; 2114 : 
; 2115 : 	if ( (lpMsg->CtlCode & 2) == 2 )

  00d2d	f6 86 c4 07 00
	00 02		 test	 BYTE PTR [esi+1988], 2
  00d34	74 1e		 je	 SHORT $LN144@gObjSetCha

; 2116 : 	{
; 2117 : 		lpObj->Penalty |= 4;

  00d36	83 8b ac 01 00
	00 04		 or	 DWORD PTR [ebx+428], 4

; 2118 : 		LogAdd(LOG_BLACK, "Penalty : Item Don't touch  %s %s", lpObj->AccountID, lpObj->Name);

  00d3d	8d 43 6f	 lea	 eax, DWORD PTR [ebx+111]
  00d40	50		 push	 eax
  00d41	8d 4b 64	 lea	 ecx, DWORD PTR [ebx+100]
  00d44	51		 push	 ecx
  00d45	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GOGGAFJG@Penalty?5?3?5Item?5Don?8t?5touch?5?5?$CFs?5?$CF@
  00d4a	6a 00		 push	 0
  00d4c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00d51	83 c4 10	 add	 esp, 16			; 00000010H
$LN144@gObjSetCha:

; 2119 : 	}
; 2120 : 
; 2121 : 	::gObjAuthorityCodeSet(lpObj);

  00d54	53		 push	 ebx
  00d55	e8 00 00 00 00	 call	 ?gObjAuthorityCodeSet@@YAXPAUOBJECTSTRUCT@@@Z ; gObjAuthorityCodeSet
  00d5a	83 c4 04	 add	 esp, 4

; 2122 : 	LogAdd(LOG_BLACK, lMsg.Get(MSGGET(1, 246)), lpObj->m_Index, lpObj->AccountID, lpObj->Name);

  00d5d	8d 43 6f	 lea	 eax, DWORD PTR [ebx+111]
  00d60	50		 push	 eax
  00d61	8b 03		 mov	 eax, DWORD PTR [ebx]
  00d63	8d 53 64	 lea	 edx, DWORD PTR [ebx+100]
  00d66	52		 push	 edx
  00d67	50		 push	 eax
  00d68	68 f6 01 00 00	 push	 502			; 000001f6H
  00d6d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00d72	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00d77	50		 push	 eax
  00d78	6a 00		 push	 0
  00d7a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2123 : 
; 2124 : 	BYTE weather = MapC[lpObj->MapNumber].GetWeather();

  00d7f	0f b6 8b 09 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+265]
  00d86	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00d8c	83 c4 14	 add	 esp, 20			; 00000014H
  00d8f	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00d95	e8 00 00 00 00	 call	 ?GetWeather@MapClass@@QAEEXZ ; MapClass::GetWeather
  00d9a	88 85 c8 fe ff
	ff		 mov	 BYTE PTR _weather$[ebp], al

; 2125 : 
; 2126 : 	if ( (weather >> 4) > 0 )

  00da0	a8 f0		 test	 al, 240			; 000000f0H
  00da2	76 10		 jbe	 SHORT $LN9@gObjSetCha

; 2127 : 	{
; 2128 : 		CGWeatherSend(aIndex, weather);

  00da4	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _weather$[ebp]
  00daa	51		 push	 ecx
  00dab	57		 push	 edi
  00dac	e8 00 00 00 00	 call	 ?CGWeatherSend@@YAXHE@Z	; CGWeatherSend
  00db1	83 c4 08	 add	 esp, 8
$LN9@gObjSetCha:

; 2129 : 	}
; 2130 : 
; 2131 : 	if ( DragonEvent->GetState() > 0 )

  00db4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  00dba	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  00dbe	76 1b		 jbe	 SHORT $LN145@gObjSetCha

; 2132 : 	{
; 2133 : 		if ( DragonEvent->GetMapNumber() == lpObj->MapNumber )

  00dc0	8a 83 09 01 00
	00		 mov	 al, BYTE PTR [ebx+265]
  00dc6	38 41 0c	 cmp	 BYTE PTR [ecx+12], al
  00dc9	75 10		 jne	 SHORT $LN145@gObjSetCha

; 2134 : 		{
; 2135 : 			::GCMapEventStateSend(lpObj->MapNumber, 1, 1);

  00dcb	6a 01		 push	 1
  00dcd	0f b6 d0	 movzx	 edx, al
  00dd0	6a 01		 push	 1
  00dd2	52		 push	 edx
  00dd3	e8 00 00 00 00	 call	 ?GCMapEventStateSend@@YAXHEE@Z ; GCMapEventStateSend
  00dd8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN145@gObjSetCha:

; 2136 : 		}
; 2137 : 	}
; 2138 : 
; 2139 : #if GS_CASTLE == 1
; 2140 : 	if ( lpObj->MapNumber == MAP_INDEX_CASTLESIEGE )
; 2141 : 	{
; 2142 : 		GCAnsCsNotifyStart(lpObj->m_Index, CHECK_CLASS(g_CastleSiege.GetCastleState(), CASTLESIEGE_STATE_STARTSIEGE));
; 2143 : 
; 2144 : 		if ( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 2145 : 			g_CastleSiege.NotifyCsSelfLeftTime(lpObj->m_Index);
; 2146 : 	}
; 2147 : #endif
; 2148 : 
; 2149 : 	::gEledoradoEvent.CheckGoldDercon(lpObj->MapNumber);

  00ddb	0f b6 83 09 01
	00 00		 movzx	 eax, BYTE PTR [ebx+265]
  00de2	50		 push	 eax
  00de3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gEledoradoEvent@@3VCEledoradoEvent@@A ; gEledoradoEvent
  00de8	e8 00 00 00 00	 call	 ?CheckGoldDercon@CEledoradoEvent@@QAEXH@Z ; CEledoradoEvent::CheckGoldDercon

; 2150 : 	::GCCheckMainExeKeySend(aIndex);

  00ded	57		 push	 edi
  00dee	e8 00 00 00 00	 call	 ?GCCheckMainExeKeySend@@YAXH@Z ; GCCheckMainExeKeySend

; 2151 : 
; 2152 : 	if ( m_ObjBill[aIndex].GetCertify() >= 0 && m_ObjBill[aIndex].GetCertify() < 3 )

  00df3	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00df6	8a 04 cd 00 00
	00 00		 mov	 al, BYTE PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[ecx*8]
  00dfd	83 c4 04	 add	 esp, 4
  00e00	84 c0		 test	 al, al
  00e02	78 13		 js	 SHORT $LN6@gObjSetCha
  00e04	3c 03		 cmp	 al, 3
  00e06	7d 0f		 jge	 SHORT $LN6@gObjSetCha

; 2153 : 	{
; 2154 : 		gLCount[m_ObjBill[aIndex].GetCertify()].Add();

  00e08	0f be c8	 movsx	 ecx, al
  00e0b	8d 0c 8d 00 00
	00 00		 lea	 ecx, DWORD PTR ?gLCount@@3PAVCLoginCount@@A[ecx*4]
  00e12	e8 00 00 00 00	 call	 ?Add@CLoginCount@@QAEXXZ ; CLoginCount::Add
$LN6@gObjSetCha:

; 2155 : 	}
; 2156 : 
; 2157 : 	if ( bAllItemExist == false )

  00e17	80 bd df fe ff
	ff 00		 cmp	 BYTE PTR _bAllItemExist$[ebp], 0
  00e1e	75 2d		 jne	 SHORT $LN147@gObjSetCha

; 2158 : 	{
; 2159 : 		PMSG_NOTICE pNotice;
; 2160 : 		TNotice::MakeNoticeMsgEx((TNotice *)&pNotice, 1, "Item not found !!!");

  00e20	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BLMMKPFO@Item?5not?5found?5?$CB?$CB?$CB?$AA@
  00e25	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$162443[ebp]
  00e2b	6a 01		 push	 1
  00e2d	52		 push	 edx
  00e2e	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 2161 : 		DataSend(lpObj->m_Index, (UCHAR *)&pNotice, pNotice.h.size);

  00e33	0f b6 85 e1 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$162443[ebp+1]
  00e3a	8b 13		 mov	 edx, DWORD PTR [ebx]
  00e3c	50		 push	 eax
  00e3d	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$162443[ebp]
  00e43	51		 push	 ecx
  00e44	52		 push	 edx
  00e45	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00e4a	83 c4 18	 add	 esp, 24			; 00000018H
$LN147@gObjSetCha:

; 2162 : 	}
; 2163 : 
; 2164 : 	if ( lpObj->Level <= g_iCharacterRecuperationMaxLevel )

  00e4d	0f bf 83 9c 00
	00 00		 movsx	 eax, WORD PTR [ebx+156]
  00e54	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_iCharacterRecuperationMaxLevel@@3HA ; g_iCharacterRecuperationMaxLevel
  00e5a	7f 0e		 jg	 SHORT $LN4@gObjSetCha

; 2165 : 	{
; 2166 : 		lpObj->m_iAutoRecuperationTime = GetTickCount();

  00e5c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00e62	89 83 20 15 00
	00		 mov	 DWORD PTR [ebx+5408], eax

; 2167 : 	}
; 2168 : 	else

  00e68	eb 0a		 jmp	 SHORT $LN3@gObjSetCha
$LN4@gObjSetCha:

; 2169 : 	{
; 2170 : 		lpObj->m_iAutoRecuperationTime = 0;

  00e6a	c7 83 20 15 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+5408], 0
$LN3@gObjSetCha:

; 2171 : 	}
; 2172 : 
; 2173 : 	if((lpObj->Authority & 2) == 2 || (lpObj->Authority & 8) == 8 || (lpObj->Authority & 32) == 32)

  00e74	f6 83 a4 01 00
	00 2a		 test	 BYTE PTR [ebx+420], 42	; 0000002aH
  00e7b	74 1c		 je	 SHORT $LN148@gObjSetCha

; 2174 : 	{
; 2175 : 		lpObj->m_ViewSkillState |= 0x1000000;

  00e7d	81 8b c4 01 00
	00 00 00 00 01	 or	 DWORD PTR [ebx+452], 16777216 ; 01000000H
  00e87	8b 83 c4 01 00
	00		 mov	 eax, DWORD PTR [ebx+452]

; 2176 : 		GCStateInfoSend(lpObj, 1, lpObj->m_ViewSkillState);

  00e8d	50		 push	 eax
  00e8e	6a 01		 push	 1
  00e90	53		 push	 ebx
  00e91	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  00e96	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN148@gObjSetCha:

; 2177 : 	}
; 2178 : 
; 2179 : 	gServerInfo.SendMain(aIndex);

  00e99	57		 push	 edi
  00e9a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gServerInfo@@3VCServerInfo@@A ; gServerInfo
  00e9f	e8 00 00 00 00	 call	 ?SendMain@CServerInfo@@QAEXH@Z ; CServerInfo::SendMain

; 2180 : 
; 2181 : 	return TRUE;
; 2182 : }

  00ea4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ea7	5f		 pop	 edi
  00ea8	5b		 pop	 ebx
  00ea9	33 cd		 xor	 ecx, ebp
  00eab	b8 01 00 00 00	 mov	 eax, 1
  00eb0	5e		 pop	 esi
  00eb1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00eb6	8b e5		 mov	 esp, ebp
  00eb8	5d		 pop	 ebp
  00eb9	c3		 ret	 0
?gObjSetCharacter@@YAHPAEH@Z ENDP			; gObjSetCharacter
_TEXT	ENDS
PUBLIC	??_C@_0CJ@KJGJCOOM@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Loser?5@ ; `string'
PUBLIC	??_C@_0EM@OALGHOD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@ ; `string'
PUBLIC	??_C@_0DN@HEKHJLCJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5stat@ ; `string'
PUBLIC	??_C@_0EG@KMNGALHI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5stat@ ; `string'
PUBLIC	??_C@_0CL@NGGLKHML@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termina@ ; `string'
PUBLIC	??_C@_0DD@JANPNOOL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termina@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHE@Z	; gObjLifeCheck
EXTRN	?GCDamageSend@@YAXHHHHH@Z:PROC			; GCDamageSend
EXTRN	?GCDamageSend@@YAXHH@Z:PROC			; GCDamageSend
EXTRN	?gObjMonsterScoreDivision@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@0HH@Z:PROC ; CDevilSquare::gObjMonsterScoreDivision
EXTRN	?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z:PROC ; GCDiePlayerSend
EXTRN	?SendFailMessage@CChaosCastle@@QAEXHH@Z:PROC	; CChaosCastle::SendFailMessage
EXTRN	?SetUserState@CChaosCastle@@QAEXHH@Z:PROC	; CChaosCastle::SetUserState
EXTRN	?DelMonsterList@CChaosCastle@@QAEXHH@Z:PROC	; CChaosCastle::DelMonsterList
EXTRN	?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z:PROC	; CChaosCastle::SearchNBlowObjs
EXTRN	?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z:PROC ; CBloodCastle::SendNoticeMessage
EXTRN	?gObjMonsterSetHitDamage@@YAXPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjMonsterSetHitDamage
EXTRN	?GCRecallMonLife@@YAXHHH@Z:PROC			; GCRecallMonLife
;	COMDAT ??_C@_0CJ@KJGJCOOM@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Loser?5@
CONST	SEGMENT
??_C@_0CJ@KJGJCOOM@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Loser?5@ DB '['
	DB	'Duel] [%s][%s] Win Duel, Loser [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@OALGHOD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@
CONST	SEGMENT
??_C@_0EM@OALGHOD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] User Dead In Chaos Castle : Kille'
	DB	'd by [%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HEKHJLCJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5stat@
CONST	SEGMENT
??_C@_0DN@HEKHJLCJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5stat@ DB '['
	DB	'Blood Castle] (%d) a stone statue Of Saint Terminated -> %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@KMNGALHI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5stat@
CONST	SEGMENT
??_C@_0EG@KMNGALHI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5stat@ DB '['
	DB	'Blood Castle] (%d) a stone statue Of Saint Terminated -> %d ['
	DB	'%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NGGLKHML@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termina@
CONST	SEGMENT
??_C@_0CL@NGGLKHML@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termina@ DB '['
	DB	'Blood Castle] (%d) Door Terminated -> %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JANPNOOL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termina@
CONST	SEGMENT
??_C@_0DD@JANPNOOL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termina@ DB '['
	DB	'Blood Castle] (%d) Door Terminated -> %d [%s][%s]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHE@Z
_TEXT	SEGMENT
_TopHitUser$164083 = -292				; size = 4
tv1723 = -288						; size = 4
tv1682 = -288						; size = 4
_ServerCmd$164138 = -288				; size = 7
_lpCallObj$ = -280					; size = 4
_pMsg$164124 = -276					; size = 15
_szMsg$164137 = -260					; size = 256
_szMsg$164092 = -260					; size = 256
_szMsg$164085 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpTargetObj$ = 8					; size = 4
_lpObj$ = 12						; size = 4
_AttackDamage$ = 16					; size = 4
_DamageSendType$ = 20					; size = 4
_MSBFlag$ = 24						; size = 4
_MSBDamage$ = 28					; size = 4
_Skill$ = 32						; size = 1
?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHE@Z PROC	; gObjLifeCheck, COMDAT

; 6931 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 6932 : 	if(lpObj->Connected < PLAYER_PLAYING)

  00017	80 7e 04 03	 cmp	 BYTE PTR [esi+4], 3
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _lpTargetObj$[ebp]
  0001f	0f 82 d1 0c 00
	00		 jb	 $LN67@gObjLifeCh

; 6933 : 	{
; 6934 : 		return;
; 6935 : 	}
; 6936 : 
; 6937 : 	if(ATTRIBUTE_RANGE(lpObj->m_Attribute) || ATTRIBUTE_RANGE(lpTargetObj->m_Attribute))

  00025	0f b7 86 26 03
	00 00		 movzx	 eax, WORD PTR [esi+806]
  0002c	66 83 f8 33	 cmp	 ax, 51			; 00000033H
  00030	7c 13		 jl	 SHORT $LN115@gObjLifeCh
  00032	33 c9		 xor	 ecx, ecx
  00034	66 83 f8 3a	 cmp	 ax, 58			; 0000003aH
  00038	0f 9e c1	 setle	 cl
  0003b	8b c1		 mov	 eax, ecx
  0003d	85 c0		 test	 eax, eax
  0003f	0f 85 b1 0c 00
	00		 jne	 $LN67@gObjLifeCh
$LN115@gObjLifeCh:
  00045	0f b7 87 26 03
	00 00		 movzx	 eax, WORD PTR [edi+806]
  0004c	66 83 f8 33	 cmp	 ax, 51			; 00000033H
  00050	7c 13		 jl	 SHORT $LN116@gObjLifeCh
  00052	33 d2		 xor	 edx, edx
  00054	66 83 f8 3a	 cmp	 ax, 58			; 0000003aH
  00058	0f 9e c2	 setle	 dl
  0005b	8b c2		 mov	 eax, edx
  0005d	85 c0		 test	 eax, eax
  0005f	0f 85 91 0c 00
	00		 jne	 $LN67@gObjLifeCh
$LN116@gObjLifeCh:

; 6938 : 	{
; 6939 : 		return;
; 6940 : 	}
; 6941 : 
; 6942 : 	LPOBJ lpCallObj = lpObj;
; 6943 : 
; 6944 : 	if(lpObj->Type == OBJ_MONSTER && lpObj->m_RecallMon >= 0)

  00065	b9 02 00 00 00	 mov	 ecx, 2
  0006a	89 b5 e8 fe ff
	ff		 mov	 DWORD PTR _lpCallObj$[ebp], esi
  00070	66 39 4e 60	 cmp	 WORD PTR [esi+96], cx
  00074	75 1b		 jne	 SHORT $LN66@gObjLifeCh
  00076	8b 86 cc 02 00
	00		 mov	 eax, DWORD PTR [esi+716]
  0007c	85 c0		 test	 eax, eax
  0007e	78 11		 js	 SHORT $LN66@gObjLifeCh

; 6945 : 	{
; 6946 : 		lpCallObj = &gObj[lpObj->m_RecallMon];

  00080	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00086	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008b	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _lpCallObj$[ebp], eax
$LN66@gObjLifeCh:

; 6947 : 	}
; 6948 : 
; 6949 : 	if(AttackDamage != 0 && lpTargetObj->Type == OBJ_MONSTER)

  00091	83 7d 10 00	 cmp	 DWORD PTR _AttackDamage$[ebp], 0
  00095	53		 push	 ebx
  00096	74 47		 je	 SHORT $LN65@gObjLifeCh
  00098	66 39 4f 60	 cmp	 WORD PTR [edi+96], cx
  0009c	75 41		 jne	 SHORT $LN65@gObjLifeCh

; 6950 : 	{
; 6951 : 		if(lpTargetObj->m_RecallMon >= 0)

  0009e	8b 9f cc 02 00
	00		 mov	 ebx, DWORD PTR [edi+716]
  000a4	85 db		 test	 ebx, ebx
  000a6	78 21		 js	 SHORT $LN64@gObjLifeCh

; 6952 : 		{
; 6953 : 			GCRecallMonLife(lpTargetObj->m_RecallMon,lpTargetObj->MaxLife,lpTargetObj->Life);

  000a8	d9 87 bc 00 00
	00		 fld	 DWORD PTR [edi+188]
  000ae	e8 00 00 00 00	 call	 __ftol2_sse
  000b3	d9 87 c0 00 00
	00		 fld	 DWORD PTR [edi+192]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 __ftol2_sse
  000bf	50		 push	 eax
  000c0	53		 push	 ebx
  000c1	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN64@gObjLifeCh:

; 6954 : 		}
; 6955 : 
; 6956 : 		gObjMonsterSetHitDamage(lpTargetObj,lpCallObj->m_Index,AttackDamage);

  000c9	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  000cc	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpCallObj$[ebp]
  000d2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d4	50		 push	 eax
  000d5	52		 push	 edx
  000d6	57		 push	 edi
  000d7	e8 00 00 00 00	 call	 ?gObjMonsterSetHitDamage@@YAXPAUOBJECTSTRUCT@@HH@Z ; gObjMonsterSetHitDamage
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN65@gObjLifeCh:

; 6957 : 	}
; 6958 : 
; 6959 : 	if(lpTargetObj->Life <= 0 && lpTargetObj->Live != 0)

  000df	d9 ee		 fldz
  000e1	d8 9f bc 00 00
	00		 fcomp	 DWORD PTR [edi+188]
  000e7	df e0		 fnstsw	 ax
  000e9	f6 c4 01	 test	 ah, 1
  000ec	0f 85 9a 0b 00
	00		 jne	 $LN63@gObjLifeCh
  000f2	80 7f 62 00	 cmp	 BYTE PTR [edi+98], 0
  000f6	0f 84 90 0b 00
	00		 je	 $LN63@gObjLifeCh

; 6960 : 	{
; 6961 : 		if(lpObj->Type == OBJ_MONSTER)

  000fc	66 83 7e 60 02	 cmp	 WORD PTR [esi+96], 2
  00101	bb 01 00 00 00	 mov	 ebx, 1
  00106	75 2e		 jne	 SHORT $LN62@gObjLifeCh

; 6962 : 		{
; 6963 : 			gObjAddMsgSend(lpObj,3,lpTargetObj->m_Index,0);

  00108	8b 07		 mov	 eax, DWORD PTR [edi]
  0010a	6a 00		 push	 0
  0010c	50		 push	 eax
  0010d	6a 03		 push	 3
  0010f	56		 push	 esi
  00110	e8 00 00 00 00	 call	 ?gObjAddMsgSend@@YAXPAUOBJECTSTRUCT@@HHH@Z ; gObjAddMsgSend

; 6964 : 			CreateFrustrum(lpObj->X,lpObj->Y,lpObj->m_Index);

  00115	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00117	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  0011e	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR [esi+260]
  00125	51		 push	 ecx
  00126	52		 push	 edx
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  0012d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 6965 : 			lpTargetObj->KillerType = 1;

  00130	88 9f 01 02 00
	00		 mov	 BYTE PTR [edi+513], bl
$LN62@gObjLifeCh:

; 6966 : 		}
; 6967 : 
; 6968 : 		if(lpObj->Type == OBJ_USER)

  00136	66 39 5e 60	 cmp	 WORD PTR [esi+96], bx
  0013a	75 2c		 jne	 SHORT $LN60@gObjLifeCh

; 6969 : 		{
; 6970 : 			gDarkSpirit[lpObj->m_Index].ReSetTarget(lpTargetObj->m_Index);

  0013c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0013e	8b 06		 mov	 eax, DWORD PTR [esi]
  00140	51		 push	 ecx
  00141	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00144	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gDarkSpirit@@3PAVCDarkSpirit@@A[ecx*8]
  0014b	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget

; 6971 : 		}
; 6972 : 
; 6973 : 		if(lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_USER)

  00150	66 39 5e 60	 cmp	 WORD PTR [esi+96], bx
  00154	75 12		 jne	 SHORT $LN60@gObjLifeCh
  00156	66 39 5f 60	 cmp	 WORD PTR [edi+96], bx
  0015a	75 0c		 jne	 SHORT $LN60@gObjLifeCh

; 6974 : 		{
; 6975 : 			gObjSetKillCount(lpObj->m_Index,1);

  0015c	8b 16		 mov	 edx, DWORD PTR [esi]
  0015e	53		 push	 ebx
  0015f	52		 push	 edx
  00160	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount
  00165	83 c4 08	 add	 esp, 8
$LN60@gObjLifeCh:

; 6976 : 		}
; 6977 : 
; 6978 : 		if(lpTargetObj->Type == OBJ_MONSTER)

  00168	0f b7 47 60	 movzx	 eax, WORD PTR [edi+96]
  0016c	83 f8 02	 cmp	 eax, 2
  0016f	0f 85 1f 06 00
	00		 jne	 $LN59@gObjLifeCh

; 6979 : 		{
; 6980 : #if (GS_CASTLE==0)
; 6981 : 			if(lpTargetObj->Class == 275 || lpTargetObj->Class == 295)

  00175	0f b7 87 98 00
	00 00		 movzx	 eax, WORD PTR [edi+152]
  0017c	b9 13 01 00 00	 mov	 ecx, 275		; 00000113H
  00181	66 3b c1	 cmp	 ax, cx
  00184	74 20		 je	 SHORT $LN57@gObjLifeCh
  00186	ba 27 01 00 00	 mov	 edx, 295		; 00000127H
  0018b	66 3b c2	 cmp	 ax, dx
  0018e	74 16		 je	 SHORT $LN57@gObjLifeCh

; 6984 : 			}
; 6985 : 			else
; 6986 : 			{
; 6987 : 				gObjAddMsgSendDelay(lpTargetObj,1,lpObj->m_Index,800,0);

  00190	8b 06		 mov	 eax, DWORD PTR [esi]
  00192	6a 00		 push	 0
  00194	68 20 03 00 00	 push	 800			; 00000320H
  00199	50		 push	 eax
  0019a	53		 push	 ebx
  0019b	57		 push	 edi
  0019c	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  001a1	83 c4 14	 add	 esp, 20			; 00000014H
  001a4	eb 16		 jmp	 SHORT $LN56@gObjLifeCh
$LN57@gObjLifeCh:

; 6982 : 			{
; 6983 : 				gObjAddMsgSendDelayInSpecificQPos(lpTargetObj,1,lpObj->m_Index,800,0,0);

  001a6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001a8	6a 00		 push	 0
  001aa	6a 00		 push	 0
  001ac	68 20 03 00 00	 push	 800			; 00000320H
  001b1	51		 push	 ecx
  001b2	53		 push	 ebx
  001b3	57		 push	 edi
  001b4	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelayInSpecificQPos@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddMsgSendDelayInSpecificQPos
  001b9	83 c4 18	 add	 esp, 24			; 00000018H
$LN56@gObjLifeCh:

; 6988 : 			}
; 6989 : #endif
; 6990 : 
; 6991 : #if (GS_CASTLE==1)
; 6992 : 			if(lpTargetObj->m_Attribute == 62)
; 6993 : 			{
; 6994 : 
; 6995 : 				char szMsg[256];
; 6996 : 
; 6997 : 				switch(lpTargetObj->Class)
; 6998 : 				{
; 6999 : 				case 300:// Hero Mobs
; 7000 : 				case 301:
; 7001 : 				case 302:
; 7002 : 				case 303:
; 7003 : 					{
; 7004 : 						PMSG_NOTICE pNotice;
; 7005 : 
; 7006 : 						ItemSerialCreateSend(lpObj->m_Index,lpObj->MapNumber,lpObj->X,lpObj->Y,ItemGetNumberMake(14,13),0,0,0,0,0,lpObj->m_Index,0,0);
; 7007 : 
; 7008 : 						if(gObjIsConnected(lpObj->m_Index))
; 7009 : 						{
; 7010 : 							wsprintf(szMsg,lMsg.Get(MSGGET(12, 155)),lpTargetObj->Name,lpObj->Name);
; 7011 : 							LogAdd(LOG_BLACK, "[CastleDeep Event] [%s][%s] Boss Monster Killed : %s",lpObj->AccountID,lpObj->Name,lpTargetObj->Name);
; 7012 : 						}
; 7013 : 						else
; 7014 : 						{
; 7015 : 							wsprintf(szMsg,lMsg.Get(MSGGET(12, 156)),lpTargetObj->Name);
; 7016 : 							LogAdd(LOG_BLACK, "[CastleDeep Event] Boss Monster Killed : %s",lpTargetObj->Name);
; 7017 : 						}
; 7018 : 
; 7019 : 						TNotice::MakeNoticeMsg(&pNotice,0,szMsg);
; 7020 : 
; 7021 : 						for(int i = OBJ_STARTUSERINDEX; i < OBJMAX;i++)
; 7022 : 						{
; 7023 : 							if(gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)
; 7024 : 							{
; 7025 : 								DataSend(i,(PBYTE)&pNotice,pNotice.h.size);
; 7026 : 							}
; 7027 : 						}
; 7028 : 					}
; 7029 : 					break;
; 7030 : 				case 295: // Erohim
; 7031 : 					{
; 7032 : 						PMSG_NOTICE pNotice;
; 7033 : 
; 7034 : 						if(gObjIsConnected(lpObj->m_Index))
; 7035 : 						{
; 7036 : 							wsprintf(szMsg,lMsg.Get(MSGGET(12, 157)),lpObj->Name);
; 7037 : 							LogAdd(LOG_BLACK, "[CastleDeep Event] [%s][%s] Boss Monster Killed : %s",lpObj->AccountID,lpObj->Name,lpTargetObj->Name);
; 7038 : 						}
; 7039 : 						else
; 7040 : 						{
; 7041 : 							wsprintf(szMsg,lMsg.Get(MSGGET(12, 158)));
; 7042 : 							LogAdd(LOG_BLACK, "[CastleDeep Event] Boss Monster Killed : %s",lpTargetObj->Name);
; 7043 : 						}
; 7044 : 
; 7045 : 						TNotice::MakeNoticeMsg(&pNotice,0,szMsg);
; 7046 : 
; 7047 : 						for(int i = OBJ_STARTUSERINDEX; i < OBJMAX;i++)
; 7048 : 						{
; 7049 : 							if(gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)
; 7050 : 							{
; 7051 : 								DataSend(i,(PBYTE)&pNotice,pNotice.h.size);
; 7052 : 							}
; 7053 : 						}
; 7054 : 					}
; 7055 : 					break;
; 7056 : 				}
; 7057 : 			}
; 7058 : #endif
; 7059 : 			if(BC_MAP_RANGE(lpTargetObj->MapNumber))

  001bc	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR [edi+265]
  001c3	3c 0b		 cmp	 al, 11			; 0000000bH
  001c5	0f 82 ed 04 00
	00		 jb	 $LN114@gObjLifeCh
  001cb	b2 11		 mov	 dl, 17			; 00000011H
  001cd	3a d0		 cmp	 dl, al
  001cf	1b c0		 sbb	 eax, eax
  001d1	40		 inc	 eax
  001d2	0f 84 e0 04 00
	00		 je	 $LN114@gObjLifeCh

; 7060 : 			{
; 7061 : 				if(lpTargetObj->Class == 131)

  001d8	b8 83 00 00 00	 mov	 eax, 131		; 00000083H
  001dd	66 39 87 98 00
	00 00		 cmp	 WORD PTR [edi+152], ax
  001e4	0f 85 81 01 00
	00		 jne	 $LN122@gObjLifeCh

; 7062 : 				{
; 7063 : 					int TopHitUser = gObjMonsterTopHitDamageUser(lpTargetObj);

  001ea	57		 push	 edi
  001eb	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  001f0	83 c4 04	 add	 esp, 4
  001f3	89 85 dc fe ff
	ff		 mov	 DWORD PTR _TopHitUser$164083[ebp], eax

; 7064 : 
; 7065 : 					if(TopHitUser != -1)
; 7066 : 					{
; 7067 : 						char szMsg[256];
; 7068 : 
; 7069 : 						wsprintf(szMsg,lMsg.Get(1178),gObj[TopHitUser].Name);

  001f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001fe	83 f8 ff	 cmp	 eax, -1
  00201	0f 84 1d 01 00
	00		 je	 $LN53@gObjLifeCh
  00207	8b d8		 mov	 ebx, eax
  00209	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  0020f	8d 83 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+111]
  00215	50		 push	 eax
  00216	68 9a 04 00 00	 push	 1178			; 0000049aH
  0021b	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv1682[ebp], eax
  00221	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00226	50		 push	 eax
  00227	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szMsg$164085[ebp]
  0022d	51		 push	 ecx
  0022e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 7070 : 
; 7071 : 						g_BloodCastle.SendNoticeMessage(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1,szMsg);

  00234	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  0023b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023e	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szMsg$164085[ebp]
  00244	52		 push	 edx
  00245	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00248	50		 push	 eax
  00249	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0024e	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage

; 7072 : 
; 7073 : 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_iExtraEXP_Kill_Door_Party = gObj[TopHitUser].PartyNumber;

  00253	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  0025a	8b 93 a8 02 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+680]
  00260	c1 e1 09	 shl	 ecx, 9
  00263	89 91 a0 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+416], edx

; 7074 : 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_iExtraEXP_Kill_Door_Index = TopHitUser;

  00269	0f be 86 02 0d
	00 00		 movsx	 eax, BYTE PTR [esi+3330]
  00270	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _TopHitUser$164083[ebp]
  00276	c1 e0 09	 shl	 eax, 9
  00279	89 88 a4 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+420], ecx

; 7075 : 
; 7076 : 						memcpy(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Door_CharName,gObj[TopHitUser].Name,10);

  0027f	0f be 86 02 0d
	00 00		 movsx	 eax, BYTE PTR [esi+3330]
  00286	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1682[ebp]
  0028c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0028e	c1 e0 09	 shl	 eax, 9
  00291	05 b3 01 00 00	 add	 eax, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A+435
  00296	89 10		 mov	 DWORD PTR [eax], edx
  00298	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0029b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0029e	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  002a2	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 7077 : 						memcpy(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Door_AccountID,gObj[TopHitUser].AccountID,10);

  002a6	0f be 86 02 0d
	00 00		 movsx	 eax, BYTE PTR [esi+3330]
  002ad	8b 93 64 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+100]
  002b3	c1 e0 09	 shl	 eax, 9
  002b6	05 a8 01 00 00	 add	 eax, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A+424
  002bb	89 10		 mov	 DWORD PTR [eax], edx
  002bd	8b 93 68 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+104]
  002c3	89 50 04	 mov	 DWORD PTR [eax+4], edx
  002c6	0f b7 93 6c 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+108]
  002cd	8d 9b 64 00 00
	00		 lea	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+100]
  002d3	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 7078 : 
; 7079 : 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Door_CharName[10] = 0;

  002d7	0f be 86 02 0d
	00 00		 movsx	 eax, BYTE PTR [esi+3330]
  002de	c1 e0 09	 shl	 eax, 9
  002e1	c6 80 bd 01 00
	00 00		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+445], 0

; 7080 : 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Door_AccountID[10] = 0;

  002e8	0f be 96 02 0d
	00 00		 movsx	 edx, BYTE PTR [esi+3330]
  002ef	c1 e2 09	 shl	 edx, 9

; 7081 : 
; 7082 : 						LogAdd(LOG_BLACK, "[Blood Castle] (%d) Door Terminated -> %d [%s][%s]",lpObj->MapNumber - (MAP_INDEX_BLOODCASTLE1-1),g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT,gObj[TopHitUser].AccountID,gObj[TopHitUser].Name);

  002f2	51		 push	 ecx
  002f3	c6 82 b2 01 00
	00 00		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+434], 0
  002fa	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00301	8d 48 f5	 lea	 ecx, DWORD PTR [eax-11]
  00304	53		 push	 ebx
  00305	c1 e1 09	 shl	 ecx, 9
  00308	8b 91 88 01 00
	00		 mov	 edx, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+392]
  0030e	52		 push	 edx
  0030f	83 c0 f6	 add	 eax, -10		; fffffff6H
  00312	50		 push	 eax
  00313	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@JANPNOOL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termina@
  00318	6a 00		 push	 0
  0031a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0031f	83 c4 18	 add	 esp, 24			; 00000018H

; 7083 : 					}
; 7084 : 					else

  00322	eb 47		 jmp	 SHORT $LN122@gObjLifeCh
$LN53@gObjLifeCh:

; 7085 : 					{
; 7086 : 						g_BloodCastle.SendNoticeMessage(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1,lMsg.Get(1169));

  00324	68 91 04 00 00	 push	 1169			; 00000491H
  00329	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0032e	50		 push	 eax
  0032f	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00336	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00339	50		 push	 eax
  0033a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0033f	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage

; 7087 : 						LogAdd(LOG_BLACK, "[Blood Castle] (%d) Door Terminated -> %d)",lpObj->MapNumber - (MAP_INDEX_BLOODCASTLE1-1),g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT);

  00344	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  0034b	8d 48 f5	 lea	 ecx, DWORD PTR [eax-11]
  0034e	c1 e1 09	 shl	 ecx, 9
  00351	8b 91 88 01 00
	00		 mov	 edx, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+392]
  00357	52		 push	 edx
  00358	83 c0 f6	 add	 eax, -10		; fffffff6H
  0035b	50		 push	 eax
  0035c	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NGGLKHML@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termina@
  00361	6a 00		 push	 0
  00363	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00368	83 c4 10	 add	 esp, 16			; 00000010H
$LN122@gObjLifeCh:

; 7088 : 					}
; 7089 : 				}
; 7090 : 
; 7091 : 
; 7092 : 				if(BC_STATUE_RANGE(lpTargetObj->Class - 132))

  0036b	0f b7 87 98 00
	00 00		 movzx	 eax, WORD PTR [edi+152]
  00372	05 7c ff ff ff	 add	 eax, -132		; ffffff7cH
  00377	0f 88 8d 01 00
	00		 js	 $LN49@gObjLifeCh
  0037d	33 c9		 xor	 ecx, ecx
  0037f	83 f8 02	 cmp	 eax, 2
  00382	0f 9e c1	 setle	 cl
  00385	8b c1		 mov	 eax, ecx
  00387	85 c0		 test	 eax, eax
  00389	0f 84 7b 01 00
	00		 je	 $LN49@gObjLifeCh

; 7093 : 				{
; 7094 : 					int TopHitUser = gObjMonsterTopHitDamageUser(lpTargetObj);

  0038f	57		 push	 edi
  00390	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00395	83 c4 04	 add	 esp, 4

; 7095 : 
; 7096 : 					if(TopHitUser != -1)
; 7097 : 					{
; 7098 : 						char szMsg[256];
; 7099 : 
; 7100 : 						wsprintf(szMsg,lMsg.Get(1179),gObj[TopHitUser].Name);

  00398	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0039d	83 f8 ff	 cmp	 eax, -1
  003a0	0f 84 1d 01 00
	00		 je	 $LN50@gObjLifeCh
  003a6	8b d8		 mov	 ebx, eax
  003a8	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  003ae	8d 83 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+111]
  003b4	50		 push	 eax
  003b5	68 9b 04 00 00	 push	 1179			; 0000049bH
  003ba	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv1723[ebp], eax
  003c0	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003c5	50		 push	 eax
  003c6	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szMsg$164092[ebp]
  003cc	52		 push	 edx
  003cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 7101 : 
; 7102 : 						g_BloodCastle.SendNoticeMessage(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1,szMsg);

  003d3	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  003da	83 c4 0c	 add	 esp, 12			; 0000000cH
  003dd	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$164092[ebp]
  003e3	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  003e6	50		 push	 eax
  003e7	51		 push	 ecx
  003e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  003ed	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage

; 7103 : 
; 7104 : 
; 7105 : 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_iExtraEXP_Kill_Statue_Party = gObj[TopHitUser].PartyNumber;

  003f2	0f be 96 02 0d
	00 00		 movsx	 edx, BYTE PTR [esi+3330]
  003f9	8b 83 a8 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+680]
  003ff	c1 e2 09	 shl	 edx, 9
  00402	89 82 c0 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+448], eax

; 7106 : 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_iExtraEXP_Kill_Statue_Index = gObj[TopHitUser].m_Index;

  00408	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  0040f	8b 93 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx]
  00415	c1 e1 09	 shl	 ecx, 9
  00418	89 91 c4 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+452], edx

; 7107 : 
; 7108 : 						memcpy(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Status_CharName,gObj[TopHitUser].Name,10);

  0041e	0f be 86 02 0d
	00 00		 movsx	 eax, BYTE PTR [esi+3330]
  00425	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1723[ebp]
  0042b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0042d	c1 e0 09	 shl	 eax, 9
  00430	05 c8 01 00 00	 add	 eax, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A+456
  00435	89 10		 mov	 DWORD PTR [eax], edx
  00437	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0043a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0043d	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  00441	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 7109 : 						memcpy(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Status_AccountID,gObj[TopHitUser].AccountID,10);

  00445	0f be 86 02 0d
	00 00		 movsx	 eax, BYTE PTR [esi+3330]
  0044c	8b 93 64 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+100]
  00452	c1 e0 09	 shl	 eax, 9
  00455	05 d3 01 00 00	 add	 eax, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A+467
  0045a	89 10		 mov	 DWORD PTR [eax], edx
  0045c	8b 93 68 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+104]
  00462	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00465	0f b7 93 6c 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+108]
  0046c	8d 9b 64 00 00
	00		 lea	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+100]
  00472	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 7110 : 
; 7111 : 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Status_CharName[10] = 0;

  00476	0f be 86 02 0d
	00 00		 movsx	 eax, BYTE PTR [esi+3330]
  0047d	c1 e0 09	 shl	 eax, 9
  00480	c6 80 d2 01 00
	00 00		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+466], 0

; 7112 : 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Status_AccountID[10] = 0;

  00487	0f be 96 02 0d
	00 00		 movsx	 edx, BYTE PTR [esi+3330]
  0048e	c1 e2 09	 shl	 edx, 9

; 7113 : 
; 7114 : 						LogAdd(LOG_BLACK, "[Blood Castle] (%d) a stone statue Of Saint Terminated -> %d [%s][%s]",lpObj->MapNumber - (MAP_INDEX_BLOODCASTLE1 - 1),g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT,gObj[TopHitUser].AccountID,gObj[TopHitUser].Name);

  00491	51		 push	 ecx
  00492	c6 82 dd 01 00
	00 00		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+477], 0
  00499	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  004a0	8d 48 f5	 lea	 ecx, DWORD PTR [eax-11]
  004a3	53		 push	 ebx
  004a4	c1 e1 09	 shl	 ecx, 9
  004a7	8b 91 88 01 00
	00		 mov	 edx, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+392]
  004ad	52		 push	 edx
  004ae	83 c0 f6	 add	 eax, -10		; fffffff6H
  004b1	50		 push	 eax
  004b2	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@KMNGALHI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5stat@
  004b7	6a 00		 push	 0
  004b9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  004be	83 c4 18	 add	 esp, 24			; 00000018H

; 7115 : 					}
; 7116 : 					else

  004c1	eb 47		 jmp	 SHORT $LN49@gObjLifeCh
$LN50@gObjLifeCh:

; 7117 : 					{
; 7118 : 						g_BloodCastle.SendNoticeMessage(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1,lMsg.Get(1170));

  004c3	68 92 04 00 00	 push	 1170			; 00000492H
  004c8	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  004cd	50		 push	 eax
  004ce	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  004d5	83 e8 0b	 sub	 eax, 11			; 0000000bH
  004d8	50		 push	 eax
  004d9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  004de	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage

; 7119 : 						LogAdd(LOG_BLACK, "[Blood Castle] (%d) a stone statue Of Saint Terminated -> %d",lpObj->MapNumber - (MAP_INDEX_BLOODCASTLE1-1),g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT);

  004e3	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  004ea	8d 48 f5	 lea	 ecx, DWORD PTR [eax-11]
  004ed	c1 e1 09	 shl	 ecx, 9
  004f0	8b 91 88 01 00
	00		 mov	 edx, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+392]
  004f6	52		 push	 edx
  004f7	83 c0 f6	 add	 eax, -10		; fffffff6H
  004fa	50		 push	 eax
  004fb	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@HEKHJLCJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5stat@
  00500	6a 00		 push	 0
  00502	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00507	83 c4 10	 add	 esp, 16			; 00000010H
$LN49@gObjLifeCh:

; 7120 : 					}
; 7121 : 				}
; 7122 : 
; 7123 : 				for(int n = 0; n < MAX_BLOOD_CASTLE_SUB_BRIDGE; n++)
; 7124 : 				{
; 7125 : 					if(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex != -1)

  0050a	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  00511	c1 e1 09	 shl	 ecx, 9
  00514	8b 81 1c 00 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+28]
  0051a	83 f8 ff	 cmp	 eax, -1
  0051d	74 16		 je	 SHORT $LN47@gObjLifeCh

; 7126 : 					{
; 7127 : 						if(gObj[g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex].Connected > PLAYER_LOGGED)

  0051f	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00525	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  0052c	76 07		 jbe	 SHORT $LN47@gObjLifeCh

; 7128 : 						{
; 7129 : 							g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_bLiveWhenDoorBreak = 1;

  0052e	c6 81 2d 00 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+45], 1
$LN47@gObjLifeCh:

; 7120 : 					}
; 7121 : 				}
; 7122 : 
; 7123 : 				for(int n = 0; n < MAX_BLOOD_CASTLE_SUB_BRIDGE; n++)
; 7124 : 				{
; 7125 : 					if(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex != -1)

  00535	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  0053c	c1 e1 09	 shl	 ecx, 9
  0053f	8b 81 30 00 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+48]
  00545	83 f8 ff	 cmp	 eax, -1
  00548	74 16		 je	 SHORT $LN98@gObjLifeCh

; 7126 : 					{
; 7127 : 						if(gObj[g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex].Connected > PLAYER_LOGGED)

  0054a	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00550	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  00557	76 07		 jbe	 SHORT $LN98@gObjLifeCh

; 7128 : 						{
; 7129 : 							g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_bLiveWhenDoorBreak = 1;

  00559	c6 81 41 00 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+65], 1
$LN98@gObjLifeCh:

; 7120 : 					}
; 7121 : 				}
; 7122 : 
; 7123 : 				for(int n = 0; n < MAX_BLOOD_CASTLE_SUB_BRIDGE; n++)
; 7124 : 				{
; 7125 : 					if(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex != -1)

  00560	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  00567	c1 e1 09	 shl	 ecx, 9
  0056a	8b 81 44 00 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+68]
  00570	83 f8 ff	 cmp	 eax, -1
  00573	74 16		 je	 SHORT $LN100@gObjLifeCh

; 7126 : 					{
; 7127 : 						if(gObj[g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex].Connected > PLAYER_LOGGED)

  00575	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0057b	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  00582	76 07		 jbe	 SHORT $LN100@gObjLifeCh

; 7128 : 						{
; 7129 : 							g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_bLiveWhenDoorBreak = 1;

  00584	c6 81 55 00 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+85], 1
$LN100@gObjLifeCh:

; 7120 : 					}
; 7121 : 				}
; 7122 : 
; 7123 : 				for(int n = 0; n < MAX_BLOOD_CASTLE_SUB_BRIDGE; n++)
; 7124 : 				{
; 7125 : 					if(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex != -1)

  0058b	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  00592	c1 e1 09	 shl	 ecx, 9
  00595	8b 81 58 00 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+88]
  0059b	83 f8 ff	 cmp	 eax, -1
  0059e	74 16		 je	 SHORT $LN102@gObjLifeCh

; 7126 : 					{
; 7127 : 						if(gObj[g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex].Connected > PLAYER_LOGGED)

  005a0	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  005a6	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  005ad	76 07		 jbe	 SHORT $LN102@gObjLifeCh

; 7128 : 						{
; 7129 : 							g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_bLiveWhenDoorBreak = 1;

  005af	c6 81 69 00 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+105], 1
$LN102@gObjLifeCh:

; 7120 : 					}
; 7121 : 				}
; 7122 : 
; 7123 : 				for(int n = 0; n < MAX_BLOOD_CASTLE_SUB_BRIDGE; n++)
; 7124 : 				{
; 7125 : 					if(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex != -1)

  005b6	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  005bd	c1 e1 09	 shl	 ecx, 9
  005c0	8b 81 6c 00 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+108]
  005c6	83 f8 ff	 cmp	 eax, -1
  005c9	74 16		 je	 SHORT $LN104@gObjLifeCh

; 7126 : 					{
; 7127 : 						if(gObj[g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex].Connected > PLAYER_LOGGED)

  005cb	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  005d1	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  005d8	76 07		 jbe	 SHORT $LN104@gObjLifeCh

; 7128 : 						{
; 7129 : 							g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_bLiveWhenDoorBreak = 1;

  005da	c6 81 7d 00 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+125], 1
$LN104@gObjLifeCh:

; 7120 : 					}
; 7121 : 				}
; 7122 : 
; 7123 : 				for(int n = 0; n < MAX_BLOOD_CASTLE_SUB_BRIDGE; n++)
; 7124 : 				{
; 7125 : 					if(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex != -1)

  005e1	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  005e8	c1 e1 09	 shl	 ecx, 9
  005eb	8b 81 80 00 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+128]
  005f1	83 f8 ff	 cmp	 eax, -1
  005f4	74 16		 je	 SHORT $LN106@gObjLifeCh

; 7126 : 					{
; 7127 : 						if(gObj[g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex].Connected > PLAYER_LOGGED)

  005f6	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  005fc	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  00603	76 07		 jbe	 SHORT $LN106@gObjLifeCh

; 7128 : 						{
; 7129 : 							g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_bLiveWhenDoorBreak = 1;

  00605	c6 81 91 00 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+145], 1
$LN106@gObjLifeCh:

; 7120 : 					}
; 7121 : 				}
; 7122 : 
; 7123 : 				for(int n = 0; n < MAX_BLOOD_CASTLE_SUB_BRIDGE; n++)
; 7124 : 				{
; 7125 : 					if(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex != -1)

  0060c	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  00613	c1 e1 09	 shl	 ecx, 9
  00616	8b 81 94 00 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+148]
  0061c	83 f8 ff	 cmp	 eax, -1
  0061f	74 16		 je	 SHORT $LN108@gObjLifeCh

; 7126 : 					{
; 7127 : 						if(gObj[g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex].Connected > PLAYER_LOGGED)

  00621	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00627	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  0062e	76 07		 jbe	 SHORT $LN108@gObjLifeCh

; 7128 : 						{
; 7129 : 							g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_bLiveWhenDoorBreak = 1;

  00630	c6 81 a5 00 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+165], 1
$LN108@gObjLifeCh:

; 7120 : 					}
; 7121 : 				}
; 7122 : 
; 7123 : 				for(int n = 0; n < MAX_BLOOD_CASTLE_SUB_BRIDGE; n++)
; 7124 : 				{
; 7125 : 					if(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex != -1)

  00637	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  0063e	c1 e1 09	 shl	 ecx, 9
  00641	8b 81 a8 00 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+168]
  00647	83 f8 ff	 cmp	 eax, -1
  0064a	74 16		 je	 SHORT $LN110@gObjLifeCh

; 7126 : 					{
; 7127 : 						if(gObj[g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex].Connected > PLAYER_LOGGED)

  0064c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00652	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  00659	76 07		 jbe	 SHORT $LN110@gObjLifeCh

; 7128 : 						{
; 7129 : 							g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_bLiveWhenDoorBreak = 1;

  0065b	c6 81 b9 00 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+185], 1
$LN110@gObjLifeCh:

; 7120 : 					}
; 7121 : 				}
; 7122 : 
; 7123 : 				for(int n = 0; n < MAX_BLOOD_CASTLE_SUB_BRIDGE; n++)
; 7124 : 				{
; 7125 : 					if(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex != -1)

  00662	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  00669	c1 e1 09	 shl	 ecx, 9
  0066c	8b 81 bc 00 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+188]
  00672	83 f8 ff	 cmp	 eax, -1
  00675	74 16		 je	 SHORT $LN112@gObjLifeCh

; 7126 : 					{
; 7127 : 						if(gObj[g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex].Connected > PLAYER_LOGGED)

  00677	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0067d	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  00684	76 07		 jbe	 SHORT $LN112@gObjLifeCh

; 7128 : 						{
; 7129 : 							g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_bLiveWhenDoorBreak = 1;

  00686	c6 81 cd 00 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+205], 1
$LN112@gObjLifeCh:

; 7120 : 					}
; 7121 : 				}
; 7122 : 
; 7123 : 				for(int n = 0; n < MAX_BLOOD_CASTLE_SUB_BRIDGE; n++)
; 7124 : 				{
; 7125 : 					if(g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex != -1)

  0068d	0f be 8e 02 0d
	00 00		 movsx	 ecx, BYTE PTR [esi+3330]
  00694	c1 e1 09	 shl	 ecx, 9
  00697	8b 81 d0 00 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+208]
  0069d	83 f8 ff	 cmp	 eax, -1
  006a0	74 16		 je	 SHORT $LN114@gObjLifeCh

; 7126 : 					{
; 7127 : 						if(gObj[g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_iIndex].Connected > PLAYER_LOGGED)

  006a2	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  006a8	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  006af	76 07		 jbe	 SHORT $LN114@gObjLifeCh

; 7128 : 						{
; 7129 : 							g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[n].m_bLiveWhenDoorBreak = 1;

  006b1	c6 81 e1 00 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+225], 1
$LN114@gObjLifeCh:

; 7130 : 						}
; 7131 : 					}
; 7132 : 				}
; 7133 : 			}
; 7134 : 
; 7135 : 			if(CC_MAP_RANGE(lpTargetObj->MapNumber))

  006b8	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR [edi+265]
  006bf	3c 12		 cmp	 al, 18			; 00000012H
  006c1	0f 82 97 00 00
	00		 jb	 $LN118@gObjLifeCh
  006c7	b1 17		 mov	 cl, 23			; 00000017H
  006c9	3a c8		 cmp	 cl, al
  006cb	1b c0		 sbb	 eax, eax
  006cd	40		 inc	 eax
  006ce	0f 84 8a 00 00
	00		 je	 $LN118@gObjLifeCh

; 7136 : 			{
; 7137 : 				if(rand()%100 < 50)

  006d4	e8 00 00 00 00	 call	 _rand
  006d9	99		 cdq
  006da	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  006df	f7 f9		 idiv	 ecx
  006e1	83 fa 32	 cmp	 edx, 50			; 00000032H
  006e4	7d 22		 jge	 SHORT $LN42@gObjLifeCh

; 7138 : 				{
; 7139 : 					g_ChaosCastle.SearchNBlowObjs(lpTargetObj->MapNumber,lpTargetObj->X,lpTargetObj->Y);

  006e6	0f bf 97 06 01
	00 00		 movsx	 edx, WORD PTR [edi+262]
  006ed	0f bf 87 04 01
	00 00		 movsx	 eax, WORD PTR [edi+260]
  006f4	0f b6 8f 09 01
	00 00		 movzx	 ecx, BYTE PTR [edi+265]
  006fb	52		 push	 edx
  006fc	50		 push	 eax
  006fd	51		 push	 ecx
  006fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00703	e8 00 00 00 00	 call	 ?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z ; CChaosCastle::SearchNBlowObjs
$LN42@gObjLifeCh:

; 7140 : 				}
; 7141 : 
; 7142 : 				g_ChaosCastle.DelMonsterList(lpTargetObj->MapNumber - MAP_INDEX_CHAOSCASTLE1,lpTargetObj->m_Index);

  00708	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR [edi+265]
  0070f	8b 17		 mov	 edx, DWORD PTR [edi]
  00711	52		 push	 edx
  00712	83 e8 12	 sub	 eax, 18			; 00000012H
  00715	50		 push	 eax
  00716	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0071b	e8 00 00 00 00	 call	 ?DelMonsterList@CChaosCastle@@QAEXHH@Z ; CChaosCastle::DelMonsterList

; 7143 : 
; 7144 : 				int TopHitUser = gObjMonsterTopHitDamageUser(lpTargetObj);

  00720	57		 push	 edi
  00721	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00726	83 c4 04	 add	 esp, 4

; 7145 : 
; 7146 : 				if(TopHitUser != -1)

  00729	83 f8 ff	 cmp	 eax, -1
  0072c	74 30		 je	 SHORT $LN118@gObjLifeCh

; 7147 : 				{
; 7148 : 					if(CC_MAP_RANGE(gObj[TopHitUser].MapNumber))

  0072e	8b c8		 mov	 ecx, eax
  00730	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00736	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  0073d	80 fa 12	 cmp	 dl, 18			; 00000012H
  00740	72 1c		 jb	 SHORT $LN118@gObjLifeCh
  00742	b3 17		 mov	 bl, 23			; 00000017H
  00744	3a da		 cmp	 bl, dl
  00746	1b d2		 sbb	 edx, edx
  00748	42		 inc	 edx
  00749	74 13		 je	 SHORT $LN118@gObjLifeCh

; 7149 : 					{
; 7150 : 						if(gObjIsConnected(TopHitUser))

  0074b	50		 push	 eax
  0074c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00751	83 c4 04	 add	 esp, 4
  00754	85 c0		 test	 eax, eax
  00756	74 06		 je	 SHORT $LN118@gObjLifeCh

; 7151 : 						{
; 7152 : 							gObj[TopHitUser].m_cKillMonsterCount += 1;

  00758	fe 81 11 0d 00
	00		 inc	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3345]
$LN118@gObjLifeCh:

; 7153 : 						}
; 7154 : 					}
; 7155 : 				}
; 7156 : 			}
; 7157 : 
; 7158 : 			gObjPkDownTimeCheck(lpObj,lpTargetObj->Level);

  0075e	0f bf 8f 9c 00
	00 00		 movsx	 ecx, WORD PTR [edi+156]
  00765	51		 push	 ecx
  00766	56		 push	 esi
  00767	e8 00 00 00 00	 call	 ?gObjPkDownTimeCheck@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjPkDownTimeCheck
  0076c	83 c4 08	 add	 esp, 8

; 7159 : 
; 7160 : 			if(lpObj->Type == OBJ_USER)

  0076f	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00774	0f 85 40 01 00
	00		 jne	 $LN29@gObjLifeCh

; 7161 : 			{
; 7162 : 				gObjAddMsgSendDelay(lpObj,3,lpTargetObj->m_Index,2000,0);

  0077a	8b 17		 mov	 edx, DWORD PTR [edi]
  0077c	6a 00		 push	 0
  0077e	68 d0 07 00 00	 push	 2000			; 000007d0H
  00783	52		 push	 edx
  00784	6a 03		 push	 3
  00786	56		 push	 esi
  00787	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  0078c	83 c4 14	 add	 esp, 20			; 00000014H

; 7163 : 			}
; 7164 : 		}

  0078f	e9 26 01 00 00	 jmp	 $LN29@gObjLifeCh
$LN59@gObjLifeCh:

; 7165 : 		else if(lpTargetObj->Type == OBJ_USER)

  00794	66 3b c3	 cmp	 ax, bx
  00797	0f 85 1d 01 00
	00		 jne	 $LN29@gObjLifeCh

; 7166 : 		{
; 7167 : 			if(BC_MAP_RANGE(lpTargetObj->MapNumber))

  0079d	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR [edi+265]
  007a4	3c 0b		 cmp	 al, 11			; 0000000bH
  007a6	72 24		 jb	 SHORT $LN35@gObjLifeCh
  007a8	b1 11		 mov	 cl, 17			; 00000011H
  007aa	3a c8		 cmp	 cl, al
  007ac	1b c0		 sbb	 eax, eax
  007ae	40		 inc	 eax
  007af	74 1b		 je	 SHORT $LN35@gObjLifeCh

; 7168 : 			{
; 7169 : 				g_BloodCastle.SetUserState(lpTargetObj->m_Index,1);

  007b1	8b 17		 mov	 edx, DWORD PTR [edi]
  007b3	53		 push	 ebx
  007b4	52		 push	 edx
  007b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  007ba	e8 00 00 00 00	 call	 ?SetUserState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetUserState

; 7170 : 				g_BloodCastle.SearchUserDropQuestItem(lpTargetObj->m_Index);

  007bf	8b 07		 mov	 eax, DWORD PTR [edi]
  007c1	50		 push	 eax
  007c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  007c7	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem
$LN35@gObjLifeCh:

; 7171 : 			}
; 7172 : 
; 7173 : 			if(CC_MAP_RANGE(lpTargetObj->MapNumber))

  007cc	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR [edi+265]
  007d3	3c 12		 cmp	 al, 18			; 00000012H
  007d5	0f 82 82 00 00
	00		 jb	 $LN34@gObjLifeCh
  007db	b1 17		 mov	 cl, 23			; 00000017H
  007dd	3a c8		 cmp	 cl, al
  007df	1b c0		 sbb	 eax, eax
  007e1	40		 inc	 eax
  007e2	74 79		 je	 SHORT $LN34@gObjLifeCh

; 7174 : 			{
; 7175 : 				g_ChaosCastle.SetUserState(lpTargetObj->m_Index,1);

  007e4	8b 17		 mov	 edx, DWORD PTR [edi]
  007e6	53		 push	 ebx
  007e7	52		 push	 edx
  007e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  007ed	e8 00 00 00 00	 call	 ?SetUserState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetUserState

; 7176 : 
; 7177 : 				if(CC_MAP_RANGE(lpObj->MapNumber))

  007f2	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  007f9	3c 12		 cmp	 al, 18			; 00000012H
  007fb	72 1e		 jb	 SHORT $LN119@gObjLifeCh
  007fd	b1 17		 mov	 cl, 23			; 00000017H
  007ff	3a c8		 cmp	 cl, al
  00801	1b c0		 sbb	 eax, eax
  00803	40		 inc	 eax
  00804	74 15		 je	 SHORT $LN119@gObjLifeCh

; 7178 : 				{
; 7179 : 					if(gObjIsConnected(lpObj->m_Index))

  00806	8b 16		 mov	 edx, DWORD PTR [esi]
  00808	52		 push	 edx
  00809	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0080e	83 c4 04	 add	 esp, 4
  00811	85 c0		 test	 eax, eax
  00813	74 06		 je	 SHORT $LN119@gObjLifeCh

; 7180 : 					{
; 7181 : 						lpObj->m_cKillUserCount += 1;

  00815	fe 86 10 0d 00
	00		 inc	 BYTE PTR [esi+3344]
$LN119@gObjLifeCh:

; 7182 : 					}
; 7183 : 				}
; 7184 : 
; 7185 : 				g_ChaosCastle.SendFailMessage(lpTargetObj->MapNumber - MAP_INDEX_CHAOSCASTLE1,lpTargetObj->m_Index);

  0081b	0f b6 8f 09 01
	00 00		 movzx	 ecx, BYTE PTR [edi+265]
  00822	8b 07		 mov	 eax, DWORD PTR [edi]
  00824	83 e9 12	 sub	 ecx, 18			; 00000012H
  00827	50		 push	 eax
  00828	51		 push	 ecx
  00829	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0082e	e8 00 00 00 00	 call	 ?SendFailMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendFailMessage

; 7186 : 
; 7187 : 				LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] User Dead In Chaos Castle : Killed by [%s][%s]",lpTargetObj->MapNumber - (MAP_INDEX_CHAOSCASTLE1 - 1),lpTargetObj->AccountID,lpTargetObj->Name,lpObj->AccountID,lpObj->Name);

  00833	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  00836	52		 push	 edx
  00837	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  0083a	50		 push	 eax
  0083b	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR [edi+265]
  00842	8d 4f 6f	 lea	 ecx, DWORD PTR [edi+111]
  00845	51		 push	 ecx
  00846	8d 57 64	 lea	 edx, DWORD PTR [edi+100]
  00849	52		 push	 edx
  0084a	83 e8 11	 sub	 eax, 17			; 00000011H
  0084d	50		 push	 eax
  0084e	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@OALGHOD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@
  00853	6a 00		 push	 0
  00855	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0085a	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN34@gObjLifeCh:

; 7188 : 			}
; 7189 : 
; 7190 : 			lpTargetObj->KillerType = 0;
; 7191 : 
; 7192 : 			gObjUserDie(lpTargetObj,lpCallObj);

  0085d	8b 9d e8 fe ff
	ff		 mov	 ebx, DWORD PTR _lpCallObj$[ebp]
  00863	53		 push	 ebx
  00864	57		 push	 edi
  00865	c6 87 01 02 00
	00 00		 mov	 BYTE PTR [edi+513], 0
  0086c	e8 00 00 00 00	 call	 ?gObjUserDie@@YAXPAUOBJECTSTRUCT@@0@Z ; gObjUserDie

; 7193 : 
; 7194 : 			int iGuildWar = gObjGuildWarCheck(lpCallObj,lpTargetObj);

  00871	57		 push	 edi
  00872	53		 push	 ebx
  00873	e8 00 00 00 00	 call	 ?gObjGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjGuildWarCheck
  00878	83 c4 10	 add	 esp, 16			; 00000010H

; 7196 : 
; 7197 : 			if(iGuildWar == 0 && iDuel == 0)

  0087b	85 c0		 test	 eax, eax
  0087d	75 20		 jne	 SHORT $LN30@gObjLifeCh

; 7195 : 			int iDuel = gObjDuelCheck(lpCallObj,lpTargetObj);

  0087f	57		 push	 edi
  00880	53		 push	 ebx
  00881	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjDuelCheck
  00886	83 c4 08	 add	 esp, 8

; 7196 : 
; 7197 : 			if(iGuildWar == 0 && iDuel == 0)

  00889	85 c0		 test	 eax, eax
  0088b	75 12		 jne	 SHORT $LN30@gObjLifeCh

; 7198 : 			{
; 7199 : 				if(lpTargetObj->m_bAttackerKilled == 0)

  0088d	38 87 44 02 00
	00		 cmp	 BYTE PTR [edi+580], al
  00893	75 0a		 jne	 SHORT $LN30@gObjLifeCh

; 7200 : 				{
; 7201 : 					gObjPlayerKiller(lpCallObj,lpTargetObj);

  00895	57		 push	 edi
  00896	53		 push	 ebx
  00897	e8 00 00 00 00	 call	 ?gObjPlayerKiller@@YAXPAUOBJECTSTRUCT@@0@Z ; gObjPlayerKiller
  0089c	83 c4 08	 add	 esp, 8
$LN30@gObjLifeCh:

; 7202 : 				}
; 7203 : 			}
; 7204 : 
; 7205 : 			lpTargetObj->m_bAttackerKilled = 0;
; 7206 : 
; 7207 : 			if(lpTargetObj->m_RecallMon >= 0)

  0089f	83 bf cc 02 00
	00 00		 cmp	 DWORD PTR [edi+716], 0
  008a6	c6 87 44 02 00
	00 00		 mov	 BYTE PTR [edi+580], 0
  008ad	7c 0b		 jl	 SHORT $LN29@gObjLifeCh

; 7208 : 			{
; 7209 : 				gObjMonsterCallKill(lpTargetObj->m_Index);

  008af	8b 0f		 mov	 ecx, DWORD PTR [edi]
  008b1	51		 push	 ecx
  008b2	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  008b7	83 c4 04	 add	 esp, 4
$LN29@gObjLifeCh:

; 7210 : 			}
; 7211 : 		}
; 7212 : 
; 7213 : 		lpTargetObj->Live = 0;

  008ba	c6 47 62 00	 mov	 BYTE PTR [edi+98], 0

; 7214 : 		lpTargetObj->m_State = 4;

  008be	c7 87 bc 01 00
	00 04 00 00 00	 mov	 DWORD PTR [edi+444], 4

; 7215 : 		lpTargetObj->RegenTime = GetTickCount();

  008c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 7216 : 		lpTargetObj->DieRegen = 1;
; 7217 : 		lpTargetObj->PathCount = 0;
; 7218 : 		if(gObjTargetGuildWarCheck(lpTargetObj,lpCallObj)==1)

  008ce	8b 9d e8 fe ff
	ff		 mov	 ebx, DWORD PTR _lpCallObj$[ebp]
  008d4	53		 push	 ebx
  008d5	57		 push	 edi
  008d6	89 87 08 02 00
	00		 mov	 DWORD PTR [edi+520], eax
  008dc	c6 87 02 02 00
	00 01		 mov	 BYTE PTR [edi+514], 1
  008e3	c7 87 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+296], 0
  008ed	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  008f2	83 c4 08	 add	 esp, 8
  008f5	83 f8 01	 cmp	 eax, 1
  008f8	75 07		 jne	 SHORT $LN28@gObjLifeCh

; 7219 : 		{
; 7220 : 			lpTargetObj->KillerType = 2;

  008fa	c6 87 01 02 00
	00 02		 mov	 BYTE PTR [edi+513], 2
$LN28@gObjLifeCh:

; 7221 : 		}
; 7222 : 
; 7223 : 		if(gObjDuelCheck(lpCallObj,lpTargetObj))

  00901	57		 push	 edi
  00902	53		 push	 ebx
  00903	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjDuelCheck
  00908	83 c4 08	 add	 esp, 8
  0090b	85 c0		 test	 eax, eax
  0090d	0f 84 cd 01 00
	00		 je	 $LN26@gObjLifeCh

; 7224 : 		{
; 7225 : 			lpTargetObj->KillerType = 3;

  00913	c6 87 01 02 00
	00 03		 mov	 BYTE PTR [edi+513], 3

; 7226 : 			if(lpObj->m_btDuelScore >= 10)

  0091a	80 be 20 0d 00
	00 0a		 cmp	 BYTE PTR [esi+3360], 10	; 0000000aH
  00921	0f 82 b9 01 00
	00		 jb	 $LN26@gObjLifeCh

; 7227 : 			{
; 7228 : 				PMSG_ANS_END_DUEL pMsg;
; 7229 : 				pMsg.h.c = 193;
; 7230 : 				pMsg.h.headcode = 171;
; 7231 : 				pMsg.h.size = 15;
; 7232 : 				pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  00927	8b 16		 mov	 edx, DWORD PTR [esi]

; 7233 : 				pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 7234 : 
; 7235 : 				memcpy(pMsg.szName,lpObj->Name,10);

  00929	8b 4e 6f	 mov	 ecx, DWORD PTR [esi+111]
  0092c	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0092f	c1 ea 08	 shr	 edx, 8
  00932	8d 5e 6f	 lea	 ebx, DWORD PTR [esi+111]
  00935	88 95 ef fe ff
	ff		 mov	 BYTE PTR _pMsg$164124[ebp+3], dl
  0093b	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0093e	89 8d f1 fe ff
	ff		 mov	 DWORD PTR _pMsg$164124[ebp+5], ecx

; 7236 : 
; 7237 : 				DataSend(lpTargetObj->m_Index,(unsigned char *)&pMsg,pMsg.h.size);

  00944	6a 0f		 push	 15			; 0000000fH
  00946	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$164124[ebp]
  0094c	89 95 f5 fe ff
	ff		 mov	 DWORD PTR _pMsg$164124[ebp+9], edx
  00952	8b 17		 mov	 edx, DWORD PTR [edi]
  00954	88 85 f0 fe ff
	ff		 mov	 BYTE PTR _pMsg$164124[ebp+4], al
  0095a	66 8b 43 08	 mov	 ax, WORD PTR [ebx+8]
  0095e	51		 push	 ecx
  0095f	52		 push	 edx
  00960	c6 85 ec fe ff
	ff c1		 mov	 BYTE PTR _pMsg$164124[ebp], 193 ; 000000c1H
  00967	66 c7 85 ed fe
	ff ff 0f ab	 mov	 WORD PTR _pMsg$164124[ebp+1], 43791 ; 0000ab0fH
  00970	66 89 85 f9 fe
	ff ff		 mov	 WORD PTR _pMsg$164124[ebp+13], ax
  00977	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 7238 : 
; 7239 : 				lpTargetObj->m_iDuelUser = -1;
; 7240 : 
; 7241 : 				pMsg.NumberH = SET_NUMBERH(lpTargetObj->m_Index);

  0097c	8b 07		 mov	 eax, DWORD PTR [edi]

; 7242 : 				pMsg.NumberL = SET_NUMBERL(lpTargetObj->m_Index);
; 7243 : 
; 7244 : 				memcpy(pMsg.szName,lpTargetObj->Name,10);

  0097e	8b 57 6f	 mov	 edx, DWORD PTR [edi+111]
  00981	8a 0f		 mov	 cl, BYTE PTR [edi]
  00983	c1 e8 08	 shr	 eax, 8
  00986	88 85 ef fe ff
	ff		 mov	 BYTE PTR _pMsg$164124[ebp+3], al
  0098c	8b 47 73	 mov	 eax, DWORD PTR [edi+115]
  0098f	89 95 f1 fe ff
	ff		 mov	 DWORD PTR _pMsg$164124[ebp+5], edx

; 7245 : 
; 7246 : 				DataSend(lpObj->m_Index,(unsigned char *)&pMsg,pMsg.h.size);

  00995	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pMsg$164124[ebp+1]
  0099c	88 8d f0 fe ff
	ff		 mov	 BYTE PTR _pMsg$164124[ebp+4], cl
  009a2	66 8b 4f 77	 mov	 cx, WORD PTR [edi+119]
  009a6	89 85 f5 fe ff
	ff		 mov	 DWORD PTR _pMsg$164124[ebp+9], eax
  009ac	52		 push	 edx
  009ad	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$164124[ebp]
  009b3	c7 87 1c 0d 00
	00 ff ff ff ff	 mov	 DWORD PTR [edi+3356], -1
  009bd	66 89 8d f9 fe
	ff ff		 mov	 WORD PTR _pMsg$164124[ebp+13], cx
  009c4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  009c6	50		 push	 eax
  009c7	51		 push	 ecx
  009c8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 7247 : 
; 7248 : 				lpObj->m_iDuelUser = -1;
; 7249 : 
; 7250 : 				gDarkSpirit[lpObj->m_Index].ReSetTarget(lpTargetObj->m_Index);

  009cd	8b 06		 mov	 eax, DWORD PTR [esi]
  009cf	c7 86 1c 0d 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+3356], -1
  009d9	8b 17		 mov	 edx, DWORD PTR [edi]
  009db	83 c4 18	 add	 esp, 24			; 00000018H
  009de	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  009e1	52		 push	 edx
  009e2	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gDarkSpirit@@3PAVCDarkSpirit@@A[ecx*8]
  009e9	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget

; 7251 : 				gDarkSpirit[lpTargetObj->m_Index].ReSetTarget(lpObj->m_Index);

  009ee	8b 06		 mov	 eax, DWORD PTR [esi]
  009f0	50		 push	 eax
  009f1	8b 07		 mov	 eax, DWORD PTR [edi]
  009f3	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  009f6	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gDarkSpirit@@3PAVCDarkSpirit@@A[ecx*8]
  009fd	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget

; 7252 : 
; 7253 : 				char szMsg[256];
; 7254 : 
; 7255 : 				wsprintf(szMsg,lMsg.Get(1216),lpTargetObj->Name);

  00a02	8d 47 6f	 lea	 eax, DWORD PTR [edi+111]
  00a05	50		 push	 eax
  00a06	68 c0 04 00 00	 push	 1216			; 000004c0H
  00a0b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00a10	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00a15	50		 push	 eax
  00a16	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szMsg$164137[ebp]
  00a1c	51		 push	 ecx
  00a1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 7256 : 
; 7257 : 				GCServerMsgStringSend(szMsg,lpObj->m_Index,1);

  00a23	8b 16		 mov	 edx, DWORD PTR [esi]
  00a25	6a 01		 push	 1
  00a27	52		 push	 edx
  00a28	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$164137[ebp]
  00a2e	50		 push	 eax
  00a2f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00a34	83 c4 18	 add	 esp, 24			; 00000018H

; 7258 : 
; 7259 : 				wsprintf(szMsg,lMsg.Get(1217),lpObj->Name);

  00a37	53		 push	 ebx
  00a38	68 c1 04 00 00	 push	 1217			; 000004c1H
  00a3d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00a42	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00a47	50		 push	 eax
  00a48	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szMsg$164137[ebp]
  00a4e	51		 push	 ecx
  00a4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 7260 : 
; 7261 : 				GCServerMsgStringSend(szMsg,lpTargetObj->m_Index,1);

  00a55	8b 17		 mov	 edx, DWORD PTR [edi]
  00a57	6a 01		 push	 1
  00a59	52		 push	 edx
  00a5a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$164137[ebp]
  00a60	50		 push	 eax
  00a61	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 7262 : 
; 7263 : 				PMSG_SERVERCMD ServerCmd;
; 7264 : 
; 7265 : 				PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  00a66	6a 07		 push	 7
  00a68	6a 40		 push	 64			; 00000040H
  00a6a	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _ServerCmd$164138[ebp]
  00a70	68 f3 00 00 00	 push	 243			; 000000f3H
  00a75	51		 push	 ecx
  00a76	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 7266 : 				ServerCmd.CmdType = 0;
; 7267 : 				ServerCmd.X = lpObj->X;
; 7268 : 				ServerCmd.Y = lpObj->Y;

  00a7b	0f b6 86 06 01
	00 00		 movzx	 eax, BYTE PTR [esi+262]
  00a82	8a 96 04 01 00
	00		 mov	 dl, BYTE PTR [esi+260]

; 7269 : 
; 7270 : 				MsgSendV2(lpObj,(unsigned char *)&ServerCmd,sizeof(ServerCmd));

  00a88	6a 07		 push	 7
  00a8a	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _ServerCmd$164138[ebp]
  00a90	51		 push	 ecx
  00a91	56		 push	 esi
  00a92	c6 85 e4 fe ff
	ff 00		 mov	 BYTE PTR _ServerCmd$164138[ebp+4], 0
  00a99	88 95 e5 fe ff
	ff		 mov	 BYTE PTR _ServerCmd$164138[ebp+5], dl
  00a9f	88 85 e6 fe ff
	ff		 mov	 BYTE PTR _ServerCmd$164138[ebp+6], al
  00aa5	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 7271 : 				DataSend(lpObj->m_Index,(unsigned char *)&ServerCmd,sizeof(ServerCmd));

  00aaa	8b 06		 mov	 eax, DWORD PTR [esi]
  00aac	6a 07		 push	 7
  00aae	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _ServerCmd$164138[ebp]
  00ab4	52		 push	 edx
  00ab5	50		 push	 eax
  00ab6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00abb	83 c4 40	 add	 esp, 64			; 00000040H

; 7272 : 
; 7273 : 				LogAdd(LOG_BLACK, "[Duel] [%s][%s] Win Duel, Loser [%s][%s]",lpObj->AccountID,lpObj->Name,lpTargetObj->AccountID,lpTargetObj->Name);

  00abe	8d 47 6f	 lea	 eax, DWORD PTR [edi+111]
  00ac1	50		 push	 eax
  00ac2	8d 4f 64	 lea	 ecx, DWORD PTR [edi+100]
  00ac5	51		 push	 ecx
  00ac6	53		 push	 ebx
  00ac7	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  00aca	52		 push	 edx
  00acb	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@KJGJCOOM@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Loser?5@
  00ad0	6a 00		 push	 0
  00ad2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00ad7	8b 9d e8 fe ff
	ff		 mov	 ebx, DWORD PTR _lpCallObj$[ebp]
  00add	83 c4 18	 add	 esp, 24			; 00000018H
$LN26@gObjLifeCh:

; 7274 : 			}
; 7275 : 		}
; 7276 : 
; 7277 : 		if(lpTargetObj->Teleport == 1)

  00ae0	80 bf 00 02 00
	00 01		 cmp	 BYTE PTR [edi+512], 1
  00ae7	75 07		 jne	 SHORT $LN25@gObjLifeCh

; 7278 : 		{
; 7279 : 			lpTargetObj->Teleport = 0;

  00ae9	c6 87 00 02 00
	00 00		 mov	 BYTE PTR [edi+512], 0
$LN25@gObjLifeCh:

; 7280 : 		}
; 7281 : 
; 7282 : 		GCDiePlayerSend(lpTargetObj,lpTargetObj->m_Index,Skill,lpObj->m_Index);

  00af0	8b 06		 mov	 eax, DWORD PTR [esi]
  00af2	8b 4d 20	 mov	 ecx, DWORD PTR _Skill$[ebp]
  00af5	8b 17		 mov	 edx, DWORD PTR [edi]
  00af7	50		 push	 eax
  00af8	51		 push	 ecx
  00af9	52		 push	 edx
  00afa	57		 push	 edi
  00afb	e8 00 00 00 00	 call	 ?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z ; GCDiePlayerSend
  00b00	83 c4 10	 add	 esp, 16			; 00000010H

; 7283 : 
; 7284 : 		if(lpTargetObj->Class == 79)

  00b03	66 83 bf 98 00
	00 00 4f	 cmp	 WORD PTR [edi+152], 79	; 0000004fH
  00b0b	75 24		 jne	 SHORT $LN24@gObjLifeCh

; 7285 : 		{
; 7286 : 			gEledoradoEvent.m_BossGoldDerconMapNumber[lpTargetObj->m_BossGoldDerconMapNumber] = -1;

  00b0d	0f be 87 20 0f
	00 00		 movsx	 eax, BYTE PTR [edi+3872]
  00b14	c7 04 85 44 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ?gEledoradoEvent@@3VCEledoradoEvent@@A[eax*4+68], -1

; 7287 : 			gEledoradoEvent.CheckGoldDercon(lpObj->MapNumber);

  00b1f	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00b26	51		 push	 ecx
  00b27	b9 00 00 00 00	 mov	 ecx, OFFSET ?gEledoradoEvent@@3VCEledoradoEvent@@A ; gEledoradoEvent
  00b2c	e8 00 00 00 00	 call	 ?CheckGoldDercon@CEledoradoEvent@@QAEXH@Z ; CEledoradoEvent::CheckGoldDercon
$LN24@gObjLifeCh:

; 7288 : 		}
; 7289 : 
; 7290 : 		if(lpTargetObj->m_RecallMon >= 0)

  00b31	83 bf cc 02 00
	00 00		 cmp	 DWORD PTR [edi+716], 0
  00b38	0f 8d b7 01 00
	00		 jge	 $LN123@gObjLifeCh

; 7291 : 		{
; 7292 : 			return;
; 7293 : 		}
; 7294 : 
; 7295 : 		if(lpTargetObj->Class == 340 || lpTargetObj->Class == 348 || lpTargetObj->Class == 349)

  00b3e	0f b7 87 98 00
	00 00		 movzx	 eax, WORD PTR [edi+152]
  00b45	ba 54 01 00 00	 mov	 edx, 340		; 00000154H
  00b4a	66 3b c2	 cmp	 ax, dx
  00b4d	0f 84 a2 01 00
	00		 je	 $LN123@gObjLifeCh
  00b53	b9 5c 01 00 00	 mov	 ecx, 348		; 0000015cH
  00b58	66 3b c1	 cmp	 ax, cx
  00b5b	0f 84 94 01 00
	00		 je	 $LN123@gObjLifeCh
  00b61	ba 5d 01 00 00	 mov	 edx, 349		; 0000015dH
  00b66	66 3b c2	 cmp	 ax, dx
  00b69	0f 84 86 01 00
	00		 je	 $LN123@gObjLifeCh

; 7296 : 		{
; 7297 : 			return;
; 7298 : 		}
; 7299 : 
; 7300 : 		if(lpTargetObj->Class == 287 || lpTargetObj->Class == 286)

  00b6f	b9 1f 01 00 00	 mov	 ecx, 287		; 0000011fH
  00b74	66 3b c1	 cmp	 ax, cx
  00b77	0f 84 78 01 00
	00		 je	 $LN123@gObjLifeCh
  00b7d	ba 1e 01 00 00	 mov	 edx, 286		; 0000011eH
  00b82	66 3b c2	 cmp	 ax, dx
  00b85	0f 84 6a 01 00
	00		 je	 $LN123@gObjLifeCh

; 7301 : 		{
; 7302 : 			return;
; 7303 : 		}
; 7304 : 
; 7305 : 		if(lpTargetObj->Class == 275)

  00b8b	b9 13 01 00 00	 mov	 ecx, 275		; 00000113H
  00b90	66 3b c1	 cmp	 ax, cx
  00b93	0f 84 5c 01 00
	00		 je	 $LN123@gObjLifeCh

; 7306 : 		{
; 7307 : 			return;
; 7308 : 		}
; 7309 : 		
; 7310 : 		if(lpTargetObj->Class == 288)

  00b99	ba 20 01 00 00	 mov	 edx, 288		; 00000120H
  00b9e	66 3b c2	 cmp	 ax, dx
  00ba1	0f 84 4e 01 00
	00		 je	 $LN123@gObjLifeCh

; 7311 : 		{
; 7312 : 			return;
; 7313 : 		}
; 7314 : 
; 7315 : 		if(lpTargetObj->Class == 295)

  00ba7	b9 27 01 00 00	 mov	 ecx, 295		; 00000127H
  00bac	66 3b c1	 cmp	 ax, cx
  00baf	0f 84 40 01 00
	00		 je	 $LN123@gObjLifeCh

; 7316 : 		{
; 7317 : 			return;
; 7318 : 		}
; 7319 : 
; 7320 : #if (GS_CASTLE == 0)
; 7321 : 		if(lpTargetObj->Class == 362 || lpTargetObj->Class == 363 || lpTargetObj->Class == 361)

  00bb5	ba 6a 01 00 00	 mov	 edx, 362		; 0000016aH
  00bba	66 3b c2	 cmp	 ax, dx
  00bbd	0f 84 32 01 00
	00		 je	 $LN123@gObjLifeCh
  00bc3	b9 6b 01 00 00	 mov	 ecx, 363		; 0000016bH
  00bc8	66 3b c1	 cmp	 ax, cx
  00bcb	0f 84 24 01 00
	00		 je	 $LN123@gObjLifeCh
  00bd1	ba 69 01 00 00	 mov	 edx, 361		; 00000169H
  00bd6	66 3b c2	 cmp	 ax, dx
  00bd9	0f 84 16 01 00
	00		 je	 $LN123@gObjLifeCh

; 7322 : 		{
; 7323 : 			return;
; 7324 : 		}
; 7325 : #endif
; 7326 : 
; 7327 : 		if(lpCallObj->Type == OBJ_USER)

  00bdf	66 83 7b 60 01	 cmp	 WORD PTR [ebx+96], 1
  00be4	75 67		 jne	 SHORT $LN121@gObjLifeCh

; 7328 : 		{
; 7329 : 			if(lpCallObj->PartyNumber >= 0)

  00be6	83 bb a8 02 00
	00 00		 cmp	 DWORD PTR [ebx+680], 0
  00bed	8b 75 18	 mov	 esi, DWORD PTR _MSBFlag$[ebp]
  00bf0	7c 0e		 jl	 SHORT $LN12@gObjLifeCh

; 7330 : 			{
; 7331 : 				gObjExpParty(lpCallObj,lpTargetObj,AttackDamage,MSBFlag);

  00bf2	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00bf5	56		 push	 esi
  00bf6	50		 push	 eax
  00bf7	57		 push	 edi
  00bf8	53		 push	 ebx
  00bf9	e8 00 00 00 00	 call	 ?gObjExpParty@@YAXPAUOBJECTSTRUCT@@0HH@Z ; gObjExpParty
  00bfe	eb 17		 jmp	 SHORT $LN125@gObjLifeCh
$LN12@gObjLifeCh:

; 7332 : 			}
; 7333 : 			else if(lpTargetObj->Type == OBJ_MONSTER)

  00c00	66 83 7f 60 02	 cmp	 WORD PTR [edi+96], 2
  00c05	0f 85 ea 00 00
	00		 jne	 $LN123@gObjLifeCh

; 7334 : 			{
; 7335 : 				gObjMonsterExpDivision(lpTargetObj,lpCallObj,AttackDamage,MSBFlag);

  00c0b	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  00c0e	56		 push	 esi
  00c0f	51		 push	 ecx
  00c10	53		 push	 ebx
  00c11	57		 push	 edi
  00c12	e8 00 00 00 00	 call	 ?gObjMonsterExpDivision@@YAXPAUOBJECTSTRUCT@@0HH@Z ; gObjMonsterExpDivision
$LN125@gObjLifeCh:
  00c17	83 c4 10	 add	 esp, 16			; 00000010H

; 7336 : 			}
; 7337 : 
; 7338 : 			if(lpTargetObj->Type == OBJ_MONSTER && DS_MAP_RANGE(lpTargetObj->MapNumber))

  00c1a	66 83 7f 60 02	 cmp	 WORD PTR [edi+96], 2
  00c1f	0f 85 d0 00 00
	00		 jne	 $LN123@gObjLifeCh
  00c25	8a 87 09 01 00
	00		 mov	 al, BYTE PTR [edi+265]
  00c2b	3c 09		 cmp	 al, 9
  00c2d	74 0d		 je	 SHORT $LN117@gObjLifeCh
  00c2f	33 d2		 xor	 edx, edx
  00c31	3c 20		 cmp	 al, 32			; 00000020H
  00c33	0f 94 c2	 sete	 dl
  00c36	8b c2		 mov	 eax, edx
  00c38	85 c0		 test	 eax, eax
  00c3a	74 11		 je	 SHORT $LN121@gObjLifeCh
$LN117@gObjLifeCh:

; 7339 : 			{
; 7340 : 				g_DevilSquare.gObjMonsterScoreDivision(lpTargetObj,lpCallObj,AttackDamage,MSBFlag);

  00c3c	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00c3f	56		 push	 esi
  00c40	50		 push	 eax
  00c41	53		 push	 ebx
  00c42	57		 push	 edi
  00c43	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  00c48	e8 00 00 00 00	 call	 ?gObjMonsterScoreDivision@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@0HH@Z ; CDevilSquare::gObjMonsterScoreDivision
$LN121@gObjLifeCh:

; 7341 : 			}
; 7342 : 		}
; 7343 : 		if(lpTargetObj->Type == OBJ_MONSTER)

  00c4d	66 83 7f 60 02	 cmp	 WORD PTR [edi+96], 2
  00c52	0f 85 9d 00 00
	00		 jne	 $LN123@gObjLifeCh

; 7344 : 		{
; 7345 : 			if(lpTargetObj->m_bIsInMonsterHerd != 0 && lpTargetObj->m_lpMonsterHerd != 0)

  00c58	83 bf 24 0f 00
	00 00		 cmp	 DWORD PTR [edi+3876], 0
  00c5f	0f 84 90 00 00
	00		 je	 $LN123@gObjLifeCh
  00c65	8b 8f 2c 0f 00
	00		 mov	 ecx, DWORD PTR [edi+3884]
  00c6b	85 c9		 test	 ecx, ecx
  00c6d	0f 84 82 00 00
	00		 je	 $LN123@gObjLifeCh

; 7346 : 			{
; 7347 : 				lpTargetObj->m_lpMonsterHerd->MonsterDieAction(lpTargetObj);

  00c73	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c75	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00c78	57		 push	 edi
  00c79	ff d0		 call	 eax
  00c7b	5b		 pop	 ebx
  00c7c	5f		 pop	 edi
  00c7d	5e		 pop	 esi

; 7364 : 		}
; 7365 : 	}
; 7366 : }

  00c7e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c81	33 cd		 xor	 ecx, ebp
  00c83	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c88	8b e5		 mov	 esp, ebp
  00c8a	5d		 pop	 ebp
  00c8b	c3		 ret	 0
$LN63@gObjLifeCh:

; 7348 : 			}
; 7349 : 		}
; 7350 : 	}
; 7351 : 	else
; 7352 : 	{
; 7353 : 		if(DamageSendType == 0)

  00c8c	8b 45 14	 mov	 eax, DWORD PTR _DamageSendType$[ebp]
  00c8f	85 c0		 test	 eax, eax
  00c91	75 1a		 jne	 SHORT $LN5@gObjLifeCh

; 7354 : 		{
; 7355 : 			GCDamageSend(lpCallObj->m_Index,lpTargetObj->m_Index,AttackDamage,MSBFlag,MSBDamage);

  00c93	8b 4d 1c	 mov	 ecx, DWORD PTR _MSBDamage$[ebp]
  00c96	8b 55 18	 mov	 edx, DWORD PTR _MSBFlag$[ebp]
  00c99	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00c9c	51		 push	 ecx
  00c9d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00c9f	52		 push	 edx
  00ca0	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _lpCallObj$[ebp]
  00ca6	50		 push	 eax
  00ca7	8b 02		 mov	 eax, DWORD PTR [edx]
  00ca9	51		 push	 ecx
  00caa	50		 push	 eax
  00cab	eb 40		 jmp	 SHORT $LN128@gObjLifeCh
$LN5@gObjLifeCh:

; 7356 : 		}
; 7357 : 		else if(DamageSendType == 1)

  00cad	83 f8 01	 cmp	 eax, 1
  00cb0	75 20		 jne	 SHORT $LN3@gObjLifeCh

; 7358 : 		{
; 7359 : 			GCDamageSend(lpTargetObj->m_Index,AttackDamage);

  00cb2	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  00cb5	8b 17		 mov	 edx, DWORD PTR [edi]
  00cb7	51		 push	 ecx
  00cb8	52		 push	 edx
  00cb9	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHH@Z	; GCDamageSend
  00cbe	83 c4 08	 add	 esp, 8
  00cc1	5b		 pop	 ebx
  00cc2	5f		 pop	 edi
  00cc3	5e		 pop	 esi

; 7364 : 		}
; 7365 : 	}
; 7366 : }

  00cc4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cc7	33 cd		 xor	 ecx, ebp
  00cc9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00cce	8b e5		 mov	 esp, ebp
  00cd0	5d		 pop	 ebp
  00cd1	c3		 ret	 0
$LN3@gObjLifeCh:

; 7360 : 		}
; 7361 : 		else if(DamageSendType == 2)

  00cd2	83 f8 02	 cmp	 eax, 2
  00cd5	75 1e		 jne	 SHORT $LN123@gObjLifeCh

; 7362 : 		{
; 7363 : 			GCDamageSend(lpCallObj->m_Index,lpTargetObj->m_Index,AttackDamage,MSBFlag,5);

  00cd7	8b 45 18	 mov	 eax, DWORD PTR _MSBFlag$[ebp]
  00cda	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  00cdd	8b 17		 mov	 edx, DWORD PTR [edi]
  00cdf	6a 05		 push	 5
  00ce1	50		 push	 eax
  00ce2	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  00ce8	51		 push	 ecx
  00ce9	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ceb	52		 push	 edx
  00cec	51		 push	 ecx
$LN128@gObjLifeCh:
  00ced	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  00cf2	83 c4 14	 add	 esp, 20			; 00000014H
$LN123@gObjLifeCh:
  00cf5	5b		 pop	 ebx
$LN67@gObjLifeCh:

; 7364 : 		}
; 7365 : 	}
; 7366 : }

  00cf6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cf9	5f		 pop	 edi
  00cfa	33 cd		 xor	 ecx, ebp
  00cfc	5e		 pop	 esi
  00cfd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d02	8b e5		 mov	 esp, ebp
  00d04	5d		 pop	 ebp
  00d05	c3		 ret	 0
?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHE@Z ENDP	; gObjLifeCheck
_TEXT	ENDS
PUBLIC	?gObjSkillBeAttackProc@@YAXPAUOBJECTSTRUCT@@@Z	; gObjSkillBeAttackProc
; Function compile flags: /Ogtp
;	COMDAT ?gObjSkillBeAttackProc@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv280 = 8						; size = 4
_ad$ = 8						; size = 4
_lpObj$ = 8						; size = 4
?gObjSkillBeAttackProc@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjSkillBeAttackProc, COMDAT

; 14306: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 14307: 	int ad = 0;
; 14308: 
; 14309: 	if(lpObj->m_PoisonBeattackCount > 0)

  00005	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00008	8a 86 27 02 00
	00		 mov	 al, BYTE PTR [esi+551]
  0000e	33 db		 xor	 ebx, ebx
  00010	3a c3		 cmp	 al, bl
  00012	0f 8e f8 00 00
	00		 jle	 $LN23@gObjSkillB

; 14310: 	{
; 14311: 		lpObj->m_PoisonBeattackCount--;

  00018	fe c8		 dec	 al
  0001a	88 86 27 02 00
	00		 mov	 BYTE PTR [esi+551], al

; 14312: 
; 14313: 		if(lpObj->m_PoisonBeattackCount % 3 == 0)

  00020	0f be c0	 movsx	 eax, al
  00023	99		 cdq
  00024	b9 03 00 00 00	 mov	 ecx, 3
  00029	f7 f9		 idiv	 ecx
  0002b	85 d2		 test	 edx, edx
  0002d	0f 85 a7 01 00
	00		 jne	 $LN1@gObjSkillB

; 14314: 		{
; 14315: 			if(lpObj->Life > 0.0f)

  00033	d9 ee		 fldz
  00035	d8 96 bc 00 00
	00		 fcom	 DWORD PTR [esi+188]
  0003b	df e0		 fnstsw	 ax
  0003d	f6 c4 05	 test	 ah, 5
  00040	7a 59		 jp	 SHORT $LN21@gObjSkillB

; 14316: 			{
; 14317: 				if(lpObj->m_PoisonType == 38)
; 14318: 				{
; 14319: 					ad = lpObj->Life * 3 / 100;

  00042	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  00048	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4008000000000000
  0004e	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  00054	e8 00 00 00 00	 call	 __ftol2_sse
  00059	80 be 25 02 00
	00 26		 cmp	 BYTE PTR [esi+549], 38	; 00000026H
  00060	8b c8		 mov	 ecx, eax
  00062	75 32		 jne	 SHORT $LN20@gObjSkillB
  00064	89 4d 08	 mov	 DWORD PTR _ad$[ebp], ecx
$LN18@gObjSkillB:

; 14329: 			}
; 14330: 
; 14331: 			if(ad < 0)

  00067	3b cb		 cmp	 ecx, ebx
  00069	7d 05		 jge	 SHORT $LN26@gObjSkillB

; 14332: 			{
; 14333: 				ad = 0;

  0006b	33 c9		 xor	 ecx, ecx
$LN41@gObjSkillB:
  0006d	89 4d 08	 mov	 DWORD PTR _ad$[ebp], ecx
$LN26@gObjSkillB:

; 14334: 			}
; 14335: 
; 14336: 			lpObj->Life -= ad;

  00070	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  00076	da 65 08	 fisub	 DWORD PTR _ad$[ebp]
  00079	d9 5d 08	 fstp	 DWORD PTR tv280[ebp]
  0007c	d9 45 08	 fld	 DWORD PTR tv280[ebp]
  0007f	d9 96 bc 00 00
	00		 fst	 DWORD PTR [esi+188]

; 14337: 
; 14338: 			if(lpObj->Life < 0)

  00085	d8 d9		 fcomp	 ST(1)
  00087	df e0		 fnstsw	 ax
  00089	f6 c4 05	 test	 ah, 5
  0008c	7a 14		 jp	 SHORT $LN39@gObjSkillB

; 14339: 			{
; 14340: 				lpObj->Life = 0;

  0008e	d9 9e bc 00 00
	00		 fstp	 DWORD PTR [esi+188]
  00094	eb 0e		 jmp	 SHORT $LN16@gObjSkillB
$LN20@gObjSkillB:

; 14320: 				}
; 14321: 				else
; 14322: 				{
; 14323: 					ad = lpObj->Life * 3 / 100;

  00096	89 45 08	 mov	 DWORD PTR _ad$[ebp], eax

; 14324: 				}
; 14325: 			}
; 14326: 			else

  00099	eb cc		 jmp	 SHORT $LN18@gObjSkillB
$LN21@gObjSkillB:

; 14327: 			{
; 14328: 				ad = 1;

  0009b	b9 01 00 00 00	 mov	 ecx, 1

; 14329: 			}
; 14330: 
; 14331: 			if(ad < 0)

  000a0	eb cb		 jmp	 SHORT $LN41@gObjSkillB
$LN39@gObjSkillB:

; 14339: 			{
; 14340: 				lpObj->Life = 0;

  000a2	dd d8		 fstp	 ST(0)
$LN16@gObjSkillB:

; 14341: 			}
; 14342: 
; 14343: 			if(lpObj->lpAttackObj != 0)

  000a4	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  000aa	3b c3		 cmp	 eax, ebx
  000ac	74 11		 je	 SHORT $LN27@gObjSkillB

; 14344: 			{
; 14345: 				gObjLifeCheck(lpObj,lpObj->lpAttackObj,ad,2,0,0,1);

  000ae	6a 01		 push	 1
  000b0	53		 push	 ebx
  000b1	53		 push	 ebx
  000b2	6a 02		 push	 2
  000b4	51		 push	 ecx
  000b5	50		 push	 eax
  000b6	56		 push	 esi
  000b7	e8 00 00 00 00	 call	 ?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHE@Z ; gObjLifeCheck
  000bc	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN27@gObjSkillB:

; 14346: 			}
; 14347: 
; 14348: 			if(lpObj->m_PoisonBeattackCount <= 0)

  000bf	38 9e 27 02 00
	00		 cmp	 BYTE PTR [esi+551], bl
  000c5	0f 8f 0f 01 00
	00		 jg	 $LN1@gObjSkillB

; 14349: 			{
; 14350: 				lpObj->lpAttackObj = 0;
; 14351: 				lpObj->m_ViewSkillState &= ~1;

  000cb	83 a6 c4 01 00
	00 fe		 and	 DWORD PTR [esi+452], -2	; fffffffeH

; 14352: 				lpObj->m_ViewState = 0;
; 14353: 
; 14354: 				if(lpObj->m_PoisonType == 38)

  000d2	80 be 25 02 00
	00 26		 cmp	 BYTE PTR [esi+549], 38	; 00000026H
  000d9	89 9e 38 02 00
	00		 mov	 DWORD PTR [esi+568], ebx
  000df	88 9e c2 01 00
	00		 mov	 BYTE PTR [esi+450], bl

; 14355: 				{
; 14356: 					GCStateInfoSend(lpObj,0,1);

  000e5	6a 01		 push	 1
  000e7	75 14		 jne	 SHORT $LN13@gObjSkillB
  000e9	53		 push	 ebx
  000ea	56		 push	 esi
  000eb	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14361: 				}
; 14362: 
; 14363: 				lpObj->m_PoisonType = 0;

  000f3	88 9e 25 02 00
	00		 mov	 BYTE PTR [esi+549], bl
  000f9	5e		 pop	 esi
  000fa	5b		 pop	 ebx

; 14410: 		}
; 14411: 	}
; 14412: }

  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
$LN13@gObjSkillB:

; 14357: 				}
; 14358: 				else
; 14359: 				{
; 14360: 					GCMagicCancelSend(lpObj,1);

  000fd	56		 push	 esi
  000fe	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  00103	83 c4 08	 add	 esp, 8

; 14361: 				}
; 14362: 
; 14363: 				lpObj->m_PoisonType = 0;

  00106	88 9e 25 02 00
	00		 mov	 BYTE PTR [esi+549], bl
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx

; 14410: 		}
; 14411: 	}
; 14412: }

  0010e	5d		 pop	 ebp
  0010f	c3		 ret	 0
$LN23@gObjSkillB:

; 14364: 			}
; 14365: 		}
; 14366: 	}
; 14367: 	else if(lpObj->m_ColdBeattackCount > 0)

  00110	8a 86 28 02 00
	00		 mov	 al, BYTE PTR [esi+552]
  00116	3a c3		 cmp	 al, bl
  00118	7e 63		 jle	 SHORT $LN10@gObjSkillB

; 14368: 	{
; 14369: 		lpObj->m_ColdBeattackCount--;

  0011a	fe c8		 dec	 al
  0011c	88 86 28 02 00
	00		 mov	 BYTE PTR [esi+552], al

; 14370: 
; 14371: 		if(lpObj->m_ColdBeattackCount <= 0)

  00122	3a c3		 cmp	 al, bl
  00124	0f 8f b0 00 00
	00		 jg	 $LN1@gObjSkillB

; 14372: 		{
; 14373: 			lpObj->lpAttackObj = 0;
; 14374: 			lpObj->DelayActionTime = 0;
; 14375: 			lpObj->DelayLevel = 0;
; 14376: 
; 14377: 			lpObj->m_ViewSkillState &= ~2;

  0012a	83 a6 c4 01 00
	00 fd		 and	 DWORD PTR [esi+452], -3	; fffffffdH

; 14378: 			lpObj->m_ViewState = 0;
; 14379: 
; 14380: 			if(lpObj->m_IceType == 39)

  00131	80 be 26 02 00
	00 27		 cmp	 BYTE PTR [esi+550], 39	; 00000027H
  00138	89 9e 38 02 00
	00		 mov	 DWORD PTR [esi+568], ebx
  0013e	89 9e 20 02 00
	00		 mov	 DWORD PTR [esi+544], ebx
  00144	88 9e 24 02 00
	00		 mov	 BYTE PTR [esi+548], bl
  0014a	88 9e c2 01 00
	00		 mov	 BYTE PTR [esi+450], bl
  00150	75 16		 jne	 SHORT $LN8@gObjSkillB

; 14381: 			{
; 14382: 				GCStateInfoSend(lpObj,0,2);

  00152	6a 02		 push	 2
  00154	53		 push	 ebx
  00155	56		 push	 esi
  00156	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14387: 			}
; 14388: 
; 14389: 			lpObj->m_IceType = 0;

  0015e	88 9e 26 02 00
	00		 mov	 BYTE PTR [esi+550], bl
  00164	5e		 pop	 esi
  00165	5b		 pop	 ebx

; 14410: 		}
; 14411: 	}
; 14412: }

  00166	5d		 pop	 ebp
  00167	c3		 ret	 0
$LN8@gObjSkillB:

; 14383: 			}
; 14384: 			else
; 14385: 			{
; 14386: 				GCMagicCancelSend(lpObj,7);

  00168	6a 07		 push	 7
  0016a	56		 push	 esi
  0016b	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  00170	83 c4 08	 add	 esp, 8

; 14387: 			}
; 14388: 
; 14389: 			lpObj->m_IceType = 0;

  00173	88 9e 26 02 00
	00		 mov	 BYTE PTR [esi+550], bl
  00179	5e		 pop	 esi
  0017a	5b		 pop	 ebx

; 14410: 		}
; 14411: 	}
; 14412: }

  0017b	5d		 pop	 ebp
  0017c	c3		 ret	 0
$LN10@gObjSkillB:

; 14390: 		}
; 14391: 	}
; 14392: 	else if(lpObj->m_ImmuneToMagicCount > 0)

  0017d	8a 86 29 02 00
	00		 mov	 al, BYTE PTR [esi+553]
  00183	3a c3		 cmp	 al, bl
  00185	7e 2a		 jle	 SHORT $LN5@gObjSkillB

; 14393: 	{
; 14394: 		lpObj->m_ImmuneToMagicCount--;

  00187	fe c8		 dec	 al
  00189	88 86 29 02 00
	00		 mov	 BYTE PTR [esi+553], al

; 14395: 
; 14396: 		if(lpObj->m_ImmuneToMagicCount <= 0)

  0018f	3a c3		 cmp	 al, bl
  00191	7f 47		 jg	 SHORT $LN1@gObjSkillB

; 14397: 		{
; 14398: 			lpObj->m_ViewSkillState &= ~0x80;

  00193	81 a6 c4 01 00
	00 7f ff ff ff	 and	 DWORD PTR [esi+452], -129 ; ffffff7fH

; 14399: 			GCStateInfoSend(lpObj,1,0x80);

  0019d	68 80 00 00 00	 push	 128			; 00000080H
  001a2	6a 01		 push	 1

; 14409: 			GCStateInfoSend(lpObj,0,8);

  001a4	56		 push	 esi
  001a5	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  001aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ad	5e		 pop	 esi
  001ae	5b		 pop	 ebx

; 14410: 		}
; 14411: 	}
; 14412: }

  001af	5d		 pop	 ebp
  001b0	c3		 ret	 0
$LN5@gObjSkillB:

; 14400: 		}
; 14401: 	}
; 14402: 	else if(lpObj->m_ImmuneToHarmCount > 0)

  001b1	8a 86 2a 02 00
	00		 mov	 al, BYTE PTR [esi+554]
  001b7	3a c3		 cmp	 al, bl
  001b9	7e 1f		 jle	 SHORT $LN1@gObjSkillB

; 14403: 	{
; 14404: 		lpObj->m_ImmuneToHarmCount--;

  001bb	fe c8		 dec	 al
  001bd	88 86 2a 02 00
	00		 mov	 BYTE PTR [esi+554], al

; 14405: 
; 14406: 		if(lpObj->m_ImmuneToHarmCount <= 0)

  001c3	3a c3		 cmp	 al, bl
  001c5	7f 13		 jg	 SHORT $LN1@gObjSkillB

; 14407: 		{
; 14408: 			lpObj->m_ViewSkillState &= ~8;

  001c7	83 a6 c4 01 00
	00 f7		 and	 DWORD PTR [esi+452], -9	; fffffff7H

; 14409: 			GCStateInfoSend(lpObj,0,8);

  001ce	6a 08		 push	 8
  001d0	53		 push	 ebx
  001d1	56		 push	 esi
  001d2	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  001d7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjSkillB:
  001da	5e		 pop	 esi
  001db	5b		 pop	 ebx

; 14410: 		}
; 14411: 	}
; 14412: }

  001dc	5d		 pop	 ebp
  001dd	c3		 ret	 0
?gObjSkillBeAttackProc@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjSkillBeAttackProc
_TEXT	ENDS
PUBLIC	??_C@_0EI@IELJOCDM@?$FLMoveMap?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5?3?5?$CIBefore?3Map?3@ ; `string'
PUBLIC	??_C@_0FH@OIJJJHHH@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5Va@ ; `string'
PUBLIC	??_C@_0CP@FPPAACN@?$FLPSHOP?5ITEM?5CLONNING?$FN?5Move?5Faile@ ; `string'
PUBLIC	??_C@_0EG@IKFPGELB@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Used?5@ ; `string'
PUBLIC	??_C@_0P@EEJEJBPC@Regen?5OK?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjMoveGate@@YAHHH@Z				; gObjMoveGate
EXTRN	?CheckGateLevel@CGate@@QAEHHH@Z:PROC		; CGate::CheckGateLevel
EXTRN	?DeleteKalimaGate@CKalimaGate@@QAEHH@Z:PROC	; CKalimaGate::DeleteKalimaGate
EXTRN	?g_KalimaGate@@3VCKalimaGate@@A:BYTE		; g_KalimaGate
EXTRN	?IsGate@CGate@@QAEHH@Z:PROC			; CGate::IsGate
;	COMDAT ??_C@_0EI@IELJOCDM@?$FLMoveMap?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5?3?5?$CIBefore?3Map?3@
CONST	SEGMENT
??_C@_0EI@IELJOCDM@?$FLMoveMap?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5?3?5?$CIBefore?3Map?3@ DB '['
	DB	'MoveMap][%s][%s] : (Before:Map:%d X:%d Y:%d) -> (New Map:%d X'
	DB	':%d Y:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@OIJJJHHH@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5Va@
CONST	SEGMENT
??_C@_0FH@OIJJJHHH@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5Va@ DB '['
	DB	'Kalima] [%s][%s] Kalima Gate Vanished - User MoveGate (Summon'
	DB	'Index:%d, EnterCount:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FPPAACN@?$FLPSHOP?5ITEM?5CLONNING?$FN?5Move?5Faile@
CONST	SEGMENT
??_C@_0CP@FPPAACN@?$FLPSHOP?5ITEM?5CLONNING?$FN?5Move?5Faile@ DB '[PSHOP '
	DB	'ITEM CLONNING] Move Failed : %d (%s %s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@IKFPGELB@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Used?5@
CONST	SEGMENT
??_C@_0EG@IKFPGELB@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Used?5@ DB '['
	DB	'DevilSquare] [%s][%s] Not Used DevilSquare Invitation In Devi'
	DB	'lSquare', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EEJEJBPC@Regen?5OK?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0P@EEJEJBPC@Regen?5OK?5?$CFs?5?$CFd?$AA@ DB 'Regen OK %s %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjMoveGate@@YAHHH@Z
_TEXT	SEGMENT
_userlevel$ = -292					; size = 4
_aIndex$GSCopy$ = -288					; size = 4
_level$ = -284						; size = 2
_sSvrCode$166893 = -280					; size = 2
_movefail$ = -280					; size = 4
_x$ = -276						; size = 2
_y$ = -272						; size = 2
_mapNumber$ = -265					; size = 1
_dir$ = -261						; size = 1
_szTemp$166880 = -260					; size = 256
_szMsg$166829 = -260					; size = 255
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_gt$ = 12						; size = 4
?gObjMoveGate@@YAHHH@Z PROC				; gObjMoveGate, COMDAT

; 14445: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi

; 14446: 	LPOBJ lpObj = &gObj[aIndex];

  00019	8b fb		 mov	 edi, ebx
  0001b	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H

; 14447: 	int result;
; 14448: 	short x,y;
; 14449: 	BYTE mapNumber = 0,dir;
; 14450: 	short level;
; 14451: 	int userlevel = gObj[aIndex].Level;
; 14452: 	int movefail = 0;
; 14453: 
; 14454: 	if(gObj[aIndex].SkillRecallParty_Time != 0)

  00021	66 83 bf b0 10
	00 00 00	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+4272], 0
  00029	0f bf 87 9c 00
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+156]
  00030	89 9d e0 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  00036	8d b7 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  0003c	c6 85 f7 fe ff
	ff 00		 mov	 BYTE PTR _mapNumber$[ebp], 0
  00043	89 85 dc fe ff
	ff		 mov	 DWORD PTR _userlevel$[ebp], eax
  00049	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _movefail$[ebp], 0
  00053	74 38		 je	 SHORT $LN54@gObjMoveGa

; 14455: 	{
; 14456: 		char szMsg[255];
; 14457: 		gObj[aIndex].SkillRecallParty_Time = 0;

  00055	33 c9		 xor	 ecx, ecx
  00057	66 89 8f b0 10
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+4272], cx

; 14458: 		wsprintf(szMsg,lMsg.Get(1254));

  0005e	68 e6 04 00 00	 push	 1254			; 000004e6H
  00063	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00068	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0006d	50		 push	 eax
  0006e	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szMsg$166829[ebp]
  00074	52		 push	 edx
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 14459: 		GCServerMsgStringSend(szMsg,aIndex,1);

  0007b	6a 01		 push	 1
  0007d	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$166829[ebp]
  00083	53		 push	 ebx
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0008a	83 c4 14	 add	 esp, 20			; 00000014H
$LN54@gObjMoveGa:

; 14460: 	}
; 14461: 
; 14462: 	if(lpObj->Type == OBJ_USER)

  0008d	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00092	75 15		 jne	 SHORT $LN53@gObjMoveGa

; 14463: 	{
; 14464: 		gDarkSpirit[lpObj->m_Index].SetMode(CDarkSpirit::ePetItem_Mode::PetItem_Mode_Normal,-1);

  00094	8b 06		 mov	 eax, DWORD PTR [esi]
  00096	6a ff		 push	 -1
  00098	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0009b	6a 00		 push	 0
  0009d	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gDarkSpirit@@3PAVCDarkSpirit@@A[ecx*8]
  000a4	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode
$LN53@gObjMoveGa:

; 14465: 	}
; 14466: 
; 14467: 	if(BC_MAP_RANGE(lpObj->MapNumber))

  000a9	8a 8e 09 01 00
	00		 mov	 cl, BYTE PTR [esi+265]
  000af	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  000b2	72 3b		 jb	 SHORT $LN50@gObjMoveGa
  000b4	b2 11		 mov	 dl, 17			; 00000011H
  000b6	3a d1		 cmp	 dl, cl
  000b8	1b c0		 sbb	 eax, eax
  000ba	40		 inc	 eax
  000bb	74 32		 je	 SHORT $LN50@gObjMoveGa

; 14468: 	{
; 14469: 		if(g_BloodCastle.GetCurrentState(lpObj->MapNumber-11) == BC_STATE_PLAYING)

  000bd	0f b6 c1	 movzx	 eax, cl
  000c0	83 e8 0b	 sub	 eax, 11			; 0000000bH
  000c3	50		 push	 eax
  000c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  000c9	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  000ce	83 f8 02	 cmp	 eax, 2
  000d1	75 0f		 jne	 SHORT $LN51@gObjMoveGa

; 14470: 		{
; 14471: 			g_BloodCastle.SearchUserDropQuestItem(lpObj->m_Index);

  000d3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000d5	51		 push	 ecx
  000d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  000db	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem

; 14472: 		}
; 14473: 		else

  000e0	eb 0d		 jmp	 SHORT $LN50@gObjMoveGa
$LN51@gObjMoveGa:

; 14474: 		{
; 14475: 			g_BloodCastle.SearchUserDeleteQuestItem(lpObj->m_Index);

  000e2	8b 16		 mov	 edx, DWORD PTR [esi]
  000e4	52		 push	 edx
  000e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  000ea	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN50@gObjMoveGa:

; 14476: 		}
; 14477: 	}
; 14478: 
; 14479: 	if(gObj[aIndex].RegenOk != 0)

  000ef	80 bf 03 02 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+515], 0
  000f6	0f 84 b8 00 00
	00		 je	 $LN49@gObjMoveGa

; 14480: 	{
; 14481: 		LogAdd(LOG_BLACK, "Regen OK %s %d",__FILE__,__LINE__);

  000fc	68 91 38 00 00	 push	 14481			; 00003891H
  00101	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEJEJBPC@Regen?5OK?5?$CFs?5?$CFd?$AA@
  0010b	6a 00		 push	 0
  0010d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 14482: 		x = lpObj->X;

  00112	0f b7 8e 04 01
	00 00		 movzx	 ecx, WORD PTR [esi+260]

; 14483: 		y = lpObj->Y;

  00119	0f b7 96 06 01
	00 00		 movzx	 edx, WORD PTR [esi+262]

; 14484: 		mapNumber = lpObj->MapNumber;

  00120	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]

; 14485: 		dir = lpObj->Dir;

  00126	8a 9e 08 01 00
	00		 mov	 bl, BYTE PTR [esi+264]

; 14486: 		movefail = 1;
; 14487: 
; 14488: 		lpObj->RegenMapNumber = lpObj->MapNumber;
; 14489: 		lpObj->RegenMapX = x;
; 14490: 		lpObj->RegenMapY = y;
; 14491: 
; 14492: 		gObjClearViewport(&gObj[aIndex]);

  0012c	56		 push	 esi
  0012d	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  00133	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _y$[ebp], edx
  00139	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _mapNumber$[ebp], al
  0013f	88 9d fb fe ff
	ff		 mov	 BYTE PTR _dir$[ebp], bl
  00145	88 86 04 02 00
	00		 mov	 BYTE PTR [esi+516], al
  0014b	88 8e 05 02 00
	00		 mov	 BYTE PTR [esi+517], cl
  00151	88 96 06 02 00
	00		 mov	 BYTE PTR [esi+518], dl
  00157	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport

; 14493: 
; 14494: 		GCTeleportSend(&gObj[aIndex],gt,mapNumber,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);

  0015c	0f b6 87 08 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+264]
  00163	0f b6 8f 06 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  0016a	0f b6 97 04 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  00171	50		 push	 eax
  00172	8b 85 f7 fe ff
	ff		 mov	 eax, DWORD PTR _mapNumber$[ebp]
  00178	51		 push	 ecx
  00179	8b 4d 0c	 mov	 ecx, DWORD PTR _gt$[ebp]
  0017c	52		 push	 edx
  0017d	50		 push	 eax
  0017e	51		 push	 ecx
  0017f	56		 push	 esi
  00180	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend
  00185	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN92@gObjMoveGa:

; 14495: 
; 14496: 		if(lpObj->m_Change >= 0)

  00188	83 be d0 02 00
	00 00		 cmp	 DWORD PTR [esi+720], 0
  0018f	7c 09		 jl	 SHORT $LN48@gObjMoveGa

; 14497: 		{
; 14498: 			gObjViewportListProtocolCreate(&gObj[aIndex]);

  00191	56		 push	 esi
  00192	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00197	83 c4 04	 add	 esp, 4
$LN48@gObjMoveGa:

; 14499: 		}
; 14500: 
; 14501: 		gObj[aIndex].RegenOk = 1;

  0019a	c6 87 03 02 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+515], 1
  001a1	5f		 pop	 edi
  001a2	5e		 pop	 esi

; 14502: 
; 14503: 		return false;

  001a3	33 c0		 xor	 eax, eax
  001a5	5b		 pop	 ebx

; 14974: 	}
; 14975: 
; 14976: 	return true;
; 14977: }

  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a9	33 cd		 xor	 ecx, ebp
  001ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	c3		 ret	 0
$LN49@gObjMoveGa:

; 14504: 	}
; 14505: 
; 14506: 
; 14507: 	if(gGateC.IsGate(gt) == false)

  001b4	8b 5d 0c	 mov	 ebx, DWORD PTR _gt$[ebp]
  001b7	53		 push	 ebx
  001b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  001bd	e8 00 00 00 00	 call	 ?IsGate@CGate@@QAEHH@Z	; CGate::IsGate
  001c2	85 c0		 test	 eax, eax
  001c4	0f 85 a1 00 00
	00		 jne	 $LN47@gObjMoveGa

; 14508: 	{
; 14509: 
; 14510: 		LogAdd(LOG_BLACK, lMsg.Get(545),gt,__FILE__,__LINE__);

  001ca	68 ae 38 00 00	 push	 14510			; 000038aeH
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  001d4	53		 push	 ebx
  001d5	68 21 02 00 00	 push	 545			; 00000221H
  001da	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001df	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001e4	50		 push	 eax
  001e5	6a 00		 push	 0
  001e7	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 14511: 
; 14512: 		x = lpObj->X;
; 14513: 		y = lpObj->Y;

  001ec	0f b7 96 06 01
	00 00		 movzx	 edx, WORD PTR [esi+262]

; 14514: 		mapNumber = lpObj->MapNumber;

  001f3	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  001f9	0f b7 8e 04 01
	00 00		 movzx	 ecx, WORD PTR [esi+260]
  00200	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _y$[ebp], edx

; 14515: 		dir = lpObj->Dir;

  00206	8a 96 08 01 00
	00		 mov	 dl, BYTE PTR [esi+264]
  0020c	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _mapNumber$[ebp], al

; 14516: 		movefail = 1;
; 14517: 
; 14518: 		lpObj->RegenMapNumber = lpObj->MapNumber;

  00212	88 86 04 02 00
	00		 mov	 BYTE PTR [esi+516], al

; 14519: 		lpObj->RegenMapX = x;
; 14520: 		lpObj->RegenMapY = y;

  00218	0f b6 85 f0 fe
	ff ff		 movzx	 eax, BYTE PTR _y$[ebp]

; 14521: 
; 14522: 		gObjClearViewport(&gObj[aIndex]);

  0021f	56		 push	 esi
  00220	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  00226	88 95 fb fe ff
	ff		 mov	 BYTE PTR _dir$[ebp], dl
  0022c	88 8e 05 02 00
	00		 mov	 BYTE PTR [esi+517], cl
  00232	88 86 06 02 00
	00		 mov	 BYTE PTR [esi+518], al
  00238	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport

; 14523: 
; 14524: 		GCTeleportSend(&gObj[aIndex],gt,mapNumber,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);

  0023d	0f b6 8f 08 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+264]
  00244	0f b6 97 06 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  0024b	0f b6 87 04 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  00252	51		 push	 ecx
  00253	8b 8d f7 fe ff
	ff		 mov	 ecx, DWORD PTR _mapNumber$[ebp]
  00259	52		 push	 edx
  0025a	50		 push	 eax
  0025b	51		 push	 ecx
  0025c	53		 push	 ebx
  0025d	56		 push	 esi
  0025e	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend
  00263	83 c4 30	 add	 esp, 48			; 00000030H

; 14525: 
; 14526: 		if(lpObj->m_Change >= 0)
; 14527: 		{
; 14528: 			gObjViewportListProtocolCreate(&gObj[aIndex]);
; 14529: 		}
; 14530: 
; 14531: 		gObj[aIndex].RegenOk = 1;
; 14532: 
; 14533: 		return false;

  00266	e9 1d ff ff ff	 jmp	 $LN92@gObjMoveGa
$LN47@gObjMoveGa:

; 14534: 	}
; 14535: 
; 14536: 	if(gt >= 58 && gt <= 61)

  0026b	8d 53 c6	 lea	 edx, DWORD PTR [ebx-58]
  0026e	83 fa 03	 cmp	 edx, 3
  00271	77 40		 ja	 SHORT $LN43@gObjMoveGa

; 14537: 	{
; 14538: 		if(gObj[aIndex].m_bDevilSquareAuth == 0)

  00273	80 bf 01 0d 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3329], 0
  0027a	75 30		 jne	 SHORT $LN44@gObjMoveGa

; 14539: 		{
; 14540: 			LogAdd(LOG_BLACK, "[DevilSquare] [%s][%s] Not Used DevilSquare Invitation In DevilSquare",gObj[aIndex].AccountID,gObj[aIndex].Name);

  0027c	8d 87 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+111]
  00282	50		 push	 eax
  00283	8d 8f 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+100]
  00289	51		 push	 ecx
  0028a	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@IKFPGELB@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Used?5@
  0028f	6a 00		 push	 0
  00291	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00296	83 c4 10	 add	 esp, 16			; 00000010H
  00299	5f		 pop	 edi
  0029a	5e		 pop	 esi
  0029b	33 c0		 xor	 eax, eax
  0029d	5b		 pop	 ebx

; 14974: 	}
; 14975: 
; 14976: 	return true;
; 14977: }

  0029e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a1	33 cd		 xor	 ecx, ebp
  002a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a8	8b e5		 mov	 esp, ebp
  002aa	5d		 pop	 ebp
  002ab	c3		 ret	 0
$LN44@gObjMoveGa:

; 14541: 			return false;
; 14542: 		}
; 14543: 		else
; 14544: 		{
; 14545: 			gObj[aIndex].m_bDevilSquareAuth = 0;

  002ac	c6 87 01 0d 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3329], 0
$LN43@gObjMoveGa:

; 14546: 		}
; 14547: 	}
; 14548: 
; 14549: 	lpObj->m_MoveGateNumber = gt;
; 14550: 
; 14551: 	result = gGateC.GetGate(gt,(short &)x,(short &)y,(BYTE &)mapNumber,(BYTE &)dir,(short &)level);

  002b3	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _level$[ebp]
  002b9	52		 push	 edx
  002ba	8d 85 fb fe ff
	ff		 lea	 eax, DWORD PTR _dir$[ebp]
  002c0	50		 push	 eax
  002c1	8d 8d f7 fe ff
	ff		 lea	 ecx, DWORD PTR _mapNumber$[ebp]
  002c7	51		 push	 ecx
  002c8	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _y$[ebp]
  002ce	52		 push	 edx
  002cf	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _x$[ebp]
  002d5	50		 push	 eax
  002d6	53		 push	 ebx
  002d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  002dc	88 9e a0 01 00
	00		 mov	 BYTE PTR [esi+416], bl
  002e2	e8 00 00 00 00	 call	 ?GetGate@CGate@@QAEHHAAF0AAE10@Z ; CGate::GetGate
  002e7	8b d8		 mov	 ebx, eax

; 14552: 
; 14553: 	if(result < 0)

  002e9	85 db		 test	 ebx, ebx
  002eb	79 58		 jns	 SHORT $LN79@gObjMoveGa

; 14554: 	{
; 14555: 		LogAdd(LOG_BLACK, "error : %d (%s %d)",result,__FILE__,__LINE__);

  002ed	68 db 38 00 00	 push	 14555			; 000038dbH
  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  002f7	53		 push	 ebx
  002f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DHOELAFE@error?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ?$AA@
  002fd	6a 00		 push	 0
  002ff	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 14556: 
; 14557: 		x = lpObj->X;

  00304	0f b7 8e 04 01
	00 00		 movzx	 ecx, WORD PTR [esi+260]

; 14558: 		y = lpObj->Y;

  0030b	0f b7 96 06 01
	00 00		 movzx	 edx, WORD PTR [esi+262]

; 14559: 		mapNumber = lpObj->MapNumber;

  00312	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00318	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx

; 14560: 		dir = lpObj->Dir;

  0031e	8a 8e 08 01 00
	00		 mov	 cl, BYTE PTR [esi+264]
  00324	83 c4 14	 add	 esp, 20			; 00000014H
  00327	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _y$[ebp], edx
  0032d	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _mapNumber$[ebp], al
  00333	88 8d fb fe ff
	ff		 mov	 BYTE PTR _dir$[ebp], cl

; 14561: 
; 14562: 		movefail = 1;

  00339	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _movefail$[ebp], 1
  00343	eb 06		 jmp	 SHORT $LN42@gObjMoveGa
$LN79@gObjMoveGa:
  00345	8a 85 f7 fe ff
	ff		 mov	 al, BYTE PTR _mapNumber$[ebp]
$LN42@gObjMoveGa:

; 14563: 	}
; 14564: 
; 14565: 	if(lpObj->m_bPShopOpen == 1)

  0034b	80 be 28 0d 00
	00 01		 cmp	 BYTE PTR [esi+3368], 1
  00352	0f 85 b6 00 00
	00		 jne	 $LN84@gObjMoveGa

; 14566: 	{
; 14567: 		int bMove = 1;
; 14568: 
; 14569: 		if(lpObj->MapNumber == MAP_INDEX_CASTLESIEGE && mapNumber == MAP_INDEX_LORENCIA)

  00358	8a 8e 09 01 00
	00		 mov	 cl, BYTE PTR [esi+265]
  0035e	ba 01 00 00 00	 mov	 edx, 1
  00363	80 f9 1e	 cmp	 cl, 30			; 0000001eH
  00366	75 06		 jne	 SHORT $LN83@gObjMoveGa
  00368	84 c0		 test	 al, al
  0036a	75 02		 jne	 SHORT $LN83@gObjMoveGa

; 14570: 		{
; 14571: 			bMove = 0;

  0036c	33 d2		 xor	 edx, edx
$LN83@gObjMoveGa:

; 14572: 		}
; 14573: 
; 14574: 		if(lpObj->MapNumber == MAP_INDEX_LORENCIA && mapNumber == MAP_INDEX_CASTLESIEGE)

  0036e	84 c9		 test	 cl, cl
  00370	75 04		 jne	 SHORT $LN39@gObjMoveGa
  00372	3c 1e		 cmp	 al, 30			; 0000001eH

; 14575: 		{
; 14576: 			bMove = 0;
; 14577: 		}
; 14578: 
; 14579: 		if(bMove == 0)

  00374	74 08		 je	 SHORT $LN73@gObjMoveGa
$LN39@gObjMoveGa:
  00376	85 d2		 test	 edx, edx
  00378	0f 85 90 00 00
	00		 jne	 $LN84@gObjMoveGa
$LN73@gObjMoveGa:

; 14580: 		{
; 14581: 			LogAdd(LOG_BLACK, "[PSHOP ITEM CLONNING] Move Failed : %d (%s %s)",result,lpObj->AccountID,lpObj->Name);

  0037e	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  00381	52		 push	 edx
  00382	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  00385	50		 push	 eax
  00386	53		 push	 ebx
  00387	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FPPAACN@?$FLPSHOP?5ITEM?5CLONNING?$FN?5Move?5Faile@
  0038c	6a 00		 push	 0
  0038e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 14582: 
; 14583: 			x = lpObj->X;

  00393	0f b7 8e 04 01
	00 00		 movzx	 ecx, WORD PTR [esi+260]

; 14584: 			y = lpObj->Y;

  0039a	0f b7 96 06 01
	00 00		 movzx	 edx, WORD PTR [esi+262]

; 14585: 			mapNumber = lpObj->MapNumber;

  003a1	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]

; 14586: 			dir = lpObj->Dir;

  003a7	8a 9e 08 01 00
	00		 mov	 bl, BYTE PTR [esi+264]

; 14587: 			movefail = 1;
; 14588: 
; 14589: 			lpObj->RegenMapX = x;
; 14590: 			lpObj->RegenMapY = y;
; 14591: 
; 14592: 			lpObj->RegenMapNumber = mapNumber;
; 14593: 			lpObj->RegenMapNumber = lpObj->MapNumber;
; 14594: 
; 14595: 			lpObj->RegenMapX = x;
; 14596: 			lpObj->RegenMapY = y;
; 14597: 	
; 14598: 			gObjClearViewport(&gObj[aIndex]);

  003ad	56		 push	 esi
  003ae	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  003b4	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _y$[ebp], edx
  003ba	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _mapNumber$[ebp], al
  003c0	88 9d fb fe ff
	ff		 mov	 BYTE PTR _dir$[ebp], bl
  003c6	88 86 04 02 00
	00		 mov	 BYTE PTR [esi+516], al
  003cc	88 8e 05 02 00
	00		 mov	 BYTE PTR [esi+517], cl
  003d2	88 96 06 02 00
	00		 mov	 BYTE PTR [esi+518], dl
  003d8	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport

; 14599: 	
; 14600: 			GCTeleportSend(&gObj[aIndex],gt,mapNumber,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);

  003dd	0f b6 8f 08 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+264]
  003e4	0f b6 97 06 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  003eb	0f b6 87 04 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  003f2	51		 push	 ecx
  003f3	8b 8d f7 fe ff
	ff		 mov	 ecx, DWORD PTR _mapNumber$[ebp]
  003f9	52		 push	 edx
  003fa	8b 55 0c	 mov	 edx, DWORD PTR _gt$[ebp]
  003fd	50		 push	 eax
  003fe	51		 push	 ecx
  003ff	52		 push	 edx
  00400	56		 push	 esi
  00401	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend
  00406	83 c4 30	 add	 esp, 48			; 00000030H

; 14601: 	
; 14602: 			if(lpObj->m_Change >= 0)
; 14603: 			{
; 14604: 				gObjViewportListProtocolCreate(&gObj[aIndex]);
; 14605: 			}
; 14606: 	
; 14607: 			gObj[aIndex].RegenOk = 1;
; 14608: 			return false;

  00409	e9 7a fd ff ff	 jmp	 $LN92@gObjMoveGa
$LN84@gObjMoveGa:

; 14609: 		}
; 14610: 	}
; 14611: 
; 14612: 	if(BC_MAP_RANGE(mapNumber)
; 14613: 		|| CC_MAP_RANGE(mapNumber)
; 14614: 		|| DS_MAP_RANGE(mapNumber))

  0040e	3c 0b		 cmp	 al, 11			; 0000000bH
  00410	72 0c		 jb	 SHORT $LN74@gObjMoveGa
  00412	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00417	3a c8		 cmp	 cl, al
  00419	1b c9		 sbb	 ecx, ecx
  0041b	41		 inc	 ecx
  0041c	75 1c		 jne	 SHORT $LN89@gObjMoveGa
$LN74@gObjMoveGa:
  0041e	3c 12		 cmp	 al, 18			; 00000012H
  00420	72 09		 jb	 SHORT $LN75@gObjMoveGa
  00422	b2 17		 mov	 dl, 23			; 00000017H
  00424	3a d0		 cmp	 dl, al
  00426	1b c9		 sbb	 ecx, ecx
  00428	41		 inc	 ecx
  00429	75 0f		 jne	 SHORT $LN89@gObjMoveGa
$LN75@gObjMoveGa:
  0042b	3c 09		 cmp	 al, 9
  0042d	74 0b		 je	 SHORT $LN89@gObjMoveGa
  0042f	33 c9		 xor	 ecx, ecx
  00431	3c 20		 cmp	 al, 32			; 00000020H
  00433	0f 94 c1	 sete	 cl
  00436	85 c9		 test	 ecx, ecx
  00438	74 3c		 je	 SHORT $LN34@gObjMoveGa
$LN89@gObjMoveGa:

; 14615: 	{
; 14616: 		if(lpObj->m_iSkillNPCHelpTime > 0)

  0043a	83 be 24 15 00
	00 00		 cmp	 DWORD PTR [esi+5412], 0
  00441	7e 33		 jle	 SHORT $LN34@gObjMoveGa

; 14617: 		{
; 14618: 			lpObj->m_iSkillNPCHelpTime = 0;
; 14619: 			lpObj->m_iSkillNPCDefense = 0;
; 14620: 			lpObj->m_iSkillNPCAttack = 0;
; 14621: 
; 14622: 			lpObj->m_ViewSkillState &= ~0x2000000;

  00443	81 a6 c4 01 00
	00 ff ff ff fd	 and	 DWORD PTR [esi+452], -33554433 ; fdffffffH
  0044d	33 c0		 xor	 eax, eax

; 14623: 			GCStateInfoSend(lpObj,0,0x2000000);

  0044f	68 00 00 00 02	 push	 33554432		; 02000000H
  00454	50		 push	 eax
  00455	56		 push	 esi
  00456	89 86 24 15 00
	00		 mov	 DWORD PTR [esi+5412], eax
  0045c	89 86 28 15 00
	00		 mov	 DWORD PTR [esi+5416], eax
  00462	89 86 2c 15 00
	00		 mov	 DWORD PTR [esi+5420], eax
  00468	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  0046d	8a 85 f7 fe ff
	ff		 mov	 al, BYTE PTR _mapNumber$[ebp]
  00473	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@gObjMoveGa:

; 14624: 		}
; 14625: 	}
; 14626: 
; 14627: #if GS_CASTLE == 1
; 14628: 	if ( result == 97 )
; 14629: 	{
; 14630: 		if ( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 14631: 		{
; 14632: 			if ( lpObj->m_btCsJoinSide != 1 && g_CastleSiege.GetCastleTowerAccessable() == FALSE )
; 14633: 			{
; 14634: 				GCServerMsgStringSend(lMsg.Get(MSGGET(6,88)), lpObj->m_Index, 1);
; 14635: 
; 14636: 				x = lpObj->X;
; 14637: 				y = lpObj->Y;
; 14638: 				mapNumber = lpObj->MapNumber;
; 14639: 				dir = lpObj->Dir;
; 14640: 				movefail = 1;
; 14641: 
; 14642: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 14643: 				lpObj->RegenMapX = x;
; 14644: 				lpObj->RegenMapY = y;
; 14645: 		
; 14646: 				gObjClearViewport(&gObj[aIndex]);
; 14647: 		
; 14648: 				GCTeleportSend(&gObj[aIndex],gt,mapNumber,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);
; 14649: 		
; 14650: 				if(lpObj->m_Change >= 0)
; 14651: 				{
; 14652: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 14653: 				}
; 14654: 		
; 14655: 				gObj[aIndex].RegenOk = 1;
; 14656: 				return false;
; 14657: 			}
; 14658: 
; 14659: 			if ( lpObj->m_btCsJoinSide == 0 )
; 14660: 			{
; 14661: 				GCServerMsgStringSend(lMsg.Get(MSGGET(6,89)), lpObj->m_Index, 1);
; 14662: 
; 14663: 				x = lpObj->X;
; 14664: 				y = lpObj->Y;
; 14665: 				mapNumber = lpObj->MapNumber;
; 14666: 				dir = lpObj->Dir;
; 14667: 				movefail = 1;
; 14668: 
; 14669: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 14670: 				lpObj->RegenMapX = x;
; 14671: 				lpObj->RegenMapY = y;
; 14672: 		
; 14673: 				gObjClearViewport(&gObj[aIndex]);
; 14674: 		
; 14675: 				GCTeleportSend(&gObj[aIndex],gt,mapNumber,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);
; 14676: 		
; 14677: 				if(lpObj->m_Change >= 0)
; 14678: 				{
; 14679: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 14680: 				}
; 14681: 		
; 14682: 				gObj[aIndex].RegenOk = 1;
; 14683: 				return false;
; 14684: 			}
; 14685: 		}
; 14686: 		else if ( g_CastleSiege.CheckCastleOwnerUnionMember(lpObj->m_Index) == FALSE )
; 14687: 		{
; 14688: 			GCServerMsgStringSend(lMsg.Get(MSGGET(6,90)), lpObj->m_Index, 1);
; 14689: 
; 14690: 			x = lpObj->X;
; 14691: 			y = lpObj->Y;
; 14692: 			mapNumber = lpObj->MapNumber;
; 14693: 			dir = lpObj->Dir;
; 14694: 			movefail = 1;
; 14695: 
; 14696: 			lpObj->RegenMapNumber = lpObj->MapNumber;
; 14697: 			lpObj->RegenMapX = x;
; 14698: 			lpObj->RegenMapY = y;
; 14699: 	
; 14700: 			gObjClearViewport(&gObj[aIndex]);
; 14701: 	
; 14702: 			GCTeleportSend(&gObj[aIndex],gt,mapNumber,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);
; 14703: 	
; 14704: 			if(lpObj->m_Change >= 0)
; 14705: 			{
; 14706: 				gObjViewportListProtocolCreate(&gObj[aIndex]);
; 14707: 			}
; 14708: 	
; 14709: 			gObj[aIndex].RegenOk = 1;
; 14710: 			return false;
; 14711: 		}
; 14712: 	}
; 14713: #endif
; 14714: 
; 14715: 	if(mapNumber == MAP_INDEX_ATHLANSE)

  00476	3c 07		 cmp	 al, 7
  00478	0f 85 72 01 00
	00		 jne	 $LN29@gObjMoveGa

; 14716: 	{
; 14717: 		if(lpObj->pInventory[8].IsItem())

  0047e	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3212]
  00484	81 c1 40 05 00
	00		 add	 ecx, 1344		; 00000540H
  0048a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0048f	85 c0		 test	 eax, eax
  00491	0f 84 53 01 00
	00		 je	 $LN80@gObjMoveGa

; 14718: 		{
; 14719: 			if(lpObj->pInventory[8].m_Type == ITEMGET(13,2))

  00497	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  0049d	0f b7 80 46 05
	00 00		 movzx	 eax, WORD PTR [eax+1350]
  004a4	b9 02 1a 00 00	 mov	 ecx, 6658		; 00001a02H
  004a9	66 3b c1	 cmp	 ax, cx
  004ac	0f 85 95 00 00
	00		 jne	 $LN31@gObjMoveGa

; 14720: 			{
; 14721: 				GCServerMsgStringSend(lMsg.Get(702),lpObj->m_Index,1);

  004b2	8b 16		 mov	 edx, DWORD PTR [esi]
  004b4	6a 01		 push	 1
  004b6	52		 push	 edx
  004b7	68 be 02 00 00	 push	 702			; 000002beH
  004bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004c1	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  004c6	50		 push	 eax
  004c7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 14722: 
; 14723: 				x = lpObj->X;

  004cc	0f b7 8e 04 01
	00 00		 movzx	 ecx, WORD PTR [esi+260]

; 14724: 				y = lpObj->Y;

  004d3	0f b7 96 06 01
	00 00		 movzx	 edx, WORD PTR [esi+262]

; 14725: 				mapNumber = lpObj->MapNumber;

  004da	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]

; 14726: 				dir = lpObj->Dir;

  004e0	8a 9e 08 01 00
	00		 mov	 bl, BYTE PTR [esi+264]

; 14727: 				movefail = 1;
; 14728: 
; 14729: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 14730: 				lpObj->RegenMapX = x;
; 14731: 				lpObj->RegenMapY = y;
; 14732: 				gObjClearViewport(&gObj[aIndex]);

  004e6	56		 push	 esi
  004e7	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  004ed	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _y$[ebp], edx
  004f3	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _mapNumber$[ebp], al
  004f9	88 9d fb fe ff
	ff		 mov	 BYTE PTR _dir$[ebp], bl
  004ff	88 86 04 02 00
	00		 mov	 BYTE PTR [esi+516], al
  00505	88 8e 05 02 00
	00		 mov	 BYTE PTR [esi+517], cl
  0050b	88 96 06 02 00
	00		 mov	 BYTE PTR [esi+518], dl
  00511	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport

; 14733: 				GCTeleportSend(&gObj[aIndex],gt,mapNumber,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);

  00516	0f b6 87 08 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+264]
  0051d	0f b6 8f 06 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  00524	0f b6 97 04 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  0052b	50		 push	 eax
  0052c	8b 85 f7 fe ff
	ff		 mov	 eax, DWORD PTR _mapNumber$[ebp]
  00532	51		 push	 ecx
  00533	8b 4d 0c	 mov	 ecx, DWORD PTR _gt$[ebp]
  00536	52		 push	 edx
  00537	50		 push	 eax
  00538	51		 push	 ecx
  00539	56		 push	 esi
  0053a	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend
  0053f	83 c4 28	 add	 esp, 40			; 00000028H

; 14734: 
; 14735: 				if(lpObj->m_Change >= 0)
; 14736: 				{
; 14737: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 14738: 				}
; 14739: 
; 14740: 				gObj[aIndex].RegenOk = 1;
; 14741: 				return false;

  00542	e9 41 fc ff ff	 jmp	 $LN92@gObjMoveGa
$LN31@gObjMoveGa:

; 14742: 			}
; 14743: 
; 14744: 			if(lpObj->pInventory[8].m_Type == ITEMGET(13,3))

  00547	ba 03 1a 00 00	 mov	 edx, 6659		; 00001a03H
  0054c	66 3b c2	 cmp	 ax, dx
  0054f	0f 85 95 00 00
	00		 jne	 $LN80@gObjMoveGa

; 14745: 			{
; 14746: 				GCServerMsgStringSend(lMsg.Get(1604),lpObj->m_Index,1);

  00555	8b 06		 mov	 eax, DWORD PTR [esi]
  00557	6a 01		 push	 1
  00559	50		 push	 eax
  0055a	68 44 06 00 00	 push	 1604			; 00000644H
  0055f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00564	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00569	50		 push	 eax
  0056a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 14747: 
; 14748: 				x = lpObj->X;

  0056f	0f b7 8e 04 01
	00 00		 movzx	 ecx, WORD PTR [esi+260]

; 14749: 				y = lpObj->Y;

  00576	0f b7 96 06 01
	00 00		 movzx	 edx, WORD PTR [esi+262]

; 14750: 				mapNumber = lpObj->MapNumber;

  0057d	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]

; 14751: 				dir = lpObj->Dir;

  00583	8a 9e 08 01 00
	00		 mov	 bl, BYTE PTR [esi+264]

; 14752: 				movefail = 1;
; 14753: 
; 14754: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 14755: 				lpObj->RegenMapX = x;
; 14756: 				lpObj->RegenMapY = y;
; 14757: 				gObjClearViewport(&gObj[aIndex]);

  00589	56		 push	 esi
  0058a	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  00590	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _y$[ebp], edx
  00596	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _mapNumber$[ebp], al
  0059c	88 9d fb fe ff
	ff		 mov	 BYTE PTR _dir$[ebp], bl
  005a2	88 86 04 02 00
	00		 mov	 BYTE PTR [esi+516], al
  005a8	88 8e 05 02 00
	00		 mov	 BYTE PTR [esi+517], cl
  005ae	88 96 06 02 00
	00		 mov	 BYTE PTR [esi+518], dl
  005b4	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport

; 14758: 				GCTeleportSend(&gObj[aIndex],gt,mapNumber,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);

  005b9	0f b6 8f 08 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+264]
  005c0	0f b6 97 06 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  005c7	0f b6 87 04 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  005ce	51		 push	 ecx
  005cf	8b 8d f7 fe ff
	ff		 mov	 ecx, DWORD PTR _mapNumber$[ebp]
  005d5	52		 push	 edx
  005d6	8b 55 0c	 mov	 edx, DWORD PTR _gt$[ebp]
  005d9	50		 push	 eax
  005da	51		 push	 ecx
  005db	52		 push	 edx
  005dc	56		 push	 esi
  005dd	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend
  005e2	83 c4 28	 add	 esp, 40			; 00000028H

; 14759: 				if(lpObj->m_Change >= 0)
; 14760: 				{
; 14761: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 14762: 				}
; 14763: 				gObj[aIndex].RegenOk = 1;
; 14764: 				return false;

  005e5	e9 9e fb ff ff	 jmp	 $LN92@gObjMoveGa
$LN80@gObjMoveGa:
  005ea	8a 85 f7 fe ff
	ff		 mov	 al, BYTE PTR _mapNumber$[ebp]
$LN29@gObjMoveGa:

; 14765: 			}
; 14766: 		}
; 14767: 	}
; 14768: 
; 14769: 	if(mapNumber == MAP_INDEX_ICARUS)

  005f0	3c 0a		 cmp	 al, 10			; 0000000aH
  005f2	0f 85 c2 00 00
	00		 jne	 $LN85@gObjMoveGa

; 14770: 	{
; 14771: 		if(!(lpObj->pInventory[8].m_Type == ITEMGET(13,3)
; 14772: 			|| lpObj->pInventory[7].m_Type == ITEMGET(13,30)
; 14773: 			|| lpObj->pInventory[8].m_Type == ITEMGET(13,37)
; 14774: 			|| (lpObj->pInventory[7].m_Type >= ITEMGET(12,0)
; 14775: 				&& lpObj->pInventory[7].m_Type <=ITEMGET(12,6)))
; 14776: 			|| lpObj->pInventory[8].m_Type == ITEMGET(13,2)
; 14777: 			|| lpObj->pInventory[11].m_Type == ITEMGET(13,10)
; 14778: 			|| lpObj->pInventory[10].m_Type == ITEMGET(13,10)
; 14779: 			|| lpObj->pInventory[10].m_Type == ITEMGET(13,39)
; 14780: 			|| lpObj->pInventory[11].m_Type == ITEMGET(13,39))

  005f8	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR [esi+3212]
  005fe	0f b7 88 46 05
	00 00		 movzx	 ecx, WORD PTR [eax+1350]
  00605	ba 03 1a 00 00	 mov	 edx, 6659		; 00001a03H
  0060a	66 3b ca	 cmp	 cx, dx
  0060d	74 37		 je	 SHORT $LN88@gObjMoveGa
  0060f	0f b7 90 9e 04
	00 00		 movzx	 edx, WORD PTR [eax+1182]
  00616	bb 1e 1a 00 00	 mov	 ebx, 6686		; 00001a1eH
  0061b	66 3b d3	 cmp	 dx, bx
  0061e	74 26		 je	 SHORT $LN88@gObjMoveGa
  00620	bb 25 1a 00 00	 mov	 ebx, 6693		; 00001a25H
  00625	66 3b cb	 cmp	 cx, bx
  00628	74 1c		 je	 SHORT $LN88@gObjMoveGa
  0062a	bb 00 18 00 00	 mov	 ebx, 6144		; 00001800H
  0062f	66 3b d3	 cmp	 dx, bx
  00632	0f 8c 36 01 00
	00		 jl	 $LN25@gObjMoveGa
  00638	bb 06 18 00 00	 mov	 ebx, 6150		; 00001806H
  0063d	66 3b d3	 cmp	 dx, bx
  00640	0f 8f 28 01 00
	00		 jg	 $LN25@gObjMoveGa
$LN88@gObjMoveGa:
  00646	ba 02 1a 00 00	 mov	 edx, 6658		; 00001a02H
  0064b	66 3b ca	 cmp	 cx, dx
  0064e	0f 84 1a 01 00
	00		 je	 $LN25@gObjMoveGa
  00654	0f b7 88 3e 07
	00 00		 movzx	 ecx, WORD PTR [eax+1854]
  0065b	ba 0a 1a 00 00	 mov	 edx, 6666		; 00001a0aH
  00660	66 3b ca	 cmp	 cx, dx
  00663	0f 84 05 01 00
	00		 je	 $LN25@gObjMoveGa
  00669	0f b7 80 96 06
	00 00		 movzx	 eax, WORD PTR [eax+1686]
  00670	66 3b c2	 cmp	 ax, dx
  00673	0f 84 f5 00 00
	00		 je	 $LN25@gObjMoveGa
  00679	ba 27 1a 00 00	 mov	 edx, 6695		; 00001a27H
  0067e	66 3b c2	 cmp	 ax, dx
  00681	0f 84 e7 00 00
	00		 je	 $LN25@gObjMoveGa
  00687	8b c2		 mov	 eax, edx
  00689	66 3b c8	 cmp	 cx, ax
  0068c	0f 84 dc 00 00
	00		 je	 $LN25@gObjMoveGa

; 14803: 		}
; 14804: 
; 14805: 		if(lpObj->m_RecallMon >= 0)

  00692	83 be cc 02 00
	00 00		 cmp	 DWORD PTR [esi+716], 0
  00699	7c 34		 jl	 SHORT $LN86@gObjMoveGa

; 14806: 		{
; 14807: 			GCRecallMonLife(aIndex,60,0);

  0069b	8b 9d e0 fe ff
	ff		 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
  006a1	6a 00		 push	 0
  006a3	6a 3c		 push	 60			; 0000003cH
  006a5	53		 push	 ebx
  006a6	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife

; 14808: 			gObjMonsterCallKill(aIndex);

  006ab	53		 push	 ebx
  006ac	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  006b1	8a 85 f7 fe ff
	ff		 mov	 al, BYTE PTR _mapNumber$[ebp]
  006b7	83 c4 10	 add	 esp, 16			; 00000010H
$LN85@gObjMoveGa:

; 14809: 		}
; 14810: 	}
; 14811: 
; 14812: 	if(!KALIMA_MAP_RANGE(mapNumber) && KALIMA_MAP_RANGE(lpObj->MapNumber))

  006ba	3c 18		 cmp	 al, 24			; 00000018H
  006bc	72 11		 jb	 SHORT $LN86@gObjMoveGa
  006be	3c 1d		 cmp	 al, 29			; 0000001dH
  006c0	76 67		 jbe	 SHORT $LN20@gObjMoveGa
  006c2	33 c9		 xor	 ecx, ecx
  006c4	3c 24		 cmp	 al, 36			; 00000024H
  006c6	0f 94 c1	 sete	 cl
  006c9	8b c1		 mov	 eax, ecx
  006cb	85 c0		 test	 eax, eax
  006cd	75 5a		 jne	 SHORT $LN20@gObjMoveGa
$LN86@gObjMoveGa:
  006cf	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  006d5	3c 18		 cmp	 al, 24			; 00000018H
  006d7	72 50		 jb	 SHORT $LN20@gObjMoveGa
  006d9	3c 1d		 cmp	 al, 29			; 0000001dH
  006db	76 0d		 jbe	 SHORT $LN78@gObjMoveGa
  006dd	33 d2		 xor	 edx, edx
  006df	3c 24		 cmp	 al, 36			; 00000024H
  006e1	0f 94 c2	 sete	 dl
  006e4	8b c2		 mov	 eax, edx
  006e6	85 c0		 test	 eax, eax
  006e8	74 3f		 je	 SHORT $LN20@gObjMoveGa
$LN78@gObjMoveGa:

; 14813: 	{
; 14814: 		int iKalimaGateIndex = lpObj->m_iKalimaGateIndex;
; 14815: 
; 14816: 		if(g_KalimaGate.DeleteKalimaGate(lpObj->m_Index))

  006ea	8b 06		 mov	 eax, DWORD PTR [esi]
  006ec	8b 9e 30 02 00
	00		 mov	 ebx, DWORD PTR [esi+560]
  006f2	50		 push	 eax
  006f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  006f8	e8 00 00 00 00	 call	 ?DeleteKalimaGate@CKalimaGate@@QAEHH@Z ; CKalimaGate::DeleteKalimaGate
  006fd	85 c0		 test	 eax, eax
  006ff	74 28		 je	 SHORT $LN20@gObjMoveGa

; 14817: 		{
; 14818: 			LogAdd(LOG_BLACK, "[Kalima] [%s][%s] Kalima Gate Vanished - User MoveGate (SummonIndex:%d, EnterCount:%d)",lpObj->AccountID,lpObj->Name,iKalimaGateIndex,gObj[iKalimaGateIndex].m_cKalimaGateEnterCount);

  00701	8b cb		 mov	 ecx, ebx
  00703	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00709	0f be 91 34 02
	00 00		 movsx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+564]
  00710	52		 push	 edx
  00711	53		 push	 ebx
  00712	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00715	50		 push	 eax
  00716	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  00719	51		 push	 ecx
  0071a	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@OIJJJHHH@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5Va@
  0071f	6a 00		 push	 0
  00721	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00726	83 c4 18	 add	 esp, 24			; 00000018H
$LN20@gObjMoveGa:

; 14819: 		}
; 14820: 	}
; 14821: 
; 14822: 	if(lpObj->Class == 4 || lpObj->Class == 3)

  00729	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00730	83 f8 04	 cmp	 eax, 4
  00733	74 09		 je	 SHORT $LN18@gObjMoveGa
  00735	83 f8 03	 cmp	 eax, 3
  00738	0f 85 c5 00 00
	00		 jne	 $LN81@gObjMoveGa
$LN18@gObjMoveGa:

; 14823: 	{
; 14824: 		if(level > 0)

  0073e	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _level$[ebp]
  00744	66 85 c0	 test	 ax, ax
  00747	0f 8e bf 00 00
	00		 jle	 $LN91@gObjMoveGa

; 14825: 		{
; 14826: 			level = (level / 3)*2;

  0074d	0f bf c8	 movsx	 ecx, ax
  00750	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00755	f7 e9		 imul	 ecx
  00757	8b c2		 mov	 eax, edx
  00759	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0075c	03 c2		 add	 eax, edx
  0075e	03 c0		 add	 eax, eax
  00760	0f b7 c0	 movzx	 eax, ax
  00763	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _level$[ebp], eax
  00769	e9 9b 00 00 00	 jmp	 $LN17@gObjMoveGa
$LN25@gObjMoveGa:

; 14781: 		{
; 14782: 			GCServerMsgStringSend(lMsg.Get(1604),lpObj->m_Index,1);

  0076e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00770	6a 01		 push	 1
  00772	51		 push	 ecx
  00773	68 44 06 00 00	 push	 1604			; 00000644H
  00778	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0077d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00782	50		 push	 eax
  00783	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 14783: 
; 14784: 			x = lpObj->X;

  00788	0f b7 8e 04 01
	00 00		 movzx	 ecx, WORD PTR [esi+260]

; 14785: 			y = lpObj->Y;

  0078f	0f b7 96 06 01
	00 00		 movzx	 edx, WORD PTR [esi+262]

; 14786: 			mapNumber = lpObj->MapNumber;

  00796	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]

; 14787: 			dir = lpObj->Dir;

  0079c	8a 9e 08 01 00
	00		 mov	 bl, BYTE PTR [esi+264]

; 14788: 			movefail = 1;
; 14789: 
; 14790: 			lpObj->RegenMapNumber = lpObj->MapNumber;

  007a2	88 86 04 02 00
	00		 mov	 BYTE PTR [esi+516], al

; 14791: 			lpObj->RegenMapX = x;
; 14792: 			lpObj->RegenMapY = y;

  007a8	88 96 06 02 00
	00		 mov	 BYTE PTR [esi+518], dl
  007ae	88 8e 05 02 00
	00		 mov	 BYTE PTR [esi+517], cl
  007b4	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _y$[ebp], edx

; 14793: 			
; 14794: 			GCTeleportSend(&gObj[aIndex],gt,mapNumber,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);

  007ba	0f b6 97 08 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+264]
  007c1	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _mapNumber$[ebp], al
  007c7	0f b6 87 06 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  007ce	52		 push	 edx
  007cf	8b 95 f7 fe ff
	ff		 mov	 edx, DWORD PTR _mapNumber$[ebp]
  007d5	50		 push	 eax
  007d6	8b 45 0c	 mov	 eax, DWORD PTR _gt$[ebp]
  007d9	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  007df	0f b6 8f 04 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  007e6	51		 push	 ecx
  007e7	52		 push	 edx
  007e8	50		 push	 eax
  007e9	56		 push	 esi
  007ea	88 9d fb fe ff
	ff		 mov	 BYTE PTR _dir$[ebp], bl
  007f0	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend

; 14795: 			gObjClearViewportOfMine(lpObj);

  007f5	56		 push	 esi
  007f6	e8 00 00 00 00	 call	 ?gObjClearViewportOfMine@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewportOfMine
  007fb	83 c4 28	 add	 esp, 40			; 00000028H

; 14796: 
; 14797: 			if(lpObj->m_Change >= 0)
; 14798: 			{
; 14799: 				gObjViewportListProtocolCreate(&gObj[aIndex]);
; 14800: 			}
; 14801: 			gObj[aIndex].RegenOk = 1;
; 14802: 			return false;

  007fe	e9 85 f9 ff ff	 jmp	 $LN92@gObjMoveGa
$LN81@gObjMoveGa:

; 14825: 		{
; 14826: 			level = (level / 3)*2;

  00803	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _level$[ebp]
$LN17@gObjMoveGa:

; 14827: 		}
; 14828: 	}
; 14829: 
; 14830: 	if(level != 0)

  00809	66 85 c0	 test	 ax, ax
$LN91@gObjMoveGa:
  0080c	74 78		 je	 SHORT $LN87@gObjMoveGa

; 14831: 	{
; 14832: 		if(userlevel < level)

  0080e	98		 cwde
  0080f	39 85 dc fe ff
	ff		 cmp	 DWORD PTR _userlevel$[ebp], eax
  00815	7d 6f		 jge	 SHORT $LN87@gObjMoveGa

; 14833: 		{
; 14834: 			char szTemp[256];
; 14835: 			wsprintf(szTemp,lMsg.Get(1117),level);

  00817	50		 push	 eax
  00818	68 5d 04 00 00	 push	 1117			; 0000045dH
  0081d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00822	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00827	50		 push	 eax
  00828	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$166880[ebp]
  0082e	51		 push	 ecx
  0082f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 14836: 			GCServerMsgStringSend(szTemp,aIndex,1);

  00835	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0083b	6a 01		 push	 1
  0083d	52		 push	 edx
  0083e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$166880[ebp]
  00844	50		 push	 eax
  00845	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 14837: 
; 14838: 			x = lpObj->X;

  0084a	0f b7 8e 04 01
	00 00		 movzx	 ecx, WORD PTR [esi+260]

; 14839: 			y = lpObj->Y;

  00851	0f b7 96 06 01
	00 00		 movzx	 edx, WORD PTR [esi+262]

; 14840: 			mapNumber = lpObj->MapNumber;

  00858	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  0085e	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx

; 14841: 			dir = lpObj->Dir;

  00864	8a 8e 08 01 00
	00		 mov	 cl, BYTE PTR [esi+264]
  0086a	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _mapNumber$[ebp], al
  00870	83 c4 18	 add	 esp, 24			; 00000018H
  00873	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _y$[ebp], edx
  00879	88 8d fb fe ff
	ff		 mov	 BYTE PTR _dir$[ebp], cl

; 14842: 			movefail = 1;

  0087f	b8 01 00 00 00	 mov	 eax, 1
  00884	eb 06		 jmp	 SHORT $LN15@gObjMoveGa
$LN87@gObjMoveGa:
  00886	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _movefail$[ebp]
$LN15@gObjMoveGa:

; 14843: 		}
; 14844: 	}
; 14845: 
; 14846: 	if(gObj[aIndex].m_IfState.use != 0)

  0088c	f6 87 84 0c 00
	00 03		 test	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3204], 3
  00893	74 37		 je	 SHORT $LN90@gObjMoveGa

; 14847: 	{
; 14848: 		x = lpObj->X;

  00895	0f b7 96 04 01
	00 00		 movzx	 edx, WORD PTR [esi+260]

; 14849: 		y = lpObj->Y;

  0089c	0f b7 86 06 01
	00 00		 movzx	 eax, WORD PTR [esi+262]

; 14850: 		mapNumber = lpObj->MapNumber;

  008a3	8a 8e 09 01 00
	00		 mov	 cl, BYTE PTR [esi+265]
  008a9	89 95 ec fe ff
	ff		 mov	 DWORD PTR _x$[ebp], edx

; 14851: 		dir = lpObj->Dir;

  008af	8a 96 08 01 00
	00		 mov	 dl, BYTE PTR [esi+264]
  008b5	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _y$[ebp], eax
  008bb	88 8d f7 fe ff
	ff		 mov	 BYTE PTR _mapNumber$[ebp], cl
  008c1	88 95 fb fe ff
	ff		 mov	 BYTE PTR _dir$[ebp], dl

; 14852: 		movefail = 1;

  008c7	b8 01 00 00 00	 mov	 eax, 1
$LN90@gObjMoveGa:

; 14853: 	}
; 14854: 
; 14855: 	if(gObj[aIndex].DieRegen != 0)

  008cc	80 bf 02 02 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+514], 0
  008d3	74 37		 je	 SHORT $LN13@gObjMoveGa

; 14856: 	{
; 14857: 		x = lpObj->X;

  008d5	0f b7 86 04 01
	00 00		 movzx	 eax, WORD PTR [esi+260]

; 14858: 		y = lpObj->Y;

  008dc	0f b7 8e 06 01
	00 00		 movzx	 ecx, WORD PTR [esi+262]

; 14859: 		mapNumber = lpObj->MapNumber;

  008e3	8a 96 09 01 00
	00		 mov	 dl, BYTE PTR [esi+265]
  008e9	89 85 ec fe ff
	ff		 mov	 DWORD PTR _x$[ebp], eax

; 14860: 		dir = lpObj->Dir;

  008ef	8a 86 08 01 00
	00		 mov	 al, BYTE PTR [esi+264]
  008f5	88 85 fb fe ff
	ff		 mov	 BYTE PTR _dir$[ebp], al
  008fb	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _y$[ebp], ecx
  00901	88 95 f7 fe ff
	ff		 mov	 BYTE PTR _mapNumber$[ebp], dl

; 14861: 		movefail = 1;

  00907	b8 01 00 00 00	 mov	 eax, 1
$LN13@gObjMoveGa:

; 14862: 	}
; 14863: 
; 14864: 	lpObj->m_State = 32;

  0090c	c7 86 bc 01 00
	00 20 00 00 00	 mov	 DWORD PTR [esi+444], 32	; 00000020H

; 14865: 
; 14866: 	if(movefail == 0)

  00916	85 c0		 test	 eax, eax
  00918	0f 85 fb 02 00
	00		 jne	 $LN12@gObjMoveGa

; 14867: 	{
; 14868: 		if(gGateC.GetGate(gt,(short &)x,(short &)y,(BYTE &)mapNumber,(BYTE &)dir,(short &)level) != -1)

  0091e	8b 5d 0c	 mov	 ebx, DWORD PTR _gt$[ebp]
  00921	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _level$[ebp]
  00927	51		 push	 ecx
  00928	8d 95 fb fe ff
	ff		 lea	 edx, DWORD PTR _dir$[ebp]
  0092e	52		 push	 edx
  0092f	8d 85 f7 fe ff
	ff		 lea	 eax, DWORD PTR _mapNumber$[ebp]
  00935	50		 push	 eax
  00936	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _y$[ebp]
  0093c	51		 push	 ecx
  0093d	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _x$[ebp]
  00943	52		 push	 edx
  00944	53		 push	 ebx
  00945	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  0094a	e8 00 00 00 00	 call	 ?GetGate@CGate@@QAEHHAAF0AAE10@Z ; CGate::GetGate
  0094f	83 f8 ff	 cmp	 eax, -1
  00952	0f 84 9e 01 00
	00		 je	 $LN82@gObjMoveGa

; 14869: 		{
; 14870: 			if(gObj[aIndex].MapNumber != mapNumber)

  00958	8a 85 f7 fe ff
	ff		 mov	 al, BYTE PTR _mapNumber$[ebp]
  0095e	38 87 09 01 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+265], al
  00964	0f 84 92 01 00
	00		 je	 $LN8@gObjMoveGa

; 14871: 			{
; 14872: 				if(MapNumberCheck(mapNumber)== 0)

  0096a	0f b6 c0	 movzx	 eax, al
  0096d	50		 push	 eax
  0096e	e8 00 00 00 00	 call	 ?MapNumberCheck@@YAHH@Z	; MapNumberCheck
  00973	83 c4 04	 add	 esp, 4
  00976	85 c0		 test	 eax, eax
  00978	75 2b		 jne	 SHORT $LN9@gObjMoveGa

; 14873: 				{
; 14874: 					LogAdd(LOG_BLACK, "error-L3 : %s %d",__FILE__,__LINE__);

  0097a	68 1a 3a 00 00	 push	 14874			; 00003a1aH
  0097f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCNFOMBO@user?4cpp?$AA@
  00984	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  00989	50		 push	 eax
  0098a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0098f	83 c4 10	 add	 esp, 16			; 00000010H
  00992	5f		 pop	 edi
  00993	5e		 pop	 esi
  00994	33 c0		 xor	 eax, eax
  00996	5b		 pop	 ebx

; 14974: 	}
; 14975: 
; 14976: 	return true;
; 14977: }

  00997	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0099a	33 cd		 xor	 ecx, ebp
  0099c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009a1	8b e5		 mov	 esp, ebp
  009a3	5d		 pop	 ebp
  009a4	c3		 ret	 0
$LN9@gObjMoveGa:

; 14875: 					return false;
; 14876: 				}
; 14877: 
; 14878: 				short sSvrCode = g_MapServerManager.CheckMoveMapSvr(lpObj->m_Index,mapNumber,lpObj->m_sPrevMapSvrCode);

  009a5	0f b7 8e cc 14
	00 00		 movzx	 ecx, WORD PTR [esi+5324]
  009ac	0f b6 95 f7 fe
	ff ff		 movzx	 edx, BYTE PTR _mapNumber$[ebp]
  009b3	8b 06		 mov	 eax, DWORD PTR [esi]
  009b5	51		 push	 ecx
  009b6	52		 push	 edx
  009b7	50		 push	 eax
  009b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  009bd	e8 00 00 00 00	 call	 ?CheckMoveMapSvr@CMapServerManager@@QAEFHHF@Z ; CMapServerManager::CheckMoveMapSvr
  009c2	0f b7 c0	 movzx	 eax, ax
  009c5	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _sSvrCode$166893[ebp], eax

; 14879: 
; 14880: 				if(sSvrCode != gGameServerCode)

  009cb	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  009d2	0f 84 1e 01 00
	00		 je	 $LN82@gObjMoveGa

; 14881: 				{
; 14882: 					if(sSvrCode == -1)

  009d8	66 83 f8 ff	 cmp	 ax, -1
  009dc	75 2d		 jne	 SHORT $LN7@gObjMoveGa

; 14883: 					{
; 14884: 						LogAdd(LOG_RED, "[MapServerMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s][%s] (%d)",lpObj->AccountID,lpObj->Name,lpObj->m_Index);

  009de	8b 0e		 mov	 ecx, DWORD PTR [esi]
  009e0	51		 push	 ecx
  009e1	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  009e4	52		 push	 edx
  009e5	83 c6 64	 add	 esi, 100		; 00000064H
  009e8	56		 push	 esi
  009e9	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@
  009ee	6a 01		 push	 1
  009f0	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  009f5	83 c4 14	 add	 esp, 20			; 00000014H
  009f8	5f		 pop	 edi
  009f9	5e		 pop	 esi
  009fa	33 c0		 xor	 eax, eax
  009fc	5b		 pop	 ebx

; 14974: 	}
; 14975: 
; 14976: 	return true;
; 14977: }

  009fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a00	33 cd		 xor	 ecx, ebp
  00a02	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a07	8b e5		 mov	 esp, ebp
  00a09	5d		 pop	 ebp
  00a0a	c3		 ret	 0
$LN7@gObjMoveGa:

; 14885: 						return false;
; 14886: 					}
; 14887: 
; 14888: 					if(gGateC.CheckGateLevel(aIndex,gt) == 0)

  00a0b	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00a11	53		 push	 ebx
  00a12	50		 push	 eax
  00a13	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  00a18	e8 00 00 00 00	 call	 ?CheckGateLevel@CGate@@QAEHHH@Z ; CGate::CheckGateLevel
  00a1d	85 c0		 test	 eax, eax
  00a1f	75 7f		 jne	 SHORT $LN6@gObjMoveGa

; 14889: 					{
; 14890: 						x = lpObj->X;
; 14891: 						y = lpObj->Y;

  00a21	0f b7 96 06 01
	00 00		 movzx	 edx, WORD PTR [esi+262]

; 14892: 						mapNumber = lpObj->MapNumber;

  00a28	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00a2e	0f b7 8e 04 01
	00 00		 movzx	 ecx, WORD PTR [esi+260]
  00a35	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _y$[ebp], edx

; 14893: 						dir = lpObj->Dir;

  00a3b	8a 96 08 01 00
	00		 mov	 dl, BYTE PTR [esi+264]
  00a41	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _mapNumber$[ebp], al

; 14894: 						movefail = 1;
; 14895: 
; 14896: 						lpObj->RegenMapNumber = lpObj->MapNumber;

  00a47	88 86 04 02 00
	00		 mov	 BYTE PTR [esi+516], al

; 14897: 		
; 14898: 						lpObj->RegenMapX = x;
; 14899: 						lpObj->RegenMapY = y;

  00a4d	0f b6 85 f0 fe
	ff ff		 movzx	 eax, BYTE PTR _y$[ebp]

; 14900: 				
; 14901: 						gObjClearViewport(&gObj[aIndex]);

  00a54	56		 push	 esi
  00a55	89 8d ec fe ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  00a5b	88 95 fb fe ff
	ff		 mov	 BYTE PTR _dir$[ebp], dl
  00a61	88 8e 05 02 00
	00		 mov	 BYTE PTR [esi+517], cl
  00a67	88 86 06 02 00
	00		 mov	 BYTE PTR [esi+518], al
  00a6d	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport

; 14902: 				
; 14903: 						GCTeleportSend(&gObj[aIndex],gt,mapNumber,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);

  00a72	0f b6 8f 08 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+264]
  00a79	0f b6 97 06 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  00a80	0f b6 87 04 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  00a87	51		 push	 ecx
  00a88	8b 8d f7 fe ff
	ff		 mov	 ecx, DWORD PTR _mapNumber$[ebp]
  00a8e	52		 push	 edx
  00a8f	50		 push	 eax
  00a90	51		 push	 ecx
  00a91	53		 push	 ebx
  00a92	56		 push	 esi
  00a93	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend
  00a98	83 c4 1c	 add	 esp, 28			; 0000001cH

; 14904: 				
; 14905: 						if(lpObj->m_Change >= 0)
; 14906: 						{
; 14907: 							gObjViewportListProtocolCreate(&gObj[aIndex]);
; 14908: 						}
; 14909: 	
; 14910: 						gObj[aIndex].RegenOk = 1;
; 14911: #if GS_CASTLE == 1
; 14912: 						if ( gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 14913: 						{
; 14914: 							g_CastleSiege.NotifySelfCsJoinSide(aIndex);
; 14915: 							g_CastleSiege.NotifyCsSelfLeftTime(aIndex);
; 14916: 						}
; 14917: #endif
; 14918: 						return false;

  00a9b	e9 e8 f6 ff ff	 jmp	 $LN92@gObjMoveGa
$LN6@gObjMoveGa:

; 14919: 					}
; 14920: 
; 14921: 					GJReqMapSvrMove(lpObj->m_Index,sSvrCode,mapNumber,x,y);

  00aa0	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _y$[ebp]
  00aa6	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00aac	8b bd e8 fe ff
	ff		 mov	 edi, DWORD PTR _sSvrCode$166893[ebp]
  00ab2	52		 push	 edx
  00ab3	0f b6 95 f7 fe
	ff ff		 movzx	 edx, BYTE PTR _mapNumber$[ebp]
  00aba	50		 push	 eax
  00abb	8b 06		 mov	 eax, DWORD PTR [esi]
  00abd	52		 push	 edx
  00abe	57		 push	 edi
  00abf	50		 push	 eax
  00ac0	e8 00 00 00 00	 call	 ?GJReqMapSvrMove@@YAXHGGEE@Z ; GJReqMapSvrMove

; 14922: 					LogAdd(LOG_BLACK, "[MapServerMng] Request to Move Map Server : (%d) - [%s][%s] (%d)",sSvrCode,lpObj->AccountID,lpObj->Name,lpObj->m_Index);

  00ac5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00ac7	51		 push	 ecx
  00ac8	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  00acb	52		 push	 edx
  00acc	0f bf c7	 movsx	 eax, di
  00acf	83 c6 64	 add	 esi, 100		; 00000064H
  00ad2	56		 push	 esi
  00ad3	50		 push	 eax
  00ad4	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@
  00ad9	6a 00		 push	 0
  00adb	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00ae0	83 c4 2c	 add	 esp, 44			; 0000002cH
  00ae3	5f		 pop	 edi
  00ae4	5e		 pop	 esi
  00ae5	33 c0		 xor	 eax, eax
  00ae7	5b		 pop	 ebx

; 14974: 	}
; 14975: 
; 14976: 	return true;
; 14977: }

  00ae8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00aeb	33 cd		 xor	 ecx, ebp
  00aed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00af2	8b e5		 mov	 esp, ebp
  00af4	5d		 pop	 ebp
  00af5	c3		 ret	 0
$LN82@gObjMoveGa:

; 14923: 					return false;

  00af6	8a 85 f7 fe ff
	ff		 mov	 al, BYTE PTR _mapNumber$[ebp]
$LN8@gObjMoveGa:

; 14924: 				}
; 14925: 			}
; 14926: 		}
; 14927: 
; 14928: 		LogAdd(LOG_BLACK, "[MoveMap][%s][%s] : (Before:Map:%d X:%d Y:%d) -> (New Map:%d X:%d Y:%d)",lpObj->AccountID,lpObj->Name,lpObj->MapNumber,lpObj->X,lpObj->Y,mapNumber,x,y);

  00afc	0f bf 8d f0 fe
	ff ff		 movsx	 ecx, WORD PTR _y$[ebp]
  00b03	0f bf 95 ec fe
	ff ff		 movsx	 edx, WORD PTR _x$[ebp]
  00b0a	51		 push	 ecx
  00b0b	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR [esi+262]
  00b12	52		 push	 edx
  00b13	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  00b1a	0f b6 c0	 movzx	 eax, al
  00b1d	50		 push	 eax
  00b1e	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00b25	51		 push	 ecx
  00b26	52		 push	 edx
  00b27	50		 push	 eax
  00b28	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  00b2b	51		 push	 ecx
  00b2c	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  00b2f	52		 push	 edx
  00b30	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@IELJOCDM@?$FLMoveMap?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5?3?5?$CIBefore?3Map?3@
  00b35	6a 00		 push	 0
  00b37	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 14929: 
; 14930: 		gObj[aIndex].X = x;

  00b3c	66 8b 85 ec fe
	ff ff		 mov	 ax, WORD PTR _x$[ebp]

; 14931: 		gObj[aIndex].Y = y;
; 14932: 		gObj[aIndex].TX = x;
; 14933: 		gObj[aIndex].TX = y;	// #error Change to TY
; 14934: 		gObj[aIndex].MapNumber = mapNumber;

  00b43	8a 8d f7 fe ff
	ff		 mov	 cl, BYTE PTR _mapNumber$[ebp]

; 14935: 		gObj[aIndex].Dir = dir;

  00b49	8a 95 fb fe ff
	ff		 mov	 dl, BYTE PTR _dir$[ebp]
  00b4f	66 89 87 04 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260], ax
  00b56	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _y$[ebp]

; 14936: 		gObj[aIndex].PathCount = 0;
; 14937: 		gObj[aIndex].Teleport = 0;
; 14938: 
; 14939: 		gObjClearViewport(&gObj[aIndex]);

  00b5c	56		 push	 esi
  00b5d	66 89 87 06 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262], ax
  00b64	66 89 87 20 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+288], ax
  00b6b	88 8f 09 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+265], cl
  00b71	88 97 08 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+264], dl
  00b77	c7 87 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+296], 0
  00b81	c6 87 00 02 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+512], 0
  00b88	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport

; 14940: 		GCTeleportSend(&gObj[aIndex],gt,mapNumber,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);

  00b8d	0f b6 87 08 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+264]
  00b94	0f b6 8f 06 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  00b9b	0f b6 97 04 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  00ba2	50		 push	 eax
  00ba3	8b 85 f7 fe ff
	ff		 mov	 eax, DWORD PTR _mapNumber$[ebp]
  00ba9	51		 push	 ecx
  00baa	52		 push	 edx
  00bab	50		 push	 eax
  00bac	53		 push	 ebx
  00bad	56		 push	 esi
  00bae	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend
  00bb3	83 c4 44	 add	 esp, 68			; 00000044H

; 14941: 
; 14942: 		if(lpObj->m_Change >= 0)

  00bb6	83 be d0 02 00
	00 00		 cmp	 DWORD PTR [esi+720], 0
  00bbd	7c 09		 jl	 SHORT $LN4@gObjMoveGa

; 14943: 		{
; 14944: 			gObjViewportListProtocolCreate(&gObj[aIndex]);

  00bbf	56		 push	 esi
  00bc0	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00bc5	83 c4 04	 add	 esp, 4
$LN4@gObjMoveGa:

; 14945: 		}
; 14946: 
; 14947: 		gObj[aIndex].RegenMapNumber = mapNumber;
; 14948: 		gObj[aIndex].RegenMapX = x;
; 14949: 		gObj[aIndex].RegenMapY = y;

  00bc8	8a 85 f0 fe ff
	ff		 mov	 al, BYTE PTR _y$[ebp]
  00bce	8a 8d f7 fe ff
	ff		 mov	 cl, BYTE PTR _mapNumber$[ebp]
  00bd4	8a 95 ec fe ff
	ff		 mov	 dl, BYTE PTR _x$[ebp]
  00bda	88 87 06 02 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+518], al

; 14969: 	}
; 14970: 
; 14971: 	if(gObj[aIndex].Type == OBJ_USER)

  00be0	b8 01 00 00 00	 mov	 eax, 1
  00be5	88 8f 04 02 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+516], cl
  00beb	88 97 05 02 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+517], dl
  00bf1	c6 87 03 02 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+515], 1
  00bf8	66 39 87 60 00
	00 00		 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+96], ax
  00bff	75 07		 jne	 SHORT $LN55@gObjMoveGa

; 14972: 	{
; 14973: 		gObj[aIndex].m_LastTeleportTime = 10;

  00c01	c6 87 21 0f 00
	00 0a		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3873], 10 ; 0000000aH
$LN55@gObjMoveGa:

; 14974: 	}
; 14975: 
; 14976: 	return true;
; 14977: }

  00c08	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c0b	5f		 pop	 edi
  00c0c	5e		 pop	 esi
  00c0d	33 cd		 xor	 ecx, ebp
  00c0f	5b		 pop	 ebx
  00c10	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c15	8b e5		 mov	 esp, ebp
  00c17	5d		 pop	 ebp
  00c18	c3		 ret	 0
$LN12@gObjMoveGa:

; 14950: 		gObj[aIndex].RegenOk = 1;
; 14951: 	}
; 14952: 	else
; 14953: 	{
; 14954: 		GCTeleportSend(&gObj[aIndex],gt,mapNumber,gObj[aIndex].X,gObj[aIndex].Y,gObj[aIndex].Dir);

  00c19	0f b6 8f 08 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+264]
  00c20	0f b6 97 06 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  00c27	0f b6 87 04 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  00c2e	51		 push	 ecx
  00c2f	8b 8d f7 fe ff
	ff		 mov	 ecx, DWORD PTR _mapNumber$[ebp]
  00c35	52		 push	 edx
  00c36	8b 55 0c	 mov	 edx, DWORD PTR _gt$[ebp]
  00c39	50		 push	 eax
  00c3a	51		 push	 ecx
  00c3b	52		 push	 edx
  00c3c	56		 push	 esi
  00c3d	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend
  00c42	83 c4 18	 add	 esp, 24			; 00000018H

; 14955: 		gObj[aIndex].RegenOk = 1;
; 14956: 
; 14957: #if GS_CASTLE == 1
; 14958: 		if ( lpObj->MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 14959: 		{
; 14960: 			g_CastleSiege.NotifySelfCsJoinSide(aIndex);
; 14961: 			g_CastleSiege.NotifyCsSelfLeftTime(aIndex);
; 14962: 		}
; 14963: #endif
; 14964: 	}
; 14965: 
; 14966: 	if(movefail != 0)
; 14967: 	{
; 14968: 		return false;

  00c45	e9 50 f5 ff ff	 jmp	 $LN48@gObjMoveGa
?gObjMoveGate@@YAHHH@Z ENDP				; gObjMoveGate
_TEXT	ENDS
PUBLIC	??_C@_0EL@FIMACGK@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@ ; `string'
PUBLIC	?gObjMonsterCall@@YAHHHHH@Z			; gObjMonsterCall
;	COMDAT ??_C@_0EL@FIMACGK@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@
CONST	SEGMENT
??_C@_0EL@FIMACGK@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@ DB '['
	DB	'Summon Monster] [%s][%s] Try to Summon Monster - Succeed (Sum'
	DB	'monIndex:%d)', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjMonsterCall@@YAHHHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_MonsterType$ = 12					; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?gObjMonsterCall@@YAHHHHH@Z PROC			; gObjMonsterCall, COMDAT

; 16304: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 16305: 
; 16306: 	if(gObj[aIndex].MapNumber == MAP_INDEX_ICARUS)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	57		 push	 edi
  00008	8b fe		 mov	 edi, esi
  0000a	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00010	80 bf 09 01 00
	00 0a		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+265], 10 ; 0000000aH

; 16307: 	{
; 16308: 		return false;

  00017	74 1c		 je	 SHORT $LN7@gObjMonste@8

; 16309: 	}
; 16310: 
; 16311: 	if(gObj[aIndex].m_RecallMon >= 0)

  00019	83 bf cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+716], 0
  00020	7c 19		 jl	 SHORT $LN2@gObjMonste@8

; 16312: 	{
; 16313: 
; 16314: 		GCRecallMonLife(aIndex,60,0);

  00022	6a 00		 push	 0
  00024	6a 3c		 push	 60			; 0000003cH
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife

; 16315: 		gObjMonsterCallKill(aIndex);

  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  00032	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@gObjMonste@8:

; 16316: 		return false;

  00035	5f		 pop	 edi
  00036	33 c0		 xor	 eax, eax
  00038	5e		 pop	 esi

; 16352: }

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
$LN2@gObjMonste@8:
  0003b	53		 push	 ebx

; 16317: 	}
; 16318: 
; 16319: 	int result = gObjAddCallMon();

  0003c	e8 00 00 00 00	 call	 ?gObjAddCallMon@@YAFXZ	; gObjAddCallMon
  00041	0f bf d8	 movsx	 ebx, ax

; 16320: 
; 16321: 	if(result >= 0)

  00044	85 db		 test	 ebx, ebx
  00046	0f 88 e2 00 00
	00		 js	 $LN1@gObjMonste@8

; 16322: 	{
; 16323: 		gObj[result].X = x;
; 16324: 		gObj[result].Y = y;

  0004c	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  0004f	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  00052	8b f3		 mov	 esi, ebx
  00054	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0005a	66 89 8e 06 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262], cx

; 16325: 
; 16326: 		gObj[result].MTX = x;
; 16327: 		gObj[result].MTY = y;

  00061	66 89 8e 26 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+294], cx

; 16328: 		gObj[result].Dir = 2;
; 16329: 
; 16330: 		gObj[result].MapNumber = gObj[aIndex].MapNumber;
; 16331: 
; 16332: 		gObjSetMonster(result,MonsterType);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _MonsterType$[ebp]
  0006b	66 89 86 04 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260], ax
  00072	66 89 86 24 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+292], ax
  00079	c6 86 08 01 00
	00 02		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+264], 2
  00080	8a 87 09 01 00
	00		 mov	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+265]
  00086	51		 push	 ecx
  00087	53		 push	 ebx
  00088	88 86 09 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265], al
  0008e	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 16333: 
; 16334: 		gObj[result].m_RecallMon = aIndex;

  00093	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]

; 16335: 		gObj[result].m_Attribute = 100;
; 16336: 
; 16337: 		gObj[result].TargetNumber = -1;
; 16338: 		gObj[result].m_ActState.Emotion = 0;
; 16339: 		gObj[result].m_ActState.Attack = 0;

  00096	81 a6 b4 01 00
	00 0d ff ff ff	 and	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+436], -243 ; ffffff0dH
  000a0	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  000a5	83 c9 ff	 or	 ecx, -1
  000a8	89 96 cc 02 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+716], edx
  000ae	66 89 86 26 03
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+806], ax
  000b5	66 89 8e d4 02
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+724], cx

; 16340: 		gObj[result].m_ActState.EmotionCount = 0;

  000bc	c6 86 b5 01 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+437], 0

; 16341: 
; 16342: 		gObj[result].PathCount = 0;

  000c3	c7 86 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+296], 0

; 16343: 
; 16344: 		gObj[aIndex].m_RecallMon = result;

  000cd	89 9f cc 02 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+716], ebx

; 16345: 		gObj[result].m_MoveRange = 15;
; 16346: 
; 16347: 		GCRecallMonLife(gObj[result].m_RecallMon,gObj[result].MaxLife,gObj[result].Life);

  000d3	d9 86 bc 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+188]
  000d9	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH
  000de	83 c4 08	 add	 esp, 8
  000e1	66 89 96 1e 03
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+798], dx
  000e8	e8 00 00 00 00	 call	 __ftol2_sse
  000ed	d9 86 c0 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 __ftol2_sse
  000f9	50		 push	 eax
  000fa	8b 86 cc 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+716]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife

; 16348: 		LogAdd(LOG_BLACK, "[Summon Monster] [%s][%s] Try to Summon Monster - Succeed (SummonIndex:%d)",gObj[aIndex].AccountID,gObj[aIndex].Name,result);

  00106	53		 push	 ebx
  00107	8d 8f 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+111]
  0010d	51		 push	 ecx
  0010e	8d 97 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+100]
  00114	52		 push	 edx
  00115	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@FIMACGK@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to@
  0011a	6a 00		 push	 0
  0011c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00121	83 c4 20	 add	 esp, 32			; 00000020H
  00124	5b		 pop	 ebx
  00125	5f		 pop	 edi

; 16349: 		return true;

  00126	b8 01 00 00 00	 mov	 eax, 1
  0012b	5e		 pop	 esi

; 16352: }

  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
$LN1@gObjMonste@8:
  0012e	5b		 pop	 ebx
  0012f	5f		 pop	 edi

; 16350: 	}
; 16351: 	return false;

  00130	33 c0		 xor	 eax, eax
  00132	5e		 pop	 esi

; 16352: }

  00133	5d		 pop	 ebp
  00134	c3		 ret	 0
?gObjMonsterCall@@YAHHHHH@Z ENDP			; gObjMonsterCall
_TEXT	ENDS
PUBLIC	?gObjDelayLifeCheck@@YAXH@Z			; gObjDelayLifeCheck
; Function compile flags: /Ogtp
;	COMDAT ?gObjDelayLifeCheck@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjDelayLifeCheck@@YAXH@Z PROC			; gObjDelayLifeCheck, COMDAT

; 17564: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17565: 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0000c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17566: 
; 17567: 	if(lpObj->m_CheckLifeTime > 0)

  00012	8b 81 10 0f 00
	00		 mov	 eax, DWORD PTR [ecx+3856]
  00018	85 c0		 test	 eax, eax
  0001a	7e 4c		 jle	 SHORT $LN1@gObjDelayL

; 17568: 	{
; 17569: 		lpObj->m_CheckLifeTime--;

  0001c	48		 dec	 eax
  0001d	89 81 10 0f 00
	00		 mov	 DWORD PTR [ecx+3856], eax

; 17570: 
; 17571: 		if(lpObj->m_CheckLifeTime <= 0)

  00023	85 c0		 test	 eax, eax
  00025	7f 41		 jg	 SHORT $LN1@gObjDelayL

; 17572: 		{
; 17573: 			lpObj->m_CheckLifeTime = 0;
; 17574: 
; 17575: 			if(lpObj->Life < 0)

  00027	d9 ee		 fldz
  00029	c7 81 10 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+3856], 0
  00033	d8 91 bc 00 00
	00		 fcom	 DWORD PTR [ecx+188]
  00039	df e0		 fnstsw	 ax
  0003b	f6 c4 41	 test	 ah, 65			; 00000041H
  0003e	75 08		 jne	 SHORT $LN8@gObjDelayL

; 17576: 			{
; 17577: 				lpObj->Life = 0;

  00040	d9 99 bc 00 00
	00		 fstp	 DWORD PTR [ecx+188]
  00046	eb 02		 jmp	 SHORT $LN2@gObjDelayL
$LN8@gObjDelayL:
  00048	dd d8		 fstp	 ST(0)
$LN2@gObjDelayL:

; 17578: 			}
; 17579: 
; 17580: 			if(lpObj->lpAttackObj != 0)

  0004a	8b 81 38 02 00
	00		 mov	 eax, DWORD PTR [ecx+568]
  00050	85 c0		 test	 eax, eax
  00052	74 14		 je	 SHORT $LN1@gObjDelayL

; 17581: 			{
; 17582: 				gObjLifeCheck(lpObj,lpObj->lpAttackObj,0,1,0,0,0);

  00054	6a 00		 push	 0
  00056	6a 00		 push	 0
  00058	6a 00		 push	 0
  0005a	6a 01		 push	 1
  0005c	6a 00		 push	 0
  0005e	50		 push	 eax
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHE@Z ; gObjLifeCheck
  00065	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@gObjDelayL:

; 17583: 			}
; 17584: 		}
; 17585: 	}
; 17586: }

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?gObjDelayLifeCheck@@YAXH@Z ENDP			; gObjDelayLifeCheck
_TEXT	ENDS
PUBLIC	??_C@_0GB@MEEFOHBG@?$FL?5CHECK?5POSITION?5?$FN?5DbgName?$FL?$CFd?$FN?5?$FL@ ; `string'
PUBLIC	?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z	; gObjCheckXYMapTile
;	COMDAT ??_C@_0GB@MEEFOHBG@?$FL?5CHECK?5POSITION?5?$FN?5DbgName?$FL?$CFd?$FN?5?$FL@
CONST	SEGMENT
??_C@_0GB@MEEFOHBG@?$FL?5CHECK?5POSITION?5?$FN?5DbgName?$FL?$CFd?$FN?5?$FL@ DB '['
	DB	' CHECK POSITION ] DbgName[%d] [%s][%s] Map[%d]-(%d,%d) Invali'
	DB	'd location causes to force to move', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
tv341 = -8						; size = 4
_attr4$162905 = -2					; size = 1
_attr3$162904 = -1					; size = 1
_mapnumber$ = 8						; size = 4
_lpObj$ = 8						; size = 4
_attr2$162903 = 11					; size = 1
_iDbgName$ = 12						; size = 4
?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z PROC	; gObjCheckXYMapTile, COMDAT

; 3558 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 3559 : 	if ( lpObj->Type != OBJ_USER )

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000a	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0000f	74 07		 je	 SHORT $LN16@gObjCheckX
$LN25@gObjCheckX:

; 3560 : 	{
; 3561 : 		return false;

  00011	33 c0		 xor	 eax, eax
  00013	5e		 pop	 esi

; 3642 : 
; 3643 : }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN16@gObjCheckX:

; 3562 : 	}
; 3563 : 
; 3564 : 	if ( (lpObj->Authority&2 ) == 2 )

  00018	f6 86 a4 01 00
	00 02		 test	 BYTE PTR [esi+420], 2

; 3565 : 	{
; 3566 : 		return FALSE;

  0001f	75 f0		 jne	 SHORT $LN25@gObjCheckX

; 3567 : 	}
; 3568 : 
; 3569 : 	if ( CC_MAP_RANGE(lpObj->MapNumber) )

  00021	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00027	3c 12		 cmp	 al, 18			; 00000012H
  00029	72 22		 jb	 SHORT $LN21@gObjCheckX
  0002b	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00030	3a c8		 cmp	 cl, al
  00032	1b c9		 sbb	 ecx, ecx
  00034	41		 inc	 ecx
  00035	74 16		 je	 SHORT $LN21@gObjCheckX

; 3570 : 	{
; 3571 : 		if ( g_ChaosCastle.GetCurrentState(lpObj->MapNumber-MAP_INDEX_CHAOSCASTLE1) == 2 )

  00037	0f b6 d0	 movzx	 edx, al
  0003a	83 ea 12	 sub	 edx, 18			; 00000012H
  0003d	52		 push	 edx
  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00043	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  00048	83 f8 02	 cmp	 eax, 2

; 3572 : 		{
; 3573 : 			return FALSE;

  0004b	74 c4		 je	 SHORT $LN25@gObjCheckX
$LN21@gObjCheckX:

; 3574 : 		}
; 3575 : 	}
; 3576 : 
; 3577 : 	int x = lpObj->X;
; 3578 : 	int y = lpObj->Y;
; 3579 : 	int mapnumber = lpObj->MapNumber;

  0004d	8a 96 09 01 00
	00		 mov	 dl, BYTE PTR [esi+265]
  00053	0f b6 ca	 movzx	 ecx, dl
  00056	53		 push	 ebx
  00057	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]
  0005e	8b c1		 mov	 eax, ecx
  00060	57		 push	 edi
  00061	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]
  00068	89 45 08	 mov	 DWORD PTR _mapnumber$[ebp], eax

; 3580 : 
; 3581 : 	if ( mapnumber > MAX_NUMBER_MAP-1 )

  0006b	83 f8 27	 cmp	 eax, 39			; 00000027H
  0006e	7e 0a		 jle	 SHORT $LN12@gObjCheckX

; 3582 : 	{
; 3583 : 		mapnumber = MAP_INDEX_LORENCIA;

  00070	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _mapnumber$[ebp], 0
  00077	8b 45 08	 mov	 eax, DWORD PTR _mapnumber$[ebp]
$LN12@gObjCheckX:

; 3584 : 	}
; 3585 : 
; 3586 : 	int mapminlevel = MapMinUserLevel[mapnumber];
; 3587 : 	mapminlevel = 0;
; 3588 : 
; 3589 : 	if ( lpObj->Class == 4 || lpObj->Class == 3 )
; 3590 : 	{
; 3591 : 		if ( mapminlevel > 0 )
; 3592 : 		{
; 3593 : 			if ( MapMinUserLevel[mapnumber] > 0 )
; 3594 : 			{
; 3595 : 				mapminlevel = MapMinUserLevel[mapnumber] - (MapMinUserLevel[mapnumber] / 3 * 2);
; 3596 : 			}
; 3597 : 		}
; 3598 : 	}
; 3599 : 
; 3600 : 	if ( lpObj->Class == 2 && lpObj->Level < 10 )

  0007a	66 83 be 98 00
	00 00 02	 cmp	 WORD PTR [esi+152], 2
  00082	75 31		 jne	 SHORT $LN7@gObjCheckX
  00084	66 83 be 9c 00
	00 00 0a	 cmp	 WORD PTR [esi+156], 10	; 0000000aH
  0008c	7d 27		 jge	 SHORT $LN7@gObjCheckX

; 3601 : 	{
; 3602 : 		if ( lpObj->MapNumber != MAP_INDEX_NORIA )

  0008e	80 fa 03	 cmp	 dl, 3
  00091	74 5b		 je	 SHORT $LN4@gObjCheckX

; 3603 : 		{
; 3604 : 			LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2, 5)), lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y);

  00093	53		 push	 ebx
  00094	57		 push	 edi
  00095	51		 push	 ecx
  00096	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  00099	50		 push	 eax
  0009a	68 05 02 00 00	 push	 517			; 00000205H
  0009f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000a4	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000a9	50		 push	 eax
  000aa	6a 00		 push	 0
  000ac	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 3605 : 			PMSG_TELEPORT pMsg;
; 3606 : 			pMsg.MoveNumber = 27;
; 3607 : 			gObjMoveGate(lpObj->m_Index, pMsg.MoveNumber);

  000b1	6a 1b		 push	 27			; 0000001bH

; 3608 : 		}
; 3609 : 	}
; 3610 : 	else

  000b3	eb 2b		 jmp	 SHORT $LN24@gObjCheckX
$LN7@gObjCheckX:

; 3611 : 	{
; 3612 : 		if ( mapminlevel > lpObj->Level )

  000b5	33 d2		 xor	 edx, edx
  000b7	66 3b 96 9c 00
	00 00		 cmp	 dx, WORD PTR [esi+156]
  000be	7e 2e		 jle	 SHORT $LN4@gObjCheckX

; 3613 : 		{
; 3614 : 			LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2, 5)), lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y);

  000c0	53		 push	 ebx
  000c1	57		 push	 edi
  000c2	51		 push	 ecx
  000c3	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  000c6	50		 push	 eax
  000c7	68 05 02 00 00	 push	 517			; 00000205H
  000cc	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000d1	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000d6	50		 push	 eax
  000d7	6a 00		 push	 0
  000d9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 3615 : 			PMSG_TELEPORT pMsg;
; 3616 : 			pMsg.MoveNumber = 17;
; 3617 : 			gObjMoveGate(lpObj->m_Index, pMsg.MoveNumber);

  000de	6a 11		 push	 17			; 00000011H
$LN24@gObjCheckX:
  000e0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000e2	51		 push	 ecx
  000e3	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000e8	8b 45 08	 mov	 eax, DWORD PTR _mapnumber$[ebp]
  000eb	83 c4 20	 add	 esp, 32			; 00000020H
$LN4@gObjCheckX:

; 3618 : 		}
; 3619 : 	}
; 3620 : 
; 3621 : 	BYTE attr = MapC[mapnumber].GetAttr(x, y);

  000ee	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  000f4	53		 push	 ebx
  000f5	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  000fb	57		 push	 edi
  000fc	89 4d f8	 mov	 DWORD PTR tv341[ebp], ecx
  000ff	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 3622 : 
; 3623 : 	if ( (attr&4) == 4 || (attr&8) == 8 )

  00104	a8 0c		 test	 al, 12			; 0000000cH
  00106	0f 84 9c 00 00
	00		 je	 $LN1@gObjCheckX

; 3624 : 	{
; 3625 : 		BYTE attr2 = MapC[mapnumber].GetAttr(x+2, y);

  0010c	8b 4d f8	 mov	 ecx, DWORD PTR tv341[ebp]
  0010f	53		 push	 ebx
  00110	8d 57 02	 lea	 edx, DWORD PTR [edi+2]
  00113	52		 push	 edx
  00114	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 3626 : 		BYTE attr3 = MapC[mapnumber].GetAttr(x, y+2);

  00119	8b 4d f8	 mov	 ecx, DWORD PTR tv341[ebp]
  0011c	88 45 0b	 mov	 BYTE PTR _attr2$162903[ebp], al
  0011f	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  00122	50		 push	 eax
  00123	57		 push	 edi
  00124	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 3627 : 		BYTE attr4 = MapC[mapnumber].GetAttr(x-2, y);

  00129	53		 push	 ebx
  0012a	8d 4f fe	 lea	 ecx, DWORD PTR [edi-2]
  0012d	51		 push	 ecx
  0012e	8b 4d f8	 mov	 ecx, DWORD PTR tv341[ebp]
  00131	88 45 ff	 mov	 BYTE PTR _attr3$162904[ebp], al
  00134	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 3628 : 		BYTE attr5 = MapC[mapnumber].GetAttr(x, y-2);

  00139	8b 4d f8	 mov	 ecx, DWORD PTR tv341[ebp]
  0013c	83 c3 fe	 add	 ebx, -2			; fffffffeH
  0013f	53		 push	 ebx
  00140	57		 push	 edi
  00141	88 45 fe	 mov	 BYTE PTR _attr4$162905[ebp], al
  00144	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 3629 : 
; 3630 : 		if ( attr2 > 1 && attr3 > 1 && attr4 > 1 && attr5 > 1 )

  00149	80 7d 0b 01	 cmp	 BYTE PTR _attr2$162903[ebp], 1
  0014d	76 59		 jbe	 SHORT $LN1@gObjCheckX
  0014f	80 7d ff 01	 cmp	 BYTE PTR _attr3$162904[ebp], 1
  00153	76 53		 jbe	 SHORT $LN1@gObjCheckX
  00155	80 7d fe 01	 cmp	 BYTE PTR _attr4$162905[ebp], 1
  00159	76 4d		 jbe	 SHORT $LN1@gObjCheckX
  0015b	3c 01		 cmp	 al, 1
  0015d	76 49		 jbe	 SHORT $LN1@gObjCheckX

; 3631 : 		{
; 3632 : 			LogAdd(LOG_BLACK, "[ CHECK POSITION ] DbgName[%d] [%s][%s] Map[%d]-(%d,%d) Invalid location causes to force to move",iDbgName,lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y);

  0015f	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  00166	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR [esi+260]
  0016d	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00174	52		 push	 edx
  00175	50		 push	 eax
  00176	51		 push	 ecx
  00177	8b 4d 0c	 mov	 ecx, DWORD PTR _iDbgName$[ebp]
  0017a	8d 56 6f	 lea	 edx, DWORD PTR [esi+111]
  0017d	52		 push	 edx
  0017e	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  00181	50		 push	 eax
  00182	51		 push	 ecx
  00183	68 00 00 00 00	 push	 OFFSET ??_C@_0GB@MEEFOHBG@?$FL?5CHECK?5POSITION?5?$FN?5DbgName?$FL?$CFd?$FN?5?$FL@
  00188	6a 00		 push	 0
  0018a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 3633 : 			PMSG_TELEPORT pMsg;
; 3634 : 			pMsg.MoveNumber = 17;
; 3635 : 			gObjMoveGate(lpObj->m_Index, pMsg.MoveNumber);

  0018f	8b 16		 mov	 edx, DWORD PTR [esi]
  00191	6a 11		 push	 17			; 00000011H
  00193	52		 push	 edx
  00194	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00199	83 c4 28	 add	 esp, 40			; 00000028H
  0019c	5f		 pop	 edi
  0019d	5b		 pop	 ebx

; 3636 : 
; 3637 : 			return TRUE;

  0019e	b8 01 00 00 00	 mov	 eax, 1
  001a3	5e		 pop	 esi

; 3642 : 
; 3643 : }

  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c3		 ret	 0
$LN1@gObjCheckX:
  001a8	5f		 pop	 edi
  001a9	5b		 pop	 ebx

; 3638 : 		}
; 3639 : 	}
; 3640 : 
; 3641 : 	return FALSE;

  001aa	33 c0		 xor	 eax, eax
  001ac	5e		 pop	 esi

; 3642 : 
; 3643 : }

  001ad	8b e5		 mov	 esp, ebp
  001af	5d		 pop	 ebp
  001b0	c3		 ret	 0
?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z ENDP	; gObjCheckXYMapTile
_TEXT	ENDS
PUBLIC	??_C@_0EK@OABCCBMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$LE?Y?E?$KJ?H?$KD?$LN?$LK?$MA?G?$LL?T?5Item?5is?5Br@ ; `string'
PUBLIC	??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5Le@ ; `string'
PUBLIC	__real@4034000000000000
PUBLIC	__$ArrayPad$
PUBLIC	?gObjSpriteDamage@@YAXPAUOBJECTSTRUCT@@H@Z	; gObjSpriteDamage
EXTRN	?GCItemMoveResultSend@@YAXHEEQAE@Z:PROC		; GCItemMoveResultSend
EXTRN	?DecPetItemExp@CItem@@QAEHH@Z:PROC		; CItem::DecPetItemExp
;	COMDAT ??_C@_0EK@OABCCBMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$LE?Y?E?$KJ?H?$KD?$LN?$LK?$MA?G?$LL?T?5Item?5is?5Br@
CONST	SEGMENT
??_C@_0EK@OABCCBMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$LE?Y?E?$KJ?H?$KD?$LN?$LK?$MA?G?$LL?T?5Item?5is?5Br@ DB '['
	DB	'%s][%s] ', 0b4H, 0d9H, 0c5H, 0a9H, 0c8H, 0a3H, 0bdH, 0baH, 0c0H
	DB	0c7H, 0bbH, 0d4H, ' Item is Broken because durability is exhau'
	DB	'sted [%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5Le@
CONST	SEGMENT
??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5Le@ DB '['
	DB	'%s][%s][PetItemExpDown] [%s] Level:[%d]Exp:[%d]DecExp[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4034000000000000
CONST	SEGMENT
__real@4034000000000000 DQ 04034000000000000r	; 20
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjSpriteDamage@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
tv677 = -24						; size = 4
tv675 = -24						; size = 4
tv666 = -24						; size = 4
tv662 = -24						; size = 4
tv557 = -24						; size = 4
_DurTargetSend$163679 = -24				; size = 4
_DurTargetSend$163663 = -24				; size = 4
_itemnum$163648 = -20					; size = 4
tv702 = -18						; size = 2
tv680 = -18						; size = 2
tv669 = -18						; size = 2
tv748 = -16						; size = 4
tv746 = -16						; size = 4
tv743 = -16						; size = 4
tv739 = -16						; size = 4
tv737 = -16						; size = 4
tv734 = -16						; size = 4
tv729 = -16						; size = 4
tv726 = -16						; size = 4
tv721 = -16						; size = 4
tv718 = -16						; size = 4
tv710 = -16						; size = 4
tv708 = -16						; size = 4
tv705 = -16						; size = 4
tv699 = -16						; size = 4
tv697 = -16						; size = 4
tv628 = -16						; size = 4
_DurSend$163678 = -16					; size = 4
_i$163668 = -16						; size = 4
_DurSend$163662 = -16					; size = 4
_i$163654 = -16						; size = 4
_ItemInfo$163677 = -12					; size = 7
_ItemInfo$163661 = -12					; size = 7
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_damage$ = 12						; size = 4
?gObjSpriteDamage@@YAXPAUOBJECTSTRUCT@@H@Z PROC		; gObjSpriteDamage, COMDAT

; 5665 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]

; 5666 : 	if ( lpObj->Type != OBJ_USER )

  00014	66 83 7b 60 01	 cmp	 WORD PTR [ebx+96], 1
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	0f 85 7d 05 00
	00		 jne	 $LN1@gObjSprite

; 5667 : 	{
; 5668 : 		return;
; 5669 : 	}
; 5670 : 
; 5671 : 	int send_dur = 0;
; 5672 : 
; 5673 : 	if ( lpObj->pInventory[8].IsItem() == FALSE )

  00021	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  00027	81 c1 40 05 00
	00		 add	 ecx, 1344		; 00000540H
  0002d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00032	85 c0		 test	 eax, eax
  00034	0f 84 64 05 00
	00		 je	 $LN1@gObjSprite

; 5674 : 	{
; 5675 : 		return;
; 5676 : 	}
; 5677 : 
; 5678 : 	float fN = 10.0f;
; 5679 : 	CItem * sprite = &lpObj->pInventory[8];

  0003a	8b b3 8c 0c 00
	00		 mov	 esi, DWORD PTR [ebx+3212]

; 5680 : 	float fdamage = damage;
; 5681 : 
; 5682 : 	if ( sprite->m_Type == ITEMGET(13,0) ) // angel

  00040	0f b7 86 46 05
	00 00		 movzx	 eax, WORD PTR [esi+1350]
  00047	b9 00 1a 00 00	 mov	 ecx, 6656		; 00001a00H
  0004c	66 3b c1	 cmp	 ax, cx
  0004f	0f 85 69 01 00
	00		 jne	 $LN36@gObjSprite

; 5683 : 	{
; 5684 : 		fdamage = (damage*3)/10.0f;

  00055	8b 45 0c	 mov	 eax, DWORD PTR _damage$[ebp]

; 5685 : 		fdamage /= fN;
; 5686 : 		sprite->m_Durability -= fdamage;

  00058	d9 86 64 05 00
	00		 fld	 DWORD PTR [esi+1380]
  0005e	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00061	89 55 f0	 mov	 DWORD PTR tv748[ebp], edx
  00064	db 45 f0	 fild	 DWORD PTR tv748[ebp]
  00067	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  0006d	dc f9		 fdiv	 ST(1), ST(0)
  0006f	d9 c9		 fxch	 ST(1)
  00071	d9 5d f0	 fstp	 DWORD PTR tv746[ebp]
  00074	d8 7d f0	 fdivr	 DWORD PTR tv746[ebp]
  00077	d9 5d f0	 fstp	 DWORD PTR tv743[ebp]
  0007a	d8 65 f0	 fsub	 DWORD PTR tv743[ebp]
$LN64@gObjSprite:

; 5748 : 		}
; 5749 : 	
; 5750 : 		return;
; 5751 : 	}
; 5752 : 
; 5753 : 	if ( send_dur != FALSE )
; 5754 : 	{
; 5755 : 		GCItemDurSend(lpObj->m_Index, 8, sprite->m_Durability, 0);

  0007d	d9 7d ee	 fnstcw	 WORD PTR tv669[ebp]
  00080	6a 00		 push	 0
  00082	0f b7 45 ee	 movzx	 eax, WORD PTR tv669[ebp]
  00086	d9 9e 64 05 00
	00		 fstp	 DWORD PTR [esi+1380]
  0008c	d9 86 64 05 00
	00		 fld	 DWORD PTR [esi+1380]
  00092	8b 13		 mov	 edx, DWORD PTR [ebx]
  00094	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00099	89 45 e8	 mov	 DWORD PTR tv666[ebp], eax
  0009c	d9 6d e8	 fldcw	 WORD PTR tv666[ebp]
  0009f	db 5d e8	 fistp	 DWORD PTR tv662[ebp]
  000a2	8a 45 e8	 mov	 al, BYTE PTR tv662[ebp]
  000a5	0f b6 c8	 movzx	 ecx, al
  000a8	51		 push	 ecx
  000a9	6a 08		 push	 8
  000ab	d9 6d ee	 fldcw	 WORD PTR tv669[ebp]
  000ae	52		 push	 edx
  000af	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  000b4	83 c4 10	 add	 esp, 16			; 00000010H

; 5756 : 
; 5757 : 		if ( sprite->m_Durability < 1.0f )

  000b7	d9 e8		 fld1
  000b9	d8 9e 64 05 00
	00		 fcomp	 DWORD PTR [esi+1380]
  000bf	df e0		 fnstsw	 ax
  000c1	f6 c4 41	 test	 ah, 65			; 00000041H
  000c4	0f 85 d4 04 00
	00		 jne	 $LN1@gObjSprite

; 5758 : 		{
; 5759 : 			int itemnum = sprite->m_Type;
; 5760 : 
; 5761 : 			LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2, 10)), lpObj->AccountID, lpObj->Name,
; 5762 : 				lpObj->pInventory[8].GetName(), lpObj->pInventory[8].m_Level);

  000ca	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3212]
  000d0	0f bf 88 48 05
	00 00		 movsx	 ecx, WORD PTR [eax+1352]
  000d7	0f bf b6 46 05
	00 00		 movsx	 esi, WORD PTR [esi+1350]
  000de	51		 push	 ecx
  000df	8d 88 40 05 00
	00		 lea	 ecx, DWORD PTR [eax+1344]
  000e5	89 75 ec	 mov	 DWORD PTR _itemnum$163648[ebp], esi
  000e8	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000ed	50		 push	 eax
  000ee	8d 53 6f	 lea	 edx, DWORD PTR [ebx+111]
  000f1	52		 push	 edx
  000f2	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  000f5	50		 push	 eax
  000f6	68 0a 02 00 00	 push	 522			; 0000020aH
  000fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00100	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00105	50		 push	 eax
  00106	6a 00		 push	 0
  00108	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 5763 : 			gObjInventoryDeleteItem(lpObj->m_Index, 8);

  0010d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0010f	6a 08		 push	 8
  00111	51		 push	 ecx
  00112	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5764 : 			GCInventoryItemDeleteSend(lpObj->m_Index, 8, 0);

  00117	8b 13		 mov	 edx, DWORD PTR [ebx]
  00119	6a 00		 push	 0
  0011b	6a 08		 push	 8
  0011d	52		 push	 edx
  0011e	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 5765 : 			gObjMakePreviewCharSet(lpObj->m_Index);

  00123	8b 03		 mov	 eax, DWORD PTR [ebx]
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 5766 : 			GCEquipmentChange(lpObj->m_Index, 8);

  0012b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0012d	6a 08		 push	 8
  0012f	51		 push	 ecx
  00130	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange

; 5767 : 
; 5768 : 			if ( BC_MAP_RANGE(lpObj->MapNumber) || CC_MAP_RANGE(lpObj->MapNumber) )

  00135	8a 83 09 01 00
	00		 mov	 al, BYTE PTR [ebx+265]
  0013b	83 c4 38	 add	 esp, 56			; 00000038H
  0013e	3c 0b		 cmp	 al, 11			; 0000000bH
  00140	72 09		 jb	 SHORT $LN52@gObjSprite
  00142	b2 11		 mov	 dl, 17			; 00000011H
  00144	3a d0		 cmp	 dl, al
  00146	1b c9		 sbb	 ecx, ecx
  00148	41		 inc	 ecx
  00149	75 15		 jne	 SHORT $LN20@gObjSprite
$LN52@gObjSprite:
  0014b	3c 12		 cmp	 al, 18			; 00000012H
  0014d	0f 82 09 03 00
	00		 jb	 $LN12@gObjSprite
  00153	b1 17		 mov	 cl, 23			; 00000017H
  00155	3a c8		 cmp	 cl, al
  00157	1b c0		 sbb	 eax, eax
  00159	40		 inc	 eax
  0015a	0f 84 fc 02 00
	00		 je	 $LN12@gObjSprite
$LN20@gObjSprite:

; 5769 : 			{
; 5770 : 				if ( itemnum == ITEMGET(13,0) || itemnum == ITEMGET(13,1))

  00160	81 fe 00 1a 00
	00		 cmp	 esi, 6656		; 00001a00H
  00166	74 0c		 je	 SHORT $LN18@gObjSprite
  00168	81 fe 01 1a 00
	00		 cmp	 esi, 6657		; 00001a01H
  0016e	0f 85 e8 02 00
	00		 jne	 $LN12@gObjSprite
$LN18@gObjSprite:

; 5771 : 				{
; 5772 : 					int pos = -1;
; 5773 : 
; 5774 : 					for ( int i=MAX_PLAYER_EQUIPMENT;i<MAIN_INVENTORY_SIZE;i++)

  00174	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  00179	89 75 f0	 mov	 DWORD PTR _i$163654[ebp], esi
  0017c	bf e0 07 00 00	 mov	 edi, 2016		; 000007e0H
$LL17@gObjSprite:

; 5775 : 					{
; 5776 : 						if ( lpObj->pInventory[i].IsItem() == TRUE )

  00181	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  00187	03 cf		 add	 ecx, edi
  00189	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0018e	83 f8 01	 cmp	 eax, 1
  00191	75 14		 jne	 SHORT $LN16@gObjSprite

; 5777 : 						{
; 5778 : 							if ( lpObj->pInventory[i].m_Type == itemnum )

  00193	8b 93 8c 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3212]
  00199	0f bf 44 17 06	 movsx	 eax, WORD PTR [edi+edx+6]
  0019e	3b 45 ec	 cmp	 eax, DWORD PTR _itemnum$163648[ebp]
  001a1	0f 84 27 02 00
	00		 je	 $LN47@gObjSprite
$LN16@gObjSprite:

; 5771 : 				{
; 5772 : 					int pos = -1;
; 5773 : 
; 5774 : 					for ( int i=MAX_PLAYER_EQUIPMENT;i<MAIN_INVENTORY_SIZE;i++)

  001a7	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  001ad	46		 inc	 esi
  001ae	81 ff e0 31 00
	00		 cmp	 edi, 12768		; 000031e0H
  001b4	7c cb		 jl	 SHORT $LL17@gObjSprite
  001b6	89 75 f0	 mov	 DWORD PTR _i$163654[ebp], esi

; 5808 : 					{
; 5809 : 						if ( lpObj->pInventory[i].m_Type == ITEMGET(13,3) )

  001b9	e9 9b 02 00 00	 jmp	 $LN57@gObjSprite
$LN36@gObjSprite:

; 5687 : 		send_dur = 1;
; 5688 : 	}
; 5689 : 	else if ( sprite->m_Type == ITEMGET(13,1) )

  001be	b9 01 1a 00 00	 mov	 ecx, 6657		; 00001a01H
  001c3	66 3b c1	 cmp	 ax, cx
  001c6	75 2d		 jne	 SHORT $LN34@gObjSprite

; 5690 : 	{
; 5691 : 		fdamage = (damage*2)/10.0f;

  001c8	8b 55 0c	 mov	 edx, DWORD PTR _damage$[ebp]

; 5692 : 		fdamage /= fN;
; 5693 : 		sprite->m_Durability -= fdamage;

  001cb	d9 86 64 05 00
	00		 fld	 DWORD PTR [esi+1380]
  001d1	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  001d4	89 45 f0	 mov	 DWORD PTR tv739[ebp], eax
  001d7	db 45 f0	 fild	 DWORD PTR tv739[ebp]
  001da	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  001e0	dc f9		 fdiv	 ST(1), ST(0)
  001e2	d9 c9		 fxch	 ST(1)
  001e4	d9 5d f0	 fstp	 DWORD PTR tv737[ebp]
  001e7	d8 7d f0	 fdivr	 DWORD PTR tv737[ebp]
  001ea	d9 5d f0	 fstp	 DWORD PTR tv734[ebp]
  001ed	d8 65 f0	 fsub	 DWORD PTR tv734[ebp]

; 5694 : 		send_dur = 1;

  001f0	e9 88 fe ff ff	 jmp	 $LN64@gObjSprite
$LN34@gObjSprite:

; 5695 : 	}
; 5696 : 	else if ( sprite->m_Type == ITEMGET(13,2) )

  001f5	b9 02 1a 00 00	 mov	 ecx, 6658		; 00001a02H
  001fa	66 3b c1	 cmp	 ax, cx
  001fd	75 24		 jne	 SHORT $LN32@gObjSprite

; 5697 : 	{
; 5698 : 		fdamage = (damage)/10.0f;
; 5699 : 		fdamage /= 10.0f;
; 5700 : 		sprite->m_Durability -= fdamage;

  001ff	d9 86 64 05 00
	00		 fld	 DWORD PTR [esi+1380]
  00205	db 45 0c	 fild	 DWORD PTR _damage$[ebp]
  00208	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  0020e	dc f9		 fdiv	 ST(1), ST(0)
  00210	d9 c9		 fxch	 ST(1)
  00212	d9 5d f0	 fstp	 DWORD PTR tv729[ebp]
  00215	d8 7d f0	 fdivr	 DWORD PTR tv729[ebp]
  00218	d9 5d f0	 fstp	 DWORD PTR tv726[ebp]
  0021b	d8 65 f0	 fsub	 DWORD PTR tv726[ebp]

; 5701 : 		send_dur = 1;

  0021e	e9 5a fe ff ff	 jmp	 $LN64@gObjSprite
$LN32@gObjSprite:

; 5702 : 	}
; 5703 : 	else if ( sprite->m_Type == ITEMGET(13,3) )

  00223	ba 03 1a 00 00	 mov	 edx, 6659		; 00001a03H
  00228	66 3b c2	 cmp	 ax, dx
  0022b	75 26		 jne	 SHORT $LN30@gObjSprite

; 5704 : 	{
; 5705 : 		fdamage = (damage)/20.0f;
; 5706 : 		fdamage /= 10.0f;
; 5707 : 		sprite->m_Durability -= fdamage;

  0022d	d9 86 64 05 00
	00		 fld	 DWORD PTR [esi+1380]
  00233	db 45 0c	 fild	 DWORD PTR _damage$[ebp]
  00236	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4034000000000000
  0023c	d9 5d f0	 fstp	 DWORD PTR tv721[ebp]
  0023f	d9 45 f0	 fld	 DWORD PTR tv721[ebp]
  00242	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4024000000000000
  00248	d9 5d f0	 fstp	 DWORD PTR tv718[ebp]
  0024b	d8 65 f0	 fsub	 DWORD PTR tv718[ebp]

; 5708 : 		send_dur = 1;

  0024e	e9 2a fe ff ff	 jmp	 $LN64@gObjSprite
$LN30@gObjSprite:

; 5709 : 	}		
; 5710 : 	else if ( sprite->m_Type == ITEMGET(13,4) )

  00253	b9 04 1a 00 00	 mov	 ecx, 6660		; 00001a04H
  00258	66 3b c1	 cmp	 ax, cx
  0025b	0f 85 3d 03 00
	00		 jne	 $LN1@gObjSprite

; 5711 : 	{
; 5712 : 		if ( sprite->m_Durability < 1.0f )

  00261	d9 e8		 fld1
  00263	8d 8e 64 05 00
	00		 lea	 ecx, DWORD PTR [esi+1380]
  00269	d8 11		 fcom	 DWORD PTR [ecx]
  0026b	89 4d e8	 mov	 DWORD PTR tv557[ebp], ecx
  0026e	df e0		 fnstsw	 ax
  00270	f6 c4 41	 test	 ah, 65			; 00000041H
  00273	0f 84 23 03 00
	00		 je	 $LN59@gObjSprite

; 5713 : 		{
; 5714 : 			return;
; 5715 : 		}
; 5716 : 
; 5717 : 		fdamage = (damage*2)/10.0f;

  00279	8b 55 0c	 mov	 edx, DWORD PTR _damage$[ebp]

; 5718 : 		fdamage /= 10.0f;
; 5719 : 		fdamage += 1.0f;
; 5720 : 		sprite->m_DurabilitySmall += (int)fdamage;

  0027c	d9 7d ee	 fnstcw	 WORD PTR tv702[ebp]
  0027f	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  00282	89 45 f0	 mov	 DWORD PTR tv710[ebp], eax
  00285	db 45 f0	 fild	 DWORD PTR tv710[ebp]
  00288	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  0028e	0f b7 45 ee	 movzx	 eax, WORD PTR tv702[ebp]
  00292	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00297	dc f9		 fdiv	 ST(1), ST(0)
  00299	d9 c9		 fxch	 ST(1)
  0029b	d9 5d f0	 fstp	 DWORD PTR tv708[ebp]
  0029e	d8 7d f0	 fdivr	 DWORD PTR tv708[ebp]
  002a1	d9 5d f0	 fstp	 DWORD PTR tv705[ebp]
  002a4	d9 45 f0	 fld	 DWORD PTR tv705[ebp]
  002a7	d9 e8		 fld1
  002a9	89 45 f0	 mov	 DWORD PTR tv699[ebp], eax
  002ac	dc c1		 fadd	 ST(1), ST(0)
  002ae	d9 6d f0	 fldcw	 WORD PTR tv699[ebp]
  002b1	d9 c9		 fxch	 ST(1)
  002b3	db 5d f0	 fistp	 DWORD PTR tv697[ebp]
  002b6	66 8b 55 f0	 mov	 dx, WORD PTR tv697[ebp]
  002ba	66 01 96 68 05
	00 00		 add	 WORD PTR [esi+1384], dx

; 5721 : 
; 5722 : 		if ( sprite->m_DurabilitySmall > 1500 )

  002c1	ba dc 05 00 00	 mov	 edx, 1500		; 000005dcH
  002c6	d9 6d ee	 fldcw	 WORD PTR tv702[ebp]
  002c9	66 39 96 68 05
	00 00		 cmp	 WORD PTR [esi+1384], dx
  002d0	0f 86 c4 02 00
	00		 jbe	 $LN62@gObjSprite

; 5723 : 		{
; 5724 : 			sprite->m_Durability -= 1.0f;

  002d6	d8 29		 fsubr	 DWORD PTR [ecx]

; 5725 : 			sprite->m_DurabilitySmall = 0;

  002d8	33 c0		 xor	 eax, eax
  002da	66 89 86 68 05
	00 00		 mov	 WORD PTR [esi+1384], ax
  002e1	d9 5d f0	 fstp	 DWORD PTR tv628[ebp]
  002e4	d9 45 f0	 fld	 DWORD PTR tv628[ebp]
  002e7	d9 11		 fst	 DWORD PTR [ecx]

; 5726 : 			send_dur = 1;
; 5727 : 
; 5728 : 			if ( sprite->m_Durability < 1.0f )

  002e9	de d9		 fcompp
  002eb	df e0		 fnstsw	 ax
  002ed	f6 c4 05	 test	 ah, 5
  002f0	0f 8a 97 00 00
	00		 jp	 $LN55@gObjSprite

; 5729 : 			{
; 5730 : 				sprite->m_Durability = 0;

  002f6	d9 ee		 fldz

; 5731 : 
; 5732 : 				int iPetExperience = lpObj->pInventory[1].m_PetItem_Exp;
; 5733 : 
; 5734 : 				if ( sprite->DecPetItemExp(10) != FALSE )

  002f8	6a 0a		 push	 10			; 0000000aH
  002fa	d9 19		 fstp	 DWORD PTR [ecx]
  002fc	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  00302	8b b9 4c 01 00
	00		 mov	 edi, DWORD PTR [ecx+332]
  00308	8d 8e 40 05 00
	00		 lea	 ecx, DWORD PTR [esi+1344]
  0030e	e8 00 00 00 00	 call	 ?DecPetItemExp@CItem@@QAEHH@Z ; CItem::DecPetItemExp
  00313	85 c0		 test	 eax, eax
  00315	74 4f		 je	 SHORT $LN54@gObjSprite

; 5735 : 				{
; 5736 : 					LogAdd(LOG_BLACK, "[%s][%s][PetItemExpDown] [%s] Level:[%d]Exp:[%d]DecExp[%d]",
; 5737 : 						lpObj->AccountID, lpObj->Name, lpObj->pInventory[8].GetName(),
; 5738 : 						lpObj->pInventory[8].m_PetItem_Level, lpObj->pInventory[8].m_PetItem_Exp,
; 5739 : 						iPetExperience - lpObj->pInventory[1].m_PetItem_Exp);

  00317	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR [ebx+3212]
  0031d	2b b8 4c 01 00
	00		 sub	 edi, DWORD PTR [eax+332]
  00323	8b 90 e4 05 00
	00		 mov	 edx, DWORD PTR [eax+1508]
  00329	8b 88 e0 05 00
	00		 mov	 ecx, DWORD PTR [eax+1504]
  0032f	57		 push	 edi
  00330	52		 push	 edx
  00331	51		 push	 ecx
  00332	8d 88 40 05 00
	00		 lea	 ecx, DWORD PTR [eax+1344]
  00338	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0033d	50		 push	 eax
  0033e	8d 53 6f	 lea	 edx, DWORD PTR [ebx+111]
  00341	52		 push	 edx
  00342	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  00345	50		 push	 eax
  00346	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5Le@
  0034b	6a 00		 push	 0
  0034d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 5740 : 					CDarkSpirit::SendLevelmsg(lpObj->m_Index, 8, 1, (BYTE)-1);

  00352	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00354	68 ff 00 00 00	 push	 255			; 000000ffH
  00359	6a 01		 push	 1
  0035b	6a 08		 push	 8
  0035d	51		 push	 ecx
  0035e	e8 00 00 00 00	 call	 ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ; CDarkSpirit::SendLevelmsg
  00363	83 c4 30	 add	 esp, 48			; 00000030H
$LN54@gObjSprite:

; 5741 : 				}
; 5742 : 
; 5743 : 				LogAdd(LOG_BLACK, "[%s][%s]  Item is Broken because durability is exhausted [%d]",
; 5744 : 						lpObj->AccountID,lpObj->Name,lpObj->pInventory[8].m_Number);

  00366	8b 93 8c 0c 00
	00		 mov	 edx, DWORD PTR [ebx+3212]
  0036c	8b 82 40 05 00
	00		 mov	 eax, DWORD PTR [edx+1344]
  00372	50		 push	 eax
  00373	8d 4b 6f	 lea	 ecx, DWORD PTR [ebx+111]
  00376	51		 push	 ecx
  00377	8d 53 64	 lea	 edx, DWORD PTR [ebx+100]
  0037a	52		 push	 edx
  0037b	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OABCCBMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$LE?Y?E?$KJ?H?$KD?$LN?$LK?$MA?G?$LL?T?5Item?5is?5Br@
  00380	6a 00		 push	 0
  00382	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00387	8b 4d e8	 mov	 ecx, DWORD PTR tv557[ebp]
  0038a	83 c4 14	 add	 esp, 20			; 00000014H
$LN55@gObjSprite:

; 5745 : 			}
; 5746 : 
; 5747 : 			GCItemDurSend(lpObj->m_Index, 8, sprite->m_Durability, 0);

  0038d	d9 01		 fld	 DWORD PTR [ecx]
  0038f	8b 13		 mov	 edx, DWORD PTR [ebx]
  00391	d9 7d ee	 fnstcw	 WORD PTR tv680[ebp]
  00394	6a 00		 push	 0
  00396	0f b7 45 ee	 movzx	 eax, WORD PTR tv680[ebp]
  0039a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0039f	89 45 e8	 mov	 DWORD PTR tv677[ebp], eax
  003a2	d9 6d e8	 fldcw	 WORD PTR tv677[ebp]
  003a5	db 5d e8	 fistp	 DWORD PTR tv675[ebp]
  003a8	8a 45 e8	 mov	 al, BYTE PTR tv675[ebp]
  003ab	0f b6 c8	 movzx	 ecx, al
  003ae	51		 push	 ecx
  003af	6a 08		 push	 8
  003b1	d9 6d ee	 fldcw	 WORD PTR tv680[ebp]
  003b4	52		 push	 edx
  003b5	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  003ba	83 c4 10	 add	 esp, 16			; 00000010H

; 5835 : 				}
; 5836 : 			}
; 5837 : 		}
; 5838 : 
; 5839 : 	}
; 5840 : }

  003bd	5f		 pop	 edi
  003be	5e		 pop	 esi
  003bf	5b		 pop	 ebx
  003c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c3	33 cd		 xor	 ecx, ebp
  003c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ca	8b e5		 mov	 esp, ebp
  003cc	5d		 pop	 ebp
  003cd	c3		 ret	 0
$LN47@gObjSprite:

; 5771 : 				{
; 5772 : 					int pos = -1;
; 5773 : 
; 5774 : 					for ( int i=MAX_PLAYER_EQUIPMENT;i<MAIN_INVENTORY_SIZE;i++)

  003ce	89 75 f0	 mov	 DWORD PTR _i$163654[ebp], esi

; 5779 : 							{
; 5780 : 								pos = i;
; 5781 : 								break;
; 5782 : 							}
; 5783 : 						}
; 5784 : 					}
; 5785 : 
; 5786 : 					if ( pos != -1 )

  003d1	83 fe ff	 cmp	 esi, -1
  003d4	0f 84 7f 00 00
	00		 je	 $LN57@gObjSprite

; 5787 : 					{
; 5788 : 						BYTE ItemInfo[MAX_ITEM_INFO];
; 5789 : 						BOOL DurSend;
; 5790 : 						BOOL DurTargetSend;
; 5791 : 
; 5792 : 						ItemByteConvert(ItemInfo, lpObj->pInventory[pos]);

  003da	69 f6 a8 00 00
	00		 imul	 esi, 168		; 000000a8H
  003e0	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  003e6	03 f2		 add	 esi, edx
  003e8	8b fc		 mov	 edi, esp
  003ea	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  003ef	f3 a5		 rep movsd
  003f1	8d 4d f4	 lea	 ecx, DWORD PTR _ItemInfo$163661[ebp]
  003f4	51		 push	 ecx
  003f5	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 5793 : 						gObjInventoryMoveItem(lpObj->m_Index, pos, 8, DurSend, DurTargetSend, 0, 0, ItemInfo);

  003fa	8b 75 f0	 mov	 esi, DWORD PTR _i$163654[ebp]
  003fd	8d 55 f4	 lea	 edx, DWORD PTR _ItemInfo$163661[ebp]
  00400	52		 push	 edx
  00401	8b 13		 mov	 edx, DWORD PTR [ebx]
  00403	6a 00		 push	 0
  00405	6a 00		 push	 0
  00407	8d 45 e8	 lea	 eax, DWORD PTR _DurTargetSend$163663[ebp]
  0040a	50		 push	 eax
  0040b	8d 4d f0	 lea	 ecx, DWORD PTR _DurSend$163662[ebp]
  0040e	51		 push	 ecx
  0040f	6a 08		 push	 8
  00411	56		 push	 esi
  00412	52		 push	 edx
  00413	e8 00 00 00 00	 call	 ?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z ; gObjInventoryMoveItem

; 5794 : 						GCItemMoveResultSend(lpObj->m_Index, 0, 8, ItemInfo);

  00418	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0041a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00420	8d 45 f4	 lea	 eax, DWORD PTR _ItemInfo$163661[ebp]
  00423	50		 push	 eax
  00424	6a 08		 push	 8
  00426	6a 00		 push	 0
  00428	51		 push	 ecx
  00429	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 5795 : 						GCInventoryItemDeleteSend(lpObj->m_Index, pos, 0);

  0042e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00430	6a 00		 push	 0
  00432	56		 push	 esi
  00433	52		 push	 edx
  00434	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 5796 : 						GCServerMsgStringSend(lMsg.Get(MSGGET(4, 158)), lpObj->m_Index, 1);

  00439	8b 03		 mov	 eax, DWORD PTR [ebx]
  0043b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0043e	6a 01		 push	 1
  00440	50		 push	 eax
  00441	68 9e 04 00 00	 push	 1182			; 0000049eH
  00446	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0044b	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00450	50		 push	 eax
  00451	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00456	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@gObjSprite:
  00459	8b 75 ec	 mov	 esi, DWORD PTR _itemnum$163648[ebp]
$LN12@gObjSprite:

; 5797 : 					}
; 5798 : 				}
; 5799 : 			}
; 5800 : 				
; 5801 : 			if ( lpObj->MapNumber == MAP_INDEX_ICARUS && itemnum == ITEMGET(13,3) || lpObj->MapNumber == MAP_INDEX_ICARUS && itemnum == ITEMGET(13,37))

  0045c	8a 83 09 01 00
	00		 mov	 al, BYTE PTR [ebx+265]
  00462	3c 0a		 cmp	 al, 10			; 0000000aH
  00464	0f 85 34 01 00
	00		 jne	 $LN1@gObjSprite
  0046a	81 fe 03 1a 00
	00		 cmp	 esi, 6659		; 00001a03H
  00470	74 14		 je	 SHORT $LN10@gObjSprite
  00472	3a c0		 cmp	 al, al
  00474	0f 85 24 01 00
	00		 jne	 $LN1@gObjSprite
  0047a	81 fe 25 1a 00
	00		 cmp	 esi, 6693		; 00001a25H
  00480	0f 85 18 01 00
	00		 jne	 $LN1@gObjSprite
$LN10@gObjSprite:

; 5802 : 			{
; 5803 : 				int pos = -1;
; 5804 : 
; 5805 : 				for ( int i=MAX_PLAYER_EQUIPMENT;i<MAIN_INVENTORY_SIZE;i++)

  00486	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  0048b	89 75 f0	 mov	 DWORD PTR _i$163668[ebp], esi
  0048e	bf e0 07 00 00	 mov	 edi, 2016		; 000007e0H
$LL8@gObjSprite:

; 5806 : 				{
; 5807 : 					if ( lpObj->pInventory[i].IsItem() == TRUE )

  00493	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  00499	03 cf		 add	 ecx, edi
  0049b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  004a0	83 f8 01	 cmp	 eax, 1
  004a3	75 12		 jne	 SHORT $LN7@gObjSprite

; 5808 : 					{
; 5809 : 						if ( lpObj->pInventory[i].m_Type == ITEMGET(13,3) )

  004a5	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  004ab	ba 03 1a 00 00	 mov	 edx, 6659		; 00001a03H
  004b0	66 39 54 0f 06	 cmp	 WORD PTR [edi+ecx+6], dx
  004b5	74 14		 je	 SHORT $LN48@gObjSprite
$LN7@gObjSprite:

; 5802 : 			{
; 5803 : 				int pos = -1;
; 5804 : 
; 5805 : 				for ( int i=MAX_PLAYER_EQUIPMENT;i<MAIN_INVENTORY_SIZE;i++)

  004b7	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  004bd	46		 inc	 esi
  004be	81 ff e0 31 00
	00		 cmp	 edi, 12768		; 000031e0H
  004c4	7c cd		 jl	 SHORT $LL8@gObjSprite
  004c6	89 75 f0	 mov	 DWORD PTR _i$163668[ebp], esi

; 5808 : 					{
; 5809 : 						if ( lpObj->pInventory[i].m_Type == ITEMGET(13,3) )

  004c9	eb 08		 jmp	 SHORT $LN53@gObjSprite
$LN48@gObjSprite:

; 5802 : 			{
; 5803 : 				int pos = -1;
; 5804 : 
; 5805 : 				for ( int i=MAX_PLAYER_EQUIPMENT;i<MAIN_INVENTORY_SIZE;i++)

  004cb	89 75 f0	 mov	 DWORD PTR _i$163668[ebp], esi

; 5810 : 						{
; 5811 : 							pos = i;
; 5812 : 							break;
; 5813 : 						}
; 5814 : 					}
; 5815 : 				}
; 5816 : 
; 5817 : 				if ( pos == -1 )

  004ce	83 fe ff	 cmp	 esi, -1
  004d1	75 37		 jne	 SHORT $LN3@gObjSprite
$LN53@gObjSprite:

; 5818 : 				{
; 5819 : 					if ( lpObj->pInventory[7].IsItem() == FALSE )

  004d3	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  004d9	81 c1 98 04 00
	00		 add	 ecx, 1176		; 00000498H
  004df	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  004e4	85 c0		 test	 eax, eax
  004e6	0f 85 b2 00 00
	00		 jne	 $LN1@gObjSprite

; 5820 : 					{
; 5821 : 						gObjMoveGate(lpObj->m_Index, 22);

  004ec	8b 03		 mov	 eax, DWORD PTR [ebx]
  004ee	6a 16		 push	 22			; 00000016H
  004f0	50		 push	 eax
  004f1	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  004f6	83 c4 08	 add	 esp, 8

; 5835 : 				}
; 5836 : 			}
; 5837 : 		}
; 5838 : 
; 5839 : 	}
; 5840 : }

  004f9	5f		 pop	 edi
  004fa	5e		 pop	 esi
  004fb	5b		 pop	 ebx
  004fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004ff	33 cd		 xor	 ecx, ebp
  00501	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00506	8b e5		 mov	 esp, ebp
  00508	5d		 pop	 ebp
  00509	c3		 ret	 0
$LN3@gObjSprite:

; 5822 : 					}
; 5823 : 				}
; 5824 : 				else
; 5825 : 				{
; 5826 : 					BYTE ItemInfo[MAX_ITEM_INFO];
; 5827 : 					BOOL DurSend;
; 5828 : 					BOOL DurTargetSend;
; 5829 : 
; 5830 : 					ItemByteConvert(ItemInfo, lpObj->pInventory[pos]);

  0050a	69 f6 a8 00 00
	00		 imul	 esi, 168		; 000000a8H
  00510	03 f1		 add	 esi, ecx
  00512	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00518	8b fc		 mov	 edi, esp
  0051a	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0051f	f3 a5		 rep movsd
  00521	8d 4d f4	 lea	 ecx, DWORD PTR _ItemInfo$163677[ebp]
  00524	51		 push	 ecx
  00525	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 5831 : 					gObjInventoryMoveItem(lpObj->m_Index, pos, 8, DurSend, DurTargetSend, 0, 0, ItemInfo);

  0052a	8b 75 f0	 mov	 esi, DWORD PTR _i$163668[ebp]
  0052d	8d 55 f4	 lea	 edx, DWORD PTR _ItemInfo$163677[ebp]
  00530	52		 push	 edx
  00531	8b 13		 mov	 edx, DWORD PTR [ebx]
  00533	6a 00		 push	 0
  00535	6a 00		 push	 0
  00537	8d 45 e8	 lea	 eax, DWORD PTR _DurTargetSend$163679[ebp]
  0053a	50		 push	 eax
  0053b	8d 4d f0	 lea	 ecx, DWORD PTR _DurSend$163678[ebp]
  0053e	51		 push	 ecx
  0053f	6a 08		 push	 8
  00541	56		 push	 esi
  00542	52		 push	 edx
  00543	e8 00 00 00 00	 call	 ?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z ; gObjInventoryMoveItem

; 5832 : 					GCItemMoveResultSend(lpObj->m_Index, 0, 8, ItemInfo);

  00548	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0054a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00550	8d 45 f4	 lea	 eax, DWORD PTR _ItemInfo$163677[ebp]
  00553	50		 push	 eax
  00554	6a 08		 push	 8
  00556	6a 00		 push	 0
  00558	51		 push	 ecx
  00559	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 5833 : 					GCInventoryItemDeleteSend(lpObj->m_Index, pos, 0);

  0055e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00560	6a 00		 push	 0
  00562	56		 push	 esi
  00563	52		 push	 edx
  00564	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 5834 : 					GCServerMsgStringSend(lMsg.Get(MSGGET(4, 158)), lpObj->m_Index, 1);

  00569	8b 03		 mov	 eax, DWORD PTR [ebx]
  0056b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0056e	6a 01		 push	 1
  00570	50		 push	 eax
  00571	68 9e 04 00 00	 push	 1182			; 0000049eH
  00576	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0057b	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00580	50		 push	 eax
  00581	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00586	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5835 : 				}
; 5836 : 			}
; 5837 : 		}
; 5838 : 
; 5839 : 	}
; 5840 : }

  00589	5f		 pop	 edi
  0058a	5e		 pop	 esi
  0058b	5b		 pop	 ebx
  0058c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0058f	33 cd		 xor	 ecx, ebp
  00591	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00596	8b e5		 mov	 esp, ebp
  00598	5d		 pop	 ebp
  00599	c3		 ret	 0
$LN62@gObjSprite:

; 5721 : 
; 5722 : 		if ( sprite->m_DurabilitySmall > 1500 )

  0059a	dd d8		 fstp	 ST(0)
$LN59@gObjSprite:
  0059c	dd d8		 fstp	 ST(0)
$LN1@gObjSprite:

; 5835 : 				}
; 5836 : 			}
; 5837 : 		}
; 5838 : 
; 5839 : 	}
; 5840 : }

  0059e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005a1	5f		 pop	 edi
  005a2	5e		 pop	 esi
  005a3	33 cd		 xor	 ecx, ebp
  005a5	5b		 pop	 ebx
  005a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005ab	8b e5		 mov	 esp, ebp
  005ad	5d		 pop	 ebp
  005ae	c3		 ret	 0
?gObjSpriteDamage@@YAXPAUOBJECTSTRUCT@@H@Z ENDP		; gObjSpriteDamage
_TEXT	ENDS
PUBLIC	??_C@_0CF@CDIMOMMI@DisAppear?5TamaJJang?5?3?5Keep?5Time?5@ ; `string'
PUBLIC	??_C@_0CC@LHOBKJF@Appear?5TamaJJang?5?3?5Keep?5Time?5?$CI?$CFd@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?gObjSecondProc@@YAXXZ				; gObjSecondProc
EXTRN	?gTamaJJangDisappearTime@@3HA:DWORD		; gTamaJJangDisappearTime
EXTRN	?gTamaJJangDisappearTimeRandomRange@@3HA:DWORD	; gTamaJJangDisappearTimeRandomRange
EXTRN	?gTamaJJangKeepTime@@3HA:DWORD			; gTamaJJangKeepTime
EXTRN	?gTamaJJangTime@@3HA:DWORD			; gTamaJJangTime
EXTRN	?TimeTick@CDropEvent@@QAEXXZ:PROC		; CDropEvent::TimeTick
EXTRN	?gDropEvent@@3VCDropEvent@@A:BYTE		; gDropEvent
EXTRN	?TimeTick@CHappyHour@@QAEXXZ:PROC		; CHappyHour::TimeTick
EXTRN	?gHappyHour@@3VCHappyHour@@A:BYTE		; gHappyHour
EXTRN	?ResponErrorCloseClient@@YAXH@Z:PROC		; ResponErrorCloseClient
EXTRN	?GJUpdateMatchDBUserCharacters@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; GJUpdateMatchDBUserCharacters
EXTRN	?GCCloseMsgSend@@YAXHE@Z:PROC			; GCCloseMsgSend
EXTRN	?gCheckBattleGround@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gCheckBattleGround
EXTRN	?GCTimeViewSend@@YAXHH@Z:PROC			; GCTimeViewSend
EXTRN	?gCheckBattleGroundTimer@@YAHXZ:PROC		; gCheckBattleGroundTimer
EXTRN	?PartyMemberLifeSend@PartyClass@@QAEXH@Z:PROC	; PartyClass::PartyMemberLifeSend
EXTRN	?WeaponAct@CWeapon@@QAEXH@Z:PROC		; CWeapon::WeaponAct
EXTRN	?GuardianAct@CGuardian@@QAEXH@Z:PROC		; CGuardian::GuardianAct
EXTRN	?g_CsNPC_Guardian@@3VCGuardian@@A:DWORD		; g_CsNPC_Guardian
EXTRN	?gObjRefillMonsterHP@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; gObjRefillMonsterHP
EXTRN	?giKundunRefillHPSec@@3HA:DWORD			; giKundunRefillHPSec
EXTRN	?Run@CQeustNpcTeleport@@QAEXH@Z:PROC		; CQeustNpcTeleport::Run
;	COMDAT ??_C@_0CF@CDIMOMMI@DisAppear?5TamaJJang?5?3?5Keep?5Time?5@
CONST	SEGMENT
??_C@_0CF@CDIMOMMI@DisAppear?5TamaJJang?5?3?5Keep?5Time?5@ DB 'DisAppear '
	DB	'TamaJJang : Keep Time (%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LHOBKJF@Appear?5TamaJJang?5?3?5Keep?5Time?5?$CI?$CFd@
CONST	SEGMENT
??_C@_0CC@LHOBKJF@Appear?5TamaJJang?5?3?5Keep?5Time?5?$CI?$CFd@ DB 'Appea'
	DB	'r TamaJJang : Keep Time (%d)', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjSecondProc@@YAXXZ
_TEXT	SEGMENT
tv1164 = -140						; size = 4
_n$166230 = -136					; size = 4
_Msg$166277 = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
?gObjSecondProc@@YAXXZ PROC				; gObjSecondProc, COMDAT

; 12462: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 12463: 	if(gDisconnect == 1)

  00013	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect
  0001a	0f 84 f5 04 00
	00		 je	 $LN3@gObjSecond@2

; 12464: 		return;
; 12465: 
; 12466: 	int n;
; 12467: 	LPOBJ lpObj;
; 12468: 
; 12469: 	for(int n = 0; n < OBJMAX;n++)

  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$166230[ebp], 0
  0002d	be 98 00 00 00	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+152
$LL56@gObjSecond@2:

; 12470: 	{
; 12471: 		lpObj = &gObj[n];
; 12472: 
; 12473: 		if(lpObj->Connected > PLAYER_LOGGED)

  00032	80 be 6c ff ff
	ff 02		 cmp	 BYTE PTR [esi-148], 2
  00039	0f 86 1c 02 00
	00		 jbe	 $LN75@gObjSecond@2

; 12474: 		{
; 12475: 			if(lpObj->m_bMapSvrMoveQuit == 1)

  0003f	80 be 2c 14 00
	00 01		 cmp	 BYTE PTR [esi+5164], 1
  00046	75 27		 jne	 SHORT $LN63@gObjSecond@2

; 12476: 			{
; 12477: 				if(GetTickCount() - lpObj->m_dwMapSvrQuitTick > 30000)

  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0004e	2b 86 30 14 00
	00		 sub	 eax, DWORD PTR [esi+5168]
  00054	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00059	76 14		 jbe	 SHORT $LN63@gObjSecond@2

; 12478: 				{
; 12479: 					gObjDel(lpObj->m_Index);

  0005b	8b 86 68 ff ff
	ff		 mov	 eax, DWORD PTR [esi-152]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00067	83 c4 04	 add	 esp, 4

; 12480: 					continue;

  0006a	e9 f2 03 00 00	 jmp	 $LN55@gObjSecond@2
$LN63@gObjSecond@2:

; 12481: 				}
; 12482: 			}
; 12483: 
; 12484: 			gObjSkillUseProc(lpObj);

  0006f	8d be 68 ff ff
	ff		 lea	 edi, DWORD PTR [esi-152]
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 ?gObjSkillUseProc@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSkillUseProc

; 12485: 			gObjSkillBeAttackProc(lpObj);

  0007b	57		 push	 edi
  0007c	e8 00 00 00 00	 call	 ?gObjSkillBeAttackProc@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSkillBeAttackProc

; 12486: 
; 12487: 			if(lpObj->Type == OBJ_NPC && lpObj->Class == 229)

  00081	bb 03 00 00 00	 mov	 ebx, 3
  00086	83 c4 08	 add	 esp, 8
  00089	66 39 5e c8	 cmp	 WORD PTR [esi-56], bx
  0008d	75 1b		 jne	 SHORT $LN50@gObjSecond@2
  0008f	b9 e5 00 00 00	 mov	 ecx, 229		; 000000e5H
  00094	66 39 0e	 cmp	 WORD PTR [esi], cx
  00097	75 11		 jne	 SHORT $LN50@gObjSecond@2

; 12488: 			{
; 12489: 				gQeustNpcTeleport.Run(n);

  00099	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _n$166230[ebp]
  0009f	52		 push	 edx
  000a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A ; gQeustNpcTeleport
  000a5	e8 00 00 00 00	 call	 ?Run@CQeustNpcTeleport@@QAEXH@Z ; CQeustNpcTeleport::Run
$LN50@gObjSecond@2:

; 12490: 			}
; 12491: 
; 12492: 			if(lpObj->Type == OBJ_MONSTER)

  000aa	66 83 7e c8 02	 cmp	 WORD PTR [esi-56], 2
  000af	75 36		 jne	 SHORT $LN47@gObjSecond@2

; 12493: 			{
; 12494: 				if(lpObj->Class == 275)

  000b1	b8 13 01 00 00	 mov	 eax, 275		; 00000113H
  000b6	66 39 06	 cmp	 WORD PTR [esi], ax
  000b9	75 10		 jne	 SHORT $LN48@gObjSecond@2

; 12495: 				{
; 12496: 					gObjRefillMonsterHP(lpObj,giKundunRefillHPSec);

  000bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?giKundunRefillHPSec@@3HA ; giKundunRefillHPSec
  000c1	51		 push	 ecx
  000c2	57		 push	 edi
  000c3	e8 00 00 00 00	 call	 ?gObjRefillMonsterHP@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjRefillMonsterHP
  000c8	83 c4 08	 add	 esp, 8
$LN48@gObjSecond@2:

; 12497: 				}
; 12498: #if GS_CASTLE == 1
; 12499: 				if(lpObj->Class == 283 )
; 12500: 				{
; 12501: 					g_CsNPC_GuardianStatue.GuardianStatueAct(lpObj->m_Index);
; 12502: 					continue;
; 12503: 				}
; 12504: 
; 12505: 				if(lpObj->Class == 278 )
; 12506: 				{
; 12507: 					g_CsNPC_LifeStone.LifeStoneAct(lpObj->m_Index);
; 12508: 					continue;
; 12509: 				}
; 12510: #endif
; 12511: 				if(lpObj->Class == 285)

  000cb	ba 1d 01 00 00	 mov	 edx, 285		; 0000011dH
  000d0	66 39 16	 cmp	 WORD PTR [esi], dx
  000d3	75 12		 jne	 SHORT $LN47@gObjSecond@2

; 12512: 				{
; 12513: 					g_CsNPC_Guardian.GuardianAct(lpObj->m_Index);

  000d5	8b 07		 mov	 eax, DWORD PTR [edi]
  000d7	50		 push	 eax
  000d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Guardian@@3VCGuardian@@A ; g_CsNPC_Guardian
  000dd	e8 00 00 00 00	 call	 ?GuardianAct@CGuardian@@QAEXH@Z ; CGuardian::GuardianAct

; 12514: 					continue;

  000e2	e9 7a 03 00 00	 jmp	 $LN55@gObjSecond@2
$LN47@gObjSecond@2:

; 12515: 				}
; 12516: 
; 12517: #if GS_CASTLE == 1
; 12518: 				if(lpObj->Class == 288)
; 12519: 				{
; 12520: 					g_CsNPC_CannonTower.CannonTowerAct(lpObj->m_Index);
; 12521: 					continue;
; 12522: 				}
; 12523: #endif
; 12524: 
; 12525: 			}
; 12526: 
; 12527: 			if(lpObj->Type == OBJ_NPC)

  000e7	66 39 5e c8	 cmp	 WORD PTR [esi-56], bx
  000eb	75 24		 jne	 SHORT $LN45@gObjSecond@2

; 12528: 			{
; 12529: #if GS_CASTLE == 1
; 12530: 				if ( lpObj->Class == 216 )
; 12531: 				{
; 12532: 					g_CsNPC_CastleCrown.CastleCrownAct(lpObj->m_Index);
; 12533: 					continue;
; 12534: 				}
; 12535: 
; 12536: 				if ( CHECK_LIMIT2(lpObj->Class, 217, 219) )
; 12537: 				{
; 12538: 					g_CsNPC_CastleCrownSwitch.CastleCrownSwitchAct(lpObj->m_Index);
; 12539: 					continue;
; 12540: 				}
; 12541: 
; 12542: #endif
; 12543: 
; 12544: 				if(lpObj->Class == 221 || lpObj->Class == 222)

  000ed	0f b7 06	 movzx	 eax, WORD PTR [esi]
  000f0	b9 dd 00 00 00	 mov	 ecx, 221		; 000000ddH
  000f5	66 3b c1	 cmp	 ax, cx
  000f8	74 0a		 je	 SHORT $LN44@gObjSecond@2
  000fa	ba de 00 00 00	 mov	 edx, 222		; 000000deH
  000ff	66 3b c2	 cmp	 ax, dx
  00102	75 0d		 jne	 SHORT $LN45@gObjSecond@2
$LN44@gObjSecond@2:

; 12545: 				{
; 12546: 					g_CsNPC_Weapon.WeaponAct(lpObj->m_Index);

  00104	8b 07		 mov	 eax, DWORD PTR [edi]
  00106	50		 push	 eax
  00107	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  0010c	e8 00 00 00 00	 call	 ?WeaponAct@CWeapon@@QAEXH@Z ; CWeapon::WeaponAct
$LN45@gObjSecond@2:

; 12547: 				}
; 12548: 			}
; 12549: 
; 12550: 			if(lpObj->Type == OBJ_USER)

  00111	66 83 7e c8 01	 cmp	 WORD PTR [esi-56], 1
  00116	0f 85 38 01 00
	00		 jne	 $LN64@gObjSecond@2

; 12551: 			{
; 12552: 				gObjManaPotionFill(lpObj);

  0011c	57		 push	 edi
  0011d	e8 00 00 00 00	 call	 ?gObjManaPotionFill@@YAXPAUOBJECTSTRUCT@@@Z ; gObjManaPotionFill

; 12553: 				gObjRestPotionFill(lpObj);

  00122	57		 push	 edi
  00123	e8 00 00 00 00	 call	 ?gObjRestPotionFill@@YAXPAUOBJECTSTRUCT@@@Z ; gObjRestPotionFill

; 12554: 
; 12555: 				gObjCheckXYMapTile(lpObj,3);

  00128	53		 push	 ebx
  00129	57		 push	 edi
  0012a	e8 00 00 00 00	 call	 ?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCheckXYMapTile

; 12556: 
; 12557: 				if(lpObj->ChatLimitTime > 0)

  0012f	0f b7 46 44	 movzx	 eax, WORD PTR [esi+68]
  00133	83 c4 10	 add	 esp, 16			; 00000010H
  00136	66 85 c0	 test	 ax, ax
  00139	74 39		 je	 SHORT $LN68@gObjSecond@2

; 12558: 				{
; 12559: 					lpObj->ChatLimitTimeSec++;

  0013b	fe 46 46	 inc	 BYTE PTR [esi+70]

; 12560: 
; 12561: 					if(lpObj->ChatLimitTimeSec > 60)

  0013e	80 7e 46 3c	 cmp	 BYTE PTR [esi+70], 60	; 0000003cH
  00142	76 30		 jbe	 SHORT $LN68@gObjSecond@2

; 12562: 					{
; 12563: 						lpObj->ChatLimitTimeSec = 0;
; 12564: 						lpObj->ChatLimitTime--;

  00144	48		 dec	 eax
  00145	c6 46 46 00	 mov	 BYTE PTR [esi+70], 0
  00149	66 89 46 44	 mov	 WORD PTR [esi+68], ax

; 12565: 
; 12566: 						if(lpObj->ChatLimitTime < 1)

  0014d	66 83 f8 01	 cmp	 ax, 1
  00151	73 21		 jae	 SHORT $LN68@gObjSecond@2

; 12567: 						{
; 12568: 							lpObj->ChatLimitTime = 0;

  00153	33 c9		 xor	 ecx, ecx
  00155	66 89 4e 44	 mov	 WORD PTR [esi+68], cx

; 12569: 							MsgOutput(lpObj->m_Index,lMsg.Get(1141));

  00159	68 75 04 00 00	 push	 1141			; 00000475H
  0015e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00163	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00168	8b 17		 mov	 edx, DWORD PTR [edi]
  0016a	50		 push	 eax
  0016b	52		 push	 edx
  0016c	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00171	83 c4 08	 add	 esp, 8
$LN68@gObjSecond@2:

; 12570: 						}
; 12571: 					}
; 12572: 				}
; 12573: 
; 12574: 				if(g_iUseCharacterAutoRecuperationSystem != 0)

  00174	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iUseCharacterAutoRecuperationSystem@@3HA, 0 ; g_iUseCharacterAutoRecuperationSystem
  0017b	74 15		 je	 SHORT $LN38@gObjSecond@2

; 12575: 				{
; 12576: 					if(lpObj->Level <= g_iCharacterRecuperationMaxLevel)

  0017d	0f bf 46 04	 movsx	 eax, WORD PTR [esi+4]
  00181	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_iCharacterRecuperationMaxLevel@@3HA ; g_iCharacterRecuperationMaxLevel
  00187	7f 09		 jg	 SHORT $LN38@gObjSecond@2

; 12577: 					{
; 12578: 						gProcessAutoRecuperation(lpObj);

  00189	57		 push	 edi
  0018a	e8 00 00 00 00	 call	 ?gProcessAutoRecuperation@@YAXPAUOBJECTSTRUCT@@@Z ; gProcessAutoRecuperation
  0018f	83 c4 04	 add	 esp, 4
$LN38@gObjSecond@2:

; 12579: 					}
; 12580: 				}
; 12581: 	
; 12582: 				if(lpObj->Type == OBJ_USER && lpObj->m_LastTeleportTime > 0)

  00192	bb 01 00 00 00	 mov	 ebx, 1
  00197	66 39 5e c8	 cmp	 WORD PTR [esi-56], bx
  0019b	75 12		 jne	 SHORT $LN37@gObjSecond@2
  0019d	8a 86 89 0e 00
	00		 mov	 al, BYTE PTR [esi+3721]
  001a3	84 c0		 test	 al, al
  001a5	7e 08		 jle	 SHORT $LN37@gObjSecond@2

; 12583: 				{
; 12584: 					lpObj->m_LastTeleportTime--;

  001a7	fe c8		 dec	 al
  001a9	88 86 89 0e 00
	00		 mov	 BYTE PTR [esi+3721], al
$LN37@gObjSecond@2:

; 12585: 				}
; 12586: 	
; 12587: 				gObjDelayLifeCheck(n);

  001af	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _n$166230[ebp]
  001b5	51		 push	 ecx
  001b6	e8 00 00 00 00	 call	 ?gObjDelayLifeCheck@@YAXH@Z ; gObjDelayLifeCheck

; 12588: 				gObjSecondDurDown(lpObj);

  001bb	57		 push	 edi
  001bc	e8 00 00 00 00	 call	 ?gObjSecondDurDown@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSecondDurDown

; 12589: 	
; 12590: 				if(lpObj->PartyNumber >= 0)

  001c1	8b 86 10 02 00
	00		 mov	 eax, DWORD PTR [esi+528]
  001c7	83 c4 08	 add	 esp, 8
  001ca	85 c0		 test	 eax, eax
  001cc	78 0b		 js	 SHORT $LN36@gObjSecond@2

; 12591: 				{
; 12592: 					gParty.PartyMemberLifeSend(lpObj->PartyNumber);

  001ce	50		 push	 eax
  001cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  001d4	e8 00 00 00 00	 call	 ?PartyMemberLifeSend@PartyClass@@QAEXH@Z ; PartyClass::PartyMemberLifeSend
$LN36@gObjSecond@2:

; 12593: 				}
; 12594: 	
; 12595: 				if(lpObj->m_ShopTime >= 1 && lpObj->m_ShopTime < 255)

  001d9	8a 86 58 01 00
	00		 mov	 al, BYTE PTR [esi+344]
  001df	3c 01		 cmp	 al, 1
  001e1	72 0c		 jb	 SHORT $LN35@gObjSecond@2
  001e3	3c ff		 cmp	 al, 255			; 000000ffH
  001e5	73 08		 jae	 SHORT $LN35@gObjSecond@2

; 12596: 				{
; 12597: 					lpObj->m_ShopTime++;

  001e7	fe c0		 inc	 al
  001e9	88 86 58 01 00
	00		 mov	 BYTE PTR [esi+344], al
$LN35@gObjSecond@2:

; 12598: 				}
; 12599: 	
; 12600: 				int BattleGround = 1;
; 12601: 				int m_BattleTimer = gCheckBattleGroundTimer();

  001ef	e8 00 00 00 00	 call	 ?gCheckBattleGroundTimer@@YAHXZ ; gCheckBattleGroundTimer

; 12602: 	
; 12603: 				if((lpObj->Authority & 2) == 2)

  001f4	f6 86 0c 01 00
	00 02		 test	 BYTE PTR [esi+268], 2
  001fb	74 0e		 je	 SHORT $LN34@gObjSecond@2

; 12604: 				{
; 12605: 					BattleGround = 0;
; 12606: 					GCTimeViewSend(lpObj->m_Index,m_BattleTimer);

  001fd	8b 17		 mov	 edx, DWORD PTR [edi]
  001ff	50		 push	 eax
  00200	52		 push	 edx
  00201	33 db		 xor	 ebx, ebx
  00203	e8 00 00 00 00	 call	 ?GCTimeViewSend@@YAXHH@Z ; GCTimeViewSend
  00208	83 c4 08	 add	 esp, 8
$LN34@gObjSecond@2:

; 12607: 				}
; 12608: 	
; 12609: 				if(lpObj->MapNumber == MAP_INDEX_BATTLESOCCER && BattleGround == 1)

  0020b	80 7e 71 06	 cmp	 BYTE PTR [esi+113], 6
  0020f	75 43		 jne	 SHORT $LN64@gObjSecond@2
  00211	83 fb 01	 cmp	 ebx, 1
  00214	75 3e		 jne	 SHORT $LN64@gObjSecond@2

; 12610: 				{
; 12611: 					BattleGround = 1;
; 12612: 	
; 12613: 					if(lpObj->lpGuild != 0)

  00216	8b 86 1c 02 00
	00		 mov	 eax, DWORD PTR [esi+540]
  0021c	85 c0		 test	 eax, eax
  0021e	74 1a		 je	 SHORT $LN32@gObjSecond@2

; 12614: 					{
; 12615: 						if(lpObj->lpGuild->WarState != 0)

  00220	80 b8 91 05 00
	00 00		 cmp	 BYTE PTR [eax+1425], 0
  00227	74 11		 je	 SHORT $LN32@gObjSecond@2

; 12616: 						{
; 12617: 							int CheckBattleGround = gCheckBattleGround(lpObj);

  00229	57		 push	 edi
  0022a	e8 00 00 00 00	 call	 ?gCheckBattleGround@@YAHPAUOBJECTSTRUCT@@@Z ; gCheckBattleGround

; 12618: 	
; 12619: 							if(CheckBattleGround != lpObj->lpGuild->BattleGroundIndex)

  0022f	8b 86 1c 02 00
	00		 mov	 eax, DWORD PTR [esi+540]
  00235	83 c4 04	 add	 esp, 4

; 12620: 							{
; 12621: 								if(lpObj->lpGuild->WarType == 1)
; 12622: 								{
; 12623: 									BattleGround = 0;
; 12624: 								}
; 12625: 								else
; 12626: 								{
; 12627: 									BattleGround = 0;
; 12628: 								}
; 12629: 							}
; 12630: 							else

  00238	eb 1a		 jmp	 SHORT $LN64@gObjSecond@2
$LN32@gObjSecond@2:

; 12631: 							{
; 12632: 								BattleGround = 0;
; 12633: 							}
; 12634: 						}
; 12635: 					}
; 12636: 					else
; 12637: 					{
; 12638: 						BattleGround = 1;
; 12639: 					}
; 12640: 	
; 12641: 					if(BattleGround != 0)
; 12642: 					{
; 12643: 						int CheckBattleGround = gCheckBattleGround(lpObj);

  0023a	57		 push	 edi
  0023b	e8 00 00 00 00	 call	 ?gCheckBattleGround@@YAHPAUOBJECTSTRUCT@@@Z ; gCheckBattleGround
  00240	83 c4 04	 add	 esp, 4

; 12644: 		
; 12645: 						if(CheckBattleGround >= 0)

  00243	85 c0		 test	 eax, eax
  00245	78 0d		 js	 SHORT $LN64@gObjSecond@2

; 12646: 						{
; 12647: 							gObjMoveGate(lpObj->m_Index,17);

  00247	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00249	6a 11		 push	 17			; 00000011H
  0024b	51		 push	 ecx
  0024c	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00251	83 c4 08	 add	 esp, 8
$LN64@gObjSecond@2:

; 12648: 						}	
; 12649: 					}
; 12650: 				}
; 12651: 			}
; 12652: 		}
; 12653: 
; 12654: 		if(lpObj->Connected >= PLAYER_LOGGED && lpObj->Type == OBJ_USER && lpObj->CloseCount > 0)

  00254	80 be 6c ff ff
	ff 02		 cmp	 BYTE PTR [esi-148], 2
$LN75@gObjSecond@2:
  0025b	0f 82 d3 00 00
	00		 jb	 $LN73@gObjSecond@2
  00261	66 83 7e c8 01	 cmp	 WORD PTR [esi-56], 1
  00266	0f 85 c8 00 00
	00		 jne	 $LN73@gObjSecond@2
  0026c	8a 86 6f ff ff
	ff		 mov	 al, BYTE PTR [esi-145]
  00272	84 c0		 test	 al, al
  00274	0f 8e ba 00 00
	00		 jle	 $LN73@gObjSecond@2

; 12655: 		{
; 12656: 			if(lpObj->CloseCount == 1)

  0027a	3c 01		 cmp	 al, 1
  0027c	75 76		 jne	 SHORT $LN22@gObjSecond@2

; 12657: 			{
; 12658: 				if(lpObj->CloseType == 1)

  0027e	8a 86 70 ff ff
	ff		 mov	 al, BYTE PTR [esi-144]
  00284	3c 01		 cmp	 al, 1
  00286	75 32		 jne	 SHORT $LN21@gObjSecond@2

; 12659: 				{
; 12660: 					if(gObjGameClose(lpObj->m_Index) == 1)

  00288	8b 96 68 ff ff
	ff		 mov	 edx, DWORD PTR [esi-152]
  0028e	8d be 68 ff ff
	ff		 lea	 edi, DWORD PTR [esi-152]
  00294	52		 push	 edx
  00295	e8 00 00 00 00	 call	 ?gObjGameClose@@YAHH@Z	; gObjGameClose
  0029a	83 c4 04	 add	 esp, 4
  0029d	83 f8 01	 cmp	 eax, 1
  002a0	0f 85 88 00 00
	00		 jne	 $LN71@gObjSecond@2

; 12661: 					{
; 12662: 						GCCloseMsgSend(lpObj->m_Index,1);

  002a6	50		 push	 eax
  002a7	8b 07		 mov	 eax, DWORD PTR [edi]
  002a9	50		 push	 eax
  002aa	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend

; 12663: 						GJUpdateMatchDBUserCharacters(lpObj);

  002af	57		 push	 edi
  002b0	e8 00 00 00 00	 call	 ?GJUpdateMatchDBUserCharacters@@YAXPAUOBJECTSTRUCT@@@Z ; GJUpdateMatchDBUserCharacters
  002b5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12664: 					}
; 12665: 				}

  002b8	eb 74		 jmp	 SHORT $LN71@gObjSecond@2
$LN21@gObjSecond@2:

; 12666: 				else if(lpObj->CloseType == 0)

  002ba	84 c0		 test	 al, al
  002bc	75 1f		 jne	 SHORT $LN18@gObjSecond@2

; 12667: 				{
; 12668: 					GCCloseMsgSend(lpObj->m_Index,0);

  002be	8b 8e 68 ff ff
	ff		 mov	 ecx, DWORD PTR [esi-152]
  002c4	6a 00		 push	 0
  002c6	51		 push	 ecx
  002c7	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend

; 12669: 					CloseClient(lpObj->m_Index);

  002cc	8b 96 68 ff ff
	ff		 mov	 edx, DWORD PTR [esi-152]
  002d2	52		 push	 edx
  002d3	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  002d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002db	eb 51		 jmp	 SHORT $LN71@gObjSecond@2
$LN18@gObjSecond@2:

; 12670: 				}
; 12671: 				else if(lpObj->CloseType == 2)

  002dd	3c 02		 cmp	 al, 2
  002df	75 4d		 jne	 SHORT $LN71@gObjSecond@2

; 12672: 				{
; 12673: 					GCCloseMsgSend(lpObj->m_Index,2);

  002e1	8b 86 68 ff ff
	ff		 mov	 eax, DWORD PTR [esi-152]
  002e7	6a 02		 push	 2
  002e9	50		 push	 eax
  002ea	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  002ef	83 c4 08	 add	 esp, 8

; 12674: 				}
; 12675: 			}
; 12676: 			else

  002f2	eb 3a		 jmp	 SHORT $LN71@gObjSecond@2
$LN22@gObjSecond@2:

; 12677: 			{
; 12678: 				char Msg[128];
; 12679: 				wsprintf(Msg,lMsg.Get(1116),lpObj->CloseCount-1);

  002f4	0f be c8	 movsx	 ecx, al
  002f7	49		 dec	 ecx
  002f8	51		 push	 ecx
  002f9	68 5c 04 00 00	 push	 1116			; 0000045cH
  002fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00303	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00308	50		 push	 eax
  00309	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _Msg$166277[ebp]
  0030f	52		 push	 edx
  00310	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 12680: 				GCServerMsgStringSend(Msg,lpObj->m_Index,1);

  00316	8b 86 68 ff ff
	ff		 mov	 eax, DWORD PTR [esi-152]
  0031c	6a 01		 push	 1
  0031e	50		 push	 eax
  0031f	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _Msg$166277[ebp]
  00325	51		 push	 ecx
  00326	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0032b	83 c4 18	 add	 esp, 24			; 00000018H
$LN71@gObjSecond@2:

; 12681: 			}
; 12682: 			lpObj->CloseCount--;

  0032e	fe 8e 6f ff ff
	ff		 dec	 BYTE PTR [esi-145]
$LN73@gObjSecond@2:

; 12683: 		}
; 12684: 		if(lpObj->Connected > PLAYER_LOGGED && lpObj->Type == OBJ_USER)

  00334	80 be 6c ff ff
	ff 02		 cmp	 BYTE PTR [esi-148], 2
  0033b	76 76		 jbe	 SHORT $LN70@gObjSecond@2
  0033d	66 83 7e c8 01	 cmp	 WORD PTR [esi-56], 1
  00342	75 6f		 jne	 SHORT $LN70@gObjSecond@2

; 12685: 		{
; 12686: 			if(GetTickCount() - lpObj->AutoSaveTime > 600000)

  00344	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  0034a	ff d3		 call	 ebx
  0034c	2b 46 98	 sub	 eax, DWORD PTR [esi-104]
  0034f	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  00354	76 1d		 jbe	 SHORT $LN72@gObjSecond@2

; 12687: 			{
; 12688: 				GJSetCharacterInfo(lpObj,n,0);

  00356	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _n$166230[ebp]
  0035c	6a 00		 push	 0
  0035e	52		 push	 edx
  0035f	8d 86 68 ff ff
	ff		 lea	 eax, DWORD PTR [esi-152]
  00365	50		 push	 eax
  00366	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  0036b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12689: 				lpObj->AutoSaveTime = GetTickCount();

  0036e	ff d3		 call	 ebx
  00370	89 46 98	 mov	 DWORD PTR [esi-104], eax
$LN72@gObjSecond@2:

; 12690: 			}
; 12691: 			// ---
; 12692: 			if(lpObj->CheckSumTime > 0 && GetTickCount() - lpObj->CheckSumTime > 3000)

  00373	83 7e c4 00	 cmp	 DWORD PTR [esi-60], 0
  00377	76 1b		 jbe	 SHORT $LN12@gObjSecond@2
  00379	ff d3		 call	 ebx
  0037b	2b 46 c4	 sub	 eax, DWORD PTR [esi-60]
  0037e	3d b8 0b 00 00	 cmp	 eax, 3000		; 00000bb8H
  00383	76 0f		 jbe	 SHORT $LN12@gObjSecond@2

; 12693: 			{
; 12694: 				CloseClient(n);

  00385	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _n$166230[ebp]
  0038b	51		 push	 ecx
  0038c	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00391	83 c4 04	 add	 esp, 4
$LN12@gObjSecond@2:

; 12695: 			}
; 12696: 			// ---
; 12697: 			gObjPkDownTimeCheck(lpObj,1);

  00394	8d be 68 ff ff
	ff		 lea	 edi, DWORD PTR [esi-152]
  0039a	6a 01		 push	 1
  0039c	57		 push	 edi
  0039d	e8 00 00 00 00	 call	 ?gObjPkDownTimeCheck@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjPkDownTimeCheck

; 12698: 			gObjInterfaceTimeCheck(lpObj);

  003a2	57		 push	 edi
  003a3	e8 00 00 00 00	 call	 ?gObjInterfaceTimeCheck@@YAXPAUOBJECTSTRUCT@@@Z ; gObjInterfaceTimeCheck

; 12699: 			gObjTimeCheckSelfDefense(lpObj);

  003a8	57		 push	 edi
  003a9	e8 00 00 00 00	 call	 ?gObjTimeCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@@Z ; gObjTimeCheckSelfDefense
  003ae	83 c4 10	 add	 esp, 16			; 00000010H
  003b1	eb 06		 jmp	 SHORT $LN14@gObjSecond@2
$LN70@gObjSecond@2:
  003b3	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
$LN14@gObjSecond@2:

; 12700: 		}
; 12701: 
; 12702: 		if(lpObj->Connected == PLAYER_CONNECTED || lpObj->Connected == PLAYER_LOGGED || lpObj->Connected == PLAYER_PLAYING)

  003b9	8a 86 6c ff ff
	ff		 mov	 al, BYTE PTR [esi-148]
  003bf	3c 01		 cmp	 al, 1
  003c1	74 0c		 je	 SHORT $LN10@gObjSecond@2
  003c3	3c 02		 cmp	 al, 2
  003c5	74 08		 je	 SHORT $LN10@gObjSecond@2
  003c7	3c 03		 cmp	 al, 3
  003c9	0f 85 92 00 00
	00		 jne	 $LN55@gObjSecond@2
$LN10@gObjSecond@2:

; 12703: 		{
; 12704: 			if(lpObj->Type == OBJ_USER)

  003cf	66 83 7e c8 01	 cmp	 WORD PTR [esi-56], 1
  003d4	0f 85 87 00 00
	00		 jne	 $LN55@gObjSecond@2

; 12705: 			{
; 12706: 				if(lpObj->Connected >= PLAYER_LOGGED)

  003da	3c 02		 cmp	 al, 2
  003dc	72 38		 jb	 SHORT $LN8@gObjSecond@2

; 12707: 				{
; 12708: 					if(GetTickCount() - lpObj->ConnectCheckTime > 60000)

  003de	ff d3		 call	 ebx
  003e0	2b 46 9c	 sub	 eax, DWORD PTR [esi-100]
  003e3	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  003e8	76 77		 jbe	 SHORT $LN55@gObjSecond@2

; 12709: 					{
; 12710: 						ResponErrorCloseClient(n);

  003ea	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _n$166230[ebp]
  003f0	52		 push	 edx
  003f1	e8 00 00 00 00	 call	 ?ResponErrorCloseClient@@YAXH@Z ; ResponErrorCloseClient
  003f6	83 c4 04	 add	 esp, 4

; 12711: 						LogAdd(LOG_BLACK, lMsg.Get(542),lpObj->m_Index,lpObj->AccountID,lpObj->Name,lpObj->Ip_addr);

  003f9	8d 86 7c ff ff
	ff		 lea	 eax, DWORD PTR [esi-132]
  003ff	50		 push	 eax
  00400	8b 86 68 ff ff
	ff		 mov	 eax, DWORD PTR [esi-152]
  00406	8d 4e d7	 lea	 ecx, DWORD PTR [esi-41]
  00409	51		 push	 ecx
  0040a	8d 56 cc	 lea	 edx, DWORD PTR [esi-52]
  0040d	52		 push	 edx
  0040e	50		 push	 eax
  0040f	68 1e 02 00 00	 push	 542			; 0000021eH

; 12712: 					}
; 12713: 				}
; 12714: 				else

  00414	eb 36		 jmp	 SHORT $LN76@gObjSecond@2
$LN8@gObjSecond@2:

; 12715: 				{
; 12716: 					if(GetTickCount() - lpObj->ConnectCheckTime > 30000)

  00416	ff d3		 call	 ebx
  00418	2b 46 9c	 sub	 eax, DWORD PTR [esi-100]
  0041b	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00420	76 3f		 jbe	 SHORT $LN55@gObjSecond@2

; 12717: 					{
; 12718: 						ResponErrorCloseClient(n);

  00422	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _n$166230[ebp]
  00428	51		 push	 ecx
  00429	e8 00 00 00 00	 call	 ?ResponErrorCloseClient@@YAXH@Z ; ResponErrorCloseClient
  0042e	83 c4 04	 add	 esp, 4

; 12719: 						LogAdd(LOG_BLACK, lMsg.Get(543),lpObj->m_Index,lpObj->AccountID,lpObj->Name,lpObj->Ip_addr);

  00431	8d 96 7c ff ff
	ff		 lea	 edx, DWORD PTR [esi-132]
  00437	52		 push	 edx
  00438	8b 96 68 ff ff
	ff		 mov	 edx, DWORD PTR [esi-152]
  0043e	8d 46 d7	 lea	 eax, DWORD PTR [esi-41]
  00441	50		 push	 eax
  00442	8d 4e cc	 lea	 ecx, DWORD PTR [esi-52]
  00445	51		 push	 ecx
  00446	52		 push	 edx
  00447	68 1f 02 00 00	 push	 543			; 0000021fH
$LN76@gObjSecond@2:
  0044c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00451	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00456	50		 push	 eax
  00457	6a 00		 push	 0
  00459	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0045e	83 c4 18	 add	 esp, 24			; 00000018H
$LN55@gObjSecond@2:

; 12464: 		return;
; 12465: 
; 12466: 	int n;
; 12467: 	LPOBJ lpObj;
; 12468: 
; 12469: 	for(int n = 0; n < OBJMAX;n++)

  00461	bf 01 00 00 00	 mov	 edi, 1
  00466	01 bd 78 ff ff
	ff		 add	 DWORD PTR _n$166230[ebp], edi
  0046c	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  00472	81 fe 38 53 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522552
  00478	0f 8c b4 fb ff
	ff		 jl	 $LL56@gObjSecond@2

; 12720: 					}
; 12721: 				}
; 12722: 			}
; 12723: 		}
; 12724: 	}
; 12725: 	// ---
; 12726: 	gHappyHour.TimeTick();

  0047e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gHappyHour@@3VCHappyHour@@A ; gHappyHour
  00483	e8 00 00 00 00	 call	 ?TimeTick@CHappyHour@@QAEXXZ ; CHappyHour::TimeTick

; 12727: 	gDropEvent.TimeTick();

  00488	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDropEvent@@3VCDropEvent@@A ; gDropEvent
  0048d	e8 00 00 00 00	 call	 ?TimeTick@CDropEvent@@QAEXXZ ; CDropEvent::TimeTick

; 12728: 	// ---
; 12729: 	if( gTamaJJangEvent != 0)

  00492	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gTamaJJangEvent@@3HA, 0 ; gTamaJJangEvent
  00499	74 77		 je	 SHORT $LN74@gObjSecond@2

; 12730: 	{
; 12731: 		gTamaJJangTime--;

  0049b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gTamaJJangTime@@3HA ; gTamaJJangTime
  004a0	2b c7		 sub	 eax, edi
  004a2	a3 00 00 00 00	 mov	 DWORD PTR ?gTamaJJangTime@@3HA, eax ; gTamaJJangTime

; 12732: 
; 12733: 		if(gTamaJJangTime <= 0)

  004a7	85 c0		 test	 eax, eax
  004a9	7f 67		 jg	 SHORT $LN74@gObjSecond@2

; 12734: 		{
; 12735: 			if(gAppearTamaJJang==0)

  004ab	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gAppearTamaJJang@@3HA, 0 ; gAppearTamaJJang
  004b2	75 18		 jne	 SHORT $LN2@gObjSecond@2

; 12736: 			{
; 12737: 				gAppearTamaJJang = 1;
; 12738: 				gTamaJJangTime = gTamaJJangKeepTime;

  004b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gTamaJJangKeepTime@@3HA ; gTamaJJangKeepTime

; 12739: 				LogAdd(LOG_BLACK, "Appear TamaJJang : Keep Time (%d)",gTamaJJangTime);

  004b9	50		 push	 eax
  004ba	89 3d 00 00 00
	00		 mov	 DWORD PTR ?gAppearTamaJJang@@3HA, edi ; gAppearTamaJJang
  004c0	a3 00 00 00 00	 mov	 DWORD PTR ?gTamaJJangTime@@3HA, eax ; gTamaJJangTime
  004c5	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@LHOBKJF@Appear?5TamaJJang?5?3?5Keep?5Time?5?$CI?$CFd@

; 12740: 			}
; 12741: 			else

  004ca	eb 28		 jmp	 SHORT $LN77@gObjSecond@2
$LN2@gObjSecond@2:

; 12742: 			{
; 12743: 				gAppearTamaJJang = 0;

  004cc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gAppearTamaJJang@@3HA, 0 ; gAppearTamaJJang

; 12744: 
; 12745: 				gTamaJJangTime = gTamaJJangDisappearTime +rand()% gTamaJJangDisappearTimeRandomRange;

  004d6	e8 00 00 00 00	 call	 _rand
  004db	99		 cdq
  004dc	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?gTamaJJangDisappearTimeRandomRange@@3HA ; gTamaJJangDisappearTimeRandomRange
  004e2	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gTamaJJangDisappearTime@@3HA ; gTamaJJangDisappearTime

; 12746: 				LogAdd(LOG_BLACK, "DisAppear TamaJJang : Keep Time (%d)",gTamaJJangTime);

  004e8	52		 push	 edx
  004e9	89 15 00 00 00
	00		 mov	 DWORD PTR ?gTamaJJangTime@@3HA, edx ; gTamaJJangTime
  004ef	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CDIMOMMI@DisAppear?5TamaJJang?5?3?5Keep?5Time?5@
$LN77@gObjSecond@2:
  004f4	6a 00		 push	 0
  004f6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 12747: 			}
; 12748: 
; 12749: 			GCMapEventStateSend(0,gAppearTamaJJang,2);

  004fb	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?gAppearTamaJJang@@3HA
  00502	83 c4 0c	 add	 esp, 12			; 0000000cH
  00505	6a 02		 push	 2
  00507	50		 push	 eax
  00508	6a 00		 push	 0
  0050a	e8 00 00 00 00	 call	 ?GCMapEventStateSend@@YAXHEE@Z ; GCMapEventStateSend
  0050f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@gObjSecond@2:
  00512	5f		 pop	 edi
  00513	5e		 pop	 esi
  00514	5b		 pop	 ebx
$LN3@gObjSecond@2:

; 12750: 		}
; 12751: 	}
; 12752: }

  00515	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00518	33 cd		 xor	 ecx, ebp
  0051a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0051f	8b e5		 mov	 esp, ebp
  00521	5d		 pop	 ebp
  00522	c3		 ret	 0
?gObjSecondProc@@YAXXZ ENDP				; gObjSecondProc
_TEXT	ENDS
EXTRN	_atexit:PROC
EXTRN	??0CViewportGuild@@QAE@XZ:PROC			; CViewportGuild::CViewportGuild
; Function compile flags: /Ogtp
;	COMDAT ??__EViewGuildMng@@YAXXZ
text$yc	SEGMENT
??__EViewGuildMng@@YAXXZ PROC				; `dynamic initializer for 'ViewGuildMng'', COMDAT

; 97   : CViewportGuild ViewGuildMng;	// line : 130

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ViewGuildMng@@3VCViewportGuild@@A ; ViewGuildMng
  00005	e8 00 00 00 00	 call	 ??0CViewportGuild@@QAE@XZ ; CViewportGuild::CViewportGuild
  0000a	68 00 00 00 00	 push	 OFFSET ??__FViewGuildMng@@YAXXZ ; `dynamic atexit destructor for 'ViewGuildMng''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__EViewGuildMng@@YAXXZ ENDP				; `dynamic initializer for 'ViewGuildMng''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__EgObj@@YAXXZ
text$yc	SEGMENT
??__EgObj@@YAXXZ PROC					; `dynamic initializer for 'gObj'', COMDAT

; 101  : OBJECTSTRUCT gObj[OBJMAX];	// line : 180

  00000	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00005	68 00 00 00 00	 push	 OFFSET ??0OBJECTSTRUCT@@QAE@XZ
  0000a	68 e8 1c 00 00	 push	 7400			; 00001ce8H
  0000f	68 64 15 00 00	 push	 5476			; 00001564H
  00014	68 00 00 00 00	 push	 OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  0001e	68 00 00 00 00	 push	 OFFSET ??__FgObj@@YAXXZ	; `dynamic atexit destructor for 'gObj''
  00023	e8 00 00 00 00	 call	 _atexit
  00028	59		 pop	 ecx
  00029	c3		 ret	 0
??__EgObj@@YAXXZ ENDP					; `dynamic initializer for 'gObj''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Em_ObjBill@@YAXXZ
text$yc	SEGMENT
??__Em_ObjBill@@YAXXZ PROC				; `dynamic initializer for 'm_ObjBill'', COMDAT

; 113  : BILL_CLASS m_ObjBill[OBJMAX];	// line : 193

  00000	b9 e7 1c 00 00	 mov	 ecx, 7399		; 00001ce7H
  00005	b8 04 00 00 00	 mov	 eax, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A+4
  0000a	33 d2		 xor	 edx, edx
  0000c	8d 64 24 00	 npad	 4
$LL4@dynamic:
  00010	66 c7 40 fc ff
	00		 mov	 WORD PTR [eax-4], 255	; 000000ffH
  00016	89 10		 mov	 DWORD PTR [eax], edx
  00018	88 50 04	 mov	 BYTE PTR [eax+4], dl
  0001b	83 c0 18	 add	 eax, 24			; 00000018H
  0001e	49		 dec	 ecx
  0001f	79 ef		 jns	 SHORT $LL4@dynamic
  00021	c3		 ret	 0
??__Em_ObjBill@@YAXXZ ENDP				; `dynamic initializer for 'm_ObjBill''
text$yc	ENDS
EXTRN	??1CViewportGuild@@UAE@XZ:PROC			; CViewportGuild::~CViewportGuild
; Function compile flags: /Ogtp
;	COMDAT ??__FViewGuildMng@@YAXXZ
text$yd	SEGMENT
??__FViewGuildMng@@YAXXZ PROC				; `dynamic atexit destructor for 'ViewGuildMng'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ViewGuildMng@@3VCViewportGuild@@A ; ViewGuildMng
  00005	e9 00 00 00 00	 jmp	 ??1CViewportGuild@@UAE@XZ ; CViewportGuild::~CViewportGuild
??__FViewGuildMng@@YAXXZ ENDP				; `dynamic atexit destructor for 'ViewGuildMng''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__FgObj@@YAXXZ
text$yd	SEGMENT
??__FgObj@@YAXXZ PROC					; `dynamic atexit destructor for 'gObj'', COMDAT
  00000	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00005	68 e8 1c 00 00	 push	 7400			; 00001ce8H
  0000a	68 64 15 00 00	 push	 5476			; 00001564H
  0000f	68 00 00 00 00	 push	 OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00014	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00019	c3		 ret	 0
??__FgObj@@YAXXZ ENDP					; `dynamic atexit destructor for 'gObj''
text$yd	ENDS
PUBLIC	?m_ObjBill@@3PAVBILL_CLASS@@A			; m_ObjBill
PUBLIC	?gObj@@3PAUOBJECTSTRUCT@@A			; gObj
PUBLIC	?ViewGuildMng@@3VCViewportGuild@@A		; ViewGuildMng
_BSS	SEGMENT
?m_ObjBill@@3PAVBILL_CLASS@@A DB 02b5c0H DUP (?)	; m_ObjBill
?gObj@@3PAUOBJECTSTRUCT@@A DB 026a52a0H DUP (?)		; gObj
?ViewGuildMng@@3VCViewportGuild@@A DB 09cH DUP (?)	; ViewGuildMng
_BSS	ENDS
CRT$XCU	SEGMENT
_ViewGuildMng$initializer$ DD FLAT:??__EViewGuildMng@@YAXXZ
_gObj$initializer$ DD FLAT:??__EgObj@@YAXXZ
_m_ObjBill$initializer$ DD FLAT:??__Em_ObjBill@@YAXXZ
CRT$XCU	ENDS
END
