; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\ChaosCastle.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_iChaosCastle_OffLineGiftRate@@3HA		; g_iChaosCastle_OffLineGiftRate
CONST	SEGMENT
_g_btCastleSafetyZoneMapXY DB 017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
_g_btCastleCenterHollowZoneMapXY DB 020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
_g_iChaosCastle_ExpTable DD 01f4H
	DD	03e8H
	DD	03e8H
	DD	05dcH
	DD	05dcH
	DD	07d0H
	DD	07d0H
	DD	09c4H
	DD	09c4H
	DD	0bb8H
	DD	0bb8H
	DD	0dacH
CONST	ENDS
_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
_g_sttCHAOSCASTLE_LEVEL DD 0aH
	DD	031H
	DD	0aH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
?g_iChaosCastle_OffLineGiftRate@@3HA DD 02H		; g_iChaosCastle_OffLineGiftRate
_DATA	ENDS
PUBLIC	??0_MONSTER_ITEM_DROP@@QAE@XZ			; _MONSTER_ITEM_DROP::_MONSTER_ITEM_DROP
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.h
;	COMDAT ??0_MONSTER_ITEM_DROP@@QAE@XZ
_TEXT	SEGMENT
??0_MONSTER_ITEM_DROP@@QAE@XZ PROC			; _MONSTER_ITEM_DROP::_MONSTER_ITEM_DROP, COMDAT
; _this$ = ecx

; 123  : 	_MONSTER_ITEM_DROP()	// line : 229

  00000	8b c1		 mov	 eax, ecx

; 124  : 	{
; 125  : 		this->m_iIndex = -1;

  00002	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 126  : 		this->m_iItemKind = -1;

  00008	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 127  : 	};	// line : 232

  0000f	c3		 ret	 0
??0_MONSTER_ITEM_DROP@@QAE@XZ ENDP			; _MONSTER_ITEM_DROP::_MONSTER_ITEM_DROP
_TEXT	ENDS
PUBLIC	?Clear@_CHAOSCASTLE_USER@@QAEXXZ		; _CHAOSCASTLE_USER::Clear
; Function compile flags: /Ogtp
;	COMDAT ?Clear@_CHAOSCASTLE_USER@@QAEXXZ
_TEXT	SEGMENT
?Clear@_CHAOSCASTLE_USER@@QAEXXZ PROC			; _CHAOSCASTLE_USER::Clear, COMDAT
; _this$ = ecx

; 146  : 		this->m_iIndex = -1;
; 147  : 		this->m_iEXP = 0;

  00000	33 c0		 xor	 eax, eax
  00002	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1
  00008	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 148  : 		this->m_iScore = 0;

  0000b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 149  : 		this->m_iUserState = 0;

  0000e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 150  : 		this->m_bSendQuitMsg = false;

  00011	88 41 10	 mov	 BYTE PTR [ecx+16], al

; 151  : 	};	// line : 348

  00014	c3		 ret	 0
?Clear@_CHAOSCASTLE_USER@@QAEXXZ ENDP			; _CHAOSCASTLE_USER::Clear
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?ProcState_None@CChaosCastle@@IAEXH@Z		; CChaosCastle::ProcState_None
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
;	COMDAT ?ProcState_None@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?ProcState_None@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::ProcState_None, COMDAT
; _this$ = ecx

; 330  : 	return;
; 331  : }

  00000	c2 04 00	 ret	 4
?ProcState_None@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::ProcState_None
_TEXT	ENDS
PUBLIC	?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z	; CChaosCastle::SetMapAttrHollow
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
; Function compile flags: /Ogtp
;	COMDAT ?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
tv429 = 12						; size = 4
_iTRAP_STEP$ = 12					; size = 4
?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SetMapAttrHollow, COMDAT
; _this$ = ecx

; 754  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 755  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	0f 88 83 00 00
	00		 js	 $LN7@SetMapAttr
  0000e	33 c0		 xor	 eax, eax
  00010	83 f9 05	 cmp	 ecx, 5
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 77		 je	 SHORT $LN7@SetMapAttr

; 756  : 	{
; 757  : 		return;
; 758  : 	}
; 759  : 
; 760  : 	if ( CC_TRAP_STEP_RANGE(iTRAP_STEP) == FALSE )

  0001a	56		 push	 esi
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _iTRAP_STEP$[ebp]
  0001e	85 f6		 test	 esi, esi
  00020	78 6e		 js	 SHORT $LN25@SetMapAttr
  00022	33 c0		 xor	 eax, eax
  00024	83 fe 03	 cmp	 esi, 3
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	74 62		 je	 SHORT $LN25@SetMapAttr

; 761  : 	{
; 762  : 		return;
; 763  : 	}
; 764  : 
; 765  : 	if ( iTRAP_STEP == 0 )

  0002e	85 f6		 test	 esi, esi
  00030	74 5e		 je	 SHORT $LN25@SetMapAttr

; 766  : 	{
; 767  : 		return;
; 768  : 	}
; 769  : 
; 770  : 	for ( int a=0;a<MAX_CC_HOLLOW_ZONE;a++)

  00032	c1 e6 06	 shl	 esi, 6
  00035	53		 push	 ebx
  00036	81 c6 0c 00 00
	00		 add	 esi, OFFSET _g_iChaosCastle_MapHollowZone+12
  0003c	c7 45 0c 04 00
	00 00		 mov	 DWORD PTR tv429[ebp], 4
  00043	57		 push	 edi
$LL9@SetMapAttr:

; 771  : 	{
; 772  : 		for ( int b=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][0] ; b<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][2] ; b++)

  00044	8b 7e f4	 mov	 edi, DWORD PTR [esi-12]
  00047	3b 7e fc	 cmp	 edi, DWORD PTR [esi-4]
  0004a	7f 3a		 jg	 SHORT $LN8@SetMapAttr

; 766  : 	{
; 767  : 		return;
; 768  : 	}
; 769  : 
; 770  : 	for ( int a=0;a<MAX_CC_HOLLOW_ZONE;a++)

  0004c	8b 06		 mov	 eax, DWORD PTR [esi]
  0004e	8b ff		 npad	 2
$LL6@SetMapAttr:

; 773  : 		{
; 774  : 			for ( int c=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][1] ; c<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][3] ; c++)

  00050	8b 56 f8	 mov	 edx, DWORD PTR [esi-8]
  00053	3b d0		 cmp	 edx, eax
  00055	7f 29		 jg	 SHORT $LN5@SetMapAttr
  00057	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  0005d	8d 99 a0 7e 5a
	00		 lea	 ebx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+5930656]
  00063	8b ca		 mov	 ecx, edx
  00065	c1 e1 08	 shl	 ecx, 8
$LL3@SetMapAttr:

; 775  : 			{
; 776  : 				MapC[iChaosCastleIndex +MAP_INDEX_CHAOSCASTLE1].m_attrbuf[ c * 256 + b] |= 8;

  00068	8b 03		 mov	 eax, DWORD PTR [ebx]
  0006a	03 c1		 add	 eax, ecx
  0006c	80 0c 38 08	 or	 BYTE PTR [eax+edi], 8
  00070	8b 06		 mov	 eax, DWORD PTR [esi]
  00072	42		 inc	 edx
  00073	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00079	3b d0		 cmp	 edx, eax
  0007b	7e eb		 jle	 SHORT $LL3@SetMapAttr

; 773  : 		{
; 774  : 			for ( int c=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][1] ; c<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][3] ; c++)

  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
$LN5@SetMapAttr:

; 771  : 	{
; 772  : 		for ( int b=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][0] ; b<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][2] ; b++)

  00080	47		 inc	 edi
  00081	3b 7e fc	 cmp	 edi, DWORD PTR [esi-4]
  00084	7e ca		 jle	 SHORT $LL6@SetMapAttr
$LN8@SetMapAttr:

; 766  : 	{
; 767  : 		return;
; 768  : 	}
; 769  : 
; 770  : 	for ( int a=0;a<MAX_CC_HOLLOW_ZONE;a++)

  00086	83 c6 10	 add	 esi, 16			; 00000010H
  00089	ff 4d 0c	 dec	 DWORD PTR tv429[ebp]
  0008c	75 b6		 jne	 SHORT $LL9@SetMapAttr
  0008e	5f		 pop	 edi
  0008f	5b		 pop	 ebx
$LN25@SetMapAttr:
  00090	5e		 pop	 esi
$LN7@SetMapAttr:

; 777  : 			}
; 778  : 		}
; 779  : 	}
; 780  : 	
; 781  : }

  00091	5d		 pop	 ebp
  00092	c2 08 00	 ret	 8
?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SetMapAttrHollow
_TEXT	ENDS
PUBLIC	?SetMapAttrFill@CChaosCastle@@QAEXH@Z		; CChaosCastle::SetMapAttrFill
; Function compile flags: /Ogtp
;	COMDAT ?SetMapAttrFill@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
tv420 = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SetMapAttrFill@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::SetMapAttrFill, COMDAT
; _this$ = ecx

; 784  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 785  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 c9		 test	 ecx, ecx
  00009	78 76		 js	 SHORT $LN10@SetMapAttr@2
  0000b	33 c0		 xor	 eax, eax
  0000d	83 f9 05	 cmp	 ecx, 5
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	74 6a		 je	 SHORT $LN10@SetMapAttr@2

; 786  : 	{
; 787  : 		return;
; 788  : 	}
; 789  : 	
; 790  : 	for ( int iTRAP_STEP=1;iTRAP_STEP<MAX_CC_TRAP_STEP;iTRAP_STEP++)

  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	be 4c 00 00 00	 mov	 esi, OFFSET _g_iChaosCastle_MapHollowZone+76
  0001f	90		 npad	 1
$LL12@SetMapAttr@2:

; 791  : 	{
; 792  : 		for ( int a=0;a<MAX_CC_HOLLOW_ZONE;a++)

  00020	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR tv420[ebp], 4
$LL9@SetMapAttr@2:

; 793  : 		{
; 794  : 			for ( int b=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][0] ; b<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][2] ; b++)

  00027	8b 7e f4	 mov	 edi, DWORD PTR [esi-12]
  0002a	3b 7e fc	 cmp	 edi, DWORD PTR [esi-4]
  0002d	7f 3f		 jg	 SHORT $LN8@SetMapAttr@2
  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
$LL6@SetMapAttr@2:

; 795  : 			{
; 796  : 				for ( int c=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][1] ; c<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][3] ; c++)

  00031	8b 56 f8	 mov	 edx, DWORD PTR [esi-8]
  00034	3b d0		 cmp	 edx, eax
  00036	7f 30		 jg	 SHORT $LN5@SetMapAttr@2
  00038	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  0003e	8d 99 a0 7e 5a
	00		 lea	 ebx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+5930656]
  00044	8b ca		 mov	 ecx, edx
  00046	c1 e1 08	 shl	 ecx, 8
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL3@SetMapAttr@2:

; 797  : 				{
; 798  : 					MapC[iChaosCastleIndex +MAP_INDEX_CHAOSCASTLE1].m_attrbuf[ c * 256 + b] &= ~8;

  00050	8b 03		 mov	 eax, DWORD PTR [ebx]
  00052	03 c1		 add	 eax, ecx
  00054	80 24 38 f7	 and	 BYTE PTR [eax+edi], 247	; 000000f7H
  00058	8b 06		 mov	 eax, DWORD PTR [esi]
  0005a	42		 inc	 edx
  0005b	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00061	3b d0		 cmp	 edx, eax
  00063	7e eb		 jle	 SHORT $LL3@SetMapAttr@2

; 795  : 			{
; 796  : 				for ( int c=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][1] ; c<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][3] ; c++)

  00065	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
$LN5@SetMapAttr@2:

; 793  : 		{
; 794  : 			for ( int b=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][0] ; b<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][2] ; b++)

  00068	47		 inc	 edi
  00069	3b 7e fc	 cmp	 edi, DWORD PTR [esi-4]
  0006c	7e c3		 jle	 SHORT $LL6@SetMapAttr@2
$LN8@SetMapAttr@2:

; 791  : 	{
; 792  : 		for ( int a=0;a<MAX_CC_HOLLOW_ZONE;a++)

  0006e	83 c6 10	 add	 esi, 16			; 00000010H
  00071	ff 4d fc	 dec	 DWORD PTR tv420[ebp]
  00074	75 b1		 jne	 SHORT $LL9@SetMapAttr@2

; 786  : 	{
; 787  : 		return;
; 788  : 	}
; 789  : 	
; 790  : 	for ( int iTRAP_STEP=1;iTRAP_STEP<MAX_CC_TRAP_STEP;iTRAP_STEP++)

  00076	81 fe 0c 01 00
	00		 cmp	 esi, OFFSET _g_iChaosCastle_MapHollowZone+268
  0007c	7c a2		 jl	 SHORT $LL12@SetMapAttr@2
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
$LN10@SetMapAttr@2:

; 799  : 				}
; 800  : 			}
; 801  : 		}
; 802  : 	}
; 803  : }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
?SetMapAttrFill@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::SetMapAttrFill
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	?SetState_None@CChaosCastle@@IAEXH@Z		; CChaosCastle::SetState_None
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
;	COMDAT ?SetState_None@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?SetState_None@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::SetState_None, COMDAT
; _this$ = ecx

; 872  : 	return;
; 873  : }

  00000	c2 04 00	 ret	 4
?SetState_None@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::SetState_None
_TEXT	ENDS
PUBLIC	?ClearMonster@CChaosCastle@@QAEXH@Z		; CChaosCastle::ClearMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:BYTE			; gObj
; Function compile flags: /Ogtp
;	COMDAT ?ClearMonster@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?ClearMonster@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::ClearMonster, COMDAT
; _this$ = ecx

; 973  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 974  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 3b		 js	 SHORT $LN2@ClearMonst
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 f8 05	 cmp	 eax, 5
  0000f	0f 9e c1	 setle	 cl
  00012	85 c9		 test	 ecx, ecx
  00014	74 2f		 je	 SHORT $LN2@ClearMonst

; 975  : 	{
; 976  : 		return;
; 977  : 	}
; 978  : 
; 979  : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	33 ff		 xor	 edi, edi
  0001b	8d 58 12	 lea	 ebx, DWORD PTR [eax+18]
  0001e	be 09 01 00 00	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+265
$LL4@ClearMonst:

; 980  : 	{
; 981  : 		if ( gObj[n].MapNumber == (iChaosCastleIndex+MAP_INDEX_CHAOSCASTLE1))

  00023	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00026	3b c3		 cmp	 eax, ebx
  00028	75 09		 jne	 SHORT $LN3@ClearMonst

; 982  : 		{
; 983  : 			gObjDel(n);

  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00030	83 c4 04	 add	 esp, 4
$LN3@ClearMonst:

; 975  : 	{
; 976  : 		return;
; 977  : 	}
; 978  : 
; 979  : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  00033	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  00039	47		 inc	 edi
  0003a	81 fe a9 a2 e4
	01		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+31761065
  00040	7c e1		 jl	 SHORT $LL4@ClearMonst
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
$LN2@ClearMonst:

; 984  : 		}
; 985  : 	}
; 986  : }

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?ClearMonster@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::ClearMonster
_TEXT	ENDS
PUBLIC	?AddMonsterList@CChaosCastle@@QAEXHH@Z		; CChaosCastle::AddMonsterList
EXTRN	__imp__InterlockedExchange@8:PROC
; Function compile flags: /Ogtp
;	COMDAT ?AddMonsterList@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
_iMonsterIndex$ = 12					; size = 4
?AddMonsterList@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::AddMonsterList, COMDAT
; _this$ = ecx

; 1051 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1052 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 4a		 js	 SHORT $LN2@AddMonster
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fe 05	 cmp	 esi, 5
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	74 3e		 je	 SHORT $LN2@AddMonster

; 1053 : 	{
; 1054 : 		return;
; 1055 : 	}
; 1056 : 
; 1057 : 	for ( int iMON =0;iMON<MAX_CC_MONSTERS;iMON++)

  00017	8b d6		 mov	 edx, esi
  00019	33 c0		 xor	 eax, eax
  0001b	69 d2 6c 08 00
	00		 imul	 edx, 2156		; 0000086cH
  00021	8d 94 0a e4 05
	00 00		 lea	 edx, DWORD PTR [edx+ecx+1508]
$LL4@AddMonster:

; 1058 : 	{
; 1059 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == -1 )

  00028	83 3a ff	 cmp	 DWORD PTR [edx], -1
  0002b	74 0e		 je	 SHORT $LN11@AddMonster

; 1053 : 	{
; 1054 : 		return;
; 1055 : 	}
; 1056 : 
; 1057 : 	for ( int iMON =0;iMON<MAX_CC_MONSTERS;iMON++)

  0002d	40		 inc	 eax
  0002e	83 c2 04	 add	 edx, 4
  00031	83 f8 64	 cmp	 eax, 100		; 00000064H
  00034	7c f2		 jl	 SHORT $LL4@AddMonster
  00036	5e		 pop	 esi

; 1062 : 			break;
; 1063 : 		}
; 1064 : 	}
; 1065 : }

  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
$LN11@AddMonster:

; 1060 : 		{
; 1061 : 			InterlockedExchange((LPLONG)&this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON], iMonsterIndex);

  0003b	8b 55 0c	 mov	 edx, DWORD PTR _iMonsterIndex$[ebp]
  0003e	69 f6 1b 02 00
	00		 imul	 esi, 539		; 0000021bH
  00044	03 f0		 add	 esi, eax
  00046	52		 push	 edx
  00047	8d 84 b1 e4 05
	00 00		 lea	 eax, DWORD PTR [ecx+esi*4+1508]
  0004e	50		 push	 eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8
$LN2@AddMonster:
  00055	5e		 pop	 esi

; 1062 : 			break;
; 1063 : 		}
; 1064 : 	}
; 1065 : }

  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
?AddMonsterList@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::AddMonsterList
_TEXT	ENDS
PUBLIC	??_C@_0EI@EFJJJNMJ@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@ ; `string'
PUBLIC	??_C@_0EK@BMJDNMGE@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@ ; `string'
PUBLIC	?DelMonsterList@CChaosCastle@@QAEXHH@Z		; CChaosCastle::DelMonsterList
EXTRN	__imp__InterlockedDecrement@4:PROC
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
;	COMDAT ??_C@_0EI@EFJJJNMJ@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@
CONST	SEGMENT
??_C@_0EI@EFJJJNMJ@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@ DB '['
	DB	'Chaos Castle][Bug Tracer] MONSTER DEL (%d) Count(%d) : OUT - '
	DB	'Index(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@BMJDNMGE@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@
CONST	SEGMENT
??_C@_0EK@BMJDNMGE@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@ DB '['
	DB	'Chaos Castle][Bug Tracer] MONSTER DEL (%d) Count(%d) : ENTER '
	DB	'- Index(%d)', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DelMonsterList@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
tv200 = 8						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iMonsterIndex$ = 12					; size = 4
?DelMonsterList@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::DelMonsterList, COMDAT
; _this$ = ecx

; 1068 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1069 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00005	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000b	85 f6		 test	 esi, esi
  0000d	0f 88 9d 00 00
	00		 js	 $LN7@DelMonster
  00013	33 c0		 xor	 eax, eax
  00015	83 fe 05	 cmp	 esi, 5
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 8d 00 00
	00		 je	 $LN7@DelMonster

; 1070 : 	{
; 1071 : 		return;
; 1072 : 	}
; 1073 : 
; 1074 : 	LogAdd(LOG_BLACK, "[Chaos Castle][Bug Tracer] MONSTER DEL (%d) Count(%d) : ENTER - Index(%d)",
; 1075 : 		iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT, iMonsterIndex);

  00023	53		 push	 ebx
  00024	57		 push	 edi
  00025	8b fe		 mov	 edi, esi
  00027	69 ff 6c 08 00
	00		 imul	 edi, 2156		; 0000086cH
  0002d	03 f9		 add	 edi, ecx
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _iMonsterIndex$[ebp]
  00032	8b 57 60	 mov	 edx, DWORD PTR [edi+96]
  00035	51		 push	 ecx
  00036	8d 5f 60	 lea	 ebx, DWORD PTR [edi+96]
  00039	52		 push	 edx
  0003a	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0003d	50		 push	 eax
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@BMJDNMGE@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@
  00043	6a 00		 push	 0
  00045	89 45 08	 mov	 DWORD PTR tv200[ebp], eax
  00048	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0004d	83 c4 14	 add	 esp, 20			; 00000014H

; 1076 : 
; 1077 : 	for ( int iMON =0;iMON<MAX_CC_MONSTERS;iMON++)

  00050	33 c0		 xor	 eax, eax
  00052	8d 8f e4 05 00
	00		 lea	 ecx, DWORD PTR [edi+1508]
$LL5@DelMonster:

; 1078 : 	{
; 1079 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == iMonsterIndex )

  00058	8b 7d 0c	 mov	 edi, DWORD PTR _iMonsterIndex$[ebp]
  0005b	39 39		 cmp	 DWORD PTR [ecx], edi
  0005d	74 0b		 je	 SHORT $LN12@DelMonster

; 1076 : 
; 1077 : 	for ( int iMON =0;iMON<MAX_CC_MONSTERS;iMON++)

  0005f	40		 inc	 eax
  00060	83 c1 04	 add	 ecx, 4
  00063	83 f8 64	 cmp	 eax, 100		; 00000064H
  00066	7c f0		 jl	 SHORT $LL5@DelMonster

; 1078 : 	{
; 1079 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == iMonsterIndex )

  00068	eb 1b		 jmp	 SHORT $LN3@DelMonster
$LN12@DelMonster:

; 1080 : 		{
; 1081 : 			InterlockedExchange(&this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON], -1);

  0006a	69 f6 1b 02 00
	00		 imul	 esi, 539		; 0000021bH
  00070	03 f0		 add	 esi, eax
  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	6a ff		 push	 -1
  00077	8d 8c b0 e4 05
	00 00		 lea	 ecx, DWORD PTR [eax+esi*4+1508]
  0007e	51		 push	 ecx
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8
$LN3@DelMonster:

; 1082 : 			break;
; 1083 : 		}
; 1084 : 	}
; 1085 : 
; 1086 : 	InterlockedDecrement(&this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT);

  00085	53		 push	 ebx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4

; 1087 : 
; 1088 : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT < 0 )

  0008c	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  0008f	7d 06		 jge	 SHORT $LN1@DelMonster

; 1089 : 	{
; 1090 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT = 0;

  00091	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN1@DelMonster:

; 1091 : 	}
; 1092 : 
; 1093 : 	LogAdd(LOG_BLACK, "[Chaos Castle][Bug Tracer] MONSTER DEL (%d) Count(%d) : OUT - Index(%d)",
; 1094 : 		iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT, iMonsterIndex);

  00097	8b 13		 mov	 edx, DWORD PTR [ebx]
  00099	8b 45 08	 mov	 eax, DWORD PTR tv200[ebp]
  0009c	57		 push	 edi
  0009d	52		 push	 edx
  0009e	50		 push	 eax
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EFJJJNMJ@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@
  000a4	6a 00		 push	 0
  000a6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	5f		 pop	 edi
  000af	5b		 pop	 ebx
$LN7@DelMonster:
  000b0	5e		 pop	 esi

; 1095 : }

  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 08 00	 ret	 8
?DelMonsterList@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::DelMonsterList
_TEXT	ENDS
PUBLIC	?GetMonsterListCount@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetMonsterListCount
; Function compile flags: /Ogtp
;	COMDAT ?GetMonsterListCount@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?GetMonsterListCount@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetMonsterListCount, COMDAT
; _this$ = ecx

; 1098 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1099 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 0c		 js	 SHORT $LN18@GetMonster
  0000a	33 c0		 xor	 eax, eax
  0000c	83 f9 05	 cmp	 ecx, 5
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	75 07		 jne	 SHORT $LN6@GetMonster
$LN18@GetMonster:

; 1100 : 	{
; 1101 : 		return -1;

  00016	83 c8 ff	 or	 eax, -1

; 1116 : 			}
; 1117 : 		}
; 1118 : 	}
; 1119 : 	
; 1120 : 	return iAliveMonsterCount;
; 1121 : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN6@GetMonster:
  0001d	53		 push	 ebx
  0001e	56		 push	 esi

; 1102 : 	}
; 1103 : 
; 1104 : 	int iAliveMonsterCount = 0;

  0001f	33 c0		 xor	 eax, eax

; 1105 : 	int iMapNumber = iChaosCastleIndex + 18;

  00021	8d 51 12	 lea	 edx, DWORD PTR [ecx+18]
  00024	57		 push	 edi
  00025	b9 60 00 00 00	 mov	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+96
  0002a	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  0002d	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
$LL5@GetMonster:

; 1108 : 	{
; 1109 : 		if ( gObj[i].Connected == PLAYER_PLAYING &&
; 1110 : 			 gObj[i].Type == OBJ_MONSTER &&
; 1111 : 			 gObj[i].Live == 1) 

  00030	80 79 a4 03	 cmp	 BYTE PTR [ecx-92], 3
  00034	75 17		 jne	 SHORT $LN4@GetMonster
  00036	66 39 31	 cmp	 WORD PTR [ecx], si
  00039	75 12		 jne	 SHORT $LN4@GetMonster
  0003b	38 59 02	 cmp	 BYTE PTR [ecx+2], bl
  0003e	75 0d		 jne	 SHORT $LN4@GetMonster

; 1112 : 		{
; 1113 : 			if ( gObj[i].MapNumber == iMapNumber )

  00040	0f b6 b9 a9 00
	00 00		 movzx	 edi, BYTE PTR [ecx+169]
  00047	3b fa		 cmp	 edi, edx
  00049	75 02		 jne	 SHORT $LN4@GetMonster

; 1114 : 			{
; 1115 : 				iAliveMonsterCount++;

  0004b	03 c3		 add	 eax, ebx
$LN4@GetMonster:

; 1108 : 	{
; 1109 : 		if ( gObj[i].Connected == PLAYER_PLAYING &&
; 1110 : 			 gObj[i].Type == OBJ_MONSTER &&
; 1111 : 			 gObj[i].Live == 1) 

  0004d	80 b9 08 15 00
	00 03		 cmp	 BYTE PTR [ecx+5384], 3
  00054	75 1e		 jne	 SHORT $LN14@GetMonster
  00056	66 39 b1 64 15
	00 00		 cmp	 WORD PTR [ecx+5476], si
  0005d	75 15		 jne	 SHORT $LN14@GetMonster
  0005f	38 99 66 15 00
	00		 cmp	 BYTE PTR [ecx+5478], bl
  00065	75 0d		 jne	 SHORT $LN14@GetMonster

; 1112 : 		{
; 1113 : 			if ( gObj[i].MapNumber == iMapNumber )

  00067	0f b6 b9 0d 16
	00 00		 movzx	 edi, BYTE PTR [ecx+5645]
  0006e	3b fa		 cmp	 edi, edx
  00070	75 02		 jne	 SHORT $LN14@GetMonster

; 1114 : 			{
; 1115 : 				iAliveMonsterCount++;

  00072	03 c3		 add	 eax, ebx
$LN14@GetMonster:

; 1108 : 	{
; 1109 : 		if ( gObj[i].Connected == PLAYER_PLAYING &&
; 1110 : 			 gObj[i].Type == OBJ_MONSTER &&
; 1111 : 			 gObj[i].Live == 1) 

  00074	80 b9 6c 2a 00
	00 03		 cmp	 BYTE PTR [ecx+10860], 3
  0007b	75 1e		 jne	 SHORT $LN15@GetMonster
  0007d	66 39 b1 c8 2a
	00 00		 cmp	 WORD PTR [ecx+10952], si
  00084	75 15		 jne	 SHORT $LN15@GetMonster
  00086	38 99 ca 2a 00
	00		 cmp	 BYTE PTR [ecx+10954], bl
  0008c	75 0d		 jne	 SHORT $LN15@GetMonster

; 1112 : 		{
; 1113 : 			if ( gObj[i].MapNumber == iMapNumber )

  0008e	0f b6 b9 71 2b
	00 00		 movzx	 edi, BYTE PTR [ecx+11121]
  00095	3b fa		 cmp	 edi, edx
  00097	75 02		 jne	 SHORT $LN15@GetMonster

; 1114 : 			{
; 1115 : 				iAliveMonsterCount++;

  00099	03 c3		 add	 eax, ebx
$LN15@GetMonster:

; 1108 : 	{
; 1109 : 		if ( gObj[i].Connected == PLAYER_PLAYING &&
; 1110 : 			 gObj[i].Type == OBJ_MONSTER &&
; 1111 : 			 gObj[i].Live == 1) 

  0009b	80 b9 d0 3f 00
	00 03		 cmp	 BYTE PTR [ecx+16336], 3
  000a2	75 1e		 jne	 SHORT $LN16@GetMonster
  000a4	66 39 b1 2c 40
	00 00		 cmp	 WORD PTR [ecx+16428], si
  000ab	75 15		 jne	 SHORT $LN16@GetMonster
  000ad	38 99 2e 40 00
	00		 cmp	 BYTE PTR [ecx+16430], bl
  000b3	75 0d		 jne	 SHORT $LN16@GetMonster

; 1112 : 		{
; 1113 : 			if ( gObj[i].MapNumber == iMapNumber )

  000b5	0f b6 b9 d5 40
	00 00		 movzx	 edi, BYTE PTR [ecx+16597]
  000bc	3b fa		 cmp	 edi, edx
  000be	75 02		 jne	 SHORT $LN16@GetMonster

; 1114 : 			{
; 1115 : 				iAliveMonsterCount++;

  000c0	03 c3		 add	 eax, ebx
$LN16@GetMonster:

; 1108 : 	{
; 1109 : 		if ( gObj[i].Connected == PLAYER_PLAYING &&
; 1110 : 			 gObj[i].Type == OBJ_MONSTER &&
; 1111 : 			 gObj[i].Live == 1) 

  000c2	80 b9 34 55 00
	00 03		 cmp	 BYTE PTR [ecx+21812], 3
  000c9	75 1e		 jne	 SHORT $LN17@GetMonster
  000cb	66 39 b1 90 55
	00 00		 cmp	 WORD PTR [ecx+21904], si
  000d2	75 15		 jne	 SHORT $LN17@GetMonster
  000d4	38 99 92 55 00
	00		 cmp	 BYTE PTR [ecx+21906], bl
  000da	75 0d		 jne	 SHORT $LN17@GetMonster

; 1112 : 		{
; 1113 : 			if ( gObj[i].MapNumber == iMapNumber )

  000dc	0f b6 b9 39 56
	00 00		 movzx	 edi, BYTE PTR [ecx+22073]
  000e3	3b fa		 cmp	 edi, edx
  000e5	75 02		 jne	 SHORT $LN17@GetMonster

; 1114 : 			{
; 1115 : 				iAliveMonsterCount++;

  000e7	03 c3		 add	 eax, ebx
$LN17@GetMonster:

; 1102 : 	}
; 1103 : 
; 1104 : 	int iAliveMonsterCount = 0;

  000e9	81 c1 f4 6a 00
	00		 add	 ecx, 27380		; 00006af4H

; 1106 : 
; 1107 : 	for (int i=0;i<OBJ_STARTUSERINDEX;i++)

  000ef	81 f9 60 c4 16
	02		 cmp	 ecx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046496
  000f5	0f 8c 35 ff ff
	ff		 jl	 $LL5@GetMonster
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 1116 : 			}
; 1117 : 		}
; 1118 : 	}
; 1119 : 	
; 1120 : 	return iAliveMonsterCount;
; 1121 : }

  000fe	5d		 pop	 ebp
  000ff	c2 04 00	 ret	 4
?GetMonsterListCount@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetMonsterListCount
_TEXT	ENDS
PUBLIC	?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z	; CChaosCastle::SendAllUserAnyMsg
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
; Function compile flags: /Ogtp
;	COMDAT ?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z PROC	; CChaosCastle::SendAllUserAnyMsg, COMDAT
; _this$ = ecx

; 1206 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1207 : 	for ( int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _iSize$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	bf 00 19 00 00	 mov	 edi, 6400		; 00001900H
  0000e	be 60 c4 16 02	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046496
$LL5@SendAllUse:

; 1208 : 	{
; 1209 : 		if ( gObj[i].Connected == PLAYER_PLAYING )

  00013	80 7e a4 03	 cmp	 BYTE PTR [esi-92], 3
  00017	75 14		 jne	 SHORT $LN4@SendAllUse

; 1210 : 		{
; 1211 : 			if ( gObj[i].Type == OBJ_USER )

  00019	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  0001d	75 0e		 jne	 SHORT $LN4@SendAllUse

; 1212 : 			{
; 1213 : 				DataSend(i, lpMsg, iSize);

  0001f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00022	53		 push	 ebx
  00023	50		 push	 eax
  00024	57		 push	 edi
  00025	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendAllUse:

; 1207 : 	for ( int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  0002d	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  00033	47		 inc	 edi
  00034	81 fe 00 53 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522496
  0003a	7c d7		 jl	 SHORT $LL5@SendAllUse
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 1214 : 			}
; 1215 : 		}
; 1216 : 	}
; 1217 : }

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z ENDP	; CChaosCastle::SendAllUserAnyMsg
_TEXT	ENDS
PUBLIC	?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
; Function compile flags: /Ogtp
;	COMDAT ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
_iChaosCastleIndex$ = 16				; size = 4
?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z PROC	; CChaosCastle::SendChaosCastleAnyMsg, COMDAT
; _this$ = ecx

; 1220 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1221 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 10	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 6d		 js	 SHORT $LN4@SendChaosC
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 05	 cmp	 eax, 5
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	74 61		 je	 SHORT $LN4@SendChaosC

; 1222 : 	{
; 1223 : 		return;
; 1224 : 	}
; 1225 : 
; 1226 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00016	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8d 74 08 6c	 lea	 esi, DWORD PTR [eax+ecx+108]
  00023	bf 46 00 00 00	 mov	 edi, 70			; 00000046H
  00028	83 cb ff	 or	 ebx, -1
  0002b	eb 03 8d 49 00	 npad	 5
$LL6@SendChaosC:

; 1227 : 	{
; 1228 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	3b c3		 cmp	 eax, ebx
  00034	74 38		 je	 SHORT $LN5@SendChaosC

; 1229 : 		{
; 1230 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) != FALSE )

  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003c	83 c4 04	 add	 esp, 4
  0003f	85 c0		 test	 eax, eax
  00041	74 2b		 je	 SHORT $LN5@SendChaosC

; 1231 : 			{
; 1232 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex != -1 && gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex != -1 )

  00043	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00045	8b c1		 mov	 eax, ecx
  00047	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0004d	38 98 09 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3337], bl
  00053	74 19		 je	 SHORT $LN5@SendChaosC
  00055	38 98 0a 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3338], bl
  0005b	74 11		 je	 SHORT $LN5@SendChaosC

; 1233 : 				{
; 1234 : 					DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, lpMsg, iSize);

  0005d	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  00060	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00063	50		 push	 eax
  00064	52		 push	 edx
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@SendChaosC:

; 1222 : 	{
; 1223 : 		return;
; 1224 : 	}
; 1225 : 
; 1226 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0006e	83 c6 14	 add	 esi, 20			; 00000014H
  00071	4f		 dec	 edi
  00072	75 bc		 jne	 SHORT $LL6@SendChaosC
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
$LN4@SendChaosC:

; 1235 : 				}
; 1236 : 			}
; 1237 : 		}
; 1238 : 	}
; 1239 : }

  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ENDP	; CChaosCastle::SendChaosCastleAnyMsg
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendNoticeMessage@CChaosCastle@@QAEXHPAD@Z	; CChaosCastle::SendNoticeMessage
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
; Function compile flags: /Ogtp
;	COMDAT ?SendNoticeMessage@CChaosCastle@@QAEXHPAD@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_lpszMSG$ = 12						; size = 4
?SendNoticeMessage@CChaosCastle@@QAEXHPAD@Z PROC	; CChaosCastle::SendNoticeMessage, COMDAT
; _this$ = ecx

; 1242 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _lpszMSG$[ebp]
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  0001a	57		 push	 edi
  0001b	8b f9		 mov	 edi, ecx

; 1243 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0001d	85 f6		 test	 esi, esi
  0001f	78 77		 js	 SHORT $LN4@SendNotice
  00021	33 c9		 xor	 ecx, ecx
  00023	83 fe 05	 cmp	 esi, 5
  00026	0f 9e c1	 setle	 cl
  00029	85 c9		 test	 ecx, ecx
  0002b	74 6b		 je	 SHORT $LN4@SendNotice

; 1244 : 	{
; 1245 : 		return;
; 1246 : 	}
; 1247 : 
; 1248 : 	PMSG_NOTICE pNotice;
; 1249 : 	TNotice::MakeNoticeMsgEx((TNotice *)&pNotice, 0, lpszMSG);

  0002d	53		 push	 ebx
  0002e	50		 push	 eax
  0002f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00035	6a 00		 push	 0
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  0003d	69 f6 6c 08 00
	00		 imul	 esi, 2156		; 0000086cH
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	8d 74 3e 6c	 lea	 esi, DWORD PTR [esi+edi+108]
  0004a	bf 46 00 00 00	 mov	 edi, 70			; 00000046H
  0004f	83 cb ff	 or	 ebx, -1
$LL6@SendNotice:

; 1252 : 	{
; 1253 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00052	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00054	3b cb		 cmp	 ecx, ebx
  00056	74 39		 je	 SHORT $LN5@SendNotice

; 1254 : 		{
; 1255 : 			if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00058	8b c1		 mov	 eax, ecx
  0005a	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00060	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  00067	76 28		 jbe	 SHORT $LN5@SendNotice

; 1256 : 			{
; 1257 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex != -1 && gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex != -1 )

  00069	38 98 09 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3337], bl
  0006f	74 20		 je	 SHORT $LN5@SendNotice
  00071	38 98 0a 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3338], bl
  00077	74 18		 je	 SHORT $LN5@SendNotice

; 1258 : 				{
; 1259 : 					DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, (UCHAR*)&pNotice, pNotice.h.size);

  00079	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$[ebp+1]
  00080	52		 push	 edx
  00081	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00087	50		 push	 eax
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@SendNotice:

; 1250 : 
; 1251 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00091	83 c6 14	 add	 esi, 20			; 00000014H
  00094	4f		 dec	 edi
  00095	75 bb		 jne	 SHORT $LL6@SendNotice
  00097	5b		 pop	 ebx
$LN4@SendNotice:

; 1260 : 				}
; 1261 : 			}
; 1262 : 		}
; 1263 : 	}
; 1264 : 
; 1265 : }

  00098	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009b	5f		 pop	 edi
  0009c	33 cd		 xor	 ecx, ebp
  0009e	5e		 pop	 esi
  0009f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 08 00	 ret	 8
?SendNoticeMessage@CChaosCastle@@QAEXHPAD@Z ENDP	; CChaosCastle::SendNoticeMessage
_TEXT	ENDS
PUBLIC	?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z	; CChaosCastle::EnterUserChaosCastle
; Function compile flags: /Ogtp
;	COMDAT ?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z PROC	; CChaosCastle::EnterUserChaosCastle, COMDAT
; _this$ = ecx

; 1387 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1388 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	78 0c		 js	 SHORT $LN17@EnterUserC
  0000b	33 c0		 xor	 eax, eax
  0000d	83 ff 05	 cmp	 edi, 5
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	75 08		 jne	 SHORT $LN8@EnterUserC
$LN17@EnterUserC:

; 1389 : 	{
; 1390 : 		return -1;

  00017	83 c8 ff	 or	 eax, -1
  0001a	5f		 pop	 edi

; 1419 : 			}
; 1420 : 
; 1421 : 			break;
; 1422 : 		}
; 1423 : 	}
; 1424 : 
; 1425 : 	return iRET_VAL;
; 1426 : }

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
$LN8@EnterUserC:

; 1391 : 	}
; 1392 : 
; 1393 : 	int iRET_VAL = -1;

  0001f	83 c8 ff	 or	 eax, -1

; 1394 : 
; 1395 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00022	33 d2		 xor	 edx, edx
  00024	69 ff 6c 08 00
	00		 imul	 edi, 2156		; 0000086cH
  0002a	53		 push	 ebx
  0002b	56		 push	 esi
  0002c	8d 74 0f 6c	 lea	 esi, DWORD PTR [edi+ecx+108]
$LL18@EnterUserC:

; 1396 : 	{
; 1397 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00030	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00032	83 fb ff	 cmp	 ebx, -1
  00035	74 1e		 je	 SHORT $LN15@EnterUserC

; 1398 : 		{
; 1399 : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex == iUserIndex )

  00037	3b 5d 0c	 cmp	 ebx, DWORD PTR _iUserIndex$[ebp]
  0003a	74 10		 je	 SHORT $LN14@EnterUserC

; 1394 : 
; 1395 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0003c	42		 inc	 edx
  0003d	83 c6 14	 add	 esi, 20			; 00000014H
  00040	83 fa 46	 cmp	 edx, 70			; 00000046H
  00043	7c eb		 jl	 SHORT $LL18@EnterUserC
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	5f		 pop	 edi

; 1419 : 			}
; 1420 : 
; 1421 : 			break;
; 1422 : 		}
; 1423 : 	}
; 1424 : 
; 1425 : 	return iRET_VAL;
; 1426 : }

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN14@EnterUserC:
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx

; 1400 : 			{
; 1401 : 				iRET_VAL = i;

  0004e	8b c2		 mov	 eax, edx
  00050	5f		 pop	 edi

; 1419 : 			}
; 1420 : 
; 1421 : 			break;
; 1422 : 		}
; 1423 : 	}
; 1424 : 
; 1425 : 	return iRET_VAL;
; 1426 : }

  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
$LN15@EnterUserC:

; 1402 : 				break;
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex == -1 )
; 1407 : 		{
; 1408 : 			iRET_VAL = i;
; 1409 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex = iUserIndex;

  00055	8b 5d 0c	 mov	 ebx, DWORD PTR _iUserIndex$[ebp]
  00058	8d 34 92	 lea	 esi, DWORD PTR [edx+edx*4]
  0005b	8d 34 b7	 lea	 esi, DWORD PTR [edi+esi*4]
  0005e	03 f1		 add	 esi, ecx
  00060	8b c2		 mov	 eax, edx
  00062	89 5e 6c	 mov	 DWORD PTR [esi+108], ebx

; 1410 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iEXP = 0;

  00065	33 db		 xor	 ebx, ebx

; 1411 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iScore = 0;
; 1412 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iUserState = 0;

  00067	8d 54 92 1e	 lea	 edx, DWORD PTR [edx+edx*4+30]
  0006b	8d 14 97	 lea	 edx, DWORD PTR [edi+edx*4]
  0006e	89 1c 0a	 mov	 DWORD PTR [edx+ecx], ebx

; 1413 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_bSendQuitMsg = false;
; 1414 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER++;

  00071	8d 4c 0f 54	 lea	 ecx, DWORD PTR [edi+ecx+84]
  00075	89 5e 70	 mov	 DWORD PTR [esi+112], ebx
  00078	89 5e 74	 mov	 DWORD PTR [esi+116], ebx
  0007b	88 5e 7c	 mov	 BYTE PTR [esi+124], bl
  0007e	ff 01		 inc	 DWORD PTR [ecx]

; 1415 : 	
; 1416 : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER > MAX_CHAOSCASTLE_USER)

  00080	83 39 46	 cmp	 DWORD PTR [ecx], 70	; 00000046H
  00083	7e 06		 jle	 SHORT $LN1@EnterUserC

; 1417 : 			{
; 1418 : 				this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER = MAX_CHAOSCASTLE_USER;

  00085	c7 01 46 00 00
	00		 mov	 DWORD PTR [ecx], 70	; 00000046H
$LN1@EnterUserC:
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	5f		 pop	 edi

; 1419 : 			}
; 1420 : 
; 1421 : 			break;
; 1422 : 		}
; 1423 : 	}
; 1424 : 
; 1425 : 	return iRET_VAL;
; 1426 : }

  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z ENDP	; CChaosCastle::EnterUserChaosCastle
_TEXT	ENDS
PUBLIC	?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z	; CChaosCastle::LeaveUserChaosCastle
; Function compile flags: /Ogtp
;	COMDAT ?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z PROC	; CChaosCastle::LeaveUserChaosCastle, COMDAT
; _this$ = ecx

; 1429 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1430 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 0c		 js	 SHORT $LN14@LeaveUserC
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fe 05	 cmp	 esi, 5
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	75 08		 jne	 SHORT $LN6@LeaveUserC
$LN14@LeaveUserC:

; 1431 : 	{
; 1432 : 		return -1;

  00017	83 c8 ff	 or	 eax, -1
  0001a	5e		 pop	 esi

; 1452 : 			}
; 1453 : 
; 1454 : 			break;
; 1455 : 		}
; 1456 : 	}
; 1457 : 
; 1458 : 	return iRET_VAL;
; 1459 : }

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
$LN6@LeaveUserC:

; 1433 : 	}
; 1434 : 
; 1435 : 	int iRET_VAL = -1;

  0001f	83 c8 ff	 or	 eax, -1

; 1436 : 
; 1437 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00022	33 d2		 xor	 edx, edx
  00024	69 f6 6c 08 00
	00		 imul	 esi, 2156		; 0000086cH
  0002a	53		 push	 ebx
  0002b	8b 5d 0c	 mov	 ebx, DWORD PTR _iUserIndex$[ebp]
  0002e	57		 push	 edi
  0002f	8d 7c 0e 6c	 lea	 edi, DWORD PTR [esi+ecx+108]
$LL5@LeaveUserC:

; 1438 : 	{
; 1439 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex == iUserIndex )

  00033	39 1f		 cmp	 DWORD PTR [edi], ebx
  00035	74 10		 je	 SHORT $LN12@LeaveUserC

; 1436 : 
; 1437 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00037	42		 inc	 edx
  00038	83 c7 14	 add	 edi, 20			; 00000014H
  0003b	83 fa 46	 cmp	 edx, 70			; 00000046H
  0003e	7c f3		 jl	 SHORT $LL5@LeaveUserC
  00040	5f		 pop	 edi
  00041	5b		 pop	 ebx
  00042	5e		 pop	 esi

; 1452 : 			}
; 1453 : 
; 1454 : 			break;
; 1455 : 		}
; 1456 : 	}
; 1457 : 
; 1458 : 	return iRET_VAL;
; 1459 : }

  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN12@LeaveUserC:

; 1440 : 		{
; 1441 : 			iRET_VAL = iUserIndex;	// #error Instead of iUserIndex put i
; 1442 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex = -1;

  00047	8d 3c 92	 lea	 edi, DWORD PTR [edx+edx*4]

; 1443 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iEXP = 0;
; 1444 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iScore = 0;
; 1445 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iUserState = 0;

  0004a	8d 54 92 1e	 lea	 edx, DWORD PTR [edx+edx*4+30]
  0004e	8b c3		 mov	 eax, ebx
  00050	33 db		 xor	 ebx, ebx
  00052	8d 3c be	 lea	 edi, DWORD PTR [esi+edi*4]
  00055	03 f9		 add	 edi, ecx
  00057	8d 14 96	 lea	 edx, DWORD PTR [esi+edx*4]
  0005a	89 1c 0a	 mov	 DWORD PTR [edx+ecx], ebx

; 1446 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_bSendQuitMsg = false;
; 1447 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER--;

  0005d	8d 4c 0e 54	 lea	 ecx, DWORD PTR [esi+ecx+84]
  00061	c7 47 6c ff ff
	ff ff		 mov	 DWORD PTR [edi+108], -1
  00068	89 5f 70	 mov	 DWORD PTR [edi+112], ebx
  0006b	89 5f 74	 mov	 DWORD PTR [edi+116], ebx
  0006e	88 5f 7c	 mov	 BYTE PTR [edi+124], bl
  00071	ff 09		 dec	 DWORD PTR [ecx]

; 1448 : 	
; 1449 : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER < 0)

  00073	79 02		 jns	 SHORT $LN1@LeaveUserC

; 1450 : 			{
; 1451 : 				this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER = 0;

  00075	89 19		 mov	 DWORD PTR [ecx], ebx
$LN1@LeaveUserC:
  00077	5f		 pop	 edi
  00078	5b		 pop	 ebx
  00079	5e		 pop	 esi

; 1452 : 			}
; 1453 : 
; 1454 : 			break;
; 1455 : 		}
; 1456 : 	}
; 1457 : 
; 1458 : 	return iRET_VAL;
; 1459 : }

  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z ENDP	; CChaosCastle::LeaveUserChaosCastle
_TEXT	ENDS
PUBLIC	?AddFallUser@CChaosCastle@@QAEXHH@Z		; CChaosCastle::AddFallUser
; Function compile flags: /Ogtp
;	COMDAT ?AddFallUser@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?AddFallUser@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::AddFallUser, COMDAT
; _this$ = ecx

; 1462 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1463 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 4a		 js	 SHORT $LN2@AddFallUse
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fe 05	 cmp	 esi, 5
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	74 3e		 je	 SHORT $LN2@AddFallUse

; 1464 : 	{
; 1465 : 		return;
; 1466 : 	}
; 1467 : 
; 1468 : 	for ( int iFALL=0;iFALL<MAX_CHAOSCASTLE_USER;iFALL++)

  00017	8b d6		 mov	 edx, esi
  00019	33 c0		 xor	 eax, eax
  0001b	69 d2 6c 08 00
	00		 imul	 edx, 2156		; 0000086cH
  00021	8d 94 0a 74 07
	00 00		 lea	 edx, DWORD PTR [edx+ecx+1908]
$LL4@AddFallUse:

; 1469 : 	{
; 1470 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL] == -1 )

  00028	83 3a ff	 cmp	 DWORD PTR [edx], -1
  0002b	74 0e		 je	 SHORT $LN11@AddFallUse

; 1464 : 	{
; 1465 : 		return;
; 1466 : 	}
; 1467 : 
; 1468 : 	for ( int iFALL=0;iFALL<MAX_CHAOSCASTLE_USER;iFALL++)

  0002d	40		 inc	 eax
  0002e	83 c2 04	 add	 edx, 4
  00031	83 f8 46	 cmp	 eax, 70			; 00000046H
  00034	7c f2		 jl	 SHORT $LL4@AddFallUse
  00036	5e		 pop	 esi

; 1473 : 			break;
; 1474 : 		}
; 1475 : 	}
; 1476 : }

  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
$LN11@AddFallUse:

; 1471 : 		{
; 1472 : 			InterlockedExchange(&this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL], iUserIndex);

  0003b	8b 55 0c	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  0003e	69 f6 1b 02 00
	00		 imul	 esi, 539		; 0000021bH
  00044	03 f0		 add	 esi, eax
  00046	52		 push	 edx
  00047	8d 84 b1 74 07
	00 00		 lea	 eax, DWORD PTR [ecx+esi*4+1908]
  0004e	50		 push	 eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8
$LN2@AddFallUse:
  00055	5e		 pop	 esi

; 1473 : 			break;
; 1474 : 		}
; 1475 : 	}
; 1476 : }

  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
?AddFallUser@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::AddFallUser
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?ProcessFallUser@CChaosCastle@@QAEXH@Z		; CChaosCastle::ProcessFallUser
EXTRN	?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z:PROC ; GCDiePlayerSend
EXTRN	__imp__GetTickCount@0:PROC
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ProcessFallUser@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
tv82 = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcessFallUser@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::ProcessFallUser, COMDAT
; _this$ = ecx

; 1479 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1480 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 c0		 test	 eax, eax
  00009	0f 88 db 00 00
	00		 js	 $LN3@ProcessFal
  0000f	33 d2		 xor	 edx, edx
  00011	83 f8 05	 cmp	 eax, 5
  00014	0f 9e c2	 setle	 dl
  00017	85 d2		 test	 edx, edx
  00019	0f 84 cb 00 00
	00		 je	 $LN3@ProcessFal

; 1481 : 	{
; 1482 : 		return;
; 1483 : 	}
; 1484 : 
; 1485 : 	for ( int iFALL=0;iFALL<MAX_CHAOSCASTLE_USER;iFALL++)

  0001f	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	8d 9c 08 74 07
	00 00		 lea	 ebx, DWORD PTR [eax+ecx+1908]
  0002f	c7 45 fc 46 00
	00 00		 mov	 DWORD PTR tv82[ebp], 70	; 00000046H
  00036	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL5@ProcessFal:

; 1486 : 	{
; 1487 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL] != -1 )

  00040	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00042	83 ff ff	 cmp	 edi, -1
  00045	0f 84 90 00 00
	00		 je	 $LN4@ProcessFal

; 1488 : 		{
; 1489 : 			int iFALL_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL];
; 1490 : 			InterlockedExchange(&this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL], -1);

  0004b	6a ff		 push	 -1
  0004d	53		 push	 ebx
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 1491 : 
; 1492 : 			if ( (gObj[iFALL_INDEX].MapNumber) == (iChaosCastleIndex+18) &&
; 1493 : 				  gObjIsConnected(iFALL_INDEX) &&
; 1494 : 				  gObj[iFALL_INDEX].Life > 0 )

  00054	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  00057	8b f7		 mov	 esi, edi
  00059	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0005f	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]
  00066	83 c1 12	 add	 ecx, 18			; 00000012H
  00069	3b c1		 cmp	 eax, ecx
  0006b	75 6e		 jne	 SHORT $LN4@ProcessFal
  0006d	57		 push	 edi
  0006e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00073	83 c4 04	 add	 esp, 4
  00076	85 c0		 test	 eax, eax
  00078	74 61		 je	 SHORT $LN4@ProcessFal
  0007a	d9 ee		 fldz
  0007c	d8 96 bc 00 00
	00		 fcom	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+188]
  00082	df e0		 fnstsw	 ax
  00084	f6 c4 05	 test	 ah, 5
  00087	7a 50		 jp	 SHORT $LN16@ProcessFal

; 1495 : 			{
; 1496 : 				gObj[iFALL_INDEX].Life = 0;

  00089	d9 9e bc 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+188]

; 1497 : 				gObj[iFALL_INDEX].m_State = 4;

  0008f	c7 86 bc 01 00
	00 04 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+444], 4

; 1498 : 				gObj[iFALL_INDEX].KillerType = 1;

  00099	c6 86 01 02 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+513], 1

; 1499 : 				gObj[iFALL_INDEX].RegenTime = GetTickCount();

  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 1500 : 				gObj[iFALL_INDEX].DieRegen = 1;
; 1501 : 				gObj[iFALL_INDEX].PathCount = 0;
; 1502 : 				
; 1503 : 				GCDiePlayerSend(&gObj[iFALL_INDEX], gObj[iFALL_INDEX].m_Index, 0, 0);

  000a6	8b 96 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000ac	89 86 08 02 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+520], eax
  000b2	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000b8	6a 00		 push	 0
  000ba	6a 00		 push	 0
  000bc	52		 push	 edx
  000bd	50		 push	 eax
  000be	c6 86 02 02 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+514], 1
  000c5	c7 86 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+296], 0
  000cf	e8 00 00 00 00	 call	 ?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z ; GCDiePlayerSend
  000d4	83 c4 10	 add	 esp, 16			; 00000010H
  000d7	eb 02		 jmp	 SHORT $LN4@ProcessFal
$LN16@ProcessFal:
  000d9	dd d8		 fstp	 ST(0)
$LN4@ProcessFal:

; 1481 : 	{
; 1482 : 		return;
; 1483 : 	}
; 1484 : 
; 1485 : 	for ( int iFALL=0;iFALL<MAX_CHAOSCASTLE_USER;iFALL++)

  000db	83 c3 04	 add	 ebx, 4
  000de	ff 4d fc	 dec	 DWORD PTR tv82[ebp]
  000e1	0f 85 59 ff ff
	ff		 jne	 $LL5@ProcessFal
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx
$LN3@ProcessFal:

; 1504 : 			}
; 1505 : 		}
; 1506 : 	}
; 1507 : }

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 04 00	 ret	 4
?ProcessFallUser@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::ProcessFallUser
_TEXT	ENDS
PUBLIC	?SetUserState@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SetUserState
; Function compile flags: /Ogtp
;	COMDAT ?SetUserState@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
_iState$ = 12						; size = 4
?SetUserState@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SetUserState, COMDAT
; _this$ = ecx

; 1510 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1511 : 	if ( !OBJMAX_RANGE(iUserIndex))

  00003	8b 55 08	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	0f 88 80 00 00
	00		 js	 $LN3@SetUserSta
  00011	33 c0		 xor	 eax, eax
  00013	81 fa e7 1c 00
	00		 cmp	 edx, 7399		; 00001ce7H
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	74 71		 je	 SHORT $LN3@SetUserSta

; 1512 : 		return;
; 1513 : 
; 1514 : 	int iChaosCastleIndex = gObj[iUserIndex].m_cChaosCastleIndex;

  00020	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00026	0f be 82 09 0d
	00 00		 movsx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3337]

; 1515 : 	int iChaosCastleSubIndex = gObj[iUserIndex].m_cChaosCastleSubIndex;

  0002d	0f be 92 0a 0d
	00 00		 movsx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3338]

; 1516 : 
; 1517 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00034	85 c0		 test	 eax, eax
  00036	78 59		 js	 SHORT $LN3@SetUserSta
  00038	33 c9		 xor	 ecx, ecx
  0003a	83 f8 05	 cmp	 eax, 5
  0003d	0f 9e c1	 setle	 cl
  00040	56		 push	 esi
  00041	8b f1		 mov	 esi, ecx
  00043	85 f6		 test	 esi, esi
  00045	74 49		 je	 SHORT $LN16@SetUserSta

; 1518 : 		return;
; 1519 : 
; 1520 : 	if ( CC_SUB_FLOOR_RANGE(iChaosCastleSubIndex) == FALSE )

  00047	85 d2		 test	 edx, edx
  00049	78 45		 js	 SHORT $LN16@SetUserSta
  0004b	33 c9		 xor	 ecx, ecx
  0004d	83 fa 45	 cmp	 edx, 69			; 00000045H
  00050	0f 9e c1	 setle	 cl
  00053	8b f1		 mov	 esi, ecx
  00055	85 f6		 test	 esi, esi
  00057	74 37		 je	 SHORT $LN16@SetUserSta

; 1521 : 		return;
; 1522 : 
; 1523 : 	switch ( iState )

  00059	8b 75 0c	 mov	 esi, DWORD PTR _iState$[ebp]
  0005c	83 ee 00	 sub	 esi, 0
  0005f	74 1c		 je	 SHORT $LN2@SetUserSta
  00061	4e		 dec	 esi
  00062	75 2c		 jne	 SHORT $LN16@SetUserSta

; 1527 : 			break;
; 1528 : 		case 1:
; 1529 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iUserState = 1;

  00064	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  0006a	03 c7		 add	 eax, edi
  0006c	8d 54 92 1e	 lea	 edx, DWORD PTR [edx+edx*4+30]
  00070	5e		 pop	 esi
  00071	c7 04 90 01 00
	00 00		 mov	 DWORD PTR [eax+edx*4], 1
  00078	5f		 pop	 edi

; 1530 : 	}
; 1531 : }

  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
$LN2@SetUserSta:

; 1524 : 	{
; 1525 : 		case 0:
; 1526 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iUserState = 0;

  0007d	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  00083	8d 4c 92 1e	 lea	 ecx, DWORD PTR [edx+edx*4+30]
  00087	03 c7		 add	 eax, edi
  00089	c7 04 88 00 00
	00 00		 mov	 DWORD PTR [eax+ecx*4], 0
$LN16@SetUserSta:
  00090	5e		 pop	 esi
$LN3@SetUserSta:
  00091	5f		 pop	 edi

; 1530 : 	}
; 1531 : }

  00092	5d		 pop	 ebp
  00093	c2 08 00	 ret	 8
?SetUserState@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SetUserState
_TEXT	ENDS
PUBLIC	?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetUserLevelToEnter
; Function compile flags: /Ogtp
;	COMDAT ?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetUserLevelToEnter, COMDAT
; _this$ = ecx

; 1579 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1580 : 	if ( !gObjIsConnected(iUserIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iUserIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 08		 jne	 SHORT $LN9@GetUserLev

; 1581 : 		return -1;

  00014	83 c8 ff	 or	 eax, -1
  00017	5e		 pop	 esi

; 1601 : 			{
; 1602 : 				iENTER_LEVEL = i;
; 1603 : 				break;
; 1604 : 			}
; 1605 : 		}
; 1606 : 	}
; 1607 : 			 
; 1608 : 	return iENTER_LEVEL;
; 1609 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN9@GetUserLev:
  0001c	53		 push	 ebx
  0001d	57		 push	 edi

; 1582 : 
; 1583 : 	int iENTER_LEVEL = -1;
; 1584 : 
; 1585 : 	for (int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)

  0001e	8b d6		 mov	 edx, esi
  00020	83 c8 ff	 or	 eax, -1
  00023	33 ff		 xor	 edi, edi
  00025	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  0002b	0f b7 9a 98 00
	00 00		 movzx	 ebx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+152]
  00032	b9 04 00 00 00	 mov	 ecx, OFFSET _g_sttCHAOSCASTLE_LEVEL+4
$LL8@GetUserLev:

; 1586 : 	{
; 1587 : 		if ( gObj[iUserIndex].Class == CLASS_DARKLORD ||
; 1588 : 			 gObj[iUserIndex].Class == CLASS_MAGUMSA )

  00037	83 fb 04	 cmp	 ebx, 4
  0003a	74 15		 je	 SHORT $LN4@GetUserLev
  0003c	83 fb 03	 cmp	 ebx, 3
  0003f	74 10		 je	 SHORT $LN4@GetUserLev

; 1594 : 				break;
; 1595 : 			}
; 1596 : 		}
; 1597 : 		else
; 1598 : 		{
; 1599 : 			if ( gObj[iUserIndex].Level >= g_sttCHAOSCASTLE_LEVEL[i].iLOWER_BOUND &&
; 1600 : 				 gObj[iUserIndex].Level <= g_sttCHAOSCASTLE_LEVEL[i].iUPPER_BOUND )

  00041	0f bf b2 9c 00
	00 00		 movsx	 esi, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+156]
  00048	3b 71 fc	 cmp	 esi, DWORD PTR [ecx-4]
  0004b	7c 15		 jl	 SHORT $LN7@GetUserLev
  0004d	3b 31		 cmp	 esi, DWORD PTR [ecx]
  0004f	eb 0f		 jmp	 SHORT $LN16@GetUserLev
$LN4@GetUserLev:

; 1589 : 		{
; 1590 : 			if ( gObj[iUserIndex].Level >= g_sttCHAOSCASTLE_LEVEL[i].iLOWER_BOUND_MAGUMSA &&
; 1591 : 				 gObj[iUserIndex].Level <= g_sttCHAOSCASTLE_LEVEL[i].iUPPER_BOUND_MAGUMSA )

  00051	0f bf b2 9c 00
	00 00		 movsx	 esi, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+156]
  00058	3b 71 04	 cmp	 esi, DWORD PTR [ecx+4]
  0005b	7c 05		 jl	 SHORT $LN7@GetUserLev
  0005d	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
$LN16@GetUserLev:
  00060	7e 13		 jle	 SHORT $LN14@GetUserLev
$LN7@GetUserLev:

; 1582 : 
; 1583 : 	int iENTER_LEVEL = -1;
; 1584 : 
; 1585 : 	for (int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)

  00062	83 c1 10	 add	 ecx, 16			; 00000010H
  00065	47		 inc	 edi
  00066	81 f9 64 00 00
	00		 cmp	 ecx, OFFSET _g_sttCHAOSCASTLE_LEVEL+100
  0006c	7c c9		 jl	 SHORT $LL8@GetUserLev
  0006e	5f		 pop	 edi
  0006f	5b		 pop	 ebx
  00070	5e		 pop	 esi

; 1601 : 			{
; 1602 : 				iENTER_LEVEL = i;
; 1603 : 				break;
; 1604 : 			}
; 1605 : 		}
; 1606 : 	}
; 1607 : 			 
; 1608 : 	return iENTER_LEVEL;
; 1609 : }

  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
$LN14@GetUserLev:

; 1592 : 			{
; 1593 : 				iENTER_LEVEL = i;

  00075	8b c7		 mov	 eax, edi
  00077	5f		 pop	 edi
  00078	5b		 pop	 ebx
  00079	5e		 pop	 esi

; 1601 : 			{
; 1602 : 				iENTER_LEVEL = i;
; 1603 : 				break;
; 1604 : 			}
; 1605 : 		}
; 1606 : 	}
; 1607 : 			 
; 1608 : 	return iENTER_LEVEL;
; 1609 : }

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetUserLevelToEnter
_TEXT	ENDS
PUBLIC	?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z	; CChaosCastle::CheckUserEnterMoney
; Function compile flags: /Ogtp
;	COMDAT ?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
_iEnterLevel$ = 12					; size = 4
?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z PROC	; CChaosCastle::CheckUserEnterMoney, COMDAT
; _this$ = ecx

; 1612 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1613 : 	if ( OBJMAX_RANGE(iUserIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN10@CheckUserE
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN3@CheckUserE
$LN10@CheckUserE:

; 1614 : 	{
; 1615 : 		return FALSE;

  00018	33 c0		 xor	 eax, eax

; 1624 : 	{
; 1625 : 		return TRUE;
; 1626 : 	}
; 1627 : 
; 1628 : 	return FALSE;
; 1629 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
$LN3@CheckUserE:

; 1616 : 	}
; 1617 : 
; 1618 : 	if ( CC_FLOOR_RANGE(iEnterLevel) == FALSE )

  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _iEnterLevel$[ebp]
  00021	85 c9		 test	 ecx, ecx
  00023	78 f3		 js	 SHORT $LN10@CheckUserE
  00025	33 d2		 xor	 edx, edx
  00027	83 f9 05	 cmp	 ecx, 5
  0002a	0f 9e c2	 setle	 dl
  0002d	85 d2		 test	 edx, edx

; 1619 : 	{
; 1620 : 		return FALSE;

  0002f	74 e7		 je	 SHORT $LN10@CheckUserE

; 1621 : 	}
; 1622 : 
; 1623 : 	if ( gObj[iUserIndex].Money >= ::g_iChaosCastle_EnterCost[iEnterLevel] )

  00031	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00037	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+176]
  0003d	33 d2		 xor	 edx, edx
  0003f	3b 04 8d 00 00
	00 00		 cmp	 eax, DWORD PTR _g_iChaosCastle_EnterCost[ecx*4]
  00046	0f 9d c2	 setge	 dl
  00049	8b c2		 mov	 eax, edx

; 1624 : 	{
; 1625 : 		return TRUE;
; 1626 : 	}
; 1627 : 
; 1628 : 	return FALSE;
; 1629 : }

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z ENDP	; CChaosCastle::CheckUserEnterMoney
_TEXT	ENDS
PUBLIC	?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z	; CChaosCastle::PayUserEnterMoney
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
; Function compile flags: /Ogtp
;	COMDAT ?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
_iEnterLevel$ = 12					; size = 4
?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z PROC		; CChaosCastle::PayUserEnterMoney, COMDAT
; _this$ = ecx

; 1632 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1633 : 	if ( OBJMAX_RANGE(iUserIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iUserIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 55		 js	 SHORT $LN1@PayUserEnt
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax

; 1634 : 	{
; 1635 : 		return FALSE;

  00018	74 46		 je	 SHORT $LN1@PayUserEnt

; 1636 : 	}
; 1637 : 
; 1638 : 	if ( CC_FLOOR_RANGE(iEnterLevel) == FALSE )

  0001a	8b 55 0c	 mov	 edx, DWORD PTR _iEnterLevel$[ebp]
  0001d	85 d2		 test	 edx, edx
  0001f	78 3f		 js	 SHORT $LN1@PayUserEnt
  00021	33 c0		 xor	 eax, eax
  00023	83 fa 05	 cmp	 edx, 5
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax

; 1639 : 	{
; 1640 : 		return FALSE;

  0002b	74 33		 je	 SHORT $LN1@PayUserEnt

; 1641 : 	}
; 1642 : 
; 1643 : 	if ( gObj[iUserIndex].Money >= ::g_iChaosCastle_EnterCost[iEnterLevel] )

  0002d	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _g_iChaosCastle_EnterCost[edx*4]
  00034	8b c6		 mov	 eax, esi
  00036	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0003c	8d 88 b0 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+176]
  00042	8b 01		 mov	 eax, DWORD PTR [ecx]
  00044	3b c2		 cmp	 eax, edx
  00046	7c 18		 jl	 SHORT $LN1@PayUserEnt

; 1644 : 	{
; 1645 : 		gObj[iUserIndex].Money -= ::g_iChaosCastle_EnterCost[iEnterLevel];

  00048	2b c2		 sub	 eax, edx

; 1646 : 		GCMoneySend(iUserIndex, gObj[iUserIndex].Money);

  0004a	50		 push	 eax
  0004b	56		 push	 esi
  0004c	89 01		 mov	 DWORD PTR [ecx], eax
  0004e	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00053	83 c4 08	 add	 esp, 8

; 1647 : 
; 1648 : 		return TRUE;

  00056	b8 01 00 00 00	 mov	 eax, 1
  0005b	5e		 pop	 esi

; 1652 : }

  0005c	5d		 pop	 ebp
  0005d	c2 08 00	 ret	 8
$LN1@PayUserEnt:

; 1649 : 	}
; 1650 : 
; 1651 : 	return FALSE;

  00060	33 c0		 xor	 eax, eax
  00062	5e		 pop	 esi

; 1652 : }

  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z ENDP		; CChaosCastle::PayUserEnterMoney
_TEXT	ENDS
PUBLIC	?GiveUserDamage@CChaosCastle@@QAEXHH@Z		; CChaosCastle::GiveUserDamage
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
; Function compile flags: /Ogtp
;	COMDAT ?GiveUserDamage@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 8
_iUserIndex$ = 8					; size = 4
tv209 = 12						; size = 4
_iDamage$ = 12						; size = 4
?GiveUserDamage@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::GiveUserDamage, COMDAT
; _this$ = ecx

; 1655 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1656 : 	if ( !gObjIsConnected(iUserIndex))

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iUserIndex$[ebp]
  0000a	53		 push	 ebx
  0000b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00010	83 c4 04	 add	 esp, 4
  00013	85 c0		 test	 eax, eax
  00015	0f 84 df 00 00
	00		 je	 $LN1@GiveUserDa

; 1657 : 		return;
; 1658 : 
; 1659 : 	if ( gObj[iUserIndex].Life <= 0.0 )

  0001b	d9 ee		 fldz
  0001d	56		 push	 esi
  0001e	8b f3		 mov	 esi, ebx
  00020	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00026	d8 9e bc 00 00
	00		 fcomp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+188]
  0002c	df e0		 fnstsw	 ax
  0002e	f6 c4 01	 test	 ah, 1
  00031	0f 84 c2 00 00
	00		 je	 $LN7@GiveUserDa

; 1660 : 		return;
; 1661 : 
; 1662 : 	PMSG_ATTACKRESULT pResult;
; 1663 : 
; 1664 : 	PHeadSetB((LPBYTE)&pResult, PROTOCOL_ATTACK, sizeof(pResult));

  00037	6a 08		 push	 8
  00039	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0003c	68 d7 00 00 00	 push	 215			; 000000d7H
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1665 : 	pResult.NumberH = SET_NUMBERH(iUserIndex);
; 1666 : 	pResult.NumberL = SET_NUMBERL(iUserIndex);
; 1667 : 	pResult.DamageH = SET_NUMBERH(iDamage);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _iDamage$[ebp]
  0004a	8b cb		 mov	 ecx, ebx
  0004c	8b d0		 mov	 edx, eax
  0004e	c1 e9 08	 shr	 ecx, 8
  00051	c1 ea 08	 shr	 edx, 8
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1668 : 	pResult.DamageL = SET_NUMBERL(iDamage);
; 1669 : 
; 1670 : 	if ( gObj[iUserIndex].Type == OBJ_USER )

  00057	66 83 be 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+96], 1
  0005f	88 4d fb	 mov	 BYTE PTR _pResult$[ebp+3], cl
  00062	88 5d fc	 mov	 BYTE PTR _pResult$[ebp+4], bl
  00065	88 55 fd	 mov	 BYTE PTR _pResult$[ebp+5], dl
  00068	88 45 fe	 mov	 BYTE PTR _pResult$[ebp+6], al
  0006b	75 12		 jne	 SHORT $LN2@GiveUserDa

; 1671 : 		DataSend(iUserIndex, (LPBYTE)&pResult, pResult.h.size);

  0006d	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00071	50		 push	 eax
  00072	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00075	51		 push	 ecx
  00076	53		 push	 ebx
  00077	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GiveUserDa:

; 1672 : 
; 1673 : 	gObj[iUserIndex].Life -= iDamage;

  0007f	d9 86 bc 00 00
	00		 fld	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+188]
  00085	da 65 0c	 fisub	 DWORD PTR _iDamage$[ebp]
  00088	d9 5d 0c	 fstp	 DWORD PTR tv209[ebp]
  0008b	d9 45 0c	 fld	 DWORD PTR tv209[ebp]
  0008e	d9 96 bc 00 00
	00		 fst	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+188]

; 1674 : 
; 1675 : 	if ( gObj[iUserIndex].Life <= 0.0 )

  00094	d9 ee		 fldz
  00096	d8 d1		 fcom	 ST(1)
  00098	df e0		 fnstsw	 ax
  0009a	dd d9		 fstp	 ST(1)
  0009c	f6 c4 01	 test	 ah, 1
  0009f	75 56		 jne	 SHORT $LN9@GiveUserDa

; 1676 : 	{
; 1677 : 		gObj[iUserIndex].Life = 0;

  000a1	d9 9e bc 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+188]

; 1678 : 		gObj[iUserIndex].m_State = 4;

  000a7	c7 86 bc 01 00
	00 04 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+444], 4

; 1679 : 		gObj[iUserIndex].KillerType = 1;

  000b1	c6 86 01 02 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+513], 1

; 1680 : 		gObj[iUserIndex].RegenTime = GetTickCount();

  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 1681 : 		gObj[iUserIndex].DieRegen = 1;
; 1682 : 		gObj[iUserIndex].PathCount = 0;
; 1683 : 		
; 1684 : 		GCDiePlayerSend(&gObj[iUserIndex], gObj[iUserIndex].m_Index, 0, 0);

  000be	8b 96 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000c4	89 86 08 02 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+520], eax
  000ca	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000d0	6a 00		 push	 0
  000d2	6a 00		 push	 0
  000d4	52		 push	 edx
  000d5	50		 push	 eax
  000d6	c6 86 02 02 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+514], 1
  000dd	c7 86 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+296], 0
  000e7	e8 00 00 00 00	 call	 ?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z ; GCDiePlayerSend
  000ec	83 c4 10	 add	 esp, 16			; 00000010H
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx

; 1685 : 	}
; 1686 : }

  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c2 08 00	 ret	 8
$LN9@GiveUserDa:

; 1674 : 
; 1675 : 	if ( gObj[iUserIndex].Life <= 0.0 )

  000f7	dd d8		 fstp	 ST(0)
$LN7@GiveUserDa:
  000f9	5e		 pop	 esi
$LN1@GiveUserDa:
  000fa	5b		 pop	 ebx

; 1685 : 	}
; 1686 : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 08 00	 ret	 8
?GiveUserDamage@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::GiveUserDamage
_TEXT	ENDS
PUBLIC	??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ ; `string'
PUBLIC	??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ ; `string'
PUBLIC	?LevelUp@CChaosCastle@@QAEHHHH@Z		; CChaosCastle::LevelUp
EXTRN	?gObjCalcMaxLifePower@@YAXH@Z:PROC		; gObjCalcMaxLifePower
EXTRN	?GCLevelUpMsgSend@@YAXHH@Z:PROC			; GCLevelUpMsgSend
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjNextExpCal
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?gObjSetExpPetItem@@YAXHH@Z:PROC		; gObjSetExpPetItem
;	COMDAT ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
CONST	SEGMENT
??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ DB '['
	DB	'%s][%s] LevelUp PlusStatQuest Clear AddStat %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ DB 'E'
	DB	'xperience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex :'
	DB	' %d, EventType : %d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LevelUp@CChaosCastle@@QAEHHHH@Z
_TEXT	SEGMENT
_iLEFT_EXP$ = -8					; size = 4
tv364 = -4						; size = 4
tv363 = 8						; size = 4
_iUserIndex$ = 8					; size = 4
_iAddExp$ = 12						; size = 4
tv425 = 16						; size = 4
tv415 = 16						; size = 4
_iEventType$ = 16					; size = 4
?LevelUp@CChaosCastle@@QAEHHHH@Z PROC			; CChaosCastle::LevelUp, COMDAT
; _this$ = ecx

; 1689 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1690 : 	if ( OBJMAX_RANGE(iUserIndex) == FALSE )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iUserIndex$[ebp]
  0000a	85 db		 test	 ebx, ebx
  0000c	78 0f		 js	 SHORT $LN13@LevelUp
  0000e	33 c0		 xor	 eax, eax
  00010	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 09		 jne	 SHORT $LN8@LevelUp
$LN13@LevelUp:

; 1691 : 	{
; 1692 : 		return 0;

  0001d	33 c0		 xor	 eax, eax
  0001f	5b		 pop	 ebx

; 1750 : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
$LN8@LevelUp:

; 1693 : 	}
; 1694 : 
; 1695 : 	int iLEFT_EXP = 0;
; 1696 : 
; 1697 : 	LogAdd(LOG_BLACK, "Experience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex : %d, EventType : %d",
; 1698 : 		gObj[iUserIndex].MapNumber, gObj[iUserIndex].X, gObj[iUserIndex].Y,	
; 1699 : 		gObj[iUserIndex].AccountID,	gObj[iUserIndex].Name,
; 1700 : 		gObj[iUserIndex].Level, gObj[iUserIndex].Experience,
; 1701 : 		iAddExp, 0, iEventType);

  00026	8b 55 10	 mov	 edx, DWORD PTR _iEventType$[ebp]
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	8b 7d 0c	 mov	 edi, DWORD PTR _iAddExp$[ebp]
  0002e	52		 push	 edx
  0002f	8b f3		 mov	 esi, ebx
  00031	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00037	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+168]
  0003d	6a 00		 push	 0
  0003f	57		 push	 edi
  00040	52		 push	 edx
  00041	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156]
  00048	52		 push	 edx
  00049	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]
  00050	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00056	50		 push	 eax
  00057	8d 8e 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  0005d	51		 push	 ecx
  0005e	89 45 08	 mov	 DWORD PTR tv363[ebp], eax
  00061	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  00068	89 4d fc	 mov	 DWORD PTR tv364[ebp], ecx
  0006b	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  00072	50		 push	 eax
  00073	51		 push	 ecx
  00074	52		 push	 edx
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
  0007a	6a 00		 push	 0
  0007c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iLEFT_EXP$[ebp], 0
  00083	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 1702 : 
; 1703 : 	::gObjSetExpPetItem(iUserIndex, iAddExp);

  00088	57		 push	 edi
  00089	53		 push	 ebx
  0008a	e8 00 00 00 00	 call	 ?gObjSetExpPetItem@@YAXHH@Z ; gObjSetExpPetItem

; 1704 : 
; 1705 : 	if ( gObj[iUserIndex].Level >= MAX_CHAR_LEVEL )

  0008f	0f b7 96 9c 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156]
  00096	b8 90 01 00 00	 mov	 eax, 400		; 00000190H
  0009b	83 c4 38	 add	 esp, 56			; 00000038H
  0009e	66 3b d0	 cmp	 dx, ax
  000a1	7c 2c		 jl	 SHORT $LN7@LevelUp

; 1706 : 	{
; 1707 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 112)), gObj[iUserIndex].m_Index, 1);

  000a3	8b 8e 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000a9	6a 01		 push	 1
  000ab	51		 push	 ecx
  000ac	68 70 04 00 00	 push	 1136			; 00000470H
  000b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000b6	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi

; 1708 : 		return 0;

  000c6	33 c0		 xor	 eax, eax
  000c8	5b		 pop	 ebx

; 1750 : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 0c 00	 ret	 12			; 0000000cH
$LN7@LevelUp:

; 1709 : 	}
; 1710 : 
; 1711 : 	if ( (gObj[iUserIndex].Experience + iAddExp) < gObj[iUserIndex].NextExp )

  000cf	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+168]
  000d5	8b 8e ac 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+172]
  000db	8d 1c 38	 lea	 ebx, DWORD PTR [eax+edi]
  000de	3b d9		 cmp	 ebx, ecx
  000e0	73 14		 jae	 SHORT $LN6@LevelUp

; 1712 : 	{
; 1713 : 		gObj[iUserIndex].Experience += iAddExp;

  000e2	89 9e a8 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+168], ebx

; 1714 : 	}
; 1715 : 	else

  000e8	8b 5d f8	 mov	 ebx, DWORD PTR _iLEFT_EXP$[ebp]
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi

; 1747 : 	}
; 1748 : 
; 1749 : 	return iLEFT_EXP;

  000ed	8b c3		 mov	 eax, ebx
  000ef	5b		 pop	 ebx

; 1750 : }

  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c2 0c 00	 ret	 12			; 0000000cH
$LN6@LevelUp:

; 1716 : 	{
; 1717 : 		iLEFT_EXP = gObj[iUserIndex].Experience + iAddExp - gObj[iUserIndex].NextExp;

  000f6	2b c1		 sub	 eax, ecx
  000f8	8d 1c 07	 lea	 ebx, DWORD PTR [edi+eax]

; 1718 : 		gObj[iUserIndex].Experience = gObj[iUserIndex].NextExp;
; 1719 : 		gObj[iUserIndex].Level++;
; 1720 : 
; 1721 : 		if ( gObj[iUserIndex].Class == CLASS_DARKLORD || gObj[iUserIndex].Class == CLASS_MAGUMSA )

  000fb	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152]
  00102	42		 inc	 edx
  00103	89 8e a8 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+168], ecx
  00109	66 89 96 9c 00
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156], dx
  00110	83 f8 04	 cmp	 eax, 4
  00113	74 0e		 je	 SHORT $LN3@LevelUp
  00115	83 f8 03	 cmp	 eax, 3
  00118	74 09		 je	 SHORT $LN3@LevelUp

; 1724 : 		}
; 1725 : 		else
; 1726 : 		{
; 1727 : 			gObj[iUserIndex].LevelUpPoint += 5;

  0011a	83 86 a0 00 00
	00 05		 add	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+160], 5
  00121	eb 07		 jmp	 SHORT $LN2@LevelUp
$LN3@LevelUp:

; 1722 : 		{
; 1723 : 			gObj[iUserIndex].LevelUpPoint += 7;

  00123	83 86 a0 00 00
	00 07		 add	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+160], 7
$LN2@LevelUp:

; 1728 : 		}
; 1729 : 
; 1730 : 		if ( gObj[iUserIndex].PlusStatQuestClear != false )

  0012a	80 be 88 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+136], 0
  00131	74 24		 je	 SHORT $LN14@LevelUp

; 1731 : 		{
; 1732 : 			gObj[iUserIndex].LevelUpPoint++;

  00133	ff 86 a0 00 00
	00		 inc	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+160]
  00139	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+160]

; 1733 : 
; 1734 : 			LogAdd(LOG_BLACK, "[%s][%s] LevelUp PlusStatQuest Clear AddStat %d",
; 1735 : 				gObj[iUserIndex].AccountID, gObj[iUserIndex].Name, gObj[iUserIndex].LevelUpPoint);

  0013f	8b 55 08	 mov	 edx, DWORD PTR tv363[ebp]
  00142	50		 push	 eax
  00143	8b 45 fc	 mov	 eax, DWORD PTR tv364[ebp]
  00146	52		 push	 edx
  00147	50		 push	 eax
  00148	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
  0014d	6a 00		 push	 0
  0014f	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00154	83 c4 14	 add	 esp, 20			; 00000014H
$LN14@LevelUp:

; 1736 : 		}
; 1737 : 
; 1738 : 		gObj[iUserIndex].MaxLife += DCInfo.DefClass[gObj[iUserIndex].Class].LevelLife;

  00157	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152]
  0015e	69 c0 60 09 00
	00		 imul	 eax, 2400		; 00000960H

; 1739 : 		gObj[iUserIndex].MaxMana += DCInfo.DefClass[gObj[iUserIndex].Class].LevelMana;
; 1740 : 		gObj[iUserIndex].Life = gObj[iUserIndex].MaxLife;
; 1741 : 		gObj[iUserIndex].Mana = gObj[iUserIndex].MaxMana;
; 1742 : 		gObjNextExpCal(&gObj[iUserIndex]);

  00164	8d be 00 00 00
	00		 lea	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  0016a	57		 push	 edi
  0016b	d9 80 10 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  00171	d8 86 c0 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]
  00177	d9 5d 10	 fstp	 DWORD PTR tv415[ebp]
  0017a	d9 45 10	 fld	 DWORD PTR tv415[ebp]
  0017d	d9 96 c0 00 00
	00		 fst	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]
  00183	d9 80 1c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  00189	d8 86 d4 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  0018f	d9 5d 10	 fstp	 DWORD PTR tv425[ebp]
  00192	d9 45 10	 fld	 DWORD PTR tv425[ebp]
  00195	d9 96 d4 00 00
	00		 fst	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  0019b	d9 9e d0 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+208]
  001a1	d9 9e bc 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+188]
  001a7	e8 00 00 00 00	 call	 ?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNextExpCal

; 1743 : 		gObjSetBP(gObj[iUserIndex].m_Index);

  001ac	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 1744 : 		GCLevelUpMsgSend(gObj[iUserIndex].m_Index, 1);

  001b4	8b 17		 mov	 edx, DWORD PTR [edi]
  001b6	6a 01		 push	 1
  001b8	52		 push	 edx
  001b9	e8 00 00 00 00	 call	 ?GCLevelUpMsgSend@@YAXHH@Z ; GCLevelUpMsgSend

; 1745 : 		gObjCalcMaxLifePower(gObj[iUserIndex].m_Index);

  001be	8b 07		 mov	 eax, DWORD PTR [edi]
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower

; 1746 : 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2, 8)), gObj[iUserIndex].AccountID, gObj[iUserIndex].Name, gObj[iUserIndex].Level);

  001c6	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156]
  001cd	8b 55 08	 mov	 edx, DWORD PTR tv363[ebp]
  001d0	8b 45 fc	 mov	 eax, DWORD PTR tv364[ebp]
  001d3	83 c4 14	 add	 esp, 20			; 00000014H
  001d6	51		 push	 ecx
  001d7	52		 push	 edx
  001d8	50		 push	 eax
  001d9	68 08 02 00 00	 push	 520			; 00000208H
  001de	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001e3	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001e8	50		 push	 eax
  001e9	6a 00		 push	 0
  001eb	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001f0	83 c4 14	 add	 esp, 20			; 00000014H
  001f3	5f		 pop	 edi
  001f4	5e		 pop	 esi

; 1747 : 	}
; 1748 : 
; 1749 : 	return iLEFT_EXP;

  001f5	8b c3		 mov	 eax, ebx
  001f7	5b		 pop	 ebx

; 1750 : }

  001f8	8b e5		 mov	 esp, ebp
  001fa	5d		 pop	 ebp
  001fb	c2 0c 00	 ret	 12			; 0000000cH
?LevelUp@CChaosCastle@@QAEHHHH@Z ENDP			; CChaosCastle::LevelUp
_TEXT	ENDS
PUBLIC	?CheckEnterLevel@CChaosCastle@@QAEHHH@Z		; CChaosCastle::CheckEnterLevel
; Function compile flags: /Ogtp
;	COMDAT ?CheckEnterLevel@CChaosCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iLevel$ = 12						; size = 4
?CheckEnterLevel@CChaosCastle@@QAEHHH@Z PROC		; CChaosCastle::CheckEnterLevel, COMDAT
; _this$ = ecx

; 1802 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1803 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 88 b5 00 00
	00		 js	 $LN10@CheckEnter
  0000e	33 c9		 xor	 ecx, ecx
  00010	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00015	0f 9e c1	 setle	 cl
  00018	85 c9		 test	 ecx, ecx

; 1804 : 	{
; 1805 : 		return 2;

  0001a	0f 84 a3 00 00
	00		 je	 $LN10@CheckEnter

; 1806 : 	}
; 1807 : 
; 1808 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00020	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00026	66 83 b8 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 1
  0002e	0f 85 8f 00 00
	00		 jne	 $LN10@CheckEnter
  00034	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  0003b	0f 86 82 00 00
	00		 jbe	 $LN10@CheckEnter

; 1811 : 	}
; 1812 : 
; 1813 : 	if ( gObj[iIndex].Class == CLASS_DARKLORD || gObj[iIndex].Class == CLASS_MAGUMSA )

  00041	0f b7 88 98 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+152]
  00048	83 f9 04	 cmp	 ecx, 4
  0004b	74 39		 je	 SHORT $LN8@CheckEnter
  0004d	83 f9 03	 cmp	 ecx, 3
  00050	74 34		 je	 SHORT $LN8@CheckEnter

; 1828 : 		}
; 1829 : 	}
; 1830 : 	else
; 1831 : 	{
; 1832 : 		if ( gObj[iIndex].Level >= g_sttCHAOSCASTLE_LEVEL[iLevel-1].iLOWER_BOUND && gObj[iIndex].Level <= g_sttCHAOSCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  00052	0f bf 88 9c 00
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+156]
  00059	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  0005c	c1 e0 04	 shl	 eax, 4
  0005f	8b 90 f0 ff ff
	ff		 mov	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax-16]
  00065	3b ca		 cmp	 ecx, edx
  00067	7c 46		 jl	 SHORT $LN21@CheckEnter
  00069	3b 88 f4 ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax-12]

; 1833 : 		{
; 1834 : 			return 0;

  0006f	7e 34		 jle	 SHORT $LN22@CheckEnter

; 1835 : 		}
; 1836 : 
; 1837 : 		if ( gObj[iIndex].Level < g_sttCHAOSCASTLE_LEVEL[iLevel-1].iLOWER_BOUND )

  00071	3b ca		 cmp	 ecx, edx

; 1838 : 		{
; 1839 : 			return -1;

  00073	7c 3a		 jl	 SHORT $LN21@CheckEnter

; 1840 : 		}
; 1841 : 
; 1842 : 		if ( gObj[iIndex].Level > g_sttCHAOSCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  00075	3b 88 f4 ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax-12]
  0007b	7e 46		 jle	 SHORT $LN10@CheckEnter

; 1843 : 		{
; 1844 : 			return 1;

  0007d	b8 01 00 00 00	 mov	 eax, 1

; 1845 : 		}
; 1846 : 	}
; 1847 : 
; 1848 : 	return 2;
; 1849 : }

  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
$LN8@CheckEnter:

; 1814 : 	{
; 1815 : 		if ( gObj[iIndex].Level >= g_sttCHAOSCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA && gObj[iIndex].Level <= g_sttCHAOSCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  00086	0f bf 88 9c 00
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+156]
  0008d	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  00090	c1 e0 04	 shl	 eax, 4
  00093	8b 90 f8 ff ff
	ff		 mov	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax-8]
  00099	3b ca		 cmp	 ecx, edx
  0009b	7c 12		 jl	 SHORT $LN21@CheckEnter
  0009d	3b 88 fc ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax-4]
  000a3	7f 06		 jg	 SHORT $LN7@CheckEnter
$LN22@CheckEnter:

; 1816 : 		{
; 1817 : 			return 0;

  000a5	33 c0		 xor	 eax, eax

; 1845 : 		}
; 1846 : 	}
; 1847 : 
; 1848 : 	return 2;
; 1849 : }

  000a7	5d		 pop	 ebp
  000a8	c2 08 00	 ret	 8
$LN7@CheckEnter:

; 1818 : 		}
; 1819 : 
; 1820 : 		if ( gObj[iIndex].Level < g_sttCHAOSCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA )

  000ab	3b ca		 cmp	 ecx, edx
  000ad	7d 07		 jge	 SHORT $LN6@CheckEnter
$LN21@CheckEnter:

; 1821 : 		{
; 1822 : 			return -1;

  000af	83 c8 ff	 or	 eax, -1

; 1845 : 		}
; 1846 : 	}
; 1847 : 
; 1848 : 	return 2;
; 1849 : }

  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
$LN6@CheckEnter:

; 1823 : 		}
; 1824 : 
; 1825 : 		if ( gObj[iIndex].Level > g_sttCHAOSCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  000b6	3b 88 fc ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax-4]

; 1826 : 		{
; 1827 : 			return 1;

  000bc	b8 01 00 00 00	 mov	 eax, 1
  000c1	7f 05		 jg	 SHORT $LN13@CheckEnter
$LN10@CheckEnter:

; 1809 : 	{
; 1810 : 		return 2;

  000c3	b8 02 00 00 00	 mov	 eax, 2
$LN13@CheckEnter:

; 1845 : 		}
; 1846 : 	}
; 1847 : 
; 1848 : 	return 2;
; 1849 : }

  000c8	5d		 pop	 ebp
  000c9	c2 08 00	 ret	 8
?CheckEnterLevel@CChaosCastle@@QAEHHH@Z ENDP		; CChaosCastle::CheckEnterLevel
_TEXT	ENDS
PUBLIC	?CheckEnterItem@CChaosCastle@@QAEHH@Z		; CChaosCastle::CheckEnterItem
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckEnterItem@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckEnterItem@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::CheckEnterItem, COMDAT
; _this$ = ecx

; 1852 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1853 : 	int iITEM_LEVEL = 0;
; 1854 : 
; 1855 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	33 f6		 xor	 esi, esi
  0000a	85 db		 test	 ebx, ebx
  0000c	78 0f		 js	 SHORT $LN20@CheckEnter@2
  0000e	33 c0		 xor	 eax, eax
  00010	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 08		 jne	 SHORT $LN10@CheckEnter@2
$LN20@CheckEnter@2:
  0001d	5e		 pop	 esi

; 1856 : 	{
; 1857 : 		return 0;

  0001e	33 c0		 xor	 eax, eax
  00020	5b		 pop	 ebx

; 1888 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN10@CheckEnter@2:

; 1858 : 	}
; 1859 : 
; 1860 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00025	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  0002b	66 83 bb 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+96], 1
  00033	75 e8		 jne	 SHORT $LN20@CheckEnter@2
  00035	80 bb 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+4], 2
  0003c	76 df		 jbe	 SHORT $LN20@CheckEnter@2

; 1861 : 	{
; 1862 : 		return 0;
; 1863 : 	}
; 1864 : 
; 1865 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  0003e	57		 push	 edi
  0003f	33 ff		 xor	 edi, edi
$LL7@CheckEnter@2:

; 1866 : 	{
; 1867 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00041	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3212]
  00047	03 cf		 add	 ecx, edi
  00049	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004e	83 f8 01	 cmp	 eax, 1
  00051	75 2f		 jne	 SHORT $LN6@CheckEnter@2

; 1868 : 		{
; 1869 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,29) )

  00053	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3212]
  00059	b9 1d 1a 00 00	 mov	 ecx, 6685		; 00001a1dH
  0005e	66 39 4c 38 06	 cmp	 WORD PTR [eax+edi+6], cx
  00063	75 1d		 jne	 SHORT $LN6@CheckEnter@2

; 1870 : 			{
; 1871 : 				iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;

  00065	0f bf 74 38 08	 movsx	 esi, WORD PTR [eax+edi+8]

; 1872 : 
; 1873 : 				if ( CHECK_LIMIT(iITEM_LEVEL, MAX_CHAOSCASTLE_LEVEL+2) == FALSE )	// #error Change 2 to 1

  0006a	85 f6		 test	 esi, esi
  0006c	78 0c		 js	 SHORT $LN21@CheckEnter@2
  0006e	33 c0		 xor	 eax, eax
  00070	83 fe 07	 cmp	 esi, 7
  00073	0f 9e c0	 setle	 al
  00076	85 c0		 test	 eax, eax
  00078	75 04		 jne	 SHORT $LN2@CheckEnter@2
$LN21@CheckEnter@2:

; 1874 : 				{
; 1875 : 					iITEM_LEVEL = 0;

  0007a	33 f6		 xor	 esi, esi

; 1876 : 
; 1877 : 				}
; 1878 : 
; 1879 : 				if ( iITEM_LEVEL != 0 )

  0007c	eb 04		 jmp	 SHORT $LN6@CheckEnter@2
$LN2@CheckEnter@2:
  0007e	85 f6		 test	 esi, esi
  00080	75 0e		 jne	 SHORT $LN5@CheckEnter@2
$LN6@CheckEnter@2:

; 1861 : 	{
; 1862 : 		return 0;
; 1863 : 	}
; 1864 : 
; 1865 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  00082	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00088	81 ff e0 31 00
	00		 cmp	 edi, 12768		; 000031e0H
  0008e	7c b1		 jl	 SHORT $LL7@CheckEnter@2
$LN5@CheckEnter@2:
  00090	5f		 pop	 edi

; 1880 : 				{
; 1881 : 					return iITEM_LEVEL;
; 1882 : 				}
; 1883 : 			}
; 1884 : 		}
; 1885 : 	}
; 1886 : 
; 1887 : 	return iITEM_LEVEL;

  00091	8b c6		 mov	 eax, esi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx

; 1888 : }

  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
?CheckEnterItem@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::CheckEnterItem
_TEXT	ENDS
PUBLIC	?CheckCanEnter@CChaosCastle@@QAE_NH@Z		; CChaosCastle::CheckCanEnter
; Function compile flags: /Ogtp
;	COMDAT ?CheckCanEnter@CChaosCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?CheckCanEnter@CChaosCastle@@QAE_NH@Z PROC		; CChaosCastle::CheckCanEnter, COMDAT
; _this$ = ecx

; 1915 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1916 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckCanEn
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 05	 cmp	 eax, 5
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckCanEn
$LN6@CheckCanEn:

; 1917 : 	{
; 1918 : 		return false;

  00016	32 c0		 xor	 al, al

; 1922 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckCanEn:

; 1919 : 	}
; 1920 : 
; 1921 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER;

  0001c	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  00022	8a 44 08 4c	 mov	 al, BYTE PTR [eax+ecx+76]

; 1922 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?CheckCanEnter@CChaosCastle@@QAE_NH@Z ENDP		; CChaosCastle::CheckCanEnter
_TEXT	ENDS
PUBLIC	?CheckPlayStart@CChaosCastle@@QAE_NH@Z		; CChaosCastle::CheckPlayStart
; Function compile flags: /Ogtp
;	COMDAT ?CheckPlayStart@CChaosCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?CheckPlayStart@CChaosCastle@@QAE_NH@Z PROC		; CChaosCastle::CheckPlayStart, COMDAT
; _this$ = ecx

; 1925 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1926 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckPlayS
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 05	 cmp	 eax, 5
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckPlayS
$LN6@CheckPlayS:

; 1927 : 	{
; 1928 : 		return false;

  00016	32 c0		 xor	 al, al

; 1932 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckPlayS:

; 1929 : 	}
; 1930 : 
; 1931 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START;

  0001c	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  00022	8a 44 08 4e	 mov	 al, BYTE PTR [eax+ecx+78]

; 1932 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?CheckPlayStart@CChaosCastle@@QAE_NH@Z ENDP		; CChaosCastle::CheckPlayStart
_TEXT	ENDS
PUBLIC	?GetCurrentState@CChaosCastle@@QAEHH@Z		; CChaosCastle::GetCurrentState
; Function compile flags: /Ogtp
;	COMDAT ?GetCurrentState@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?GetCurrentState@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurrentState, COMDAT
; _this$ = ecx

; 1954 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1955 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@GetCurrent
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 05	 cmp	 eax, 5
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 07		 jne	 SHORT $LN1@GetCurrent
$LN6@GetCurrent:

; 1956 : 	{
; 1957 : 		return -1;

  00016	83 c8 ff	 or	 eax, -1

; 1961 : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN1@GetCurrent:

; 1958 : 	}
; 1959 : 
; 1960 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_STATE;

  0001d	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  00023	8b 44 08 30	 mov	 eax, DWORD PTR [eax+ecx+48]

; 1961 : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?GetCurrentState@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurrentState
_TEXT	ENDS
PUBLIC	?GetCurEnteredUser@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetCurEnteredUser
; Function compile flags: /Ogtp
;	COMDAT ?GetCurEnteredUser@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?GetCurEnteredUser@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurEnteredUser, COMDAT
; _this$ = ecx

; 1964 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1965 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@GetCurEnte
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 05	 cmp	 eax, 5
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 07		 jne	 SHORT $LN1@GetCurEnte
$LN6@GetCurEnte:

; 1966 : 	{
; 1967 : 		return -1;

  00016	83 c8 ff	 or	 eax, -1

; 1971 : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN1@GetCurEnte:

; 1968 : 	}
; 1969 : 
; 1970 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER;

  0001d	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  00023	8b 44 08 54	 mov	 eax, DWORD PTR [eax+ecx+84]

; 1971 : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?GetCurEnteredUser@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurEnteredUser
_TEXT	ENDS
PUBLIC	?GetCurPlayUser@CChaosCastle@@QAEHH@Z		; CChaosCastle::GetCurPlayUser
; Function compile flags: /Ogtp
;	COMDAT ?GetCurPlayUser@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iPlayUser$ = 8						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetCurPlayUser@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurPlayUser, COMDAT
; _this$ = ecx

; 1974 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1975 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	78 0c		 js	 SHORT $LN13@GetCurPlay
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fb 05	 cmp	 ebx, 5
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	75 08		 jne	 SHORT $LN6@GetCurPlay
$LN13@GetCurPlay:

; 1976 : 	{
; 1977 : 		return -1;

  00017	83 c8 ff	 or	 eax, -1
  0001a	5b		 pop	 ebx

; 1995 : }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
$LN6@GetCurPlay:

; 1978 : 	}
; 1979 : 
; 1980 : 	int iPlayUser = 0;

  0001f	8b c3		 mov	 eax, ebx
  00021	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iPlayUser$[ebp], 0
  00030	8d 74 08 6c	 lea	 esi, DWORD PTR [eax+ecx+108]
  00034	bf 46 00 00 00	 mov	 edi, 70			; 00000046H
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL5@GetCurPlay:

; 1983 : 	{
; 1984 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	83 f8 ff	 cmp	 eax, -1
  00045	74 27		 je	 SHORT $LN4@GetCurPlay

; 1985 : 		{
; 1986 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) == TRUE &&
; 1987 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == ( iChaosCastleIndex+18) )

  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0004d	83 c4 04	 add	 esp, 4
  00050	83 f8 01	 cmp	 eax, 1
  00053	75 19		 jne	 SHORT $LN4@GetCurPlay
  00055	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00057	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0005d	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  00064	8d 43 12	 lea	 eax, DWORD PTR [ebx+18]
  00067	3b d0		 cmp	 edx, eax
  00069	75 03		 jne	 SHORT $LN4@GetCurPlay

; 1988 : 			{
; 1989 : 				iPlayUser++;

  0006b	ff 45 08	 inc	 DWORD PTR _iPlayUser$[ebp]
$LN4@GetCurPlay:

; 1981 : 
; 1982 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0006e	83 c6 14	 add	 esi, 20			; 00000014H
  00071	4f		 dec	 edi
  00072	75 cc		 jne	 SHORT $LL5@GetCurPlay

; 1990 : 			}
; 1991 : 		}
; 1992 : 	}
; 1993 : 
; 1994 : 	return iPlayUser;

  00074	8b 45 08	 mov	 eax, DWORD PTR _iPlayUser$[ebp]
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx

; 1995 : }

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?GetCurPlayUser@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurPlayUser
_TEXT	ENDS
PUBLIC	?GetCurrentRemainSec@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetCurrentRemainSec
; Function compile flags: /Ogtp
;	COMDAT ?GetCurrentRemainSec@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?GetCurrentRemainSec@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurrentRemainSec, COMDAT
; _this$ = ecx

; 2086 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2087 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 1000;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  0000c	8b 4c 08 40	 mov	 ecx, DWORD PTR [eax+ecx+64]
  00010	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00015	f7 e9		 imul	 ecx
  00017	c1 fa 06	 sar	 edx, 6
  0001a	8b c2		 mov	 eax, edx
  0001c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001f	03 c2		 add	 eax, edx

; 2088 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?GetCurrentRemainSec@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurrentRemainSec
_TEXT	ENDS
PUBLIC	?ObjSetPosition@CChaosCastle@@QAEHHHH@Z		; CChaosCastle::ObjSetPosition
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?ClearStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::ClearStandAttr
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
; Function compile flags: /Ogtp
;	COMDAT ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z
_TEXT	SEGMENT
_pMove2$ = -8						; size = 7
_iIndex$ = 8						; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
tv344 = 18						; size = 4
?ObjSetPosition@CChaosCastle@@QAEHHHH@Z PROC		; CChaosCastle::ObjSetPosition, COMDAT
; _this$ = ecx

; 2091 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2092 : 	if ( !OBJMAX_RANGE(iIndex))

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 0e		 js	 SHORT $LN13@ObjSetPosi
  0000d	33 c9		 xor	 ecx, ecx
  0000f	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00014	0f 9e c1	 setle	 cl
  00017	85 c9		 test	 ecx, ecx
  00019	75 0b		 jne	 SHORT $LN6@ObjSetPosi
$LN13@ObjSetPosi:

; 2093 : 		return TRUE;

  0001b	b8 01 00 00 00	 mov	 eax, 1

; 2153 : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
$LN6@ObjSetPosi:

; 2094 : 
; 2095 : 	LPOBJ lpObj = &gObj[iIndex];

  00026	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0002c	56		 push	 esi
  0002d	8d b0 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]

; 2096 : 
; 2097 : 	if ( !CC_MAP_RANGE(lpObj->MapNumber))

  00033	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00039	3c 12		 cmp	 al, 18			; 00000012H
  0003b	72 0c		 jb	 SHORT $LN14@ObjSetPosi
  0003d	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00042	3a c8		 cmp	 cl, al
  00044	1b c9		 sbb	 ecx, ecx
  00046	41		 inc	 ecx
  00047	75 09		 jne	 SHORT $LN5@ObjSetPosi
$LN14@ObjSetPosi:

; 2098 : 		return FALSE;

  00049	33 c0		 xor	 eax, eax
  0004b	5e		 pop	 esi

; 2153 : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 0c 00	 ret	 12			; 0000000cH
$LN5@ObjSetPosi:

; 2099 : 
; 2100 : 	if ( lpObj->Teleport )

  00052	80 be 00 02 00
	00 00		 cmp	 BYTE PTR [esi+512], 0
  00059	74 0c		 je	 SHORT $LN4@ObjSetPosi

; 2101 : 		return TRUE;

  0005b	b8 01 00 00 00	 mov	 eax, 1
  00060	5e		 pop	 esi

; 2153 : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 0c 00	 ret	 12			; 0000000cH
$LN4@ObjSetPosi:

; 2102 : 
; 2103 : 	BYTE btMapAttr = MapC[lpObj->MapNumber].GetAttr(iX, iY);

  00067	8b 55 0c	 mov	 edx, DWORD PTR _iX$[ebp]
  0006a	0f b6 c8	 movzx	 ecx, al
  0006d	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00073	53		 push	 ebx
  00074	8b 5d 10	 mov	 ebx, DWORD PTR _iY$[ebp]
  00077	53		 push	 ebx
  00078	52		 push	 edx
  00079	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0007f	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 2104 : 
; 2105 : 	if ( (btMapAttr&2) == 2 || (btMapAttr&4) == 4 )

  00084	a8 06		 test	 al, 6
  00086	0f 85 70 01 00
	00		 jne	 $LN2@ObjSetPosi

; 2107 : 
; 2108 : 	PMSG_POSISTION_SET pMove;
; 2109 : 
; 2110 : 	pMove.h.c = 0xC1;
; 2111 : 	pMove.h.headcode = PROTOCOL_POSITION;
; 2112 : 	pMove.h.size = sizeof(pMove);
; 2113 : 	pMove.X = iX;
; 2114 : 	pMove.Y = iY;
; 2115 : 
; 2116 : 	lpObj->m_Rest = 0;
; 2117 : 
; 2118 : 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX,lpObj->m_OldY);

  0008c	0f bf 86 1e 01
	00 00		 movsx	 eax, WORD PTR [esi+286]
  00093	0f bf 8e 1c 01
	00 00		 movsx	 ecx, WORD PTR [esi+284]
  0009a	57		 push	 edi
  0009b	50		 push	 eax
  0009c	51		 push	 ecx
  0009d	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  000a4	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  000aa	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000b0	c6 86 c1 01 00
	00 00		 mov	 BYTE PTR [esi+449], 0
  000b7	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 2119 : 	MapC[lpObj->MapNumber].SetStandAttr(iX,iY);

  000bc	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  000c3	8b 55 0c	 mov	 edx, DWORD PTR _iX$[ebp]
  000c6	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  000cc	53		 push	 ebx
  000cd	52		 push	 edx
  000ce	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000d4	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 2120 : 
; 2121 : 	lpObj->m_OldX = iX;

  000d9	8b 45 0c	 mov	 eax, DWORD PTR _iX$[ebp]

; 2122 : 	lpObj->m_OldY = iY;
; 2123 : 
; 2124 : 	lpObj->X = pMove.X;

  000dc	0f b6 f8	 movzx	 edi, al
  000df	66 89 86 1c 01
	00 00		 mov	 WORD PTR [esi+284], ax

; 2125 : 	lpObj->Y = pMove.Y;

  000e6	0f b6 c3	 movzx	 eax, bl

; 2126 : 
; 2127 : 	PMSG_RECV_POSISTION_SET pMove2;
; 2128 : 
; 2129 : 	PHeadSetB((LPBYTE)&pMove2, PROTOCOL_MOVE, sizeof(pMove2));

  000e9	6a 07		 push	 7
  000eb	66 89 45 12	 mov	 WORD PTR tv344[ebp], ax
  000ef	66 89 86 06 01
	00 00		 mov	 WORD PTR [esi+262], ax
  000f6	8d 45 f8	 lea	 eax, DWORD PTR _pMove2$[ebp]
  000f9	68 d3 00 00 00	 push	 211			; 000000d3H
  000fe	50		 push	 eax
  000ff	66 89 9e 1e 01
	00 00		 mov	 WORD PTR [esi+286], bx
  00106	66 89 be 04 01
	00 00		 mov	 WORD PTR [esi+260], di
  0010d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2130 : 	pMove2.NumberH = SET_NUMBERH(iIndex);

  00112	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]

; 2131 : 	pMove2.NumberL = SET_NUMBERL(iIndex);
; 2132 : 	pMove2.X = pMove.X;

  00115	8a 55 0c	 mov	 dl, BYTE PTR _iX$[ebp]
  00118	8b c8		 mov	 ecx, eax
  0011a	88 55 fd	 mov	 BYTE PTR _pMove2$[ebp+5], dl

; 2133 : 	pMove2.Y = pMove.Y;
; 2134 : 	lpObj->TX = pMove.X;
; 2135 : 	lpObj->TY = pMove.Y;
; 2136 : 
; 2137 : 	CreateFrustrum(lpObj->X, lpObj->Y, iIndex);

  0011d	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  00124	50		 push	 eax
  00125	c1 e9 08	 shr	 ecx, 8
  00128	88 45 fc	 mov	 BYTE PTR _pMove2$[ebp+4], al
  0012b	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR [esi+260]
  00132	88 4d fb	 mov	 BYTE PTR _pMove2$[ebp+3], cl
  00135	66 8b 4d 12	 mov	 cx, WORD PTR tv344[ebp]
  00139	52		 push	 edx
  0013a	50		 push	 eax
  0013b	88 5d fe	 mov	 BYTE PTR _pMove2$[ebp+6], bl
  0013e	66 89 be 20 01
	00 00		 mov	 WORD PTR [esi+288], di
  00145	66 89 8e 22 01
	00 00		 mov	 WORD PTR [esi+290], cx
  0014c	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  00151	83 c4 18	 add	 esp, 24			; 00000018H

; 2138 : 
; 2139 : 	if ( lpObj->Type == OBJ_USER )

  00154	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00159	5f		 pop	 edi
  0015a	75 15		 jne	 SHORT $LN1@ObjSetPosi

; 2140 : 	{
; 2141 : 		DataSend(iIndex, (UCHAR *)&pMove2, pMove2.h.size);

  0015c	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMove2$[ebp+1]
  00160	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00163	51		 push	 ecx
  00164	8d 55 f8	 lea	 edx, DWORD PTR _pMove2$[ebp]
  00167	52		 push	 edx
  00168	50		 push	 eax
  00169	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ObjSetPosi:

; 2142 : 	}
; 2143 : 
; 2144 : 	MsgSendV2(&gObj[iIndex], (UCHAR *)&pMove2, pMove2.h.size);

  00171	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMove2$[ebp+1]
  00175	51		 push	 ecx
  00176	8d 55 f8	 lea	 edx, DWORD PTR _pMove2$[ebp]
  00179	52		 push	 edx
  0017a	56		 push	 esi
  0017b	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 2145 : 
; 2146 : 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  00180	0f bf 86 1e 01
	00 00		 movsx	 eax, WORD PTR [esi+286]
  00187	0f bf 8e 1c 01
	00 00		 movsx	 ecx, WORD PTR [esi+284]
  0018e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00191	50		 push	 eax
  00192	51		 push	 ecx
  00193	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  0019a	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  001a0	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  001a6	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 2147 : 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->TX, lpObj->TY);

  001ab	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  001b2	0f bf 96 22 01
	00 00		 movsx	 edx, WORD PTR [esi+290]
  001b9	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  001bf	0f bf 86 20 01
	00 00		 movsx	 eax, WORD PTR [esi+288]
  001c6	52		 push	 edx
  001c7	50		 push	 eax
  001c8	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  001ce	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 2148 : 
; 2149 : 	lpObj->m_OldX = lpObj->TX;

  001d3	66 8b 8e 20 01
	00 00		 mov	 cx, WORD PTR [esi+288]

; 2150 : 	lpObj->m_OldY = lpObj->TY;

  001da	66 8b 96 22 01
	00 00		 mov	 dx, WORD PTR [esi+290]
  001e1	5b		 pop	 ebx
  001e2	66 89 8e 1c 01
	00 00		 mov	 WORD PTR [esi+284], cx
  001e9	66 89 96 1e 01
	00 00		 mov	 WORD PTR [esi+286], dx

; 2151 : 
; 2152 : 	return TRUE;

  001f0	b8 01 00 00 00	 mov	 eax, 1
  001f5	5e		 pop	 esi

; 2153 : }

  001f6	8b e5		 mov	 esp, ebp
  001f8	5d		 pop	 ebp
  001f9	c2 0c 00	 ret	 12			; 0000000cH
$LN2@ObjSetPosi:
  001fc	5b		 pop	 ebx

; 2106 : 		return FALSE;

  001fd	33 c0		 xor	 eax, eax
  001ff	5e		 pop	 esi

; 2153 : }

  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c2 0c 00	 ret	 12			; 0000000cH
?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ENDP		; CChaosCastle::ObjSetPosition
_TEXT	ENDS
PUBLIC	?BlowObjsToPoint@CChaosCastle@@QAEHHHHH@Z	; CChaosCastle::BlowObjsToPoint
; Function compile flags: /Ogtp
;	COMDAT ?BlowObjsToPoint@CChaosCastle@@QAEHHHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iMapNumber$ = 12					; size = 4
_iX$ = 16						; size = 4
_iY$ = 20						; size = 4
?BlowObjsToPoint@CChaosCastle@@QAEHHHHH@Z PROC		; CChaosCastle::BlowObjsToPoint, COMDAT
; _this$ = ecx

; 2306 : 	return TRUE;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 2307 : }

  00005	c2 10 00	 ret	 16			; 00000010H
?BlowObjsToPoint@CChaosCastle@@QAEHHHHH@Z ENDP		; CChaosCastle::BlowObjsToPoint
_TEXT	ENDS
PUBLIC	?SafetyCastleZone@CChaosCastle@@QAEXH@Z		; CChaosCastle::SafetyCastleZone
; Function compile flags: /Ogtp
;	COMDAT ?SafetyCastleZone@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
tv248 = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SafetyCastleZone@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::SafetyCastleZone, COMDAT
; _this$ = ecx

; 2345 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2346 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]
  00008	85 db		 test	 ebx, ebx
  0000a	0f 88 dc 00 00
	00		 js	 $LN7@SafetyCast
  00010	33 c0		 xor	 eax, eax
  00012	83 fb 05	 cmp	 ebx, 5
  00015	0f 9e c0	 setle	 al
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 cc 00 00
	00		 je	 $LN7@SafetyCast

; 2347 : 		return ;
; 2348 : 
; 2349 : 	for ( int i=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][0] ; i <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][2] ; i++ )

  00020	0f b6 04 9d 02
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+2]
  00028	56		 push	 esi
  00029	0f b6 34 9d 00
	00 00 00	 movzx	 esi, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4]
  00031	57		 push	 edi
  00032	3b f0		 cmp	 esi, eax
  00034	7f 52		 jg	 SHORT $LN13@SafetyCast
  00036	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+3]
  0003e	8b ff		 npad	 2
$LL15@SafetyCast:

; 2350 : 	{
; 2351 : 		for (int j=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][1] ; j <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][3] ; j++ )

  00040	0f b6 14 9d 01
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+1]
  00048	3b d0		 cmp	 edx, eax
  0004a	7f 2f		 jg	 SHORT $LN14@SafetyCast
  0004c	8b cb		 mov	 ecx, ebx
  0004e	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00054	8d b9 a0 7e 5a
	00		 lea	 edi, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+5930656]
  0005a	8b ca		 mov	 ecx, edx
  0005c	c1 e1 08	 shl	 ecx, 8
  0005f	90		 npad	 1
$LL12@SafetyCast:

; 2352 : 		{
; 2353 : 			MapC[iChaosCastleIndex+18].m_attrbuf[ j * 256 + i] |= 1;

  00060	8b 07		 mov	 eax, DWORD PTR [edi]
  00062	03 c1		 add	 eax, ecx
  00064	80 0c 30 01	 or	 BYTE PTR [eax+esi], 1
  00068	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+3]
  00070	42		 inc	 edx
  00071	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00077	3b d0		 cmp	 edx, eax
  00079	7e e5		 jle	 SHORT $LL12@SafetyCast
$LN14@SafetyCast:

; 2347 : 		return ;
; 2348 : 
; 2349 : 	for ( int i=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][0] ; i <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][2] ; i++ )

  0007b	0f b6 0c 9d 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+2]
  00083	46		 inc	 esi
  00084	3b f1		 cmp	 esi, ecx
  00086	7e b8		 jle	 SHORT $LL15@SafetyCast
$LN13@SafetyCast:

; 2354 : 		}
; 2355 : 	}
; 2356 : 
; 2357 : 	for ( int iHOLE_NUM = 0; iHOLE_NUM <2;iHOLE_NUM++)

  00088	8d 34 dd 03 00
	00 00		 lea	 esi, DWORD PTR _g_btCastleCenterHollowZoneMapXY[ebx*8+3]
  0008f	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR tv248[ebp], 2
$LL9@SafetyCast:

; 2358 : 	{
; 2359 : 		for (int i=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][0] ; i<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][2] ; i++ )

  00096	0f b6 7e fd	 movzx	 edi, BYTE PTR [esi-3]
  0009a	0f b6 56 ff	 movzx	 edx, BYTE PTR [esi-1]
  0009e	3b fa		 cmp	 edi, edx
  000a0	7f 40		 jg	 SHORT $LN8@SafetyCast
  000a2	0f b6 06	 movzx	 eax, BYTE PTR [esi]
$LL6@SafetyCast:

; 2360 : 		{
; 2361 : 			for (int j=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][1] ; j<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][3] ; j++ )

  000a5	0f b6 56 fe	 movzx	 edx, BYTE PTR [esi-2]
  000a9	3b d0		 cmp	 edx, eax
  000ab	7f 2c		 jg	 SHORT $LN5@SafetyCast
  000ad	69 db 08 07 05
	00		 imul	 ebx, 329480		; 00050708H
  000b3	8b ca		 mov	 ecx, edx
  000b5	8d 9b a0 7e 5a
	00		 lea	 ebx, DWORD PTR ?MapC@@3PAVMapClass@@A[ebx+5930656]
  000bb	c1 e1 08	 shl	 ecx, 8
  000be	8b ff		 npad	 2
$LL3@SafetyCast:

; 2362 : 			{
; 2363 : 				MapC[iChaosCastleIndex+18].m_attrbuf[ j * 256 + i] |= 8;

  000c0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c2	03 c1		 add	 eax, ecx
  000c4	80 0c 38 08	 or	 BYTE PTR [eax+edi], 8
  000c8	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  000cb	42		 inc	 edx
  000cc	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  000d2	3b d0		 cmp	 edx, eax
  000d4	7e ea		 jle	 SHORT $LL3@SafetyCast

; 2360 : 		{
; 2361 : 			for (int j=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][1] ; j<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][3] ; j++ )

  000d6	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]
$LN5@SafetyCast:

; 2358 : 	{
; 2359 : 		for (int i=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][0] ; i<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][2] ; i++ )

  000d9	0f b6 4e ff	 movzx	 ecx, BYTE PTR [esi-1]
  000dd	47		 inc	 edi
  000de	3b f9		 cmp	 edi, ecx
  000e0	7e c3		 jle	 SHORT $LL6@SafetyCast
$LN8@SafetyCast:

; 2354 : 		}
; 2355 : 	}
; 2356 : 
; 2357 : 	for ( int iHOLE_NUM = 0; iHOLE_NUM <2;iHOLE_NUM++)

  000e2	83 c6 04	 add	 esi, 4
  000e5	ff 4d fc	 dec	 DWORD PTR tv248[ebp]
  000e8	75 ac		 jne	 SHORT $LL9@SafetyCast
  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
$LN7@SafetyCast:
  000ec	5b		 pop	 ebx

; 2364 : 			}
; 2365 : 		}
; 2366 : 	}
; 2367 : }

  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 04 00	 ret	 4
?SafetyCastleZone@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::SafetyCastleZone
_TEXT	ENDS
PUBLIC	?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z	; CChaosCastle::UnSafetyCastleZone
; Function compile flags: /Ogtp
;	COMDAT ?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
tv248 = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::UnSafetyCastleZone, COMDAT
; _this$ = ecx

; 2370 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2371 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]
  00008	85 db		 test	 ebx, ebx
  0000a	0f 88 dc 00 00
	00		 js	 $LN7@UnSafetyCa
  00010	33 c0		 xor	 eax, eax
  00012	83 fb 05	 cmp	 ebx, 5
  00015	0f 9e c0	 setle	 al
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 cc 00 00
	00		 je	 $LN7@UnSafetyCa

; 2372 : 		return ;
; 2373 : 
; 2374 : 	for ( int i=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][0] ; i <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][2] ; i++ )

  00020	0f b6 04 9d 02
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+2]
  00028	56		 push	 esi
  00029	0f b6 34 9d 00
	00 00 00	 movzx	 esi, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4]
  00031	57		 push	 edi
  00032	3b f0		 cmp	 esi, eax
  00034	7f 52		 jg	 SHORT $LN13@UnSafetyCa
  00036	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+3]
  0003e	8b ff		 npad	 2
$LL15@UnSafetyCa:

; 2375 : 	{
; 2376 : 		for (int j=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][1] ; j <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][3] ; j++ )

  00040	0f b6 14 9d 01
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+1]
  00048	3b d0		 cmp	 edx, eax
  0004a	7f 2f		 jg	 SHORT $LN14@UnSafetyCa
  0004c	8b cb		 mov	 ecx, ebx
  0004e	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00054	8d b9 a0 7e 5a
	00		 lea	 edi, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+5930656]
  0005a	8b ca		 mov	 ecx, edx
  0005c	c1 e1 08	 shl	 ecx, 8
  0005f	90		 npad	 1
$LL12@UnSafetyCa:

; 2377 : 		{
; 2378 : 			MapC[iChaosCastleIndex+18].m_attrbuf[ j * 256 + i] &= ~1;

  00060	8b 07		 mov	 eax, DWORD PTR [edi]
  00062	03 c1		 add	 eax, ecx
  00064	80 24 30 fe	 and	 BYTE PTR [eax+esi], 254	; 000000feH
  00068	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+3]
  00070	42		 inc	 edx
  00071	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00077	3b d0		 cmp	 edx, eax
  00079	7e e5		 jle	 SHORT $LL12@UnSafetyCa
$LN14@UnSafetyCa:

; 2372 : 		return ;
; 2373 : 
; 2374 : 	for ( int i=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][0] ; i <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][2] ; i++ )

  0007b	0f b6 0c 9d 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+2]
  00083	46		 inc	 esi
  00084	3b f1		 cmp	 esi, ecx
  00086	7e b8		 jle	 SHORT $LL15@UnSafetyCa
$LN13@UnSafetyCa:

; 2379 : 		}
; 2380 : 	}
; 2381 : 
; 2382 : 	for ( int iHOLE_NUM = 0; iHOLE_NUM <2;iHOLE_NUM++)

  00088	8d 34 dd 03 00
	00 00		 lea	 esi, DWORD PTR _g_btCastleCenterHollowZoneMapXY[ebx*8+3]
  0008f	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR tv248[ebp], 2
$LL9@UnSafetyCa:

; 2383 : 	{
; 2384 : 		for (int i=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][0] ; i<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][2] ; i++ )

  00096	0f b6 7e fd	 movzx	 edi, BYTE PTR [esi-3]
  0009a	0f b6 56 ff	 movzx	 edx, BYTE PTR [esi-1]
  0009e	3b fa		 cmp	 edi, edx
  000a0	7f 40		 jg	 SHORT $LN8@UnSafetyCa
  000a2	0f b6 06	 movzx	 eax, BYTE PTR [esi]
$LL6@UnSafetyCa:

; 2385 : 		{
; 2386 : 			for (int j=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][1] ; j<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][3] ; j++ )

  000a5	0f b6 56 fe	 movzx	 edx, BYTE PTR [esi-2]
  000a9	3b d0		 cmp	 edx, eax
  000ab	7f 2c		 jg	 SHORT $LN5@UnSafetyCa
  000ad	69 db 08 07 05
	00		 imul	 ebx, 329480		; 00050708H
  000b3	8b ca		 mov	 ecx, edx
  000b5	8d 9b a0 7e 5a
	00		 lea	 ebx, DWORD PTR ?MapC@@3PAVMapClass@@A[ebx+5930656]
  000bb	c1 e1 08	 shl	 ecx, 8
  000be	8b ff		 npad	 2
$LL3@UnSafetyCa:

; 2387 : 			{
; 2388 : 				MapC[iChaosCastleIndex+18].m_attrbuf[ j * 256 + i] |= 8;

  000c0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c2	03 c1		 add	 eax, ecx
  000c4	80 0c 38 08	 or	 BYTE PTR [eax+edi], 8
  000c8	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  000cb	42		 inc	 edx
  000cc	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  000d2	3b d0		 cmp	 edx, eax
  000d4	7e ea		 jle	 SHORT $LL3@UnSafetyCa

; 2385 : 		{
; 2386 : 			for (int j=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][1] ; j<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][3] ; j++ )

  000d6	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]
$LN5@UnSafetyCa:

; 2383 : 	{
; 2384 : 		for (int i=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][0] ; i<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][2] ; i++ )

  000d9	0f b6 4e ff	 movzx	 ecx, BYTE PTR [esi-1]
  000dd	47		 inc	 edi
  000de	3b f9		 cmp	 edi, ecx
  000e0	7e c3		 jle	 SHORT $LL6@UnSafetyCa
$LN8@UnSafetyCa:

; 2379 : 		}
; 2380 : 	}
; 2381 : 
; 2382 : 	for ( int iHOLE_NUM = 0; iHOLE_NUM <2;iHOLE_NUM++)

  000e2	83 c6 04	 add	 esi, 4
  000e5	ff 4d fc	 dec	 DWORD PTR tv248[ebp]
  000e8	75 ac		 jne	 SHORT $LL9@UnSafetyCa
  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
$LN7@UnSafetyCa:
  000ec	5b		 pop	 ebx

; 2389 : 			}
; 2390 : 		}
; 2391 : 	}
; 2392 : }

  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 04 00	 ret	 4
?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::UnSafetyCastleZone
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z ; CChaosCastle::SendCastleZoneSafetyInfo
; Function compile flags: /Ogtp
;	COMDAT ?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z
_TEXT	SEGMENT
_cTEMP_BUF$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_bDoSet$ = 12						; size = 1
?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z PROC	; CChaosCastle::SendCastleZoneSafetyInfo, COMDAT
; _this$ = ecx

; 2395 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 2396 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00014	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	0f 88 be 00 00
	00		 js	 $LN3@SendCastle
  0001f	33 c0		 xor	 eax, eax
  00021	83 fe 05	 cmp	 esi, 5
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 ae 00 00
	00		 je	 $LN3@SendCastle

; 2397 : 		return ;
; 2398 : 
; 2399 : 	char cTEMP_BUF[256];
; 2400 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;
; 2401 : 
; 2402 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  0002f	53		 push	 ebx
  00030	57		 push	 edi
  00031	6a 13		 push	 19			; 00000013H
  00033	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  00039	6a 46		 push	 70			; 00000046H
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2403 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];
; 2404 : 	lpMsg->btType = 0;
; 2405 : 	lpMsg->btCount = 1;
; 2406 : 	lpMsg->btMapAttr = 1;
; 2407 : 	(bDoSet)?(lpMsg->btMapSetType=0) :( lpMsg->btMapSetType=1);
; 2408 : 
; 2409 : 	lpMsgBody[0].btX = ::g_btCastleSafetyZoneMapXY[iChaosCastleIndex][0];

  00041	0f b6 14 b5 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleSafetyZoneMapXY[esi*4]

; 2410 : 	lpMsgBody[0].btY = ::g_btCastleSafetyZoneMapXY[iChaosCastleIndex][1];

  00049	8a 04 b5 01 00
	00 00		 mov	 al, BYTE PTR _g_btCastleSafetyZoneMapXY[esi*4+1]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	80 7d 0c 00	 cmp	 BYTE PTR _bDoSet$[ebp], 0
  00057	88 95 03 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+7], dl

; 2411 : 	lpMsgBody[1].btX   = ::g_btCastleSafetyZoneMapXY[iChaosCastleIndex][2];
; 2412 : 	lpMsgBody[1].btY   = ::g_btCastleSafetyZoneMapXY[iChaosCastleIndex][3];

  0005d	0f b6 14 b5 03
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleSafetyZoneMapXY[esi*4+3]
  00065	0f 94 c1	 sete	 cl
  00068	88 8d 01 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+5], cl
  0006e	8a 0c b5 02 00
	00 00		 mov	 cl, BYTE PTR _g_btCastleSafetyZoneMapXY[esi*4+2]
  00075	8d 5e 12	 lea	 ebx, DWORD PTR [esi+18]
  00078	c6 85 02 ff ff
	ff 01		 mov	 BYTE PTR _cTEMP_BUF$[ebp+6], 1
  0007f	66 c7 85 ff fe
	ff ff 00 01	 mov	 WORD PTR _cTEMP_BUF$[ebp+3], 256 ; 00000100H
  00088	88 85 04 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+8], al
  0008e	88 8d 05 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+9], cl
  00094	88 95 06 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+10], dl

; 2413 : 
; 2414 : 	for (int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  0009a	bf 00 19 00 00	 mov	 edi, 6400		; 00001900H
  0009f	be 04 c4 16 02	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046404
$LL5@SendCastle:

; 2415 : 	{
; 2416 : 		if ( gObj[i].MapNumber == (iChaosCastleIndex + 18) )

  000a4	0f b6 86 05 01
	00 00		 movzx	 eax, BYTE PTR [esi+261]
  000ab	3b c3		 cmp	 eax, ebx
  000ad	75 1d		 jne	 SHORT $LN4@SendCastle

; 2417 : 		{
; 2418 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  000af	80 3e 02	 cmp	 BYTE PTR [esi], 2
  000b2	76 18		 jbe	 SHORT $LN4@SendCastle

; 2419 : 			{
; 2420 : 				DataSend(i, (unsigned char *)lpMsg, lpMsg->h.size);

  000b4	0f b6 8d fd fe
	ff ff		 movzx	 ecx, BYTE PTR _cTEMP_BUF$[ebp+1]
  000bb	51		 push	 ecx
  000bc	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _cTEMP_BUF$[ebp]
  000c2	52		 push	 edx
  000c3	57		 push	 edi
  000c4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendCastle:

; 2413 : 
; 2414 : 	for (int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  000cc	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  000d2	47		 inc	 edi
  000d3	81 fe a4 52 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522404
  000d9	7c c9		 jl	 SHORT $LL5@SendCastle
  000db	5f		 pop	 edi
  000dc	5b		 pop	 ebx
$LN3@SendCastle:

; 2421 : 			}
; 2422 : 		}
; 2423 : 	}
; 2424 : }

  000dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e0	33 cd		 xor	 ecx, ebp
  000e2	5e		 pop	 esi
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 08 00	 ret	 8
?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z ENDP	; CChaosCastle::SendCastleZoneSafetyInfo
_TEXT	ENDS
PUBLIC	??_C@_0GA@JMGLBJMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pay@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?PlayFailedRollBack@CChaosCastle@@QAEXH@Z	; CChaosCastle::PlayFailedRollBack
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
;	COMDAT ??_C@_0GA@JMGLBJMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pay@
CONST	SEGMENT
??_C@_0GA@JMGLBJMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pay@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Payback to User ChaosCastle Money'
	DB	' (FIRST:%d, PAYBACK:%d, FINAL:%d)', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?PlayFailedRollBack@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
_iFIRST_MONEY$159819 = -288				; size = 4
_iPAYBACK_MONEY$159820 = -284				; size = 4
tv186 = -280						; size = 4
_Notice$159822 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?PlayFailedRollBack@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::PlayFailedRollBack, COMDAT
; _this$ = ecx

; 2546 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]

; 2547 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00017	85 ff		 test	 edi, edi
  00019	0f 88 45 01 00
	00		 js	 $LN3@PlayFailed
  0001f	33 c0		 xor	 eax, eax
  00021	83 ff 05	 cmp	 edi, 5
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 35 01 00
	00		 je	 $LN3@PlayFailed

; 2548 : 		return;
; 2549 : 
; 2550 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0002f	8b c7		 mov	 eax, edi
  00031	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  00037	53		 push	 ebx
  00038	56		 push	 esi
  00039	8d 74 08 6c	 lea	 esi, DWORD PTR [eax+ecx+108]
  0003d	c7 85 e8 fe ff
	ff 46 00 00 00	 mov	 DWORD PTR tv186[ebp], 70 ; 00000046H
  00047	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL5@PlayFailed:

; 2551 : 	{
; 2552 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00050	8b 06		 mov	 eax, DWORD PTR [esi]
  00052	83 f8 ff	 cmp	 eax, -1
  00055	0f 84 f8 00 00
	00		 je	 $LN4@PlayFailed

; 2553 : 		{
; 2554 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) ==TRUE &&
; 2555 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == (iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1) )

  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00061	83 c4 04	 add	 esp, 4
  00064	83 f8 01	 cmp	 eax, 1
  00067	0f 85 e6 00 00
	00		 jne	 $LN4@PlayFailed
  0006d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006f	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00075	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  0007c	8d 47 12	 lea	 eax, DWORD PTR [edi+18]
  0007f	3b d0		 cmp	 edx, eax
  00081	0f 85 cc 00 00
	00		 jne	 $LN4@PlayFailed

; 2556 : 			{
; 2557 : 				int iFIRST_MONEY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Money;

  00087	8b 06		 mov	 eax, DWORD PTR [esi]

; 2558 : 				int iPAYBACK_MONEY = g_iChaosCastle_EnterCost[iChaosCastleIndex] + g_iChaosCastle_GuardSetValue[iChaosCastleIndex];

  00089	8b 14 bd 00 00
	00 00		 mov	 edx, DWORD PTR _g_iChaosCastle_GuardSetValue[edi*4]
  00090	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00096	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+176]
  0009c	8b 1c bd 00 00
	00 00		 mov	 ebx, DWORD PTR _g_iChaosCastle_EnterCost[edi*4]
  000a3	8d 80 b0 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+176]
  000a9	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _iFIRST_MONEY$159819[ebp], ecx

; 2559 : 				gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Money += g_iChaosCastle_EnterCost[iChaosCastleIndex] + g_iChaosCastle_GuardSetValue[iChaosCastleIndex];

  000af	03 0c bd 00 00
	00 00		 add	 ecx, DWORD PTR _g_iChaosCastle_EnterCost[edi*4]
  000b6	03 da		 add	 ebx, edx
  000b8	03 ca		 add	 ecx, edx
  000ba	89 08		 mov	 DWORD PTR [eax], ecx

; 2560 : 				int iNOW_MONEY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Money;

  000bc	8b 06		 mov	 eax, DWORD PTR [esi]
  000be	8b c8		 mov	 ecx, eax
  000c0	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000c6	89 9d e4 fe ff
	ff		 mov	 DWORD PTR _iPAYBACK_MONEY$159820[ebp], ebx
  000cc	8b 99 b0 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+176]

; 2561 : 
; 2562 : 				GCMoneySend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Money);

  000d2	53		 push	 ebx
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 2563 : 				gObjMoveGate(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, 22);

  000d9	8b 16		 mov	 edx, DWORD PTR [esi]
  000db	6a 16		 push	 22			; 00000016H
  000dd	52		 push	 edx
  000de	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000e3	83 c4 10	 add	 esp, 16			; 00000010H

; 2564 : 
; 2565 : 				PMSG_NOTICE Notice;
; 2566 : 
; 2567 : 				TNotice::MakeNoticeMsgEx(&Notice, 1, lMsg.Get(MSGGET(4,212)));

  000e6	68 d4 04 00 00	 push	 1236			; 000004d4H
  000eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000f0	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000f5	50		 push	 eax
  000f6	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _Notice$159822[ebp]
  000fc	6a 01		 push	 1
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 2568 : 
; 2569 : 				DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, (LPBYTE)&Notice, Notice.h.size);

  00104	0f b6 8d ed fe
	ff ff		 movzx	 ecx, BYTE PTR _Notice$159822[ebp+1]
  0010b	8b 06		 mov	 eax, DWORD PTR [esi]
  0010d	51		 push	 ecx
  0010e	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _Notice$159822[ebp]
  00114	52		 push	 edx
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2570 : 
; 2571 : 				LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] Payback to User ChaosCastle Money (FIRST:%d, PAYBACK:%d, FINAL:%d)",
; 2572 : 					iChaosCastleIndex+1, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].AccountID,
; 2573 : 					gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Name,
; 2574 : 					iFIRST_MONEY, iPAYBACK_MONEY, iNOW_MONEY);

  0011b	8b 06		 mov	 eax, DWORD PTR [esi]
  0011d	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _iPAYBACK_MONEY$159820[ebp]
  00123	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00129	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _iFIRST_MONEY$159819[ebp]
  0012f	53		 push	 ebx
  00130	51		 push	 ecx
  00131	52		 push	 edx
  00132	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  00138	51		 push	 ecx
  00139	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  0013f	52		 push	 edx
  00140	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00143	50		 push	 eax
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@JMGLBJMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pay@
  00149	6a 00		 push	 0
  0014b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00150	83 c4 38	 add	 esp, 56			; 00000038H
$LN4@PlayFailed:

; 2548 : 		return;
; 2549 : 
; 2550 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00153	83 c6 14	 add	 esi, 20			; 00000014H
  00156	ff 8d e8 fe ff
	ff		 dec	 DWORD PTR tv186[ebp]
  0015c	0f 85 ee fe ff
	ff		 jne	 $LL5@PlayFailed
  00162	5e		 pop	 esi
  00163	5b		 pop	 ebx
$LN3@PlayFailed:

; 2575 : 
; 2576 : 			}
; 2577 : 		}
; 2578 : 	}
; 2579 : }

  00164	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00167	33 cd		 xor	 ecx, ebp
  00169	5f		 pop	 edi
  0016a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c2 04 00	 ret	 4
?PlayFailedRollBack@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::PlayFailedRollBack
_TEXT	ENDS
PUBLIC	?CalUsersInTrap@CChaosCastle@@QAEXH@Z		; CChaosCastle::CalUsersInTrap
EXTRN	?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z:PROC	; GCStateInfoSend
; Function compile flags: /Ogtp
;	COMDAT ?CalUsersInTrap@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv359 = -8						; size = 4
tv241 = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?CalUsersInTrap@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::CalUsersInTrap, COMDAT
; _this$ = ecx

; 2666 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2667 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00006	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  00009	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	85 d2		 test	 edx, edx
  0000e	0f 88 9c 01 00
	00		 js	 $LN6@CalUsersIn
  00014	33 c0		 xor	 eax, eax
  00016	83 fa 05	 cmp	 edx, 5
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 8c 01 00
	00		 je	 $LN6@CalUsersIn

; 2668 : 		return;
; 2669 : 
; 2670 : 	if (this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS== 0 )

  00024	69 d2 6c 08 00
	00		 imul	 edx, 2156		; 0000086cH
  0002a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0002d	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00030	89 4d f8	 mov	 DWORD PTR tv359[ebp], ecx
  00033	85 c9		 test	 ecx, ecx
  00035	0f 84 75 01 00
	00		 je	 $LN6@CalUsersIn

; 2671 : 		return;
; 2672 : 
; 2673 : 	if ( !CHECK_LIMIT(this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS, 4))

  0003b	0f 88 6f 01 00
	00		 js	 $LN6@CalUsersIn
  00041	33 d2		 xor	 edx, edx
  00043	83 f9 03	 cmp	 ecx, 3
  00046	0f 9e c2	 setle	 dl
  00049	8b ca		 mov	 ecx, edx
  0004b	85 c9		 test	 ecx, ecx
  0004d	0f 84 5d 01 00
	00		 je	 $LN6@CalUsersIn

; 2674 : 		return;
; 2675 : 
; 2676 : 	int iTRAP_STEP = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS;

  00053	53		 push	 ebx
  00054	56		 push	 esi
  00055	57		 push	 edi
  00056	8d 70 6c	 lea	 esi, DWORD PTR [eax+108]
  00059	c7 45 fc 46 00
	00 00		 mov	 DWORD PTR tv241[ebp], 70 ; 00000046H
  00060	bb 01 00 00 00	 mov	 ebx, 1
$LL8@CalUsersIn:

; 2679 : 	{
; 2680 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	83 f8 ff	 cmp	 eax, -1
  0006a	0f 84 31 01 00
	00		 je	 $LN7@CalUsersIn

; 2681 : 		{
; 2682 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) ==TRUE &&
; 2683 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == (iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1) )

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00076	83 c4 04	 add	 esp, 4
  00079	3b c3		 cmp	 eax, ebx
  0007b	0f 85 20 01 00
	00		 jne	 $LN7@CalUsersIn
  00081	8b 3e		 mov	 edi, DWORD PTR [esi]
  00083	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  00086	8b c7		 mov	 eax, edi
  00088	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0008e	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00095	83 c2 12	 add	 edx, 18			; 00000012H
  00098	3b ca		 cmp	 ecx, edx
  0009a	0f 85 01 01 00
	00		 jne	 $LN7@CalUsersIn

; 2684 : 			{
; 2685 : 				int iSX = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].X;

  000a0	8b c7		 mov	 eax, edi
  000a2	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000a8	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]

; 2686 : 				int iSY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Y;

  000af	0f bf 90 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]

; 2687 : 				
; 2688 : 				if ( iSX >= g_iChaosCastle_GroundAxis[0] &&
; 2689 : 					 iSX <= g_iChaosCastle_GroundAxis[2] &&
; 2690 : 					 iSY >= g_iChaosCastle_GroundAxis[1] &&
; 2691 : 					 iSY <= g_iChaosCastle_GroundAxis[3] &&
; 2692 : 					 ( iSX < g_iChaosCastle_DamageAxis[iTRAP_STEP][0] ||
; 2693 : 					   iSX > g_iChaosCastle_DamageAxis[iTRAP_STEP][2] ||
; 2694 : 					   iSY < g_iChaosCastle_DamageAxis[iTRAP_STEP][1] ||
; 2695 : 					   iSY > g_iChaosCastle_DamageAxis[iTRAP_STEP][3] ) )

  000b6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_GroundAxis
  000bc	0f 8c df 00 00
	00		 jl	 $LN7@CalUsersIn
  000c2	3b 0d 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_GroundAxis+8
  000c8	0f 8f d3 00 00
	00		 jg	 $LN7@CalUsersIn
  000ce	3b 15 04 00 00
	00		 cmp	 edx, DWORD PTR _g_iChaosCastle_GroundAxis+4
  000d4	0f 8c c7 00 00
	00		 jl	 $LN7@CalUsersIn
  000da	3b 15 0c 00 00
	00		 cmp	 edx, DWORD PTR _g_iChaosCastle_GroundAxis+12
  000e0	0f 8f bb 00 00
	00		 jg	 $LN7@CalUsersIn
  000e6	8b 45 f8	 mov	 eax, DWORD PTR tv359[ebp]
  000e9	c1 e0 04	 shl	 eax, 4
  000ec	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax]
  000f2	7c 1c		 jl	 SHORT $LN2@CalUsersIn
  000f4	3b 88 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+8]
  000fa	7f 14		 jg	 SHORT $LN2@CalUsersIn
  000fc	3b 90 04 00 00
	00		 cmp	 edx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+4]
  00102	7c 0c		 jl	 SHORT $LN2@CalUsersIn
  00104	3b 90 0c 00 00
	00		 cmp	 edx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+12]
  0010a	0f 8e 91 00 00
	00		 jle	 $LN7@CalUsersIn
$LN2@CalUsersIn:

; 2696 : 				{
; 2697 : 					this->GiveUserDamage(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, 10);

  00110	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	6a 0a		 push	 10			; 0000000aH
  00115	57		 push	 edi
  00116	e8 00 00 00 00	 call	 ?GiveUserDamage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::GiveUserDamage

; 2698 : 					
; 2699 : 					if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_ColdBeattackCount <= 0 )

  0011b	8b 06		 mov	 eax, DWORD PTR [esi]
  0011d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00123	80 b8 28 02 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+552], 0
  0012a	7f 75		 jg	 SHORT $LN7@CalUsersIn

; 2700 : 					{
; 2701 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_ColdBeattackCount = 3;

  0012c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0012e	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00134	c6 81 28 02 00
	00 03		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+552], 3

; 2702 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].lpAttackObj = NULL;

  0013b	8b 16		 mov	 edx, DWORD PTR [esi]
  0013d	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00143	c7 82 38 02 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+568], 0

; 2703 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].DelayActionTime = 800;

  0014d	8b 06		 mov	 eax, DWORD PTR [esi]
  0014f	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00155	c7 80 20 02 00
	00 20 03 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+544], 800 ; 00000320H

; 2704 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].DelayLevel = 1;

  0015f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00161	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00167	88 99 24 02 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+548], bl

; 2705 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_ViewSkillState |= 2;

  0016d	8b 06		 mov	 eax, DWORD PTR [esi]
  0016f	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00175	83 88 c4 01 00
	00 02		 or	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+452], 2
  0017c	8d 80 c4 01 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+452]

; 2706 : 
; 2707 : 						GCStateInfoSend(&gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex], 1,
; 2708 : 							gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_ViewSkillState);

  00182	8b 06		 mov	 eax, DWORD PTR [esi]
  00184	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0018a	8b 90 c4 01 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+452]
  00190	52		 push	 edx
  00191	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  00197	53		 push	 ebx
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  0019e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@CalUsersIn:

; 2677 : 
; 2678 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  001a1	83 c6 14	 add	 esi, 20			; 00000014H
  001a4	29 5d fc	 sub	 DWORD PTR tv241[ebp], ebx
  001a7	0f 85 b8 fe ff
	ff		 jne	 $LL8@CalUsersIn
  001ad	5f		 pop	 edi
  001ae	5e		 pop	 esi
  001af	5b		 pop	 ebx
$LN6@CalUsersIn:

; 2709 : 					}
; 2710 : 				}
; 2711 : 			}
; 2712 : 		}
; 2713 : 	}
; 2714 : }

  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	c2 04 00	 ret	 4
?CalUsersInTrap@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::CalUsersInTrap
_TEXT	ENDS
PUBLIC	?CheckWearingMOPH@CChaosCastle@@QAEHH@Z		; CChaosCastle::CheckWearingMOPH
; Function compile flags: /Ogtp
;	COMDAT ?CheckWearingMOPH@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
?CheckWearingMOPH@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::CheckWearingMOPH, COMDAT
; _this$ = ecx

; 2717 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2718 : 	if (  gObjIsConnected(iUserIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iUserIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax

; 2719 : 	{
; 2720 : 		return FALSE;

  00012	74 76		 je	 SHORT $LN1@CheckWeari

; 2721 : 	}
; 2722 : 
; 2723 : 	if ( gObj[iUserIndex].pInventory[10].IsItem()  )

  00014	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0001a	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  00020	8d b6 8c 0c 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  00026	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
  0002c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00031	85 c0		 test	 eax, eax
  00033	74 27		 je	 SHORT $LN4@CheckWeari

; 2724 : 	{
; 2725 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,10) ) // Tranformation Ring

  00035	8b 06		 mov	 eax, DWORD PTR [esi]
  00037	0f b7 80 96 06
	00 00		 movzx	 eax, WORD PTR [eax+1686]
  0003e	b9 0a 1a 00 00	 mov	 ecx, 6666		; 00001a0aH
  00043	66 3b c1	 cmp	 ax, cx
  00046	75 0a		 jne	 SHORT $LN5@CheckWeari
$LN10@CheckWeari:

; 2726 : 		{
; 2727 : 			return TRUE;

  00048	b8 01 00 00 00	 mov	 eax, 1
  0004d	5e		 pop	 esi

; 2750 : }

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN5@CheckWeari:

; 2728 : 		}
; 2729 : 
; 2730 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,39) ) 

  00052	ba 27 1a 00 00	 mov	 edx, 6695		; 00001a27H
  00057	66 3b c2	 cmp	 ax, dx

; 2731 : 		{
; 2732 : 			return TRUE;

  0005a	74 ec		 je	 SHORT $LN10@CheckWeari
$LN4@CheckWeari:

; 2733 : 		}
; 2734 : 	}
; 2735 : 
; 2736 : 	if ( gObj[iUserIndex].pInventory[11].IsItem() )

  0005c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005e	81 c1 38 07 00
	00		 add	 ecx, 1848		; 00000738H
  00064	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00069	85 c0		 test	 eax, eax
  0006b	74 1d		 je	 SHORT $LN1@CheckWeari

; 2737 : 	{
; 2738 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,10) ) // Tranformation Ring

  0006d	8b 06		 mov	 eax, DWORD PTR [esi]
  0006f	0f b7 80 3e 07
	00 00		 movzx	 eax, WORD PTR [eax+1854]
  00076	b9 0a 1a 00 00	 mov	 ecx, 6666		; 00001a0aH
  0007b	66 3b c1	 cmp	 ax, cx

; 2739 : 		{
; 2740 : 			return TRUE;

  0007e	74 c8		 je	 SHORT $LN10@CheckWeari

; 2741 : 		}
; 2742 : 
; 2743 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,39) ) 

  00080	ba 27 1a 00 00	 mov	 edx, 6695		; 00001a27H
  00085	66 3b c2	 cmp	 ax, dx

; 2744 : 		{
; 2745 : 			return TRUE;

  00088	74 be		 je	 SHORT $LN10@CheckWeari
$LN1@CheckWeari:

; 2746 : 		}
; 2747 : 	}
; 2748 : 
; 2749 : 	return FALSE;

  0008a	33 c0		 xor	 eax, eax
  0008c	5e		 pop	 esi

; 2750 : }

  0008d	5d		 pop	 ebp
  0008e	c2 04 00	 ret	 4
?CheckWearingMOPH@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::CheckWearingMOPH
_TEXT	ENDS
PUBLIC	??_C@_0DK@DHDNPFMP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ ; `string'
PUBLIC	??_C@_0DE@HBELAIG@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ ; `string'
PUBLIC	??_C@_0DI@DBIACCAA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ ; `string'
PUBLIC	??_C@_0DH@LBJAIKPF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ ; `string'
PUBLIC	??_C@_0DH@LJOJHDBK@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ ; `string'
PUBLIC	??_C@_0DL@MGKGLOGC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ ; `string'
PUBLIC	?GiveWinnerItem@CChaosCastle@@QAEXHH@Z		; CChaosCastle::GiveWinnerItem
EXTRN	?RingEventItemBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; RingEventItemBoxOpen
EXTRN	?MakeRandomSetItem@@YAXH@Z:PROC			; MakeRandomSetItem
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	_rand:PROC
;	COMDAT ??_C@_0DK@DHDNPFMP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
CONST	SEGMENT
??_C@_0DK@DHDNPFMP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Winner Item - Lucky Box Item', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HBELAIG@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
CONST	SEGMENT
??_C@_0DE@HBELAIG@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Winner Item - Set Item', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DBIACCAA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
CONST	SEGMENT
??_C@_0DI@DBIACCAA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Winner Item - Gem of Bless', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@LBJAIKPF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
CONST	SEGMENT
??_C@_0DH@LBJAIKPF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Winner Item - Gem of Life', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@LJOJHDBK@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
CONST	SEGMENT
??_C@_0DH@LJOJHDBK@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Winner Item - Gem of Soul', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@MGKGLOGC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
CONST	SEGMENT
??_C@_0DL@MGKGLOGC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Winner Item - Gem of Creative', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GiveWinnerItem@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
_iWinnerIndex$ = 12					; size = 4
?GiveWinnerItem@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::GiveWinnerItem, COMDAT
; _this$ = ecx

; 2753 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2754 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	0f 88 af 01 00
	00		 js	 $LN3@GiveWinner
  0000f	33 c0		 xor	 eax, eax
  00011	83 fe 05	 cmp	 esi, 5
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	0f 84 9f 01 00
	00		 je	 $LN3@GiveWinner

; 2755 : 		return;
; 2756 : 
; 2757 : 	if ( !gObjIsConnected(iWinnerIndex))

  0001f	57		 push	 edi
  00020	8b 7d 0c	 mov	 edi, DWORD PTR _iWinnerIndex$[ebp]
  00023	57		 push	 edi
  00024	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00029	83 c4 04	 add	 esp, 4
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 89 01 00
	00		 je	 $LN24@GiveWinner

; 2758 : 		return;
; 2759 : 
; 2760 : 	int iItemDropRate = rand()%100;

  00034	53		 push	 ebx
  00035	e8 00 00 00 00	 call	 _rand
  0003a	99		 cdq
  0003b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00040	f7 f9		 idiv	 ecx

; 2761 : 	int iItemType = 0;

  00042	33 db		 xor	 ebx, ebx

; 2762 : 	int iItemLevel = 0;
; 2763 : 	int iItemDur = 0;
; 2764 : 
; 2765 : 	if ( iItemDropRate < 50 )

  00044	83 fa 32	 cmp	 edx, 50			; 00000032H
  00047	7d 5b		 jge	 SHORT $LN16@GiveWinner

; 2766 : 	{
; 2767 : 		switch ( iChaosCastleIndex )

  00049	85 f6		 test	 esi, esi
  0004b	74 33		 je	 SHORT $LN13@GiveWinner
  0004d	0f 8e b5 00 00
	00		 jle	 $LN23@GiveWinner
  00053	83 fe 05	 cmp	 esi, 5
  00056	0f 8f ac 00 00
	00		 jg	 $LN23@GiveWinner

; 2773 : 				break;
; 2774 : 			case 1: case 2: case 3: case 4: case 5:
; 2775 : 				iItemType = ITEMGET(14,22);
; 2776 : 				LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] Winner Item - Gem of Creative", iChaosCastleIndex+1,
; 2777 : 					gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name);

  0005c	8b c7		 mov	 eax, edi
  0005e	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00064	8d 90 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  0006a	52		 push	 edx
  0006b	8d 80 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00071	50		 push	 eax
  00072	46		 inc	 esi
  00073	56		 push	 esi
  00074	bb 16 1c 00 00	 mov	 ebx, 7190		; 00001c16H
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MGKGLOGC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@

; 2778 : 				break;

  0007e	eb 7e		 jmp	 SHORT $LN26@GiveWinner
$LN13@GiveWinner:

; 2768 : 		{
; 2769 : 			case 0:
; 2770 : 				iItemType = ITEMGET(14,14);
; 2771 : 				LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] Winner Item - Gem of Soul", iChaosCastleIndex+1,
; 2772 : 					gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name);

  00080	8b c7		 mov	 eax, edi
  00082	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00088	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  0008e	51		 push	 ecx
  0008f	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00095	52		 push	 edx
  00096	6a 01		 push	 1
  00098	bb 0e 1c 00 00	 mov	 ebx, 7182		; 00001c0eH
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@LJOJHDBK@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@

; 2779 : 		}
; 2780 : 
; 2781 : 		iItemLevel = 0;
; 2782 : 		iItemDur = 0;

  000a2	eb 5a		 jmp	 SHORT $LN26@GiveWinner
$LN16@GiveWinner:

; 2783 : 	}
; 2784 : 	else if ( iItemDropRate <95 )

  000a4	83 fa 5f	 cmp	 edx, 95			; 0000005fH
  000a7	0f 8d a1 00 00
	00		 jge	 $LN10@GiveWinner

; 2785 : 	{
; 2786 : 		switch ( iChaosCastleIndex )

  000ad	85 f6		 test	 esi, esi
  000af	74 2b		 je	 SHORT $LN7@GiveWinner
  000b1	7e 55		 jle	 SHORT $LN23@GiveWinner
  000b3	83 fe 05	 cmp	 esi, 5
  000b6	7f 50		 jg	 SHORT $LN23@GiveWinner

; 2792 : 				break;
; 2793 : 			case 1: case 2: case 3: case 4: case 5:
; 2794 : 				iItemType = ITEMGET(14,16);
; 2795 : 				LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] Winner Item - Gem of Life", iChaosCastleIndex+1,
; 2796 : 					gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name);

  000b8	8b c7		 mov	 eax, edi
  000ba	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000c0	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  000c6	51		 push	 ecx
  000c7	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  000cd	52		 push	 edx
  000ce	46		 inc	 esi
  000cf	56		 push	 esi
  000d0	bb 10 1c 00 00	 mov	 ebx, 7184		; 00001c10H
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@LBJAIKPF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@

; 2797 : 				break;

  000da	eb 22		 jmp	 SHORT $LN26@GiveWinner
$LN7@GiveWinner:

; 2787 : 		{
; 2788 : 			case 0:
; 2789 : 				iItemType = ITEMGET(14,13);
; 2790 : 				LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] Winner Item - Gem of Bless", iChaosCastleIndex+1,
; 2791 : 					gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name);

  000dc	8b c7		 mov	 eax, edi
  000de	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000e4	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  000ea	51		 push	 ecx
  000eb	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  000f1	52		 push	 edx
  000f2	6a 01		 push	 1
  000f4	bb 0d 1c 00 00	 mov	 ebx, 7181		; 00001c0dH
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@DBIACCAA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
$LN26@GiveWinner:
  000fe	6a 00		 push	 0
  00100	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00105	83 c4 14	 add	 esp, 20			; 00000014H
$LN23@GiveWinner:

; 2816 : 				break;
; 2817 : 		}
; 2818 : 
; 2819 : 		return;
; 2820 : 	}
; 2821 : 
; 2822 : 	ItemSerialCreateSend(gObj[iWinnerIndex].m_Index, gObj[iWinnerIndex].MapNumber,
; 2823 : 		gObj[iWinnerIndex].X, gObj[iWinnerIndex].Y, iItemType, iItemLevel, iItemDur, 0, 0, 0, iWinnerIndex, 0, 0);

  00108	6a 00		 push	 0
  0010a	6a 00		 push	 0
  0010c	57		 push	 edi
  0010d	6a 00		 push	 0
  0010f	8b c7		 mov	 eax, edi
  00111	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00117	0f b6 88 06 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  0011e	0f b6 90 04 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  00125	6a 00		 push	 0
  00127	6a 00		 push	 0
  00129	6a 00		 push	 0
  0012b	6a 00		 push	 0
  0012d	53		 push	 ebx
  0012e	51		 push	 ecx
  0012f	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00136	52		 push	 edx
  00137	8b 90 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  0013d	51		 push	 ecx
  0013e	52		 push	 edx
  0013f	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00144	83 c4 34	 add	 esp, 52			; 00000034H
  00147	5b		 pop	 ebx
  00148	5f		 pop	 edi
  00149	5e		 pop	 esi

; 2824 : }

  0014a	5d		 pop	 ebp
  0014b	c2 08 00	 ret	 8
$LN10@GiveWinner:

; 2798 : 		}
; 2799 : 
; 2800 : 		iItemLevel = 0;
; 2801 : 		iItemDur = 0;
; 2802 : 	}
; 2803 : 	else
; 2804 : 	{
; 2805 : 		switch ( iChaosCastleIndex )

  0014e	85 f6		 test	 esi, esi
  00150	74 39		 je	 SHORT $LN2@GiveWinner
  00152	7e 68		 jle	 SHORT $LN25@GiveWinner
  00154	83 fe 05	 cmp	 esi, 5
  00157	7f 63		 jg	 SHORT $LN25@GiveWinner

; 2811 : 				break;
; 2812 : 			case 1: case 2: case 3: case 4: case 5:
; 2813 : 				MakeRandomSetItem(iWinnerIndex);

  00159	57		 push	 edi
  0015a	e8 00 00 00 00	 call	 ?MakeRandomSetItem@@YAXH@Z ; MakeRandomSetItem

; 2814 : 				LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] Winner Item - Set Item", iChaosCastleIndex+1,
; 2815 : 					gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name);

  0015f	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00165	8d 87 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+111]
  0016b	50		 push	 eax
  0016c	8d 8f 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+100]
  00172	51		 push	 ecx
  00173	46		 inc	 esi
  00174	56		 push	 esi
  00175	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@HBELAIG@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
  0017a	6a 00		 push	 0
  0017c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00181	83 c4 18	 add	 esp, 24			; 00000018H
  00184	5b		 pop	 ebx
  00185	5f		 pop	 edi
  00186	5e		 pop	 esi

; 2824 : }

  00187	5d		 pop	 ebp
  00188	c2 08 00	 ret	 8
$LN2@GiveWinner:

; 2806 : 		{
; 2807 : 			case 0:
; 2808 : 				RingEventItemBoxOpen(&gObj[iWinnerIndex]);

  0018b	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00191	8d 97 00 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  00197	52		 push	 edx
  00198	e8 00 00 00 00	 call	 ?RingEventItemBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; RingEventItemBoxOpen

; 2809 : 				LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] Winner Item - Lucky Box Item", iChaosCastleIndex+1,
; 2810 : 					gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name);

  0019d	8d 87 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+111]
  001a3	50		 push	 eax
  001a4	8d 8f 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+100]
  001aa	51		 push	 ecx
  001ab	6a 01		 push	 1
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@DHDNPFMP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
  001b2	6a 00		 push	 0
  001b4	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001b9	83 c4 18	 add	 esp, 24			; 00000018H
$LN25@GiveWinner:
  001bc	5b		 pop	 ebx
$LN24@GiveWinner:
  001bd	5f		 pop	 edi
$LN3@GiveWinner:
  001be	5e		 pop	 esi

; 2824 : }

  001bf	5d		 pop	 ebp
  001c0	c2 08 00	 ret	 8
?GiveWinnerItem@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::GiveWinnerItem
_TEXT	ENDS
PUBLIC	?ReCalcUserCount@CChaosCastle@@QAEHH@Z		; CChaosCastle::ReCalcUserCount
; Function compile flags: /Ogtp
;	COMDAT ?ReCalcUserCount@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?ReCalcUserCount@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::ReCalcUserCount, COMDAT
; _this$ = ecx

; 2827 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2828 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 0c		 js	 SHORT $LN8@ReCalcUser
  0000e	33 c0		 xor	 eax, eax
  00010	83 fe 05	 cmp	 esi, 5
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 09		 jne	 SHORT $LN3@ReCalcUser
$LN8@ReCalcUser:
  0001a	5f		 pop	 edi

; 2829 : 		return -1;

  0001b	83 c8 ff	 or	 eax, -1
  0001e	5e		 pop	 esi

; 2843 : 	}
; 2844 : 	return iRET_VAL;
; 2845 : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN3@ReCalcUser:

; 2830 : 
; 2831 : 	int iRET_VAL = 0;
; 2832 : 	int iPlayUser = this->GetCurPlayUser(iChaosCastleIndex);

  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser

; 2833 : 
; 2834 : 	if ( iPlayUser > 0 )
; 2835 : 	{
; 2836 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER = iPlayUser;

  00029	69 f6 6c 08 00
	00		 imul	 esi, 2156		; 0000086cH
  0002f	85 c0		 test	 eax, eax
  00031	7e 0a		 jle	 SHORT $LN2@ReCalcUser
  00033	89 44 3e 54	 mov	 DWORD PTR [esi+edi+84], eax
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 2843 : 	}
; 2844 : 	return iRET_VAL;
; 2845 : }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN2@ReCalcUser:

; 2837 : 		iRET_VAL = iPlayUser;
; 2838 : 	}
; 2839 : 	else
; 2840 : 	{
; 2841 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER = 0;

  0003d	c7 44 3e 54 00
	00 00 00	 mov	 DWORD PTR [esi+edi+84], 0
  00045	5f		 pop	 edi

; 2842 : 		iRET_VAL = 0;

  00046	33 c0		 xor	 eax, eax
  00048	5e		 pop	 esi

; 2843 : 	}
; 2844 : 	return iRET_VAL;
; 2845 : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?ReCalcUserCount@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::ReCalcUserCount
_TEXT	ENDS
PUBLIC	?CheckRegisterOfflineGift@CChaosCastle@@QAEXH@Z	; CChaosCastle::CheckRegisterOfflineGift
EXTRN	?EGReqRegCCOfflineGift@@YAXH@Z:PROC		; EGReqRegCCOfflineGift
; Function compile flags: /Ogtp
;	COMDAT ?CheckRegisterOfflineGift@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
?CheckRegisterOfflineGift@CChaosCastle@@QAEXH@Z PROC	; CChaosCastle::CheckRegisterOfflineGift, COMDAT
; _this$ = ecx

; 2931 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2932 : 	if ( gObjIsConnected(iUserIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iUserIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 1e		 je	 SHORT $LN1@CheckRegis

; 2933 : 	{
; 2934 : 		return;
; 2935 : 	}
; 2936 : 
; 2937 : 	int iGiftRate = rand() % 10000;

  00014	e8 00 00 00 00	 call	 _rand
  00019	99		 cdq
  0001a	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0001f	f7 f9		 idiv	 ecx

; 2938 : 
; 2939 : 	if ( iGiftRate < ::g_iChaosCastle_OffLineGiftRate )

  00021	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iChaosCastle_OffLineGiftRate@@3HA ; g_iChaosCastle_OffLineGiftRate
  00027	7d 09		 jge	 SHORT $LN1@CheckRegis

; 2940 : 	{
; 2941 : 		EGReqRegCCOfflineGift(iUserIndex);

  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ?EGReqRegCCOfflineGift@@YAXH@Z ; EGReqRegCCOfflineGift
  0002f	83 c4 04	 add	 esp, 4
$LN1@CheckRegis:
  00032	5e		 pop	 esi

; 2942 : 	}
; 2943 : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?CheckRegisterOfflineGift@CChaosCastle@@QAEXH@Z ENDP	; CChaosCastle::CheckRegisterOfflineGift
_TEXT	ENDS
PUBLIC	?empty@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE_NXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::empty
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?empty@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE_NXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::empty, COMDAT
; _this$ = ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	33 d2		 xor	 edx, edx
  00004	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 890  : 		}

  0000a	c3		 ret	 0
?empty@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::empty
_TEXT	ENDS
PUBLIC	?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::empty
; Function compile flags: /Ogtp
;	COMDAT ?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::empty, COMDAT
; _this$ = ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	33 d2		 xor	 edx, edx
  00004	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 890  : 		}

  0000a	c3		 ret	 0
?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::empty
_TEXT	ENDS
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 331  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtp
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00008	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xfunctional
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 124  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 125  : 		return (_Left < _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0000f	0f 9c c0	 setl	 al

; 126  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBE_NPBUCHAOSCASTLE_START_TIME@@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Inside
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBE_NPBUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBE_NPBUCHAOSCASTLE_START_TIME@@@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBE_NPBUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@XZ ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@XZ PROC ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@XZ ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 41   : 		}

  00008	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUCHAOSCASTLE_START_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUCHAOSCASTLE_START_TIME@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUCHAOSCASTLE_START_TIME@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUCHAOSCASTLE_START_TIME@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBE_NPBUtagPOINT@@@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Inside
; Function compile flags: /Ogtp
;	COMDAT ?_Inside@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBE_NPBUtagPOINT@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBE_NPBUtagPOINT@@@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside@2
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside@2
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside@2:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBE_NPBUtagPOINT@@@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::~_Vector_val<tagPOINT,std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::~_Vector_val<tagPOINT,std::allocator<tagPOINT> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::~_Vector_val<tagPOINT,std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UtagPOINT@@@std@@QAE@XZ		; std::allocator<tagPOINT>::allocator<tagPOINT>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UtagPOINT@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UtagPOINT@@@std@@QAE@XZ PROC		; std::allocator<tagPOINT>::allocator<tagPOINT>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UtagPOINT@@@std@@QAE@XZ ENDP		; std::allocator<tagPOINT>::allocator<tagPOINT>
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ; std::vector<int,std::allocator<int> >::_Inside
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z PROC ; std::vector<int,std::allocator<int> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside@3
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside@3
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside@3:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ENDP ; std::vector<int,std::allocator<int> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 19	 add	 eax, 25			; 00000019H

; 613  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
; Function compile flags: /Ogtp
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
; Function compile flags: /Ogtp
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 628  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
; Function compile flags: /Ogtp
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 633  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
; Function compile flags: /Ogtp
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::capacity
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::size
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z ; std::allocator<CHAOSCASTLE_START_TIME>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::deallocate
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  00002	83 00 08	 add	 DWORD PTR [eax], 8

; 111  : 		return (*this);
; 112  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Compat
; Function compile flags: /Ogtp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Compat
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::capacity
; Function compile flags: /Ogtp
;	COMDAT ?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::size
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Xlen
; Function compile flags: /Ogtp
;	COMDAT ?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen@2:
$LN3@Xlen@2:
  0000a	cc		 int	 3
?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@UtagPOINT@@@std@@QAE@ABV01@@Z	; std::allocator<tagPOINT>::allocator<tagPOINT>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UtagPOINT@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UtagPOINT@@@std@@QAE@ABV01@@Z PROC	; std::allocator<tagPOINT>::allocator<tagPOINT>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UtagPOINT@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<tagPOINT>::allocator<tagPOINT>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z ; std::allocator<tagPOINT>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z PROC ; std::allocator<tagPOINT>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z ENDP ; std::allocator<tagPOINT>::deallocate
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Ogtp
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen@3:
$LN3@Xlen@3:
  0000a	cc		 int	 3
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEABUtagPOINT@@XZ ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEABUtagPOINT@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEABUtagPOINT@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEABUtagPOINT@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		return ((char&)(*_Pnode)._Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 18	 add	 eax, 24			; 00000018H

; 608  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QBEIXZ ; std::allocator<CHAOSCASTLE_START_TIME>::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QBEIXZ PROC ; std::allocator<CHAOSCASTLE_START_TIME>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QBEIXZ ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UtagPOINT@@@std@@QBEIXZ	; std::allocator<tagPOINT>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@UtagPOINT@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UtagPOINT@@@std@@QBEIXZ PROC	; std::allocator<tagPOINT>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UtagPOINT@@@std@@QBEIXZ ENDP	; std::allocator<tagPOINT>::max_size
_TEXT	ENDS
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator!=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 336  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Max
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  0000d	75 0c		 jne	 SHORT $LN1@Max
  0000f	90		 npad	 1
$LL2@Max:

; 643  : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN1@Max:

; 644  : 		return (_Pnode);
; 645  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Min
; Function compile flags: /Ogtp
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  0000c	75 0c		 jne	 SHORT $LN1@Min
  0000e	8b ff		 npad	 2
$LL2@Min:

; 650  : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00018	74 f6		 je	 SHORT $LL2@Min
$LN1@Min:

; 651  : 		return (_Pnode);
; 652  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Min
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 41   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=, COMDAT
; _this$ = ecx

; 151  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 		if (this->_Getcont() == 0
; 154  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 155  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 156  : 			{	// report error
; 157  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 158  : 			_SCL_SECURE_OUT_OF_RANGE;
; 159  : 			}
; 160  : 
; 161  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 162  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 163  : 		_SCL_SECURE_VALIDATE_RANGE(
; 164  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 165  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 166  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 167  : 
; 168  : 		_Ptr += _Off;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  0000f	01 10		 add	 DWORD PTR [eax], edx

; 169  : 		return (*this);
; 170  : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 10		 mov	 edx, DWORD PTR [eax]
  00004	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00008	75 40		 jne	 SHORT $LN3@operator

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0000d	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00011	75 1a		 jne	 SHORT $LN34@operator

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00019	75 0f		 jne	 SHORT $LN17@operator
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator:
  00020	8b ca		 mov	 ecx, edx
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00028	74 f6		 je	 SHORT $LL18@operator
$LN17@operator:
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0002c	c3		 ret	 0
$LN34@operator:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00030	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00034	75 12		 jne	 SHORT $LN1@operator
$LL2@operator:
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0003b	75 0b		 jne	 SHORT $LN1@operator

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003d	89 10		 mov	 DWORD PTR [eax], edx
  0003f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00042	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00046	74 ee		 je	 SHORT $LL2@operator
$LN1@operator:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00048	89 10		 mov	 DWORD PTR [eax], edx
$LN3@operator:

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0004a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::addressof<CHAOSCASTLE_START_TIME const >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z PROC ; std::addressof<CHAOSCASTLE_START_TIME const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z ENDP ; std::addressof<CHAOSCASTLE_START_TIME const >
_TEXT	ENDS
PUBLIC	??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z ; std::addressof<tagPOINT const >
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z PROC ; std::addressof<tagPOINT const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z ENDP ; std::addressof<tagPOINT const >
_TEXT	ENDS
PUBLIC	??$addressof@$$CBH@std@@YAPBHABH@Z		; std::addressof<int const >
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@$$CBH@std@@YAPBHABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBH@std@@YAPBHABH@Z PROC			; std::addressof<int const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBH@std@@YAPBHABH@Z ENDP			; std::addressof<int const >
_TEXT	ENDS
PUBLIC	??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Kfn<int const ,_MONSTER_ITEM_DROP>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Kfn<int const ,_MONSTER_ITEM_DROP>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Kfn<int const ,_MONSTER_ITEM_DROP>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node><std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node><std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node><std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::max_size
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00008	74 06		 je	 SHORT $LN8@operator@2

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0000f	c3		 ret	 0
$LN8@operator@2:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00016	75 17		 jne	 SHORT $LN40@operator@2

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  00018	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001b	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  0001f	75 30		 jne	 SHORT $LN21@operator@2
$LL22@operator@2:
  00021	8b d1		 mov	 edx, ecx
  00023	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00026	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  0002a	74 f5		 je	 SHORT $LL22@operator@2

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0002e	c3		 ret	 0
$LN40@operator@2:

; 89   : 		else
; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00036	75 11		 jne	 SHORT $LN3@operator@2
$LL4@operator@2:
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0003c	75 0b		 jne	 SHORT $LN3@operator@2

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  0003e	89 10		 mov	 DWORD PTR [eax], edx
  00040	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00043	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00047	74 ef		 je	 SHORT $LL4@operator@2
$LN3@operator@2:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  0004f	75 02		 jne	 SHORT $LN1@operator@2

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

$LN21@operator@2:

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00051	89 10		 mov	 DWORD PTR [eax], edx
$LN1@operator@2:

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00053	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
PUBLIC	??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z ; std::forward<_MONSTER_ITEM_DROP &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z PROC ; std::forward<_MONSTER_ITEM_DROP &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z ENDP ; std::forward<_MONSTER_ITEM_DROP &>
_TEXT	ENDS
PUBLIC	??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$_Pair_base@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ; std::_Pair_base<int,_MONSTER_ITEM_DROP>::_Pair_base<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$_Pair_base@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$_Pair_base@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z PROC ; std::_Pair_base<int,_MONSTER_ITEM_DROP>::_Pair_base<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00014	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00017	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 164  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$_Pair_base@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ENDP ; std::_Pair_base<int,_MONSTER_ITEM_DROP>::_Pair_base<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::forward<std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
;	COMDAT ??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z PROC ; std::forward<std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ENDP ; std::forward<std::pair<int,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::forward<CHAOSCASTLE_START_TIME &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z PROC ; std::forward<CHAOSCASTLE_START_TIME &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z ENDP ; std::forward<CHAOSCASTLE_START_TIME &>
_TEXT	ENDS
PUBLIC	??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::construct<CHAOSCASTLE_START_TIME &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::construct<CHAOSCASTLE_START_TIME &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct:

; 209  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::construct<CHAOSCASTLE_START_TIME &>
_TEXT	ENDS
PUBLIC	??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::forward<CHAOSCASTLE_START_TIME const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z PROC ; std::forward<CHAOSCASTLE_START_TIME const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z ENDP ; std::forward<CHAOSCASTLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z ; std::_Ptr_cat<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z PROC ; std::_Ptr_cat<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z ENDP ; std::_Ptr_cat<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z ; std::forward<tagPOINT &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z PROC ; std::forward<tagPOINT &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z ENDP ; std::forward<tagPOINT &>
_TEXT	ENDS
PUBLIC	??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z ; std::allocator<tagPOINT>::construct<tagPOINT &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z PROC ; std::allocator<tagPOINT>::construct<tagPOINT &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@2:

; 209  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z ENDP ; std::allocator<tagPOINT>::construct<tagPOINT &>
_TEXT	ENDS
PUBLIC	??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z ; std::forward<tagPOINT const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z PROC ; std::forward<tagPOINT const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z ENDP ; std::forward<tagPOINT const &>
_TEXT	ENDS
PUBLIC	??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z ; std::allocator<int>::construct<int &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z PROC	; std::allocator<int>::construct<int &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@construct@3
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN3@construct@3:

; 209  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z ENDP	; std::allocator<int>::construct<int &>
_TEXT	ENDS
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z ; std::_Ptr_cat<tagPOINT,tagPOINT>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z PROC ; std::_Ptr_cat<tagPOINT,tagPOINT>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z ENDP ; std::_Ptr_cat<tagPOINT,tagPOINT>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>
; Function compile flags: /Ogtp
;	COMDAT ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z PROC ; std::_Ptr_cat<int,int>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ENDP ; std::_Ptr_cat<int,int>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 105  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Destroy<std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z PROC ; std::_Destroy<std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ENDP ; std::_Destroy<std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::_Construct<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z PROC ; std::_Construct<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@Construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@Construct:

; 49   : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z ENDP ; std::_Construct<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z ; std::_Construct<tagPOINT,tagPOINT const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z PROC ; std::_Construct<tagPOINT,tagPOINT const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@Construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@Construct@2:

; 49   : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z ENDP ; std::_Construct<tagPOINT,tagPOINT const &>
_TEXT	ENDS
PUBLIC	??$_Destroy@UtagPOINT@@@std@@YAXPAUtagPOINT@@@Z	; std::_Destroy<tagPOINT>
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy@UtagPOINT@@@std@@YAXPAUtagPOINT@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UtagPOINT@@@std@@YAXPAUtagPOINT@@@Z PROC	; std::_Destroy<tagPOINT>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@UtagPOINT@@@std@@YAXPAUtagPOINT@@@Z ENDP	; std::_Destroy<tagPOINT>
_TEXT	ENDS
PUBLIC	??$_Construct@HABH@std@@YAXPAHABH@Z		; std::_Construct<int,int const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Construct@HABH@std@@YAXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@HABH@std@@YAXPAHABH@Z PROC		; std::_Construct<int,int const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@Construct@3
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Construct@3:

; 49   : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Construct@HABH@std@@YAXPAHABH@Z ENDP		; std::_Construct<int,int const &>
_TEXT	ENDS
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$move@AAUCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::move<CHAOSCASTLE_START_TIME &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAUCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z PROC ; std::move<CHAOSCASTLE_START_TIME &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ENDP ; std::move<CHAOSCASTLE_START_TIME &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@@Z ; std::_Val_type<CHAOSCASTLE_START_TIME *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@@Z PROC ; std::_Val_type<CHAOSCASTLE_START_TIME *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@@Z ENDP ; std::_Val_type<CHAOSCASTLE_START_TIME *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUtagPOINT@@@std@@YAPAUtagPOINT@@PAU1@@Z ; std::_Val_type<tagPOINT *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Val_type@PAUtagPOINT@@@std@@YAPAUtagPOINT@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUtagPOINT@@@std@@YAPAUtagPOINT@@PAU1@@Z PROC ; std::_Val_type<tagPOINT *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUtagPOINT@@@std@@YAPAUtagPOINT@@PAU1@@Z ENDP ; std::_Val_type<tagPOINT *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAH@std@@YAPAHPAH@Z		; std::_Val_type<int *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Val_type@PAH@std@@YAPAHPAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAH@std@@YAPAHPAH@Z PROC			; std::_Val_type<int *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAH@std@@YAPAHPAH@Z ENDP			; std::_Val_type<int *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<int,int,int>
EXTRN	_memmove:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<int,int,int>, COMDAT

; 456  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 457  : 	_DEBUG_RANGE(_First, _Last);
; 458  : 	_DEBUG_POINTER(_Dest);
; 459  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi
  0000c	c1 f8 02	 sar	 eax, 2

; 460  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 461  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 462  : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int,int,int>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$_Destroy@UCHAOSCASTLE_START_TIME@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@@Z ; std::_Destroy<CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UCHAOSCASTLE_START_TIME@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UCHAOSCASTLE_START_TIME@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@@Z PROC ; std::_Destroy<CHAOSCASTLE_START_TIME>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@UCHAOSCASTLE_START_TIME@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::_Destroy<CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::forward<CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z PROC ; std::forward<CHAOSCASTLE_START_TIME>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ENDP ; std::forward<CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z ; std::forward<tagPOINT>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z PROC ; std::forward<tagPOINT>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z ENDP ; std::forward<tagPOINT>
_TEXT	ENDS
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
PUBLIC	??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z ; std::forward<_MONSTER_ITEM_DROP>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z PROC ; std::forward<_MONSTER_ITEM_DROP>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z ENDP ; std::forward<_MONSTER_ITEM_DROP>
_TEXT	ENDS
PUBLIC	??$?0HU_MONSTER_ITEM_DROP@@@?$_Pair_base@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAH$$QAU_MONSTER_ITEM_DROP@@@Z ; std::_Pair_base<int const ,_MONSTER_ITEM_DROP>::_Pair_base<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>
; Function compile flags: /Ogtp
;	COMDAT ??$?0HU_MONSTER_ITEM_DROP@@@?$_Pair_base@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAH$$QAU_MONSTER_ITEM_DROP@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0HU_MONSTER_ITEM_DROP@@@?$_Pair_base@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAH$$QAU_MONSTER_ITEM_DROP@@@Z PROC ; std::_Pair_base<int const ,_MONSTER_ITEM_DROP>::_Pair_base<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00014	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00017	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 164  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
??$?0HU_MONSTER_ITEM_DROP@@@?$_Pair_base@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAH$$QAU_MONSTER_ITEM_DROP@@@Z ENDP ; std::_Pair_base<int const ,_MONSTER_ITEM_DROP>::_Pair_base<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>
_TEXT	ENDS
PUBLIC	_sqrtf
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Ogtp
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 542  :         {return (sqrtf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 38   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
_TEXT	ENDS
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
PUBLIC	??0_CHAOSCASTLE_USER@@QAE@XZ			; _CHAOSCASTLE_USER::_CHAOSCASTLE_USER
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.h
;	COMDAT ??0_CHAOSCASTLE_USER@@QAE@XZ
_TEXT	SEGMENT
??0_CHAOSCASTLE_USER@@QAE@XZ PROC			; _CHAOSCASTLE_USER::_CHAOSCASTLE_USER, COMDAT
; _this$ = ecx

; 139  : 	_CHAOSCASTLE_USER()	// line : 338

  00000	8b c1		 mov	 eax, ecx

; 140  : 	{
; 141  : 		this->Clear();

  00002	33 c9		 xor	 ecx, ecx
  00004	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00010	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00013	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 142  : 	};	// line : 340

  00016	c3		 ret	 0
??0_CHAOSCASTLE_USER@@QAE@XZ ENDP			; _CHAOSCASTLE_USER::_CHAOSCASTLE_USER
_TEXT	ENDS
PUBLIC	?SetMonster@CChaosCastle@@QAEHH@Z		; CChaosCastle::SetMonster
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
;	COMDAT ?SetMonster@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_iMAX_ADDABLE_MONSTER_COUNT$ = -16			; size = 4
_n$158417 = -12						; size = 4
_iNOW_ADDED_MONSTER_COUNT$ = -8				; size = 4
_btChaosCastleIndex$158425 = -2				; size = 1
_btMonsterIndex$158423 = -1				; size = 1
_iChaosCastleIndex$ = 8					; size = 4
?SetMonster@CChaosCastle@@QAEHH@Z PROC			; CChaosCastle::SetMonster, COMDAT
; _this$ = ecx

; 989  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi

; 990  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00007	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  0000a	57		 push	 edi
  0000b	33 ff		 xor	 edi, edi
  0000d	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00010	3b f7		 cmp	 esi, edi
  00012	7c 0c		 jl	 SHORT $LN19@SetMonster
  00014	33 c0		 xor	 eax, eax
  00016	83 fe 05	 cmp	 esi, 5
  00019	0f 9e c0	 setle	 al
  0001c	3b c7		 cmp	 eax, edi
  0001e	75 0b		 jne	 SHORT $LN9@SetMonster
$LN19@SetMonster:
  00020	5f		 pop	 edi

; 991  : 	{
; 992  : 		return -1;

  00021	83 c8 ff	 or	 eax, -1
  00024	5e		 pop	 esi

; 1048 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN9@SetMonster:

; 993  : 	}
; 994  : 
; 995  : 	int iNOW_ADDED_MONSTER_COUNT = 0;
; 996  : 	int iMAX_ADDABLE_MONSTER_COUNT = MAX_CC_MONSTERS - this->GetCurPlayUser(iChaosCastleIndex);

  0002b	56		 push	 esi
  0002c	89 7d f8	 mov	 DWORD PTR _iNOW_ADDED_MONSTER_COUNT$[ebp], edi
  0002f	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  00034	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00039	2b c8		 sub	 ecx, eax
  0003b	89 4d f0	 mov	 DWORD PTR _iMAX_ADDABLE_MONSTER_COUNT$[ebp], ecx

; 997  : 	int result;
; 998  : 
; 999  : 	if ( iMAX_ADDABLE_MONSTER_COUNT < 0 )

  0003e	79 03		 jns	 SHORT $LN8@SetMonster

; 1000 : 	{
; 1001 : 		iMAX_ADDABLE_MONSTER_COUNT = 0;

  00040	89 7d f0	 mov	 DWORD PTR _iMAX_ADDABLE_MONSTER_COUNT$[ebp], edi
$LN8@SetMonster:

; 1002 : 	}
; 1003 : 
; 1004 : 	for ( int n=0;n<gMSetBase.m_Count;n++)

  00043	89 7d f4	 mov	 DWORD PTR _n$158417[ebp], edi
  00046	39 3d e4 0f 01
	00		 cmp	 DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+69604, edi
  0004c	0f 8e 38 01 00
	00		 jle	 $LN17@SetMonster
  00052	bf 08 00 00 00	 mov	 edi, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A+8
  00057	53		 push	 ebx
  00058	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL22@SetMonster:

; 1005 : 	{
; 1006 : 		if ( iNOW_ADDED_MONSTER_COUNT >= iMAX_ADDABLE_MONSTER_COUNT )

  00060	8b 45 f8	 mov	 eax, DWORD PTR _iNOW_ADDED_MONSTER_COUNT$[ebp]
  00063	3b 45 f0	 cmp	 eax, DWORD PTR _iMAX_ADDABLE_MONSTER_COUNT$[ebp]
  00066	0f 8d 1d 01 00
	00		 jge	 $LN23@SetMonster

; 1007 : 		{
; 1008 : 			break;
; 1009 : 		}
; 1010 : 
; 1011 : 		if ( CC_MAP_RANGE(gMSetBase.m_Mp[n].m_MapNumber) != FALSE )

  0006c	8a 07		 mov	 al, BYTE PTR [edi]
  0006e	3c 12		 cmp	 al, 18			; 00000012H
  00070	0f 82 fd 00 00
	00		 jb	 $LN6@SetMonster
  00076	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  0007b	3a c8		 cmp	 cl, al
  0007d	1b c9		 sbb	 ecx, ecx
  0007f	41		 inc	 ecx
  00080	0f 84 ed 00 00
	00		 je	 $LN6@SetMonster

; 1012 : 		{
; 1013 : 			BYTE btMonsterIndex = gMSetBase.m_Mp[n].m_Type;

  00086	8a 57 fe	 mov	 dl, BYTE PTR [edi-2]

; 1014 : 			BYTE btMapNumber = gMSetBase.m_Mp[n].m_MapNumber;
; 1015 : 			BYTE btChaosCastleIndex = btMapNumber - MAP_INDEX_CHAOSCASTLE1;

  00089	8d 48 ee	 lea	 ecx, DWORD PTR [eax-18]
  0008c	88 4d fe	 mov	 BYTE PTR _btChaosCastleIndex$158425[ebp], cl

; 1016 : 
; 1017 : 			if ( btChaosCastleIndex != iChaosCastleIndex )

  0008f	0f b6 c9	 movzx	 ecx, cl
  00092	88 55 ff	 mov	 BYTE PTR _btMonsterIndex$158423[ebp], dl
  00095	3b ce		 cmp	 ecx, esi
  00097	0f 85 d6 00 00
	00		 jne	 $LN6@SetMonster

; 1018 : 			{
; 1019 : 				continue;
; 1020 : 			}
; 1021 : 
; 1022 : 			result = gObjAddMonster(btMapNumber);

  0009d	0f b6 d0	 movzx	 edx, al
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  000a6	0f bf d8	 movsx	 ebx, ax
  000a9	83 c4 04	 add	 esp, 4

; 1023 : 
; 1024 : 			if ( result >= 0 )

  000ac	85 db		 test	 ebx, ebx
  000ae	0f 88 bf 00 00
	00		 js	 $LN6@SetMonster

; 1025 : 			{
; 1026 : 				gObj[result].m_PosNum = n;

  000b4	0f b7 45 f4	 movzx	 eax, WORD PTR _n$158417[ebp]

; 1027 : 				gObj[result].X = gMSetBase.m_Mp[n].m_X;
; 1028 : 				gObj[result].Y = gMSetBase.m_Mp[n].m_Y;

  000b8	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]

; 1029 : 				gObj[result].MapNumber = gMSetBase.m_Mp[n].m_MapNumber;

  000bc	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  000bf	8b f3		 mov	 esi, ebx
  000c1	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000c7	66 89 86 10 02
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+528], ax
  000ce	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]
  000d2	66 89 86 04 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260], ax

; 1030 : 				gObj[result].TX = gObj[result].X;

  000d9	66 89 86 20 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+288], ax

; 1031 : 				gObj[result].TY = gObj[result].Y;
; 1032 : 				gObj[result].m_OldX = gObj[result].X;

  000e0	66 89 86 1c 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+284], ax

; 1033 : 				gObj[result].m_OldY = gObj[result].Y;
; 1034 : 				gObj[result].Dir = gMSetBase.m_Mp[n].m_Dir;

  000e7	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  000eb	88 86 08 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+264], al

; 1035 : 				gObj[result].StartX = gObj[result].X;
; 1036 : 				gObj[result].StartY = gObj[result].Y;
; 1037 : 				gObjSetMonster(result, btMonsterIndex);

  000f1	0f b6 45 ff	 movzx	 eax, BYTE PTR _btMonsterIndex$158423[ebp]
  000f5	66 89 8e 06 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262], cx
  000fc	88 96 09 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265], dl
  00102	0f b6 96 06 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  00109	66 89 8e 22 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+290], cx
  00110	66 89 8e 1e 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+286], cx
  00117	8a 8e 04 01 00
	00		 mov	 cl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  0011d	50		 push	 eax
  0011e	53		 push	 ebx
  0011f	88 8e 1a 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+282], cl
  00125	88 96 1b 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+283], dl
  0012b	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1038 : 				gObj[result].MaxRegenTime = this->m_iCC_MONSTER_REGEN;

  00130	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]

; 1039 : 				gObj[result].m_cChaosCastleIndex = btChaosCastleIndex;

  00133	0f b6 45 fe	 movzx	 eax, BYTE PTR _btChaosCastleIndex$158425[ebp]
  00137	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0013a	83 c4 08	 add	 esp, 8
  0013d	89 96 0c 02 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+524], edx
  00143	88 86 09 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3337], al

; 1040 : 				gObj[result].Dir = rand() % 8;

  00149	e8 00 00 00 00	 call	 _rand
  0014e	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00153	79 05		 jns	 SHORT $LN24@SetMonster
  00155	48		 dec	 eax
  00156	83 c8 f8	 or	 eax, -8			; fffffff8H
  00159	40		 inc	 eax
$LN24@SetMonster:

; 1041 : 				iNOW_ADDED_MONSTER_COUNT++;
; 1042 : 				this->AddMonsterList(iChaosCastleIndex, result);

  0015a	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0015d	ff 45 f8	 inc	 DWORD PTR _iNOW_ADDED_MONSTER_COUNT$[ebp]
  00160	53		 push	 ebx
  00161	51		 push	 ecx
  00162	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00165	88 86 08 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+264], al
  0016b	e8 00 00 00 00	 call	 ?AddMonsterList@CChaosCastle@@QAEXHH@Z ; CChaosCastle::AddMonsterList
  00170	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
$LN6@SetMonster:

; 1002 : 	}
; 1003 : 
; 1004 : 	for ( int n=0;n<gMSetBase.m_Count;n++)

  00173	8b 45 f4	 mov	 eax, DWORD PTR _n$158417[ebp]
  00176	40		 inc	 eax
  00177	83 c7 0c	 add	 edi, 12			; 0000000cH
  0017a	89 45 f4	 mov	 DWORD PTR _n$158417[ebp], eax
  0017d	3b 05 e4 0f 01
	00		 cmp	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+69604
  00183	0f 8c d7 fe ff
	ff		 jl	 $LL22@SetMonster
$LN23@SetMonster:
  00189	5b		 pop	 ebx
$LN17@SetMonster:

; 1043 : 			}
; 1044 : 		}
; 1045 : 	}
; 1046 : 
; 1047 : 	return iNOW_ADDED_MONSTER_COUNT;

  0018a	8b 45 f8	 mov	 eax, DWORD PTR _iNOW_ADDED_MONSTER_COUNT$[ebp]
  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi

; 1048 : }

  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c2 04 00	 ret	 4
?SetMonster@CChaosCastle@@QAEHH@Z ENDP			; CChaosCastle::SetMonster
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendNoticeState@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SendNoticeState
; Function compile flags: /Ogtp
;	COMDAT ?SendNoticeState@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv388 = -24						; size = 4
_pMsg$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iPlayState$ = 12					; size = 4
?SendNoticeState@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SendNoticeState, COMDAT
; _this$ = ecx

; 1268 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  00015	8b d9		 mov	 ebx, ecx

; 1269 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00017	85 ff		 test	 edi, edi
  00019	0f 88 d1 00 00
	00		 js	 $LN4@SendNotice@2
  0001f	33 c0		 xor	 eax, eax
  00021	83 ff 05	 cmp	 edi, 5
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 c1 00 00
	00		 je	 $LN4@SendNotice@2

; 1270 : 	{
; 1271 : 		return;
; 1272 : 	}
; 1273 : 
; 1274 : 	PMSG_STATEBLOODCASTLE pMsg;
; 1275 : 
; 1276 : 	PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(PMSG_STATEBLOODCASTLE));

  0002f	56		 push	 esi
  00030	6a 0e		 push	 14			; 0000000eH
  00032	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00035	68 9b 00 00 00	 push	 155			; 0000009bH
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1277 : 	pMsg.btPlayState = iPlayState;

  00040	8a 4d 0c	 mov	 cl, BYTE PTR _iPlayState$[ebp]

; 1278 : 	pMsg.wRemainSec = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 1000;

  00043	8b f7		 mov	 esi, edi
  00045	69 f6 6c 08 00
	00		 imul	 esi, 2156		; 0000086cH
  0004b	03 f3		 add	 esi, ebx
  0004d	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00052	f7 6e 40	 imul	 DWORD PTR [esi+64]
  00055	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 1279 : 	pMsg.wMaxKillMonster = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_FIRST_USER_COUNT + this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_FIRST_MONSTER_COUNT;

  00058	66 8b 4e 5c	 mov	 cx, WORD PTR [esi+92]
  0005c	66 03 4e 58	 add	 cx, WORD PTR [esi+88]
  00060	c1 fa 06	 sar	 edx, 6
  00063	8b c2		 mov	 eax, edx
  00065	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	03 c2		 add	 eax, edx
  0006d	66 89 4d f2	 mov	 WORD PTR _pMsg$[ebp+6], cx

; 1280 : 	pMsg.wCurKillMonster = this->GetCurPlayUser(iChaosCastleIndex) + this->GetMonsterListCount(iChaosCastleIndex);

  00071	57		 push	 edi
  00072	8b cb		 mov	 ecx, ebx
  00074	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax
  00078	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  0007d	57		 push	 edi
  0007e	8b cb		 mov	 ecx, ebx
  00080	89 45 e8	 mov	 DWORD PTR tv388[ebp], eax
  00083	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  00088	8b 4d e8	 mov	 ecx, DWORD PTR tv388[ebp]
  0008b	03 c8		 add	 ecx, eax

; 1281 : 	pMsg.wUserHaveWeapon = -1;

  0008d	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00092	83 c6 6c	 add	 esi, 108		; 0000006cH
  00095	66 89 4d f4	 mov	 WORD PTR _pMsg$[ebp+8], cx
  00099	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+10], dx

; 1282 : 	pMsg.btWeaponNum = -1;

  0009d	c6 45 f8 ff	 mov	 BYTE PTR _pMsg$[ebp+12], 255 ; 000000ffH
  000a1	bf 46 00 00 00	 mov	 edi, 70			; 00000046H
  000a6	83 cb ff	 or	 ebx, -1
  000a9	8d a4 24 00 00
	00 00		 npad	 7
$LL6@SendNotice@2:

; 1285 : 	{
; 1286 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  000b0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b2	3b cb		 cmp	 ecx, ebx
  000b4	74 33		 je	 SHORT $LN5@SendNotice@2

; 1287 : 		{
; 1288 : 			if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000b6	8b c1		 mov	 eax, ecx
  000b8	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000be	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  000c5	76 22		 jbe	 SHORT $LN5@SendNotice@2

; 1289 : 			{
; 1290 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex != -1 && gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex != -1 )

  000c7	38 98 09 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3337], bl
  000cd	74 1a		 je	 SHORT $LN5@SendNotice@2
  000cf	38 98 0a 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3338], bl
  000d5	74 12		 je	 SHORT $LN5@SendNotice@2

; 1291 : 				{
; 1292 : 					DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  000d7	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000db	50		 push	 eax
  000dc	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000df	52		 push	 edx
  000e0	51		 push	 ecx
  000e1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@SendNotice@2:

; 1283 : 
; 1284 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  000e9	83 c6 14	 add	 esi, 20			; 00000014H
  000ec	4f		 dec	 edi
  000ed	75 c1		 jne	 SHORT $LL6@SendNotice@2
  000ef	5e		 pop	 esi
$LN4@SendNotice@2:

; 1293 : 				}
; 1294 : 			}
; 1295 : 		}
; 1296 : 	}
; 1297 : }

  000f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f3	5f		 pop	 edi
  000f4	33 cd		 xor	 ecx, ebp
  000f6	5b		 pop	 ebx
  000f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c2 08 00	 ret	 8
?SendNoticeState@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SendNoticeState
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z	; CChaosCastle::CalcSendRewardEXP
EXTRN	?PHeadSetBE@@YAXPAEEH@Z:PROC			; PHeadSetBE
; Function compile flags: /Ogtp
;	COMDAT ?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_pkillMsg$159316 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_iUserIndex$ = 8					; size = 4
_iEXP$ = 12						; size = 4
_iKILLCOUNT_USER$ = 16					; size = 4
_iKILLCOUNT_MONSTER$ = 20				; size = 4
?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z PROC	; CChaosCastle::CalcSendRewardEXP, COMDAT
; _this$ = ecx

; 1534 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 1535 : 	if ( iEXP <= 0 )

  00011	8b 75 0c	 mov	 esi, DWORD PTR _iEXP$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _iUserIndex$[ebp]
  00018	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001b	85 f6		 test	 esi, esi
  0001d	7f 14		 jg	 SHORT $LN7@CalcSendRe

; 1536 : 		return 0;

  0001f	5f		 pop	 edi
  00020	33 c0		 xor	 eax, eax
  00022	5e		 pop	 esi

; 1573 : 	}
; 1574 : 
; 1575 : 	return iRET_EXP;
; 1576 : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
$LN7@CalcSendRe:
  00033	53		 push	 ebx

; 1537 : 
; 1538 : 	int iRET_EXP = 0;
; 1539 : 	int iCAL_EXP = iEXP;
; 1540 : 	int iMAX_LEVCOUNT = 0;
; 1541 : 
; 1542 : 	if ( !gObjIsConnected(iUserIndex))

  00034	57		 push	 edi
  00035	33 db		 xor	 ebx, ebx
  00037	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003c	83 c4 04	 add	 esp, 4
  0003f	85 c0		 test	 eax, eax
  00041	75 13		 jne	 SHORT $LN6@CalcSendRe
  00043	5b		 pop	 ebx
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 1573 : 	}
; 1574 : 
; 1575 : 	return iRET_EXP;
; 1576 : }

  00046	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00049	33 cd		 xor	 ecx, ebp
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 10 00	 ret	 16			; 00000010H
$LN6@CalcSendRe:

; 1543 : 		return 0;
; 1544 : 
; 1545 : 	iRET_EXP = iCAL_EXP;
; 1546 : 
; 1547 : 	if ( gObj[iUserIndex].Type == OBJ_USER )

  00056	8b c7		 mov	 eax, edi
  00058	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0005e	66 83 b8 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 1
  00066	75 5f		 jne	 SHORT $LN12@CalcSendRe

; 1550 : 		{
; 1551 : 			if ( iCAL_EXP > 0 )

  00068	85 f6		 test	 esi, esi
  0006a	7e 0e		 jle	 SHORT $LN2@CalcSendRe
$LN15@CalcSendRe:

; 1552 : 			{
; 1553 : 				iCAL_EXP = this->LevelUp(iUserIndex, iCAL_EXP, 3);

  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	6a 03		 push	 3
  00071	56		 push	 esi
  00072	57		 push	 edi
  00073	e8 00 00 00 00	 call	 ?LevelUp@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::LevelUp
  00078	8b f0		 mov	 esi, eax
$LN2@CalcSendRe:

; 1554 : 			}
; 1555 : 
; 1556 : 			iMAX_LEVCOUNT++;

  0007a	43		 inc	 ebx

; 1557 : 
; 1558 : 			if ( iMAX_LEVCOUNT > 1000 )

  0007b	81 fb e8 03 00
	00		 cmp	 ebx, 1000		; 000003e8H
  00081	7f 04		 jg	 SHORT $LN11@CalcSendRe

; 1548 : 	{
; 1549 : 		while ( iCAL_EXP > 0 )

  00083	85 f6		 test	 esi, esi
  00085	7f e5		 jg	 SHORT $LN15@CalcSendRe
$LN11@CalcSendRe:

; 1559 : 				break;
; 1560 : 		}
; 1561 : 		
; 1562 : 		PMSG_KILLPLAYER_EXT pkillMsg;
; 1563 : 
; 1564 : 		PHeadSetBE((LPBYTE)&pkillMsg, 0x9C, sizeof(pkillMsg));

  00087	6a 0c		 push	 12			; 0000000cH
  00089	8d 4d f0	 lea	 ecx, DWORD PTR _pkillMsg$159316[ebp]
  0008c	68 9c 00 00 00	 push	 156			; 0000009cH
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 1565 : 		pkillMsg.NumberH = -1;
; 1566 : 		pkillMsg.NumberL = -1;
; 1567 : 		pkillMsg.ExpH = SET_NUMBERHW(iEXP);
; 1568 : 		pkillMsg.ExpL = SET_NUMBERLW(iEXP);
; 1569 : 		pkillMsg.DamageH = 0;
; 1570 : 		pkillMsg.DamageL = 0;
; 1571 : 
; 1572 : 		DataSend(iUserIndex, (LPBYTE)&pkillMsg, pkillMsg.h.size);

  00097	0f b6 45 f1	 movzx	 eax, BYTE PTR _pkillMsg$159316[ebp+1]
  0009b	8b 75 0c	 mov	 esi, DWORD PTR _iEXP$[ebp]
  0009e	50		 push	 eax
  0009f	8d 4d f0	 lea	 ecx, DWORD PTR _pkillMsg$159316[ebp]
  000a2	8b d6		 mov	 edx, esi
  000a4	51		 push	 ecx
  000a5	c1 ea 10	 shr	 edx, 16			; 00000010H
  000a8	57		 push	 edi
  000a9	66 c7 45 f3 ff
	ff		 mov	 WORD PTR _pkillMsg$159316[ebp+3], 65535 ; 0000ffffH
  000af	66 89 55 f6	 mov	 WORD PTR _pkillMsg$159316[ebp+6], dx
  000b3	66 89 75 f8	 mov	 WORD PTR _pkillMsg$159316[ebp+8], si
  000b7	66 c7 45 fa 00
	00		 mov	 WORD PTR _pkillMsg$159316[ebp+10], 0
  000bd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000c2	83 c4 18	 add	 esp, 24			; 00000018H
  000c5	eb 03		 jmp	 SHORT $LN5@CalcSendRe
$LN12@CalcSendRe:
  000c7	8b 75 0c	 mov	 esi, DWORD PTR _iEXP$[ebp]
$LN5@CalcSendRe:

; 1573 : 	}
; 1574 : 
; 1575 : 	return iRET_EXP;
; 1576 : }

  000ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cd	5b		 pop	 ebx
  000ce	5f		 pop	 edi
  000cf	8b c6		 mov	 eax, esi
  000d1	33 cd		 xor	 ecx, ebp
  000d3	5e		 pop	 esi
  000d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 10 00	 ret	 16			; 00000010H
?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z ENDP	; CChaosCastle::CalcSendRewardEXP
_TEXT	ENDS
PUBLIC	?GetCurrentWinUser@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetCurrentWinUser
; Function compile flags: /Ogtp
;	COMDAT ?GetCurrentWinUser@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv174 = -4						; size = 4
_iCC_WINNER_INDEX$ = 8					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetCurrentWinUser@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurrentWinUser, COMDAT
; _this$ = ecx

; 1753 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1754 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]
  0000a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	85 db		 test	 ebx, ebx
  0000f	78 0c		 js	 SHORT $LN18@GetCurrent@2
  00011	33 c0		 xor	 eax, eax
  00013	83 fb 05	 cmp	 ebx, 5
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 0a		 jne	 SHORT $LN11@GetCurrent@2
$LN18@GetCurrent@2:

; 1755 : 	{
; 1756 : 		return -1;

  0001d	83 c8 ff	 or	 eax, -1
  00020	5b		 pop	 ebx

; 1799 : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN11@GetCurrent@2:
  00027	56		 push	 esi
  00028	57		 push	 edi

; 1757 : 	}
; 1758 : 
; 1759 : 	int iCC_SCORE = -1;

  00029	83 cf ff	 or	 edi, -1
  0002c	8b c3		 mov	 eax, ebx
  0002e	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH

; 1760 : 	int iCC_WINNER_INDEX = -1;

  00034	89 7d 08	 mov	 DWORD PTR _iCC_WINNER_INDEX$[ebp], edi
  00037	8d 74 08 6c	 lea	 esi, DWORD PTR [eax+ecx+108]
  0003b	c7 45 fc 46 00
	00 00		 mov	 DWORD PTR tv174[ebp], 70 ; 00000046H
$LL24@GetCurrent@2:

; 1763 : 	{
; 1764 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00042	8b 06		 mov	 eax, DWORD PTR [esi]
  00044	83 f8 ff	 cmp	 eax, -1
  00047	74 4a		 je	 SHORT $LN9@GetCurrent@2

; 1765 : 		{
; 1766 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) == TRUE &&
; 1767 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == ( iChaosCastleIndex+18) &&	
; 1768 : 				this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iUserState == 0 )

  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0004f	83 c4 04	 add	 esp, 4
  00052	83 f8 01	 cmp	 eax, 1
  00055	75 3c		 jne	 SHORT $LN9@GetCurrent@2
  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0005f	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00066	8d 53 12	 lea	 edx, DWORD PTR [ebx+18]
  00069	3b ca		 cmp	 ecx, edx
  0006b	75 26		 jne	 SHORT $LN9@GetCurrent@2
  0006d	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  00071	75 20		 jne	 SHORT $LN9@GetCurrent@2

; 1769 : 			{
; 1770 : 				LPOBJ lpObj = &gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex];
; 1771 : 
; 1772 : 				int iUSER_SCORE = lpObj->m_cKillUserCount + lpObj->m_cKillMonsterCount * 2;

  00073	0f be 88 11 0d
	00 00		 movsx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3345]
  0007a	0f be 90 10 0d
	00 00		 movsx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3344]
  00081	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]

; 1773 : 
; 1774 : 				if ( iCC_SCORE < iUSER_SCORE )

  00084	3b f9		 cmp	 edi, ecx
  00086	7d 0b		 jge	 SHORT $LN9@GetCurrent@2

; 1775 : 				{
; 1776 : 					iCC_SCORE = iUSER_SCORE;
; 1777 : 					iCC_WINNER_INDEX = lpObj->m_Index;

  00088	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  0008e	8b f9		 mov	 edi, ecx
  00090	89 45 08	 mov	 DWORD PTR _iCC_WINNER_INDEX$[ebp], eax
$LN9@GetCurrent@2:

; 1761 : 
; 1762 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00093	83 c6 14	 add	 esi, 20			; 00000014H
  00096	ff 4d fc	 dec	 DWORD PTR tv174[ebp]
  00099	75 a7		 jne	 SHORT $LL24@GetCurrent@2

; 1778 : 				}
; 1779 : 			}
; 1780 : 		}
; 1781 : 	}
; 1782 : 
; 1783 : 	if ( iCC_WINNER_INDEX != -1 )

  0009b	8b 45 08	 mov	 eax, DWORD PTR _iCC_WINNER_INDEX$[ebp]
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	83 f8 ff	 cmp	 eax, -1
  000a3	74 3a		 je	 SHORT $LN23@GetCurrent@2

; 1784 : 	{
; 1785 : 		if ( gObj[iCC_WINNER_INDEX].m_cKillUserCount == 0 &&
; 1786 : 			 gObj[iCC_WINNER_INDEX].m_cKillMonsterCount == 0 )

  000a5	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000ab	80 b8 10 0d 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3344], 0
  000b2	75 2b		 jne	 SHORT $LN23@GetCurrent@2
  000b4	80 b8 11 0d 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3345], 0
  000bb	75 22		 jne	 SHORT $LN23@GetCurrent@2

; 1787 : 		{
; 1788 : 			int iUSER_COUNT = this->GetCurPlayUser(iChaosCastleIndex);

  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	53		 push	 ebx
  000c1	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser

; 1790 : 
; 1791 : 			if ( iUSER_COUNT != 1 || iMONSTER_COUNT != 0 )

  000c6	83 f8 01	 cmp	 eax, 1
  000c9	75 0d		 jne	 SHORT $LN1@GetCurrent@2

; 1789 : 			int iMONSTER_COUNT = this->GetMonsterListCount(iChaosCastleIndex);

  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	53		 push	 ebx
  000cf	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount

; 1790 : 
; 1791 : 			if ( iUSER_COUNT != 1 || iMONSTER_COUNT != 0 )

  000d4	85 c0		 test	 eax, eax
  000d6	74 07		 je	 SHORT $LN23@GetCurrent@2
$LN1@GetCurrent@2:

; 1792 : 			{
; 1793 : 				iCC_WINNER_INDEX = -1;

  000d8	c7 45 08 ff ff
	ff ff		 mov	 DWORD PTR _iCC_WINNER_INDEX$[ebp], -1
$LN23@GetCurrent@2:

; 1794 : 			}
; 1795 : 		}
; 1796 : 	}
; 1797 : 
; 1798 : 	return iCC_WINNER_INDEX;

  000df	8b 45 08	 mov	 eax, DWORD PTR _iCC_WINNER_INDEX$[ebp]
  000e2	5b		 pop	 ebx

; 1799 : }

  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 04 00	 ret	 4
?GetCurrentWinUser@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurrentWinUser
_TEXT	ENDS
PUBLIC	?CheckPlayEnded@CChaosCastle@@QAEHH@Z		; CChaosCastle::CheckPlayEnded
; Function compile flags: /Ogtp
;	COMDAT ?CheckPlayEnded@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?CheckPlayEnded@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::CheckPlayEnded, COMDAT
; _this$ = ecx

; 1892 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1893 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 3d		 js	 SHORT $LN1@CheckPlayE
  0000e	33 c0		 xor	 eax, eax
  00010	83 fe 05	 cmp	 esi, 5
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax

; 1894 : 	{
; 1895 : 		return FALSE;

  00018	74 31		 je	 SHORT $LN1@CheckPlayE

; 1896 : 	}
; 1897 : 
; 1898 : 	int iCUR_USER_COUNT = this->GetCurPlayUser(iChaosCastleIndex);

  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser

; 1900 : 
; 1901 : 	if ( iCUR_USER_COUNT <= 0 )

  00020	85 c0		 test	 eax, eax
  00022	7f 0b		 jg	 SHORT $LN2@CheckPlayE

; 1902 : 	{
; 1903 : 		return 2;

  00024	5f		 pop	 edi
  00025	b8 02 00 00 00	 mov	 eax, 2
  0002a	5e		 pop	 esi

; 1912 : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN2@CheckPlayE:

; 1904 : 	}
; 1905 : 
; 1906 : 	if ( iCUR_USER_COUNT == 1 && iCUR_MONSTER_COUNT <= 0)

  0002f	83 f8 01	 cmp	 eax, 1
  00032	75 17		 jne	 SHORT $LN1@CheckPlayE

; 1899 : 	int iCUR_MONSTER_COUNT = this->GetMonsterListCount(iChaosCastleIndex);

  00034	56		 push	 esi
  00035	8b cf		 mov	 ecx, edi
  00037	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount

; 1904 : 	}
; 1905 : 
; 1906 : 	if ( iCUR_USER_COUNT == 1 && iCUR_MONSTER_COUNT <= 0)

  0003c	85 c0		 test	 eax, eax
  0003e	7f 0b		 jg	 SHORT $LN1@CheckPlayE

; 1907 : 	{
; 1908 : 		return 1;

  00040	5f		 pop	 edi
  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	5e		 pop	 esi

; 1912 : }

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN1@CheckPlayE:
  0004b	5f		 pop	 edi

; 1909 : 	}
; 1910 : 
; 1911 : 	return 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	5e		 pop	 esi

; 1912 : }

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?CheckPlayEnded@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::CheckPlayEnded
_TEXT	ENDS
PUBLIC	??_C@_0DL@GPIGPHOF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5GetCurPlayUs@ ; `string'
PUBLIC	?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z	; CChaosCastle::CheckCanStartPlay
;	COMDAT ??_C@_0DL@GPIGPHOF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5GetCurPlayUs@
CONST	SEGMENT
??_C@_0DL@GPIGPHOF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5GetCurPlayUs@ DB '['
	DB	'Chaos Castle] (%d) GetCurPlayUser() FAILED (UserCount:%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z PROC		; CChaosCastle::CheckCanStartPlay, COMDAT
; _this$ = ecx

; 1935 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1936 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 29		 js	 SHORT $LN7@CheckCanSt
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fe 05	 cmp	 esi, 5
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax

; 1937 : 	{
; 1938 : 		return false;

  00015	74 1d		 je	 SHORT $LN7@CheckCanSt

; 1939 : 	}
; 1940 : 
; 1941 : 	int iEnteredUser = this->GetCurPlayUser(iChaosCastleIndex);

  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser

; 1942 : 
; 1943 : 	if ( iEnteredUser < MIN_CC_USER_NEED_PLAY )

  0001d	83 f8 02	 cmp	 eax, 2
  00020	7d 19		 jge	 SHORT $LN1@CheckCanSt

; 1944 : 	{
; 1945 : 		LogAdd(LOG_BLACK, "[Chaos Castle] (%d) GetCurPlayUser() FAILED (UserCount:%d)", iChaosCastleIndex+1, iEnteredUser);

  00022	50		 push	 eax
  00023	46		 inc	 esi
  00024	56		 push	 esi
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GPIGPHOF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5GetCurPlayUs@
  0002a	6a 00		 push	 0
  0002c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00031	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@CheckCanSt:

; 1946 : 
; 1947 : 		return false;

  00034	32 c0		 xor	 al, al
  00036	5e		 pop	 esi

; 1951 : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN1@CheckCanSt:

; 1948 : 	}
; 1949 : 
; 1950 : 	return true;

  0003b	b0 01		 mov	 al, 1
  0003d	5e		 pop	 esi

; 1951 : }

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z ENDP		; CChaosCastle::CheckCanStartPlay
_TEXT	ENDS
PUBLIC	?CalDistance@CChaosCastle@@QAEHHHHH@Z		; CChaosCastle::CalDistance
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CalDistance@CChaosCastle@@QAEHHHHH@Z
_TEXT	SEGMENT
tv170 = 8						; size = 4
tv167 = 8						; size = 4
tv138 = 8						; size = 4
tv136 = 8						; size = 4
_fTY$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_fTX$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?CalDistance@CChaosCastle@@QAEHHHHH@Z PROC		; CChaosCastle::CalDistance, COMDAT
; _this$ = ecx

; 2310 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2311 : 	if ( iX1 == iX2 && iY1 == iY2 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iX1$[ebp]
  00006	8b 55 10	 mov	 edx, DWORD PTR _iX2$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _iY1$[ebp]
  0000c	56		 push	 esi
  0000d	8b 75 14	 mov	 esi, DWORD PTR _iY2$[ebp]
  00010	3b c2		 cmp	 eax, edx
  00012	75 0b		 jne	 SHORT $LN1@CalDistanc
  00014	3b ce		 cmp	 ecx, esi
  00016	75 07		 jne	 SHORT $LN1@CalDistanc

; 2312 : 	{
; 2313 : 		return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	5e		 pop	 esi

; 2320 : }

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
$LN1@CalDistanc:

; 2314 : 	}
; 2315 : 
; 2316 : 	float fTX = (float)(iX1 - iX2);

  0001f	2b c2		 sub	 eax, edx
  00021	89 45 08	 mov	 DWORD PTR tv170[ebp], eax
  00024	db 45 08	 fild	 DWORD PTR tv170[ebp]

; 2317 : 	float fTY = (float)(iY1 - iY2);

  00027	2b ce		 sub	 ecx, esi
  00029	89 4d 08	 mov	 DWORD PTR tv167[ebp], ecx
  0002c	d9 5d 10	 fstp	 DWORD PTR _fTX$[ebp]
  0002f	db 45 08	 fild	 DWORD PTR tv167[ebp]
  00032	d9 5d 08	 fstp	 DWORD PTR _fTY$[ebp]

; 2318 : 
; 2319 : 	return sqrt( (fTX * fTX) + (fTY * fTY) );

  00035	d9 45 08	 fld	 DWORD PTR _fTY$[ebp]
  00038	d9 45 10	 fld	 DWORD PTR _fTX$[ebp]
  0003b	dc c8		 fmul	 ST(0), ST(0)
  0003d	d9 c1		 fld	 ST(1)
  0003f	de ca		 fmulp	 ST(2), ST(0)
  00041	de c1		 faddp	 ST(1), ST(0)
  00043	d9 5d 08	 fstp	 DWORD PTR tv138[ebp]
  00046	d9 45 08	 fld	 DWORD PTR tv138[ebp]
  00049	e8 00 00 00 00	 call	 __CIsqrt
  0004e	d9 5d 08	 fstp	 DWORD PTR tv136[ebp]
  00051	d9 45 08	 fld	 DWORD PTR tv136[ebp]
  00054	e8 00 00 00 00	 call	 __ftol2_sse
  00059	5e		 pop	 esi

; 2320 : }

  0005a	5d		 pop	 ebp
  0005b	c2 10 00	 ret	 16			; 00000010H
?CalDistance@CChaosCastle@@QAEHHHHH@Z ENDP		; CChaosCastle::CalDistance
_TEXT	ENDS
PUBLIC	??_C@_0GI@LIKADFKD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Rew@ ; `string'
PUBLIC	_iChaosCastleIndex$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?RewardUserEXP@CChaosCastle@@QAEXHHH@Z		; CChaosCastle::RewardUserEXP
;	COMDAT ??_C@_0GI@LIKADFKD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Rew@
CONST	SEGMENT
??_C@_0GI@LIKADFKD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Rew@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Reward User EXP (USER_KILL:%d, MO'
	DB	'N_KILL:%d, TOT_EXP:%d, TOT_REWARD_EXP:%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?RewardUserEXP@CChaosCastle@@QAEXHHH@Z
_TEXT	SEGMENT
_iKILLCOUNT_MONSTER$159839 = -288			; size = 4
_iChaosCastleIndex$GSCopy$ = -284			; size = 4
_this$GSCopy$ = -280					; size = 4
_iREWARD_EXP$159841 = -280				; size = 4
_pMsg$159842 = -276					; size = 269
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iChaosCastleSubIndex$ = 12				; size = 4
_bWinner$ = 16						; size = 4
?RewardUserEXP@CChaosCastle@@QAEXHHH@Z PROC		; CChaosCastle::RewardUserEXP, COMDAT
; _this$ = ecx

; 2594 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _iChaosCastleSubIndex$[ebp]
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]

; 2607 : 			{
; 2608 : 				return;
; 2609 : 			}
; 2610 : 
; 2611 : 			int iKILLCOUNT_USER = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cKillUserCount;

  0001a	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00020	89 b5 e4 fe ff
	ff		 mov	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], esi
  00026	85 f6		 test	 esi, esi
  00028	0f 88 83 01 00
	00		 js	 $LN1@RewardUser

; 2595 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0002e	33 d2		 xor	 edx, edx
  00030	83 fe 05	 cmp	 esi, 5
  00033	0f 9e c2	 setle	 dl
  00036	85 d2		 test	 edx, edx
  00038	0f 84 73 01 00
	00		 je	 $LN1@RewardUser

; 2596 : 		return;
; 2597 : 
; 2598 : 	if ( CC_SUB_FLOOR_RANGE(iChaosCastleSubIndex) == FALSE )

  0003e	85 c0		 test	 eax, eax
  00040	0f 88 6b 01 00
	00		 js	 $LN1@RewardUser
  00046	33 d2		 xor	 edx, edx
  00048	83 f8 45	 cmp	 eax, 69			; 00000045H
  0004b	0f 9e c2	 setle	 dl
  0004e	85 d2		 test	 edx, edx
  00050	0f 84 5b 01 00
	00		 je	 $LN1@RewardUser

; 2599 : 		return;
; 2600 : 
; 2601 : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex != -1 )

  00056	8b d6		 mov	 edx, esi
  00058	69 d2 6c 08 00
	00		 imul	 edx, 2156		; 0000086cH
  0005e	53		 push	 ebx
  0005f	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00062	03 d1		 add	 edx, ecx
  00064	57		 push	 edi
  00065	8d 7c 82 6c	 lea	 edi, DWORD PTR [edx+eax*4+108]
  00069	8b 07		 mov	 eax, DWORD PTR [edi]
  0006b	83 cb ff	 or	 ebx, -1
  0006e	3b c3		 cmp	 eax, ebx
  00070	0f 84 39 01 00
	00		 je	 $LN13@RewardUser

; 2602 : 	{
; 2603 : 		if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex) ==TRUE )

  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0007c	83 c4 04	 add	 esp, 4
  0007f	83 f8 01	 cmp	 eax, 1
  00082	0f 85 27 01 00
	00		 jne	 $LN13@RewardUser

; 2604 : 		{
; 2605 : 			if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cChaosCastleIndex == -1 ||
; 2606 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cChaosCastleSubIndex == -1 )

  00088	8b 07		 mov	 eax, DWORD PTR [edi]
  0008a	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00090	38 98 09 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3337], bl
  00096	0f 84 13 01 00
	00		 je	 $LN13@RewardUser
  0009c	38 98 0a 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3338], bl
  000a2	0f 84 07 01 00
	00		 je	 $LN13@RewardUser

; 2607 : 			{
; 2608 : 				return;
; 2609 : 			}
; 2610 : 
; 2611 : 			int iKILLCOUNT_USER = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cKillUserCount;

  000a8	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2612 : 			int iKILLCOUNT_MONSTER = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cKillMonsterCount;
; 2613 : 			int iTOT_EXP = iKILLCOUNT_USER * g_iChaosCastle_ExpTable[iChaosCastleIndex][0] + iKILLCOUNT_MONSTER * g_iChaosCastle_ExpTable[iChaosCastleIndex][1];

  000aa	8b 34 f5 04 00
	00 00		 mov	 esi, DWORD PTR _g_iChaosCastle_ExpTable[esi*8+4]
  000b1	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  000b7	8b 14 d5 00 00
	00 00		 mov	 edx, DWORD PTR _g_iChaosCastle_ExpTable[edx*8]
  000be	8b c1		 mov	 eax, ecx
  000c0	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000c6	0f be 98 10 0d
	00 00		 movsx	 ebx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3344]
  000cd	0f be 80 11 0d
	00 00		 movsx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3345]
  000d4	0f af d3	 imul	 edx, ebx
  000d7	0f af f0	 imul	 esi, eax

; 2614 : 			int iREWARD_EXP = this->CalcSendRewardEXP(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex,
; 2615 : 				iTOT_EXP, iKILLCOUNT_USER, iKILLCOUNT_MONSTER);

  000da	50		 push	 eax
  000db	53		 push	 ebx
  000dc	03 f2		 add	 esi, edx
  000de	56		 push	 esi
  000df	51		 push	 ecx
  000e0	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000e6	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _iKILLCOUNT_MONSTER$159839[ebp], eax
  000ec	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z ; CChaosCastle::CalcSendRewardEXP
  000f1	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$159841[ebp], eax

; 2616 : 
; 2617 : 			PMSG_DEVILSQUARERESULT pMsg;
; 2618 : 
; 2619 : 			pMsg.MyRank = bWinner;

  000f7	8a 45 10	 mov	 al, BYTE PTR _bWinner$[ebp]
  000fa	88 85 ef fe ff
	ff		 mov	 BYTE PTR _pMsg$159842[ebp+3], al

; 2620 : 			pMsg.Count = 0xFE;
; 2621 : 			memcpy(pMsg.Score[0].Name, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].Name, 10);

  00100	8b 07		 mov	 eax, DWORD PTR [edi]
  00102	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00108	05 6f 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+111
  0010d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00110	8b 08		 mov	 ecx, DWORD PTR [eax]
  00112	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]

; 2622 : 			pMsg.Score[0].BonusExp = iTOT_EXP;
; 2623 : 			pMsg.Score[0].BonusZen = iKILLCOUNT_USER;
; 2624 : 			pMsg.Score[0].TotalScore = iKILLCOUNT_MONSTER;
; 2625 : 			PHeadSetB((LPBYTE)&pMsg, 0x93, 0x35);

  00116	6a 35		 push	 53			; 00000035H
  00118	89 95 f5 fe ff
	ff		 mov	 DWORD PTR _pMsg$159842[ebp+9], edx
  0011e	89 8d f1 fe ff
	ff		 mov	 DWORD PTR _pMsg$159842[ebp+5], ecx
  00124	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _iKILLCOUNT_MONSTER$159839[ebp]
  0012a	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$159842[ebp]
  00130	68 93 00 00 00	 push	 147			; 00000093H
  00135	52		 push	 edx
  00136	c6 85 f0 fe ff
	ff fe		 mov	 BYTE PTR _pMsg$159842[ebp+4], 254 ; 000000feH
  0013d	66 89 85 f9 fe
	ff ff		 mov	 WORD PTR _pMsg$159842[ebp+13], ax
  00144	89 b5 01 ff ff
	ff		 mov	 DWORD PTR _pMsg$159842[ebp+21], esi
  0014a	89 9d 05 ff ff
	ff		 mov	 DWORD PTR _pMsg$159842[ebp+25], ebx
  00150	89 8d fd fe ff
	ff		 mov	 DWORD PTR _pMsg$159842[ebp+17], ecx
  00156	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2626 : 
; 2627 : 			DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0015b	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$159842[ebp+1]
  00162	8b 17		 mov	 edx, DWORD PTR [edi]
  00164	50		 push	 eax
  00165	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$159842[ebp]
  0016b	51		 push	 ecx
  0016c	52		 push	 edx
  0016d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2628 : 
; 2629 : 			LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] Reward User EXP (USER_KILL:%d, MON_KILL:%d, TOT_EXP:%d, TOT_REWARD_EXP:%d)",
; 2630 : 				iChaosCastleIndex+1, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].AccountID,
; 2631 : 				gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].Name,
; 2632 : 				iKILLCOUNT_USER, iKILLCOUNT_MONSTER, iTOT_EXP, iREWARD_EXP);

  00172	8b 3f		 mov	 edi, DWORD PTR [edi]
  00174	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_EXP$159841[ebp]
  0017a	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00180	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _iKILLCOUNT_MONSTER$159839[ebp]
  00186	50		 push	 eax
  00187	56		 push	 esi
  00188	51		 push	 ecx
  00189	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  0018f	53		 push	 ebx
  00190	8d 97 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+111]
  00196	52		 push	 edx
  00197	8d 87 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+100]
  0019d	50		 push	 eax
  0019e	41		 inc	 ecx
  0019f	51		 push	 ecx
  001a0	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@LIKADFKD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Rew@
  001a5	6a 00		 push	 0
  001a7	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001ac	83 c4 3c	 add	 esp, 60			; 0000003cH
$LN13@RewardUser:
  001af	5f		 pop	 edi
  001b0	5b		 pop	 ebx
$LN1@RewardUser:

; 2633 : 		}
; 2634 : 	}
; 2635 : }

  001b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b4	33 cd		 xor	 ecx, ebp
  001b6	5e		 pop	 esi
  001b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c2 0c 00	 ret	 12			; 0000000cH
?RewardUserEXP@CChaosCastle@@QAEXHHH@Z ENDP		; CChaosCastle::RewardUserEXP
_TEXT	ENDS
PUBLIC	?ProcessTrapStatus@CChaosCastle@@QAEXH@Z	; CChaosCastle::ProcessTrapStatus
; Function compile flags: /Ogtp
;	COMDAT ?ProcessTrapStatus@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?ProcessTrapStatus@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::ProcessTrapStatus, COMDAT
; _this$ = ecx

; 2638 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2639 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	0f 88 a4 00 00
	00		 js	 $LN1@ProcessTra
  00012	33 c0		 xor	 eax, eax
  00014	83 fe 05	 cmp	 esi, 5
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 94 00 00
	00		 je	 $LN1@ProcessTra

; 2640 : 		return;
; 2641 : 
; 2642 : 	int iCUR_LIVES = this->GetCurPlayUser(iChaosCastleIndex) + this->GetMonsterListCount(iChaosCastleIndex);

  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  00029	56		 push	 esi
  0002a	8b cf		 mov	 ecx, edi
  0002c	8b d8		 mov	 ebx, eax
  0002e	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  00033	03 d8		 add	 ebx, eax

; 2643 : 
; 2644 : 	if ( iCUR_LIVES > 40 )

  00035	83 fb 28	 cmp	 ebx, 40			; 00000028H
  00038	7e 15		 jle	 SHORT $LN6@ProcessTra

; 2645 : 	{
; 2646 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS = 0;

  0003a	69 f6 6c 08 00
	00		 imul	 esi, 2156		; 0000086cH
  00040	5b		 pop	 ebx
  00041	c7 44 3e 64 00
	00 00 00	 mov	 DWORD PTR [esi+edi+100], 0
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi

; 2662 : 	}
; 2663 : }

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN6@ProcessTra:

; 2647 : 	}
; 2648 : 	else if ( iCUR_LIVES > 30 )

  0004f	83 fb 1e	 cmp	 ebx, 30			; 0000001eH
  00052	7e 21		 jle	 SHORT $LN4@ProcessTra

; 2649 : 	{
; 2650 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS = 1;

  00054	8b c6		 mov	 eax, esi
  00056	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH

; 2651 : 		this->SendNoticeState(iChaosCastleIndex, 8);

  0005c	6a 08		 push	 8

; 2661 : 		this->SendNoticeState(iChaosCastleIndex, 10);

  0005e	56		 push	 esi
  0005f	8b cf		 mov	 ecx, edi
  00061	c7 44 38 64 01
	00 00 00	 mov	 DWORD PTR [eax+edi+100], 1
  00069	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState
  0006e	5b		 pop	 ebx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi

; 2662 : 	}
; 2663 : }

  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
$LN4@ProcessTra:

; 2652 : 	}
; 2653 : 	else if ( iCUR_LIVES > 20 )

  00075	83 fb 14	 cmp	 ebx, 20			; 00000014H
  00078	7e 21		 jle	 SHORT $LN2@ProcessTra

; 2654 : 	{
; 2655 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS = 2;

  0007a	8b ce		 mov	 ecx, esi
  0007c	69 c9 6c 08 00
	00		 imul	 ecx, 2156		; 0000086cH

; 2656 : 		this->SendNoticeState(iChaosCastleIndex, 9);

  00082	6a 09		 push	 9
  00084	c7 44 39 64 02
	00 00 00	 mov	 DWORD PTR [ecx+edi+100], 2

; 2661 : 		this->SendNoticeState(iChaosCastleIndex, 10);

  0008c	56		 push	 esi
  0008d	8b cf		 mov	 ecx, edi
  0008f	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState
  00094	5b		 pop	 ebx
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi

; 2662 : 	}
; 2663 : }

  00097	5d		 pop	 ebp
  00098	c2 04 00	 ret	 4
$LN2@ProcessTra:

; 2657 : 	}
; 2658 : 	else
; 2659 : 	{
; 2660 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS = 3;

  0009b	8b d6		 mov	 edx, esi
  0009d	69 d2 6c 08 00
	00		 imul	 edx, 2156		; 0000086cH

; 2661 : 		this->SendNoticeState(iChaosCastleIndex, 10);

  000a3	6a 0a		 push	 10			; 0000000aH
  000a5	56		 push	 esi
  000a6	8b cf		 mov	 ecx, edi
  000a8	c7 44 3a 64 03
	00 00 00	 mov	 DWORD PTR [edx+edi+100], 3
  000b0	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState
  000b5	5b		 pop	 ebx
$LN1@ProcessTra:
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi

; 2662 : 	}
; 2663 : }

  000b8	5d		 pop	 ebp
  000b9	c2 04 00	 ret	 4
?ProcessTrapStatus@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::ProcessTrapStatus
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 298  : 	_Vector_iterator()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 299  : 		{	// construct with null vector pointer
; 300  : 		}

  00008	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 323  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost
; Function compile flags: /Ogtp
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
; Function compile flags: /Ogtp
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 556  : 		}

  0000a	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key
; Function compile flags: /Ogtp
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UCHAOSCASTLE_START_TIME@@@1@@Z ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UCHAOSCASTLE_START_TIME@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UCHAOSCASTLE_START_TIME@@@1@@Z PROC ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UCHAOSCASTLE_START_TIME@@@1@@Z ENDP ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 332  : 		++*(_Mybase *)this;

  00002	83 00 08	 add	 DWORD PTR [eax], 8

; 333  : 		return (*this);
; 334  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@V?$allocator@UtagPOINT@@@1@@Z ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::_Vector_val<tagPOINT,std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@V?$allocator@UtagPOINT@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@V?$allocator@UtagPOINT@@@1@@Z PROC ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::_Vector_val<tagPOINT,std::allocator<tagPOINT> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@V?$allocator@UtagPOINT@@@1@@Z ENDP ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::_Vector_val<tagPOINT,std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >, COMDAT
; _this$ = ecx

; 208  : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 209  : 		}

  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEAAUtagPOINT@@XZ ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEAAUtagPOINT@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEAAUtagPOINT@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 323  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEAAUtagPOINT@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lbound
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1742 : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00009	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  0000d	75 19		 jne	 SHORT $LN3@Lbound
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL4@Lbound:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	7d 05		 jge	 SHORT $LN2@Lbound

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  0001c	eb 04		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00026	74 ec		 je	 SHORT $LL4@Lbound
$LN3@Lbound:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEII@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEII@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 1f	 mov	 edx, 536870911		; 1fffffffH
  0000d	c1 f8 03	 sar	 eax, 3
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00023	3b c1		 cmp	 eax, ecx
  00025	73 02		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00027	8b c1		 mov	 eax, ecx
$LN1@Grow_to:

; 1282 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Grow_to@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEII@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Grow_to
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEII@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEII@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 1f	 mov	 edx, 536870911		; 1fffffffH
  0000d	c1 f8 03	 sar	 eax, 3
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to@2
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to@2:

; 1279 : 		if (_Capacity < _Count)

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00023	3b c1		 cmp	 eax, ecx
  00025	73 02		 jae	 SHORT $LN1@Grow_to@2

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00027	8b c1		 mov	 eax, ecx
$LN1@Grow_to@2:

; 1282 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Grow_to@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEII@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Grow_to
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ; std::vector<int,std::allocator<int> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z PROC ; std::vector<int,std::allocator<int> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  0000d	c1 f8 02	 sar	 eax, 2
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to@3
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to@3
$LN4@Grow_to@3:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to@3:

; 1279 : 		if (_Capacity < _Count)

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00023	3b c1		 cmp	 eax, ecx
  00025	73 02		 jae	 SHORT $LN1@Grow_to@3

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00027	8b c1		 mov	 eax, ecx
$LN1@Grow_to@3:

; 1282 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ENDP ; std::vector<int,std::allocator<int> >::_Grow_to
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 483  : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=, COMDAT
; _this$ = ecx

; 357  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 358  : 		*(_Mybase *)this += _Off;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  0000f	01 10		 add	 DWORD PTR [eax], edx

; 359  : 		return (*this);
; 360  : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	56		 push	 esi

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
  0000c	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000f	8b 30		 mov	 esi, DWORD PTR [eax]
  00011	80 7e 19 00	 cmp	 BYTE PTR [esi+25], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0c		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Lrotate:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0b		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003e	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  00040	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate:

; 1775 : 		else
; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	56		 push	 esi

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000c	89 32		 mov	 DWORD PTR [edx], esi

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00011	80 7e 19 00	 cmp	 BYTE PTR [esi+25], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0d		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN4@Rrotate:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0d		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00041	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00044	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate:

; 1805 : 		else
; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 267  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ; std::pair<int,_MONSTER_ITEM_DROP>::pair<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z PROC ; std::pair<int,_MONSTER_ITEM_DROP>::pair<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00014	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00017	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 248  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ENDP ; std::pair<int,_MONSTER_ITEM_DROP>::pair<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val@2
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@2:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ; std::_Cons_val<std::allocator<int>,int,int &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z PROC ; std::_Cons_val<std::allocator<int>,int,int &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN7@Cons_val@3
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN7@Cons_val@3:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ENDP ; std::_Cons_val<std::allocator<int>,int,int &>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T164725 = -12						; size = 12
$T164730 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 4a		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00015	77 1a		 ja	 SHORT $LN1@Allocate
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	2b c1		 sub	 eax, ecx
  00020	03 c0		 add	 eax, eax
  00022	03 c0		 add	 eax, eax
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002a	83 c4 04	 add	 esp, 4
  0002d	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0002f	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00031	8d 4d 08	 lea	 ecx, DWORD PTR $T164730[ebp]
  00034	51		 push	 ecx
  00035	8d 4d f4	 lea	 ecx, DWORD PTR $T164725[ebp]
  00038	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T164730[ebp], 0
  0003f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00044	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00049	8d 55 f4	 lea	 edx, DWORD PTR $T164725[ebp]
  0004c	52		 push	 edx
  0004d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T164725[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00054	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$_Allocate@UCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@IPAU1@@Z ; std::_Allocate<CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@UCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@IPAU1@@Z
_TEXT	SEGMENT
$T164738 = -12						; size = 12
$T164742 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@IPAU1@@Z PROC ; std::_Allocate<CHAOSCASTLE_START_TIME>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate@2

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN1@Allocate@2
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T164742[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T164738[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T164742[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T164738[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T164738[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate@2:
??$_Allocate@UCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@IPAU1@@Z ENDP ; std::_Allocate<CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$_Allocate@UtagPOINT@@@std@@YAPAUtagPOINT@@IPAU1@@Z ; std::_Allocate<tagPOINT>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@UtagPOINT@@@std@@YAPAUtagPOINT@@IPAU1@@Z
_TEXT	SEGMENT
$T164747 = -12						; size = 12
$T164751 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UtagPOINT@@@std@@YAPAUtagPOINT@@IPAU1@@Z PROC ; std::_Allocate<tagPOINT>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate@3

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN1@Allocate@3
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T164751[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T164747[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T164751[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T164747[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T164747[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@3:
$LN5@Allocate@3:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate@3:
??$_Allocate@UtagPOINT@@@std@@YAPAUtagPOINT@@IPAU1@@Z ENDP ; std::_Allocate<tagPOINT>
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T164756 = -12						; size = 12
$T164760 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate@4

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 14		 ja	 SHORT $LN1@Allocate@4
  00017	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate@4
$LN1@Allocate@4:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T164760[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T164756[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T164760[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T164756[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T164756[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@4:
$LN5@Allocate@4:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate@4:
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@Z PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@Z ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@ABU3@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@ABU3@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN5@construct@4
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@construct@4:

; 198  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@ABU3@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::construct
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@ABU3@@Z ; std::allocator<tagPOINT>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@ABU3@@Z PROC ; std::allocator<tagPOINT>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN5@construct@5
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@construct@5:

; 198  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@ABU3@@Z ENDP ; std::allocator<tagPOINT>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@@Z ; std::allocator<tagPOINT>::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@@Z PROC ; std::allocator<tagPOINT>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@@Z ENDP ; std::allocator<tagPOINT>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@H@std@@QAEXPAHABH@Z	; std::allocator<int>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@H@std@@QAEXPAHABH@Z PROC		; std::allocator<int>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN5@construct@6
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN5@construct@6:

; 198  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@H@std@@QAEXPAHABH@Z ENDP		; std::allocator<int>::construct
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::max_size, COMDAT
; _this$ = ecx

; 874  : 		return (this->_Alval.max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::max_size
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 306  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 146  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 16		 je	 SHORT $LN1@Move
  00010	56		 push	 esi
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	83 c1 08	 add	 ecx, 8
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ca		 cmp	 ecx, edx
  00023	75 ec		 jne	 SHORT $LL3@Move
  00025	5e		 pop	 esi
$LN1@Move:

; 2515 : 	return (_Dest);
; 2516 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 472  : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::destroy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct@7
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@7:

; 203  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::construct
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z ; std::allocator<tagPOINT>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z PROC ; std::allocator<tagPOINT>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct@8
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@8:

; 203  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z ENDP ; std::allocator<tagPOINT>::construct
_TEXT	ENDS
PUBLIC	??$?0HU_MONSTER_ITEM_DROP@@@?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::pair<int const ,_MONSTER_ITEM_DROP>::pair<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0HU_MONSTER_ITEM_DROP@@@?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0HU_MONSTER_ITEM_DROP@@@?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::pair<int const ,_MONSTER_ITEM_DROP>::pair<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx
  0000c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00012	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00015	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 256  : 		}

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??$?0HU_MONSTER_ITEM_DROP@@@?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::pair<int const ,_MONSTER_ITEM_DROP>::pair<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtp
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	_Ty _Tmp = _Move(_Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00009	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]
  0000c	8a 16		 mov	 dl, BYTE PTR [esi]
  0000e	88 10		 mov	 BYTE PTR [eax], dl

; 104  : 	_Right = _Move(_Tmp);

  00010	88 0e		 mov	 BYTE PTR [esi], cl
  00012	5e		 pop	 esi

; 105  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	??_C@_0CF@HDBNCAHD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
PUBLIC	?SetState_PlayEnd@CChaosCastle@@IAEXH@Z		; CChaosCastle::SetState_PlayEnd
;	COMDAT ??_C@_0CF@HDBNCAHD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
CONST	SEGMENT
??_C@_0CF@HDBNCAHD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Chaos Castle] (%d) SetState PLAYEND', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_PlayEnd@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?SetState_PlayEnd@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::SetState_PlayEnd, COMDAT
; _this$ = ecx

; 932  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 933  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 47		 js	 SHORT $LN2@SetState_P
  0000e	33 c0		 xor	 eax, eax
  00010	83 fe 05	 cmp	 esi, 5
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 3b		 je	 SHORT $LN2@SetState_P

; 934  : 	{
; 935  : 		return;
; 936  : 	}
; 937  : 
; 938  : 	this->SendNoticeState(iChaosCastleIndex, 7);

  0001a	6a 07		 push	 7
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState

; 939  : 	this->ClearMonster(iChaosCastleIndex);

  00022	56		 push	 esi
  00023	8b cf		 mov	 ecx, edi
  00025	e8 00 00 00 00	 call	 ?ClearMonster@CChaosCastle@@QAEXH@Z ; CChaosCastle::ClearMonster

; 940  : 	this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER = false;

  0002a	8b c6		 mov	 eax, esi
  0002c	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  00032	c6 44 38 4c 00	 mov	 BYTE PTR [eax+edi+76], 0

; 941  : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = this->m_iCC_TIME_MIN_REST * 60 * 1000;

  00037	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0003a	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H

; 942  : 
; 943  : 	LogAdd(LOG_BLACK, "[Chaos Castle] (%d) SetState PLAYEND", iChaosCastleIndex+1);

  00040	46		 inc	 esi
  00041	56		 push	 esi
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HDBNCAHD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  00047	6a 00		 push	 0
  00049	89 4c 38 40	 mov	 DWORD PTR [eax+edi+64], ecx
  0004d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SetState_P:
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 944  : 
; 945  : 
; 946  : }

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?SetState_PlayEnd@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::SetState_PlayEnd
_TEXT	ENDS
PUBLIC	?SendWinMessage@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SendWinMessage
; Function compile flags: /Ogtp
;	COMDAT ?SendWinMessage@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
_iWinnerIndex$ = 12					; size = 4
?SendWinMessage@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SendWinMessage, COMDAT
; _this$ = ecx

; 1300 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1301 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	0f 88 88 00 00
	00		 js	 $LN5@SendWinMes
  0000e	33 c0		 xor	 eax, eax
  00010	83 fa 05	 cmp	 edx, 5
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 7c		 je	 SHORT $LN5@SendWinMes

; 1302 : 	{
; 1303 : 		return;
; 1304 : 	}
; 1305 : 
; 1306 : 	if ( OBJMAX_RANGE(iWinnerIndex) == FALSE )

  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _iWinnerIndex$[ebp]
  0001e	85 ff		 test	 edi, edi
  00020	78 73		 js	 SHORT $LN13@SendWinMes
  00022	33 c0		 xor	 eax, eax
  00024	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  0002a	0f 9e c0	 setle	 al
  0002d	85 c0		 test	 eax, eax
  0002f	74 64		 je	 SHORT $LN13@SendWinMes

; 1307 : 	{
; 1308 : 		return;
; 1309 : 	}
; 1310 : 
; 1311 : 	int iChaosCastleSubIndex = gObj[iWinnerIndex].m_cChaosCastleSubIndex;

  00031	8b c7		 mov	 eax, edi
  00033	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00039	0f be 80 0a 0d
	00 00		 movsx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3338]

; 1312 : 
; 1313 : 	if ( CC_SUB_FLOOR_RANGE(iChaosCastleSubIndex) == FALSE )

  00040	85 c0		 test	 eax, eax
  00042	78 51		 js	 SHORT $LN13@SendWinMes
  00044	53		 push	 ebx
  00045	33 db		 xor	 ebx, ebx
  00047	83 f8 45	 cmp	 eax, 69			; 00000045H
  0004a	0f 9e c3	 setle	 bl
  0004d	56		 push	 esi
  0004e	8b f3		 mov	 esi, ebx
  00050	85 f6		 test	 esi, esi
  00052	74 3f		 je	 SHORT $LN14@SendWinMes

; 1314 : 	{
; 1315 : 		return;
; 1316 : 	}
; 1317 : 
; 1318 : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_bSendQuitMsg == true )

  00054	8b f2		 mov	 esi, edx
  00056	69 f6 6c 08 00
	00		 imul	 esi, 2156		; 0000086cH
  0005c	03 f1		 add	 esi, ecx
  0005e	8d 1c 80	 lea	 ebx, DWORD PTR [eax+eax*4]
  00061	80 7c 9e 7c 01	 cmp	 BYTE PTR [esi+ebx*4+124], 1
  00066	8d 74 9e 7c	 lea	 esi, DWORD PTR [esi+ebx*4+124]
  0006a	74 27		 je	 SHORT $LN14@SendWinMes

; 1319 : 	{
; 1320 : 		return;
; 1321 : 	}
; 1322 : 
; 1323 : 	this->RewardUserEXP(iChaosCastleIndex, gObj[iWinnerIndex].m_cChaosCastleSubIndex, true );

  0006c	6a 01		 push	 1
  0006e	50		 push	 eax
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 ?RewardUserEXP@CChaosCastle@@QAEXHHH@Z ; CChaosCastle::RewardUserEXP

; 1324 : 	::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 210)), iWinnerIndex, 1);

  00075	6a 01		 push	 1
  00077	57		 push	 edi
  00078	68 d2 04 00 00	 push	 1234			; 000004d2H
  0007d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00082	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1325 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_bSendQuitMsg = true;

  00090	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN14@SendWinMes:
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
$LN13@SendWinMes:
  00095	5f		 pop	 edi
$LN5@SendWinMes:

; 1326 : }

  00096	5d		 pop	 ebp
  00097	c2 08 00	 ret	 8
?SendWinMessage@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SendWinMessage
_TEXT	ENDS
PUBLIC	?SendFailMessage@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SendFailMessage
; Function compile flags: /Ogtp
;	COMDAT ?SendFailMessage@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
_iLoserIndex$ = 12					; size = 4
?SendFailMessage@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SendFailMessage, COMDAT
; _this$ = ecx

; 1329 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1330 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	78 7a		 js	 SHORT $LN5@SendFailMe
  0000d	33 c0		 xor	 eax, eax
  0000f	83 fa 05	 cmp	 edx, 5
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 6e		 je	 SHORT $LN5@SendFailMe

; 1331 : 	{
; 1332 : 		return;
; 1333 : 	}
; 1334 : 
; 1335 : 	if ( OBJMAX_RANGE(iLoserIndex) == FALSE )

  00019	8b 45 0c	 mov	 eax, DWORD PTR _iLoserIndex$[ebp]
  0001c	85 c0		 test	 eax, eax
  0001e	78 67		 js	 SHORT $LN5@SendFailMe
  00020	33 c9		 xor	 ecx, ecx
  00022	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00027	0f 9e c1	 setle	 cl
  0002a	56		 push	 esi
  0002b	8b f1		 mov	 esi, ecx
  0002d	85 f6		 test	 esi, esi
  0002f	74 55		 je	 SHORT $LN13@SendFailMe

; 1336 : 	{
; 1337 : 		return;
; 1338 : 	}
; 1339 : 
; 1340 : 	int iChaosCastleSubIndex = gObj[iLoserIndex].m_cChaosCastleSubIndex;

  00031	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00037	0f be 80 0a 0d
	00 00		 movsx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3338]

; 1341 : 
; 1342 : 	if ( CC_SUB_FLOOR_RANGE(iChaosCastleSubIndex) == FALSE )

  0003e	85 c0		 test	 eax, eax
  00040	78 44		 js	 SHORT $LN13@SendFailMe
  00042	33 c9		 xor	 ecx, ecx
  00044	83 f8 45	 cmp	 eax, 69			; 00000045H
  00047	0f 9e c1	 setle	 cl
  0004a	8b f1		 mov	 esi, ecx
  0004c	85 f6		 test	 esi, esi
  0004e	74 36		 je	 SHORT $LN13@SendFailMe

; 1343 : 	{
; 1344 : 		return;
; 1345 : 	}
; 1346 : 
; 1347 : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_bSendQuitMsg == true )

  00050	8b ca		 mov	 ecx, edx
  00052	69 c9 6c 08 00
	00		 imul	 ecx, 2156		; 0000086cH
  00058	03 cf		 add	 ecx, edi
  0005a	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0005d	80 7c 81 7c 01	 cmp	 BYTE PTR [ecx+eax*4+124], 1
  00062	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  00065	74 1f		 je	 SHORT $LN13@SendFailMe

; 1348 : 	{
; 1349 : 		return;
; 1350 : 	}
; 1351 : 
; 1352 : 	this->RewardUserEXP(iChaosCastleIndex, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cChaosCastleSubIndex, false );

  00067	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0006a	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00070	0f be 81 0a 0d
	00 00		 movsx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3338]
  00077	6a 00		 push	 0
  00079	50		 push	 eax
  0007a	52		 push	 edx
  0007b	8b cf		 mov	 ecx, edi
  0007d	e8 00 00 00 00	 call	 ?RewardUserEXP@CChaosCastle@@QAEXHHH@Z ; CChaosCastle::RewardUserEXP

; 1353 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_bSendQuitMsg = true;

  00082	c6 46 7c 01	 mov	 BYTE PTR [esi+124], 1
$LN13@SendFailMe:
  00086	5e		 pop	 esi
$LN5@SendFailMe:
  00087	5f		 pop	 edi

; 1354 : }

  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
?SendFailMessage@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SendFailMessage
_TEXT	ENDS
PUBLIC	?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z	; CChaosCastle::SendAllLoserFailMessage
; Function compile flags: /Ogtp
;	COMDAT ?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv186 = 8						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iWinnerIndex$ = 12					; size = 4
?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z PROC	; CChaosCastle::SendAllLoserFailMessage, COMDAT
; _this$ = ecx

; 1357 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 1358 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	0f 88 95 00 00
	00		 js	 $LN4@SendAllLos
  00012	33 c0		 xor	 eax, eax
  00014	83 ff 05	 cmp	 edi, 5
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 85 00 00
	00		 je	 $LN4@SendAllLos

; 1359 : 	{
; 1360 : 		return;
; 1361 : 	}
; 1362 : 
; 1363 : 	if ( OBJMAX_RANGE(iWinnerIndex) == FALSE && iWinnerIndex != -1)	

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _iWinnerIndex$[ebp]
  00025	85 c9		 test	 ecx, ecx
  00027	78 0f		 js	 SHORT $LN17@SendAllLos
  00029	33 c0		 xor	 eax, eax
  0002b	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  00031	0f 9e c0	 setle	 al
  00034	85 c0		 test	 eax, eax
  00036	75 05		 jne	 SHORT $LN18@SendAllLos
$LN17@SendAllLos:
  00038	83 f9 ff	 cmp	 ecx, -1
  0003b	75 6a		 jne	 SHORT $LN4@SendAllLos
$LN18@SendAllLos:

; 1364 : 	{
; 1365 : 		return;
; 1366 : 	}
; 1367 : 
; 1368 : 
; 1369 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0003d	8b c7		 mov	 eax, edi
  0003f	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  00045	56		 push	 esi
  00046	8d 74 18 6c	 lea	 esi, DWORD PTR [eax+ebx+108]
  0004a	c7 45 08 46 00
	00 00		 mov	 DWORD PTR tv186[ebp], 70 ; 00000046H
$LL19@SendAllLos:

; 1370 : 	{
; 1371 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00051	8b 06		 mov	 eax, DWORD PTR [esi]
  00053	83 f8 ff	 cmp	 eax, -1
  00056	74 46		 je	 SHORT $LN5@SendAllLos

; 1372 : 		{
; 1373 : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != iWinnerIndex )

  00058	3b c1		 cmp	 eax, ecx
  0005a	74 42		 je	 SHORT $LN5@SendAllLos

; 1374 : 			{
; 1375 : 				if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_bSendQuitMsg == false )

  0005c	80 7e 10 00	 cmp	 BYTE PTR [esi+16], 0
  00060	75 3c		 jne	 SHORT $LN5@SendAllLos

; 1376 : 				{
; 1377 : 					this->RewardUserEXP(iChaosCastleIndex, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex, false);

  00062	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00068	0f be 88 0a 0d
	00 00		 movsx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3338]
  0006f	6a 00		 push	 0
  00071	51		 push	 ecx
  00072	57		 push	 edi
  00073	8b cb		 mov	 ecx, ebx
  00075	e8 00 00 00 00	 call	 ?RewardUserEXP@CChaosCastle@@QAEXHHH@Z ; CChaosCastle::RewardUserEXP

; 1378 : 					::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 211)), this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, 1);

  0007a	8b 16		 mov	 edx, DWORD PTR [esi]
  0007c	6a 01		 push	 1
  0007e	52		 push	 edx
  0007f	68 d3 04 00 00	 push	 1235			; 000004d3H
  00084	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00089	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1379 : 					this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_bSendQuitMsg = true;

  00094	8b 4d 0c	 mov	 ecx, DWORD PTR _iWinnerIndex$[ebp]
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1
$LN5@SendAllLos:

; 1364 : 	{
; 1365 : 		return;
; 1366 : 	}
; 1367 : 
; 1368 : 
; 1369 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0009e	83 c6 14	 add	 esi, 20			; 00000014H
  000a1	ff 4d 08	 dec	 DWORD PTR tv186[ebp]
  000a4	75 ab		 jne	 SHORT $LL19@SendAllLos
  000a6	5e		 pop	 esi
$LN4@SendAllLos:
  000a7	5f		 pop	 edi
  000a8	5b		 pop	 ebx

; 1380 : 				}
; 1381 : 			}
; 1382 : 		}
; 1383 : 	}
; 1384 : }

  000a9	5d		 pop	 ebp
  000aa	c2 08 00	 ret	 8
?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z ENDP	; CChaosCastle::SendAllLoserFailMessage
_TEXT	ENDS
PUBLIC	?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z	; CChaosCastle::BlowObjsFromPoint
; Function compile flags: /Ogtp
;	COMDAT ?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z
_TEXT	SEGMENT
_lpObj$ = -24						; size = 4
_this$ = -20						; size = 4
_iOBJ_DIST$ = -16					; size = 4
tv285 = -12						; size = 4
_iBLOWOUT_COUNT$159627 = -12				; size = 4
_iBLOW_MAX$159632 = -8					; size = 4
_iSIGN_Y$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iSIGN_X$ = 12						; size = 4
_iMapNumber$ = 12					; size = 4
_iX$ = 16						; size = 4
_iY$ = 20						; size = 4
?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z PROC	; CChaosCastle::BlowObjsFromPoint, COMDAT
; _this$ = ecx

; 2202 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 2203 : 	if ( !gObjIsConnected(iIndex))

  00008	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00011	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00016	83 c4 04	 add	 esp, 4
  00019	85 c0		 test	 eax, eax
  0001b	75 08		 jne	 SHORT $LN29@BlowObjsFr
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 2302 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 10 00	 ret	 16			; 00000010H
$LN29@BlowObjsFr:

; 2204 : 		return FALSE;
; 2205 : 
; 2206 : 	if ( !CHECK_LIMIT(iX, 256) || !CHECK_LIMIT(iY, 256))

  00025	8b 45 10	 mov	 eax, DWORD PTR _iX$[ebp]
  00028	53		 push	 ebx
  00029	8b 18		 mov	 ebx, DWORD PTR [eax]
  0002b	85 db		 test	 ebx, ebx
  0002d	0f 88 6e 02 00
	00		 js	 $LN27@BlowObjsFr
  00033	33 c0		 xor	 eax, eax
  00035	81 fb ff 00 00
	00		 cmp	 ebx, 255		; 000000ffH
  0003b	0f 9e c0	 setle	 al
  0003e	85 c0		 test	 eax, eax
  00040	0f 84 5b 02 00
	00		 je	 $LN27@BlowObjsFr
  00046	8b 4d 14	 mov	 ecx, DWORD PTR _iY$[ebp]
  00049	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004b	85 d2		 test	 edx, edx
  0004d	0f 88 4e 02 00
	00		 js	 $LN27@BlowObjsFr
  00053	33 c0		 xor	 eax, eax
  00055	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  0005b	0f 9e c0	 setle	 al
  0005e	85 c0		 test	 eax, eax
  00060	0f 84 3b 02 00
	00		 je	 $LN27@BlowObjsFr

; 2208 : 
; 2209 : 	LPOBJ lpObj = &gObj[iIndex];

  00066	8b c7		 mov	 eax, edi
  00068	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0006e	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2210 : 
; 2211 : 	if ( lpObj->DieRegen )

  00073	80 b8 02 02 00
	00 00		 cmp	 BYTE PTR [eax+514], 0
  0007a	89 45 e8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 2212 : 		return FALSE;

  0007d	0f 85 1e 02 00
	00		 jne	 $LN27@BlowObjsFr

; 2213 : 
; 2214 : 	if ( lpObj->Teleport )

  00083	80 b8 00 02 00
	00 00		 cmp	 BYTE PTR [eax+512], 0

; 2215 : 		return FALSE;

  0008a	0f 85 11 02 00
	00		 jne	 $LN27@BlowObjsFr

; 2216 : 
; 2217 : 	if ( lpObj->MapNumber != iMapNumber )

  00090	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00097	3b 4d 0c	 cmp	 ecx, DWORD PTR _iMapNumber$[ebp]

; 2218 : 		return FALSE;

  0009a	0f 85 01 02 00
	00		 jne	 $LN27@BlowObjsFr

; 2219 : 
; 2220 : 	int iOBJ_DIST = this->CalDistance(lpObj->X, lpObj->Y, iX, iY);

  000a0	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  000a7	0f bf b8 04 01
	00 00		 movsx	 edi, WORD PTR [eax+260]
  000ae	52		 push	 edx
  000af	53		 push	 ebx
  000b0	51		 push	 ecx
  000b1	89 4d f4	 mov	 DWORD PTR tv285[ebp], ecx
  000b4	57		 push	 edi
  000b5	8b ce		 mov	 ecx, esi
  000b7	e8 00 00 00 00	 call	 ?CalDistance@CChaosCastle@@QAEHHHHH@Z ; CChaosCastle::CalDistance
  000bc	8b f0		 mov	 esi, eax
  000be	89 75 f0	 mov	 DWORD PTR _iOBJ_DIST$[ebp], esi

; 2221 : 
; 2222 : 	if ( !CHECK_LIMIT(iOBJ_DIST, 4))

  000c1	85 f6		 test	 esi, esi
  000c3	0f 88 d8 01 00
	00		 js	 $LN27@BlowObjsFr
  000c9	33 c0		 xor	 eax, eax
  000cb	83 fe 03	 cmp	 esi, 3
  000ce	0f 9e c0	 setle	 al
  000d1	85 c0		 test	 eax, eax

; 2223 : 		return FALSE;

  000d3	0f 84 c8 01 00
	00		 je	 $LN27@BlowObjsFr

; 2224 : 
; 2225 : 	int iSIGN_X = 1;
; 2226 : 	int iSIGN_Y = 1;
; 2227 : 	int iUX = lpObj->X;
; 2228 : 	int iUY = lpObj->Y;
; 2229 : 
; 2230 : 	if ( iUX > iX )

  000d9	3b fb		 cmp	 edi, ebx
  000db	7e 09		 jle	 SHORT $LN55@BlowObjsFr

; 2231 : 		iSIGN_X = 1;

  000dd	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR _iSIGN_X$[ebp], 1
  000e4	eb 27		 jmp	 SHORT $LN38@BlowObjsFr
$LN55@BlowObjsFr:

; 2232 : 	else if ( iUX < iX )

  000e6	7d 09		 jge	 SHORT $LN20@BlowObjsFr

; 2233 : 		iSIGN_X = -1;

  000e8	c7 45 0c ff ff
	ff ff		 mov	 DWORD PTR _iSIGN_X$[ebp], -1

; 2234 : 	else

  000ef	eb 1c		 jmp	 SHORT $LN38@BlowObjsFr
$LN20@BlowObjsFr:

; 2235 : 	{
; 2236 : 		int iRND = rand() % 2;

  000f1	e8 00 00 00 00	 call	 _rand
  000f6	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000fb	79 05		 jns	 SHORT $LN49@BlowObjsFr
  000fd	48		 dec	 eax
  000fe	83 c8 fe	 or	 eax, -2			; fffffffeH
  00101	40		 inc	 eax
$LN49@BlowObjsFr:

; 2237 : 		(!iRND)?iSIGN_X = 1:iSIGN_X = -1;

  00102	f7 d8		 neg	 eax
  00104	1b c0		 sbb	 eax, eax
  00106	83 e0 fe	 and	 eax, -2			; fffffffeH
  00109	40		 inc	 eax
  0010a	89 45 0c	 mov	 DWORD PTR _iSIGN_X$[ebp], eax
$LN38@BlowObjsFr:

; 2238 : 	}
; 2239 : 		
; 2240 : 	if ( iUY > iY )

  0010d	8b 55 14	 mov	 edx, DWORD PTR _iY$[ebp]
  00110	8b 02		 mov	 eax, DWORD PTR [edx]
  00112	8b 4d f4	 mov	 ecx, DWORD PTR tv285[ebp]
  00115	3b c8		 cmp	 ecx, eax
  00117	7e 10		 jle	 SHORT $LN56@BlowObjsFr

; 2241 : 		iSIGN_Y = 1;

  00119	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _iSIGN_Y$[ebp], 1

; 2248 : 	}
; 2249 : 
; 2250 : 	BOOL bSuccessBlowOut = FALSE;
; 2251 : 
; 2252 : 	for ( int iBLOWOUT_COUNT = 0;iBLOWOUT_COUNT < 5 ;iBLOWOUT_COUNT++)

  00120	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iBLOWOUT_COUNT$159627[ebp], 0
  00127	eb 3a		 jmp	 SHORT $LN14@BlowObjsFr
$LN56@BlowObjsFr:

; 2242 : 	else if ( iUY < iY )

  00129	7d 10		 jge	 SHORT $LN16@BlowObjsFr

; 2243 : 		iSIGN_Y = -1;

  0012b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _iSIGN_Y$[ebp], -1

; 2248 : 	}
; 2249 : 
; 2250 : 	BOOL bSuccessBlowOut = FALSE;
; 2251 : 
; 2252 : 	for ( int iBLOWOUT_COUNT = 0;iBLOWOUT_COUNT < 5 ;iBLOWOUT_COUNT++)

  00132	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iBLOWOUT_COUNT$159627[ebp], 0
  00139	eb 28		 jmp	 SHORT $LN14@BlowObjsFr
$LN16@BlowObjsFr:

; 2244 : 	else
; 2245 : 	{
; 2246 : 		int iRND = rand() % 2;

  0013b	e8 00 00 00 00	 call	 _rand
  00140	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00145	79 05		 jns	 SHORT $LN50@BlowObjsFr
  00147	48		 dec	 eax
  00148	83 c8 fe	 or	 eax, -2			; fffffffeH
  0014b	40		 inc	 eax
$LN50@BlowObjsFr:

; 2247 : 		(!iRND)?iSIGN_Y = 1:iSIGN_Y = -1;

  0014c	f7 d8		 neg	 eax
  0014e	1b c0		 sbb	 eax, eax
  00150	83 e0 fe	 and	 eax, -2			; fffffffeH
  00153	40		 inc	 eax
  00154	89 45 fc	 mov	 DWORD PTR _iSIGN_Y$[ebp], eax

; 2248 : 	}
; 2249 : 
; 2250 : 	BOOL bSuccessBlowOut = FALSE;
; 2251 : 
; 2252 : 	for ( int iBLOWOUT_COUNT = 0;iBLOWOUT_COUNT < 5 ;iBLOWOUT_COUNT++)

  00157	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iBLOWOUT_COUNT$159627[ebp], 0
  0015e	eb 03		 jmp	 SHORT $LN14@BlowObjsFr
$LL46@BlowObjsFr:
  00160	8b 75 f0	 mov	 esi, DWORD PTR _iOBJ_DIST$[ebp]
$LN14@BlowObjsFr:

; 2253 : 	{
; 2254 : 		int iBLOW_MIN = g_iChaosCastle_BlowOutDistance[iOBJ_DIST][0];

  00163	8b 1c f5 00 00
	00 00		 mov	 ebx, DWORD PTR _g_iChaosCastle_BlowOutDistance[esi*8]

; 2255 : 		int iBLOW_MAX = g_iChaosCastle_BlowOutDistance[iOBJ_DIST][1];

  0016a	8b 34 f5 04 00
	00 00		 mov	 esi, DWORD PTR _g_iChaosCastle_BlowOutDistance[esi*8+4]
  00171	89 75 f8	 mov	 DWORD PTR _iBLOW_MAX$159632[ebp], esi

; 2256 : 		int iBLOW_X = rand() % (iBLOW_MAX - iBLOW_MIN + 1) + iBLOW_MIN;

  00174	2b f3		 sub	 esi, ebx
  00176	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
  00179	e8 00 00 00 00	 call	 _rand
  0017e	99		 cdq
  0017f	f7 ff		 idiv	 edi
  00181	8d 34 13	 lea	 esi, DWORD PTR [ebx+edx]

; 2257 : 		int iBLOW_Y = rand() % (iBLOW_MAX - iBLOW_MIN + 1) + iBLOW_MIN;

  00184	e8 00 00 00 00	 call	 _rand
  00189	99		 cdq
  0018a	f7 ff		 idiv	 edi
  0018c	8d 3c 13	 lea	 edi, DWORD PTR [ebx+edx]

; 2258 : 		int iRND = rand() % 2;

  0018f	e8 00 00 00 00	 call	 _rand
  00194	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00199	79 05		 jns	 SHORT $LN51@BlowObjsFr
  0019b	48		 dec	 eax
  0019c	83 c8 fe	 or	 eax, -2			; fffffffeH
  0019f	40		 inc	 eax
$LN51@BlowObjsFr:

; 2261 : 		{
; 2262 : 			if ( iBLOW_X >= iBLOW_MAX )

  001a0	8b 45 f8	 mov	 eax, DWORD PTR _iBLOW_MAX$159632[ebp]

; 2259 : 
; 2260 : 		if ( iRND )

  001a3	74 23		 je	 SHORT $LN11@BlowObjsFr

; 2261 : 		{
; 2262 : 			if ( iBLOW_X >= iBLOW_MAX )

  001a5	3b f0		 cmp	 esi, eax
  001a7	7c 40		 jl	 SHORT $LN47@BlowObjsFr

; 2263 : 			{
; 2264 : 				iBLOW_X = iBLOW_MAX;

  001a9	8b f0		 mov	 esi, eax

; 2265 : 				iBLOW_Y = iBLOW_MIN + (rand() % 2 -1);

  001ab	e8 00 00 00 00	 call	 _rand
  001b0	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  001b5	79 05		 jns	 SHORT $LN52@BlowObjsFr
  001b7	48		 dec	 eax
  001b8	83 c8 fe	 or	 eax, -2			; fffffffeH
  001bb	40		 inc	 eax
$LN52@BlowObjsFr:
  001bc	8d 7c 18 ff	 lea	 edi, DWORD PTR [eax+ebx-1]

; 2266 : 
; 2267 : 				if ( iBLOW_Y < 0 )

  001c0	85 ff		 test	 edi, edi
  001c2	79 25		 jns	 SHORT $LN47@BlowObjsFr

; 2268 : 					iBLOW_Y = 0;

  001c4	33 ff		 xor	 edi, edi

; 2269 : 			}
; 2270 : 		}

  001c6	eb 21		 jmp	 SHORT $LN47@BlowObjsFr
$LN11@BlowObjsFr:

; 2271 : 		else if ( iBLOW_Y >= iBLOW_MAX )

  001c8	3b f8		 cmp	 edi, eax
  001ca	7c 1d		 jl	 SHORT $LN47@BlowObjsFr

; 2272 : 		{
; 2273 : 			iBLOW_Y = iBLOW_MAX;

  001cc	8b f8		 mov	 edi, eax

; 2274 : 			iBLOW_X = iBLOW_MIN + (rand() % 2 -1);

  001ce	e8 00 00 00 00	 call	 _rand
  001d3	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  001d8	79 05		 jns	 SHORT $LN53@BlowObjsFr
  001da	48		 dec	 eax
  001db	83 c8 fe	 or	 eax, -2			; fffffffeH
  001de	40		 inc	 eax
$LN53@BlowObjsFr:
  001df	8d 74 18 ff	 lea	 esi, DWORD PTR [eax+ebx-1]

; 2275 : 
; 2276 : 			if ( iBLOW_X < 0 )

  001e3	85 f6		 test	 esi, esi
  001e5	79 02		 jns	 SHORT $LN47@BlowObjsFr

; 2277 : 				iBLOW_X = 0;

  001e7	33 f6		 xor	 esi, esi
$LN47@BlowObjsFr:

; 2278 : 		}
; 2279 : 
; 2280 : 		int iTX = lpObj->X  + iBLOW_X * iSIGN_X;
; 2281 : 		int iTY = lpObj->Y  + iBLOW_Y * iSIGN_Y;

  001e9	0f af 7d fc	 imul	 edi, DWORD PTR _iSIGN_Y$[ebp]
  001ed	0f af 75 0c	 imul	 esi, DWORD PTR _iSIGN_X$[ebp]
  001f1	8b 5d e8	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  001f4	0f bf 8b 06 01
	00 00		 movsx	 ecx, WORD PTR [ebx+262]
  001fb	0f bf 83 04 01
	00 00		 movsx	 eax, WORD PTR [ebx+260]
  00202	03 f9		 add	 edi, ecx
  00204	03 f0		 add	 esi, eax

; 2282 : 
; 2283 : 		if ( iTX < 0 ) iTX = 0;

  00206	79 02		 jns	 SHORT $LN5@BlowObjsFr
  00208	33 f6		 xor	 esi, esi
$LN5@BlowObjsFr:

; 2284 : 		if ( iTY < 0 ) iTY = 0;

  0020a	85 ff		 test	 edi, edi
  0020c	79 02		 jns	 SHORT $LN4@BlowObjsFr
  0020e	33 ff		 xor	 edi, edi
$LN4@BlowObjsFr:

; 2285 : 		if ( iTX > 255 ) iTX = 255;

  00210	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  00216	7e 05		 jle	 SHORT $LN3@BlowObjsFr
  00218	be ff 00 00 00	 mov	 esi, 255		; 000000ffH
$LN3@BlowObjsFr:

; 2286 : 		if ( iTY > 255 ) iTY = 255;

  0021d	81 ff ff 00 00
	00		 cmp	 edi, 255		; 000000ffH
  00223	7e 05		 jle	 SHORT $LN2@BlowObjsFr
  00225	bf ff 00 00 00	 mov	 edi, 255		; 000000ffH
$LN2@BlowObjsFr:

; 2287 : 
; 2288 : 		bSuccessBlowOut = this->ObjSetPosition(iIndex, iTX, iTY);

  0022a	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0022d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00230	57		 push	 edi
  00231	56		 push	 esi
  00232	52		 push	 edx
  00233	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition

; 2289 : 		
; 2290 : 		if ( bSuccessBlowOut )

  00238	85 c0		 test	 eax, eax
  0023a	75 1e		 jne	 SHORT $LN43@BlowObjsFr

; 2248 : 	}
; 2249 : 
; 2250 : 	BOOL bSuccessBlowOut = FALSE;
; 2251 : 
; 2252 : 	for ( int iBLOWOUT_COUNT = 0;iBLOWOUT_COUNT < 5 ;iBLOWOUT_COUNT++)

  0023c	8b 45 f4	 mov	 eax, DWORD PTR _iBLOWOUT_COUNT$159627[ebp]
  0023f	40		 inc	 eax
  00240	89 45 f4	 mov	 DWORD PTR _iBLOWOUT_COUNT$159627[ebp], eax
  00243	83 f8 05	 cmp	 eax, 5
  00246	0f 8c 14 ff ff
	ff		 jl	 $LL46@BlowObjsFr

; 2297 : 			break;
; 2298 : 		}
; 2299 : 	}
; 2300 : 
; 2301 : 	return TRUE;

  0024c	5b		 pop	 ebx
  0024d	5f		 pop	 edi
  0024e	b8 01 00 00 00	 mov	 eax, 1
  00253	5e		 pop	 esi

; 2302 : }

  00254	8b e5		 mov	 esp, ebp
  00256	5d		 pop	 ebp
  00257	c2 10 00	 ret	 16			; 00000010H
$LN43@BlowObjsFr:

; 2291 : 		{
; 2292 : 			lpObj->m_iChaosCastleBlowTime = GetTickCount();

  0025a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 2293 : 			iX = iTX;
; 2294 : 			iY = iTY;
; 2295 : 
; 2296 : 			this->GiveUserDamage(lpObj->m_Index, g_iChaosCastle_BlowOutDamage[iOBJ_DIST % 4]);

  00260	8b 55 f0	 mov	 edx, DWORD PTR _iOBJ_DIST$[ebp]
  00263	81 e2 03 00 00
	80		 and	 edx, -2147483645	; 80000003H
  00269	8b 4d 14	 mov	 ecx, DWORD PTR _iY$[ebp]
  0026c	89 83 0c 0d 00
	00		 mov	 DWORD PTR [ebx+3340], eax
  00272	8b 45 10	 mov	 eax, DWORD PTR _iX$[ebp]
  00275	89 30		 mov	 DWORD PTR [eax], esi
  00277	89 39		 mov	 DWORD PTR [ecx], edi
  00279	79 05		 jns	 SHORT $LN54@BlowObjsFr
  0027b	4a		 dec	 edx
  0027c	83 ca fc	 or	 edx, -4			; fffffffcH
  0027f	42		 inc	 edx
$LN54@BlowObjsFr:
  00280	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _g_iChaosCastle_BlowOutDamage[edx*4]
  00287	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00289	50		 push	 eax
  0028a	51		 push	 ecx
  0028b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0028e	e8 00 00 00 00	 call	 ?GiveUserDamage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::GiveUserDamage
  00293	5b		 pop	 ebx
  00294	5f		 pop	 edi

; 2297 : 			break;
; 2298 : 		}
; 2299 : 	}
; 2300 : 
; 2301 : 	return TRUE;

  00295	b8 01 00 00 00	 mov	 eax, 1
  0029a	5e		 pop	 esi

; 2302 : }

  0029b	8b e5		 mov	 esp, ebp
  0029d	5d		 pop	 ebp
  0029e	c2 10 00	 ret	 16			; 00000010H
$LN27@BlowObjsFr:
  002a1	5b		 pop	 ebx
  002a2	5f		 pop	 edi

; 2207 : 		return FALSE;

  002a3	33 c0		 xor	 eax, eax
  002a5	5e		 pop	 esi

; 2302 : }

  002a6	8b e5		 mov	 esp, ebp
  002a8	5d		 pop	 ebp
  002a9	c2 10 00	 ret	 16			; 00000010H
?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z ENDP	; CChaosCastle::BlowObjsFromPoint
_TEXT	ENDS
PUBLIC	??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@ ; `string'
PUBLIC	?CheckUserInDieTile@CChaosCastle@@QAEXH@Z	; CChaosCastle::CheckUserInDieTile
;	COMDAT ??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@
CONST	SEGMENT
??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] User Dead In Chaos Castle : Fall '
	DB	'from Castle (X:%d, Y:%d)', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckUserInDieTile@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iSY$159805 = -4					; size = 4
tv226 = 8						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?CheckUserInDieTile@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::CheckUserInDieTile, COMDAT
; _this$ = ecx

; 2502 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi

; 2503 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00007	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  0000a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	85 ff		 test	 edi, edi
  0000f	0f 88 71 01 00
	00		 js	 $LN5@CheckUserI
  00015	33 c0		 xor	 eax, eax
  00017	83 ff 05	 cmp	 edi, 5
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 61 01 00
	00		 je	 $LN5@CheckUserI

; 2504 : 		return;
; 2505 : 
; 2506 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00025	8b c7		 mov	 eax, edi
  00027	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  0002d	53		 push	 ebx
  0002e	56		 push	 esi
  0002f	8d 74 08 6c	 lea	 esi, DWORD PTR [eax+ecx+108]
  00033	c7 45 08 46 00
	00 00		 mov	 DWORD PTR tv226[ebp], 70 ; 00000046H
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL7@CheckUserI:

; 2507 : 	{
; 2508 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	83 f8 ff	 cmp	 eax, -1
  00045	0f 84 2d 01 00
	00		 je	 $LN6@CheckUserI

; 2509 : 		{
; 2510 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) ==TRUE &&
; 2511 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == (iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1) )

  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00051	83 c4 04	 add	 esp, 4
  00054	83 f8 01	 cmp	 eax, 1
  00057	0f 85 1b 01 00
	00		 jne	 $LN6@CheckUserI
  0005d	8b 06		 mov	 eax, DWORD PTR [esi]
  0005f	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00065	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  0006c	8d 57 12	 lea	 edx, DWORD PTR [edi+18]
  0006f	3b ca		 cmp	 ecx, edx
  00071	0f 85 01 01 00
	00		 jne	 $LN6@CheckUserI

; 2512 : 			{
; 2513 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Life > 0.0 )

  00077	d9 ee		 fldz
  00079	d8 90 bc 00 00
	00		 fcom	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+188]
  0007f	df e0		 fnstsw	 ax
  00081	f6 c4 05	 test	 ah, 5
  00084	0f 8a ec 00 00
	00		 jp	 $LN21@CheckUserI

; 2514 : 				{
; 2515 : 					int iSX = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].X;

  0008a	8b 06		 mov	 eax, DWORD PTR [esi]
  0008c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00092	0f bf 98 04 01
	00 00		 movsx	 ebx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]

; 2516 : 					int iSY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Y;

  00099	0f bf 80 06 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]

; 2517 : 					BYTE btMapAttr = MapC[iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1].m_attrbuf[iSY * 256 + iSX] & 0x08;

  000a0	8b cf		 mov	 ecx, edi
  000a2	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  000a8	89 45 fc	 mov	 DWORD PTR _iSY$159805[ebp], eax
  000ab	c1 e0 08	 shl	 eax, 8
  000ae	03 81 a0 7e 5a
	00		 add	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+5930656]
  000b4	f6 04 18 08	 test	 BYTE PTR [eax+ebx], 8

; 2518 : 
; 2519 : 					if ( btMapAttr == 8 )

  000b8	0f 84 b8 00 00
	00		 je	 $LN21@CheckUserI

; 2520 : 					{
; 2521 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Life = 0;

  000be	8b 16		 mov	 edx, DWORD PTR [esi]
  000c0	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  000c6	d9 9a bc 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+188]

; 2522 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_State = 4;

  000cc	8b 06		 mov	 eax, DWORD PTR [esi]
  000ce	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000d4	c7 80 bc 01 00
	00 04 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+444], 4

; 2523 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].KillerType = 1;

  000de	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000e0	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000e6	c6 81 01 02 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+513], 1

; 2524 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].RegenTime = GetTickCount();

  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000f3	8b 16		 mov	 edx, DWORD PTR [esi]
  000f5	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  000fb	89 82 08 02 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+520], eax

; 2525 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].DieRegen = 1;

  00101	8b 06		 mov	 eax, DWORD PTR [esi]
  00103	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00109	c6 80 02 02 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+514], 1

; 2526 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].PathCount = 0;

  00110	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00112	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H

; 2527 : 
; 2528 : 						GCDiePlayerSend(&gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex],
; 2529 : 							this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, 0, 0);

  00118	6a 00		 push	 0
  0011a	c7 81 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+296], 0
  00124	8b 06		 mov	 eax, DWORD PTR [esi]
  00126	6a 00		 push	 0
  00128	50		 push	 eax
  00129	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0012f	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 ?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z ; GCDiePlayerSend

; 2530 : 
; 2531 : 						LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] User Dead In Chaos Castle : Fall from Castle (X:%d, Y:%d)",
; 2532 : 							iChaosCastleIndex+1, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].AccountID,
; 2533 : 							gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Name,
; 2534 : 							iSX, iSY);

  0013a	8b 06		 mov	 eax, DWORD PTR [esi]
  0013c	8b 55 fc	 mov	 edx, DWORD PTR _iSY$159805[ebp]
  0013f	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00145	52		 push	 edx
  00146	53		 push	 ebx
  00147	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  0014d	51		 push	 ecx
  0014e	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00154	52		 push	 edx
  00155	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00158	50		 push	 eax
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@
  0015e	6a 00		 push	 0
  00160	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2535 : 
; 2536 : 						this->SendFailMessage(iChaosCastleIndex, this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex);

  00165	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00167	83 c4 2c	 add	 esp, 44			; 0000002cH
  0016a	51		 push	 ecx
  0016b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	57		 push	 edi
  0016f	e8 00 00 00 00	 call	 ?SendFailMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendFailMessage
  00174	eb 02		 jmp	 SHORT $LN6@CheckUserI
$LN21@CheckUserI:

; 2518 : 
; 2519 : 					if ( btMapAttr == 8 )

  00176	dd d8		 fstp	 ST(0)
$LN6@CheckUserI:

; 2504 : 		return;
; 2505 : 
; 2506 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00178	83 c6 14	 add	 esi, 20			; 00000014H
  0017b	ff 4d 08	 dec	 DWORD PTR tv226[ebp]
  0017e	0f 85 bc fe ff
	ff		 jne	 $LL7@CheckUserI
  00184	5e		 pop	 esi
  00185	5b		 pop	 ebx
$LN5@CheckUserI:
  00186	5f		 pop	 edi

; 2537 : 
; 2538 : 					}
; 2539 : 				}
; 2540 : 			}
; 2541 : 		}
; 2542 : 	}
; 2543 : }

  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c2 04 00	 ret	 4
?CheckUserInDieTile@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::CheckUserInDieTile
_TEXT	ENDS
PUBLIC	??0?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 338  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 339  : 		++*this;

  0000a	83 c2 08	 add	 edx, 8
  0000d	89 11		 mov	 DWORD PTR [ecx], edx

; 340  : 		return (_Tmp);
; 341  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >, COMDAT
; _this$ = ecx

; 372  : 	_Tree_iterator()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 373  : 		{	// construct with null node
; 374  : 		}

  00008	c3		 ret	 0
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
_TEXT	ENDS
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator->
; Function compile flags: /Ogtp
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator->, COMDAT
; _this$ = ecx

; 401  : 		return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 402  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator->
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >
_TEXT	ENDS
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-=
; Function compile flags: /Ogtp
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-=, COMDAT
; _this$ = ecx

; 369  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 370  : 		return (*this += -_Off);

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	f7 d9		 neg	 ecx
  0000a	03 c9		 add	 ecx, ecx
  0000c	03 c9		 add	 ecx, ecx
  0000e	03 c9		 add	 ecx, ecx
  00010	01 08		 add	 DWORD PTR [eax], ecx

; 371  : 		}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-=
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
$T165197 = -12						; size = 12
$T165189 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 4a		 je	 SHORT $LN1@allocate
  0000f	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00015	77 1a		 ja	 SHORT $LN3@allocate
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	2b c1		 sub	 eax, ecx
  00020	03 c0		 add	 eax, eax
  00022	03 c0		 add	 eax, eax
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002a	83 c4 04	 add	 esp, 4
  0002d	85 c0		 test	 eax, eax
  0002f	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  00031	8d 4d 08	 lea	 ecx, DWORD PTR $T165189[ebp]
  00034	51		 push	 ecx
  00035	8d 4d f4	 lea	 ecx, DWORD PTR $T165197[ebp]
  00038	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T165189[ebp], 0
  0003f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00044	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00049	8d 55 f4	 lea	 edx, DWORD PTR $T165197[ebp]
  0004c	52		 push	 edx
  0004d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T165197[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00054	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z ; std::allocator<CHAOSCASTLE_START_TIME>::allocate
; Function compile flags: /Ogtp
;	COMDAT ?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z
_TEXT	SEGMENT
$T165220 = -12						; size = 12
$T165212 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate@2
  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN3@allocate@2
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate@2
$LN3@allocate@2:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T165212[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T165220[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T165212[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T165220[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T165220[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@2:
$LN1@allocate@2:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate@2:
?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z ; std::allocator<tagPOINT>::allocate
; Function compile flags: /Ogtp
;	COMDAT ?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z
_TEXT	SEGMENT
$T165243 = -12						; size = 12
$T165235 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z PROC ; std::allocator<tagPOINT>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate@3
  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN3@allocate@3
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate@3
$LN3@allocate@3:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T165235[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T165243[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T165235[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T165243[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T165243[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@3:
$LN1@allocate@3:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate@3:
?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z ENDP ; std::allocator<tagPOINT>::allocate
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 272  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++

; 273  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 274  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
$T165271 = -12						; size = 12
$T165263 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate@4
  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 14		 ja	 SHORT $LN3@allocate@4
  00017	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate@4
$LN3@allocate@4:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T165263[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T165271[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T165263[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T165271[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T165271[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@4:
$LN1@allocate@4:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate@4:
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN9@Cons_val@4
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Cons_val@4:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00@Z ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00@Z PROC ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 16		 je	 SHORT $LN5@Move@2
  00010	56		 push	 esi
$LL7@Move@2:
  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	83 c1 08	 add	 ecx, 8
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ca		 cmp	 ecx, edx
  00023	75 ec		 jne	 SHORT $LL7@Move@2
  00025	5e		 pop	 esi
$LN5@Move@2:

; 2536 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00@Z ENDP ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN9@Cons_val@5
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Cons_val@5:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z ; std::_Dest_val<std::allocator<tagPOINT>,tagPOINT>
; Function compile flags: /Ogtp
;	COMDAT ??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z PROC ; std::_Dest_val<std::allocator<tagPOINT>,tagPOINT>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z ENDP ; std::_Dest_val<std::allocator<tagPOINT>,tagPOINT>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ; std::_Cons_val<std::allocator<int>,int,int const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z PROC ; std::_Cons_val<std::allocator<int>,int,int const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN9@Cons_val@6
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN9@Cons_val@6:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ENDP ; std::_Cons_val<std::allocator<int>,int,int const &>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 1326 : 		}

  00027	5d		 pop	 ebp
  00028	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 419  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 421  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 228  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<tagPOINT> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T165541 = -16						; size = 12
$T165518 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00007	6a 1c		 push	 28			; 0000001cH
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 1a		 je	 SHORT $LN5@Buynode

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00024	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00027	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  0002a	66 89 48 18	 mov	 WORD PTR [eax+24], cx
  0002e	5e		 pop	 esi

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode:
  00033	8d 45 fc	 lea	 eax, DWORD PTR $T165518[ebp]
  00036	89 4d fc	 mov	 DWORD PTR $T165518[ebp], ecx
  00039	50		 push	 eax
  0003a	8d 4d f0	 lea	 ecx, DWORD PTR $T165541[ebp]
  0003d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00042	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00047	8d 4d f0	 lea	 ecx, DWORD PTR $T165541[ebp]
  0004a	51		 push	 ecx
  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T165541[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00052	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode:
$LN26@Buynode:
  00057	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z ; std::_Dest_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z PROC ; std::_Dest_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::_Dest_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::construct<std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
;	COMDAT ??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::construct<std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 13		 je	 SHORT $LN3@construct@9
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00014	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00017	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN3@construct@9:

; 209  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::construct<std::pair<int,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val@7
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@7:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val@8
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@8:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT>
_TEXT	ENDS
PUBLIC	?SetState_Playing@CChaosCastle@@IAEXH@Z		; CChaosCastle::SetState_Playing
PUBLIC	?SetState_Closed@CChaosCastle@@IAEXH@Z		; CChaosCastle::SetState_Closed
PUBLIC	?SetState@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SetState
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
;	COMDAT ?SetState@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
_iCC_STATE$ = 12					; size = 4
?SetState@CChaosCastle@@QAEXHH@Z PROC			; CChaosCastle::SetState, COMDAT
; _this$ = ecx

; 837  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 838  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 48		 js	 SHORT $LN7@SetState
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 05	 cmp	 eax, 5
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	74 3c		 je	 SHORT $LN7@SetState

; 839  : 	{
; 840  : 		return;
; 841  : 	}
; 842  : 
; 843  : 	if ( iCC_STATE < CC_STATE_NONE || iCC_STATE > CC_STATE_PLAYEND )

  00016	8b 55 0c	 mov	 edx, DWORD PTR _iCC_STATE$[ebp]
  00019	83 fa 03	 cmp	 edx, 3
  0001c	77 34		 ja	 SHORT $LN7@SetState

; 844  : 	{
; 845  : 		return;
; 846  : 	}
; 847  : 
; 848  : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_STATE = iCC_STATE;

  0001e	56		 push	 esi
  0001f	8b f0		 mov	 esi, eax
  00021	69 f6 6c 08 00
	00		 imul	 esi, 2156		; 0000086cH
  00027	89 54 0e 30	 mov	 DWORD PTR [esi+ecx+48], edx
  0002b	5e		 pop	 esi

; 849  : 
; 850  : 	switch ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_STATE )

  0002c	83 fa 03	 cmp	 edx, 3
  0002f	77 21		 ja	 SHORT $LN7@SetState
  00031	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN14@SetState[edx*4]
$LN3@SetState:

; 851  : 	{
; 852  : 		case CC_STATE_NONE:
; 853  : 			this->SetState_None(iChaosCastleIndex);
; 854  : 			break;
; 855  : 
; 856  : 		case CC_STATE_CLOSED:
; 857  : 			this->SetState_Closed(iChaosCastleIndex);

  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?SetState_Closed@CChaosCastle@@IAEXH@Z ; CChaosCastle::SetState_Closed

; 866  : 	}
; 867  : 	
; 868  : }

  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN2@SetState:

; 858  : 			break;
; 859  : 
; 860  : 		case CC_STATE_PLAYING:
; 861  : 			this->SetState_Playing(iChaosCastleIndex);

  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?SetState_Playing@CChaosCastle@@IAEXH@Z ; CChaosCastle::SetState_Playing

; 866  : 	}
; 867  : 	
; 868  : }

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN1@SetState:

; 862  : 			break;
; 863  : 
; 864  : 		case CC_STATE_PLAYEND:
; 865  : 			this->SetState_PlayEnd(iChaosCastleIndex);

  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?SetState_PlayEnd@CChaosCastle@@IAEXH@Z ; CChaosCastle::SetState_PlayEnd
$LN7@SetState:

; 866  : 	}
; 867  : 	
; 868  : }

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
  00056	8b ff		 npad	 2
$LN14@SetState:
  00058	00 00 00 00	 DD	 $LN7@SetState
  0005c	00 00 00 00	 DD	 $LN3@SetState
  00060	00 00 00 00	 DD	 $LN2@SetState
  00064	00 00 00 00	 DD	 $LN1@SetState
?SetState@CChaosCastle@@QAEXHH@Z ENDP			; CChaosCastle::SetState
_TEXT	ENDS
PUBLIC	?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z	; CChaosCastle::SearchNBlowObjs
; Function compile flags: /Ogtp
;	COMDAT ?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z
_TEXT	SEGMENT
tv407 = -28						; size = 4
_iMAX_Y$ = -24						; size = 4
_iMAX_X$ = -20						; size = 4
tv66 = -16						; size = 4
tv404 = -12						; size = 4
_this$ = -8						; size = 4
_iMIN_Y$ = -4						; size = 4
_iMIN_X$ = 8						; size = 4
_iMapNumber$ = 8					; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z PROC		; CChaosCastle::SearchNBlowObjs, COMDAT
; _this$ = ecx

; 2156 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	57		 push	 edi

; 2157 : 	if ( !CC_MAP_RANGE(iMapNumber))

  00007	8b 7d 08	 mov	 edi, DWORD PTR _iMapNumber$[ebp]
  0000a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	83 ff 12	 cmp	 edi, 18			; 00000012H
  00010	0f 8c 78 01 00
	00		 jl	 $LN12@SearchNBlo
  00016	33 c0		 xor	 eax, eax
  00018	83 ff 17	 cmp	 edi, 23			; 00000017H
  0001b	0f 9e c0	 setle	 al
  0001e	56		 push	 esi
  0001f	33 f6		 xor	 esi, esi
  00021	3b c6		 cmp	 eax, esi
  00023	0f 84 64 01 00
	00		 je	 $LN27@SearchNBlo

; 2158 : 		return;
; 2159 : 
; 2160 : 	if ( !CHECK_LIMIT(iX, 256) || !CHECK_LIMIT(iY, 256))

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _iX$[ebp]
  0002c	3b ce		 cmp	 ecx, esi
  0002e	0f 8c 59 01 00
	00		 jl	 $LN27@SearchNBlo
  00034	53		 push	 ebx
  00035	33 c0		 xor	 eax, eax
  00037	bb ff 00 00 00	 mov	 ebx, 255		; 000000ffH
  0003c	3b cb		 cmp	 ecx, ebx
  0003e	0f 9e c0	 setle	 al
  00041	3b c6		 cmp	 eax, esi
  00043	0f 84 43 01 00
	00		 je	 $LN28@SearchNBlo
  00049	8b 45 10	 mov	 eax, DWORD PTR _iY$[ebp]
  0004c	3b c6		 cmp	 eax, esi
  0004e	0f 8c 38 01 00
	00		 jl	 $LN28@SearchNBlo
  00054	33 d2		 xor	 edx, edx
  00056	3b c3		 cmp	 eax, ebx
  00058	0f 9e c2	 setle	 dl
  0005b	3b d6		 cmp	 edx, esi
  0005d	0f 84 29 01 00
	00		 je	 $LN28@SearchNBlo

; 2161 : 		return;
; 2162 : 
; 2163 : 	int iMIN_X = iX-3;

  00063	8d 51 fd	 lea	 edx, DWORD PTR [ecx-3]

; 2164 : 	int iMAX_X = iX+3;

  00066	83 c1 03	 add	 ecx, 3
  00069	89 4d ec	 mov	 DWORD PTR _iMAX_X$[ebp], ecx

; 2165 : 	int iMIN_Y = iY-3;

  0006c	8d 48 fd	 lea	 ecx, DWORD PTR [eax-3]

; 2166 : 	int iMAX_Y = iY+3;

  0006f	83 c0 03	 add	 eax, 3
  00072	89 55 08	 mov	 DWORD PTR _iMIN_X$[ebp], edx
  00075	89 4d fc	 mov	 DWORD PTR _iMIN_Y$[ebp], ecx
  00078	89 45 e8	 mov	 DWORD PTR _iMAX_Y$[ebp], eax

; 2167 : 
; 2168 : 	if ( iMIN_X < 0 ) iMIN_X = 0;

  0007b	3b d6		 cmp	 edx, esi
  0007d	7d 03		 jge	 SHORT $LN11@SearchNBlo
  0007f	89 75 08	 mov	 DWORD PTR _iMIN_X$[ebp], esi
$LN11@SearchNBlo:

; 2169 : 	if ( iMIN_Y < 0 ) iMIN_Y = 0;

  00082	3b ce		 cmp	 ecx, esi
  00084	7d 03		 jge	 SHORT $LN10@SearchNBlo
  00086	89 75 fc	 mov	 DWORD PTR _iMIN_Y$[ebp], esi
$LN10@SearchNBlo:

; 2170 : 	if ( iMIN_X > 255 ) iMIN_X = 255;

  00089	39 5d 08	 cmp	 DWORD PTR _iMIN_X$[ebp], ebx
  0008c	7e 03		 jle	 SHORT $LN9@SearchNBlo
  0008e	89 5d 08	 mov	 DWORD PTR _iMIN_X$[ebp], ebx
$LN9@SearchNBlo:

; 2171 : 	if ( iMIN_Y > 255 ) iMIN_Y = 255;

  00091	39 5d fc	 cmp	 DWORD PTR _iMIN_Y$[ebp], ebx
  00094	7e 03		 jle	 SHORT $LN8@SearchNBlo
  00096	89 5d fc	 mov	 DWORD PTR _iMIN_Y$[ebp], ebx
$LN8@SearchNBlo:

; 2172 : 	
; 2173 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00099	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	8b c7		 mov	 eax, edi
  0009e	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  000a4	8d 94 08 d4 68
	ff ff		 lea	 edx, DWORD PTR [eax+ecx-38700]
  000ab	89 55 f4	 mov	 DWORD PTR tv404[ebp], edx
  000ae	c7 45 f0 46 00
	00 00		 mov	 DWORD PTR tv66[ebp], 70	; 00000046H
$LL26@SearchNBlo:

; 2174 : 	{
; 2175 : 		if ( this->m_stChaosCastleData[iMapNumber-18].m_UserData[i].m_iIndex == -1 )

  000b5	8b 45 f4	 mov	 eax, DWORD PTR tv404[ebp]
  000b8	8b 30		 mov	 esi, DWORD PTR [eax]
  000ba	89 75 e4	 mov	 DWORD PTR tv407[ebp], esi
  000bd	83 fe ff	 cmp	 esi, -1
  000c0	0f 84 b9 00 00
	00		 je	 $LN6@SearchNBlo

; 2176 : 			continue;
; 2177 : 
; 2178 : 		int iIndex = this->m_stChaosCastleData[iMapNumber-18].m_UserData[i].m_iIndex;
; 2179 : 
; 2180 : 		if ( gObj[iIndex].MapNumber == iMapNumber && gObj[iIndex].Connected > PLAYER_LOGGED )

  000c6	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000cc	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]
  000d3	3b cf		 cmp	 ecx, edi
  000d5	0f 85 a4 00 00
	00		 jne	 $LN6@SearchNBlo
  000db	80 be 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+4], 2
  000e2	0f 86 97 00 00
	00		 jbe	 $LN6@SearchNBlo

; 2181 : 		{
; 2182 : 			if ( gObj[iIndex].X >= iMIN_X && gObj[iIndex].X <= iMAX_X &&
; 2183 : 				 gObj[iIndex].Y >= iMIN_Y && gObj[iIndex].Y <= iMAX_Y )

  000e8	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  000ef	3b 45 08	 cmp	 eax, DWORD PTR _iMIN_X$[ebp]
  000f2	0f 8c 87 00 00
	00		 jl	 $LN6@SearchNBlo
  000f8	3b 45 ec	 cmp	 eax, DWORD PTR _iMAX_X$[ebp]
  000fb	0f 8f 7e 00 00
	00		 jg	 $LN6@SearchNBlo
  00101	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  00108	3b 45 fc	 cmp	 eax, DWORD PTR _iMIN_Y$[ebp]
  0010b	7c 72		 jl	 SHORT $LN6@SearchNBlo
  0010d	3b 45 e8	 cmp	 eax, DWORD PTR _iMAX_Y$[ebp]
  00110	7f 6d		 jg	 SHORT $LN6@SearchNBlo

; 2184 : 			{
; 2185 : 				this->BlowObjsFromPoint(gObj[iIndex].m_Index, iMapNumber, iX, iY);

  00112	8b 8e 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00118	8d 55 10	 lea	 edx, DWORD PTR _iY$[ebp]
  0011b	52		 push	 edx
  0011c	8d 45 0c	 lea	 eax, DWORD PTR _iX$[ebp]
  0011f	50		 push	 eax
  00120	57		 push	 edi
  00121	51		 push	 ecx
  00122	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	e8 00 00 00 00	 call	 ?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z ; CChaosCastle::BlowObjsFromPoint

; 2186 : 
; 2187 : 				BYTE btMapAttr = MapC[iMapNumber].m_attrbuf[iY * 256 + iX]&0x08;

  0012a	8b 5d 10	 mov	 ebx, DWORD PTR _iY$[ebp]
  0012d	8b 4d 0c	 mov	 ecx, DWORD PTR _iX$[ebp]
  00130	8b d7		 mov	 edx, edi
  00132	69 d2 08 07 05
	00		 imul	 edx, 329480		; 00050708H
  00138	8b c3		 mov	 eax, ebx
  0013a	c1 e0 08	 shl	 eax, 8
  0013d	03 82 10 00 00
	00		 add	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[edx+16]
  00143	f6 04 08 08	 test	 BYTE PTR [eax+ecx], 8

; 2188 : 
; 2189 : 				if ( btMapAttr == 8 )

  00147	74 36		 je	 SHORT $LN6@SearchNBlo

; 2190 : 				{
; 2191 : 					this->AddFallUser(iMapNumber-18, iIndex);

  00149	8b 55 e4	 mov	 edx, DWORD PTR tv407[ebp]
  0014c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	52		 push	 edx
  00150	8d 47 ee	 lea	 eax, DWORD PTR [edi-18]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ?AddFallUser@CChaosCastle@@QAEXHH@Z ; CChaosCastle::AddFallUser

; 2192 : 
; 2193 : 					LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] User Dead In Chaos Castle : Fall from Castle (X:%d, Y:%d)",
; 2194 : 						iMapNumber - 18+1, gObj[iIndex].AccountID, gObj[iIndex].Name, iX, iY);

  00159	8b 4d 0c	 mov	 ecx, DWORD PTR _iX$[ebp]
  0015c	53		 push	 ebx
  0015d	51		 push	 ecx
  0015e	8d 96 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00164	52		 push	 edx
  00165	8d 86 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  0016b	50		 push	 eax
  0016c	8d 4f ef	 lea	 ecx, DWORD PTR [edi-17]
  0016f	51		 push	 ecx
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@
  00175	6a 00		 push	 0
  00177	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0017c	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN6@SearchNBlo:

; 2172 : 	
; 2173 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0017f	83 45 f4 14	 add	 DWORD PTR tv404[ebp], 20 ; 00000014H
  00183	ff 4d f0	 dec	 DWORD PTR tv66[ebp]
  00186	0f 85 29 ff ff
	ff		 jne	 $LL26@SearchNBlo
$LN28@SearchNBlo:
  0018c	5b		 pop	 ebx
$LN27@SearchNBlo:
  0018d	5e		 pop	 esi
$LN12@SearchNBlo:
  0018e	5f		 pop	 edi

; 2195 : 				}
; 2196 : 			}
; 2197 : 		}
; 2198 : 	}
; 2199 : }

  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c2 0c 00	 ret	 12			; 0000000cH
?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z ENDP		; CChaosCastle::SearchNBlowObjs
_TEXT	ENDS
PUBLIC	?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end
_TEXT	ENDS
PUBLIC	?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::pop_back
; Function compile flags: /Ogtp
;	COMDAT ?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::pop_back, COMDAT
; _this$ = ecx

; 1017 : 		if (!empty())

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	39 01		 cmp	 DWORD PTR [ecx], eax
  00005	74 06		 je	 SHORT $LN1@pop_back

; 1018 : 			{	// erase last element
; 1019 : 			_Dest_val(this->_Alval,
; 1020 : 				this->_Mylast - 1);
; 1021 : 			--this->_Mylast;

  00007	83 c0 f8	 add	 eax, -8			; fffffff8H
  0000a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN1@pop_back:

; 1022 : 			}
; 1023 : 		}

  0000d	c3		 ret	 0
?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::pop_back
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 19 00	 cmp	 BYTE PTR [edi+25], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 1e		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	50		 push	 eax
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));
; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
  00029	80 7e 19 00	 cmp	 BYTE PTR [esi+25], 0
  0002d	8b fe		 mov	 edi, esi
  0002f	74 e2		 je	 SHORT $LL3@Erase
$LN1@Erase:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Make_iter
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Make_iter
_TEXT	ENDS
PUBLIC	?end@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@2@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@2@XZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@2@XZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::end
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-
; Function compile flags: /Ogtp
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-, COMDAT
; _this$ = ecx

; 374  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 375  : 		_Myiter _Tmp = *this;
; 376  : 		return (_Tmp -= _Off);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00012	2b ca		 sub	 ecx, edx
  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 377  : 		}

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 807  : 		return (iterator(_Lmost(), this));

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::begin
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z
_TEXT	SEGMENT
$T165910 = -16						; size = 12
$T165894 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  00009	6a 1c		 push	 28			; 0000001cH
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN15@Tree_val
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 18	 mov	 BYTE PTR [ecx+24], al

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 19	 mov	 BYTE PTR [edx+25], al

; 551  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T165894[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T165910[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T165894[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T165910[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T165910[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val:
$LN36@Tree_val:
  0006e	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
_TEXT	ENDS
PUBLIC	?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::vector<int,std::allocator<int> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 747  : 		if (max_size() < _Count)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000e	76 0a		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00015	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN43@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  0001a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0001d	2b 0e		 sub	 ecx, DWORD PTR [esi]
  0001f	c1 f9 02	 sar	 ecx, 2
  00022	3b c8		 cmp	 ecx, eax
  00024	73 50		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  00026	53		 push	 ebx
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0002c	e8 00 00 00 00	 call	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00031	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00034	8b d8		 mov	 ebx, eax
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	2b d0		 sub	 edx, eax
  0003a	c1 fa 02	 sar	 edx, 2
  0003d	03 d2		 add	 edx, edx
  0003f	03 d2		 add	 edx, edx
  00041	52		 push	 edx
  00042	50		 push	 eax
  00043	53		 push	 ebx
  00044	e8 00 00 00 00	 call	 _memmove

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);
; 757  : 			_RERAISE;
; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0004e	2b f8		 sub	 edi, eax
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	c1 ff 02	 sar	 edi, 2

; 761  : 			if (this->_Myfirst != 0)

  00056	85 c0		 test	 eax, eax
  00058	74 09		 je	 SHORT $LN37@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00060	83 c4 04	 add	 esp, 4
$LN37@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  00063	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 770  : 			this->_Mylast = _Ptr + _Size;

  00066	8d 14 bb	 lea	 edx, DWORD PTR [ebx+edi*4]
  00069	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]
  0006c	5f		 pop	 edi

; 771  : 			this->_Myfirst = _Ptr;

  0006d	89 1e		 mov	 DWORD PTR [esi], ebx
  0006f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00072	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00075	5b		 pop	 ebx
$LN3@reserve:
  00076	5e		 pop	 esi

; 772  : 			}
; 773  : 		}

  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
$LN42@reserve:
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::reserve
_TEXT	ENDS
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv795 = -12						; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	80 7b 19 00	 cmp	 BYTE PTR [ebx+25], 0
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00013	74 0a		 je	 SHORT $LN40@erase

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN295@erase:
$LN40@erase:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1207 : 		++_Where;	// save successor iterator for return

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00022	89 5d f8	 mov	 DWORD PTR __Erasednode$[ebp], ebx
  00025	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  0002a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002c	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00030	74 05		 je	 SHORT $LN39@erase

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00032	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00035	eb 17		 jmp	 SHORT $LN291@erase
$LN39@erase:
  00037	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0003a	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  0003e	74 04		 je	 SHORT $LN37@erase

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00040	8b f9		 mov	 edi, ecx

; 1218 : 		else

  00042	eb 0a		 jmp	 SHORT $LN291@erase
$LN37@erase:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00047	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  0004a	3b c3		 cmp	 eax, ebx
  0004c	75 72		 jne	 SHORT $LN35@erase
$LN291@erase:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004e	80 7f 19 00	 cmp	 BYTE PTR [edi+25], 0
  00052	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00055	75 03		 jne	 SHORT $LN34@erase

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00057	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00060	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00063	75 05		 jne	 SHORT $LN33@erase

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00065	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00068	eb 0b		 jmp	 SHORT $LN30@erase
$LN33@erase:
  0006a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0006c	75 04		 jne	 SHORT $LN31@erase

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006e	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  00070	eb 03		 jmp	 SHORT $LN30@erase
$LN31@erase:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  00072	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	39 18		 cmp	 DWORD PTR [eax], ebx
  0007a	75 1b		 jne	 SHORT $LN29@erase

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007c	80 7f 19 00	 cmp	 BYTE PTR [edi+25], 0
  00080	74 04		 je	 SHORT $LN43@erase
  00082	8b c6		 mov	 eax, esi
  00084	eb 0c		 jmp	 SHORT $LN44@erase
$LN43@erase:
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Min
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c4 04	 add	 esp, 4
$LN44@erase:
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	89 02		 mov	 DWORD PTR [edx], eax
$LN29@erase:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  00097	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009a	89 4d f4	 mov	 DWORD PTR tv795[ebp], ecx
  0009d	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000a0	75 78		 jne	 SHORT $LN165@erase

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000a2	80 7f 19 00	 cmp	 BYTE PTR [edi+25], 0
  000a6	74 07		 je	 SHORT $LN45@erase
  000a8	8b c6		 mov	 eax, esi
  000aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000ad	eb 6b		 jmp	 SHORT $LN165@erase
$LN45@erase:

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Max
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR tv795[ebp]
  000b8	83 c4 04	 add	 esp, 4
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000be	eb 5a		 jmp	 SHORT $LN165@erase
$LN35@erase:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c0	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f0		 mov	 esi, eax

; 1257 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase
$LN26@erase:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 19 00	 cmp	 BYTE PTR [edi+25], 0
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	75 03		 jne	 SHORT $LN24@erase

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e1	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000e4	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000e7	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN25@erase:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f0	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000f3	75 05		 jne	 SHORT $LN23@erase

; 1271 : 				_Root() = _Pnode;	// link down from root

  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f8	eb 0e		 jmp	 SHORT $LN20@erase
$LN23@erase:
  000fa	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000fd	39 19		 cmp	 DWORD PTR [ecx], ebx
  000ff	75 04		 jne	 SHORT $LN21@erase

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00101	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  00103	eb 03		 jmp	 SHORT $LN20@erase
$LN21@erase:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  00105	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00108	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0010b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  0010e	8a 53 18	 mov	 dl, BYTE PTR [ebx+24]
  00111	8a 48 18	 mov	 cl, BYTE PTR [eax+24]
  00114	88 50 18	 mov	 BYTE PTR [eax+24], dl
  00117	88 4b 18	 mov	 BYTE PTR [ebx+24], cl
$LN165@erase:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0011d	b3 01		 mov	 bl, 1
  0011f	38 58 18	 cmp	 BYTE PTR [eax+24], bl
  00122	0f 85 fa 00 00
	00		 jne	 $LN19@erase

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00128	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	3b 7a 04	 cmp	 edi, DWORD PTR [edx+4]
  00131	0f 84 e8 00 00
	00		 je	 $LN16@erase
$LL18@erase:
  00137	38 5f 18	 cmp	 BYTE PTR [edi+24], bl
  0013a	0f 85 df 00 00
	00		 jne	 $LN16@erase

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00140	8b 06		 mov	 eax, DWORD PTR [esi]
  00142	3b f8		 cmp	 edi, eax
  00144	75 65		 jne	 SHORT $LN15@erase

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  00146	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  00149	80 78 18 00	 cmp	 BYTE PTR [eax+24], 0
  0014d	75 13		 jne	 SHORT $LN14@erase

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0014f	88 58 18	 mov	 BYTE PTR [eax+24], bl

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  00152	56		 push	 esi
  00153	c6 46 18 00	 mov	 BYTE PTR [esi+24], 0
  00157	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN14@erase:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00162	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00166	75 74		 jne	 SHORT $LN293@erase

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00168	8b 10		 mov	 edx, DWORD PTR [eax]
  0016a	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  0016d	75 08		 jne	 SHORT $LN11@erase
  0016f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00172	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  00175	74 61		 je	 SHORT $LN294@erase
$LN11@erase:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  00177	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017a	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  0017d	75 15		 jne	 SHORT $LN9@erase

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	88 5a 18	 mov	 BYTE PTR [edx+24], bl

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  00184	50		 push	 eax
  00185	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0
  00189	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  0018e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN9@erase:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00194	8a 56 18	 mov	 dl, BYTE PTR [esi+24]
  00197	88 50 18	 mov	 BYTE PTR [eax+24], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0019a	88 5e 18	 mov	 BYTE PTR [esi+24], bl

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0019d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1323 : 						_Lrotate(_Fixnodeparent);

  001a0	56		 push	 esi
  001a1	88 58 18	 mov	 BYTE PTR [eax+24], bl
  001a4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001a9	eb 74		 jmp	 SHORT $LN16@erase
$LN15@erase:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001ab	80 78 18 00	 cmp	 BYTE PTR [eax+24], 0
  001af	75 12		 jne	 SHORT $LN7@erase

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001b1	88 58 18	 mov	 BYTE PTR [eax+24], bl

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001b4	56		 push	 esi
  001b5	c6 46 18 00	 mov	 BYTE PTR [esi+24], 0
  001b9	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001be	8b 06		 mov	 eax, DWORD PTR [esi]
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN7@erase:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001c3	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001c7	75 13		 jne	 SHORT $LN293@erase

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001cc	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  001cf	75 1e		 jne	 SHORT $LN4@erase
  001d1	8b 10		 mov	 edx, DWORD PTR [eax]
  001d3	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  001d6	75 17		 jne	 SHORT $LN4@erase
$LN294@erase:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001d8	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0
$LN293@erase:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001dc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1344 : 						_Fixnode = _Fixnodeparent;

  001df	8b fe		 mov	 edi, esi
  001e1	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001e4	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001e7	0f 85 4a ff ff
	ff		 jne	 $LL18@erase

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001ed	eb 30		 jmp	 SHORT $LN16@erase
$LN4@erase:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001ef	8b 10		 mov	 edx, DWORD PTR [eax]
  001f1	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  001f4	75 15		 jne	 SHORT $LN2@erase

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001f9	88 5a 18	 mov	 BYTE PTR [edx+24], bl

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  001fc	50		 push	 eax
  001fd	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0
  00201	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00206	8b 06		 mov	 eax, DWORD PTR [esi]
  00208	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN2@erase:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0020b	8a 56 18	 mov	 dl, BYTE PTR [esi+24]
  0020e	88 50 18	 mov	 BYTE PTR [eax+24], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00211	88 5e 18	 mov	 BYTE PTR [esi+24], bl

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00214	8b 00		 mov	 eax, DWORD PTR [eax]

; 1359 : 						_Rrotate(_Fixnodeparent);

  00216	56		 push	 esi
  00217	88 58 18	 mov	 BYTE PTR [eax+24], bl
  0021a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate
$LN16@erase:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  0021f	88 5f 18	 mov	 BYTE PTR [edi+24], bl
$LN19@erase:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00222	8b 4d f8	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00225	51		 push	 ecx
  00226	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  0022b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00231	83 c4 04	 add	 esp, 4
  00234	5f		 pop	 edi
  00235	5e		 pop	 esi
  00236	5b		 pop	 ebx
  00237	85 c0		 test	 eax, eax
  00239	74 04		 je	 SHORT $LN1@erase

; 1373 : 			--this->_Mysize;

  0023b	48		 dec	 eax
  0023c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  0023f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00242	8b 55 0c	 mov	 edx, DWORD PTR __Where$[ebp]
  00245	89 10		 mov	 DWORD PTR [eax], edx

; 1376 : 		}

  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c2 08 00	 ret	 8
$LN292@erase:
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@@Z ; std::_Destroy_range<std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@@Z PROC ; std::_Destroy_range<std::allocator<tagPOINT> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	3d 54 55 55 15	 cmp	 eax, 357913940		; 15555554H
  0000b	72 16		 jb	 SHORT $LN17@Insert

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));
; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  0000d	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN377@Insert:
$LN17@Insert:

; 1640 : 			}
; 1641 : 		++this->_Mysize;

  00023	40		 inc	 eax
  00024	53		 push	 ebx
  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1642 : 		_Newnode->_Parent = _Wherenode;

  00028	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0002b	57		 push	 edi
  0002c	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  0002f	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00032	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00035	32 db		 xor	 bl, bl
  00037	3b c2		 cmp	 eax, edx
  00039	75 10		 jne	 SHORT $LN16@Insert

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  0003b	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1647 : 			_Lmost() = _Newnode;

  0003e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00041	89 3a		 mov	 DWORD PTR [edx], edi

; 1648 : 			_Rmost() = _Newnode;

  00043	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00046	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00049	eb 20		 jmp	 SHORT $LN11@Insert
$LN16@Insert:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  0004b	38 5d 0c	 cmp	 BYTE PTR __Addleft$[ebp], bl
  0004e	74 0d		 je	 SHORT $LN14@Insert

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  00050	89 38		 mov	 DWORD PTR [eax], edi

; 1653 : 			if (_Wherenode == _Lmost())

  00052	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00055	3b 02		 cmp	 eax, DWORD PTR [edx]
  00057	75 12		 jne	 SHORT $LN11@Insert

; 1654 : 				_Lmost() = _Newnode;

  00059	89 3a		 mov	 DWORD PTR [edx], edi

; 1655 : 			}
; 1656 : 		else

  0005b	eb 0e		 jmp	 SHORT $LN11@Insert
$LN14@Insert:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  0005d	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 1659 : 			if (_Wherenode == _Rmost())

  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00066	75 03		 jne	 SHORT $LN11@Insert

; 1660 : 				_Rmost() = _Newnode;

  00068	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN11@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  0006b	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0006e	8b c7		 mov	 eax, edi
  00070	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  00073	0f 85 97 01 00
	00		 jne	 $LN9@Insert
  00079	56		 push	 esi
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL10@Insert:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00080	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00083	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00086	3b 16		 cmp	 edx, DWORD PTR [esi]
  00088	0f 85 c1 00 00
	00		 jne	 $LN8@Insert

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  0008e	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00091	38 5e 18	 cmp	 BYTE PTR [esi+24], bl
  00094	75 1c		 jne	 SHORT $LN7@Insert

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00096	c6 42 18 01	 mov	 BYTE PTR [edx+24], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  0009a	c6 46 18 01	 mov	 BYTE PTR [esi+24], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  0009e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a1	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000a4	88 5a 18	 mov	 BYTE PTR [edx+24], bl

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000a7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000aa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1677 : 					}
; 1678 : 				else

  000ad	e9 51 01 00 00	 jmp	 $LN316@Insert
$LN7@Insert:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000b2	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  000b5	75 3a		 jne	 SHORT $LN111@Insert

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  000b7	8b c2		 mov	 eax, edx

; 1683 : 						_Lrotate(_Pnode);

  000b9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000bc	8b 32		 mov	 esi, DWORD PTR [edx]
  000be	89 70 08	 mov	 DWORD PTR [eax+8], esi
  000c1	8b 32		 mov	 esi, DWORD PTR [edx]
  000c3	38 5e 19	 cmp	 BYTE PTR [esi+25], bl
  000c6	75 03		 jne	 SHORT $LN110@Insert
  000c8	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN110@Insert:
  000cb	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000ce	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000d1	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000d4	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000d7	75 05		 jne	 SHORT $LN109@Insert
  000d9	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000dc	eb 0e		 jmp	 SHORT $LN106@Insert
$LN109@Insert:
  000de	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000e1	3b 06		 cmp	 eax, DWORD PTR [esi]
  000e3	75 04		 jne	 SHORT $LN107@Insert
  000e5	89 16		 mov	 DWORD PTR [esi], edx
  000e7	eb 03		 jmp	 SHORT $LN106@Insert
$LN107@Insert:
  000e9	89 56 08	 mov	 DWORD PTR [esi+8], edx
$LN106@Insert:
  000ec	89 02		 mov	 DWORD PTR [edx], eax
  000ee	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN111@Insert:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000f1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000f4	c6 42 18 01	 mov	 BYTE PTR [edx+24], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000f8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000fb	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000fe	88 5a 18	 mov	 BYTE PTR [edx+24], bl

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00101	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00104	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00107	8b 32		 mov	 esi, DWORD PTR [edx]
  00109	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0010c	89 3a		 mov	 DWORD PTR [edx], edi
  0010e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00111	38 5f 19	 cmp	 BYTE PTR [edi+25], bl
  00114	75 03		 jne	 SHORT $LN173@Insert
  00116	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN173@Insert:
  00119	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0011c	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0011f	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00122	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  00125	75 0b		 jne	 SHORT $LN172@Insert
  00127	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0012a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  0012d	e9 cb 00 00 00	 jmp	 $LN376@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN172@Insert:
  00132	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00135	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  00138	75 0b		 jne	 SHORT $LN170@Insert
  0013a	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0013d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00140	e9 b8 00 00 00	 jmp	 $LN376@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN170@Insert:
  00145	89 37		 mov	 DWORD PTR [edi], esi
  00147	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  0014a	e9 ae 00 00 00	 jmp	 $LN376@Insert
$LN8@Insert:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  0014f	8b 36		 mov	 esi, DWORD PTR [esi]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  00151	38 5e 18	 cmp	 BYTE PTR [esi+24], bl
  00154	75 1c		 jne	 SHORT $LN3@Insert

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00156	c6 42 18 01	 mov	 BYTE PTR [edx+24], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  0015a	c6 46 18 01	 mov	 BYTE PTR [esi+24], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  0015e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00161	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00164	88 5a 18	 mov	 BYTE PTR [edx+24], bl

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00167	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1703 : 					}
; 1704 : 				else

  0016d	e9 91 00 00 00	 jmp	 $LN316@Insert
$LN3@Insert:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00172	3b 02		 cmp	 eax, DWORD PTR [edx]
  00174	75 3c		 jne	 SHORT $LN253@Insert

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  00176	8b c2		 mov	 eax, edx

; 1709 : 						_Rrotate(_Pnode);

  00178	8b 10		 mov	 edx, DWORD PTR [eax]
  0017a	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  0017d	89 30		 mov	 DWORD PTR [eax], esi
  0017f	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00182	38 5e 19	 cmp	 BYTE PTR [esi+25], bl
  00185	75 03		 jne	 SHORT $LN252@Insert
  00187	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN252@Insert:
  0018a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0018d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00190	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00193	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00196	75 05		 jne	 SHORT $LN251@Insert
  00198	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0019b	eb 0f		 jmp	 SHORT $LN248@Insert
$LN251@Insert:
  0019d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001a0	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  001a3	75 05		 jne	 SHORT $LN249@Insert
  001a5	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001a8	eb 02		 jmp	 SHORT $LN248@Insert
$LN249@Insert:
  001aa	89 16		 mov	 DWORD PTR [esi], edx
$LN248@Insert:
  001ac	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001af	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN253@Insert:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  001b2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001b5	c6 42 18 01	 mov	 BYTE PTR [edx+24], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  001b9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bc	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001bf	88 5a 18	 mov	 BYTE PTR [edx+24], bl

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001c2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001c5	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001c8	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  001cb	8b 3e		 mov	 edi, DWORD PTR [esi]
  001cd	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  001d0	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d2	38 5f 19	 cmp	 BYTE PTR [edi+25], bl
  001d5	75 03		 jne	 SHORT $LN315@Insert
  001d7	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN315@Insert:
  001da	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001dd	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001e0	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  001e3	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  001e6	75 05		 jne	 SHORT $LN314@Insert
  001e8	89 77 04	 mov	 DWORD PTR [edi+4], esi
  001eb	eb 0e		 jmp	 SHORT $LN311@Insert
$LN314@Insert:
  001ed	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001f0	3b 17		 cmp	 edx, DWORD PTR [edi]
  001f2	75 04		 jne	 SHORT $LN312@Insert
  001f4	89 37		 mov	 DWORD PTR [edi], esi
  001f6	eb 03		 jmp	 SHORT $LN311@Insert
$LN312@Insert:
  001f8	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN311@Insert:
  001fb	89 16		 mov	 DWORD PTR [esi], edx
$LN376@Insert:
  001fd	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00200	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN316@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00203	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00206	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  00209	0f 84 71 fe ff
	ff		 je	 $LL10@Insert
  0020f	5e		 pop	 esi
$LN9@Insert:

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00210	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00213	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1720 : 		return (iterator(_Newnode, this));

  00216	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00219	89 38		 mov	 DWORD PTR [eax], edi
  0021b	5f		 pop	 edi
  0021c	c6 41 18 01	 mov	 BYTE PTR [ecx+24], 1
  00220	5b		 pop	 ebx

; 1721 : 		}

  00221	5d		 pop	 ebp
  00222	c2 10 00	 ret	 16			; 00000010H
$LN375@Insert:
?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP>,std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP>,std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 13		 je	 SHORT $LN7@Cons_val@9
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00014	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00017	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN7@Cons_val@9:

; 281  : 	}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP>,std::pair<int,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
  0001e	83 c6 08	 add	 esi, 8
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 08	 add	 edi, 8
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>
; Function compile flags: /Ogtp
;	COMDAT ??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov@2
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov@2:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT>
  0001e	83 c6 08	 add	 esi, 8
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 08	 add	 edi, 8
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov@2

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov@2:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>
_TEXT	ENDS
PUBLIC	?Init@CChaosCastle@@QAEX_N@Z			; CChaosCastle::Init
_BSS	SEGMENT
_g_rtPOINT_TRAP DB 040H DUP (?)
_g_rtPOINT_FRAME DB 040H DUP (?)
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
_BSS	ENDS
;	COMDAT ?Init@CChaosCastle@@QAEX_N@Z
_TEXT	SEGMENT
tv539 = -8						; size = 4
tv331 = -4						; size = 4
tv328 = 8						; size = 4
_bEVENT_ENABLE$ = 8					; size = 1
?Init@CChaosCastle@@QAEX_N@Z PROC			; CChaosCastle::Init, COMDAT
; _this$ = ecx

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 	this->m_bCC_EVENT_ENABLE = bEVENT_ENABLE;

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _bEVENT_ENABLE$[ebp]
  00007	83 ec 08	 sub	 esp, 8
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b f9		 mov	 edi, ecx
  0000f	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 93   : 
; 94   : 	for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)

  00012	33 f6		 xor	 esi, esi
$LL6@Init:

; 95   : 	{
; 96   : 		this->SetState(i, CC_STATE_CLOSED);

  00014	6a 01		 push	 1
  00016	56		 push	 esi
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
  0001e	46		 inc	 esi
  0001f	83 fe 06	 cmp	 esi, 6
  00022	7c f0		 jl	 SHORT $LL6@Init

; 97   : 	}
; 98   : 
; 99   : 	for ( int iTRAP_STEP = 0; iTRAP_STEP<MAX_CC_TRAP_STEP;iTRAP_STEP++)

  00024	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _g_iChaosCastle_GroundAxis+8

; 120  : 
; 121  : 
; 122  : 
; 123  : 
; 124  : 		g_rtPOINT_TRAP[0].left = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0]) / 2 + 1;

  0002a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _g_iChaosCastle_GroundAxis
  00030	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  00033	99		 cdq
  00034	2b c2		 sub	 eax, edx
  00036	8b f0		 mov	 esi, eax
  00038	a1 04 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+4
  0003d	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+12
  00043	d1 fe		 sar	 esi, 1
  00045	99		 cdq
  00046	2b c2		 sub	 eax, edx
  00048	d1 f8		 sar	 eax, 1
  0004a	89 75 08	 mov	 DWORD PTR tv328[ebp], esi
  0004d	89 45 fc	 mov	 DWORD PTR tv331[ebp], eax
  00050	b9 00 00 00 00	 mov	 ecx, OFFSET _g_iChaosCastle_DamageAxis
  00055	eb 15		 jmp	 SHORT $LN3@Init
  00057	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL13@Init:

; 97   : 	}
; 98   : 
; 99   : 	for ( int iTRAP_STEP = 0; iTRAP_STEP<MAX_CC_TRAP_STEP;iTRAP_STEP++)

  00060	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _g_iChaosCastle_GroundAxis
  00066	8b 75 08	 mov	 esi, DWORD PTR tv328[ebp]
  00069	8b 45 fc	 mov	 eax, DWORD PTR tv331[ebp]
$LN3@Init:

; 100  : 	{
; 101  : 		g_rtPOINT_FRAME[0].left = (::g_iChaosCastle_GroundAxis[2] + ::g_iChaosCastle_GroundAxis[0]) / 2 + 1;
; 102  : 		g_rtPOINT_FRAME[0].top = g_iChaosCastle_GroundAxis[1];

  0006c	8b 1d 04 00 00
	00		 mov	 ebx, DWORD PTR _g_iChaosCastle_GroundAxis+4
  00072	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  00075	89 15 00 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME, edx
  0007b	89 1d 04 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+4, ebx

; 103  : 		g_rtPOINT_FRAME[0].right = ::g_iChaosCastle_GroundAxis[2];

  00081	8b 1d 08 00 00
	00		 mov	 ebx, DWORD PTR _g_iChaosCastle_GroundAxis+8

; 104  : 		g_rtPOINT_FRAME[0].bottom = (::g_iChaosCastle_GroundAxis[3] + ::g_iChaosCastle_GroundAxis[1] ) / 2 ;
; 105  : 
; 106  : 		g_rtPOINT_FRAME[1].left = (::g_iChaosCastle_GroundAxis[2] + ::g_iChaosCastle_GroundAxis[0]) / 2 + 1;

  00087	89 15 10 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+16, edx

; 107  : 		g_rtPOINT_FRAME[1].top = (::g_iChaosCastle_GroundAxis[3] + ::g_iChaosCastle_GroundAxis[1] ) / 2 + 1;

  0008d	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00090	a3 0c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+12, eax

; 108  : 		g_rtPOINT_FRAME[1].right = g_iChaosCastle_GroundAxis[2];
; 109  : 		g_rtPOINT_FRAME[1].bottom = ::g_iChaosCastle_GroundAxis[3];
; 110  : 		
; 111  : 		g_rtPOINT_FRAME[2].left = ::g_iChaosCastle_GroundAxis[0];
; 112  : 		g_rtPOINT_FRAME[2].top = (::g_iChaosCastle_GroundAxis[3] + ::g_iChaosCastle_GroundAxis[1] ) / 2 + 1;
; 113  : 		g_rtPOINT_FRAME[2].right = (::g_iChaosCastle_GroundAxis[2] + ::g_iChaosCastle_GroundAxis[0] ) / 2 ;
; 114  : 		g_rtPOINT_FRAME[2].bottom = ::g_iChaosCastle_GroundAxis[3];
; 115  : 
; 116  : 		g_rtPOINT_FRAME[3].left = ::g_iChaosCastle_GroundAxis[0];
; 117  : 		g_rtPOINT_FRAME[3].top = ::g_iChaosCastle_GroundAxis[1];
; 118  : 		g_rtPOINT_FRAME[3].right = (::g_iChaosCastle_GroundAxis[2] + ::g_iChaosCastle_GroundAxis[0] ) / 2;
; 119  : 		g_rtPOINT_FRAME[3].bottom = (::g_iChaosCastle_GroundAxis[3] + ::g_iChaosCastle_GroundAxis[1] ) / 2;

  00095	a3 3c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+60, eax
  0009a	89 1d 08 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+8, ebx
  000a0	89 15 14 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+20, edx
  000a6	89 1d 18 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+24, ebx
  000ac	8b 1d 0c 00 00
	00		 mov	 ebx, DWORD PTR _g_iChaosCastle_GroundAxis+12
  000b2	89 15 24 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+36, edx
  000b8	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _g_iChaosCastle_GroundAxis+4
  000be	89 3d 20 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+32, edi
  000c4	89 3d 30 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+48, edi

; 120  : 
; 121  : 
; 122  : 
; 123  : 
; 124  : 		g_rtPOINT_TRAP[0].left = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0]) / 2 + 1;

  000ca	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  000cd	89 1d 1c 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+28, ebx
  000d3	89 1d 2c 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+44, ebx
  000d9	8b 19		 mov	 ebx, DWORD PTR [ecx]
  000db	89 15 34 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+52, edx
  000e1	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  000e4	99		 cdq
  000e5	2b c2		 sub	 eax, edx
  000e7	89 35 28 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+40, esi
  000ed	89 35 38 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+56, esi
  000f3	8b f0		 mov	 esi, eax
  000f5	d1 fe		 sar	 esi, 1
  000f7	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000fa	89 45 f8	 mov	 DWORD PTR tv539[ebp], eax
  000fd	a3 00 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP, eax

; 125  : 		g_rtPOINT_TRAP[0].top = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1];

  00102	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00105	a3 04 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP+4, eax

; 126  : 		g_rtPOINT_TRAP[0].right = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][2];
; 127  : 		g_rtPOINT_TRAP[0].bottom = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1]) / 2;

  0010a	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  0010d	89 3d 08 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+8, edi
  00113	99		 cdq
  00114	2b c2		 sub	 eax, edx

; 128  : 
; 129  : 		g_rtPOINT_TRAP[1].left = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0]) / 2 + 1;

  00116	8b 55 f8	 mov	 edx, DWORD PTR tv539[ebp]
  00119	d1 f8		 sar	 eax, 1
  0011b	89 15 10 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+16, edx

; 130  : 		g_rtPOINT_TRAP[1].top = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1] ) / 2 + 1;

  00121	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00124	89 15 14 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+20, edx

; 131  : 		g_rtPOINT_TRAP[1].right = g_iChaosCastle_DamageAxis[iTRAP_STEP][2];

  0012a	89 3d 18 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+24, edi

; 132  : 		g_rtPOINT_TRAP[1].bottom = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][3];

  00130	8b 79 0c	 mov	 edi, DWORD PTR [ecx+12]

; 133  : 
; 134  : 		g_rtPOINT_TRAP[2].left = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0];
; 135  : 		g_rtPOINT_TRAP[2].top = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1] ) / 2 + 1;

  00133	89 15 24 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+36, edx

; 136  : 		g_rtPOINT_TRAP[2].right = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0] ) / 2;
; 137  : 		g_rtPOINT_TRAP[2].bottom = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][3];
; 138  : 
; 139  : 		g_rtPOINT_TRAP[3].left = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0];
; 140  : 		g_rtPOINT_TRAP[3].top = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1];

  00139	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0013c	83 c1 10	 add	 ecx, 16			; 00000010H
  0013f	a3 0c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP+12, eax
  00144	89 3d 1c 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+28, edi
  0014a	89 1d 20 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+32, ebx
  00150	89 35 28 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+40, esi
  00156	89 3d 2c 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+44, edi
  0015c	89 1d 30 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+48, ebx
  00162	89 15 34 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+52, edx

; 141  : 		g_rtPOINT_TRAP[3].right = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0] ) / 2;

  00168	89 35 38 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+56, esi

; 142  : 		g_rtPOINT_TRAP[3].bottom = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1] ) / 2;

  0016e	a3 3c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP+60, eax
  00173	81 f9 40 00 00
	00		 cmp	 ecx, OFFSET _g_iChaosCastle_DamageAxis+64
  00179	0f 8c e1 fe ff
	ff		 jl	 $LL13@Init
  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	5b		 pop	 ebx

; 143  : 	}
; 144  : }

  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c2 04 00	 ret	 4
?Init@CChaosCastle@@QAEX_N@Z ENDP			; CChaosCastle::Init
_TEXT	ENDS
PUBLIC	??_C@_0EN@IGEPIJHA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Start?5T@ ; `string'
PUBLIC	??_C@_0FH@CMJAMBAM@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@ ; `string'
PUBLIC	??_C@_0GG@HCMJNMOO@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@ ; `string'
PUBLIC	_iChaosCastleIndex$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CheckSync@CChaosCastle@@IAEXH@Z		; CChaosCastle::CheckSync
EXTRN	__imp__GetLocalTime@4:PROC
;	COMDAT ??_C@_0EN@IGEPIJHA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Start?5T@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0EN@IGEPIJHA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Start?5T@ DB '['
	DB	'Chaos Castle] (%d) Sync Start Time. [%d] min remain (START HO'
	DB	'UR:%d, MIN:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@CMJAMBAM@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@
CONST	SEGMENT
??_C@_0FH@CMJAMBAM@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@ DB '['
	DB	'Chaos Castle] (%d) No Schedule Time Data - Chaos Castle Termi'
	DB	'nated (bTIME_CHANGED=%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@HCMJNMOO@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@
CONST	SEGMENT
??_C@_0GG@HCMJNMOO@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@ DB '['
	DB	'Chaos Castle] (%d) No Schedule Time Data - Chaos Castle Termi'
	DB	'nated (m_vtChaosCastleOpenTime.empty())', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
CONST	ENDS
;	COMDAT ?CheckSync@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
tv507 = -40						; size = 4
tv495 = -36						; size = 4
_this$GSCopy$ = -32					; size = 4
_bTIME_CHANGED$ = -28					; size = 4
_iChaosCastleIndex$GSCopy$ = -24			; size = 4
_sysTime$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?CheckSync@CChaosCastle@@IAEXH@Z PROC			; CChaosCastle::CheckSync, COMDAT
; _this$ = ecx

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00015	8b d9		 mov	 ebx, ecx

; 288  : 
; 289  : 		for ( ; it != this->m_vtChaosCastleOpenTime.end() ; it++ )

  00017	89 5d e0	 mov	 DWORD PTR _this$GSCopy$[ebp], ebx

; 316  : 			return;
; 317  : 
; 318  : 	}
; 319  : 
; 320  : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  0001a	89 75 e8	 mov	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], esi
  0001d	85 f6		 test	 esi, esi
  0001f	0f 88 00 02 00
	00		 js	 $LN18@CheckSync

; 249  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00025	33 c0		 xor	 eax, eax
  00027	83 fe 05	 cmp	 esi, 5
  0002a	0f 9e c0	 setle	 al
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 f0 01 00
	00		 je	 $LN18@CheckSync

; 250  : 	{
; 251  : 		return;
; 252  : 	}
; 253  : 
; 254  : 	if ( this->m_vtChaosCastleOpenTime.empty() != false )

  00035	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00038	3b 43 24	 cmp	 eax, DWORD PTR [ebx+36]
  0003b	75 2d		 jne	 SHORT $LN16@CheckSync

; 255  : 	{
; 256  : 		LogAdd(LOG_RED,  "[Chaos Castle] (%d) No Schedule Time Data - Chaos Castle Terminated (m_vtChaosCastleOpenTime.empty())", iChaosCastleIndex);

  0003d	56		 push	 esi
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@HCMJNMOO@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@
  00043	6a 01		 push	 1
  00045	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 257  : 		this->SetState(iChaosCastleIndex+1, CC_STATE_NONE);

  0004d	6a 00		 push	 0
  0004f	46		 inc	 esi
  00050	56		 push	 esi
  00051	8b cb		 mov	 ecx, ebx
  00053	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx

; 325  : }

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005d	33 cd		 xor	 ecx, ebp
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
$LN16@CheckSync:
  0006a	57		 push	 edi

; 258  : 		
; 259  : 		return;
; 260  : 	}
; 261  : 
; 262  : 	SYSTEMTIME sysTime;
; 263  : 	GetLocalTime(&sysTime);

  0006b	8d 4d ec	 lea	 ecx, DWORD PTR _sysTime$[ebp]
  0006e	51		 push	 ecx
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 264  : 	int iMIN_HOUR = 24;
; 265  : 	int iMIN_MINUTE = 60;
; 266  : 	BOOL bTIME_CHANGED = FALSE;
; 267  : 
; 268  : 	for ( std::vector<CHAOSCASTLE_START_TIME>::iterator it = this->m_vtChaosCastleOpenTime.begin() ; it != this->m_vtChaosCastleOpenTime.end() ; it++ )

  00075	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  00078	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  0007b	be 18 00 00 00	 mov	 esi, 24			; 00000018H
  00080	8d 7e 24	 lea	 edi, DWORD PTR [esi+36]
  00083	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 0
  0008a	89 55 dc	 mov	 DWORD PTR tv495[ebp], edx
  0008d	3b c2		 cmp	 eax, edx
  0008f	74 56		 je	 SHORT $LN98@CheckSync

; 279  : 			}
; 280  : 		}
; 281  : 	}
; 282  : 
; 283  : 	if ( bTIME_CHANGED == FALSE )

  00091	0f b7 4d f4	 movzx	 ecx, WORD PTR _sysTime$[ebp+8]
  00095	8b d1		 mov	 edx, ecx
  00097	c1 e2 04	 shl	 edx, 4
  0009a	2b d1		 sub	 edx, ecx
  0009c	0f b7 4d f6	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  000a0	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  000a3	89 55 d8	 mov	 DWORD PTR tv507[ebp], edx
$LL36@CheckSync:

; 269  : 	{
; 270  : 		CHAOSCASTLE_START_TIME * stCCTime = &(*it);
; 271  : 
; 272  : 		if ( (sysTime.wHour * 60 + sysTime.wMinute) < (stCCTime->m_iHour * 60 + stCCTime->m_iMinute) )

  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ab	8b d9		 mov	 ebx, ecx
  000ad	c1 e3 04	 shl	 ebx, 4
  000b0	2b d9		 sub	 ebx, ecx
  000b2	8d 14 9a	 lea	 edx, DWORD PTR [edx+ebx*4]
  000b5	39 55 d8	 cmp	 DWORD PTR tv507[ebp], edx
  000b8	7d 1a		 jge	 SHORT $LN14@CheckSync

; 273  : 		{
; 274  : 			if ( ( iMIN_HOUR * 60 + iMIN_MINUTE ) > ( stCCTime->m_iHour * 60 + stCCTime->m_iMinute ) )

  000ba	8b de		 mov	 ebx, esi
  000bc	c1 e3 04	 shl	 ebx, 4
  000bf	2b de		 sub	 ebx, esi
  000c1	8d 1c 9f	 lea	 ebx, DWORD PTR [edi+ebx*4]
  000c4	3b da		 cmp	 ebx, edx
  000c6	7e 0c		 jle	 SHORT $LN14@CheckSync

; 275  : 			{
; 276  : 				bTIME_CHANGED = TRUE;
; 277  : 				iMIN_HOUR = stCCTime->m_iHour;
; 278  : 				iMIN_MINUTE = stCCTime->m_iMinute;

  000c8	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  000cb	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 1
  000d2	8b f1		 mov	 esi, ecx
$LN14@CheckSync:

; 264  : 	int iMIN_HOUR = 24;
; 265  : 	int iMIN_MINUTE = 60;
; 266  : 	BOOL bTIME_CHANGED = FALSE;
; 267  : 
; 268  : 	for ( std::vector<CHAOSCASTLE_START_TIME>::iterator it = this->m_vtChaosCastleOpenTime.begin() ; it != this->m_vtChaosCastleOpenTime.end() ; it++ )

  000d4	8b 55 dc	 mov	 edx, DWORD PTR tv495[ebp]
  000d7	83 c0 08	 add	 eax, 8
  000da	3b c2		 cmp	 eax, edx
  000dc	75 c8		 jne	 SHORT $LL36@CheckSync

; 279  : 			}
; 280  : 		}
; 281  : 	}
; 282  : 
; 283  : 	if ( bTIME_CHANGED == FALSE )

  000de	83 7d e4 00	 cmp	 DWORD PTR _bTIME_CHANGED$[ebp], 0
  000e2	8b 5d e0	 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
  000e5	75 43		 jne	 SHORT $LN102@CheckSync
$LN98@CheckSync:

; 284  : 	{
; 285  : 		std::vector<CHAOSCASTLE_START_TIME>::iterator it = this->m_vtChaosCastleOpenTime.begin();

  000e7	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]

; 286  : 		iMIN_HOUR = 24;

  000ea	be 18 00 00 00	 mov	 esi, 24			; 00000018H

; 287  : 		iMIN_MINUTE = 60;

  000ef	8d 7e 24	 lea	 edi, DWORD PTR [esi+36]

; 288  : 
; 289  : 		for ( ; it != this->m_vtChaosCastleOpenTime.end() ; it++ )

  000f2	3b ca		 cmp	 ecx, edx
  000f4	74 34		 je	 SHORT $LN102@CheckSync
$LL71@CheckSync:

; 290  : 		{
; 291  : 			CHAOSCASTLE_START_TIME * stCCTime = &(*it);
; 292  : 
; 293  : 			if ( ( iMIN_HOUR * 60 + iMIN_MINUTE ) > ( stCCTime->m_iHour * 60 + stCCTime->m_iMinute ) )

  000f6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000fb	8b d8		 mov	 ebx, eax
  000fd	c1 e3 04	 shl	 ebx, 4
  00100	2b d8		 sub	 ebx, eax
  00102	8d 14 9a	 lea	 edx, DWORD PTR [edx+ebx*4]
  00105	8b de		 mov	 ebx, esi
  00107	c1 e3 04	 shl	 ebx, 4
  0010a	2b de		 sub	 ebx, esi
  0010c	8d 1c 9f	 lea	 ebx, DWORD PTR [edi+ebx*4]
  0010f	3b da		 cmp	 ebx, edx
  00111	7e 0c		 jle	 SHORT $LN8@CheckSync

; 294  : 			{
; 295  : 				bTIME_CHANGED = 2;
; 296  : 				iMIN_HOUR = stCCTime->m_iHour;
; 297  : 				iMIN_MINUTE = stCCTime->m_iMinute;

  00113	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00116	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 2
  0011d	8b f0		 mov	 esi, eax
$LN8@CheckSync:

; 288  : 
; 289  : 		for ( ; it != this->m_vtChaosCastleOpenTime.end() ; it++ )

  0011f	83 c1 08	 add	 ecx, 8
  00122	3b 4d dc	 cmp	 ecx, DWORD PTR tv495[ebp]
  00125	75 cf		 jne	 SHORT $LL71@CheckSync
  00127	8b 5d e0	 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
$LN102@CheckSync:

; 298  : 			}
; 299  : 		}
; 300  : 	}
; 301  : 
; 302  : 	switch ( bTIME_CHANGED )

  0012a	8b 4d e4	 mov	 ecx, DWORD PTR _bTIME_CHANGED$[ebp]
  0012d	8b c1		 mov	 eax, ecx
  0012f	48		 dec	 eax
  00130	74 7d		 je	 SHORT $LN3@CheckSync
  00132	48		 dec	 eax
  00133	74 34		 je	 SHORT $LN2@CheckSync

; 311  : 
; 312  : 		default:
; 313  : 			LogAdd(LOG_RED,  "[Chaos Castle] (%d) No Schedule Time Data - Chaos Castle Terminated (bTIME_CHANGED=%d)",
; 314  : 				iChaosCastleIndex + 1, bTIME_CHANGED);

  00135	8b 75 e8	 mov	 esi, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  00138	51		 push	 ecx
  00139	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0013c	50		 push	 eax
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@CMJAMBAM@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@
  00142	6a 01		 push	 1
  00144	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00149	83 c4 10	 add	 esp, 16			; 00000010H

; 315  : 			this->SetState(iChaosCastleIndex, CC_STATE_NONE);

  0014c	6a 00		 push	 0
  0014e	56		 push	 esi
  0014f	8b cb		 mov	 ecx, ebx
  00151	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx

; 325  : }

  00159	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015c	33 cd		 xor	 ecx, ebp
  0015e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c2 04 00	 ret	 4
$LN2@CheckSync:

; 306  : 			break;
; 307  : 
; 308  : 		case 2:
; 309  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = ((((iMIN_HOUR+24) * 60 * 60) + (iMIN_MINUTE * 60)) - ((sysTime.wHour * 60 * 60) + (sysTime.wMinute * 60) + (sysTime.wSecond))) * 1000;

  00169	8b 4d e8	 mov	 ecx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  0016c	0f b7 55 f4	 movzx	 edx, WORD PTR _sysTime$[ebp+8]
  00170	69 c9 6c 08 00
	00		 imul	 ecx, 2156		; 0000086cH
  00176	03 d9		 add	 ebx, ecx
  00178	8b c6		 mov	 eax, esi
  0017a	2b c2		 sub	 eax, edx
  0017c	0f b7 55 f6	 movzx	 edx, WORD PTR _sysTime$[ebp+10]
  00180	83 c0 18	 add	 eax, 24			; 00000018H
  00183	8b c8		 mov	 ecx, eax
  00185	c1 e1 04	 shl	 ecx, 4
  00188	2b c8		 sub	 ecx, eax
  0018a	03 c9		 add	 ecx, ecx
  0018c	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  0018f	2b c2		 sub	 eax, edx
  00191	0f b7 55 f8	 movzx	 edx, WORD PTR _sysTime$[ebp+12]
  00195	03 c7		 add	 eax, edi
  00197	8b c8		 mov	 ecx, eax
  00199	c1 e1 04	 shl	 ecx, 4
  0019c	2b c8		 sub	 ecx, eax
  0019e	03 c9		 add	 ecx, ecx
  001a0	03 c9		 add	 ecx, ecx
  001a2	2b ca		 sub	 ecx, edx
  001a4	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  001aa	89 4b 40	 mov	 DWORD PTR [ebx+64], ecx

; 310  : 			break;

  001ad	eb 41		 jmp	 SHORT $LN4@CheckSync
$LN3@CheckSync:

; 303  : 	{
; 304  : 		case TRUE:
; 305  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = (((iMIN_HOUR * 60 * 60) + (iMIN_MINUTE * 60)) - ((sysTime.wHour * 60 * 60) + (sysTime.wMinute * 60) + (sysTime.wSecond))) * 1000;

  001af	8b 45 e8	 mov	 eax, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  001b2	0f b7 4d f4	 movzx	 ecx, WORD PTR _sysTime$[ebp+8]
  001b6	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  001bc	03 d8		 add	 ebx, eax
  001be	8b c6		 mov	 eax, esi
  001c0	2b c1		 sub	 eax, ecx
  001c2	0f b7 4d f6	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  001c6	8b d0		 mov	 edx, eax
  001c8	c1 e2 04	 shl	 edx, 4
  001cb	2b d0		 sub	 edx, eax
  001cd	03 d2		 add	 edx, edx
  001cf	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  001d2	2b c1		 sub	 eax, ecx
  001d4	03 c7		 add	 eax, edi
  001d6	8b d0		 mov	 edx, eax
  001d8	c1 e2 04	 shl	 edx, 4
  001db	2b d0		 sub	 edx, eax
  001dd	0f b7 45 f8	 movzx	 eax, WORD PTR _sysTime$[ebp+12]
  001e1	03 d2		 add	 edx, edx
  001e3	03 d2		 add	 edx, edx
  001e5	2b d0		 sub	 edx, eax
  001e7	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  001ed	89 53 40	 mov	 DWORD PTR [ebx+64], edx
$LN4@CheckSync:

; 316  : 			return;
; 317  : 
; 318  : 	}
; 319  : 
; 320  : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  001f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001f6	89 43 44	 mov	 DWORD PTR [ebx+68], eax

; 321  : 
; 322  : 	LogAdd(LOG_BLACK, "[Chaos Castle] (%d) Sync Start Time. [%d] min remain (START HOUR:%d, MIN:%d)",
; 323  : 		iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 60000,
; 324  : 		iMIN_HOUR, iMIN_MINUTE);

  001f9	8b 5b 40	 mov	 ebx, DWORD PTR [ebx+64]
  001fc	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  00201	f7 eb		 imul	 ebx
  00203	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00206	8b ca		 mov	 ecx, edx
  00208	57		 push	 edi
  00209	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0020c	03 ca		 add	 ecx, edx
  0020e	8b 55 e8	 mov	 edx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  00211	56		 push	 esi
  00212	51		 push	 ecx
  00213	42		 inc	 edx
  00214	52		 push	 edx
  00215	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@IGEPIJHA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Start?5T@
  0021a	6a 00		 push	 0
  0021c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00221	83 c4 18	 add	 esp, 24			; 00000018H
  00224	5f		 pop	 edi
$LN18@CheckSync:

; 325  : }

  00225	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00228	5e		 pop	 esi
  00229	33 cd		 xor	 ecx, ebp
  0022b	5b		 pop	 ebx
  0022c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00231	8b e5		 mov	 esp, ebp
  00233	5d		 pop	 ebp
  00234	c2 04 00	 ret	 4
?CheckSync@CChaosCastle@@IAEXH@Z ENDP			; CChaosCastle::CheckSync
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	_iChaosCastleIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ProcState_Closed@CChaosCastle@@IAEXH@Z		; CChaosCastle::ProcState_Closed
EXTRN	?g_bChaosCastle@@3HA:DWORD			; g_bChaosCastle
; Function compile flags: /Ogtp
;	COMDAT ?ProcState_Closed@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -288					; size = 4
_pMsg$157802 = -284					; size = 4
_iChaosCastleIndex$GSCopy$ = -280			; size = 4
_pNotice$157798 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcState_Closed@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::ProcState_Closed, COMDAT
; _this$ = ecx

; 334  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]

; 373  : 
; 374  : 					for (int i= OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  00016	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], eax
  0001c	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	8b d9		 mov	 ebx, ecx
  00026	57		 push	 edi
  00027	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  0002d	89 9d e0 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ebx
  00033	8d 34 18	 lea	 esi, DWORD PTR [eax+ebx]
  00036	ff d7		 call	 edi
  00038	2b 46 44	 sub	 eax, DWORD PTR [esi+68]
  0003b	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00040	0f 8c 5b 01 00
	00		 jl	 $LN32@ProcState_

; 335  : 	int iTICK_MSEC = GetTickCount() - this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT;
; 336  : 
; 337  : 	if ( iTICK_MSEC >= 1000 )
; 338  : 	{
; 339  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC -= iTICK_MSEC;
; 340  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  00046	29 46 40	 sub	 DWORD PTR [esi+64], eax
  00049	ff d7		 call	 edi
  0004b	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 341  : 
; 342  : 		if ( g_bChaosCastle != FALSE )

  0004e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bChaosCastle@@3HA, 0 ; g_bChaosCastle
  00055	0f 84 46 01 00
	00		 je	 $LN32@ProcState_

; 343  : 		{
; 344  : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= ( this->m_iCC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER == false)

  0005b	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0005e	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  00061	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  00067	3b c8		 cmp	 ecx, eax
  00069	7f 0c		 jg	 SHORT $LN14@ProcState_
  0006b	80 7e 4c 00	 cmp	 BYTE PTR [esi+76], 0
  0006f	75 06		 jne	 SHORT $LN14@ProcState_

; 345  : 			{
; 346  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER = true;

  00071	66 c7 46 4c 01
	01		 mov	 WORD PTR [esi+76], 257	; 00000101H
$LN14@ProcState_:

; 347  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_PARTY = true;
; 348  : 			}
; 349  : 
; 350  : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= ( this->m_iCC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC > 0 && (this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC/60000) !=this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_NOTIFY_COUNT)

  00077	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  0007a	69 d2 60 ea 00
	00		 imul	 edx, 60000		; 0000ea60H
  00080	3b ca		 cmp	 ecx, edx
  00082	7f 62		 jg	 SHORT $LN27@ProcState_
  00084	85 c9		 test	 ecx, ecx
  00086	7e 5e		 jle	 SHORT $LN27@ProcState_
  00088	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  0008d	f7 e9		 imul	 ecx
  0008f	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00092	8b c2		 mov	 eax, edx
  00094	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00097	03 c2		 add	 eax, edx
  00099	3b 46 48	 cmp	 eax, DWORD PTR [esi+72]
  0009c	74 48		 je	 SHORT $LN27@ProcState_

; 351  : 			{
; 352  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_NOTIFY_COUNT = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 60000;
; 353  : 
; 354  : 				if ( iChaosCastleIndex == 0 )

  0009e	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], 0
  000a5	89 46 48	 mov	 DWORD PTR [esi+72], eax
  000a8	75 3c		 jne	 SHORT $LN27@ProcState_

; 355  : 				{
; 356  : 					PMSG_NOTICE pNotice;
; 357  : 
; 358  : 					TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get( MSGGET(4, 208)), this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_NOTIFY_COUNT+1);

  000aa	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  000ad	40		 inc	 eax
  000ae	50		 push	 eax
  000af	68 d0 04 00 00	 push	 1232			; 000004d0H
  000b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000b9	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000be	50		 push	 eax
  000bf	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$157798[ebp]
  000c5	6a 00		 push	 0
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 359  : 					this->SendAllUserAnyMsg( (LPBYTE)&pNotice, pNotice.h.size);

  000cd	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$157798[ebp+1]
  000d4	83 c4 10	 add	 esp, 16			; 00000010H
  000d7	52		 push	 edx
  000d8	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$157798[ebp]
  000de	50		 push	 eax
  000df	8b cb		 mov	 ecx, ebx
  000e1	e8 00 00 00 00	 call	 ?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z ; CChaosCastle::SendAllUserAnyMsg
$LN27@ProcState_:

; 360  : 				}
; 361  : 			}
; 362  : 
; 363  : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 30000 && this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC > 0 && this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_ENTER == false )

  000e6	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  000e9	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  000ee	0f 8f ad 00 00
	00		 jg	 $LN32@ProcState_
  000f4	85 c0		 test	 eax, eax
  000f6	0f 8e a5 00 00
	00		 jle	 $LN32@ProcState_
  000fc	80 7e 4f 00	 cmp	 BYTE PTR [esi+79], 0
  00100	0f 85 9b 00 00
	00		 jne	 $LN32@ProcState_

; 364  : 			{
; 365  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_ENTER = true;
; 366  : 
; 367  : 				if ( iChaosCastleIndex == 0 )

  00106	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], 0
  0010d	c6 46 4f 01	 mov	 BYTE PTR [esi+79], 1
  00111	0f 85 8a 00 00
	00		 jne	 $LN32@ProcState_

; 368  : 				{
; 369  : 					PMSG_SET_DEVILSQUARE pMsg;
; 370  : 
; 371  : 					PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00117	6a 04		 push	 4
  00119	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$157802[ebp]
  0011f	68 92 00 00 00	 push	 146			; 00000092H
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 372  : 					pMsg.Type = 10;

  0012d	c6 85 e7 fe ff
	ff 0a		 mov	 BYTE PTR _pMsg$157802[ebp+3], 10 ; 0000000aH

; 373  : 
; 374  : 					for (int i= OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  00134	bb 00 19 00 00	 mov	 ebx, 6400		; 00001900H
  00139	bf 09 c5 16 02	 mov	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046665
  0013e	8b ff		 npad	 2
$LL9@ProcState_:

; 375  : 					{
; 376  : 						if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)

  00140	80 bf fb fe ff
	ff 03		 cmp	 BYTE PTR [edi-261], 3
  00147	75 43		 jne	 SHORT $LN8@ProcState_
  00149	66 83 bf 57 ff
	ff ff 01	 cmp	 WORD PTR [edi-169], 1
  00151	75 39		 jne	 SHORT $LN8@ProcState_

; 377  : 						{
; 378  : 							if ( CC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  00153	8a 0f		 mov	 cl, BYTE PTR [edi]
  00155	80 f9 12	 cmp	 cl, 18			; 00000012H
  00158	72 09		 jb	 SHORT $LN30@ProcState_
  0015a	b2 17		 mov	 dl, 23			; 00000017H
  0015c	3a d1		 cmp	 dl, cl
  0015e	1b c0		 sbb	 eax, eax
  00160	40		 inc	 eax
  00161	75 29		 jne	 SHORT $LN8@ProcState_
$LN30@ProcState_:

; 379  : 							{
; 380  : 								if ( BC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  00163	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00166	72 0c		 jb	 SHORT $LN26@ProcState_
  00168	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0016d	3a c1		 cmp	 al, cl
  0016f	1b c0		 sbb	 eax, eax
  00171	40		 inc	 eax
  00172	75 18		 jne	 SHORT $LN8@ProcState_
$LN26@ProcState_:

; 381  : 								{
; 382  : 									DataSend(i, (UCHAR*)&pMsg, pMsg.h.size);

  00174	0f b6 8d e5 fe
	ff ff		 movzx	 ecx, BYTE PTR _pMsg$157802[ebp+1]
  0017b	51		 push	 ecx
  0017c	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$157802[ebp]
  00182	52		 push	 edx
  00183	53		 push	 ebx
  00184	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00189	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@ProcState_:

; 373  : 
; 374  : 					for (int i= OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  0018c	81 c7 64 15 00
	00		 add	 edi, 5476		; 00001564H
  00192	43		 inc	 ebx
  00193	81 ff a9 53 6a
	02		 cmp	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522665
  00199	7c a5		 jl	 SHORT $LL9@ProcState_
  0019b	8b 9d e0 fe ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
$LN32@ProcState_:

; 383  : 								}
; 384  : 							}
; 385  : 						}
; 386  : 					}
; 387  : 				}
; 388  : 			}
; 389  : 		}
; 390  : 	}
; 391  : 
; 392  : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 0 )

  001a1	83 7e 40 00	 cmp	 DWORD PTR [esi+64], 0
  001a5	7f 24		 jg	 SHORT $LN1@ProcState_

; 393  : 	{
; 394  : 		if ( g_bChaosCastle != FALSE )

  001a7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bChaosCastle@@3HA, 0 ; g_bChaosCastle
  001ae	74 0b		 je	 SHORT $LN2@ProcState_

; 395  : 		{
; 396  : 			this->SetState(iChaosCastleIndex, CC_STATE_PLAYING);

  001b0	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  001b6	6a 02		 push	 2
  001b8	50		 push	 eax

; 397  : 		}
; 398  : 		else

  001b9	eb 09		 jmp	 SHORT $LN34@ProcState_
$LN2@ProcState_:

; 399  : 		{
; 400  : 			this->SetState(iChaosCastleIndex, CC_STATE_CLOSED);

  001bb	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  001c1	6a 01		 push	 1
  001c3	51		 push	 ecx
$LN34@ProcState_:
  001c4	8b cb		 mov	 ecx, ebx
  001c6	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
$LN1@ProcState_:

; 401  : 		}
; 402  : 	}
; 403  : }

  001cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ce	5f		 pop	 edi
  001cf	5e		 pop	 esi
  001d0	33 cd		 xor	 ecx, ebp
  001d2	5b		 pop	 ebx
  001d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d8	8b e5		 mov	 esp, ebp
  001da	5d		 pop	 ebp
  001db	c2 04 00	 ret	 4
?ProcState_Closed@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::ProcState_Closed
_TEXT	ENDS
PUBLIC	?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z	; CChaosCastle::ProcState_PlayEnd
; Function compile flags: /Ogtp
;	COMDAT ?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_pMsg$158337 = 8					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::ProcState_PlayEnd, COMDAT
; _this$ = ecx

; 806  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 807  : 	int iTICK_MSEC = GetTickCount() - this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	56		 push	 esi
  00008	8b f3		 mov	 esi, ebx
  0000a	69 f6 6c 08 00
	00		 imul	 esi, 2156		; 0000086cH
  00010	57		 push	 edi
  00011	8b f9		 mov	 edi, ecx
  00013	03 f7		 add	 esi, edi
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0001b	2b 46 44	 sub	 eax, DWORD PTR [esi+68]

; 808  : 
; 809  : 	if ( iTICK_MSEC >= 1000 )

  0001e	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00023	7c 51		 jl	 SHORT $LN6@ProcState_@2

; 810  : 	{
; 811  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC -= iTICK_MSEC;

  00025	29 46 40	 sub	 DWORD PTR [esi+64], eax

; 812  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 813  : 		this->CheckUserInDieTile(iChaosCastleIndex);

  0002e	53		 push	 ebx
  0002f	8b cf		 mov	 ecx, edi
  00031	89 46 44	 mov	 DWORD PTR [esi+68], eax
  00034	e8 00 00 00 00	 call	 ?CheckUserInDieTile@CChaosCastle@@QAEXH@Z ; CChaosCastle::CheckUserInDieTile

; 814  : 
; 815  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 30000 && this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC > 0 && this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_QUIT == false)

  00039	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0003c	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00041	7f 33		 jg	 SHORT $LN6@ProcState_@2
  00043	85 c0		 test	 eax, eax
  00045	7e 2f		 jle	 SHORT $LN6@ProcState_@2
  00047	80 7e 52 00	 cmp	 BYTE PTR [esi+82], 0
  0004b	75 29		 jne	 SHORT $LN6@ProcState_@2

; 816  : 		{
; 817  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_QUIT = true;
; 818  : 
; 819  : 			PMSG_SET_DEVILSQUARE pMsg;
; 820  : 
; 821  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  0004d	6a 04		 push	 4
  0004f	8d 4d 08	 lea	 ecx, DWORD PTR _pMsg$158337[ebp]
  00052	68 92 00 00 00	 push	 146			; 00000092H
  00057	51		 push	 ecx
  00058	c6 46 52 01	 mov	 BYTE PTR [esi+82], 1
  0005c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 822  : 			pMsg.Type = 13;
; 823  : 
; 824  : 			this->SendChaosCastleAnyMsg((BYTE *)&pMsg, sizeof(pMsg), iChaosCastleIndex);

  00064	53		 push	 ebx
  00065	6a 04		 push	 4
  00067	8d 55 08	 lea	 edx, DWORD PTR _pMsg$158337[ebp]
  0006a	52		 push	 edx
  0006b	8b cf		 mov	 ecx, edi
  0006d	c6 45 0b 0d	 mov	 BYTE PTR _pMsg$158337[ebp+3], 13 ; 0000000dH
  00071	e8 00 00 00 00	 call	 ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg
$LN6@ProcState_@2:

; 825  : 		}
; 826  : 
; 827  : 
; 828  : 	}
; 829  : 
; 830  : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 0 )

  00076	83 7e 40 00	 cmp	 DWORD PTR [esi+64], 0
  0007a	7f 0a		 jg	 SHORT $LN1@ProcState_@2

; 831  : 	{
; 832  : 		this->SetState(iChaosCastleIndex, CC_STATE_CLOSED);

  0007c	6a 01		 push	 1
  0007e	53		 push	 ebx
  0007f	8b cf		 mov	 ecx, edi
  00081	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
$LN1@ProcState_@2:
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx

; 833  : 	}
; 834  : }

  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::ProcState_PlayEnd
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetRemainTime@CChaosCastle@@QAEHH@Z		; CChaosCastle::GetRemainTime
; Function compile flags: /Ogtp
;	COMDAT ?GetRemainTime@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
tv462 = -36						; size = 4
tv477 = -32						; size = 4
tv465 = -28						; size = 4
_bTIME_CHANGED$159508 = -24				; size = 4
_sysTime$159505 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetRemainTime@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetRemainTime, COMDAT
; _this$ = ecx

; 2013 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 2014 : 	int iREMAIN_MINUTE = 0;
; 2015 : 
; 2016 : 	if ( this->GetCurrentState(iChaosCastleIndex) == 1 )

  00012	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  00015	57		 push	 edi
  00016	8b f1		 mov	 esi, ecx
  00018	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 24		 jne	 SHORT $LN18@GetRemainT

; 2017 : 	{
; 2018 : 		iREMAIN_MINUTE = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 60000 - this->m_iCC_TIME_MIN_OPEN + 1;

  00022	69 ff 6c 08 00
	00		 imul	 edi, 2156		; 0000086cH
  00028	8b 7c 37 40	 mov	 edi, DWORD PTR [edi+esi+64]
  0002c	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  00031	f7 ef		 imul	 edi
  00033	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00036	8b c2		 mov	 eax, edx
  00038	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003b	03 c2		 add	 eax, edx
  0003d	2b 46 08	 sub	 eax, DWORD PTR [esi+8]
  00040	40		 inc	 eax

; 2019 : 	}
; 2020 : 	else

  00041	e9 14 01 00 00	 jmp	 $LN5@GetRemainT
$LN18@GetRemainT:
  00046	53		 push	 ebx

; 2021 : 	{
; 2022 : 		SYSTEMTIME sysTime;
; 2023 : 		GetLocalTime(&sysTime);

  00047	8d 4d ec	 lea	 ecx, DWORD PTR _sysTime$159505[ebp]
  0004a	51		 push	 ecx
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 2024 : 		int iMIN_HOUR = 24;
; 2025 : 		int iMIN_MINUTE = 60;
; 2026 : 		BOOL bTIME_CHANGED = FALSE;
; 2027 : 		std::vector<CHAOSCASTLE_START_TIME>::iterator it;
; 2028 : 
; 2029 : 		for( it = this->m_vtChaosCastleOpenTime.begin();  it != this->m_vtChaosCastleOpenTime.end(); it++)

  00051	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00054	8b 76 24	 mov	 esi, DWORD PTR [esi+36]
  00057	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0005c	8d 48 24	 lea	 ecx, DWORD PTR [eax+36]
  0005f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$159508[ebp], 0
  00066	89 55 dc	 mov	 DWORD PTR tv462[ebp], edx
  00069	89 75 e4	 mov	 DWORD PTR tv465[ebp], esi
  0006c	3b d6		 cmp	 edx, esi
  0006e	74 56		 je	 SHORT $LN99@GetRemainT

; 2040 : 				}
; 2041 : 			}
; 2042 : 		}
; 2043 : 
; 2044 : 		
; 2045 : 					
; 2046 : 		if ( bTIME_CHANGED == 0 )

  00070	0f b7 75 f4	 movzx	 esi, WORD PTR _sysTime$159505[ebp+8]
  00074	8b fe		 mov	 edi, esi
  00076	c1 e7 04	 shl	 edi, 4
  00079	2b fe		 sub	 edi, esi
  0007b	0f b7 75 f6	 movzx	 esi, WORD PTR _sysTime$159505[ebp+10]
  0007f	8d 34 be	 lea	 esi, DWORD PTR [esi+edi*4]
  00082	89 75 e0	 mov	 DWORD PTR tv477[ebp], esi
$LL37@GetRemainT:

; 2030 : 		{
; 2031 : 			CHAOSCASTLE_START_TIME & pRET = *it;
; 2032 : 			
; 2033 : 			if ( (sysTime.wHour * 60 + sysTime.wMinute) < (pRET.m_iHour * 60 + pRET.m_iMinute))

  00085	8b 32		 mov	 esi, DWORD PTR [edx]
  00087	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0008a	8b de		 mov	 ebx, esi
  0008c	c1 e3 04	 shl	 ebx, 4
  0008f	2b de		 sub	 ebx, esi
  00091	8d 3c 9f	 lea	 edi, DWORD PTR [edi+ebx*4]
  00094	39 7d e0	 cmp	 DWORD PTR tv477[ebp], edi
  00097	7d 1a		 jge	 SHORT $LN15@GetRemainT

; 2034 : 			{
; 2035 : 				if ( (iMIN_HOUR * 60 + iMIN_MINUTE) > (pRET.m_iHour * 60 + pRET.m_iMinute))

  00099	8b d8		 mov	 ebx, eax
  0009b	c1 e3 04	 shl	 ebx, 4
  0009e	2b d8		 sub	 ebx, eax
  000a0	8d 1c 99	 lea	 ebx, DWORD PTR [ecx+ebx*4]
  000a3	3b df		 cmp	 ebx, edi
  000a5	7e 0c		 jle	 SHORT $LN15@GetRemainT

; 2036 : 				{
; 2037 : 					bTIME_CHANGED = 1;
; 2038 : 					iMIN_HOUR = pRET.m_iHour;
; 2039 : 					iMIN_MINUTE = pRET.m_iMinute;

  000a7	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000aa	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$159508[ebp], 1
  000b1	8b c6		 mov	 eax, esi
$LN15@GetRemainT:

; 2024 : 		int iMIN_HOUR = 24;
; 2025 : 		int iMIN_MINUTE = 60;
; 2026 : 		BOOL bTIME_CHANGED = FALSE;
; 2027 : 		std::vector<CHAOSCASTLE_START_TIME>::iterator it;
; 2028 : 
; 2029 : 		for( it = this->m_vtChaosCastleOpenTime.begin();  it != this->m_vtChaosCastleOpenTime.end(); it++)

  000b3	8b 75 e4	 mov	 esi, DWORD PTR tv465[ebp]
  000b6	83 c2 08	 add	 edx, 8
  000b9	3b d6		 cmp	 edx, esi
  000bb	75 c8		 jne	 SHORT $LL37@GetRemainT

; 2040 : 				}
; 2041 : 			}
; 2042 : 		}
; 2043 : 
; 2044 : 		
; 2045 : 					
; 2046 : 		if ( bTIME_CHANGED == 0 )

  000bd	83 7d e8 00	 cmp	 DWORD PTR _bTIME_CHANGED$159508[ebp], 0
  000c1	75 42		 jne	 SHORT $LN104@GetRemainT
  000c3	8b 55 dc	 mov	 edx, DWORD PTR tv462[ebp]
$LN99@GetRemainT:

; 2047 : 		{
; 2048 : 			it = this->m_vtChaosCastleOpenTime.begin();

  000c6	8b fa		 mov	 edi, edx

; 2049 : 			iMIN_HOUR = 24;

  000c8	b8 18 00 00 00	 mov	 eax, 24			; 00000018H

; 2050 : 			iMIN_MINUTE = 60;

  000cd	8d 48 24	 lea	 ecx, DWORD PTR [eax+36]

; 2051 : 
; 2052 : 			for( ;  it != this->m_vtChaosCastleOpenTime.end(); it++)

  000d0	3b fe		 cmp	 edi, esi
  000d2	74 31		 je	 SHORT $LN104@GetRemainT
$LL72@GetRemainT:

; 2053 : 			{
; 2054 : 				CHAOSCASTLE_START_TIME & pRET = *it;
; 2055 : 			
; 2056 : 				if ( (iMIN_HOUR * 60 + iMIN_MINUTE) > (pRET.m_iHour * 60 + pRET.m_iMinute))

  000d4	8b 17		 mov	 edx, DWORD PTR [edi]
  000d6	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  000d9	8b da		 mov	 ebx, edx
  000db	c1 e3 04	 shl	 ebx, 4
  000de	2b da		 sub	 ebx, edx
  000e0	8d 34 9e	 lea	 esi, DWORD PTR [esi+ebx*4]
  000e3	8b d8		 mov	 ebx, eax
  000e5	c1 e3 04	 shl	 ebx, 4
  000e8	2b d8		 sub	 ebx, eax
  000ea	8d 1c 99	 lea	 ebx, DWORD PTR [ecx+ebx*4]
  000ed	3b de		 cmp	 ebx, esi
  000ef	7e 0c		 jle	 SHORT $LN9@GetRemainT

; 2057 : 				{
; 2058 : 					bTIME_CHANGED = 2;
; 2059 : 					iMIN_HOUR = pRET.m_iHour;
; 2060 : 					iMIN_MINUTE = pRET.m_iMinute;

  000f1	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000f4	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$159508[ebp], 2
  000fb	8b c2		 mov	 eax, edx
$LN9@GetRemainT:

; 2051 : 
; 2052 : 			for( ;  it != this->m_vtChaosCastleOpenTime.end(); it++)

  000fd	83 c7 08	 add	 edi, 8
  00100	3b 7d e4	 cmp	 edi, DWORD PTR tv465[ebp]
  00103	75 cf		 jne	 SHORT $LL72@GetRemainT
$LN104@GetRemainT:

; 2061 : 				}
; 2062 : 			}
; 2063 : 		}
; 2064 : 
; 2065 : 		switch ( bTIME_CHANGED )

  00105	8b 55 e8	 mov	 edx, DWORD PTR _bTIME_CHANGED$159508[ebp]
  00108	4a		 dec	 edx
  00109	5b		 pop	 ebx
  0010a	74 0e		 je	 SHORT $LN4@GetRemainT
  0010c	4a		 dec	 edx
  0010d	75 4f		 jne	 SHORT $LN105@GetRemainT

; 2069 : 				break;
; 2070 : 			case 2:
; 2071 : 				iREMAIN_MINUTE = ((((iMIN_HOUR + 24) * 60 * 60 + iMIN_MINUTE * 60) - (sysTime.wHour * 60 * 60 + sysTime.wMinute * 60 + sysTime.wSecond)) ) / 60 + 1;

  0010f	0f b7 55 f4	 movzx	 edx, WORD PTR _sysTime$159505[ebp+8]
  00113	2b c2		 sub	 eax, edx
  00115	83 c0 18	 add	 eax, 24			; 00000018H

; 2072 : 				break;

  00118	eb 06		 jmp	 SHORT $LN106@GetRemainT
$LN4@GetRemainT:

; 2066 : 		{
; 2067 : 			case 1:
; 2068 : 				iREMAIN_MINUTE = (((iMIN_HOUR * 60 * 60 + iMIN_MINUTE * 60) - (sysTime.wHour * 60 * 60 + sysTime.wMinute * 60 + sysTime.wSecond))) /60 + 1;

  0011a	0f b7 55 f4	 movzx	 edx, WORD PTR _sysTime$159505[ebp+8]
  0011e	2b c2		 sub	 eax, edx
$LN106@GetRemainT:
  00120	8b d0		 mov	 edx, eax
  00122	c1 e2 04	 shl	 edx, 4
  00125	2b d0		 sub	 edx, eax
  00127	03 d2		 add	 edx, edx
  00129	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  0012c	0f b7 55 f6	 movzx	 edx, WORD PTR _sysTime$159505[ebp+10]
  00130	2b c2		 sub	 eax, edx
  00132	0f b7 55 f8	 movzx	 edx, WORD PTR _sysTime$159505[ebp+12]
  00136	03 c1		 add	 eax, ecx
  00138	8b c8		 mov	 ecx, eax
  0013a	c1 e1 04	 shl	 ecx, 4
  0013d	2b c8		 sub	 ecx, eax
  0013f	03 c9		 add	 ecx, ecx
  00141	03 c9		 add	 ecx, ecx
  00143	2b ca		 sub	 ecx, edx
  00145	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0014a	f7 e9		 imul	 ecx
  0014c	03 d1		 add	 edx, ecx
  0014e	c1 fa 05	 sar	 edx, 5
  00151	8b c2		 mov	 eax, edx
  00153	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00156	8d 44 02 01	 lea	 eax, DWORD PTR [edx+eax+1]
$LN5@GetRemainT:

; 2073 : 			default:
; 2074 : 				iREMAIN_MINUTE = -1;
; 2075 : 				break;
; 2076 : 		}
; 2077 : 	}
; 2078 : 
; 2079 : 	if ( iREMAIN_MINUTE < 0 )

  0015a	85 c0		 test	 eax, eax
  0015c	79 02		 jns	 SHORT $LN1@GetRemainT
$LN105@GetRemainT:

; 2080 : 		iREMAIN_MINUTE = 0;

  0015e	33 c0		 xor	 eax, eax
$LN1@GetRemainT:

; 2081 : 
; 2082 : 	return iREMAIN_MINUTE;
; 2083 : }

  00160	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00163	5f		 pop	 edi
  00164	33 cd		 xor	 ecx, ebp
  00166	5e		 pop	 esi
  00167	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c2 04 00	 ret	 4
?GetRemainTime@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetRemainTime
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (iterator(this->_Myhead, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 818  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00005	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00008	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0000b	80 7b 19 00	 cmp	 BYTE PTR [ebx+25], 0
  0000f	8b f3		 mov	 esi, ebx
  00011	75 1e		 jne	 SHORT $LN7@clear
$LL9@clear:
  00013	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00016	51		 push	 ecx
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase
  0001e	8b 36		 mov	 esi, DWORD PTR [esi]
  00020	53		 push	 ebx
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
  00029	80 7e 19 00	 cmp	 BYTE PTR [esi+25], 0
  0002d	8b de		 mov	 ebx, esi
  0002f	74 e2		 je	 SHORT $LL9@clear
$LN7@clear:

; 1416 : 		_Root() = this->_Myhead;

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00037	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003a	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  0003c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1419 : 		this->_Mysize = 0;

  00042	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 1420 : 		}

  0004c	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::clear
_TEXT	ENDS
PUBLIC	?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ
_TEXT	SEGMENT
?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::back, COMDAT
; _this$ = ecx

; 967  : 		return (*(end() - 1));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e8 08	 sub	 eax, 8

; 968  : 		}

  00006	c3		 ret	 0
?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::back
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@2
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@2:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z
_TEXT	SEGMENT
$T168083 = -16						; size = 12
$T168024 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 1c		 push	 28			; 0000001cH
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN20@Tree
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 18	 mov	 BYTE PTR [ecx+24], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 19	 mov	 BYTE PTR [edx+25], al

; 699  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 698  : 		{	// construct empty tree

$LN20@Tree:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T168024[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T168083[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T168024[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T168083[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T168083[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@Tree:
$LN42@Tree:
  0006e	cc		 int	 3
??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::lower_bound
; Function compile flags: /Ogtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  0000d	75 19		 jne	 SHORT $LN36@lower_boun
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL6@lower_boun:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	7d 05		 jge	 SHORT $LN4@lower_boun
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN4@lower_boun:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun:
  00022	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00026	74 ec		 je	 SHORT $LL6@lower_boun
$LN36@lower_boun:
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1292 : 		if (max_size() - _Count < _Size)

  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000c	57		 push	 edi
  0000d	2b c6		 sub	 eax, esi
  0000f	bf ff ff ff 3f	 mov	 edi, 1073741823		; 3fffffffH
  00014	c1 f8 02	 sar	 eax, 2
  00017	2b fa		 sub	 edi, edx
  00019	3b f8		 cmp	 edi, eax
  0001b	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00022	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	03 c2		 add	 eax, edx
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	2b d6		 sub	 edx, esi
  0002e	c1 fa 02	 sar	 edx, 2
  00031	3b c2		 cmp	 eax, edx
  00033	76 21		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00035	8b f2		 mov	 esi, edx
  00037	d1 ee		 shr	 esi, 1
  00039	bf ff ff ff 3f	 mov	 edi, 1073741823		; 3fffffffH
  0003e	2b fe		 sub	 edi, esi
  00040	3b fa		 cmp	 edi, edx
  00042	73 04		 jae	 SHORT $LN23@Reserve
  00044	33 d2		 xor	 edx, edx
  00046	eb 02		 jmp	 SHORT $LN24@Reserve
$LN23@Reserve:
  00048	03 d6		 add	 edx, esi
$LN24@Reserve:
  0004a	3b d0		 cmp	 edx, eax
  0004c	73 02		 jae	 SHORT $LN20@Reserve
  0004e	8b d0		 mov	 edx, eax
$LN20@Reserve:
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve
$LN1@Reserve:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1298 : 		}

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN33@Reserve:
?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Reserve
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T168268 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00012	75 1c		 jne	 SHORT $LN97@erase@2
  00014	3b d0		 cmp	 edx, eax
  00016	75 18		 jne	 SHORT $LN97@erase@2

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::clear

; 1383 : 			return (begin());

  0001f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1389 : 			return (iterator(_First._Ptr, this));

  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00027	89 08		 mov	 DWORD PTR [eax], ecx
  00029	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
$LN97@erase@2:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  00030	3b ca		 cmp	 ecx, edx
  00032	74 5e		 je	 SHORT $LN1@erase@2
$LL2@erase@2:

; 1388 : 				erase(_First++);

  00034	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00038	8b d1		 mov	 edx, ecx
  0003a	75 42		 jne	 SHORT $LN59@erase@2
  0003c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0003f	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00043	75 1a		 jne	 SHORT $LN99@erase@2
  00045	8b c8		 mov	 ecx, eax
  00047	8b 01		 mov	 eax, DWORD PTR [ecx]
  00049	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  0004d	75 0b		 jne	 SHORT $LN73@erase@2
  0004f	90		 npad	 1
$LL74@erase@2:
  00050	8b c8		 mov	 ecx, eax
  00052	8b 01		 mov	 eax, DWORD PTR [ecx]
  00054	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00058	74 f6		 je	 SHORT $LL74@erase@2
$LN73@erase@2:
  0005a	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  0005d	eb 1f		 jmp	 SHORT $LN59@erase@2
$LN99@erase@2:
  0005f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00062	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00066	75 13		 jne	 SHORT $LN57@erase@2
$LL58@erase@2:
  00068	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0006b	75 0e		 jne	 SHORT $LN57@erase@2
  0006d	8b c8		 mov	 ecx, eax
  0006f	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00079	74 ed		 je	 SHORT $LL58@erase@2
$LN57@erase@2:
  0007b	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
$LN59@erase@2:
  0007e	52		 push	 edx
  0007f	8d 55 fc	 lea	 edx, DWORD PTR $T168268[ebp]
  00082	52		 push	 edx
  00083	8b ce		 mov	 ecx, esi
  00085	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
  0008a	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  0008d	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00090	75 a2		 jne	 SHORT $LL2@erase@2
$LN1@erase@2:

; 1389 : 			return (iterator(_First._Ptr, this));

  00092	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Destroy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
$T168620 = 16						; size = 4
$T168618 = 16						; size = 4
__Where$162166 = 16					; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();
; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0000d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00010	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx
  00017	b1 01		 mov	 cl, 1
  00019	57		 push	 edi
  0001a	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 2d		 jne	 SHORT $LN11@Linsert
  0001f	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
$LL12@Linsert:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Leftish$[ebp], 0
  00026	8b f0		 mov	 esi, eax
  00028	74 08		 je	 SHORT $LN10@Linsert

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0002a	39 78 0c	 cmp	 DWORD PTR [eax+12], edi
  0002d	0f 9d c1	 setge	 cl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00030	eb 06		 jmp	 SHORT $LN146@Linsert
$LN10@Linsert:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00032	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  00035	0f 9c c1	 setl	 cl
$LN146@Linsert:
  00038	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0003b	84 c9		 test	 cl, cl
  0003d	74 04		 je	 SHORT $LN15@Linsert
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 03		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert:

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();
; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00046	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  0004a	74 d6		 je	 SHORT $LL12@Linsert
$LN11@Linsert:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  0004c	8b fe		 mov	 edi, esi
  0004e	89 7d 10	 mov	 DWORD PTR __Where$162166[ebp], edi

; 970  : 			if (!_Addleft)

  00051	84 c9		 test	 cl, cl
  00053	74 35		 je	 SHORT $LN99@Linsert

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00055	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00058	8d 4d 10	 lea	 ecx, DWORD PTR $T168618[ebp]
  0005b	3b 30		 cmp	 esi, DWORD PTR [eax]
  0005d	75 20		 jne	 SHORT $LN4@Linsert
  0005f	52		 push	 edx
  00060	56		 push	 esi
  00061	6a 01		 push	 1
  00063	51		 push	 ecx
  00064	8b cb		 mov	 ecx, ebx
  00066	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert
  0006b	8b 10		 mov	 edx, DWORD PTR [eax]
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	89 10		 mov	 DWORD PTR [eax], edx
  00074	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  00078	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@Linsert:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  0007f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--
  00084	8b 7d 10	 mov	 edi, DWORD PTR __Where$162166[ebp]
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  0008a	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  0008d	52		 push	 edx
  0008e	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  00091	7d 24		 jge	 SHORT $LN2@Linsert
  00093	8b 4d fc	 mov	 ecx, DWORD PTR __Addleft$[ebp]
  00096	56		 push	 esi
  00097	51		 push	 ecx
  00098	8d 55 10	 lea	 edx, DWORD PTR $T168620[ebp]
  0009b	52		 push	 edx
  0009c	8b cb		 mov	 ecx, ebx
  0009e	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert
  000a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	89 08		 mov	 DWORD PTR [eax], ecx
  000ac	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000b0	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Linsert:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));
; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000b7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000bc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000bf	83 c4 04	 add	 esp, 4
  000c2	89 38		 mov	 DWORD PTR [eax], edi
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000ca	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
$T168991 = -12						; size = 12
$T168943 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  00008	6a 1c		 push	 28			; 0000001cH
  0000a	8b f9		 mov	 edi, ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	8b f0		 mov	 esi, eax
  00013	33 c0		 xor	 eax, eax
  00015	83 c4 04	 add	 esp, 4
  00018	3b f0		 cmp	 esi, eax
  0001a	74 33		 je	 SHORT $LN12@Buynode@2
  0001c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0001f	89 0e		 mov	 DWORD PTR [esi], ecx
  00021	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00024	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00027	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  0002a	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0002d	66 89 46 18	 mov	 WORD PTR [esi+24], ax
  00031	52		 push	 edx
  00032	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00035	50		 push	 eax
  00036	83 c7 0d	 add	 edi, 13			; 0000000dH
  00039	57		 push	 edi
  0003a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0003d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP>,std::pair<int,_MONSTER_ITEM_DROP> >
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	5f		 pop	 edi

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);
; 595  : 		_RERAISE;
; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi

; 599  : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@2:
  0004f	8d 4d 08	 lea	 ecx, DWORD PTR $T168943[ebp]
  00052	51		 push	 ecx
  00053	8d 4d f4	 lea	 ecx, DWORD PTR $T168991[ebp]
  00056	89 45 08	 mov	 DWORD PTR $T168943[ebp], eax
  00059	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0005e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00063	8d 55 f4	 lea	 edx, DWORD PTR $T168991[ebp]
  00066	52		 push	 edx
  00067	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T168991[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0006e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN44@Buynode@2:
$LN43@Buynode@2:
  00073	cc		 int	 3
??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ; std::_Uninitialized_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z
_TEXT	SEGMENT
__Cat$169035 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z PROC ; std::_Uninitialized_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$169035[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ENDP ; std::_Uninitialized_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@@Z ; std::_Uninitialized_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Uninitialized_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@@Z
_TEXT	SEGMENT
__Cat$169045 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@@Z PROC ; std::_Uninitialized_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$169045[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@@Z ENDP ; std::_Uninitialized_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	?Clear@_CHAOSCASTLE_DATA@@QAEXXZ		; _CHAOSCASTLE_DATA::Clear
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.h
;	COMDAT ?Clear@_CHAOSCASTLE_DATA@@QAEXXZ
_TEXT	SEGMENT
$T169097 = -4						; size = 4
?Clear@_CHAOSCASTLE_DATA@@QAEXXZ PROC			; _CHAOSCASTLE_DATA::Clear, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b d1		 mov	 edx, ecx
  00006	53		 push	 ebx

; 189  : 		this->m_iMISSION_SUCCESS = -1;
; 190  : 		this->m_iCC_NOTIFY_COUNT = -1;
; 191  : 		this->m_bCC_MSG_BEFORE_ENTER = false;

  00007	33 db		 xor	 ebx, ebx
  00009	83 c8 ff	 or	 eax, -1
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00011	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00014	89 5a 1f	 mov	 DWORD PTR [edx+31], ebx

; 192  : 		this->m_bCC_MSG_BEFORE_PLAY = false;
; 193  : 		this->m_bCC_MSG_BEFORE_END = false;
; 194  : 		this->m_bCC_MSG_BEFORE_QUIT = false;
; 195  : 		this->m_bCC_CAN_ENTER = false;

  00017	66 89 5a 1c	 mov	 WORD PTR [edx+28], bx

; 196  : 		this->m_bCC_CAN_PARTY = false;
; 197  : 		this->m_bCC_PLAY_START = false;

  0001b	88 5a 1e	 mov	 BYTE PTR [edx+30], bl

; 198  : 		this->m_iCC_ENTERED_USER = 0;

  0001e	89 5a 24	 mov	 DWORD PTR [edx+36], ebx

; 199  : 		this->m_iCC_FIRST_USER_COUNT = 0;

  00021	89 5a 28	 mov	 DWORD PTR [edx+40], ebx

; 200  : 		this->m_iCC_FIRST_MONSTER_COUNT = 0;

  00024	89 5a 2c	 mov	 DWORD PTR [edx+44], ebx

; 201  : 		this->m_lCC_CURRENT_MONSTER_COUNT = 0;

  00027	89 5a 30	 mov	 DWORD PTR [edx+48], ebx

; 202  : 		this->m_iCC_TRAP_STATUS = 0;

  0002a	89 5a 34	 mov	 DWORD PTR [edx+52], ebx

; 203  : 		this->m_iCC_TRAP_OLD_STATUS = 0;

  0002d	89 5a 38	 mov	 DWORD PTR [edx+56], ebx
  00030	8d ba b4 05 00
	00		 lea	 edi, DWORD PTR [edx+1460]

; 204  : 
; 205  : 		for ( int iMON = 0;iMON < MAX_CHAOSCASTLE_MONSTER ; iMON++)
; 206  : 		{
; 207  : 			this->m_lCC_MONSTER_COUNT[iMON] = -1;

  00036	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0003b	f3 ab		 rep stosd

; 208  : 		}
; 209  : 
; 210  : 		for ( int iFALL = 0; iFALL < MAX_CHAOSCASTLE_USER ; iFALL ++)

  0003d	8d ba 44 07 00
	00		 lea	 edi, DWORD PTR [edx+1860]

; 211  : 		{
; 212  : 			this->m_lFallUser[iFALL] = -1;

  00043	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00048	f3 ab		 rep stosd

; 213  : 		}
; 214  : 
; 215  : 		this->m_mapMonsterItemList.clear();

  0004a	8b 82 60 08 00
	00		 mov	 eax, DWORD PTR [edx+2144]
  00050	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00053	8d ba 5c 08 00
	00		 lea	 edi, DWORD PTR [edx+2140]
  00059	89 75 fc	 mov	 DWORD PTR $T169097[ebp], esi
  0005c	38 5e 19	 cmp	 BYTE PTR [esi+25], bl
  0005f	75 21		 jne	 SHORT $LN15@Clear
$LL17@Clear:
  00061	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00064	51		 push	 ecx
  00065	8b cf		 mov	 ecx, edi
  00067	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase
  0006c	8b 55 fc	 mov	 edx, DWORD PTR $T169097[ebp]
  0006f	8b 36		 mov	 esi, DWORD PTR [esi]
  00071	52		 push	 edx
  00072	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00077	83 c4 04	 add	 esp, 4
  0007a	89 75 fc	 mov	 DWORD PTR $T169097[ebp], esi
  0007d	38 5e 19	 cmp	 BYTE PTR [esi+25], bl
  00080	74 df		 je	 SHORT $LL17@Clear
$LN15@Clear:
  00082	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00085	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00088	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008b	89 00		 mov	 DWORD PTR [eax], eax
  0008d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00090	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00093	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx

; 216  : 	};	// line : 408

  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
?Clear@_CHAOSCASTLE_DATA@@QAEXXZ ENDP			; _CHAOSCASTLE_DATA::Clear
_TEXT	ENDS
PUBLIC	?ClearChaosCastleData@CChaosCastle@@IAEXH@Z	; CChaosCastle::ClearChaosCastleData
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
;	COMDAT ?ClearChaosCastleData@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?ClearChaosCastleData@CChaosCastle@@IAEXH@Z PROC	; CChaosCastle::ClearChaosCastleData, COMDAT
; _this$ = ecx

; 949  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 950  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	53		 push	 ebx
  00007	33 db		 xor	 ebx, ebx
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	3b c3		 cmp	 eax, ebx
  0000e	0f 8c 10 02 00
	00		 jl	 $LN14@ClearChaos
  00014	33 c9		 xor	 ecx, ecx
  00016	83 f8 05	 cmp	 eax, 5
  00019	0f 9e c1	 setle	 cl
  0001c	3b cb		 cmp	 ecx, ebx
  0001e	0f 84 00 02 00
	00		 je	 $LN14@ClearChaos

; 951  : 	{
; 952  : 		return;
; 953  : 	}
; 954  : 
; 955  : 	this->m_stChaosCastleData[iChaosCastleIndex].Clear();

  00024	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  0002a	03 f0		 add	 esi, eax
  0002c	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  0002f	e8 00 00 00 00	 call	 ?Clear@_CHAOSCASTLE_DATA@@QAEXXZ ; _CHAOSCASTLE_DATA::Clear
  00034	8d 46 74	 lea	 eax, DWORD PTR [esi+116]
  00037	8d 53 0e	 lea	 edx, DWORD PTR [ebx+14]
  0003a	83 c9 ff	 or	 ecx, -1
  0003d	8d 49 00	 npad	 3
$LL4@ClearChaos:

; 956  : 
; 957  : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++ )
; 958  : 	{
; 959  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00040	39 48 f8	 cmp	 DWORD PTR [eax-8], ecx
  00043	74 4b		 je	 SHORT $LN1@ClearChaos

; 960  : 		{
; 961  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex = -1;

  00045	8b 70 f8	 mov	 esi, DWORD PTR [eax-8]
  00048	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0004e	88 8e 09 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3337], cl

; 962  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex = -1;

  00054	8b 70 f8	 mov	 esi, DWORD PTR [eax-8]
  00057	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0005d	88 8e 0a 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3338], cl

; 963  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = 0;

  00063	8b 70 f8	 mov	 esi, DWORD PTR [eax-8]
  00066	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0006c	89 9e 0c 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3340], ebx

; 964  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillUserCount = 0;

  00072	8b 70 f8	 mov	 esi, DWORD PTR [eax-8]
  00075	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0007b	88 9e 10 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3344], bl

; 965  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillMonsterCount = 0;

  00081	8b 70 f8	 mov	 esi, DWORD PTR [eax-8]
  00084	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0008a	88 9e 11 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3345], bl
$LN1@ClearChaos:

; 966  : 		}
; 967  : 
; 968  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].Clear();

  00090	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  00093	89 58 fc	 mov	 DWORD PTR [eax-4], ebx
  00096	89 18		 mov	 DWORD PTR [eax], ebx
  00098	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  0009b	88 58 08	 mov	 BYTE PTR [eax+8], bl
  0009e	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  000a1	74 4b		 je	 SHORT $LN15@ClearChaos

; 960  : 		{
; 961  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex = -1;

  000a3	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  000a6	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000ac	88 8e 09 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3337], cl

; 962  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex = -1;

  000b2	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  000b5	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000bb	88 8e 0a 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3338], cl

; 963  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = 0;

  000c1	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  000c4	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000ca	89 9e 0c 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3340], ebx

; 964  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillUserCount = 0;

  000d0	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  000d3	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000d9	88 9e 10 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3344], bl

; 965  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillMonsterCount = 0;

  000df	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  000e2	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000e8	88 9e 11 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3345], bl
$LN15@ClearChaos:

; 966  : 		}
; 967  : 
; 968  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].Clear();

  000ee	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  000f1	89 58 10	 mov	 DWORD PTR [eax+16], ebx
  000f4	89 58 14	 mov	 DWORD PTR [eax+20], ebx
  000f7	89 58 18	 mov	 DWORD PTR [eax+24], ebx
  000fa	88 58 1c	 mov	 BYTE PTR [eax+28], bl
  000fd	39 48 20	 cmp	 DWORD PTR [eax+32], ecx
  00100	74 4b		 je	 SHORT $LN16@ClearChaos

; 960  : 		{
; 961  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex = -1;

  00102	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
  00105	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0010b	88 8e 09 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3337], cl

; 962  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex = -1;

  00111	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
  00114	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0011a	88 8e 0a 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3338], cl

; 963  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = 0;

  00120	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
  00123	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00129	89 9e 0c 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3340], ebx

; 964  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillUserCount = 0;

  0012f	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
  00132	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00138	88 9e 10 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3344], bl

; 965  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillMonsterCount = 0;

  0013e	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
  00141	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00147	88 9e 11 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3345], bl
$LN16@ClearChaos:

; 966  : 		}
; 967  : 
; 968  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].Clear();

  0014d	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00150	89 58 24	 mov	 DWORD PTR [eax+36], ebx
  00153	89 58 28	 mov	 DWORD PTR [eax+40], ebx
  00156	89 58 2c	 mov	 DWORD PTR [eax+44], ebx
  00159	88 58 30	 mov	 BYTE PTR [eax+48], bl
  0015c	39 48 34	 cmp	 DWORD PTR [eax+52], ecx
  0015f	74 4b		 je	 SHORT $LN17@ClearChaos

; 960  : 		{
; 961  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex = -1;

  00161	8b 70 34	 mov	 esi, DWORD PTR [eax+52]
  00164	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0016a	88 8e 09 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3337], cl

; 962  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex = -1;

  00170	8b 70 34	 mov	 esi, DWORD PTR [eax+52]
  00173	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00179	88 8e 0a 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3338], cl

; 963  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = 0;

  0017f	8b 70 34	 mov	 esi, DWORD PTR [eax+52]
  00182	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00188	89 9e 0c 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3340], ebx

; 964  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillUserCount = 0;

  0018e	8b 70 34	 mov	 esi, DWORD PTR [eax+52]
  00191	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00197	88 9e 10 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3344], bl

; 965  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillMonsterCount = 0;

  0019d	8b 70 34	 mov	 esi, DWORD PTR [eax+52]
  001a0	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  001a6	88 9e 11 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3345], bl
$LN17@ClearChaos:

; 966  : 		}
; 967  : 
; 968  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].Clear();

  001ac	89 48 34	 mov	 DWORD PTR [eax+52], ecx
  001af	89 58 38	 mov	 DWORD PTR [eax+56], ebx
  001b2	89 58 3c	 mov	 DWORD PTR [eax+60], ebx
  001b5	89 58 40	 mov	 DWORD PTR [eax+64], ebx
  001b8	88 58 44	 mov	 BYTE PTR [eax+68], bl
  001bb	39 48 48	 cmp	 DWORD PTR [eax+72], ecx
  001be	74 4b		 je	 SHORT $LN18@ClearChaos

; 960  : 		{
; 961  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex = -1;

  001c0	8b 70 48	 mov	 esi, DWORD PTR [eax+72]
  001c3	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  001c9	88 8e 09 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3337], cl

; 962  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex = -1;

  001cf	8b 70 48	 mov	 esi, DWORD PTR [eax+72]
  001d2	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  001d8	88 8e 0a 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3338], cl

; 963  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = 0;

  001de	8b 70 48	 mov	 esi, DWORD PTR [eax+72]
  001e1	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  001e7	89 9e 0c 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3340], ebx

; 964  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillUserCount = 0;

  001ed	8b 70 48	 mov	 esi, DWORD PTR [eax+72]
  001f0	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  001f6	88 9e 10 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3344], bl

; 965  : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillMonsterCount = 0;

  001fc	8b 70 48	 mov	 esi, DWORD PTR [eax+72]
  001ff	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00205	88 9e 11 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3345], bl
$LN18@ClearChaos:

; 966  : 		}
; 967  : 
; 968  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].Clear();

  0020b	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  0020e	89 58 4c	 mov	 DWORD PTR [eax+76], ebx
  00211	89 58 50	 mov	 DWORD PTR [eax+80], ebx
  00214	89 58 54	 mov	 DWORD PTR [eax+84], ebx
  00217	88 58 58	 mov	 BYTE PTR [eax+88], bl
  0021a	83 c0 64	 add	 eax, 100		; 00000064H
  0021d	4a		 dec	 edx
  0021e	0f 85 1c fe ff
	ff		 jne	 $LL4@ClearChaos
$LN14@ClearChaos:
  00224	5e		 pop	 esi
  00225	5b		 pop	 ebx

; 969  : 	}
; 970  : }

  00226	5d		 pop	 ebp
  00227	c2 04 00	 ret	 4
?ClearChaosCastleData@CChaosCastle@@IAEXH@Z ENDP	; CChaosCastle::ClearChaosCastleData
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
$T169186 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000a	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  00012	75 18		 jne	 SHORT $LN9@find
  00014	56		 push	 esi
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$LL10@find:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	7d 05		 jge	 SHORT $LN8@find
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $LN7@find
$LN8@find:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@find:
  00025	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00029	74 ec		 je	 SHORT $LL10@find
  0002b	5e		 pop	 esi
$LN9@find:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	89 55 0c	 mov	 DWORD PTR __Where$[ebp], edx
  00032	3b d0		 cmp	 edx, eax
  00034	74 18		 je	 SHORT $LN3@find
  00036	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00038	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003b	7c 11		 jl	 SHORT $LN3@find
  0003d	8d 45 0c	 lea	 eax, DWORD PTR __Where$[ebp]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00045	89 10		 mov	 DWORD PTR [eax], edx
  00047	5f		 pop	 edi

; 1429 : 		}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN3@find:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0004e	89 45 fc	 mov	 DWORD PTR $T169186[ebp], eax
  00051	8d 45 fc	 lea	 eax, DWORD PTR $T169186[ebp]
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00059	89 10		 mov	 DWORD PTR [eax], edx
  0005b	5f		 pop	 edi

; 1429 : 		}

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 39		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 33		 ja	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 980  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002f	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00032	51		 push	 ecx
  00033	52		 push	 edx
  00034	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ; std::_Cons_val<std::allocator<int>,int,int &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00040	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN4@push_back:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0004a	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0004d	75 09		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  0004f	6a 01		 push	 1
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00058	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005b	57		 push	 edi
  0005c	51		 push	 ecx
  0005d	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ; std::_Cons_val<std::allocator<int>,int,int const &>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00069	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tidy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T169433 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T169433[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase

; 1867 : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Destroy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy@3

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy@3:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Tidy
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::insert<std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::insert<std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 753  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 754  : 		{	// try to insert node with value _Val, favoring right side
; 755  : 		return (_Linsert(this->_Buynode(_STD forward<_Valty>(_Val)),
; 756  : 			false));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	6a 00		 push	 0
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >
  00012	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00015	50		 push	 eax
  00016	57		 push	 edi
  00017	8b ce		 mov	 ecx, esi
  00019	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert
  0001e	8b c7		 mov	 eax, edi
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 757  : 		}

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::insert<std::pair<int,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAUCHAOSCASTLE_START_TIME@@@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEPAUCHAOSCASTLE_START_TIME@@PAU2@00@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Umove<CHAOSCASTLE_START_TIME *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUCHAOSCASTLE_START_TIME@@@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEPAUCHAOSCASTLE_START_TIME@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$169563 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUCHAOSCASTLE_START_TIME@@@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEPAUCHAOSCASTLE_START_TIME@@PAU2@00@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Umove<CHAOSCASTLE_START_TIME *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$169563[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUCHAOSCASTLE_START_TIME@@@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEPAUCHAOSCASTLE_START_TIME@@PAU2@00@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Umove<CHAOSCASTLE_START_TIME *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUtagPOINT@@@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEPAUtagPOINT@@PAU2@00@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Umove<tagPOINT *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Umove@PAUtagPOINT@@@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEPAUtagPOINT@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$169583 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUtagPOINT@@@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEPAUtagPOINT@@PAU2@00@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Umove<tagPOINT *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$169583[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUtagPOINT@@@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEPAUtagPOINT@@PAU2@00@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Umove<tagPOINT *>
_TEXT	ENDS
PUBLIC	??_C@_0CE@MMNDEFNC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ ; `string'
;	COMDAT ??_C@_0CE@MMNDEFNC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
CONST	SEGMENT
??_C@_0CE@MMNDEFNC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ DB '['
	DB	'Chaos Castle] (%d) SetState CLOSED', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_Closed@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SetState_Closed@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::SetState_Closed, COMDAT
; _this$ = ecx

; 876  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 877  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00006	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	85 ff		 test	 edi, edi
  00010	0f 88 94 00 00
	00		 js	 $LN7@SetState_C
  00016	33 c0		 xor	 eax, eax
  00018	83 ff 05	 cmp	 edi, 5
  0001b	0f 9e c0	 setle	 al
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 84 00 00
	00		 je	 $LN7@SetState_C

; 878  : 	{
; 879  : 		return;
; 880  : 	}
; 881  : 
; 882  : 	this->SendNoticeState(iChaosCastleIndex, 7);

  00026	53		 push	 ebx
  00027	6a 07		 push	 7
  00029	57		 push	 edi
  0002a	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState

; 883  : 	this->ClearChaosCastleData(iChaosCastleIndex);

  0002f	57		 push	 edi
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?ClearChaosCastleData@CChaosCastle@@IAEXH@Z ; CChaosCastle::ClearChaosCastleData

; 884  : 	this->ClearMonster(iChaosCastleIndex);

  00037	57		 push	 edi
  00038	8b ce		 mov	 ecx, esi
  0003a	e8 00 00 00 00	 call	 ?ClearMonster@CChaosCastle@@QAEXH@Z ; CChaosCastle::ClearMonster

; 885  : 
; 886  : 	for ( int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  0003f	bb 00 19 00 00	 mov	 ebx, 6400		; 00001900H
  00044	be 04 c4 16 02	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046404
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL5@SetState_C:

; 887  : 	{
; 888  : 		if ( gObj[n].MapNumber == (iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1) )

  00050	0f b6 8e 05 01
	00 00		 movzx	 ecx, BYTE PTR [esi+261]
  00057	8d 47 12	 lea	 eax, DWORD PTR [edi+18]
  0005a	3b c8		 cmp	 ecx, eax
  0005c	75 10		 jne	 SHORT $LN4@SetState_C

; 889  : 		{
; 890  : 			if ( gObj[n].Connected > PLAYER_LOGGED )

  0005e	80 3e 02	 cmp	 BYTE PTR [esi], 2
  00061	76 0b		 jbe	 SHORT $LN4@SetState_C

; 891  : 			{
; 892  : 				gObjMoveGate(n, 22);

  00063	6a 16		 push	 22			; 00000016H
  00065	53		 push	 ebx
  00066	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0006b	83 c4 08	 add	 esp, 8
$LN4@SetState_C:

; 885  : 
; 886  : 	for ( int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  0006e	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  00074	43		 inc	 ebx
  00075	81 fe a4 52 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522404
  0007b	7c d3		 jl	 SHORT $LL5@SetState_C

; 893  : 			}
; 894  : 		}
; 895  : 	}
; 896  : 
; 897  : 	this->SafetyCastleZone(iChaosCastleIndex);

  0007d	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00080	57		 push	 edi
  00081	8b ce		 mov	 ecx, esi
  00083	e8 00 00 00 00	 call	 ?SafetyCastleZone@CChaosCastle@@QAEXH@Z ; CChaosCastle::SafetyCastleZone

; 898  : 	this->SetMapAttrFill(iChaosCastleIndex);

  00088	57		 push	 edi
  00089	8b ce		 mov	 ecx, esi
  0008b	e8 00 00 00 00	 call	 ?SetMapAttrFill@CChaosCastle@@QAEXH@Z ; CChaosCastle::SetMapAttrFill

; 899  : 	this->CheckSync(iChaosCastleIndex);

  00090	57		 push	 edi
  00091	8b ce		 mov	 ecx, esi
  00093	e8 00 00 00 00	 call	 ?CheckSync@CChaosCastle@@IAEXH@Z ; CChaosCastle::CheckSync

; 900  : 
; 901  : 	LogAdd(LOG_BLACK, "[Chaos Castle] (%d) SetState CLOSED", iChaosCastleIndex+1);

  00098	47		 inc	 edi
  00099	57		 push	 edi
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@MMNDEFNC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
  0009f	6a 00		 push	 0
  000a1	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a9	5b		 pop	 ebx
$LN7@SetState_C:
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi

; 902  : }

  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
?SetState_Closed@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::SetState_Closed
_TEXT	ENDS
PUBLIC	??_C@_0CF@BCOGMMAI@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
PUBLIC	??_C@_0EA@EGGFCMCP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Failed?5to?5St@ ; `string'
;	COMDAT ??_C@_0CF@BCOGMMAI@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
CONST	SEGMENT
??_C@_0CF@BCOGMMAI@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Chaos Castle] (%d) SetState PLAYING', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@EGGFCMCP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Failed?5to?5St@
CONST	SEGMENT
??_C@_0EA@EGGFCMCP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Failed?5to?5St@ DB '['
	DB	'Chaos Castle] (%d) Failed to Start Chaos Castle : Lack of Use'
	DB	'r', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_Playing@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?SetState_Playing@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::SetState_Playing, COMDAT
; _this$ = ecx

; 905  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 906  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 76		 js	 SHORT $LN1@SetState_P@2
  0000e	33 c0		 xor	 eax, eax
  00010	83 fe 05	 cmp	 esi, 5
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 6a		 je	 SHORT $LN1@SetState_P@2

; 907  : 	{
; 908  : 		return;
; 909  : 	}
; 910  : 
; 911  : 	this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER = false;

  0001a	8b c6		 mov	 eax, esi
  0001c	69 c0 6c 08 00
	00		 imul	 eax, 2156		; 0000086cH
  00022	c6 44 38 4c 00	 mov	 BYTE PTR [eax+edi+76], 0

; 912  : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = this->m_iCC_TIME_MIN_PLAY * 60 * 1000;

  00027	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0002a	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H

; 913  : 	this->SendCastleZoneSafetyInfo(iChaosCastleIndex, true);

  00030	6a 01		 push	 1
  00032	89 4c 38 40	 mov	 DWORD PTR [eax+edi+64], ecx
  00036	56		 push	 esi
  00037	8b cf		 mov	 ecx, edi
  00039	e8 00 00 00 00	 call	 ?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z ; CChaosCastle::SendCastleZoneSafetyInfo

; 914  : 
; 915  : 	if ( this->CheckCanStartPlay(iChaosCastleIndex) == false )

  0003e	56		 push	 esi
  0003f	8b cf		 mov	 ecx, edi
  00041	e8 00 00 00 00	 call	 ?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z ; CChaosCastle::CheckCanStartPlay
  00046	84 c0		 test	 al, al
  00048	75 29		 jne	 SHORT $LN2@SetState_P@2

; 916  : 	{
; 917  : 		this->PlayFailedRollBack(iChaosCastleIndex);

  0004a	56		 push	 esi
  0004b	8b cf		 mov	 ecx, edi
  0004d	e8 00 00 00 00	 call	 ?PlayFailedRollBack@CChaosCastle@@QAEXH@Z ; CChaosCastle::PlayFailedRollBack

; 918  : 		LogAdd(LOG_BLACK, "[Chaos Castle] (%d) Failed to Start Chaos Castle : Lack of User", iChaosCastleIndex +1 );

  00052	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  00055	52		 push	 edx
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@EGGFCMCP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Failed?5to?5St@
  0005b	6a 00		 push	 0
  0005d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH

; 919  : 		this->SetState_Closed(iChaosCastleIndex);

  00065	56		 push	 esi
  00066	8b cf		 mov	 ecx, edi
  00068	e8 00 00 00 00	 call	 ?SetState_Closed@CChaosCastle@@IAEXH@Z ; CChaosCastle::SetState_Closed
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 928  : 	}
; 929  : }

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@SetState_P@2:

; 920  : 	}
; 921  : 	else
; 922  : 	{
; 923  : #if (CHAOS_CASTLE_ZEN_REWARD==1)
; 924  : 		this->RewardZettoMoney(iChaosCastleIndex);	// #warning In older version it gives reward to the last user entering
; 925  : #endif
; 926  : 
; 927  : 		LogAdd(LOG_BLACK, "[Chaos Castle] (%d) SetState PLAYING", iChaosCastleIndex + 1 );

  00073	46		 inc	 esi
  00074	56		 push	 esi
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BCOGMMAI@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  0007a	6a 00		 push	 0
  0007c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@SetState_P@2:
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi

; 928  : 	}
; 929  : }

  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
?SetState_Playing@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::SetState_Playing
_TEXT	ENDS
PUBLIC	?SetItemsToMonster@CChaosCastle@@QAEXH@Z	; CChaosCastle::SetItemsToMonster
; Function compile flags: /Ogtp
;	COMDAT ?SetItemsToMonster@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
$T169603 = -56						; size = 12
$T169604 = -44						; size = 8
_MID$ = -36						; size = 8
tv503 = -32						; size = 4
$T169850 = -28						; size = 4
__Where$169845 = -24					; size = 4
_iMAX_MONSTER$ = -20					; size = 4
tv271 = -16						; size = 4
_iB$158629 = -12					; size = 4
_iC$158633 = -8						; size = 4
tv640 = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SetItemsToMonster@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::SetItemsToMonster, COMDAT
; _this$ = ecx

; 1124 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1125 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00008	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	85 f6		 test	 esi, esi
  0000f	0f 88 3f 01 00
	00		 js	 $LN8@SetItemsTo
  00015	33 c0		 xor	 eax, eax
  00017	83 fe 05	 cmp	 esi, 5
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 2f 01 00
	00		 je	 $LN8@SetItemsTo

; 1126 : 	{
; 1127 : 		return;
; 1128 : 	}
; 1129 : 
; 1130 : 	int iMAX_MONSTER = this->GetMonsterListCount(iChaosCastleIndex);

  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  0002b	89 45 ec	 mov	 DWORD PTR _iMAX_MONSTER$[ebp], eax

; 1131 : 
; 1132 : 	if ( iMAX_MONSTER <= 0 )

  0002e	85 c0		 test	 eax, eax
  00030	0f 8e 1e 01 00
	00		 jle	 $LN8@SetItemsTo

; 1133 : 	{
; 1134 : 		return;
; 1135 : 	}
; 1136 : 
; 1137 : 	std::map<int, _MONSTER_ITEM_DROP>::iterator it;
; 1138 : 	_MONSTER_ITEM_DROP MID;

  00036	83 c8 ff	 or	 eax, -1
  00039	89 45 dc	 mov	 DWORD PTR _MID$[ebp], eax
  0003c	89 45 e0	 mov	 DWORD PTR _MID$[ebp+4], eax
  0003f	8b c6		 mov	 eax, esi
  00041	c1 e0 04	 shl	 eax, 4
  00044	89 45 fc	 mov	 DWORD PTR tv640[ebp], eax
  00047	c7 45 f0 02 00
	00 00		 mov	 DWORD PTR tv271[ebp], 2
  0004e	57		 push	 edi
  0004f	90		 npad	 1
$LL131@SetItemsTo:

; 1141 : 	{
; 1142 : 		for ( int iB=0; iB< ::g_iChaosCastle_MonsterItems[iChaosCastleIndex][iA][1] ; iB++)

  00050	83 b8 04 00 00
	00 00		 cmp	 DWORD PTR _g_iChaosCastle_MonsterItems[eax+4], 0
  00057	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iB$158629[ebp], 0
  0005e	0f 8e e0 00 00
	00		 jle	 $LN9@SetItemsTo
  00064	8b fe		 mov	 edi, esi
  00066	69 f6 6c 08 00
	00		 imul	 esi, 2156		; 0000086cH
  0006c	69 ff 1b 02 00
	00		 imul	 edi, 539		; 0000021bH
  00072	03 f3		 add	 esi, ebx
  00074	89 75 e0	 mov	 DWORD PTR tv503[ebp], esi
  00077	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL7@SetItemsTo:

; 1143 : 		{
; 1144 : 			for ( int iC=0;iC<200;iC++)	// Try 200 times

  00080	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iC$158633[ebp], 0
$LL4@SetItemsTo:

; 1145 : 			{
; 1146 : 				int iMONSTER_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[rand() % iMAX_MONSTER];

  00087	e8 00 00 00 00	 call	 _rand
  0008c	99		 cdq
  0008d	f7 7d ec	 idiv	 DWORD PTR _iMAX_MONSTER$[ebp]

; 1147 : 				it = this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.find(iMONSTER_INDEX);

  00090	8b 8e 90 08 00
	00		 mov	 ecx, DWORD PTR [esi+2192]
  00096	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00099	03 d7		 add	 edx, edi
  0009b	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  0009f	8b 94 93 e4 05
	00 00		 mov	 edx, DWORD PTR [ebx+edx*4+1508]
  000a6	75 14		 jne	 SHORT $LN33@SetItemsTo
$LL34@SetItemsTo:
  000a8	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  000ab	7d 05		 jge	 SHORT $LN32@SetItemsTo
  000ad	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000b0	eb 04		 jmp	 SHORT $LN31@SetItemsTo
$LN32@SetItemsTo:
  000b2	8b c8		 mov	 ecx, eax
  000b4	8b 00		 mov	 eax, DWORD PTR [eax]
$LN31@SetItemsTo:
  000b6	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  000ba	74 ec		 je	 SHORT $LL34@SetItemsTo
$LN33@SetItemsTo:
  000bc	8b 86 90 08 00
	00		 mov	 eax, DWORD PTR [esi+2192]
  000c2	89 4d e8	 mov	 DWORD PTR __Where$169845[ebp], ecx
  000c5	3b c8		 cmp	 ecx, eax
  000c7	74 0a		 je	 SHORT $LN27@SetItemsTo
  000c9	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  000cc	7c 05		 jl	 SHORT $LN27@SetItemsTo
  000ce	8d 45 e8	 lea	 eax, DWORD PTR __Where$169845[ebp]
  000d1	eb 06		 jmp	 SHORT $LN28@SetItemsTo
$LN27@SetItemsTo:
  000d3	89 45 e4	 mov	 DWORD PTR $T169850[ebp], eax
  000d6	8d 45 e4	 lea	 eax, DWORD PTR $T169850[ebp]
$LN28@SetItemsTo:
  000d9	8b 00		 mov	 eax, DWORD PTR [eax]

; 1148 : 
; 1149 : 				if ( it == this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.end() )

  000db	8b 4d e0	 mov	 ecx, DWORD PTR tv503[ebp]
  000de	3b 81 90 08 00
	00		 cmp	 eax, DWORD PTR [ecx+2192]
  000e4	74 10		 je	 SHORT $LN127@SetItemsTo

; 1143 : 		{
; 1144 : 			for ( int iC=0;iC<200;iC++)	// Try 200 times

  000e6	8b 45 f8	 mov	 eax, DWORD PTR _iC$158633[ebp]
  000e9	40		 inc	 eax
  000ea	89 45 f8	 mov	 DWORD PTR _iC$158633[ebp], eax
  000ed	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  000f2	7c 93		 jl	 SHORT $LL4@SetItemsTo

; 1148 : 
; 1149 : 				if ( it == this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.end() )

  000f4	eb 33		 jmp	 SHORT $LN6@SetItemsTo
$LN127@SetItemsTo:

; 1150 : 				{
; 1151 : 					MID.m_iIndex = iMONSTER_INDEX;
; 1152 : 					MID.m_iItemKind = ::g_iChaosCastle_MonsterItems[iChaosCastleIndex][iA][0];

  000f6	8b 45 fc	 mov	 eax, DWORD PTR tv640[ebp]
  000f9	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _g_iChaosCastle_MonsterItems[eax]

; 1153 : 					this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.insert( std::pair<int,_MONSTER_ITEM_DROP>(iMONSTER_INDEX, MID) );

  000ff	6a 00		 push	 0
  00101	8d 4d c8	 lea	 ecx, DWORD PTR $T169603[ebp]
  00104	51		 push	 ecx
  00105	8d 8e 8c 08 00
	00		 lea	 ecx, DWORD PTR [esi+2188]
  0010b	89 55 c8	 mov	 DWORD PTR $T169603[ebp], edx
  0010e	89 55 cc	 mov	 DWORD PTR $T169603[ebp+4], edx
  00111	89 45 d0	 mov	 DWORD PTR $T169603[ebp+8], eax
  00114	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >
  00119	50		 push	 eax
  0011a	8d 55 d4	 lea	 edx, DWORD PTR $T169604[ebp]
  0011d	52		 push	 edx
  0011e	8d 8e 8c 08 00
	00		 lea	 ecx, DWORD PTR [esi+2188]
  00124	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert
$LN6@SetItemsTo:

; 1141 : 	{
; 1142 : 		for ( int iB=0; iB< ::g_iChaosCastle_MonsterItems[iChaosCastleIndex][iA][1] ; iB++)

  00129	8b 45 f4	 mov	 eax, DWORD PTR _iB$158629[ebp]
  0012c	8b 4d fc	 mov	 ecx, DWORD PTR tv640[ebp]
  0012f	40		 inc	 eax
  00130	89 45 f4	 mov	 DWORD PTR _iB$158629[ebp], eax
  00133	3b 81 04 00 00
	00		 cmp	 eax, DWORD PTR _g_iChaosCastle_MonsterItems[ecx+4]
  00139	0f 8c 41 ff ff
	ff		 jl	 $LL7@SetItemsTo
  0013f	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00142	8b c1		 mov	 eax, ecx
$LN9@SetItemsTo:

; 1139 : 
; 1140 : 	for ( int iA = 0;iA < MAX_CC_MONSTER_DROP_ITEM ; iA++)

  00144	83 c0 08	 add	 eax, 8
  00147	ff 4d f0	 dec	 DWORD PTR tv271[ebp]
  0014a	89 45 fc	 mov	 DWORD PTR tv640[ebp], eax
  0014d	0f 85 fd fe ff
	ff		 jne	 $LL131@SetItemsTo
  00153	5f		 pop	 edi
$LN8@SetItemsTo:
  00154	5e		 pop	 esi
  00155	5b		 pop	 ebx

; 1154 : 					break;
; 1155 : 				}
; 1156 : 			}
; 1157 : 		}
; 1158 : 	}
; 1159 : }

  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c2 04 00	 ret	 4
?SetItemsToMonster@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::SetItemsToMonster
_TEXT	ENDS
PUBLIC	??_C@_0EL@HKCNHNKH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Drop@ ; `string'
PUBLIC	?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z	; CChaosCastle::SearchNDropMonsterItem
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
;	COMDAT ??_C@_0EL@HKCNHNKH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Drop@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	SEGMENT
??_C@_0EL@HKCNHNKH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Drop@ DB '['
	DB	'Chaos Castle] (%d) Monster Dropped ChaosCastle Item To [%s][%'
	DB	's] (Item:%s)', 00H				; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
CONST	ENDS
;	COMDAT ?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z
_TEXT	SEGMENT
_MID$ = -12						; size = 8
tv263 = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iMonsterIndex$ = 12					; size = 4
_it$ = 16						; size = 4
_iMaxHitUserIndex$ = 16					; size = 4
?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z PROC	; CChaosCastle::SearchNDropMonsterItem, COMDAT
; _this$ = ecx

; 1162 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1163 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	85 d2		 test	 edx, edx
  0000e	0f 88 12 01 00
	00		 js	 $LN1@SearchNDro
  00014	33 c0		 xor	 eax, eax
  00016	83 fa 05	 cmp	 edx, 5
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 02 01 00
	00		 je	 $LN1@SearchNDro

; 1164 : 	{
; 1165 : 		return;
; 1166 : 	}
; 1167 : 
; 1168 : 	if ( OBJMAX_RANGE(iMonsterIndex) == FALSE )

  00024	8b 45 0c	 mov	 eax, DWORD PTR _iMonsterIndex$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	0f 88 f7 00 00
	00		 js	 $LN1@SearchNDro
  0002f	33 c9		 xor	 ecx, ecx
  00031	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00036	0f 9e c1	 setle	 cl
  00039	8b c1		 mov	 eax, ecx
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 e3 00 00
	00		 je	 $LN1@SearchNDro

; 1169 : 	{
; 1170 : 		return;
; 1171 : 	}
; 1172 : 
; 1173 : 	if ( OBJMAX_RANGE(iMaxHitUserIndex) == FALSE )

  00043	53		 push	 ebx
  00044	8b 5d 10	 mov	 ebx, DWORD PTR _iMaxHitUserIndex$[ebp]
  00047	85 db		 test	 ebx, ebx
  00049	0f 88 d6 00 00
	00		 js	 $LN37@SearchNDro
  0004f	33 c0		 xor	 eax, eax
  00051	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  00057	0f 9e c0	 setle	 al
  0005a	89 45 fc	 mov	 DWORD PTR tv263[ebp], eax
  0005d	85 c0		 test	 eax, eax
  0005f	0f 84 c0 00 00
	00		 je	 $LN37@SearchNDro

; 1174 : 	{
; 1175 : 		return;
; 1176 : 	}
; 1177 : 
; 1178 : 	std::map<int, _MONSTER_ITEM_DROP>::iterator it = this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.find(iMonsterIndex);

  00065	69 d2 6c 08 00
	00		 imul	 edx, 2156		; 0000086cH
  0006b	03 f2		 add	 esi, edx
  0006d	8d 55 0c	 lea	 edx, DWORD PTR _iMonsterIndex$[ebp]
  00070	52		 push	 edx
  00071	8d 45 10	 lea	 eax, DWORD PTR _it$[ebp]
  00074	50		 push	 eax
  00075	8d 8e 8c 08 00
	00		 lea	 ecx, DWORD PTR [esi+2188]
  0007b	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find

; 1179 : 
; 1180 : 	if ( it == this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.end() )

  00080	8b 45 10	 mov	 eax, DWORD PTR _it$[ebp]
  00083	3b 86 90 08 00
	00		 cmp	 eax, DWORD PTR [esi+2192]
  00089	0f 84 96 00 00
	00		 je	 $LN37@SearchNDro

; 1181 : 	{
; 1182 : 		return;
; 1183 : 	}
; 1184 : 
; 1185 : 	_MONSTER_ITEM_DROP MID = it->second;

  0008f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00092	57		 push	 edi
  00093	8b 78 14	 mov	 edi, DWORD PTR [eax+20]

; 1186 : 	int iType = MID.m_iItemKind;
; 1187 : 	int iLevel = 0;

  00096	33 c0		 xor	 eax, eax
  00098	89 4d f4	 mov	 DWORD PTR _MID$[ebp], ecx

; 1188 : 	
; 1189 : 	if ( iType == ITEMGET(13,15) ) // Fruit

  0009b	81 ff 0f 1a 00
	00		 cmp	 edi, 6671		; 00001a0fH
  000a1	75 11		 jne	 SHORT $LN39@SearchNDro

; 1190 : 	{
; 1191 : 		iLevel = rand()%4;

  000a3	e8 00 00 00 00	 call	 _rand
  000a8	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  000ad	79 05		 jns	 SHORT $LN39@SearchNDro
  000af	48		 dec	 eax
  000b0	83 c8 fc	 or	 eax, -4			; fffffffcH
  000b3	40		 inc	 eax
$LN39@SearchNDro:

; 1192 : 	}
; 1193 : 
; 1194 : 	::ItemSerialCreateSend(gObj[iMaxHitUserIndex].m_Index, gObj[iMaxHitUserIndex].MapNumber, gObj[iMaxHitUserIndex].X,
; 1195 : 		gObj[iMaxHitUserIndex].Y, iType, iLevel, 0, 0, 0, 0, iMaxHitUserIndex, 0, 0);

  000b4	6a 00		 push	 0
  000b6	6a 00		 push	 0
  000b8	53		 push	 ebx
  000b9	6a 00		 push	 0
  000bb	8b f3		 mov	 esi, ebx
  000bd	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000c3	0f b6 96 06 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  000ca	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]
  000d1	6a 00		 push	 0
  000d3	6a 00		 push	 0
  000d5	6a 00		 push	 0
  000d7	50		 push	 eax
  000d8	0f b6 86 04 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  000df	57		 push	 edi
  000e0	52		 push	 edx
  000e1	8b 96 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000e7	50		 push	 eax
  000e8	51		 push	 ecx
  000e9	52		 push	 edx
  000ea	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  000ef	83 c4 34	 add	 esp, 52			; 00000034H

; 1196 : 
; 1197 : 	if ( OBJMAX_RANGE(iMaxHitUserIndex) != FALSE )

  000f2	83 7d fc 00	 cmp	 DWORD PTR tv263[ebp], 0
  000f6	74 2c		 je	 SHORT $LN38@SearchNDro

; 1198 : 	{
; 1199 : 		LogAdd(LOG_BLACK, "[Chaos Castle] (%d) Monster Dropped ChaosCastle Item To [%s][%s] (Item:%s)",
; 1200 : 			iChaosCastleIndex+1, gObj[iMaxHitUserIndex].AccountID, gObj[iMaxHitUserIndex].Name,
; 1201 : 			ItemAttribute[iType].Name);

  000f8	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  000fb	6b ff 6c	 imul	 edi, 108		; 0000006cH
  000fe	81 c7 00 00 00
	00		 add	 edi, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00104	57		 push	 edi
  00105	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  0010b	50		 push	 eax
  0010c	8d 8e 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  00112	51		 push	 ecx
  00113	42		 inc	 edx
  00114	52		 push	 edx
  00115	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@HKCNHNKH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Drop@
  0011a	6a 00		 push	 0
  0011c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00121	83 c4 18	 add	 esp, 24			; 00000018H
$LN38@SearchNDro:
  00124	5f		 pop	 edi
$LN37@SearchNDro:
  00125	5b		 pop	 ebx
$LN1@SearchNDro:
  00126	5e		 pop	 esi

; 1202 : 	}
; 1203 : }

  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c2 0c 00	 ret	 12			; 0000000cH
?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z ENDP	; CChaosCastle::SearchNDropMonsterItem
_TEXT	ENDS
PUBLIC	??_C@_0EG@DMBELMMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ ; `string'
PUBLIC	??_C@_0FA@BKKNHLPK@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_0DB@POIMMHNL@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5ERROR?5?3?5REWA@ ; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?RewardZettoMoney@CChaosCastle@@QAEHH@Z		; CChaosCastle::RewardZettoMoney
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT ??_C@_0EG@DMBELMMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0EG@DMBELMMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Win Zen Lotto (RewardZen:%d, User'
	DB	'Zen:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BKKNHLPK@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0FA@BKKNHLPK@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Chaos Castle][Bug Tracer] (%d) [%s][%s] Reword ZettoMoney(Map'
	DB	':%d) Send Message', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@POIMMHNL@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5ERROR?5?3?5REWA@
CONST	SEGMENT
??_C@_0DB@POIMMHNL@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5ERROR?5?3?5REWA@ DB '['
	DB	'Chaos Castle] (%d) ERROR : REWARD ZEN <= 0 (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RewardZettoMoney@CChaosCastle@@QAEHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RewardZettoMoney@CChaosCastle@@QAEHH@Z$0
__ehfuncinfo$?RewardZettoMoney@CChaosCastle@@QAEHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RewardZettoMoney@CChaosCastle@@QAEHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
xdata$x	ENDS
;	COMDAT ?RewardZettoMoney@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
tv786 = -332						; size = 4
_vtZettoWinner$ = -328					; size = 16
_iZettoWinnerIndex$ = -312				; size = 4
_iZettoMoney$ = -308					; size = 4
tv515 = -304						; size = 4
tv211 = -304						; size = 4
_this$GSCopy$ = -304					; size = 4
_pNotice$ = -300					; size = 272
_szZettoWinnerName$ = -28				; size = 11
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iChaosCastleIndex$ = 8					; size = 4
?RewardZettoMoney@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::RewardZettoMoney, COMDAT
; _this$ = ecx

; 2848 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RewardZettoMoney@CChaosCastle@@QAEHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]

; 2856 : 
; 2857 : 	int iZettoMoney = iPlayUser * (g_iChaosCastle_EnterCost[iChaosCastleIndex] * 80 / 100);

  00031	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00037	85 ff		 test	 edi, edi
  00039	78 56		 js	 SHORT $LN63@RewardZett

; 2849 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0003b	33 c0		 xor	 eax, eax
  0003d	83 ff 05	 cmp	 edi, 5
  00040	0f 9e c0	 setle	 al
  00043	85 c0		 test	 eax, eax

; 2850 : 		return -1;

  00045	74 4a		 je	 SHORT $LN63@RewardZett

; 2851 : 
; 2852 : 	int iPlayUser = this->GetCurPlayUser(iChaosCastleIndex);

  00047	57		 push	 edi
  00048	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  0004d	8b f0		 mov	 esi, eax

; 2853 : 
; 2854 : 	if ( iPlayUser <= 0 )

  0004f	85 f6		 test	 esi, esi

; 2855 : 		return -1;

  00051	7e 3e		 jle	 SHORT $LN63@RewardZett

; 2856 : 
; 2857 : 	int iZettoMoney = iPlayUser * (g_iChaosCastle_EnterCost[iChaosCastleIndex] * 80 / 100);

  00053	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR _g_iChaosCastle_EnterCost[edi*4]
  0005a	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0005d	c1 e1 04	 shl	 ecx, 4
  00060	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00065	f7 e9		 imul	 ecx
  00067	c1 fa 05	 sar	 edx, 5
  0006a	8b da		 mov	 ebx, edx
  0006c	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0006f	03 da		 add	 ebx, edx
  00071	0f af de	 imul	 ebx, esi

; 2858 : 
; 2859 : 	if ( iZettoMoney <= 0 )

  00074	33 c0		 xor	 eax, eax
  00076	89 9d cc fe ff
	ff		 mov	 DWORD PTR _iZettoMoney$[ebp], ebx
  0007c	3b d8		 cmp	 ebx, eax
  0007e	7f 19		 jg	 SHORT $LN15@RewardZett

; 2860 : 	{
; 2861 : 		LogAdd(LOG_BLACK, "[Chaos Castle] (%d) ERROR : REWARD ZEN <= 0 (%d)",
; 2862 : 			iChaosCastleIndex+1, iZettoMoney);

  00080	53		 push	 ebx
  00081	47		 inc	 edi
  00082	57		 push	 edi
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@POIMMHNL@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5ERROR?5?3?5REWA@
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0008e	83 c4 10	 add	 esp, 16			; 00000010H
$LN63@RewardZett:

; 2863 : 
; 2864 : 		return -1;

  00091	83 c8 ff	 or	 eax, -1
  00094	e9 2f 02 00 00	 jmp	 $LN18@RewardZett
$LN15@RewardZett:

; 2865 : 	}
; 2866 : 
; 2867 : 	std::vector<int> vtZettoWinner;

  00099	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _vtZettoWinner$[ebp], eax
  0009f	89 85 bc fe ff
	ff		 mov	 DWORD PTR _vtZettoWinner$[ebp+4], eax
  000a5	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _vtZettoWinner$[ebp+8], eax
  000ab	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _this$GSCopy$[ebp]
  000b1	8b cf		 mov	 ecx, edi
  000b3	69 c9 6c 08 00
	00		 imul	 ecx, 2156		; 0000086cH
  000b9	8d 74 11 6c	 lea	 esi, DWORD PTR [ecx+edx+108]
  000bd	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  000c0	89 b5 b4 fe ff
	ff		 mov	 DWORD PTR tv786[ebp], esi
  000c6	c7 85 d0 fe ff
	ff 46 00 00 00	 mov	 DWORD PTR tv515[ebp], 70 ; 00000046H
$LL14@RewardZett:

; 2870 : 	{
; 2871 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  000d0	8b 06		 mov	 eax, DWORD PTR [esi]
  000d2	83 f8 ff	 cmp	 eax, -1
  000d5	74 30		 je	 SHORT $LN13@RewardZett

; 2872 : 		{
; 2873 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) == TRUE &&
; 2874 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == (iChaosCastleIndex+18) )

  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000dd	83 c4 04	 add	 esp, 4
  000e0	83 f8 01	 cmp	 eax, 1
  000e3	75 22		 jne	 SHORT $LN13@RewardZett
  000e5	8b 06		 mov	 eax, DWORD PTR [esi]
  000e7	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000ed	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  000f4	8d 57 12	 lea	 edx, DWORD PTR [edi+18]
  000f7	3b ca		 cmp	 ecx, edx
  000f9	75 0c		 jne	 SHORT $LN13@RewardZett

; 2875 : 			{
; 2876 : 				vtZettoWinner.push_back(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex);

  000fb	56		 push	 esi
  000fc	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _vtZettoWinner$[ebp]
  00102	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
$LN13@RewardZett:

; 2868 : 
; 2869 : 	for (int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00107	83 c6 14	 add	 esi, 20			; 00000014H
  0010a	ff 8d d0 fe ff
	ff		 dec	 DWORD PTR tv515[ebp]
  00110	75 be		 jne	 SHORT $LL14@RewardZett

; 2877 : 			}
; 2878 : 		}
; 2879 : 	}
; 2880 : 
; 2881 : 	iPlayUser = vtZettoWinner.size();

  00112	8b b5 bc fe ff
	ff		 mov	 esi, DWORD PTR _vtZettoWinner$[ebp+4]
  00118	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _vtZettoWinner$[ebp]
  0011e	2b f0		 sub	 esi, eax
  00120	c1 fe 02	 sar	 esi, 2

; 2882 : 
; 2883 : 	if ( iPlayUser <= 0 )

  00123	85 f6		 test	 esi, esi
  00125	7f 15		 jg	 SHORT $LN9@RewardZett

; 2884 : 		return -1;

  00127	85 c0		 test	 eax, eax
  00129	74 09		 je	 SHORT $LN42@RewardZett
  0012b	50		 push	 eax
  0012c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00131	83 c4 04	 add	 esp, 4
$LN42@RewardZett:
  00134	83 c8 ff	 or	 eax, -1
  00137	e9 8c 01 00 00	 jmp	 $LN18@RewardZett
$LN9@RewardZett:

; 2885 : 
; 2886 : 	int iZettoWinnerIndex = vtZettoWinner[rand()%iPlayUser];

  0013c	e8 00 00 00 00	 call	 _rand
  00141	99		 cdq
  00142	f7 fe		 idiv	 esi
  00144	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _vtZettoWinner$[ebp]
  0014a	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]

; 2887 : 	char szZettoWinnerName[11] ={0};
; 2888 : 	memcpy(szZettoWinnerName, gObj[iZettoWinnerIndex].Name, 10);

  0014d	8b f2		 mov	 esi, edx
  0014f	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00155	8b 8e 6f 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]

; 2889 : 	gObj[iZettoWinnerIndex].Money += iZettoMoney;

  0015b	01 9e b0 00 00
	00		 add	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176], ebx
  00161	33 c0		 xor	 eax, eax

; 2890 : 
; 2891 : 	if ( gObj[iZettoWinnerIndex].Money > MAX_ZEN )

  00163	81 be b0 00 00
	00 00 94 35 77	 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176], 2000000000 ; 77359400H
  0016d	89 45 e5	 mov	 DWORD PTR _szZettoWinnerName$[ebp+1], eax
  00170	89 45 e9	 mov	 DWORD PTR _szZettoWinnerName$[ebp+5], eax
  00173	66 89 45 ed	 mov	 WORD PTR _szZettoWinnerName$[ebp+9], ax
  00177	8b 86 73 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+115]
  0017d	89 4d e4	 mov	 DWORD PTR _szZettoWinnerName$[ebp], ecx
  00180	66 8b 8e 77 00
	00 00		 mov	 cx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+119]
  00187	89 95 c8 fe ff
	ff		 mov	 DWORD PTR _iZettoWinnerIndex$[ebp], edx
  0018d	89 45 e8	 mov	 DWORD PTR _szZettoWinnerName$[ebp+4], eax
  00190	66 89 4d ec	 mov	 WORD PTR _szZettoWinnerName$[ebp+8], cx
  00194	7e 0a		 jle	 SHORT $LN8@RewardZett

; 2892 : 		gObj[iZettoWinnerIndex].Money = MAX_ZEN;

  00196	c7 86 b0 00 00
	00 00 94 35 77	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176], 2000000000 ; 77359400H
$LN8@RewardZett:

; 2893 : 
; 2894 : 	GCMoneySend(iZettoWinnerIndex, gObj[iZettoWinnerIndex].Money);

  001a0	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176]
  001a6	50		 push	 eax
  001a7	52		 push	 edx
  001a8	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 2895 : 
; 2896 : 	PMSG_NOTICE pNotice;
; 2897 : 	TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get(MSGGET(4,213)), iChaosCastleIndex+1, szZettoWinnerName, iZettoMoney);

  001ad	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _iZettoMoney$[ebp]
  001b3	83 c4 08	 add	 esp, 8
  001b6	51		 push	 ecx
  001b7	8d 55 e4	 lea	 edx, DWORD PTR _szZettoWinnerName$[ebp]
  001ba	52		 push	 edx
  001bb	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  001be	53		 push	 ebx
  001bf	68 d5 04 00 00	 push	 1237			; 000004d5H
  001c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001c9	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001ce	50		 push	 eax
  001cf	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  001d5	6a 00		 push	 0
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  001dd	8b bd b4 fe ff
	ff		 mov	 edi, DWORD PTR tv786[ebp]
  001e3	83 c4 18	 add	 esp, 24			; 00000018H
  001e6	c7 85 d0 fe ff
	ff 46 00 00 00	 mov	 DWORD PTR tv211[ebp], 70 ; 00000046H
$LL7@RewardZett:

; 2900 : 	{
; 2901 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  001f0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001f2	83 f9 ff	 cmp	 ecx, -1
  001f5	74 6c		 je	 SHORT $LN6@RewardZett

; 2902 : 		{
; 2903 : 			if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Connected == PLAYER_PLAYING )

  001f7	8b c1		 mov	 eax, ecx
  001f9	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  001ff	80 b8 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 3
  00206	75 5b		 jne	 SHORT $LN6@RewardZett

; 2904 : 			{
; 2905 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex != -1 && 
; 2906 : 					 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex!= -1)

  00208	80 b8 09 0d 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3337], -1
  0020f	74 21		 je	 SHORT $LN2@RewardZett
  00211	80 b8 0a 0d 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3338], -1
  00218	74 18		 je	 SHORT $LN2@RewardZett

; 2907 : 				{
; 2908 : 					DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex,
; 2909 : 						(LPBYTE)&pNotice, pNotice.h.size);

  0021a	0f b6 95 d5 fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$[ebp+1]
  00221	52		 push	 edx
  00222	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00228	50		 push	 eax
  00229	51		 push	 ecx
  0022a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0022f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@RewardZett:

; 2910 : 				}
; 2911 : 
; 2912 : 				LogAdd(LOG_BLACK, "[Chaos Castle][Bug Tracer] (%d) [%s][%s] Reword ZettoMoney(Map:%d) Send Message",
; 2913 : 					iChaosCastleIndex+1, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].AccountID,
; 2914 : 					gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Name,
; 2915 : 					gObj[iZettoWinnerIndex].MapNumber - 18);

  00232	8b 07		 mov	 eax, DWORD PTR [edi]
  00234	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]
  0023b	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00241	83 e9 12	 sub	 ecx, 18			; 00000012H
  00244	51		 push	 ecx
  00245	8d 90 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  0024b	52		 push	 edx
  0024c	8d 80 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00252	50		 push	 eax
  00253	53		 push	 ebx
  00254	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@BKKNHLPK@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  00259	6a 00		 push	 0
  0025b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00260	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@RewardZett:

; 2898 : 
; 2899 : 	for (int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00263	83 c7 14	 add	 edi, 20			; 00000014H
  00266	ff 8d d0 fe ff
	ff		 dec	 DWORD PTR tv211[ebp]
  0026c	75 82		 jne	 SHORT $LL7@RewardZett

; 2916 : 			}
; 2917 : 		}
; 2918 : 	}
; 2919 : 
; 2920 : 	if ( OBJMAX_RANGE(iZettoWinnerIndex))

  0026e	8b bd c8 fe ff
	ff		 mov	 edi, DWORD PTR _iZettoWinnerIndex$[ebp]
  00274	85 ff		 test	 edi, edi
  00276	78 3b		 js	 SHORT $LN1@RewardZett
  00278	33 c0		 xor	 eax, eax
  0027a	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  00280	0f 9e c0	 setle	 al
  00283	85 c0		 test	 eax, eax
  00285	74 2c		 je	 SHORT $LN1@RewardZett

; 2921 : 	{
; 2922 : 		LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] Win Zen Lotto (RewardZen:%d, UserZen:%d)",
; 2923 : 			iChaosCastleIndex+1, gObj[iZettoWinnerIndex].AccountID,
; 2924 : 			gObj[iZettoWinnerIndex].Name, iZettoMoney, gObj[iZettoWinnerIndex].Money);

  00287	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176]
  0028d	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _iZettoMoney$[ebp]
  00293	51		 push	 ecx
  00294	52		 push	 edx
  00295	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  0029b	50		 push	 eax
  0029c	8d 86 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  002a2	50		 push	 eax
  002a3	53		 push	 ebx
  002a4	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@DMBELMMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
  002a9	6a 00		 push	 0
  002ab	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  002b0	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@RewardZett:

; 2925 : 	}
; 2926 : 
; 2927 : 	return iZettoWinnerIndex;

  002b3	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _vtZettoWinner$[ebp]
  002b9	85 c0		 test	 eax, eax
  002bb	74 09		 je	 SHORT $LN55@RewardZett
  002bd	50		 push	 eax
  002be	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002c3	83 c4 04	 add	 esp, 4
$LN55@RewardZett:
  002c6	8b c7		 mov	 eax, edi
$LN18@RewardZett:

; 2928 : }

  002c8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002d2	59		 pop	 ecx
  002d3	5f		 pop	 edi
  002d4	5e		 pop	 esi
  002d5	5b		 pop	 ebx
  002d6	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d9	33 cd		 xor	 ecx, ebp
  002db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e0	8b e5		 mov	 esp, ebp
  002e2	5d		 pop	 ebp
  002e3	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RewardZettoMoney@CChaosCastle@@QAEHH@Z$0:
  00000	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _vtZettoWinner$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?RewardZettoMoney@CChaosCastle@@QAEHH@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a b0 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-336]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RewardZettoMoney@CChaosCastle@@QAEHH@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RewardZettoMoney@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::RewardZettoMoney
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T170305 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 791  : 		_Tidy();

  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T170305[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase

; 792  : 		}

  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
PUBLIC	??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@3
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@3:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@0@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);
; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00003	8b 55 10	 mov	 edx, DWORD PTR __Last_arg$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __First_arg$[ebp]
  0000d	89 30		 mov	 DWORD PTR [eax], esi
  0000f	3b f2		 cmp	 esi, edx
  00011	74 26		 je	 SHORT $LN1@erase@3

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00013	57		 push	 edi
  00014	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00017	3b d7		 cmp	 edx, edi
  00019	74 1a		 je	 SHORT $LN30@erase@3
  0001b	53		 push	 ebx
  0001c	8d 64 24 00	 npad	 4
$LL32@erase@3:
  00020	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00022	89 1e		 mov	 DWORD PTR [esi], ebx
  00024	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00027	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0002a	83 c2 08	 add	 edx, 8
  0002d	83 c6 08	 add	 esi, 8
  00030	3b d7		 cmp	 edx, edi
  00032	75 ec		 jne	 SHORT $LL32@erase@3
  00034	5b		 pop	 ebx
$LN30@erase@3:

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00035	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00038	5f		 pop	 edi
$LN1@erase@3:
  00039	5e		 pop	 esi

; 1212 : 			}
; 1213 : 		return (_First);
; 1214 : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@0@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::erase
_TEXT	ENDS
PUBLIC	??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@4
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@4:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$160903 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$170545 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00030	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00035	76 0a		 jbe	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve@2:
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  00041	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00044	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00046	c1 f9 03	 sar	 ecx, 3
  00049	3b c8		 cmp	 ecx, eax
  0004b	73 56		 jae	 SHORT $LN3@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0004d	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  00050	50		 push	 eax
  00051	8b cf		 mov	 ecx, edi
  00053	e8 00 00 00 00	 call	 ?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z ; std::allocator<CHAOSCASTLE_START_TIME>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00058	8b 55 08	 mov	 edx, DWORD PTR __Cat$170545[ebp]
  0005b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005d	52		 push	 edx
  0005e	6a 00		 push	 0
  00060	8b d8		 mov	 ebx, eax
  00062	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00065	57		 push	 edi
  00066	53		 push	 ebx
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	89 5d ec	 mov	 DWORD PTR __Ptr$160903[ebp], ebx
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00073	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00078	8b 06		 mov	 eax, DWORD PTR [esi]
  0007a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0007d	2b f8		 sub	 edi, eax
  0007f	83 c4 18	 add	 esp, 24			; 00000018H
  00082	c1 ff 03	 sar	 edi, 3

; 761  : 			if (this->_Myfirst != 0)

  00085	85 c0		 test	 eax, eax
  00087	74 09		 je	 SHORT $LN35@reserve@2

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008f	83 c4 04	 add	 esp, 4
$LN35@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  00092	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00095	8d 0c c3	 lea	 ecx, DWORD PTR [ebx+eax*8]

; 770  : 			this->_Mylast = _Ptr + _Size;

  00098	8d 14 fb	 lea	 edx, DWORD PTR [ebx+edi*8]
  0009b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0009e	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  000a1	89 1e		 mov	 DWORD PTR [esi], ebx
$LN3@reserve@2:

; 772  : 			}
; 773  : 		}

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ad	59		 pop	 ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 04 00	 ret	 4
__catch$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000b7	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$160903[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c0	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000c3	6a 00		 push	 0
  000c5	6a 00		 push	 0
  000c7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve@2:
$LN41@reserve@2:
  000cc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve
PUBLIC	?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$160940 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$170630 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00030	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00035	76 0a		 jbe	 SHORT $LN5@reserve@3

; 748  : 			_Xlen();	// result too long

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve@3:
$LN5@reserve@3:

; 749  : 		else if (capacity() < _Count)

  00041	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00044	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00046	c1 f9 03	 sar	 ecx, 3
  00049	3b c8		 cmp	 ecx, eax
  0004b	73 56		 jae	 SHORT $LN3@reserve@3

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0004d	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  00050	50		 push	 eax
  00051	8b cf		 mov	 ecx, edi
  00053	e8 00 00 00 00	 call	 ?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z ; std::allocator<tagPOINT>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00058	8b 55 08	 mov	 edx, DWORD PTR __Cat$170630[ebp]
  0005b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005d	52		 push	 edx
  0005e	6a 00		 push	 0
  00060	8b d8		 mov	 ebx, eax
  00062	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00065	57		 push	 edi
  00066	53		 push	 ebx
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	89 5d ec	 mov	 DWORD PTR __Ptr$160940[ebp], ebx
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00073	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00078	8b 06		 mov	 eax, DWORD PTR [esi]
  0007a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0007d	2b f8		 sub	 edi, eax
  0007f	83 c4 18	 add	 esp, 24			; 00000018H
  00082	c1 ff 03	 sar	 edi, 3

; 761  : 			if (this->_Myfirst != 0)

  00085	85 c0		 test	 eax, eax
  00087	74 09		 je	 SHORT $LN35@reserve@3

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008f	83 c4 04	 add	 esp, 4
$LN35@reserve@3:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  00092	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00095	8d 0c c3	 lea	 ecx, DWORD PTR [ebx+eax*8]

; 770  : 			this->_Mylast = _Ptr + _Size;

  00098	8d 14 fb	 lea	 edx, DWORD PTR [ebx+edi*8]
  0009b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0009e	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  000a1	89 1e		 mov	 DWORD PTR [esi], ebx
$LN3@reserve@3:

; 772  : 			}
; 773  : 		}

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ad	59		 pop	 ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 04 00	 ret	 4
__catch$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000b7	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$160940[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c0	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000c3	6a 00		 push	 0
  000c5	6a 00		 push	 0
  000c7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve@3:
$LN41@reserve@3:
  000cc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve
PUBLIC	??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::~map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T170806 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::~map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T170806[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
__ehhandler$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::~map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >
PUBLIC	??0?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T170996 = -16						; size = 12
$T170888 = -4						; size = 4
??0?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 1c		 push	 28			; 0000001cH
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN25@map
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 18	 mov	 BYTE PTR [ecx+24], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 19	 mov	 BYTE PTR [edx+25], al

; 107  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0

; 106  : 		{	// construct empty map from defaults

$LN25@map:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T170888[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T170996[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T170888[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T170996[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T170996[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@map:
$LN48@map:
  0006c	cc		 int	 3
??0?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1292 : 		if (max_size() - _Count < _Size)

  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000c	57		 push	 edi
  0000d	2b c6		 sub	 eax, esi
  0000f	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00014	c1 f8 03	 sar	 eax, 3
  00017	2b fa		 sub	 edi, edx
  00019	3b f8		 cmp	 edi, eax
  0001b	73 0a		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00022	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve@2:
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	03 c2		 add	 eax, edx
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	2b d6		 sub	 edx, esi
  0002e	c1 fa 03	 sar	 edx, 3
  00031	3b c2		 cmp	 eax, edx
  00033	76 21		 jbe	 SHORT $LN1@Reserve@2

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00035	8b f2		 mov	 esi, edx
  00037	d1 ee		 shr	 esi, 1
  00039	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  0003e	2b fe		 sub	 edi, esi
  00040	3b fa		 cmp	 edi, edx
  00042	73 04		 jae	 SHORT $LN23@Reserve@2
  00044	33 d2		 xor	 edx, edx
  00046	eb 02		 jmp	 SHORT $LN24@Reserve@2
$LN23@Reserve@2:
  00048	03 d6		 add	 edx, esi
$LN24@Reserve@2:
  0004a	3b d0		 cmp	 edx, eax
  0004c	73 02		 jae	 SHORT $LN20@Reserve@2
  0004e	8b d0		 mov	 edx, eax
$LN20@Reserve@2:
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve
$LN1@Reserve@2:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1298 : 		}

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN33@Reserve@2:
?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve
; Function compile flags: /Ogtp
;	COMDAT ?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1292 : 		if (max_size() - _Count < _Size)

  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000c	57		 push	 edi
  0000d	2b c6		 sub	 eax, esi
  0000f	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00014	c1 f8 03	 sar	 eax, 3
  00017	2b fa		 sub	 edi, edx
  00019	3b f8		 cmp	 edi, eax
  0001b	73 0a		 jae	 SHORT $LN4@Reserve@3

; 1293 : 			_Xlen();

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00022	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve@3:
$LN4@Reserve@3:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	03 c2		 add	 eax, edx
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	2b d6		 sub	 edx, esi
  0002e	c1 fa 03	 sar	 edx, 3
  00031	3b c2		 cmp	 eax, edx
  00033	76 21		 jbe	 SHORT $LN1@Reserve@3

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00035	8b f2		 mov	 esi, edx
  00037	d1 ee		 shr	 esi, 1
  00039	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  0003e	2b fe		 sub	 edi, esi
  00040	3b fa		 cmp	 edi, edx
  00042	73 04		 jae	 SHORT $LN23@Reserve@3
  00044	33 d2		 xor	 edx, edx
  00046	eb 02		 jmp	 SHORT $LN24@Reserve@3
$LN23@Reserve@3:
  00048	03 d6		 add	 edx, esi
$LN24@Reserve@3:
  0004a	3b d0		 cmp	 edx, eax
  0004c	73 02		 jae	 SHORT $LN20@Reserve@3
  0004e	8b d0		 mov	 edx, eax
$LN20@Reserve@3:
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve
$LN1@Reserve@3:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1298 : 		}

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN33@Reserve@3:
?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve
_TEXT	ENDS
PUBLIC	??0_CHAOSCASTLE_DATA@@QAE@XZ			; _CHAOSCASTLE_DATA::_CHAOSCASTLE_DATA
; Function compile flags: /Ogtp
;	COMDAT ??0_CHAOSCASTLE_DATA@@QAE@XZ
_TEXT	SEGMENT
$T171360 = -16						; size = 12
$T171214 = -4						; size = 4
??0_CHAOSCASTLE_DATA@@QAE@XZ PROC			; _CHAOSCASTLE_DATA::_CHAOSCASTLE_DATA, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  0000d	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00012	33 db		 xor	 ebx, ebx
$LL5@CHAOSCASTL:
  00014	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0001a	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  0001d	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  00020	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  00023	88 58 10	 mov	 BYTE PTR [eax+16], bl
  00026	83 c0 14	 add	 eax, 20			; 00000014H
  00029	49		 dec	 ecx
  0002a	79 e8		 jns	 SHORT $LL5@CHAOSCASTL
  0002c	6a 1c		 push	 28			; 0000001cH
  0002e	89 9e 64 08 00
	00		 mov	 DWORD PTR [esi+2148], ebx
  00034	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00039	83 c4 04	 add	 esp, 4
  0003c	3b c3		 cmp	 eax, ebx
  0003e	74 36		 je	 SHORT $LN36@CHAOSCASTL
  00040	89 86 60 08 00
	00		 mov	 DWORD PTR [esi+2144], eax
  00046	89 00		 mov	 DWORD PTR [eax], eax
  00048	8b 86 60 08 00
	00		 mov	 eax, DWORD PTR [esi+2144]
  0004e	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00051	8b 86 60 08 00
	00		 mov	 eax, DWORD PTR [esi+2144]
  00057	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0005a	8b 86 60 08 00
	00		 mov	 eax, DWORD PTR [esi+2144]
  00060	c6 40 18 01	 mov	 BYTE PTR [eax+24], 1
  00064	8b 8e 60 08 00
	00		 mov	 ecx, DWORD PTR [esi+2144]
  0006a	8b c6		 mov	 eax, esi
  0006c	5e		 pop	 esi
  0006d	c6 41 19 01	 mov	 BYTE PTR [ecx+25], 1
  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
$LN36@CHAOSCASTL:
  00076	8d 55 fc	 lea	 edx, DWORD PTR $T171214[ebp]
  00079	52		 push	 edx
  0007a	8d 4d f0	 lea	 ecx, DWORD PTR $T171360[ebp]
  0007d	89 5d fc	 mov	 DWORD PTR $T171214[ebp], ebx
  00080	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00085	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0008a	8d 45 f0	 lea	 eax, DWORD PTR $T171360[ebp]
  0008d	50		 push	 eax
  0008e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T171360[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00095	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN63@CHAOSCASTL:
$LN62@CHAOSCASTL:
  0009a	cc		 int	 3
??0_CHAOSCASTLE_DATA@@QAE@XZ ENDP			; _CHAOSCASTLE_DATA::_CHAOSCASTLE_DATA
_TEXT	ENDS
PUBLIC	??1_CHAOSCASTLE_DATA@@QAE@XZ			; _CHAOSCASTLE_DATA::~_CHAOSCASTLE_DATA
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1_CHAOSCASTLE_DATA@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_CHAOSCASTLE_DATA@@QAE@XZ$2
__ehfuncinfo$??1_CHAOSCASTLE_DATA@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1_CHAOSCASTLE_DATA@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1_CHAOSCASTLE_DATA@@QAE@XZ
_TEXT	SEGMENT
$T171571 = -20						; size = 4
$T171603 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_CHAOSCASTLE_DATA@@QAE@XZ PROC			; _CHAOSCASTLE_DATA::~_CHAOSCASTLE_DATA, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_CHAOSCASTLE_DATA@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d b1 5c 08 00
	00		 lea	 esi, DWORD PTR [ecx+2140]
  0002c	89 75 f0	 mov	 DWORD PTR $T171603[ebp], esi
  0002f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	8d 45 ec	 lea	 eax, DWORD PTR $T171571[ebp]
  00039	50		 push	 eax
  0003a	8b ce		 mov	 ecx, esi
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
  00048	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00051	83 c4 04	 add	 esp, 4
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	5e		 pop	 esi
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_CHAOSCASTLE_DATA@@QAE@XZ$2:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T171603[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
__ehhandler$??1_CHAOSCASTLE_DATA@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_CHAOSCASTLE_DATA@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_CHAOSCASTLE_DATA@@QAE@XZ ENDP			; _CHAOSCASTLE_DATA::~_CHAOSCASTLE_DATA
PUBLIC	??_7CChaosCastle@@6B@				; CChaosCastle::`vftable'
PUBLIC	??1CChaosCastle@@UAE@XZ				; CChaosCastle::~CChaosCastle
PUBLIC	??_R4CChaosCastle@@6B@				; CChaosCastle::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCChaosCastle@@@8			; CChaosCastle `RTTI Type Descriptor'
PUBLIC	??_R3CChaosCastle@@8				; CChaosCastle::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CChaosCastle@@8				; CChaosCastle::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CChaosCastle@@8			; CChaosCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??_ECChaosCastle@@UAEPAXI@Z:PROC		; CChaosCastle::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CChaosCastle@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CChaosCastle@@8 DD FLAT:??_R0?AVCChaosCastle@@@8 ; CChaosCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CChaosCastle@@8
rdata$r	ENDS
;	COMDAT ??_R2CChaosCastle@@8
rdata$r	SEGMENT
??_R2CChaosCastle@@8 DD FLAT:??_R1A@?0A@EA@CChaosCastle@@8 ; CChaosCastle::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CChaosCastle@@8
rdata$r	SEGMENT
??_R3CChaosCastle@@8 DD 00H				; CChaosCastle::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CChaosCastle@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCChaosCastle@@@8
_DATA	SEGMENT
??_R0?AVCChaosCastle@@@8 DD FLAT:??_7type_info@@6B@	; CChaosCastle `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCChaosCastle@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CChaosCastle@@6B@
rdata$r	SEGMENT
??_R4CChaosCastle@@6B@ DD 00H				; CChaosCastle::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCChaosCastle@@@8
	DD	FLAT:??_R3CChaosCastle@@8
rdata$r	ENDS
;	COMDAT ??_7CChaosCastle@@6B@
CONST	SEGMENT
??_7CChaosCastle@@6B@ DD FLAT:??_R4CChaosCastle@@6B@	; CChaosCastle::`vftable'
	DD	FLAT:??_ECChaosCastle@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CChaosCastle@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CChaosCastle@@UAE@XZ$0
__ehfuncinfo$??1CChaosCastle@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CChaosCastle@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
xdata$x	ENDS
;	COMDAT ??1CChaosCastle@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CChaosCastle@@UAE@XZ PROC				; CChaosCastle::~CChaosCastle, COMDAT
; _this$ = ecx

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CChaosCastle@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CChaosCastle@@6B@

; 46   : 	for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)
; 47   : 	{
; 48   : 		// Empty
; 49   : 	}
; 50   : }

  00030	68 00 00 00 00	 push	 OFFSET ??1_CHAOSCASTLE_DATA@@QAE@XZ
  00035	6a 06		 push	 6
  00037	68 6c 08 00 00	 push	 2156			; 0000086cH
  0003c	8d 46 30	 lea	 eax, DWORD PTR [esi+48]
  0003f	33 ff		 xor	 edi, edi
  00041	50		 push	 eax
  00042	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00045	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0004a	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0004d	3b c7		 cmp	 eax, edi
  0004f	74 09		 je	 SHORT $LN15@CChaosCast
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00057	83 c4 04	 add	 esp, 4
$LN15@CChaosCast:
  0005a	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  0005d	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  00060	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  00063	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00066	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006d	59		 pop	 ecx
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CChaosCastle@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 20	 add	 ecx, 32			; 00000020H
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
__ehhandler$??1CChaosCastle@@UAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CChaosCastle@@UAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CChaosCastle@@UAE@XZ ENDP				; CChaosCastle::~CChaosCastle
PUBLIC	?push_back@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXABUCHAOSCASTLE_START_TIME@@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::push_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXABUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXABUCHAOSCASTLE_START_TIME@@@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 39		 jae	 SHORT $LN4@push_back@2
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 33		 ja	 SHORT $LN4@push_back@2

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 03	 sar	 edi, 3

; 980  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back@2

; 981  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve
$LN3@push_back@2:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002f	8d 0c f8	 lea	 ecx, DWORD PTR [eax+edi*8]
  00032	51		 push	 ecx
  00033	52		 push	 edx
  00034	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00040	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN4@push_back@2:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0004a	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0004d	75 09		 jne	 SHORT $LN1@push_back@2

; 991  : 				_Reserve(1);

  0004f	6a 01		 push	 1
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve
$LN1@push_back@2:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00058	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005b	57		 push	 edi
  0005c	51		 push	 ecx
  0005d	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00069	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?push_back@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXABUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::push_back
; Function compile flags: /Ogtp
;	COMDAT ?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 39		 jae	 SHORT $LN4@push_back@3
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 33		 ja	 SHORT $LN4@push_back@3

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 03	 sar	 edi, 3

; 980  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back@3

; 981  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve
$LN3@push_back@3:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002f	8d 0c f8	 lea	 ecx, DWORD PTR [eax+edi*8]
  00032	51		 push	 ecx
  00033	52		 push	 edx
  00034	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00040	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN4@push_back@3:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0004a	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0004d	75 09		 jne	 SHORT $LN1@push_back@3

; 991  : 				_Reserve(1);

  0004f	6a 01		 push	 1
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve
$LN1@push_back@3:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00058	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005b	57		 push	 edi
  0005c	51		 push	 ecx
  0005d	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00069	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::push_back
_TEXT	ENDS
PUBLIC	??0CChaosCastle@@QAE@XZ				; CChaosCastle::CChaosCastle
EXTRN	_srand:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
xdata$x	SEGMENT
__unwindtable$??0CChaosCastle@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CChaosCastle@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CChaosCastle@@QAE@XZ$1
__ehfuncinfo$??0CChaosCastle@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CChaosCastle@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
xdata$x	ENDS
;	COMDAT ??0CChaosCastle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CChaosCastle@@QAE@XZ PROC				; CChaosCastle::CChaosCastle, COMDAT
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CChaosCastle@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f9		 mov	 edi, ecx
  00028	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002b	33 db		 xor	 ebx, ebx
  0002d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CChaosCastle@@6B@
  00033	89 5f 20	 mov	 DWORD PTR [edi+32], ebx
  00036	89 5f 24	 mov	 DWORD PTR [edi+36], ebx
  00039	89 5f 28	 mov	 DWORD PTR [edi+40], ebx
  0003c	68 00 00 00 00	 push	 OFFSET ??1_CHAOSCASTLE_DATA@@QAE@XZ
  00041	68 00 00 00 00	 push	 OFFSET ??0_CHAOSCASTLE_DATA@@QAE@XZ
  00046	6a 06		 push	 6
  00048	68 6c 08 00 00	 push	 2156			; 0000086cH
  0004d	8d 47 30	 lea	 eax, DWORD PTR [edi+48]
  00050	50		 push	 eax
  00051	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00054	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  00059	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 25   : 	this->m_bCC_EVENT_ENABLE = FALSE;

  0005d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 26   : 	this->m_iCC_TIME_MIN_OPEN = 10;

  00060	c7 47 08 0a 00
	00 00		 mov	 DWORD PTR [edi+8], 10	; 0000000aH

; 27   : 	this->m_iCC_NORMAL_ITEM_DROP = 100;

  00067	c7 47 14 64 00
	00 00		 mov	 DWORD PTR [edi+20], 100	; 00000064H

; 28   : 	this->m_iCC_EXCEL_ITEM_DROP = 1200;

  0006e	c7 47 18 b0 04
	00 00		 mov	 DWORD PTR [edi+24], 1200 ; 000004b0H

; 29   : 	this->m_iCC_MONSTER_REGEN = 0;

  00075	89 5f 1c	 mov	 DWORD PTR [edi+28], ebx
  00078	8d 77 34	 lea	 esi, DWORD PTR [edi+52]
  0007b	eb 03 8d 49 00	 npad	 5
$LL3@CChaosCast@2:

; 30   : 
; 31   : 	for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)
; 32   : 	{
; 33   : 		this->m_stChaosCastleData[i].m_iCC_STATE = CC_STATE_NONE;
; 34   : 		this->m_stChaosCastleData[i].m_iMapNumber = i + MAP_INDEX_CHAOSCASTLE1;

  00080	8d 4b 12	 lea	 ecx, DWORD PTR [ebx+18]

; 35   : 		this->m_stChaosCastleData[i].m_iChaosCastleIndex = i;
; 36   : 		this->m_stChaosCastleData[i].m_iCC_REMAIN_MSEC = -1;

  00083	83 c8 ff	 or	 eax, -1
  00086	89 0e		 mov	 DWORD PTR [esi], ecx

; 37   : 		this->m_stChaosCastleData[i].m_iCC_TICK_COUNT = -1;
; 38   : 		this->ClearChaosCastleData(i);

  00088	53		 push	 ebx
  00089	8b cf		 mov	 ecx, edi
  0008b	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0
  00092	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00095	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00098	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0009b	e8 00 00 00 00	 call	 ?ClearChaosCastleData@CChaosCastle@@IAEXH@Z ; CChaosCastle::ClearChaosCastleData
  000a0	43		 inc	 ebx
  000a1	81 c6 6c 08 00
	00		 add	 esi, 2156		; 0000086cH
  000a7	83 fb 06	 cmp	 ebx, 6
  000aa	7c d4		 jl	 SHORT $LL3@CChaosCast@2

; 39   : 	}
; 40   : 
; 41   : 	srand(time(NULL));

  000ac	6a 00		 push	 0
  000ae	e8 00 00 00 00	 call	 __time64
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _srand
  000b9	83 c4 08	 add	 esp, 8

; 42   : }

  000bc	8b c7		 mov	 eax, edi
  000be	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c8	59		 pop	 ecx
  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CChaosCastle@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 20	 add	 ecx, 32			; 00000020H
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
__unwindfunclet$??0CChaosCastle@@QAE@XZ$1:
  0000b	68 00 00 00 00	 push	 OFFSET ??1_CHAOSCASTLE_DATA@@QAE@XZ
  00010	6a 06		 push	 6
  00012	68 6c 08 00 00	 push	 2156			; 0000086cH
  00017	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 c0 30	 add	 eax, 48			; 00000030H
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00023	c3		 ret	 0
__ehhandler$??0CChaosCastle@@QAE@XZ:
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002b	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CChaosCastle@@QAE@XZ
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CChaosCastle@@QAE@XZ ENDP				; CChaosCastle::CChaosCastle
; Function compile flags: /Ogtp
;	COMDAT ??_GCChaosCastle@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCChaosCastle@@UAEPAXI@Z PROC			; CChaosCastle::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CChaosCastle@@UAE@XZ	; CChaosCastle::~CChaosCastle
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@2:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCChaosCastle@@UAEPAXI@Z ENDP			; CChaosCastle::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CI@HJPKEJEN@?$FLChaos?5Castle?$FN?5Info?5file?5Load?5Fa@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?Load@CChaosCastle@@QAEXPAD@Z			; CChaosCastle::Load
EXTRN	_fclose:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HJPKEJEN@?$FLChaos?5Castle?$FN?5Info?5file?5Load?5Fa@
CONST	SEGMENT
??_C@_0CI@HJPKEJEN@?$FLChaos?5Castle?$FN?5Info?5file?5Load?5Fa@ DB '[Chao'
	DB	's Castle] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
CONST	ENDS
;	COMDAT ?Load@CChaosCastle@@QAEXPAD@Z
_TEXT	SEGMENT
_Schedule$157715 = -16					; size = 8
_type$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?Load@CChaosCastle@@QAEXPAD@Z PROC			; CChaosCastle::Load, COMDAT
; _this$ = ecx

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 148  : 	SMDFile = fopen(filename, "r");

  00008	8b 7d 08	 mov	 edi, DWORD PTR _filename$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00012	57		 push	 edi
  00013	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00016	e8 00 00 00 00	 call	 _fopen
  0001b	83 c4 08	 add	 esp, 8
  0001e	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 149  : 
; 150  : 	if ( SMDFile == NULL )

  00023	85 c0		 test	 eax, eax
  00025	75 16		 jne	 SHORT $LN17@Load

; 151  : 	{
; 152  : 		MsgBox("[Chaos Castle] Info file Load Fail [%s]", filename);

  00027	57		 push	 edi
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HJPKEJEN@?$FLChaos?5Castle?$FN?5Info?5file?5Load?5Fa@
  0002d	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00032	83 c4 08	 add	 esp, 8
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi

; 245  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN17@Load:

; 153  : 		return;
; 154  : 	}
; 155  : 
; 156  : 	int Token;
; 157  : 	int type = -1;
; 158  : 	int iChaosCastleCount = -1;
; 159  : 
; 160  : 	this->m_vtChaosCastleOpenTime.erase( this->m_vtChaosCastleOpenTime.begin(), this->m_vtChaosCastleOpenTime.end());

  0003d	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00040	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00043	8d 7e 20	 lea	 edi, DWORD PTR [esi+32]
  00046	53		 push	 ebx
  00047	3b c8		 cmp	 ecx, eax
  00049	74 1e		 je	 SHORT $LN158@Load
  0004b	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004e	3b c2		 cmp	 eax, edx
  00050	74 14		 je	 SHORT $LN65@Load
$LL67@Load:
  00052	8b 18		 mov	 ebx, DWORD PTR [eax]
  00054	89 19		 mov	 DWORD PTR [ecx], ebx
  00056	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00059	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  0005c	83 c0 08	 add	 eax, 8
  0005f	83 c1 08	 add	 ecx, 8
  00062	3b c2		 cmp	 eax, edx
  00064	75 ec		 jne	 SHORT $LL67@Load
$LN65@Load:
  00066	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
$LN158@Load:

; 161  : 
; 162  : 	while ( true )
; 163  : 	{
; 164  : 		Token = GetToken();

  00069	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 165  : 
; 166  : 		if ( Token == 2 )

  0006e	83 f8 02	 cmp	 eax, 2
  00071	0f 84 e1 02 00
	00		 je	 $LN167@Load
  00077	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL16@Load:

; 167  : 		{
; 168  : 			break;
; 169  : 		}
; 170  : 
; 171  : 		type = TokenNumber;

  00080	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00086	e8 00 00 00 00	 call	 __ftol2_sse
  0008b	8b d8		 mov	 ebx, eax
  0008d	89 5d f8	 mov	 DWORD PTR _type$[ebp], ebx
$LL13@Load:

; 172  : 
; 173  : 		while ( true )
; 174  : 		{
; 175  : 			if ( type == 0 )	// Time Setting

  00090	85 db		 test	 ebx, ebx
  00092	75 72		 jne	 SHORT $LN11@Load

; 176  : 			{
; 177  : 				Token = GetToken();

  00094	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 178  : 
; 179  : 				if ( strcmp("end", TokenString) == 0 )

  00099	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  0009e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL170@Load:
  000a3	8a 10		 mov	 dl, BYTE PTR [eax]
  000a5	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000a7	75 1a		 jne	 SHORT $LN171@Load
  000a9	84 d2		 test	 dl, dl
  000ab	74 12		 je	 SHORT $LN172@Load
  000ad	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000b0	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000b3	75 0e		 jne	 SHORT $LN171@Load
  000b5	83 c0 02	 add	 eax, 2
  000b8	83 c1 02	 add	 ecx, 2
  000bb	84 d2		 test	 dl, dl
  000bd	75 e4		 jne	 SHORT $LL170@Load
$LN172@Load:
  000bf	33 c0		 xor	 eax, eax
  000c1	eb 05		 jmp	 SHORT $LN173@Load
$LN171@Load:
  000c3	1b c0		 sbb	 eax, eax
  000c5	83 d8 ff	 sbb	 eax, -1
$LN173@Load:
  000c8	85 c0		 test	 eax, eax
  000ca	0f 84 7a 02 00
	00		 je	 $LN161@Load

; 180  : 				{
; 181  : 					break;
; 182  : 				}
; 183  : 
; 184  : 				this->m_iCC_TIME_MIN_OPEN = TokenNumber;

  000d0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000d6	e8 00 00 00 00	 call	 __ftol2_sse
  000db	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 185  : 
; 186  : 				Token = GetToken();

  000de	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 187  : 				this->m_iCC_TIME_MIN_PLAY = TokenNumber;

  000e3	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000e9	e8 00 00 00 00	 call	 __ftol2_sse
  000ee	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 188  : 
; 189  : 				Token = GetToken();

  000f1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 190  : 				this->m_iCC_TIME_MIN_REST = TokenNumber;

  000f6	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000fc	e8 00 00 00 00	 call	 __ftol2_sse
  00101	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00104	eb 8a		 jmp	 SHORT $LL13@Load
$LN11@Load:

; 191  : 			}
; 192  : 			else if ( type == 1 ) // Drops

  00106	83 fb 01	 cmp	 ebx, 1
  00109	75 7b		 jne	 SHORT $LN8@Load

; 193  : 			{
; 194  : 				Token = GetToken();

  0010b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 195  : 
; 196  : 				if ( strcmp("end", TokenString) == 0 )

  00110	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00115	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0011a	8d 9b 00 00 00
	00		 npad	 6
$LL174@Load:
  00120	8a 10		 mov	 dl, BYTE PTR [eax]
  00122	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00124	75 1a		 jne	 SHORT $LN175@Load
  00126	84 d2		 test	 dl, dl
  00128	74 12		 je	 SHORT $LN176@Load
  0012a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0012d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00130	75 0e		 jne	 SHORT $LN175@Load
  00132	83 c0 02	 add	 eax, 2
  00135	83 c1 02	 add	 ecx, 2
  00138	84 d2		 test	 dl, dl
  0013a	75 e4		 jne	 SHORT $LL174@Load
$LN176@Load:
  0013c	33 c0		 xor	 eax, eax
  0013e	eb 05		 jmp	 SHORT $LN177@Load
$LN175@Load:
  00140	1b c0		 sbb	 eax, eax
  00142	83 d8 ff	 sbb	 eax, -1
$LN177@Load:
  00145	85 c0		 test	 eax, eax
  00147	0f 84 fd 01 00
	00		 je	 $LN161@Load

; 197  : 				{
; 198  : 					break;
; 199  : 				}
; 200  : 
; 201  : 				this->m_iCC_NORMAL_ITEM_DROP = TokenNumber;

  0014d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00153	e8 00 00 00 00	 call	 __ftol2_sse
  00158	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 202  : 
; 203  : 				Token = GetToken();

  0015b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 204  : 				this->m_iCC_EXCEL_ITEM_DROP = TokenNumber;

  00160	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00166	e8 00 00 00 00	 call	 __ftol2_sse
  0016b	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 205  : 
; 206  : 				Token = GetToken();

  0016e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 207  : 				this->m_iCC_MONSTER_REGEN = TokenNumber;

  00173	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00179	e8 00 00 00 00	 call	 __ftol2_sse
  0017e	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00181	e9 0a ff ff ff	 jmp	 $LL13@Load
$LN8@Load:

; 208  : 			}
; 209  : 			else if ( type == 2 ) // Schedule

  00186	83 fb 02	 cmp	 ebx, 2
  00189	0f 85 45 01 00
	00		 jne	 $LN5@Load

; 210  : 			{
; 211  : 				Token = GetToken();

  0018f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 212  : 
; 213  : 				if ( strcmp("end", TokenString) == 0 )

  00194	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00199	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0019e	8b ff		 npad	 2
$LL178@Load:
  001a0	8a 10		 mov	 dl, BYTE PTR [eax]
  001a2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001a4	75 1a		 jne	 SHORT $LN179@Load
  001a6	84 d2		 test	 dl, dl
  001a8	74 12		 je	 SHORT $LN180@Load
  001aa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001ad	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001b0	75 0e		 jne	 SHORT $LN179@Load
  001b2	83 c0 02	 add	 eax, 2
  001b5	83 c1 02	 add	 ecx, 2
  001b8	84 d2		 test	 dl, dl
  001ba	75 e4		 jne	 SHORT $LL178@Load
$LN180@Load:
  001bc	33 c0		 xor	 eax, eax
  001be	eb 05		 jmp	 SHORT $LN181@Load
$LN179@Load:
  001c0	1b c0		 sbb	 eax, eax
  001c2	83 d8 ff	 sbb	 eax, -1
$LN181@Load:
  001c5	85 c0		 test	 eax, eax
  001c7	0f 84 7d 01 00
	00		 je	 $LN161@Load

; 214  : 				{
; 215  : 					break;
; 216  : 				}
; 217  : 				
; 218  : 				CHAOSCASTLE_START_TIME Schedule;
; 219  : 
; 220  : 				Schedule.m_iHour = TokenNumber;

  001cd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001d3	e8 00 00 00 00	 call	 __ftol2_sse
  001d8	89 45 f0	 mov	 DWORD PTR _Schedule$157715[ebp], eax

; 221  : 
; 222  : 				Token = GetToken();

  001db	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 223  : 				Schedule.m_iMinute = TokenNumber;

  001e0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001e6	e8 00 00 00 00	 call	 __ftol2_sse
  001eb	89 45 f4	 mov	 DWORD PTR _Schedule$157715[ebp+4], eax

; 224  : 
; 225  : 				this->m_vtChaosCastleOpenTime.push_back(Schedule);

  001ee	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001f1	8d 4d f0	 lea	 ecx, DWORD PTR _Schedule$157715[ebp]
  001f4	3b c8		 cmp	 ecx, eax
  001f6	73 76		 jae	 SHORT $LN75@Load
  001f8	8b 17		 mov	 edx, DWORD PTR [edi]
  001fa	3b d1		 cmp	 edx, ecx
  001fc	77 70		 ja	 SHORT $LN75@Load
  001fe	8b f1		 mov	 esi, ecx
  00200	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00203	2b f2		 sub	 esi, edx
  00205	c1 fe 03	 sar	 esi, 3
  00208	3b c1		 cmp	 eax, ecx
  0020a	75 40		 jne	 SHORT $LN86@Load
  0020c	2b c2		 sub	 eax, edx
  0020e	c1 f8 03	 sar	 eax, 3
  00211	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  00216	0f 87 64 01 00
	00		 ja	 $LN164@Load
  0021c	2b ca		 sub	 ecx, edx
  0021e	40		 inc	 eax
  0021f	c1 f9 03	 sar	 ecx, 3
  00222	3b c1		 cmp	 eax, ecx
  00224	76 26		 jbe	 SHORT $LN86@Load
  00226	8b d1		 mov	 edx, ecx
  00228	d1 ea		 shr	 edx, 1
  0022a	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  0022f	2b da		 sub	 ebx, edx
  00231	3b d9		 cmp	 ebx, ecx
  00233	73 04		 jae	 SHORT $LN108@Load
  00235	33 c9		 xor	 ecx, ecx
  00237	eb 02		 jmp	 SHORT $LN109@Load
$LN108@Load:
  00239	03 ca		 add	 ecx, edx
$LN109@Load:
  0023b	3b c8		 cmp	 ecx, eax
  0023d	73 02		 jae	 SHORT $LN105@Load
  0023f	8b c8		 mov	 ecx, eax
$LN105@Load:
  00241	51		 push	 ecx
  00242	8b cf		 mov	 ecx, edi
  00244	e8 00 00 00 00	 call	 ?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve
  00249	8b 5d f8	 mov	 ebx, DWORD PTR _type$[ebp]
$LN86@Load:
  0024c	8b 17		 mov	 edx, DWORD PTR [edi]
  0024e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00251	8d 04 f2	 lea	 eax, DWORD PTR [edx+esi*8]
  00254	50		 push	 eax
  00255	51		 push	 ecx
  00256	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]
  00259	52		 push	 edx
  0025a	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>
  0025f	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH
  00265	83 47 04 08	 add	 DWORD PTR [edi+4], 8
  00269	e9 22 fe ff ff	 jmp	 $LL13@Load
$LN75@Load:
  0026e	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00271	3b c1		 cmp	 eax, ecx
  00273	75 42		 jne	 SHORT $LN121@Load
  00275	8b 17		 mov	 edx, DWORD PTR [edi]
  00277	2b c2		 sub	 eax, edx
  00279	c1 f8 03	 sar	 eax, 3
  0027c	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  00281	0f 87 f9 00 00
	00		 ja	 $LN164@Load
  00287	2b ca		 sub	 ecx, edx
  00289	40		 inc	 eax
  0028a	c1 f9 03	 sar	 ecx, 3
  0028d	3b c1		 cmp	 eax, ecx
  0028f	76 26		 jbe	 SHORT $LN121@Load
  00291	8b d1		 mov	 edx, ecx
  00293	d1 ea		 shr	 edx, 1
  00295	be ff ff ff 1f	 mov	 esi, 536870911		; 1fffffffH
  0029a	2b f2		 sub	 esi, edx
  0029c	3b f1		 cmp	 esi, ecx
  0029e	73 04		 jae	 SHORT $LN143@Load
  002a0	33 c9		 xor	 ecx, ecx
  002a2	eb 02		 jmp	 SHORT $LN144@Load
$LN143@Load:
  002a4	03 ca		 add	 ecx, edx
$LN144@Load:
  002a6	3b c8		 cmp	 ecx, eax
  002a8	73 02		 jae	 SHORT $LN140@Load
  002aa	8b c8		 mov	 ecx, eax
$LN140@Load:
  002ac	51		 push	 ecx
  002ad	8b cf		 mov	 ecx, edi
  002af	e8 00 00 00 00	 call	 ?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve
  002b4	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
$LN121@Load:
  002b7	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  002ba	8d 45 f0	 lea	 eax, DWORD PTR _Schedule$157715[ebp]
  002bd	50		 push	 eax
  002be	51		 push	 ecx
  002bf	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]
  002c2	52		 push	 edx
  002c3	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
  002c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002cb	83 47 04 08	 add	 DWORD PTR [edi+4], 8
  002cf	e9 bc fd ff ff	 jmp	 $LL13@Load
$LN5@Load:

; 226  : 			}
; 227  : 			else if ( type == 3 ) // ItemDropProb

  002d4	83 fb 03	 cmp	 ebx, 3
  002d7	0f 85 b3 fd ff
	ff		 jne	 $LL13@Load

; 228  : 			{
; 229  : 				Token = GetToken();

  002dd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 230  : 
; 231  : 				if ( strcmp("end", TokenString) == 0 )

  002e2	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  002e7	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  002ec	8d 64 24 00	 npad	 4
$LL182@Load:
  002f0	8a 10		 mov	 dl, BYTE PTR [eax]
  002f2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  002f4	75 1a		 jne	 SHORT $LN183@Load
  002f6	84 d2		 test	 dl, dl
  002f8	74 12		 je	 SHORT $LN184@Load
  002fa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  002fd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00300	75 0e		 jne	 SHORT $LN183@Load
  00302	83 c0 02	 add	 eax, 2
  00305	83 c1 02	 add	 ecx, 2
  00308	84 d2		 test	 dl, dl
  0030a	75 e4		 jne	 SHORT $LL182@Load
$LN184@Load:
  0030c	33 c0		 xor	 eax, eax
  0030e	eb 05		 jmp	 SHORT $LN185@Load
$LN183@Load:
  00310	1b c0		 sbb	 eax, eax
  00312	83 d8 ff	 sbb	 eax, -1
$LN185@Load:
  00315	85 c0		 test	 eax, eax
  00317	74 31		 je	 SHORT $LN161@Load

; 232  : 				{
; 233  : 					break;
; 234  : 				}
; 235  : 		
; 236  : 				g_iChaosCastle_OffLineGiftRate = TokenNumber;

  00319	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0031f	e8 00 00 00 00	 call	 __ftol2_sse
  00324	8b c8		 mov	 ecx, eax

; 237  : 				g_iChaosCastle_OffLineGiftRate %= 10000;

  00326	b8 53 74 24 97	 mov	 eax, -1759218605	; 97247453H
  0032b	f7 e9		 imul	 ecx
  0032d	c1 fa 0c	 sar	 edx, 12			; 0000000cH
  00330	8b c2		 mov	 eax, edx
  00332	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00335	03 c2		 add	 eax, edx
  00337	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  0033d	03 c8		 add	 ecx, eax
  0033f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?g_iChaosCastle_OffLineGiftRate@@3HA, ecx ; g_iChaosCastle_OffLineGiftRate

; 238  : 			}
; 239  : 		}

  00345	e9 46 fd ff ff	 jmp	 $LL13@Load
$LN161@Load:

; 161  : 
; 162  : 	while ( true )
; 163  : 	{
; 164  : 		Token = GetToken();

  0034a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 165  : 
; 166  : 		if ( Token == 2 )

  0034f	83 f8 02	 cmp	 eax, 2
  00352	0f 85 28 fd ff
	ff		 jne	 $LL16@Load
$LN167@Load:

; 240  : 	}
; 241  : 
; 242  : 	fclose(SMDFile);

  00358	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  0035e	51		 push	 ecx
  0035f	e8 00 00 00 00	 call	 _fclose

; 243  : 
; 244  : 	LogAdd(LOG_BLACK, "%s file load!", filename);

  00364	8b 55 08	 mov	 edx, DWORD PTR _filename$[ebp]
  00367	52		 push	 edx
  00368	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  0036d	6a 00		 push	 0
  0036f	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00374	83 c4 10	 add	 esp, 16			; 00000010H
  00377	5b		 pop	 ebx
  00378	5f		 pop	 edi
  00379	5e		 pop	 esi

; 245  : }

  0037a	8b e5		 mov	 esp, ebp
  0037c	5d		 pop	 ebp
  0037d	c2 04 00	 ret	 4
$LN164@Load:

; 224  : 
; 225  : 				this->m_vtChaosCastleOpenTime.push_back(Schedule);

  00380	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00385	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN187@Load:
$LN186@Load:
  0038a	cc		 int	 3
?Load@CChaosCastle@@QAEXPAD@Z ENDP			; CChaosCastle::Load
_TEXT	ENDS
PUBLIC	_iChaosCastleIndex$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z	; CChaosCastle::PullObjInnerPlace
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z$0
__ehfuncinfo$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
xdata$x	ENDS
;	COMDAT ?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -108					; size = 4
_iPT$158237 = -104					; size = 8
tv1637 = -100						; size = 4
tv532 = -100						; size = 4
_iUSER_AXIS$ = -96					; size = 4
_iChaosCastleIndex$GSCopy$ = -92			; size = 4
tv1522 = -88						; size = 4
tv792 = -88						; size = 4
tv167 = -88						; size = 4
_vtMAP_UNTRAP$ = -80					; size = 64
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iChaosCastleIndex$ = 8					; size = 4
_iTRAP_STEP$ = 12					; size = 4
?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::PullObjInnerPlace, COMDAT
; _this$ = ecx

; 615  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]

; 616  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0002e	33 ff		 xor	 edi, edi
  00030	89 4d 94	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx

; 629  : 	{
; 630  : 		for ( int iMAPX = g_rtPOINT_TRAP[iAXIS].left ; iMAPX <= g_rtPOINT_TRAP[iAXIS].right ; iMAPX ++ )

  00033	89 75 a4	 mov	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], esi
  00036	3b f7		 cmp	 esi, edi
  00038	0f 8c 7d 03 00
	00		 jl	 $LN47@PullObjInn

; 616  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0003e	33 c0		 xor	 eax, eax
  00040	83 fe 05	 cmp	 esi, 5
  00043	0f 9e c0	 setle	 al
  00046	3b c7		 cmp	 eax, edi
  00048	0f 84 6d 03 00
	00		 je	 $LN47@PullObjInn

; 617  : 		return;
; 618  : 
; 619  : 	if ( CC_TRAP_STEP_RANGE(iTRAP_STEP) == FALSE )

  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _iTRAP_STEP$[ebp]
  00051	3b cf		 cmp	 ecx, edi
  00053	0f 8c 62 03 00
	00		 jl	 $LN47@PullObjInn
  00059	33 c0		 xor	 eax, eax
  0005b	83 f9 03	 cmp	 ecx, 3
  0005e	0f 9e c0	 setle	 al
  00061	3b c7		 cmp	 eax, edi
  00063	0f 84 52 03 00
	00		 je	 $LN47@PullObjInn

; 620  : 		return;
; 621  : 
; 622  : 	if ( iTRAP_STEP == 0 )

  00069	3b cf		 cmp	 ecx, edi
  0006b	0f 84 4a 03 00
	00		 je	 $LN47@PullObjInn

; 623  : 		return;
; 624  : 
; 625  : 	int iUSER_AXIS = 0;
; 626  : 	std::vector<POINT> vtMAP_UNTRAP[MAX_CC_TRAP_STEP];

  00071	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  00076	68 00 00 00 00	 push	 OFFSET ??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >
  0007b	6a 04		 push	 4
  0007d	6a 10		 push	 16			; 00000010H
  0007f	8d 45 b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  00082	50		 push	 eax
  00083	89 7d a0	 mov	 DWORD PTR _iUSER_AXIS$[ebp], edi
  00086	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  0008b	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  0008e	8b ff		 npad	 2
$LL43@PullObjInn:

; 629  : 	{
; 630  : 		for ( int iMAPX = g_rtPOINT_TRAP[iAXIS].left ; iMAPX <= g_rtPOINT_TRAP[iAXIS].right ; iMAPX ++ )

  00090	8b 9f 00 00 00
	00		 mov	 ebx, DWORD PTR _g_rtPOINT_TRAP[edi]
  00096	3b 9f 08 00 00
	00		 cmp	 ebx, DWORD PTR _g_rtPOINT_TRAP[edi+8]
  0009c	7f 58		 jg	 SHORT $LN42@PullObjInn
  0009e	8b ff		 npad	 2
$LL40@PullObjInn:

; 631  : 		{
; 632  : 			for ( int iMAPY = g_rtPOINT_TRAP[iAXIS].top ; iMAPY <= g_rtPOINT_TRAP[iAXIS].bottom ; iMAPY++ )

  000a0	8b b7 04 00 00
	00		 mov	 esi, DWORD PTR _g_rtPOINT_TRAP[edi+4]
  000a6	3b b7 0c 00 00
	00		 cmp	 esi, DWORD PTR _g_rtPOINT_TRAP[edi+12]
  000ac	7f 3c		 jg	 SHORT $LN39@PullObjInn
  000ae	8b 4d a4	 mov	 ecx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  000b1	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H

; 640  : 				}
; 641  : 			}
; 642  : 		}
; 643  : 	}
; 644  : 
; 645  : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  000b7	8d 91 90 7e 5a
	00		 lea	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+5930640]
  000bd	89 55 a8	 mov	 DWORD PTR tv792[ebp], edx
$LN37@PullObjInn:

; 633  : 			{
; 634  : 				BYTE btMapAttr = MapC[iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1].GetAttr(iMAPX, iMAPY);

  000c0	8b 4d a8	 mov	 ecx, DWORD PTR tv792[ebp]
  000c3	56		 push	 esi
  000c4	53		 push	 ebx
  000c5	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 635  : 
; 636  : 				if ( (btMapAttr&2) != 2 && (btMapAttr&4) != 4 && (btMapAttr&8) != 8 ) 

  000ca	a8 0e		 test	 al, 14			; 0000000eH
  000cc	75 13		 jne	 SHORT $LN36@PullObjInn

; 637  : 				{
; 638  : 					POINT iPT = {iMAPX, iMAPY};
; 639  : 					vtMAP_UNTRAP[iAXIS].push_back(iPT);

  000ce	8d 45 98	 lea	 eax, DWORD PTR _iPT$158237[ebp]
  000d1	50		 push	 eax
  000d2	8d 4c 3d b0	 lea	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+edi]
  000d6	89 5d 98	 mov	 DWORD PTR _iPT$158237[ebp], ebx
  000d9	89 75 9c	 mov	 DWORD PTR _iPT$158237[ebp+4], esi
  000dc	e8 00 00 00 00	 call	 ?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::push_back
$LN36@PullObjInn:

; 631  : 		{
; 632  : 			for ( int iMAPY = g_rtPOINT_TRAP[iAXIS].top ; iMAPY <= g_rtPOINT_TRAP[iAXIS].bottom ; iMAPY++ )

  000e1	46		 inc	 esi
  000e2	3b b7 0c 00 00
	00		 cmp	 esi, DWORD PTR _g_rtPOINT_TRAP[edi+12]
  000e8	7e d6		 jle	 SHORT $LN37@PullObjInn
$LN39@PullObjInn:

; 629  : 	{
; 630  : 		for ( int iMAPX = g_rtPOINT_TRAP[iAXIS].left ; iMAPX <= g_rtPOINT_TRAP[iAXIS].right ; iMAPX ++ )

  000ea	43		 inc	 ebx
  000eb	3b 9f 08 00 00
	00		 cmp	 ebx, DWORD PTR _g_rtPOINT_TRAP[edi+8]
  000f1	7e ad		 jle	 SHORT $LL40@PullObjInn
  000f3	8b 75 a4	 mov	 esi, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
$LN42@PullObjInn:

; 627  : 
; 628  : 	for ( int iAXIS = 0; iAXIS < MAX_CC_TRAP_STEP ; iAXIS++)

  000f6	83 c7 10	 add	 edi, 16			; 00000010H
  000f9	83 ff 40	 cmp	 edi, 64			; 00000040H
  000fc	7c 92		 jl	 SHORT $LL43@PullObjInn

; 640  : 				}
; 641  : 			}
; 642  : 		}
; 643  : 	}
; 644  : 
; 645  : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  000fe	69 f6 6c 08 00
	00		 imul	 esi, 2156		; 0000086cH
  00104	03 75 94	 add	 esi, DWORD PTR _this$GSCopy$[ebp]
  00107	c7 45 9c 46 00
	00 00		 mov	 DWORD PTR tv532[ebp], 70 ; 00000046H
  0010e	89 75 a8	 mov	 DWORD PTR tv1522[ebp], esi
  00111	83 c6 6c	 add	 esi, 108		; 0000006cH
$LL33@PullObjInn:

; 646  : 	{
; 647  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	83 f8 ff	 cmp	 eax, -1
  00119	0f 84 e2 00 00
	00		 je	 $LN32@PullObjInn

; 648  : 		{
; 649  : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) ==TRUE && gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == (iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1) )

  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00125	83 c4 04	 add	 esp, 4
  00128	83 f8 01	 cmp	 eax, 1
  0012b	0f 85 d0 00 00
	00		 jne	 $LN32@PullObjInn
  00131	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00133	8b 7d a4	 mov	 edi, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  00136	8b d3		 mov	 edx, ebx
  00138	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  0013e	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+265]
  00145	8d 4f 12	 lea	 ecx, DWORD PTR [edi+18]
  00148	3b c1		 cmp	 eax, ecx
  0014a	0f 85 b1 00 00
	00		 jne	 $LN32@PullObjInn

; 650  : 			{
; 651  : 				int iSX = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].X;

  00150	8b c3		 mov	 eax, ebx

; 652  : 				int iSY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Y;
; 653  : 				BYTE btMapAttr = MapC[iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1].m_attrbuf[iSY * 256 + iSX] & 0x08;

  00152	69 ff 08 07 05
	00		 imul	 edi, 329480		; 00050708H
  00158	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0015e	0f bf 90 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  00165	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  0016c	8b c2		 mov	 eax, edx
  0016e	c1 e0 08	 shl	 eax, 8
  00171	03 87 a0 7e 5a
	00		 add	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[edi+5930656]
  00177	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  0017a	24 08		 and	 al, 8

; 654  : 
; 655  : 				if ( btMapAttr == 8 )

  0017c	0f 84 7f 00 00
	00		 je	 $LN32@PullObjInn

; 656  : 				{
; 657  : 					int n = 0;
; 658  : 					for ( int n=0;n<MAX_CC_TRAP_STEP;n++)

  00182	33 ff		 xor	 edi, edi
  00184	b8 08 00 00 00	 mov	 eax, OFFSET _g_rtPOINT_FRAME+8
  00189	8d a4 24 00 00
	00 00		 npad	 7
$LL27@PullObjInn:

; 659  : 					{
; 660  : 						if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right &&
; 661  : 							 iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  00190	3b 48 f8	 cmp	 ecx, DWORD PTR [eax-8]
  00193	7c 0e		 jl	 SHORT $LN26@PullObjInn
  00195	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00197	7f 0a		 jg	 SHORT $LN26@PullObjInn
  00199	3b 50 fc	 cmp	 edx, DWORD PTR [eax-4]
  0019c	7c 05		 jl	 SHORT $LN26@PullObjInn
  0019e	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  001a1	7e 0d		 jle	 SHORT $LN130@PullObjInn
$LN26@PullObjInn:

; 656  : 				{
; 657  : 					int n = 0;
; 658  : 					for ( int n=0;n<MAX_CC_TRAP_STEP;n++)

  001a3	83 c0 10	 add	 eax, 16			; 00000010H
  001a6	47		 inc	 edi
  001a7	3d 48 00 00 00	 cmp	 eax, OFFSET _g_rtPOINT_FRAME+72
  001ac	7c e2		 jl	 SHORT $LL27@PullObjInn

; 709  : 				{
; 710  : 					if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right &&
; 711  : 						 iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  001ae	eb 03		 jmp	 SHORT $LN140@PullObjInn
$LN130@PullObjInn:

; 662  : 						{
; 663  : 							iUSER_AXIS = n;

  001b0	89 7d a0	 mov	 DWORD PTR _iUSER_AXIS$[ebp], edi
$LN140@PullObjInn:

; 664  : 							break;
; 665  : 						}
; 666  : 					}
; 667  : 
; 668  : 					if ( n == MAX_CC_TRAP_STEP )
; 669  : 						continue;
; 670  : 
; 671  : 					if ( vtMAP_UNTRAP[iUSER_AXIS].empty() == false )

  001b3	8b 4d a0	 mov	 ecx, DWORD PTR _iUSER_AXIS$[ebp]
  001b6	03 c9		 add	 ecx, ecx
  001b8	8b 54 cd b0	 mov	 edx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8]
  001bc	3b 54 cd b4	 cmp	 edx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8+4]
  001c0	8d 44 cd b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8]
  001c4	74 3b		 je	 SHORT $LN32@PullObjInn

; 672  : 					{
; 673  : 						POINT ptEMPTY = vtMAP_UNTRAP[iUSER_AXIS].back();

  001c6	8b 4c cd b4	 mov	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8+4]

; 674  : 						vtMAP_UNTRAP[iUSER_AXIS].pop_back();

  001ca	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001cd	8b 79 f8	 mov	 edi, DWORD PTR [ecx-8]
  001d0	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001d3	39 10		 cmp	 DWORD PTR [eax], edx
  001d5	74 06		 je	 SHORT $LN85@PullObjInn
  001d7	83 c2 f8	 add	 edx, -8			; fffffff8H
  001da	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN85@PullObjInn:

; 675  : 
; 676  : 						if ( this->ObjSetPosition(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, ptEMPTY.x, ptEMPTY.y) == TRUE )

  001dd	51		 push	 ecx
  001de	8b 4d 94	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001e1	57		 push	 edi
  001e2	53		 push	 ebx
  001e3	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  001e8	83 f8 01	 cmp	 eax, 1
  001eb	75 14		 jne	 SHORT $LN32@PullObjInn

; 677  : 						{
; 678  : 							gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = GetTickCount();

  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001f3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001f5	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  001fb	89 81 0c 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3340], eax
$LN32@PullObjInn:

; 640  : 				}
; 641  : 			}
; 642  : 		}
; 643  : 	}
; 644  : 
; 645  : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00201	83 c6 14	 add	 esi, 20			; 00000014H
  00204	ff 4d 9c	 dec	 DWORD PTR tv532[ebp]
  00207	0f 85 07 ff ff
	ff		 jne	 $LL33@PullObjInn

; 679  : 						}
; 680  : 					}
; 681  : 				}
; 682  : 			}
; 683  : 		}
; 684  : 	}
; 685  : 
; 686  : 	for ( int iMON = 0; iMON < MAX_CHAOSCASTLE_MONSTER ; iMON++ )

  0020d	8b 4d a8	 mov	 ecx, DWORD PTR tv1522[ebp]
  00210	81 c1 e4 05 00
	00		 add	 ecx, 1508		; 000005e4H
  00216	89 4d 9c	 mov	 DWORD PTR tv1637[ebp], ecx
  00219	c7 45 a8 64 00
	00 00		 mov	 DWORD PTR tv167[ebp], 100 ; 00000064H
$LL20@PullObjInn:

; 687  : 	{
; 688  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == -1 )

  00220	8b 31		 mov	 esi, DWORD PTR [ecx]
  00222	83 fe ff	 cmp	 esi, -1
  00225	0f 84 fe 00 00
	00		 je	 $LN19@PullObjInn

; 689  : 			continue;
; 690  : 
; 691  : 		int iMON_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON];
; 692  : 
; 693  : 		if ( !CHECK_LIMIT(iMON_INDEX, OBJ_MAXMONSTER))

  0022b	85 f6		 test	 esi, esi
  0022d	78 0f		 js	 SHORT $LN141@PullObjInn
  0022f	33 c0		 xor	 eax, eax
  00231	81 fe a7 16 00
	00		 cmp	 esi, 5799		; 000016a7H
  00237	0f 9e c0	 setle	 al
  0023a	85 c0		 test	 eax, eax
  0023c	75 0b		 jne	 SHORT $LN16@PullObjInn
$LN141@PullObjInn:

; 694  : 		{
; 695  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] = -1;

  0023e	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1

; 696  : 			continue;

  00244	e9 e0 00 00 00	 jmp	 $LN19@PullObjInn
$LN16@PullObjInn:

; 697  : 		}
; 698  : 
; 699  : 		if ( gObj[iMON_INDEX].Life > 0.0f && CC_MAP_RANGE(gObj[iMON_INDEX].MapNumber) != FALSE && gObj[iMON_INDEX].Connected > PLAYER_EMPTY )

  00249	d9 ee		 fldz
  0024b	8b de		 mov	 ebx, esi
  0024d	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  00253	d8 9b bc 00 00
	00		 fcomp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+188]
  00259	df e0		 fnstsw	 ax
  0025b	f6 c4 05	 test	 ah, 5
  0025e	0f 8a c5 00 00
	00		 jp	 $LN19@PullObjInn
  00264	0f b6 83 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+265]
  0026b	3c 12		 cmp	 al, 18			; 00000012H
  0026d	0f 82 b6 00 00
	00		 jb	 $LN19@PullObjInn
  00273	b2 17		 mov	 dl, 23			; 00000017H
  00275	3a d0		 cmp	 dl, al
  00277	1b c0		 sbb	 eax, eax
  00279	40		 inc	 eax
  0027a	0f 84 a9 00 00
	00		 je	 $LN19@PullObjInn
  00280	80 bb 04 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+4], 0
  00287	0f 86 9c 00 00
	00		 jbe	 $LN19@PullObjInn

; 700  : 		{
; 701  : 			int iSX = gObj[iMON_INDEX].X;
; 702  : 			int iSY = gObj[iMON_INDEX].Y;
; 703  : 			BYTE btMapAttr = MapC[iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1].m_attrbuf[iSY * 256 + iSX] & 0x08;

  0028d	8b 45 a4	 mov	 eax, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  00290	0f bf bb 06 01
	00 00		 movsx	 edi, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+262]
  00297	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  0029d	0f bf 93 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+260]
  002a4	8b cf		 mov	 ecx, edi
  002a6	c1 e1 08	 shl	 ecx, 8
  002a9	03 88 a0 7e 5a
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+5930656]
  002af	8a 04 11	 mov	 al, BYTE PTR [ecx+edx]
  002b2	24 08		 and	 al, 8

; 704  : 
; 705  : 			if ( btMapAttr == 8 )

  002b4	74 73		 je	 SHORT $LN19@PullObjInn

; 706  : 			{
; 707  : 				int n = 0;
; 708  : 				for ( int n=0;n<MAX_CC_TRAP_STEP;n++)

  002b6	33 c9		 xor	 ecx, ecx
  002b8	b8 08 00 00 00	 mov	 eax, OFFSET _g_rtPOINT_FRAME+8
  002bd	8d 49 00	 npad	 3
$LL13@PullObjInn:

; 709  : 				{
; 710  : 					if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right &&
; 711  : 						 iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  002c0	3b 50 f8	 cmp	 edx, DWORD PTR [eax-8]
  002c3	7c 0e		 jl	 SHORT $LN12@PullObjInn
  002c5	3b 10		 cmp	 edx, DWORD PTR [eax]
  002c7	7f 0a		 jg	 SHORT $LN12@PullObjInn
  002c9	3b 78 fc	 cmp	 edi, DWORD PTR [eax-4]
  002cc	7c 05		 jl	 SHORT $LN12@PullObjInn
  002ce	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  002d1	7e 0d		 jle	 SHORT $LN131@PullObjInn
$LN12@PullObjInn:

; 706  : 			{
; 707  : 				int n = 0;
; 708  : 				for ( int n=0;n<MAX_CC_TRAP_STEP;n++)

  002d3	83 c0 10	 add	 eax, 16			; 00000010H
  002d6	41		 inc	 ecx
  002d7	3d 48 00 00 00	 cmp	 eax, OFFSET _g_rtPOINT_FRAME+72
  002dc	7c e2		 jl	 SHORT $LL13@PullObjInn

; 709  : 				{
; 710  : 					if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right &&
; 711  : 						 iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  002de	eb 03		 jmp	 SHORT $LN142@PullObjInn
$LN131@PullObjInn:

; 712  : 					{
; 713  : 						iUSER_AXIS = n;

  002e0	89 4d a0	 mov	 DWORD PTR _iUSER_AXIS$[ebp], ecx
$LN142@PullObjInn:

; 714  : 						break;
; 715  : 					}
; 716  : 				}
; 717  : 
; 718  : 				if ( n == MAX_CC_TRAP_STEP )
; 719  : 					continue;
; 720  : 
; 721  : 				if ( vtMAP_UNTRAP[iUSER_AXIS].empty() == false )

  002e3	8b 4d a0	 mov	 ecx, DWORD PTR _iUSER_AXIS$[ebp]
  002e6	03 c9		 add	 ecx, ecx
  002e8	8b 54 cd b0	 mov	 edx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8]
  002ec	3b 54 cd b4	 cmp	 edx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8+4]
  002f0	8d 44 cd b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8]
  002f4	74 33		 je	 SHORT $LN19@PullObjInn

; 722  : 				{
; 723  : 					POINT ptEMPTY = vtMAP_UNTRAP[iUSER_AXIS].back();

  002f6	8b 4c cd b4	 mov	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8+4]

; 724  : 					vtMAP_UNTRAP[iUSER_AXIS].pop_back();

  002fa	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002fd	8b 79 f8	 mov	 edi, DWORD PTR [ecx-8]
  00300	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00303	39 10		 cmp	 DWORD PTR [eax], edx
  00305	74 06		 je	 SHORT $LN117@PullObjInn
  00307	83 c2 f8	 add	 edx, -8			; fffffff8H
  0030a	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN117@PullObjInn:

; 725  : 
; 726  : 					if ( this->ObjSetPosition(iMON_INDEX, ptEMPTY.x, ptEMPTY.y) == TRUE )

  0030d	51		 push	 ecx
  0030e	8b 4d 94	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00311	57		 push	 edi
  00312	56		 push	 esi
  00313	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  00318	83 f8 01	 cmp	 eax, 1
  0031b	75 0c		 jne	 SHORT $LN19@PullObjInn

; 727  : 					{
; 728  : 						gObj[iMON_INDEX].m_iChaosCastleBlowTime = GetTickCount();

  0031d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00323	89 83 0c 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3340], eax
$LN19@PullObjInn:

; 679  : 						}
; 680  : 					}
; 681  : 				}
; 682  : 			}
; 683  : 		}
; 684  : 	}
; 685  : 
; 686  : 	for ( int iMON = 0; iMON < MAX_CHAOSCASTLE_MONSTER ; iMON++ )

  00329	8b 4d 9c	 mov	 ecx, DWORD PTR tv1637[ebp]
  0032c	83 c1 04	 add	 ecx, 4
  0032f	ff 4d a8	 dec	 DWORD PTR tv167[ebp]
  00332	89 4d 9c	 mov	 DWORD PTR tv1637[ebp], ecx
  00335	0f 85 e5 fe ff
	ff		 jne	 $LL20@PullObjInn

; 729  : 					}
; 730  : 				}
; 731  : 			}
; 732  : 		}
; 733  : 	}
; 734  : 
; 735  : 	for ( int iMAP_ITEM =0;iMAP_ITEM<MAX_MAPITEM;iMAP_ITEM++)

  0033b	8b 7d a4	 mov	 edi, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  0033e	69 ff 08 07 05
	00		 imul	 edi, 329480		; 00050708H
  00344	81 c7 5c 7f 5a
	00		 add	 edi, OFFSET ?MapC@@3PAVMapClass@@A+5930844
  0034a	bb 2c 01 00 00	 mov	 ebx, 300		; 0000012cH
  0034f	90		 npad	 1
$LL6@PullObjInn:

; 736  : 	{
; 737  : 		if ( MapC[iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1].m_cItem[iMAP_ITEM].IsItem() )

  00350	8d 8f 58 ff ff
	ff		 lea	 ecx, DWORD PTR [edi-168]
  00356	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0035b	85 c0		 test	 eax, eax
  0035d	74 3a		 je	 SHORT $LN5@PullObjInn

; 738  : 		{
; 739  : 			int x = MapC[iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1].m_cItem[iMAP_ITEM].px;

  0035f	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]

; 740  : 			int y = MapC[iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1].m_cItem[iMAP_ITEM].py;
; 741  : 
; 742  : 			if ( x < ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0] || x > ::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] ||
; 743  : 				 y < ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1] || y > ::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] )

  00362	8b 45 0c	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  00365	0f b6 57 01	 movzx	 edx, BYTE PTR [edi+1]
  00369	c1 e0 04	 shl	 eax, 4
  0036c	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax]
  00372	7c 18		 jl	 SHORT $LN1@PullObjInn
  00374	3b 88 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+8]
  0037a	7f 10		 jg	 SHORT $LN1@PullObjInn
  0037c	3b 90 04 00 00
	00		 cmp	 edx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+4]
  00382	7c 08		 jl	 SHORT $LN1@PullObjInn
  00384	3b 90 0c 00 00
	00		 cmp	 edx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+12]
  0038a	7e 0d		 jle	 SHORT $LN5@PullObjInn
$LN1@PullObjInn:

; 744  : 			{
; 745  : 				MapC[iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1].m_cItem[iMAP_ITEM].m_State = 8;

  0038c	c7 47 04 08 00
	00 00		 mov	 DWORD PTR [edi+4], 8

; 746  : 				MapC[iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1].m_cItem[iMAP_ITEM].Give = true;

  00393	66 c7 47 02 00
	01		 mov	 WORD PTR [edi+2], 256	; 00000100H
$LN5@PullObjInn:

; 729  : 					}
; 730  : 				}
; 731  : 			}
; 732  : 		}
; 733  : 	}
; 734  : 
; 735  : 	for ( int iMAP_ITEM =0;iMAP_ITEM<MAX_MAPITEM;iMAP_ITEM++)

  00399	81 c7 48 04 00
	00		 add	 edi, 1096		; 00000448H
  0039f	4b		 dec	 ebx
  003a0	75 ae		 jne	 SHORT $LL6@PullObjInn

; 747  : 				MapC[iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1].m_cItem[iMAP_ITEM].live = false;
; 748  : 			}
; 749  : 		}
; 750  : 	}
; 751  : }

  003a2	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  003a7	6a 04		 push	 4
  003a9	6a 10		 push	 16			; 00000010H
  003ab	8d 45 b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  003ae	50		 push	 eax
  003af	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003b6	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
$LN47@PullObjInn:
  003bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003c5	59		 pop	 ecx
  003c6	5f		 pop	 edi
  003c7	5e		 pop	 esi
  003c8	5b		 pop	 ebx
  003c9	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003cc	33 cd		 xor	 ecx, ebp
  003ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d3	8b e5		 mov	 esp, ebp
  003d5	5d		 pop	 ebp
  003d6	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  00005	6a 04		 push	 4
  00007	6a 10		 push	 16			; 00000010H
  00009	8d 45 b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00012	c3		 ret	 0
__ehhandler$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::PullObjInnerPlace
PUBLIC	_iChaosCastleIndex$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z	; CChaosCastle::CheckMonsterInDieTile
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z$0
__ehfuncinfo$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\chaoscastle.cpp
xdata$x	ENDS
;	COMDAT ?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
tv724 = -120						; size = 4
_iUSER_AXIS$ = -116					; size = 4
_iPT$159769 = -112					; size = 8
_this$GSCopy$ = -104					; size = 4
_iChaosCastleIndex$GSCopy$ = -100			; size = 4
_iMAPX$159759 = -96					; size = 4
tv1239 = -88						; size = 4
_iMAPY$159763 = -88					; size = 4
tv1056 = -84						; size = 4
tv436 = -84						; size = 4
_vtMAP_UNTRAP$ = -80					; size = 64
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iChaosCastleIndex$ = 8					; size = 4
?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z PROC	; CChaosCastle::CheckMonsterInDieTile, COMDAT
; _this$ = ecx

; 2427 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]

; 2428 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0002e	33 ff		 xor	 edi, edi
  00030	89 4d 98	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx

; 2443 : 				{
; 2444 : 					POINT iPT = {iMAPX, iMAPY};
; 2445 : 					vtMAP_UNTRAP[iAXIS].push_back(iPT);

  00033	89 5d 9c	 mov	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], ebx
  00036	3b df		 cmp	 ebx, edi
  00038	0f 8c fd 02 00
	00		 jl	 $LN26@CheckMonst

; 2428 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0003e	33 c0		 xor	 eax, eax
  00040	83 fb 05	 cmp	 ebx, 5
  00043	0f 9e c0	 setle	 al
  00046	3b c7		 cmp	 eax, edi
  00048	0f 84 ed 02 00
	00		 je	 $LN26@CheckMonst

; 2429 : 		return ;
; 2430 : 
; 2431 : 	int iUSER_AXIS = 0;
; 2432 : 	std::vector<POINT> vtMAP_UNTRAP[4];

  0004e	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  00053	68 00 00 00 00	 push	 OFFSET ??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >
  00058	6a 04		 push	 4
  0005a	6a 10		 push	 16			; 00000010H
  0005c	8d 45 b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  0005f	50		 push	 eax
  00060	89 7d 8c	 mov	 DWORD PTR _iUSER_AXIS$[ebp], edi
  00063	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  00068	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  0006b	89 7d ac	 mov	 DWORD PTR tv1056[ebp], edi
  0006e	8b ff		 npad	 2
$LL24@CheckMonst:

; 2435 : 	{
; 2436 : 		for (int iMAPX = g_rtPOINT_TRAP[iAXIS].left; iMAPX <= g_rtPOINT_TRAP[iAXIS].right ; iMAPX++)

  00070	8b b7 00 00 00
	00		 mov	 esi, DWORD PTR _g_rtPOINT_TRAP[edi]
  00076	89 75 a0	 mov	 DWORD PTR _iMAPX$159759[ebp], esi
  00079	3b b7 08 00 00
	00		 cmp	 esi, DWORD PTR _g_rtPOINT_TRAP[edi+8]
  0007f	0f 8f 4c 01 00
	00		 jg	 $LN23@CheckMonst
  00085	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL21@CheckMonst:

; 2437 : 		{
; 2438 : 			for (int iMAPY = g_rtPOINT_TRAP[iAXIS].top; iMAPY <= g_rtPOINT_TRAP[iAXIS].bottom ; iMAPY++)

  00090	8b 9f 04 00 00
	00		 mov	 ebx, DWORD PTR _g_rtPOINT_TRAP[edi+4]
  00096	89 5d a8	 mov	 DWORD PTR _iMAPY$159763[ebp], ebx
  00099	3b 9f 0c 00 00
	00		 cmp	 ebx, DWORD PTR _g_rtPOINT_TRAP[edi+12]
  0009f	0f 8f 19 01 00
	00		 jg	 $LN20@CheckMonst
  000a5	8b 4d 9c	 mov	 ecx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  000a8	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H

; 2477 : 					{
; 2478 : 						iUSER_AXIS = n;

  000ae	8d 91 90 7e 5a
	00		 lea	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+5930640]
  000b4	89 55 88	 mov	 DWORD PTR tv724[ebp], edx
$LN18@CheckMonst:

; 2439 : 			{
; 2440 : 				BYTE btMapAttr = MapC[iChaosCastleIndex+18].GetAttr(iMAPX, iMAPY);

  000b7	8b 4d 88	 mov	 ecx, DWORD PTR tv724[ebp]
  000ba	53		 push	 ebx
  000bb	56		 push	 esi
  000bc	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 2441 : 
; 2442 : 				if ( (btMapAttr&2)!= 2 && (btMapAttr&4)!= 4 && (btMapAttr&8)!= 8 )

  000c1	a8 0e		 test	 al, 14			; 0000000eH
  000c3	0f 85 e5 00 00
	00		 jne	 $LN17@CheckMonst

; 2443 : 				{
; 2444 : 					POINT iPT = {iMAPX, iMAPY};
; 2445 : 					vtMAP_UNTRAP[iAXIS].push_back(iPT);

  000c9	8b 44 3d b4	 mov	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp+edi+4]
  000cd	89 75 90	 mov	 DWORD PTR _iPT$159769[ebp], esi
  000d0	8d 74 3d b0	 lea	 esi, DWORD PTR _vtMAP_UNTRAP$[ebp+edi]
  000d4	8d 4d 90	 lea	 ecx, DWORD PTR _iPT$159769[ebp]
  000d7	89 5d 94	 mov	 DWORD PTR _iPT$159769[ebp+4], ebx
  000da	3b c8		 cmp	 ecx, eax
  000dc	73 6c		 jae	 SHORT $LN38@CheckMonst
  000de	8b 16		 mov	 edx, DWORD PTR [esi]
  000e0	3b d1		 cmp	 edx, ecx
  000e2	77 66		 ja	 SHORT $LN38@CheckMonst
  000e4	8b f9		 mov	 edi, ecx
  000e6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e9	2b fa		 sub	 edi, edx
  000eb	c1 ff 03	 sar	 edi, 3
  000ee	3b c1		 cmp	 eax, ecx
  000f0	75 40		 jne	 SHORT $LN49@CheckMonst
  000f2	2b c2		 sub	 eax, edx
  000f4	c1 f8 03	 sar	 eax, 3
  000f7	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  000fc	0f 87 27 01 00
	00		 ja	 $LN156@CheckMonst
  00102	2b ca		 sub	 ecx, edx
  00104	40		 inc	 eax
  00105	c1 f9 03	 sar	 ecx, 3
  00108	3b c1		 cmp	 eax, ecx
  0010a	76 26		 jbe	 SHORT $LN49@CheckMonst
  0010c	8b d1		 mov	 edx, ecx
  0010e	d1 ea		 shr	 edx, 1
  00110	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00115	2b da		 sub	 ebx, edx
  00117	3b d9		 cmp	 ebx, ecx
  00119	73 04		 jae	 SHORT $LN71@CheckMonst
  0011b	33 c9		 xor	 ecx, ecx
  0011d	eb 02		 jmp	 SHORT $LN72@CheckMonst
$LN71@CheckMonst:
  0011f	03 ca		 add	 ecx, edx
$LN72@CheckMonst:
  00121	3b c8		 cmp	 ecx, eax
  00123	73 02		 jae	 SHORT $LN68@CheckMonst
  00125	8b c8		 mov	 ecx, eax
$LN68@CheckMonst:
  00127	51		 push	 ecx
  00128	8b ce		 mov	 ecx, esi
  0012a	e8 00 00 00 00	 call	 ?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve
  0012f	8b 5d a8	 mov	 ebx, DWORD PTR _iMAPY$159763[ebp]
$LN49@CheckMonst:
  00132	8b 16		 mov	 edx, DWORD PTR [esi]
  00134	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00137	8d 04 fa	 lea	 eax, DWORD PTR [edx+edi*8]
  0013a	50		 push	 eax
  0013b	51		 push	 ecx
  0013c	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  0013f	52		 push	 edx
  00140	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>
  00145	8b 7d ac	 mov	 edi, DWORD PTR tv1056[ebp]
  00148	eb 5a		 jmp	 SHORT $LN176@CheckMonst
$LN38@CheckMonst:
  0014a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0014d	3b c1		 cmp	 eax, ecx
  0014f	75 42		 jne	 SHORT $LN84@CheckMonst
  00151	8b 16		 mov	 edx, DWORD PTR [esi]
  00153	2b c2		 sub	 eax, edx
  00155	c1 f8 03	 sar	 eax, 3
  00158	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  0015d	0f 87 c6 00 00
	00		 ja	 $LN156@CheckMonst
  00163	2b ca		 sub	 ecx, edx
  00165	40		 inc	 eax
  00166	c1 f9 03	 sar	 ecx, 3
  00169	3b c1		 cmp	 eax, ecx
  0016b	76 26		 jbe	 SHORT $LN84@CheckMonst
  0016d	8b d1		 mov	 edx, ecx
  0016f	d1 ea		 shr	 edx, 1
  00171	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00176	2b fa		 sub	 edi, edx
  00178	3b f9		 cmp	 edi, ecx
  0017a	73 04		 jae	 SHORT $LN106@CheckMonst
  0017c	33 c9		 xor	 ecx, ecx
  0017e	eb 02		 jmp	 SHORT $LN107@CheckMonst
$LN106@CheckMonst:
  00180	03 ca		 add	 ecx, edx
$LN107@CheckMonst:
  00182	3b c8		 cmp	 ecx, eax
  00184	73 02		 jae	 SHORT $LN103@CheckMonst
  00186	8b c8		 mov	 ecx, eax
$LN103@CheckMonst:
  00188	51		 push	 ecx
  00189	8b ce		 mov	 ecx, esi
  0018b	e8 00 00 00 00	 call	 ?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve
  00190	8b 7d ac	 mov	 edi, DWORD PTR tv1056[ebp]
$LN84@CheckMonst:
  00193	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00196	8d 45 90	 lea	 eax, DWORD PTR _iPT$159769[ebp]
  00199	50		 push	 eax
  0019a	51		 push	 ecx
  0019b	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>
$LN176@CheckMonst:
  001a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a7	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  001ab	8b 75 a0	 mov	 esi, DWORD PTR _iMAPX$159759[ebp]
$LN17@CheckMonst:

; 2437 : 		{
; 2438 : 			for (int iMAPY = g_rtPOINT_TRAP[iAXIS].top; iMAPY <= g_rtPOINT_TRAP[iAXIS].bottom ; iMAPY++)

  001ae	43		 inc	 ebx
  001af	89 5d a8	 mov	 DWORD PTR _iMAPY$159763[ebp], ebx
  001b2	3b 9f 0c 00 00
	00		 cmp	 ebx, DWORD PTR _g_rtPOINT_TRAP[edi+12]
  001b8	0f 8e f9 fe ff
	ff		 jle	 $LN18@CheckMonst
$LN20@CheckMonst:

; 2435 : 	{
; 2436 : 		for (int iMAPX = g_rtPOINT_TRAP[iAXIS].left; iMAPX <= g_rtPOINT_TRAP[iAXIS].right ; iMAPX++)

  001be	46		 inc	 esi
  001bf	89 75 a0	 mov	 DWORD PTR _iMAPX$159759[ebp], esi
  001c2	3b b7 08 00 00
	00		 cmp	 esi, DWORD PTR _g_rtPOINT_TRAP[edi+8]
  001c8	0f 8e c2 fe ff
	ff		 jle	 $LL21@CheckMonst
  001ce	8b 5d 9c	 mov	 ebx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
$LN23@CheckMonst:

; 2433 : 
; 2434 : 	for ( int iAXIS =0;iAXIS <	4 ; iAXIS++)

  001d1	83 c7 10	 add	 edi, 16			; 00000010H
  001d4	89 7d ac	 mov	 DWORD PTR tv1056[ebp], edi
  001d7	83 ff 40	 cmp	 edi, 64			; 00000040H
  001da	0f 8c 90 fe ff
	ff		 jl	 $LL24@CheckMonst

; 2446 : 				}
; 2447 : 			}
; 2448 : 		}
; 2449 : 	}
; 2450 : 
; 2451 : 	for (int iMON = 0;iMON < MAX_CHAOSCASTLE_MONSTER ; iMON ++ )

  001e0	8b 45 98	 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  001e3	69 db 6c 08 00
	00		 imul	 ebx, 2156		; 0000086cH
  001e9	8d 8c 03 e4 05
	00 00		 lea	 ecx, DWORD PTR [ebx+eax+1508]
  001f0	89 4d a8	 mov	 DWORD PTR tv1239[ebp], ecx
  001f3	c7 45 ac 64 00
	00 00		 mov	 DWORD PTR tv436[ebp], 100 ; 00000064H
  001fa	8d 9b 00 00 00
	00		 npad	 6
$LL14@CheckMonst:

; 2452 : 	{
; 2453 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == -1 )

  00200	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00202	83 fb ff	 cmp	 ebx, -1
  00205	0f 84 05 01 00
	00		 je	 $LN13@CheckMonst

; 2454 : 			continue;
; 2455 : 
; 2456 : 		int iMON_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON];
; 2457 : 
; 2458 : 		if ( !CHECK_LIMIT(iMON_INDEX, OBJ_MAXMONSTER))

  0020b	85 db		 test	 ebx, ebx
  0020d	78 0f		 js	 SHORT $LN165@CheckMonst
  0020f	33 c0		 xor	 eax, eax
  00211	81 fb a7 16 00
	00		 cmp	 ebx, 5799		; 000016a7H
  00217	0f 9e c0	 setle	 al
  0021a	85 c0		 test	 eax, eax
  0021c	75 15		 jne	 SHORT $LN10@CheckMonst
$LN165@CheckMonst:

; 2459 : 		{
; 2460 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] = -1;

  0021e	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1

; 2461 : 			continue;

  00224	e9 e7 00 00 00	 jmp	 $LN13@CheckMonst
$LN156@CheckMonst:

; 2443 : 				{
; 2444 : 					POINT iPT = {iMAPX, iMAPY};
; 2445 : 					vtMAP_UNTRAP[iAXIS].push_back(iPT);

  00229	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0022e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN177@CheckMonst:
$LN10@CheckMonst:

; 2462 : 		}
; 2463 : 
; 2464 : 		if ( gObj[iMON_INDEX].Life > 0.0f && CC_MAP_RANGE(gObj[iMON_INDEX].MapNumber) != FALSE && gObj[iMON_INDEX].Connected > PLAYER_EMPTY )

  00233	d9 ee		 fldz
  00235	8b fb		 mov	 edi, ebx
  00237	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0023d	d8 9f bc 00 00
	00		 fcomp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+188]
  00243	df e0		 fnstsw	 ax
  00245	f6 c4 05	 test	 ah, 5
  00248	0f 8a c2 00 00
	00		 jp	 $LN13@CheckMonst
  0024e	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+265]
  00255	3c 12		 cmp	 al, 18			; 00000012H
  00257	0f 82 b3 00 00
	00		 jb	 $LN13@CheckMonst
  0025d	b1 17		 mov	 cl, 23			; 00000017H
  0025f	3a c8		 cmp	 cl, al
  00261	1b c0		 sbb	 eax, eax
  00263	40		 inc	 eax
  00264	0f 84 a6 00 00
	00		 je	 $LN13@CheckMonst
  0026a	80 bf 04 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+4], 0
  00271	0f 86 99 00 00
	00		 jbe	 $LN13@CheckMonst

; 2465 : 		{
; 2466 : 			int iSX = gObj[iMON_INDEX].X;
; 2467 : 			int iSY = gObj[iMON_INDEX].Y;
; 2468 : 			BYTE btMapAttr = MapC[iChaosCastleIndex + MAP_INDEX_CHAOSCASTLE1].m_attrbuf[iSY * 256 + iSX] & 0x08;

  00277	8b 45 9c	 mov	 eax, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  0027a	0f bf b7 06 01
	00 00		 movsx	 esi, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  00281	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  00287	0f bf 97 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  0028e	8b ce		 mov	 ecx, esi
  00290	c1 e1 08	 shl	 ecx, 8
  00293	03 88 a0 7e 5a
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+5930656]
  00299	8a 04 11	 mov	 al, BYTE PTR [ecx+edx]
  0029c	24 08		 and	 al, 8

; 2469 : 
; 2470 : 			if ( btMapAttr == 8 )

  0029e	74 70		 je	 SHORT $LN13@CheckMonst

; 2471 : 			{
; 2472 : 				int n = 0;
; 2473 : 				for ( int n=0;n<MAX_CC_TRAP_STEP;n++)

  002a0	33 c9		 xor	 ecx, ecx
  002a2	b8 08 00 00 00	 mov	 eax, OFFSET _g_rtPOINT_FRAME+8
$LL7@CheckMonst:

; 2474 : 				{
; 2475 : 					if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right &&
; 2476 : 						 iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  002a7	3b 50 f8	 cmp	 edx, DWORD PTR [eax-8]
  002aa	7c 0e		 jl	 SHORT $LN6@CheckMonst
  002ac	3b 10		 cmp	 edx, DWORD PTR [eax]
  002ae	7f 0a		 jg	 SHORT $LN6@CheckMonst
  002b0	3b 70 fc	 cmp	 esi, DWORD PTR [eax-4]
  002b3	7c 05		 jl	 SHORT $LN6@CheckMonst
  002b5	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  002b8	7e 0d		 jle	 SHORT $LN158@CheckMonst
$LN6@CheckMonst:

; 2471 : 			{
; 2472 : 				int n = 0;
; 2473 : 				for ( int n=0;n<MAX_CC_TRAP_STEP;n++)

  002ba	83 c0 10	 add	 eax, 16			; 00000010H
  002bd	41		 inc	 ecx
  002be	3d 48 00 00 00	 cmp	 eax, OFFSET _g_rtPOINT_FRAME+72
  002c3	7c e2		 jl	 SHORT $LL7@CheckMonst

; 2474 : 				{
; 2475 : 					if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right &&
; 2476 : 						 iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  002c5	eb 03		 jmp	 SHORT $LN166@CheckMonst
$LN158@CheckMonst:

; 2477 : 					{
; 2478 : 						iUSER_AXIS = n;

  002c7	89 4d 8c	 mov	 DWORD PTR _iUSER_AXIS$[ebp], ecx
$LN166@CheckMonst:

; 2479 : 						break;
; 2480 : 					}
; 2481 : 				}
; 2482 : 
; 2483 : 				if ( n == MAX_CC_TRAP_STEP )
; 2484 : 					continue;
; 2485 : 
; 2486 : 				if ( vtMAP_UNTRAP[iUSER_AXIS].empty() == false )

  002ca	8b 4d 8c	 mov	 ecx, DWORD PTR _iUSER_AXIS$[ebp]
  002cd	03 c9		 add	 ecx, ecx
  002cf	8b 54 cd b0	 mov	 edx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8]
  002d3	3b 54 cd b4	 cmp	 edx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8+4]
  002d7	8d 44 cd b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8]
  002db	74 33		 je	 SHORT $LN13@CheckMonst

; 2487 : 				{
; 2488 : 					POINT ptEMPTY = vtMAP_UNTRAP[iUSER_AXIS].back();

  002dd	8b 4c cd b4	 mov	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8+4]

; 2489 : 					vtMAP_UNTRAP[iUSER_AXIS].pop_back();

  002e1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002e4	8b 71 f8	 mov	 esi, DWORD PTR [ecx-8]
  002e7	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002ea	39 10		 cmp	 DWORD PTR [eax], edx
  002ec	74 06		 je	 SHORT $LN146@CheckMonst
  002ee	83 c2 f8	 add	 edx, -8			; fffffff8H
  002f1	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN146@CheckMonst:

; 2490 : 
; 2491 : 					if ( this->ObjSetPosition(iMON_INDEX, ptEMPTY.x, ptEMPTY.y) == TRUE )

  002f4	51		 push	 ecx
  002f5	8b 4d 98	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  002f8	56		 push	 esi
  002f9	53		 push	 ebx
  002fa	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  002ff	83 f8 01	 cmp	 eax, 1
  00302	75 0c		 jne	 SHORT $LN13@CheckMonst

; 2492 : 					{
; 2493 : 						gObj[iMON_INDEX].m_iChaosCastleBlowTime = GetTickCount();

  00304	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0030a	89 87 0c 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3340], eax
$LN13@CheckMonst:

; 2446 : 				}
; 2447 : 			}
; 2448 : 		}
; 2449 : 	}
; 2450 : 
; 2451 : 	for (int iMON = 0;iMON < MAX_CHAOSCASTLE_MONSTER ; iMON ++ )

  00310	8b 4d a8	 mov	 ecx, DWORD PTR tv1239[ebp]
  00313	83 c1 04	 add	 ecx, 4
  00316	ff 4d ac	 dec	 DWORD PTR tv436[ebp]
  00319	89 4d a8	 mov	 DWORD PTR tv1239[ebp], ecx
  0031c	0f 85 de fe ff
	ff		 jne	 $LL14@CheckMonst

; 2494 : 					}
; 2495 : 				}
; 2496 : 			}
; 2497 : 		}
; 2498 : 	}
; 2499 : }

  00322	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  00327	6a 04		 push	 4
  00329	6a 10		 push	 16			; 00000010H
  0032b	8d 45 b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  0032e	50		 push	 eax
  0032f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00336	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
$LN26@CheckMonst:
  0033b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0033e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00345	59		 pop	 ecx
  00346	5f		 pop	 edi
  00347	5e		 pop	 esi
  00348	5b		 pop	 ebx
  00349	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0034c	33 cd		 xor	 ecx, ebp
  0034e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00353	8b e5		 mov	 esp, ebp
  00355	5d		 pop	 ebp
  00356	c2 04 00	 ret	 4
$LN175@CheckMonst:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  00005	6a 04		 push	 4
  00007	6a 10		 push	 16			; 00000010H
  00009	8d 45 b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00012	c3		 ret	 0
__ehhandler$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a 84	 mov	 ecx, DWORD PTR [edx-124]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z ENDP	; CChaosCastle::CheckMonsterInDieTile
PUBLIC	??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@ ; `string'
PUBLIC	??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@ ; `string'
PUBLIC	??_C@_0EC@CDMJLAJE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5is?5Over?5?3?5TI@ ; `string'
PUBLIC	??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@ ; `string'
PUBLIC	??_C@_0DI@NBGGDBDE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@ ; `string'
PUBLIC	??_C@_0DM@PFNIGNGP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ProcState_Playing@CChaosCastle@@IAEXH@Z	; CChaosCastle::ProcState_Playing
;	COMDAT ??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
CONST	SEGMENT
??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@ DB '['
	DB	'Chaos Castle] (%d) Has No Winner : Monster Left (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@
CONST	SEGMENT
??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] is Winner. [CharInfoSave : Class='
	DB	'%d, Level=%d, LvPoint=%d, Exp=%d, Str=%d, Dex=%d, Vit=%d, Ene'
	DB	'rgy=%d, LeaderShip=%d, Map=%d, Pk=%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@CDMJLAJE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5is?5Over?5?3?5TI@
CONST	SEGMENT
??_C@_0EC@CDMJLAJE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5is?5Over?5?3?5TI@ DB '['
	DB	'Chaos Castle] (%d) is Over : TIME-OUT (Left User:%d, Monster:'
	DB	'%d)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
CONST	SEGMENT
??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@ DB '['
	DB	'Chaos Castle] (%d) Has No Winner.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@NBGGDBDE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@
CONST	SEGMENT
??_C@_0DI@NBGGDBDE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@ DB '['
	DB	'Chaos Castle] (%d) Chaos Castle Quest Closed - No User', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@PFNIGNGP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@
CONST	SEGMENT
??_C@_0DM@PFNIGNGP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@ DB '['
	DB	'Chaos Castle] (%d) Chaos Castle Quest Start (UserCount:%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ProcState_Playing@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_iWinnerIndex$157861 = -280				; size = 4
_iWinnerIndex$157852 = -280				; size = 4
_iWinnerIndex$157842 = -280				; size = 4
_pMsg$157826 = -280					; size = 4
_pMsg$157822 = -280					; size = 4
_pNotice$157830 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcState_Playing@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::ProcState_Playing, COMDAT
; _this$ = ecx

; 406  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]

; 407  : 	int iTICK_MSEC = GetTickCount() - this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT;

  00018	8b de		 mov	 ebx, esi
  0001a	69 db 6c 08 00
	00		 imul	 ebx, 2156		; 0000086cH
  00020	57		 push	 edi
  00021	8b f9		 mov	 edi, ecx
  00023	03 df		 add	 ebx, edi
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002b	2b 43 44	 sub	 eax, DWORD PTR [ebx+68]

; 408  : 
; 409  : 	if ( iTICK_MSEC >= 1000 )

  0002e	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00033	0f 8c 92 03 00
	00		 jl	 $LN29@ProcState_@3

; 410  : 	{
; 411  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC -= iTICK_MSEC;

  00039	29 43 40	 sub	 DWORD PTR [ebx+64], eax

; 412  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00042	89 43 44	 mov	 DWORD PTR [ebx+68], eax

; 413  : 
; 414  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= ((this->m_iCC_TIME_MIN_PLAY*60-30)*1000) &&
; 415  : 			 this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_PLAY == false )

  00045	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00048	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H
  0004e	81 e9 30 75 00
	00		 sub	 ecx, 30000		; 00007530H
  00054	39 4b 40	 cmp	 DWORD PTR [ebx+64], ecx
  00057	7f 38		 jg	 SHORT $LN23@ProcState_@3
  00059	80 7b 50 00	 cmp	 BYTE PTR [ebx+80], 0
  0005d	75 32		 jne	 SHORT $LN23@ProcState_@3

; 416  : 		{
; 417  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_PLAY = true;
; 418  : 			
; 419  : 			PMSG_SET_DEVILSQUARE pMsg;
; 420  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  0005f	6a 04		 push	 4
  00061	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$157822[ebp]
  00067	68 92 00 00 00	 push	 146			; 00000092H
  0006c	52		 push	 edx
  0006d	c6 43 50 01	 mov	 BYTE PTR [ebx+80], 1
  00071	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 421  : 			pMsg.Type = 11;
; 422  : 			this->SendChaosCastleAnyMsg((BYTE*)&pMsg, sizeof(pMsg), iChaosCastleIndex);

  00079	56		 push	 esi
  0007a	6a 04		 push	 4
  0007c	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$157822[ebp]
  00082	50		 push	 eax
  00083	8b cf		 mov	 ecx, edi
  00085	c6 85 eb fe ff
	ff 0b		 mov	 BYTE PTR _pMsg$157822[ebp+3], 11 ; 0000000bH
  0008c	e8 00 00 00 00	 call	 ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg
$LN23@ProcState_@3:

; 423  : 		}
; 424  : 
; 425  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 30000 &&
; 426  : 			 this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC > 0  &&
; 427  : 			 this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_END == false )

  00091	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  00094	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00099	7f 3c		 jg	 SHORT $LN27@ProcState_@3
  0009b	85 c0		 test	 eax, eax
  0009d	7e 38		 jle	 SHORT $LN27@ProcState_@3
  0009f	80 7b 51 00	 cmp	 BYTE PTR [ebx+81], 0
  000a3	75 32		 jne	 SHORT $LN27@ProcState_@3

; 428  : 		{
; 429  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_END = true;
; 430  : 			PMSG_SET_DEVILSQUARE pMsg;
; 431  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  000a5	6a 04		 push	 4
  000a7	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$157826[ebp]
  000ad	68 92 00 00 00	 push	 146			; 00000092H
  000b2	51		 push	 ecx
  000b3	c6 43 51 01	 mov	 BYTE PTR [ebx+81], 1
  000b7	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 			pMsg.Type = 12;
; 433  : 			this->SendChaosCastleAnyMsg((BYTE*)&pMsg, sizeof(pMsg), iChaosCastleIndex);

  000bf	56		 push	 esi
  000c0	6a 04		 push	 4
  000c2	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$157826[ebp]
  000c8	52		 push	 edx
  000c9	8b cf		 mov	 ecx, edi
  000cb	c6 85 eb fe ff
	ff 0c		 mov	 BYTE PTR _pMsg$157826[ebp+3], 12 ; 0000000cH
  000d2	e8 00 00 00 00	 call	 ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg
$LN27@ProcState_@3:

; 434  : 		}
; 435  : 
; 436  : 		// Set Play Quest
; 437  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= ((this->m_iCC_TIME_MIN_PLAY*60-60)*1000) &&
; 438  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START == false )

  000d7	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000da	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  000e0	8d 88 a0 15 ff
	ff		 lea	 ecx, DWORD PTR [eax-60000]
  000e6	39 4b 40	 cmp	 DWORD PTR [ebx+64], ecx
  000e9	0f 8f aa 00 00
	00		 jg	 $LN21@ProcState_@3
  000ef	80 7b 4e 00	 cmp	 BYTE PTR [ebx+78], 0
  000f3	0f 85 e6 00 00
	00		 jne	 $LN28@ProcState_@3

; 439  : 		{
; 440  : 			PMSG_NOTICE pNotice;
; 441  : 
; 442  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = (this->m_iCC_TIME_MIN_PLAY*60)*1000;

  000f9	89 43 40	 mov	 DWORD PTR [ebx+64], eax

; 443  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_PARTY = false;
; 444  : 			TNotice::MakeNoticeMsgEx((TNotice*)&pNotice, 0, lMsg.Get(MSGGET(4,209)), iChaosCastleIndex+1);

  000fc	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000ff	50		 push	 eax
  00100	68 d1 04 00 00	 push	 1233			; 000004d1H
  00105	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0010a	c6 43 4d 00	 mov	 BYTE PTR [ebx+77], 0
  0010e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00113	50		 push	 eax
  00114	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$157830[ebp]
  0011a	6a 00		 push	 0
  0011c	52		 push	 edx
  0011d	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 445  : 			this->SendChaosCastleAnyMsg( (LPBYTE)&pNotice, pNotice.h.size, iChaosCastleIndex);

  00122	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$157830[ebp+1]
  00129	83 c4 10	 add	 esp, 16			; 00000010H
  0012c	56		 push	 esi
  0012d	50		 push	 eax
  0012e	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$157830[ebp]
  00134	51		 push	 ecx
  00135	8b cf		 mov	 ecx, edi
  00137	e8 00 00 00 00	 call	 ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg

; 446  : 			this->UnSafetyCastleZone(iChaosCastleIndex);

  0013c	56		 push	 esi
  0013d	8b cf		 mov	 ecx, edi
  0013f	e8 00 00 00 00	 call	 ?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z ; CChaosCastle::UnSafetyCastleZone

; 447  : 			this->SendCastleZoneSafetyInfo(iChaosCastleIndex, 0);

  00144	6a 00		 push	 0
  00146	56		 push	 esi
  00147	8b cf		 mov	 ecx, edi
  00149	e8 00 00 00 00	 call	 ?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z ; CChaosCastle::SendCastleZoneSafetyInfo

; 448  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START = true;
; 449  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_FIRST_USER_COUNT = this->ReCalcUserCount(iChaosCastleIndex);

  0014e	56		 push	 esi
  0014f	8b cf		 mov	 ecx, edi
  00151	c6 43 4e 01	 mov	 BYTE PTR [ebx+78], 1
  00155	e8 00 00 00 00	 call	 ?ReCalcUserCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::ReCalcUserCount

; 450  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT = this->SetMonster(iChaosCastleIndex);

  0015a	56		 push	 esi
  0015b	8b cf		 mov	 ecx, edi
  0015d	89 43 58	 mov	 DWORD PTR [ebx+88], eax
  00160	e8 00 00 00 00	 call	 ?SetMonster@CChaosCastle@@QAEHH@Z ; CChaosCastle::SetMonster

; 451  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_FIRST_MONSTER_COUNT = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT; 
; 452  : 			this->SetItemsToMonster(iChaosCastleIndex);

  00165	56		 push	 esi
  00166	8b cf		 mov	 ecx, edi
  00168	89 43 60	 mov	 DWORD PTR [ebx+96], eax
  0016b	89 43 5c	 mov	 DWORD PTR [ebx+92], eax
  0016e	e8 00 00 00 00	 call	 ?SetItemsToMonster@CChaosCastle@@QAEXH@Z ; CChaosCastle::SetItemsToMonster

; 453  : 			this->SendNoticeState(iChaosCastleIndex, 5);

  00173	6a 05		 push	 5
  00175	56		 push	 esi
  00176	8b cf		 mov	 ecx, edi
  00178	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState

; 454  : 			
; 455  : 			LogAdd(LOG_BLACK, "[Chaos Castle] (%d) Chaos Castle Quest Start (UserCount:%d)",
; 456  : 				iChaosCastleIndex+1, this->GetCurPlayUser(iChaosCastleIndex));

  0017d	56		 push	 esi
  0017e	8b cf		 mov	 ecx, edi
  00180	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  00185	50		 push	 eax
  00186	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00189	50		 push	 eax
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@PFNIGNGP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@
  0018f	6a 00		 push	 0
  00191	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00196	83 c4 10	 add	 esp, 16			; 00000010H
$LN21@ProcState_@3:

; 457  : 		}
; 458  : 
; 459  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START == false &&
; 460  : 			 this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER == false )

  00199	80 7b 4e 00	 cmp	 BYTE PTR [ebx+78], 0
  0019d	75 40		 jne	 SHORT $LN28@ProcState_@3
  0019f	80 7b 4c 00	 cmp	 BYTE PTR [ebx+76], 0
  001a3	75 3a		 jne	 SHORT $LN28@ProcState_@3

; 461  : 		{
; 462  : 			int iCurPlayUser = this->GetCurPlayUser(iChaosCastleIndex);

  001a5	56		 push	 esi
  001a6	8b cf		 mov	 ecx, edi
  001a8	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser

; 463  : 
; 464  : 			if (iCurPlayUser == 0 )

  001ad	85 c0		 test	 eax, eax
  001af	75 2e		 jne	 SHORT $LN28@ProcState_@3

; 465  : 			{
; 466  : 				this->SetState(iChaosCastleIndex, CC_STATE_CLOSED);

  001b1	6a 01		 push	 1
  001b3	56		 push	 esi
  001b4	8b cf		 mov	 ecx, edi
  001b6	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState

; 467  : 				LogAdd(LOG_BLACK, "[Chaos Castle] (%d) Chaos Castle Quest Closed - No User",
; 468  : 					iChaosCastleIndex+1);

  001bb	46		 inc	 esi
  001bc	56		 push	 esi
  001bd	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@NBGGDBDE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@
  001c2	6a 00		 push	 0
  001c4	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001c9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cc	5f		 pop	 edi
  001cd	5e		 pop	 esi
  001ce	5b		 pop	 ebx

; 611  : 	}
; 612  : }

  001cf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d2	33 cd		 xor	 ecx, ebp
  001d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d9	8b e5		 mov	 esp, ebp
  001db	5d		 pop	 ebp
  001dc	c2 04 00	 ret	 4
$LN28@ProcState_@3:

; 469  : 
; 470  : 				return;
; 471  : 			}
; 472  : 		}
; 473  : 
; 474  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START == true )

  001df	80 7b 4e 01	 cmp	 BYTE PTR [ebx+78], 1
  001e3	0f 85 e2 01 00
	00		 jne	 $LN29@ProcState_@3

; 475  : 		{
; 476  : 			this->ProcessFallUser(iChaosCastleIndex);

  001e9	56		 push	 esi
  001ea	8b cf		 mov	 ecx, edi
  001ec	e8 00 00 00 00	 call	 ?ProcessFallUser@CChaosCastle@@QAEXH@Z ; CChaosCastle::ProcessFallUser

; 477  : 			this->CheckUserInDieTile(iChaosCastleIndex);

  001f1	56		 push	 esi
  001f2	8b cf		 mov	 ecx, edi
  001f4	e8 00 00 00 00	 call	 ?CheckUserInDieTile@CChaosCastle@@QAEXH@Z ; CChaosCastle::CheckUserInDieTile

; 478  : 			this->CheckMonsterInDieTile(iChaosCastleIndex);

  001f9	56		 push	 esi
  001fa	8b cf		 mov	 ecx, edi
  001fc	e8 00 00 00 00	 call	 ?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z ; CChaosCastle::CheckMonsterInDieTile

; 479  : 			this->ProcessTrapStatus(iChaosCastleIndex);

  00201	56		 push	 esi
  00202	8b cf		 mov	 ecx, edi
  00204	e8 00 00 00 00	 call	 ?ProcessTrapStatus@CChaosCastle@@QAEXH@Z ; CChaosCastle::ProcessTrapStatus

; 480  : 
; 481  : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS != this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_OLD_STATUS )

  00209	8b 43 64	 mov	 eax, DWORD PTR [ebx+100]
  0020c	3b 43 68	 cmp	 eax, DWORD PTR [ebx+104]
  0020f	74 18		 je	 SHORT $LN17@ProcState_@3

; 482  : 			{
; 483  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_OLD_STATUS = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS;
; 484  : 				this->SetMapAttrHollow(iChaosCastleIndex, this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS);

  00211	50		 push	 eax
  00212	56		 push	 esi
  00213	8b cf		 mov	 ecx, edi
  00215	89 43 68	 mov	 DWORD PTR [ebx+104], eax
  00218	e8 00 00 00 00	 call	 ?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetMapAttrHollow

; 485  : 				this->PullObjInnerPlace(iChaosCastleIndex, this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS);

  0021d	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  00220	52		 push	 edx
  00221	56		 push	 esi
  00222	8b cf		 mov	 ecx, edi
  00224	e8 00 00 00 00	 call	 ?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z ; CChaosCastle::PullObjInnerPlace
$LN17@ProcState_@3:

; 486  : 			}
; 487  : 
; 488  : 			BOOL bPlayEnded = this->CheckPlayEnded(iChaosCastleIndex);

  00229	56		 push	 esi
  0022a	8b cf		 mov	 ecx, edi
  0022c	e8 00 00 00 00	 call	 ?CheckPlayEnded@CChaosCastle@@QAEHH@Z ; CChaosCastle::CheckPlayEnded

; 489  : 
; 490  : 			if ( bPlayEnded == TRUE )

  00231	83 f8 01	 cmp	 eax, 1
  00234	0f 85 c1 00 00
	00		 jne	 $LN16@ProcState_@3

; 491  : 			{
; 492  : 				int iWinnerIndex = -1;
; 493  : 				int iMonsterCount = this->GetMonsterListCount(iChaosCastleIndex);

  0023a	56		 push	 esi
  0023b	8b cf		 mov	 ecx, edi
  0023d	c7 85 e8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _iWinnerIndex$157842[ebp], -1
  00247	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount

; 494  : 
; 495  : 				if ( iMonsterCount <= 0 )

  0024c	85 c0		 test	 eax, eax
  0024e	0f 8f 9a 00 00
	00		 jg	 $LN15@ProcState_@3

; 496  : 				{
; 497  : 					iWinnerIndex = this->GetCurrentWinUser(iChaosCastleIndex);

  00254	56		 push	 esi
  00255	8b cf		 mov	 ecx, edi
  00257	e8 00 00 00 00	 call	 ?GetCurrentWinUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentWinUser
  0025c	8b d8		 mov	 ebx, eax

; 498  : 
; 499  : 					if ( iWinnerIndex != -1 )

  0025e	83 fb ff	 cmp	 ebx, -1
  00261	74 73		 je	 SHORT $LN14@ProcState_@3

; 500  : 					{
; 501  : 						LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] is Winner. [CharInfoSave : Class=%d, Level=%d, LvPoint=%d, Exp=%d, Str=%d, Dex=%d, Vit=%d, Energy=%d, LeaderShip=%d, Map=%d, Pk=%d]",
; 502  : 							iChaosCastleIndex+1, gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name,
; 503  : 							gObj[iWinnerIndex].Class, gObj[iWinnerIndex].Level, gObj[iWinnerIndex].LevelUpPoint,
; 504  : 							gObj[iWinnerIndex].Experience, gObj[iWinnerIndex].Strength,
; 505  : 							gObj[iWinnerIndex].Dexterity, gObj[iWinnerIndex].Vitality, gObj[iWinnerIndex].Energy,
; 506  : 							gObj[iWinnerIndex].Leadership, gObj[iWinnerIndex].MapNumber, gObj[iWinnerIndex].m_PK_Level);

  00263	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00269	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+253]
  00270	0f b6 90 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00277	51		 push	 ecx
  00278	0f b7 88 d8 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+216]
  0027f	52		 push	 edx
  00280	0f b7 90 ba 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+186]
  00287	51		 push	 ecx
  00288	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+184]
  0028f	52		 push	 edx
  00290	0f b7 90 b6 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+182]
  00297	51		 push	 ecx
  00298	0f b7 88 b4 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+180]
  0029f	52		 push	 edx
  002a0	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+168]
  002a6	51		 push	 ecx
  002a7	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+160]
  002ad	52		 push	 edx
  002ae	0f bf 90 9c 00
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+156]
  002b5	51		 push	 ecx
  002b6	0f b7 88 98 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+152]
  002bd	52		 push	 edx
  002be	51		 push	 ecx
  002bf	8d 90 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  002c5	52		 push	 edx
  002c6	8d 80 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  002cc	50		 push	 eax
  002cd	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  002d0	51		 push	 ecx

; 507  : 
; 508  : 						this->SendWinMessage(iChaosCastleIndex, iWinnerIndex);
; 509  : 						this->GiveWinnerItem(iChaosCastleIndex, iWinnerIndex);
; 510  : 					}
; 511  : 					else

  002d1	e9 bf 01 00 00	 jmp	 $LN33@ProcState_@3
$LN14@ProcState_@3:

; 512  : 					{
; 513  : 						LogAdd(LOG_BLACK, "[Chaos Castle] (%d) Has No Winner.", iChaosCastleIndex+1);

  002d6	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  002d9	52		 push	 edx
  002da	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
  002df	6a 00		 push	 0
  002e1	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  002e6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 514  : 					}
; 515  : 				}
; 516  : 				else

  002e9	e9 fc 01 00 00	 jmp	 $LN1@ProcState_@3
$LN15@ProcState_@3:

; 517  : 				{
; 518  : 					LogAdd(LOG_BLACK, "[Chaos Castle] (%d) Has No Winner : Monster Left (%d)",
; 519  : 						iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT);

  002ee	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  002f1	50		 push	 eax
  002f2	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  002f5	51		 push	 ecx

; 520  : 				}
; 521  : 
; 522  : 				this->SendAllLoserFailMessage(iChaosCastleIndex, iWinnerIndex);
; 523  : 				this->SetState(iChaosCastleIndex, CC_STATE_PLAYEND);
; 524  : 
; 525  : 				return;

  002f6	e9 da 01 00 00	 jmp	 $LN31@ProcState_@3
$LN16@ProcState_@3:

; 526  : 			}
; 527  : 		
; 528  : 			if ( bPlayEnded == 2 )

  002fb	83 f8 02	 cmp	 eax, 2
  002fe	0f 85 b9 00 00
	00		 jne	 $LN11@ProcState_@3

; 529  : 			{
; 530  : 				int iWinnerIndex = -1;
; 531  : 				int iMonsterCount = this->GetMonsterListCount(iChaosCastleIndex);

  00304	56		 push	 esi
  00305	8b cf		 mov	 ecx, edi
  00307	c7 85 e8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _iWinnerIndex$157852[ebp], -1
  00311	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount

; 532  : 
; 533  : 				if ( iMonsterCount <= 0 )

  00316	85 c0		 test	 eax, eax
  00318	0f 8f 96 00 00
	00		 jg	 $LN10@ProcState_@3

; 534  : 				{
; 535  : 					iWinnerIndex = this->GetCurrentWinUser(iChaosCastleIndex);

  0031e	56		 push	 esi
  0031f	8b cf		 mov	 ecx, edi
  00321	e8 00 00 00 00	 call	 ?GetCurrentWinUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentWinUser
  00326	8b d8		 mov	 ebx, eax

; 536  : 
; 537  : 					if ( iWinnerIndex != -1 )

  00328	83 fb ff	 cmp	 ebx, -1
  0032b	74 6f		 je	 SHORT $LN9@ProcState_@3

; 538  : 					{
; 539  : 						LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] is Winner. [CharInfoSave : Class=%d, Level=%d, LvPoint=%d, Exp=%d, Str=%d, Dex=%d, Vit=%d, Energy=%d, LeaderShip=%d, Map=%d, Pk=%d]",
; 540  : 							iChaosCastleIndex+1, gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name,
; 541  : 							gObj[iWinnerIndex].Class, gObj[iWinnerIndex].Level, gObj[iWinnerIndex].LevelUpPoint,
; 542  : 							gObj[iWinnerIndex].Experience, gObj[iWinnerIndex].Strength,
; 543  : 							gObj[iWinnerIndex].Dexterity, gObj[iWinnerIndex].Vitality, gObj[iWinnerIndex].Energy,
; 544  : 							gObj[iWinnerIndex].Leadership, gObj[iWinnerIndex].MapNumber, gObj[iWinnerIndex].m_PK_Level);

  0032d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00333	0f be 90 fd 00
	00 00		 movsx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+253]
  0033a	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00341	52		 push	 edx
  00342	0f b7 90 d8 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+216]
  00349	51		 push	 ecx
  0034a	0f b7 88 ba 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+186]
  00351	52		 push	 edx
  00352	0f b7 90 b8 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+184]
  00359	51		 push	 ecx
  0035a	0f b7 88 b6 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+182]
  00361	52		 push	 edx
  00362	0f b7 90 b4 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+180]
  00369	51		 push	 ecx
  0036a	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+168]
  00370	52		 push	 edx
  00371	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+160]
  00377	51		 push	 ecx
  00378	0f bf 88 9c 00
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+156]
  0037f	52		 push	 edx
  00380	0f b7 90 98 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+152]
  00387	51		 push	 ecx
  00388	52		 push	 edx
  00389	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  0038f	51		 push	 ecx
  00390	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00396	52		 push	 edx

; 545  : 
; 546  : 						this->SendWinMessage(iChaosCastleIndex, iWinnerIndex);
; 547  : 						this->GiveWinnerItem(iChaosCastleIndex, iWinnerIndex);
; 548  : 					}
; 549  : 					else

  00397	e9 f5 00 00 00	 jmp	 $LN34@ProcState_@3
$LN9@ProcState_@3:

; 550  : 					{
; 551  : 						LogAdd(LOG_BLACK, "[Chaos Castle] (%d) Has No Winner.", iChaosCastleIndex+1);

  0039c	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0039f	51		 push	 ecx
  003a0	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
  003a5	6a 00		 push	 0
  003a7	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  003ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 552  : 					}
; 553  : 				}
; 554  : 				else

  003af	e9 36 01 00 00	 jmp	 $LN1@ProcState_@3
$LN10@ProcState_@3:

; 555  : 				{
; 556  : 					LogAdd(LOG_BLACK, "[Chaos Castle] (%d) Has No Winner : Monster Left (%d)",
; 557  : 						iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT);

  003b4	8b 53 60	 mov	 edx, DWORD PTR [ebx+96]
  003b7	52		 push	 edx

; 558  : 				}
; 559  : 
; 560  : 				this->SendAllLoserFailMessage(iChaosCastleIndex, iWinnerIndex);
; 561  : 				this->SetState(iChaosCastleIndex, CC_STATE_PLAYEND);
; 562  : 
; 563  : 				return;

  003b8	e9 14 01 00 00	 jmp	 $LN32@ProcState_@3
$LN11@ProcState_@3:

; 564  : 			}
; 565  : 		
; 566  : 			if ( bPlayEnded == FALSE )

  003bd	85 c0		 test	 eax, eax
  003bf	75 0a		 jne	 SHORT $LN29@ProcState_@3

; 567  : 			{
; 568  : 				this->SendNoticeState(iChaosCastleIndex, 6);

  003c1	6a 06		 push	 6
  003c3	56		 push	 esi
  003c4	8b cf		 mov	 ecx, edi
  003c6	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState
$LN29@ProcState_@3:

; 569  : 			}
; 570  : 		}
; 571  : 	}
; 572  : 
; 573  : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 0 )

  003cb	83 7b 40 00	 cmp	 DWORD PTR [ebx+64], 0
  003cf	0f 8f 28 01 00
	00		 jg	 $LN5@ProcState_@3

; 574  : 	{
; 575  : 		LogAdd(LOG_BLACK, "[Chaos Castle] (%d) is Over : TIME-OUT (Left User:%d, Monster:%d)",
; 576  : 			iChaosCastleIndex+1, this->GetCurPlayUser(iChaosCastleIndex), this->GetMonsterListCount(iChaosCastleIndex));

  003d5	56		 push	 esi
  003d6	8b cf		 mov	 ecx, edi
  003d8	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  003dd	50		 push	 eax
  003de	56		 push	 esi
  003df	8b cf		 mov	 ecx, edi
  003e1	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  003e6	50		 push	 eax
  003e7	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  003ea	50		 push	 eax
  003eb	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@CDMJLAJE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5is?5Over?5?3?5TI@
  003f0	6a 00		 push	 0
  003f2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  003f7	83 c4 14	 add	 esp, 20			; 00000014H

; 577  : 
; 578  : 
; 579  : 		int iWinnerIndex = -1;
; 580  : 		int iMonsterCount = this->GetMonsterListCount(iChaosCastleIndex);

  003fa	56		 push	 esi
  003fb	8b cf		 mov	 ecx, edi
  003fd	c7 85 e8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _iWinnerIndex$157861[ebp], -1
  00407	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount

; 581  : 
; 582  : 		if ( iMonsterCount <= 0 )

  0040c	85 c0		 test	 eax, eax
  0040e	0f 8f b9 00 00
	00		 jg	 $LN4@ProcState_@3

; 583  : 		{
; 584  : 			iWinnerIndex = this->GetCurrentWinUser(iChaosCastleIndex);

  00414	56		 push	 esi
  00415	8b cf		 mov	 ecx, edi
  00417	e8 00 00 00 00	 call	 ?GetCurrentWinUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentWinUser
  0041c	8b d8		 mov	 ebx, eax

; 585  : 
; 586  : 			if ( iWinnerIndex != -1 )

  0041e	83 fb ff	 cmp	 ebx, -1
  00421	0f 84 91 00 00
	00		 je	 $LN3@ProcState_@3

; 587  : 			{
; 588  : 				LogAdd(LOG_BLACK, "[Chaos Castle] (%d) [%s][%s] is Winner. [CharInfoSave : Class=%d, Level=%d, LvPoint=%d, Exp=%d, Str=%d, Dex=%d, Vit=%d, Energy=%d, LeaderShip=%d, Map=%d, Pk=%d]",
; 589  : 					iChaosCastleIndex+1, gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name,
; 590  : 					gObj[iWinnerIndex].Class, gObj[iWinnerIndex].Level, gObj[iWinnerIndex].LevelUpPoint,
; 591  : 					gObj[iWinnerIndex].Experience, gObj[iWinnerIndex].Strength,
; 592  : 					gObj[iWinnerIndex].Dexterity, gObj[iWinnerIndex].Vitality, gObj[iWinnerIndex].Energy,
; 593  : 					gObj[iWinnerIndex].Leadership, gObj[iWinnerIndex].MapNumber, gObj[iWinnerIndex].m_PK_Level);

  00427	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0042d	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+253]
  00434	0f b6 90 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  0043b	51		 push	 ecx
  0043c	0f b7 88 d8 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+216]
  00443	52		 push	 edx
  00444	0f b7 90 ba 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+186]
  0044b	51		 push	 ecx
  0044c	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+184]
  00453	52		 push	 edx
  00454	0f b7 90 b6 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+182]
  0045b	51		 push	 ecx
  0045c	0f b7 88 b4 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+180]
  00463	52		 push	 edx
  00464	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+168]
  0046a	51		 push	 ecx
  0046b	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+160]
  00471	52		 push	 edx
  00472	0f bf 90 9c 00
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+156]
  00479	51		 push	 ecx
  0047a	0f b7 88 98 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+152]
  00481	52		 push	 edx
  00482	51		 push	 ecx
  00483	8d 90 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  00489	52		 push	 edx
  0048a	8d 80 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00490	50		 push	 eax
$LN34@ProcState_@3:
  00491	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00494	50		 push	 eax
$LN33@ProcState_@3:
  00495	68 00 00 00 00	 push	 OFFSET ??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@
  0049a	6a 00		 push	 0
  0049c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  004a1	83 c4 40	 add	 esp, 64			; 00000040H

; 594  : 
; 595  : 				this->SendWinMessage(iChaosCastleIndex, iWinnerIndex);

  004a4	53		 push	 ebx
  004a5	56		 push	 esi
  004a6	8b cf		 mov	 ecx, edi
  004a8	e8 00 00 00 00	 call	 ?SendWinMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendWinMessage

; 596  : 				this->GiveWinnerItem(iChaosCastleIndex, iWinnerIndex);

  004ad	53		 push	 ebx
  004ae	56		 push	 esi
  004af	8b cf		 mov	 ecx, edi
  004b1	e8 00 00 00 00	 call	 ?GiveWinnerItem@CChaosCastle@@QAEXHH@Z ; CChaosCastle::GiveWinnerItem

; 597  : 			}
; 598  : 			else

  004b6	eb 32		 jmp	 SHORT $LN1@ProcState_@3
$LN3@ProcState_@3:

; 599  : 			{
; 600  : 				LogAdd(LOG_BLACK, "[Chaos Castle] (%d) Has No Winner.", iChaosCastleIndex+1);

  004b8	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  004bb	50		 push	 eax
  004bc	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
  004c1	6a 00		 push	 0
  004c3	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  004c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 601  : 			}
; 602  : 		}
; 603  : 		else

  004cb	eb 1d		 jmp	 SHORT $LN1@ProcState_@3
$LN4@ProcState_@3:

; 604  : 		{
; 605  : 			LogAdd(LOG_BLACK, "[Chaos Castle] (%d) Has No Winner : Monster Left (%d)",
; 606  : 				iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT);

  004cd	8b 4b 60	 mov	 ecx, DWORD PTR [ebx+96]
  004d0	51		 push	 ecx
$LN32@ProcState_@3:
  004d1	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  004d4	50		 push	 eax
$LN31@ProcState_@3:
  004d5	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
  004da	6a 00		 push	 0
  004dc	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  004e1	8b 9d e8 fe ff
	ff		 mov	 ebx, DWORD PTR _iWinnerIndex$157861[ebp]
  004e7	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@ProcState_@3:

; 607  : 		}
; 608  : 
; 609  : 		this->SendAllLoserFailMessage(iChaosCastleIndex, iWinnerIndex);

  004ea	53		 push	 ebx
  004eb	56		 push	 esi
  004ec	8b cf		 mov	 ecx, edi
  004ee	e8 00 00 00 00	 call	 ?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendAllLoserFailMessage

; 610  : 		this->SetState(iChaosCastleIndex, CC_STATE_PLAYEND);

  004f3	6a 03		 push	 3
  004f5	56		 push	 esi
  004f6	8b cf		 mov	 ecx, edi
  004f8	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
$LN5@ProcState_@3:

; 611  : 	}
; 612  : }

  004fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00500	5f		 pop	 edi
  00501	5e		 pop	 esi
  00502	33 cd		 xor	 ecx, ebp
  00504	5b		 pop	 ebx
  00505	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0050a	8b e5		 mov	 esp, ebp
  0050c	5d		 pop	 ebp
  0050d	c2 04 00	 ret	 4
?ProcState_Playing@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::ProcState_Playing
_TEXT	ENDS
PUBLIC	?Run@CChaosCastle@@QAEXXZ			; CChaosCastle::Run
; Function compile flags: /Ogtp
;	COMDAT ?Run@CChaosCastle@@QAEXXZ
_TEXT	SEGMENT
?Run@CChaosCastle@@QAEXXZ PROC				; CChaosCastle::Run, COMDAT
; _this$ = ecx

; 53   : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 54   : 	if ( this->m_bCC_EVENT_ENABLE != FALSE )

  00003	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00007	74 3f		 je	 SHORT $LN7@Run

; 55   : 	{
; 56   : 		for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)

  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	33 f6		 xor	 esi, esi
  0000d	8d 7b 30	 lea	 edi, DWORD PTR [ebx+48]
$LL9@Run:

; 57   : 		{
; 58   : 			switch ( this->m_stChaosCastleData[i].m_iCC_STATE )

  00010	8b 07		 mov	 eax, DWORD PTR [edi]
  00012	83 f8 03	 cmp	 eax, 3
  00015	77 23		 ja	 SHORT $LN8@Run
  00017	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN15@Run[eax*4]
$LN3@Run:

; 59   : 			{
; 60   : 				case CC_STATE_NONE:
; 61   : 					this->ProcState_None(i);
; 62   : 					break;
; 63   : 
; 64   : 				case CC_STATE_CLOSED:
; 65   : 					this->ProcState_Closed(i);

  0001e	56		 push	 esi
  0001f	8b cb		 mov	 ecx, ebx
  00021	e8 00 00 00 00	 call	 ?ProcState_Closed@CChaosCastle@@IAEXH@Z ; CChaosCastle::ProcState_Closed

; 66   : 					break;

  00026	eb 12		 jmp	 SHORT $LN8@Run
$LN2@Run:

; 67   : 
; 68   : 				case CC_STATE_PLAYING:
; 69   : 					this->ProcState_Playing(i);

  00028	56		 push	 esi
  00029	8b cb		 mov	 ecx, ebx
  0002b	e8 00 00 00 00	 call	 ?ProcState_Playing@CChaosCastle@@IAEXH@Z ; CChaosCastle::ProcState_Playing

; 70   : 					break;

  00030	eb 08		 jmp	 SHORT $LN8@Run
$LN1@Run:

; 71   : 
; 72   : 				case CC_STATE_PLAYEND:
; 73   : 					this->ProcState_PlayEnd(i);

  00032	56		 push	 esi
  00033	8b cb		 mov	 ecx, ebx
  00035	e8 00 00 00 00	 call	 ?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z ; CChaosCastle::ProcState_PlayEnd
$LN8@Run:

; 55   : 	{
; 56   : 		for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)

  0003a	46		 inc	 esi
  0003b	81 c7 6c 08 00
	00		 add	 edi, 2156		; 0000086cH
  00041	83 fe 06	 cmp	 esi, 6
  00044	7c ca		 jl	 SHORT $LL9@Run
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
$LN7@Run:
  00048	5b		 pop	 ebx

; 74   : 					break;
; 75   : 			}
; 76   : 		}
; 77   : 
; 78   : /*#if (FOREIGN_GAMESERVER==1)
; 79   : 
; 80   : 		if ( szAuthKey[13] != AUTHKEY13 )
; 81   : 		{
; 82   : 			DestroyGIocp();
; 83   : 		}
; 84   : 
; 85   : #endif*/
; 86   : 	}
; 87   : }

  00049	c3		 ret	 0
  0004a	8b ff		 npad	 2
$LN15@Run:
  0004c	00 00 00 00	 DD	 $LN8@Run
  00050	00 00 00 00	 DD	 $LN3@Run
  00054	00 00 00 00	 DD	 $LN2@Run
  00058	00 00 00 00	 DD	 $LN1@Run
?Run@CChaosCastle@@QAEXXZ ENDP				; CChaosCastle::Run
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_ChaosCastle@@YAXXZ
text$yc	SEGMENT
??__Eg_ChaosCastle@@YAXXZ PROC				; `dynamic initializer for 'g_ChaosCastle'', COMDAT

; 21   : CChaosCastle g_ChaosCastle;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00005	e8 00 00 00 00	 call	 ??0CChaosCastle@@QAE@XZ	; CChaosCastle::CChaosCastle
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_ChaosCastle@@YAXXZ ; `dynamic atexit destructor for 'g_ChaosCastle''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_ChaosCastle@@YAXXZ ENDP				; `dynamic initializer for 'g_ChaosCastle''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_ChaosCastle@@YAXXZ
text$yd	SEGMENT
??__Fg_ChaosCastle@@YAXXZ PROC				; `dynamic atexit destructor for 'g_ChaosCastle'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00005	e9 00 00 00 00	 jmp	 ??1CChaosCastle@@UAE@XZ	; CChaosCastle::~CChaosCastle
??__Fg_ChaosCastle@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_ChaosCastle''
text$yd	ENDS
PUBLIC	?g_ChaosCastle@@3VCChaosCastle@@A		; g_ChaosCastle
_BSS	SEGMENT
?g_ChaosCastle@@3VCChaosCastle@@A DB 032b8H DUP (?)	; g_ChaosCastle
_BSS	ENDS
CRT$XCU	SEGMENT
_g_ChaosCastle$initializer$ DD FLAT:??__Eg_ChaosCastle@@YAXXZ
CRT$XCU	ENDS
END
