; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\MagicInf.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_7CMagicInf@@6B@				; CMagicInf::`vftable'
PUBLIC	??1CMagicInf@@UAE@XZ				; CMagicInf::~CMagicInf
PUBLIC	??_R4CMagicInf@@6B@				; CMagicInf::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMagicInf@@@8				; CMagicInf `RTTI Type Descriptor'
PUBLIC	??_R3CMagicInf@@8				; CMagicInf::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMagicInf@@8				; CMagicInf::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMagicInf@@8			; CMagicInf::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECMagicInf@@UAEPAXI@Z:PROC			; CMagicInf::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CMagicInf@@8
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\magicinf.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CMagicInf@@8 DD FLAT:??_R0?AVCMagicInf@@@8 ; CMagicInf::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMagicInf@@8
rdata$r	ENDS
;	COMDAT ??_R2CMagicInf@@8
rdata$r	SEGMENT
??_R2CMagicInf@@8 DD FLAT:??_R1A@?0A@EA@CMagicInf@@8	; CMagicInf::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMagicInf@@8
rdata$r	SEGMENT
??_R3CMagicInf@@8 DD 00H				; CMagicInf::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMagicInf@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMagicInf@@@8
_DATA	SEGMENT
??_R0?AVCMagicInf@@@8 DD FLAT:??_7type_info@@6B@	; CMagicInf `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMagicInf@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CMagicInf@@6B@
rdata$r	SEGMENT
??_R4CMagicInf@@6B@ DD 00H				; CMagicInf::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMagicInf@@@8
	DD	FLAT:??_R3CMagicInf@@8
rdata$r	ENDS
;	COMDAT ??_7CMagicInf@@6B@
CONST	SEGMENT
??_7CMagicInf@@6B@ DD FLAT:??_R4CMagicInf@@6B@		; CMagicInf::`vftable'
	DD	FLAT:??_ECMagicInf@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1CMagicInf@@UAE@XZ
_TEXT	SEGMENT
??1CMagicInf@@UAE@XZ PROC				; CMagicInf::~CMagicInf, COMDAT
; _this$ = ecx

; 19   : 	this->m_DamageMin  = 0;

  00000	33 c0		 xor	 eax, eax
  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMagicInf@@6B@
  00008	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 20   : 	this->m_DamageMax  = 0;

  0000b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 21   : }

  0000e	c3		 ret	 0
??1CMagicInf@@UAE@XZ ENDP				; CMagicInf::~CMagicInf
_TEXT	ENDS
PUBLIC	?Clear@CMagicInf@@QAEXXZ			; CMagicInf::Clear
; Function compile flags: /Ogtp
;	COMDAT ?Clear@CMagicInf@@QAEXXZ
_TEXT	SEGMENT
?Clear@CMagicInf@@QAEXXZ PROC				; CMagicInf::Clear, COMDAT
; _this$ = ecx

; 25   : 	this->m_Skill  = -1;

  00000	66 c7 41 04 00
	ff		 mov	 WORD PTR [ecx+4], 65280	; 0000ff00H

; 26   : 	this->m_Level  = 0;
; 27   : }

  00006	c3		 ret	 0
?Clear@CMagicInf@@QAEXXZ ENDP				; CMagicInf::Clear
_TEXT	ENDS
PUBLIC	?IsMagic@CMagicInf@@QAEHXZ			; CMagicInf::IsMagic
; Function compile flags: /Ogtp
;	COMDAT ?IsMagic@CMagicInf@@QAEHXZ
_TEXT	SEGMENT
?IsMagic@CMagicInf@@QAEHXZ PROC				; CMagicInf::IsMagic, COMDAT
; _this$ = ecx

; 31   : 	if ( this->m_Skill == 0xFF )

  00000	33 c0		 xor	 eax, eax
  00002	80 79 05 ff	 cmp	 BYTE PTR [ecx+5], 255	; 000000ffH
  00006	0f 95 c0	 setne	 al

; 32   : 	{
; 33   : 		return false;
; 34   : 	}
; 35   : 	return true;
; 36   : }

  00009	c3		 ret	 0
?IsMagic@CMagicInf@@QAEHXZ ENDP				; CMagicInf::IsMagic
_TEXT	ENDS
PUBLIC	?GetSkillNumberInex@@YAHHHH@Z			; GetSkillNumberInex
; Function compile flags: /Ogtp
;	COMDAT ?GetSkillNumberInex@@YAHHHH@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
_Index$ = 12						; size = 4
_level$ = 16						; size = 4
?GetSkillNumberInex@@YAHHHH@Z PROC			; GetSkillNumberInex, COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 40   : 	int skillnumber = -1;
; 41   : 
; 42   : 	if ( type == 15 )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  00006	83 c8 ff	 or	 eax, -1
  00009	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  0000c	75 2f		 jne	 SHORT $LN29@GetSkillNu

; 43   : 	{
; 44   : 		if ( Index >= 0 && Index < 16 )

  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  00011	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00014	77 05		 ja	 SHORT $LN28@GetSkillNu

; 45   : 		{
; 46   : 			skillnumber = Index + 1;

  00016	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN28@GetSkillNu:

; 47   : 		}
; 48   : 		else if ( Index == 16 )

  0001b	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0001e	75 05		 jne	 SHORT $LN26@GetSkillNu

; 49   : 		{
; 50   : 			skillnumber = 38;

  00020	8d 41 16	 lea	 eax, DWORD PTR [ecx+22]

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
$LN26@GetSkillNu:

; 51   : 		}
; 52   : 		else if ( Index == 17 )

  00025	83 f9 11	 cmp	 ecx, 17			; 00000011H
  00028	75 05		 jne	 SHORT $LN24@GetSkillNu

; 53   : 		{
; 54   : 			skillnumber = 39;

  0002a	8d 41 16	 lea	 eax, DWORD PTR [ecx+22]

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN24@GetSkillNu:

; 55   : 		}
; 56   : 		else if ( Index == 18 )

  0002f	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00032	0f 85 a1 00 00
	00		 jne	 $LN18@GetSkillNu

; 57   : 		{
; 58   : 			skillnumber = 40;

  00038	8d 41 16	 lea	 eax, DWORD PTR [ecx+22]

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN29@GetSkillNu:

; 59   : 		}
; 60   : 	}
; 61   : 
; 62   : 	else if ( type == 12 )

  0003d	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  00040	0f 85 93 00 00
	00		 jne	 $LN18@GetSkillNu

; 63   : 	{
; 64   : 		switch ( Index )

  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  00049	83 c1 f9	 add	 ecx, -7			; fffffff9H
  0004c	83 f9 1c	 cmp	 ecx, 28			; 0000001cH
  0004f	0f 87 84 00 00
	00		 ja	 $LN18@GetSkillNu
  00055	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN32@GetSkillNu[ecx]
  0005c	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN33@GetSkillNu[ecx*4]
$LN17@GetSkillNu:

; 65   : 		{
; 66   : 			case 7:		skillnumber = 41;	break;

  00063	b8 29 00 00 00	 mov	 eax, 41			; 00000029H

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN16@GetSkillNu:

; 67   : 			case 8:		skillnumber = 26;	break;

  0006a	b8 1a 00 00 00	 mov	 eax, 26			; 0000001aH

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN15@GetSkillNu:

; 68   : 			case 9:		skillnumber = 27;	break;

  00071	b8 1b 00 00 00	 mov	 eax, 27			; 0000001bH

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
$LN14@GetSkillNu:

; 69   : 			case 10:	skillnumber = 28;	break;

  00078	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
$LN13@GetSkillNu:

; 70   : 			case 12:	skillnumber = 42;	break;

  0007f	b8 2a 00 00 00	 mov	 eax, 42			; 0000002aH

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
$LN12@GetSkillNu:

; 71   : 			case 13:	skillnumber = 47;	break;

  00086	b8 2f 00 00 00	 mov	 eax, 47			; 0000002fH

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN11@GetSkillNu:

; 72   : 			case 14:	skillnumber = 48;	break;

  0008d	b8 30 00 00 00	 mov	 eax, 48			; 00000030H

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN10@GetSkillNu:

; 73   : 			case 19:	skillnumber = 43;	break;

  00094	b8 2b 00 00 00	 mov	 eax, 43			; 0000002bH

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
$LN9@GetSkillNu:

; 74   : 			case 17:	skillnumber = 52;	break;

  0009b	b8 34 00 00 00	 mov	 eax, 52			; 00000034H

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
$LN8@GetSkillNu:

; 75   : 			case 18:	skillnumber = 51;	break;

  000a2	b8 33 00 00 00	 mov	 eax, 51			; 00000033H

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
$LN7@GetSkillNu:

; 76   : 			case 16:	skillnumber = 55;	break;

  000a9	b8 37 00 00 00	 mov	 eax, 55			; 00000037H

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
$LN6@GetSkillNu:

; 77   : 			case 21:	skillnumber = 61;	break;

  000b0	b8 3d 00 00 00	 mov	 eax, 61			; 0000003dH

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
$LN5@GetSkillNu:

; 78   : 			case 22:	skillnumber = 63;	break;

  000b7	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
$LN4@GetSkillNu:

; 79   : 			case 23:	skillnumber = 64;	break;

  000be	b8 40 00 00 00	 mov	 eax, 64			; 00000040H

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
$LN3@GetSkillNu:

; 80   : 			case 24:	skillnumber = 65;	break;

  000c5	b8 41 00 00 00	 mov	 eax, 65			; 00000041H

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
$LN2@GetSkillNu:

; 81   : 			case 11:	skillnumber = level + 30;	break;

  000cc	8b 45 10	 mov	 eax, DWORD PTR _level$[ebp]
  000cf	83 c0 1e	 add	 eax, 30			; 0000001eH

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
$LN1@GetSkillNu:

; 82   : 			case 35:	skillnumber = 78;	break;

  000d4	b8 4e 00 00 00	 mov	 eax, 78			; 0000004eH
$LN18@GetSkillNu:

; 83   : 		}
; 84   : 	}
; 85   : 		
; 86   : 	return skillnumber;
; 87   : }

  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
  000db	90		 npad	 1
$LN33@GetSkillNu:
  000dc	00 00 00 00	 DD	 $LN17@GetSkillNu
  000e0	00 00 00 00	 DD	 $LN16@GetSkillNu
  000e4	00 00 00 00	 DD	 $LN15@GetSkillNu
  000e8	00 00 00 00	 DD	 $LN14@GetSkillNu
  000ec	00 00 00 00	 DD	 $LN2@GetSkillNu
  000f0	00 00 00 00	 DD	 $LN13@GetSkillNu
  000f4	00 00 00 00	 DD	 $LN12@GetSkillNu
  000f8	00 00 00 00	 DD	 $LN11@GetSkillNu
  000fc	00 00 00 00	 DD	 $LN7@GetSkillNu
  00100	00 00 00 00	 DD	 $LN9@GetSkillNu
  00104	00 00 00 00	 DD	 $LN8@GetSkillNu
  00108	00 00 00 00	 DD	 $LN10@GetSkillNu
  0010c	00 00 00 00	 DD	 $LN6@GetSkillNu
  00110	00 00 00 00	 DD	 $LN5@GetSkillNu
  00114	00 00 00 00	 DD	 $LN4@GetSkillNu
  00118	00 00 00 00	 DD	 $LN3@GetSkillNu
  0011c	00 00 00 00	 DD	 $LN1@GetSkillNu
  00120	00 00 00 00	 DD	 $LN18@GetSkillNu
$LN32@GetSkillNu:
  00124	00		 DB	 0
  00125	01		 DB	 1
  00126	02		 DB	 2
  00127	03		 DB	 3
  00128	04		 DB	 4
  00129	05		 DB	 5
  0012a	06		 DB	 6
  0012b	07		 DB	 7
  0012c	11		 DB	 17			; 00000011H
  0012d	08		 DB	 8
  0012e	09		 DB	 9
  0012f	0a		 DB	 10			; 0000000aH
  00130	0b		 DB	 11			; 0000000bH
  00131	11		 DB	 17			; 00000011H
  00132	0c		 DB	 12			; 0000000cH
  00133	0d		 DB	 13			; 0000000dH
  00134	0e		 DB	 14			; 0000000eH
  00135	0f		 DB	 15			; 0000000fH
  00136	11		 DB	 17			; 00000011H
  00137	11		 DB	 17			; 00000011H
  00138	11		 DB	 17			; 00000011H
  00139	11		 DB	 17			; 00000011H
  0013a	11		 DB	 17			; 00000011H
  0013b	11		 DB	 17			; 00000011H
  0013c	11		 DB	 17			; 00000011H
  0013d	11		 DB	 17			; 00000011H
  0013e	11		 DB	 17			; 00000011H
  0013f	11		 DB	 17			; 00000011H
  00140	10		 DB	 16			; 00000010H
?GetSkillNumberInex@@YAHHHH@Z ENDP			; GetSkillNumberInex
_TEXT	ENDS
PUBLIC	??_C@_0N@JHHEKDLI@MagicInf?4cpp?$AA@		; `string'
PUBLIC	?Set@CMagicInf@@QAEHEEE@Z			; CMagicInf::Set
EXTRN	?SkillGet@CMagicDamage@@QAEHH@Z:PROC		; CMagicDamage::SkillGet
EXTRN	?MagicDamageC@@3VCMagicDamage@@A:BYTE		; MagicDamageC
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
;	COMDAT ??_C@_0N@JHHEKDLI@MagicInf?4cpp?$AA@
CONST	SEGMENT
??_C@_0N@JHHEKDLI@MagicInf?4cpp?$AA@ DB 'MagicInf.cpp', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Set@CMagicInf@@QAEHEEE@Z
_TEXT	SEGMENT
_aType$ = 8						; size = 1
_aIndex$ = 12						; size = 1
_aLevel$ = 16						; size = 1
?Set@CMagicInf@@QAEHEEE@Z PROC				; CMagicInf::Set, COMDAT
; _this$ = ecx

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   : 	if ( this->m_Skill != 0xFF )

  00006	80 7e 05 ff	 cmp	 BYTE PTR [esi+5], 255	; 000000ffH
  0000a	74 29		 je	 SHORT $LN2@Set

; 92   : 	{
; 93   : 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(1, 203)), __FILE__, __LINE__);

  0000c	6a 5d		 push	 93			; 0000005dH
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JHHEKDLI@MagicInf?4cpp?$AA@
  00013	68 cb 01 00 00	 push	 459			; 000001cbH
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0001d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00022	50		 push	 eax
  00023	6a 00		 push	 0
  00025	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 94   : 		return -1;

  0002d	83 c8 ff	 or	 eax, -1
  00030	5e		 pop	 esi

; 110  : }

  00031	5d		 pop	 ebp
  00032	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Set:

; 95   : 	}
; 96   : 
; 97   : 	this->m_Level = aLevel;

  00035	8a 45 10	 mov	 al, BYTE PTR _aLevel$[ebp]

; 98   : 	this->m_Skill = GetSkillNumberInex(aType, aIndex, aLevel);

  00038	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _aIndex$[ebp]
  0003c	0f b6 55 08	 movzx	 edx, BYTE PTR _aType$[ebp]
  00040	88 46 04	 mov	 BYTE PTR [esi+4], al
  00043	0f b6 c0	 movzx	 eax, al
  00046	50		 push	 eax
  00047	51		 push	 ecx
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ?GetSkillNumberInex@@YAHHHH@Z ; GetSkillNumberInex
  0004e	88 46 05	 mov	 BYTE PTR [esi+5], al

; 99   : 	
; 100  : 	if ( this->m_Skill < 0 )
; 101  : 	{
; 102  : 		this->m_Skill = 1;
; 103  : 	}
; 104  : 
; 105  : 	int damage = MagicDamageC.SkillGet(this->m_Skill);

  00051	0f b6 c0	 movzx	 eax, al
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	50		 push	 eax
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0005d	e8 00 00 00 00	 call	 ?SkillGet@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGet
  00062	8b c8		 mov	 ecx, eax

; 106  : 	this->m_DamageMin = damage;
; 107  : 	this->m_DamageMax = damage + damage/2;

  00064	99		 cdq
  00065	2b c2		 sub	 eax, edx
  00067	d1 f8		 sar	 eax, 1
  00069	03 c1		 add	 eax, ecx
  0006b	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 108  : 
; 109  : 	return this->m_Skill;

  0006e	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00072	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00075	5e		 pop	 esi

; 110  : }

  00076	5d		 pop	 ebp
  00077	c2 0c 00	 ret	 12			; 0000000cH
?Set@CMagicInf@@QAEHEEE@Z ENDP				; CMagicInf::Set
_TEXT	ENDS
PUBLIC	?GetDamage@CMagicInf@@QAEHXZ			; CMagicInf::GetDamage
EXTRN	_rand:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__except_handler4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?GetDamage@CMagicInf@@QAEHXZ DD 0fffffffeH
	DD	00H
	DD	0ffffffd0H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN6@GetDamage
	DD	FLAT:$LN7@GetDamage
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?GetDamage@CMagicInf@@QAEHXZ
_TEXT	SEGMENT
_subd$ = -32						; size = 4
_damage$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
?GetDamage@CMagicInf@@QAEHXZ PROC			; CMagicInf::GetDamage, COMDAT
; _this$ = ecx

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?GetDamage@CMagicInf@@QAEHXZ
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 10	 sub	 esp, 16			; 00000010H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00033	8b f1		 mov	 esi, ecx

; 114  : 	int damage = 0;

  00035	33 ff		 xor	 edi, edi
  00037	89 7d e4	 mov	 DWORD PTR _damage$[ebp], edi

; 115  : 
; 116  : 	if ( this->m_Skill == 0xFF )

  0003a	80 7e 05 ff	 cmp	 BYTE PTR [esi+5], 255	; 000000ffH
  0003e	75 34		 jne	 SHORT $LN2@GetDamage

; 117  : 	{
; 118  : 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(1, 202)), __FILE__, __LINE__);

  00040	6a 76		 push	 118			; 00000076H
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JHHEKDLI@MagicInf?4cpp?$AA@
  00047	68 ca 01 00 00	 push	 458			; 000001caH
  0004c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00051	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00056	50		 push	 eax
  00057	57		 push	 edi
  00058	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0005d	83 c4 10	 add	 esp, 16			; 00000010H

; 119  : 		return 0;

  00060	33 c0		 xor	 eax, eax

; 134  : }

  00062	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006c	59		 pop	 ecx
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN2@GetDamage:

; 120  : 	}
; 121  : 
; 122  : 	int subd = this->m_DamageMax - this->m_DamageMin;

  00074	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00077	2b 46 08	 sub	 eax, DWORD PTR [esi+8]
  0007a	89 45 e0	 mov	 DWORD PTR _subd$[ebp], eax

; 123  : 
; 124  : 	__try

  0007d	89 7d fc	 mov	 DWORD PTR __$SEHRec$[ebp+20], edi

; 125  : 	{
; 126  : 		damage = this->m_DamageMin + (rand() % 1);

  00080	e8 00 00 00 00	 call	 _rand
  00085	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00088	89 4d e4	 mov	 DWORD PTR _damage$[ebp], ecx

; 127  : 	}

  0008b	eb 2d		 jmp	 SHORT $LN11@GetDamage
$LN6@GetDamage:
$LN12@GetDamage:

; 128  : 	__except(subd=1,1)

  0008d	b8 01 00 00 00	 mov	 eax, 1
  00092	89 45 e0	 mov	 DWORD PTR _subd$[ebp], eax
$LN10@GetDamage:
$LN8@GetDamage:
  00095	c3		 ret	 0
$LN7@GetDamage:
  00096	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 129  : 	{
; 130  : 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(0, 111)), __FILE__, __LINE__);

  00099	68 82 00 00 00	 push	 130			; 00000082H
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JHHEKDLI@MagicInf?4cpp?$AA@
  000a3	6a 6f		 push	 111			; 0000006fH
  000a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000aa	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000af	50		 push	 eax
  000b0	6a 00		 push	 0
  000b2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000b7	83 c4 10	 add	 esp, 16			; 00000010H
$LN11@GetDamage:

; 131  : 	}

  000ba	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH

; 132  : 
; 133  : 	return damage;

  000c1	8b 45 e4	 mov	 eax, DWORD PTR _damage$[ebp]

; 134  : }

  000c4	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  000c7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ce	59		 pop	 ecx
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
?GetDamage@CMagicInf@@QAEHXZ ENDP			; CMagicInf::GetDamage
_TEXT	ENDS
PUBLIC	?Set@CMagicInf@@QAEHEE@Z			; CMagicInf::Set
; Function compile flags: /Ogtp
;	COMDAT ?Set@CMagicInf@@QAEHEE@Z
_TEXT	SEGMENT
_aSkill$ = 8						; size = 1
_aLevel$ = 12						; size = 1
?Set@CMagicInf@@QAEHEE@Z PROC				; CMagicInf::Set, COMDAT
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 138  : 	if ( this->m_Skill != 0xFF )

  00006	80 7e 05 ff	 cmp	 BYTE PTR [esi+5], 255	; 000000ffH
  0000a	74 08		 je	 SHORT $LN1@Set@2

; 139  : 	{
; 140  : 		return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	5e		 pop	 esi

; 150  : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
$LN1@Set@2:

; 141  : 	}
; 142  : 
; 143  : 	this->m_Skill = aSkill;

  00014	8a 45 08	 mov	 al, BYTE PTR _aSkill$[ebp]

; 144  : 	this->m_Level = aLevel;

  00017	8a 4d 0c	 mov	 cl, BYTE PTR _aLevel$[ebp]

; 145  : 	int damage = MagicDamageC.SkillGet(this->m_Skill);

  0001a	0f b6 d0	 movzx	 edx, al
  0001d	88 4e 04	 mov	 BYTE PTR [esi+4], cl
  00020	52		 push	 edx
  00021	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00026	88 46 05	 mov	 BYTE PTR [esi+5], al
  00029	e8 00 00 00 00	 call	 ?SkillGet@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGet
  0002e	8b c8		 mov	 ecx, eax

; 146  : 	this->m_DamageMin = damage;
; 147  : 	this->m_DamageMax = damage + damage/2;

  00030	99		 cdq
  00031	2b c2		 sub	 eax, edx
  00033	d1 f8		 sar	 eax, 1
  00035	03 c1		 add	 eax, ecx
  00037	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 148  : 
; 149  : 	return this->m_Skill;

  0003a	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  0003e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00041	5e		 pop	 esi

; 150  : }

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?Set@CMagicInf@@QAEHEE@Z ENDP				; CMagicInf::Set
_TEXT	ENDS
PUBLIC	?MagicByteConvert@@YAXPAEQAVCMagicInf@@H@Z	; MagicByteConvert
; Function compile flags: /Ogtp
;	COMDAT ?MagicByteConvert@@YAXPAEQAVCMagicInf@@H@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_Magici$ = 12						; size = 4
_maxmagic$ = 16						; size = 4
?MagicByteConvert@@YAXPAEQAVCMagicInf@@H@Z PROC		; MagicByteConvert, COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 155  : 
; 156  : 	for (int index = 0;index < maxmagic;index++)

  00004	8b 75 10	 mov	 esi, DWORD PTR _maxmagic$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	7e 28		 jle	 SHORT $LN1@MagicByteC

; 154  : 	int n=0;

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _Magici$[ebp]
  0000e	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00011	83 c1 04	 add	 ecx, 4
$LL3@MagicByteC:

; 157  : 	{
; 158  : 		buf[n] = Magici[index].m_Skill;

  00014	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  00018	88 10		 mov	 BYTE PTR [eax], dl

; 159  : 		n++;
; 160  : 
; 161  : 		buf[n] = Magici[index].m_Level << 3;

  0001a	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0001d	02 d2		 add	 dl, dl
  0001f	02 d2		 add	 dl, dl
  00021	02 d2		 add	 dl, dl
  00023	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 162  : 		n++;
; 163  : 
; 164  : 		buf[n] = 0;

  00026	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 165  : 		n++;

  0002a	83 c0 03	 add	 eax, 3
  0002d	83 c1 10	 add	 ecx, 16			; 00000010H
  00030	4e		 dec	 esi
  00031	75 e1		 jne	 SHORT $LL3@MagicByteC
$LN1@MagicByteC:
  00033	5e		 pop	 esi

; 166  : 	}
; 167  : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?MagicByteConvert@@YAXPAEQAVCMagicInf@@H@Z ENDP		; MagicByteConvert
_TEXT	ENDS
PUBLIC	??0CMagicInf@@QAE@XZ				; CMagicInf::CMagicInf
; Function compile flags: /Ogtp
;	COMDAT ??0CMagicInf@@QAE@XZ
_TEXT	SEGMENT
??0CMagicInf@@QAE@XZ PROC				; CMagicInf::CMagicInf, COMDAT
; _this$ = ecx

; 13   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMagicInf@@6B@

; 14   : 	this->Clear();

  00006	e8 00 00 00 00	 call	 ?Clear@CMagicInf@@QAEXXZ ; CMagicInf::Clear

; 15   : }

  0000b	8b c1		 mov	 eax, ecx
  0000d	c3		 ret	 0
??0CMagicInf@@QAE@XZ ENDP				; CMagicInf::CMagicInf
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCMagicInf@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMagicInf@@UAEPAXI@Z PROC				; CMagicInf::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMagicInf@@UAE@XZ	; CMagicInf::~CMagicInf
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCMagicInf@@UAEPAXI@Z ENDP				; CMagicInf::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	_atexit:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??__EDefMagicInf@@YAXXZ
text$yc	SEGMENT
??__EDefMagicInf@@YAXXZ PROC				; `dynamic initializer for 'DefMagicInf'', COMDAT

; 9    : CMagicInf DefMagicInf[MAX_SKILL-1];

  00000	68 00 00 00 00	 push	 OFFSET ??1CMagicInf@@UAE@XZ ; CMagicInf::~CMagicInf
  00005	68 00 00 00 00	 push	 OFFSET ??0CMagicInf@@QAE@XZ ; CMagicInf::CMagicInf
  0000a	68 ff 00 00 00	 push	 255			; 000000ffH
  0000f	6a 10		 push	 16			; 00000010H
  00011	68 00 00 00 00	 push	 OFFSET ?DefMagicInf@@3PAVCMagicInf@@A ; DefMagicInf
  00016	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  0001b	68 00 00 00 00	 push	 OFFSET ??__FDefMagicInf@@YAXXZ ; `dynamic atexit destructor for 'DefMagicInf''
  00020	e8 00 00 00 00	 call	 _atexit
  00025	59		 pop	 ecx
  00026	c3		 ret	 0
??__EDefMagicInf@@YAXXZ ENDP				; `dynamic initializer for 'DefMagicInf''
text$yc	ENDS
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??__FDefMagicInf@@YAXXZ
text$yd	SEGMENT
??__FDefMagicInf@@YAXXZ PROC				; `dynamic atexit destructor for 'DefMagicInf'', COMDAT
  00000	68 00 00 00 00	 push	 OFFSET ??1CMagicInf@@UAE@XZ ; CMagicInf::~CMagicInf
  00005	68 ff 00 00 00	 push	 255			; 000000ffH
  0000a	6a 10		 push	 16			; 00000010H
  0000c	68 00 00 00 00	 push	 OFFSET ?DefMagicInf@@3PAVCMagicInf@@A ; DefMagicInf
  00011	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00016	c3		 ret	 0
??__FDefMagicInf@@YAXXZ ENDP				; `dynamic atexit destructor for 'DefMagicInf''
text$yd	ENDS
PUBLIC	?DefMagicInf@@3PAVCMagicInf@@A			; DefMagicInf
_BSS	SEGMENT
?DefMagicInf@@3PAVCMagicInf@@A DB 0ff0H DUP (?)		; DefMagicInf
_BSS	ENDS
CRT$XCU	SEGMENT
_DefMagicInf$initializer$ DD FLAT:??__EDefMagicInf@@YAXXZ
CRT$XCU	ENDS
END
