; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\BloodCastle.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_g_btCastleEntranceMapXY DB 0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
_g_btCastleBridgeMapXY DB 0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
_g_btCastleDoorMapXY DB 0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
_g_iQuestWinExpendZEN DD 04e20H
	DD	02710H
	DD	0c350H
	DD	061a8H
	DD	0186a0H
	DD	0c350H
	DD	0249f0H
	DD	013880H
	DD	030d40H
	DD	0186a0H
	DD	03d090H
	DD	01d4c0H
	DD	03d090H
	DD	01d4c0H
_g_iBC_ChoasMixSuccessRate DD 050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
_g_iBC_ChoasMixMoney DD 0c350H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	0927c0H
	DD	0cf850H
_g_iBC_EventScore_Fail DD 0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
_g_iBC_EventScore DD 0258H
	DD	012cH
	DD	03e8H
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03e8H
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
_g_iBC_Party_EventPoint DD 05H
	DD	0aH
	DD	0fH
	DD	014H
	DD	01eH
_g_iBC_Add_Exp DD 04e20H
	DD	04e20H
	DD	01388H
	DD	0a0H
	DD	0c350H
	DD	0c350H
	DD	02710H
	DD	0b4H
	DD	013880H
	DD	013880H
	DD	03a98H
	DD	0c8H
	DD	015f90H
	DD	015f90H
	DD	04e20H
	DD	0dcH
	DD	0186a0H
	DD	0186a0H
	DD	061a8H
	DD	0f0H
	DD	01adb0H
	DD	01adb0H
	DD	07530H
	DD	0104H
	DD	01d4c0H
	DD	01d4c0H
	DD	088b8H
	DD	0118H
_g_iBC_MONSTER_CHANGE_STATE DD 0aH
	DD	014H
	DD	0fffffff2H
	DD	014H
	DD	028H
	DD	0ffffffe0H
CONST	ENDS
_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
_g_sttCHAOSCASTLE_LEVEL DD 0aH
	DD	031H
	DD	0aH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_DATA	ENDS
PUBLIC	?_ARGB@@YAKEEEE@Z				; _ARGB
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\tnotice.h
;	COMDAT ?_ARGB@@YAKEEEE@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
?_ARGB@@YAKEEEE@Z PROC					; _ARGB, COMDAT

; 8    : __inline DWORD _ARGB(BYTE a, BYTE r, BYTE g, BYTE b){ return a*16777216 + b*65536 + g*256 + r;}; // in tnotice.h : line 8

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  00007	0f b6 4d 14	 movzx	 ecx, BYTE PTR _b$[ebp]
  0000b	0f b6 55 10	 movzx	 edx, BYTE PTR _g$[ebp]
  0000f	c1 e0 08	 shl	 eax, 8
  00012	03 c1		 add	 eax, ecx
  00014	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _r$[ebp]
  00018	c1 e0 08	 shl	 eax, 8
  0001b	03 c2		 add	 eax, edx
  0001d	c1 e0 08	 shl	 eax, 8
  00020	03 c1		 add	 eax, ecx
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_ARGB@@YAKEEEE@Z ENDP					; _ARGB
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7CBloodCastle@@6B@				; CBloodCastle::`vftable'
PUBLIC	??1CBloodCastle@@UAE@XZ				; CBloodCastle::~CBloodCastle
PUBLIC	??_R4CBloodCastle@@6B@				; CBloodCastle::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBloodCastle@@@8			; CBloodCastle `RTTI Type Descriptor'
PUBLIC	??_R3CBloodCastle@@8				; CBloodCastle::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBloodCastle@@8				; CBloodCastle::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CBloodCastle@@8			; CBloodCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECBloodCastle@@UAEPAXI@Z:PROC		; CBloodCastle::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CBloodCastle@@8
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\bloodcastle.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CBloodCastle@@8 DD FLAT:??_R0?AVCBloodCastle@@@8 ; CBloodCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CBloodCastle@@8
rdata$r	ENDS
;	COMDAT ??_R2CBloodCastle@@8
rdata$r	SEGMENT
??_R2CBloodCastle@@8 DD FLAT:??_R1A@?0A@EA@CBloodCastle@@8 ; CBloodCastle::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CBloodCastle@@8
rdata$r	SEGMENT
??_R3CBloodCastle@@8 DD 00H				; CBloodCastle::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CBloodCastle@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBloodCastle@@@8
_DATA	SEGMENT
??_R0?AVCBloodCastle@@@8 DD FLAT:??_7type_info@@6B@	; CBloodCastle `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBloodCastle@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CBloodCastle@@6B@
rdata$r	SEGMENT
??_R4CBloodCastle@@6B@ DD 00H				; CBloodCastle::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBloodCastle@@@8
	DD	FLAT:??_R3CBloodCastle@@8
rdata$r	ENDS
;	COMDAT ??_7CBloodCastle@@6B@
CONST	SEGMENT
??_7CBloodCastle@@6B@ DD FLAT:??_R4CBloodCastle@@6B@	; CBloodCastle::`vftable'
	DD	FLAT:??_ECBloodCastle@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1CBloodCastle@@UAE@XZ
_TEXT	SEGMENT
??1CBloodCastle@@UAE@XZ PROC				; CBloodCastle::~CBloodCastle, COMDAT
; _this$ = ecx

; 126  : {

  00000	53		 push	 ebx
  00001	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DeleteCriticalSection@4
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CBloodCastle@@6B@
  0000f	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00012	bf 07 00 00 00	 mov	 edi, 7
$LL3@CBloodCast:

; 127  : 	for ( int i =0; i<MAX_BLOOD_CASTLE_LEVEL ; i++ )
; 128  : 	{
; 129  : 		DeleteCriticalSection(&this->m_BridgeData[i].m_critUserData);

  00017	56		 push	 esi
  00018	ff d3		 call	 ebx
  0001a	81 c6 00 02 00
	00		 add	 esi, 512		; 00000200H
  00020	4f		 dec	 edi
  00021	75 f4		 jne	 SHORT $LL3@CBloodCast

; 130  : 	}
; 131  : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	c3		 ret	 0
??1CBloodCastle@@UAE@XZ ENDP				; CBloodCastle::~CBloodCastle
_TEXT	ENDS
PUBLIC	??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@		; `string'
PUBLIC	??_C@_0O@PBCFFJJH@StoneDropRate?$AA@		; `string'
PUBLIC	??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@	; `string'
PUBLIC	??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@	; `string'
PUBLIC	??_C@_0P@EMJDPFDH@GameServerInfo?$AA@		; `string'
PUBLIC	??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@	; `string'
PUBLIC	??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@	; `string'
PUBLIC	?LoadItemDropRate@CBloodCastle@@QAEXXZ		; CBloodCastle::LoadItemDropRate
EXTRN	?g_bStoneItemDrop@@3HA:DWORD			; g_bStoneItemDrop
EXTRN	?g_iStoneDropRate@@3HA:DWORD			; g_iStoneDropRate
EXTRN	?g_iBloodBoneDropRate@@3HA:DWORD		; g_iBloodBoneDropRate
EXTRN	?g_iAngelKingsPaperDropRate@@3HA:DWORD		; g_iAngelKingsPaperDropRate
EXTRN	?g_bBloodCastle@@3HA:DWORD			; g_bBloodCastle
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
;	COMDAT ??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@
CONST	SEGMENT
??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@ DB 'StoneItemDrop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PBCFFJJH@StoneDropRate?$AA@
CONST	SEGMENT
??_C@_0O@PBCFFJJH@StoneDropRate?$AA@ DB 'StoneDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@
CONST	SEGMENT
??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@ DB 'BloodBoneDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@
CONST	SEGMENT
??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@ DB 'AngelKingsPaperDropRa'
	DB	'te', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
CONST	SEGMENT
??_C@_0P@EMJDPFDH@GameServerInfo?$AA@ DB 'GameServerInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@
CONST	SEGMENT
??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@ DB 'BloodCastleEvent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
CONST	SEGMENT
??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@ DB 'commonserver.cfg', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LoadItemDropRate@CBloodCastle@@QAEXXZ
_TEXT	SEGMENT
?LoadItemDropRate@CBloodCastle@@QAEXXZ PROC		; CBloodCastle::LoadItemDropRate, COMDAT
; _this$ = ecx

; 254  : {

  00000	56		 push	 esi

; 255  : 	g_bBloodCastle=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "BloodCastleEvent", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0000b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00010	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetPrivateProfileIntA@16
  00016	50		 push	 eax
  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00023	ff d6		 call	 esi

; 256  : 	g_iAngelKingsPaperDropRate=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "AngelKingsPaperDropRate", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0002f	a3 00 00 00 00	 mov	 DWORD PTR ?g_bBloodCastle@@3HA, eax ; g_bBloodCastle
  00034	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00039	50		 push	 eax
  0003a	6a 00		 push	 0
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00046	ff d6		 call	 esi

; 257  : 	g_iBloodBoneDropRate=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "BloodBoneDropRate", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00052	a3 00 00 00 00	 mov	 DWORD PTR ?g_iAngelKingsPaperDropRate@@3HA, eax ; g_iAngelKingsPaperDropRate
  00057	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0005c	50		 push	 eax
  0005d	6a 00		 push	 0
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00069	ff d6		 call	 esi

; 258  : 	g_iStoneDropRate=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "StoneDropRate", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00075	a3 00 00 00 00	 mov	 DWORD PTR ?g_iBloodBoneDropRate@@3HA, eax ; g_iBloodBoneDropRate
  0007a	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0007f	50		 push	 eax
  00080	6a 00		 push	 0
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PBCFFJJH@StoneDropRate?$AA@
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0008c	ff d6		 call	 esi

; 259  : 	g_bStoneItemDrop=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "StoneItemDrop", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00093	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00098	a3 00 00 00 00	 mov	 DWORD PTR ?g_iStoneDropRate@@3HA, eax ; g_iStoneDropRate
  0009d	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000a2	50		 push	 eax
  000a3	6a 00		 push	 0
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  000af	ff d6		 call	 esi
  000b1	a3 00 00 00 00	 mov	 DWORD PTR ?g_bStoneItemDrop@@3HA, eax ; g_bStoneItemDrop
  000b6	5e		 pop	 esi

; 260  : }

  000b7	c3		 ret	 0
?LoadItemDropRate@CBloodCastle@@QAEXXZ ENDP		; CBloodCastle::LoadItemDropRate
_TEXT	ENDS
PUBLIC	?ClearBridgeData@CBloodCastle@@IAEXH@Z		; CBloodCastle::ClearBridgeData
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:BYTE			; gObj
; Function compile flags: /Ogtp
;	COMDAT ?ClearBridgeData@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv3421 = 8						; size = 4
tv3416 = 8						; size = 4
tv3411 = 8						; size = 4
tv3406 = 8						; size = 4
tv3401 = 8						; size = 4
tv3396 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ClearBridgeData@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ClearBridgeData, COMDAT
; _this$ = ecx

; 342  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 343  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	3b c2		 cmp	 eax, edx
  0000d	0f 8c 5a 03 00
	00		 jl	 $LN12@ClearBridg
  00013	33 c9		 xor	 ecx, ecx
  00015	83 f8 06	 cmp	 eax, 6
  00018	0f 9e c1	 setle	 cl
  0001b	3b ca		 cmp	 ecx, edx
  0001d	0f 84 4a 03 00
	00		 je	 $LN12@ClearBridg

; 349  : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT = 0;
; 350  : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT = 0;
; 351  : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_SUCCESS_MSG_COUNT = 0;
; 352  : 	this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT = 0;
; 353  : 	this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT = 0;
; 354  : 	this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_SUCCESS_MSG_COUNT = 0;
; 355  : 	this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER = 0;
; 356  : 	this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN = -1;
; 357  : 	this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL = -1;
; 358  : 	this->m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX = -1;
; 359  : 	this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS = -1;
; 360  : 	this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT = -1;
; 361  : 	this->m_BridgeData[iBridgeIndex].m_bCASTLE_DOOR_LIVE = TRUE;
; 362  : 	this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED = false;
; 363  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER = false;
; 364  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY = false;
; 365  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END = false;
; 366  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_QUIT = false;
; 367  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;
; 368  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = false;
; 369  : 	this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START = false;
; 370  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE = false;
; 371  : 	this->m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE = false;
; 372  : 	this->m_BridgeData[iBridgeIndex].m_bBC_DOOR_TERMINATE_COMPLETE = false;
; 373  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index = -10;

  00023	b9 f6 ff ff ff	 mov	 ecx, -10		; fffffff6H
  00028	c1 e0 09	 shl	 eax, 9
  0002b	03 c6		 add	 eax, esi
  0002d	89 88 a4 01 00
	00		 mov	 DWORD PTR [eax+420], ecx

; 374  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party = -10;

  00033	89 88 a0 01 00
	00		 mov	 DWORD PTR [eax+416], ecx

; 375  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index = -10;

  00039	89 88 c4 01 00
	00		 mov	 DWORD PTR [eax+452], ecx

; 376  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party = -10;

  0003f	89 88 c0 01 00
	00		 mov	 DWORD PTR [eax+448], ecx

; 377  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Index = -10;

  00045	89 88 e4 01 00
	00		 mov	 DWORD PTR [eax+484], ecx

; 378  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Party = -10;

  0004b	89 88 e0 01 00
	00		 mov	 DWORD PTR [eax+480], ecx
  00051	89 90 3c 01 00
	00		 mov	 DWORD PTR [eax+316], edx
  00057	89 90 74 01 00
	00		 mov	 DWORD PTR [eax+372], edx
  0005d	89 90 78 01 00
	00		 mov	 DWORD PTR [eax+376], edx
  00063	89 90 7c 01 00
	00		 mov	 DWORD PTR [eax+380], edx
  00069	89 90 84 01 00
	00		 mov	 DWORD PTR [eax+388], edx
  0006f	89 90 88 01 00
	00		 mov	 DWORD PTR [eax+392], edx
  00075	89 90 8c 01 00
	00		 mov	 DWORD PTR [eax+396], edx
  0007b	88 90 98 01 00
	00		 mov	 BYTE PTR [eax+408], dl
  00081	c7 80 4c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+332], 1
  0008b	89 90 66 01 00
	00		 mov	 DWORD PTR [eax+358], edx
  00091	88 90 6a 01 00
	00		 mov	 BYTE PTR [eax+362], dl
  00097	66 89 90 63 01
	00 00		 mov	 WORD PTR [eax+355], dx
  0009e	88 90 65 01 00
	00		 mov	 BYTE PTR [eax+357], dl
  000a4	66 89 90 60 01
	00 00		 mov	 WORD PTR [eax+352], dx
  000ab	88 90 62 01 00
	00		 mov	 BYTE PTR [eax+354], dl

; 379  : 
; 380  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName , 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName));

  000b1	33 c9		 xor	 ecx, ecx
  000b3	89 4d 08	 mov	 DWORD PTR tv3421[ebp], ecx
  000b6	53		 push	 ebx
  000b7	83 cb ff	 or	 ebx, -1
  000ba	89 98 80 01 00
	00		 mov	 DWORD PTR [eax+384], ebx
  000c0	89 98 90 01 00
	00		 mov	 DWORD PTR [eax+400], ebx
  000c6	89 98 94 01 00
	00		 mov	 DWORD PTR [eax+404], ebx
  000cc	89 98 48 01 00
	00		 mov	 DWORD PTR [eax+328], ebx
  000d2	89 98 5c 01 00
	00		 mov	 DWORD PTR [eax+348], ebx
  000d8	89 88 b3 01 00
	00		 mov	 DWORD PTR [eax+435], ecx
  000de	89 88 b7 01 00
	00		 mov	 DWORD PTR [eax+439], ecx
  000e4	0f b7 c9	 movzx	 ecx, cx
  000e7	66 89 88 bb 01
	00 00		 mov	 WORD PTR [eax+443], cx
  000ee	0f b6 4d 08	 movzx	 ecx, BYTE PTR tv3421[ebp]
  000f2	88 88 bd 01 00
	00		 mov	 BYTE PTR [eax+445], cl

; 381  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName));

  000f8	33 c9		 xor	 ecx, ecx
  000fa	89 88 c8 01 00
	00		 mov	 DWORD PTR [eax+456], ecx
  00100	89 88 cc 01 00
	00		 mov	 DWORD PTR [eax+460], ecx
  00106	89 4d 08	 mov	 DWORD PTR tv3416[ebp], ecx
  00109	0f b7 c9	 movzx	 ecx, cx
  0010c	66 89 88 d0 01
	00 00		 mov	 WORD PTR [eax+464], cx
  00113	0f b6 4d 08	 movzx	 ecx, BYTE PTR tv3416[ebp]
  00117	88 88 d2 01 00
	00		 mov	 BYTE PTR [eax+466], cl

; 382  : 	memset(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_CharName, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_CharName));

  0011d	33 c9		 xor	 ecx, ecx
  0011f	89 88 e8 01 00
	00		 mov	 DWORD PTR [eax+488], ecx
  00125	89 88 ec 01 00
	00		 mov	 DWORD PTR [eax+492], ecx
  0012b	89 4d 08	 mov	 DWORD PTR tv3411[ebp], ecx
  0012e	0f b7 c9	 movzx	 ecx, cx
  00131	66 89 88 f0 01
	00 00		 mov	 WORD PTR [eax+496], cx
  00138	0f b6 4d 08	 movzx	 ecx, BYTE PTR tv3411[ebp]
  0013c	88 88 f2 01 00
	00		 mov	 BYTE PTR [eax+498], cl

; 383  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID));

  00142	33 c9		 xor	 ecx, ecx
  00144	89 88 a8 01 00
	00		 mov	 DWORD PTR [eax+424], ecx
  0014a	89 88 ac 01 00
	00		 mov	 DWORD PTR [eax+428], ecx
  00150	89 4d 08	 mov	 DWORD PTR tv3406[ebp], ecx
  00153	0f b7 c9	 movzx	 ecx, cx
  00156	66 89 88 b0 01
	00 00		 mov	 WORD PTR [eax+432], cx
  0015d	0f b6 4d 08	 movzx	 ecx, BYTE PTR tv3406[ebp]
  00161	88 88 b2 01 00
	00		 mov	 BYTE PTR [eax+434], cl

; 384  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID));

  00167	33 c9		 xor	 ecx, ecx
  00169	89 88 d3 01 00
	00		 mov	 DWORD PTR [eax+467], ecx
  0016f	89 88 d7 01 00
	00		 mov	 DWORD PTR [eax+471], ecx
  00175	89 4d 08	 mov	 DWORD PTR tv3401[ebp], ecx
  00178	0f b7 c9	 movzx	 ecx, cx
  0017b	66 89 88 db 01
	00 00		 mov	 WORD PTR [eax+475], cx
  00182	0f b6 4d 08	 movzx	 ecx, BYTE PTR tv3401[ebp]
  00186	88 88 dd 01 00
	00		 mov	 BYTE PTR [eax+477], cl

; 385  : 	memset(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_AccountID, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_AccountID));

  0018c	33 c9		 xor	 ecx, ecx
  0018e	89 88 f3 01 00
	00		 mov	 DWORD PTR [eax+499], ecx
  00194	89 88 f7 01 00
	00		 mov	 DWORD PTR [eax+503], ecx
  0019a	89 4d 08	 mov	 DWORD PTR tv3396[ebp], ecx
  0019d	0f b7 c9	 movzx	 ecx, cx
  001a0	66 89 88 fb 01
	00 00		 mov	 WORD PTR [eax+507], cx
  001a7	0f b6 4d 08	 movzx	 ecx, BYTE PTR tv3396[ebp]
  001ab	88 88 fd 01 00
	00		 mov	 BYTE PTR [eax+509], cl
  001b1	57		 push	 edi
  001b2	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]

; 344  : 	{
; 345  : 		return;
; 346  : 	}
; 347  : 
; 348  : 	this->m_BridgeData[iBridgeIndex].m_iTOTAL_EXP = 0;

  001b5	8d 7a 02	 lea	 edi, DWORD PTR [edx+2]
$LL4@ClearBridg:

; 386  : 	
; 387  : 
; 388  : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)
; 389  : 	{
; 390  : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  001b8	8b 31		 mov	 esi, DWORD PTR [ecx]
  001ba	3b f3		 cmp	 esi, ebx
  001bc	74 36		 je	 SHORT $LN1@ClearBridg

; 391  : 		{
; 392  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  001be	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  001c4	89 96 04 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3332], edx

; 393  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  001ca	8b 31		 mov	 esi, DWORD PTR [ecx]
  001cc	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  001d2	88 9e 02 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3330], bl

; 394  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  001d8	8b 31		 mov	 esi, DWORD PTR [ecx]
  001da	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  001e0	88 9e 03 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3331], bl

; 395  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  001e6	8b 31		 mov	 esi, DWORD PTR [ecx]
  001e8	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  001ee	88 96 08 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3336], dl
$LN1@ClearBridg:

; 396  : 		}
; 397  : 
; 398  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  001f4	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 399  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  001f7	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 400  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  001fa	89 19		 mov	 DWORD PTR [ecx], ebx

; 401  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  001fc	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 402  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  001ff	66 89 51 10	 mov	 WORD PTR [ecx+16], dx

; 403  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 404  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  00203	89 98 00 02 00
	00		 mov	 DWORD PTR [eax+512], ebx
  00209	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]
  0020c	3b f3		 cmp	 esi, ebx
  0020e	74 39		 je	 SHORT $LN13@ClearBridg

; 391  : 		{
; 392  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  00210	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00216	89 96 04 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3332], edx

; 393  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  0021c	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]
  0021f	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00225	88 9e 02 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3330], bl

; 394  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  0022b	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]
  0022e	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00234	88 9e 03 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3331], bl

; 395  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  0023a	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]
  0023d	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00243	88 96 08 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3336], dl
$LN13@ClearBridg:

; 396  : 		}
; 397  : 
; 398  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  00249	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 399  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  0024c	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 400  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  0024f	89 59 14	 mov	 DWORD PTR [ecx+20], ebx

; 401  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  00252	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 402  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  00255	66 89 51 24	 mov	 WORD PTR [ecx+36], dx

; 403  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 404  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  00259	89 98 00 02 00
	00		 mov	 DWORD PTR [eax+512], ebx
  0025f	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  00262	3b f3		 cmp	 esi, ebx
  00264	74 39		 je	 SHORT $LN14@ClearBridg

; 391  : 		{
; 392  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  00266	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0026c	89 96 04 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3332], edx

; 393  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  00272	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  00275	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0027b	88 9e 02 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3330], bl

; 394  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  00281	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  00284	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0028a	88 9e 03 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3331], bl

; 395  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  00290	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  00293	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00299	88 96 08 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3336], dl
$LN14@ClearBridg:

; 396  : 		}
; 397  : 
; 398  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  0029f	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 399  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  002a2	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 400  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  002a5	89 59 28	 mov	 DWORD PTR [ecx+40], ebx

; 401  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  002a8	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 402  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  002ab	66 89 51 38	 mov	 WORD PTR [ecx+56], dx

; 403  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 404  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  002af	89 98 00 02 00
	00		 mov	 DWORD PTR [eax+512], ebx
  002b5	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  002b8	3b f3		 cmp	 esi, ebx
  002ba	74 39		 je	 SHORT $LN15@ClearBridg

; 391  : 		{
; 392  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  002bc	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  002c2	89 96 04 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3332], edx

; 393  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  002c8	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  002cb	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  002d1	88 9e 02 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3330], bl

; 394  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  002d7	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  002da	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  002e0	88 9e 03 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3331], bl

; 395  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  002e6	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  002e9	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  002ef	88 96 08 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3336], dl
$LN15@ClearBridg:

; 396  : 		}
; 397  : 
; 398  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  002f5	89 51 40	 mov	 DWORD PTR [ecx+64], edx

; 399  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  002f8	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 400  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  002fb	89 59 3c	 mov	 DWORD PTR [ecx+60], ebx

; 401  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  002fe	89 51 48	 mov	 DWORD PTR [ecx+72], edx

; 402  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  00301	66 89 51 4c	 mov	 WORD PTR [ecx+76], dx

; 403  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 404  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  00305	89 98 00 02 00
	00		 mov	 DWORD PTR [eax+512], ebx
  0030b	8b 71 50	 mov	 esi, DWORD PTR [ecx+80]
  0030e	3b f3		 cmp	 esi, ebx
  00310	74 39		 je	 SHORT $LN16@ClearBridg

; 391  : 		{
; 392  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  00312	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00318	89 96 04 0d 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3332], edx

; 393  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  0031e	8b 71 50	 mov	 esi, DWORD PTR [ecx+80]
  00321	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00327	88 9e 02 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3330], bl

; 394  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  0032d	8b 71 50	 mov	 esi, DWORD PTR [ecx+80]
  00330	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00336	88 9e 03 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3331], bl

; 395  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  0033c	8b 71 50	 mov	 esi, DWORD PTR [ecx+80]
  0033f	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00345	88 96 08 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3336], dl
$LN16@ClearBridg:

; 396  : 		}
; 397  : 
; 398  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  0034b	89 51 54	 mov	 DWORD PTR [ecx+84], edx

; 399  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  0034e	89 51 58	 mov	 DWORD PTR [ecx+88], edx

; 400  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  00351	89 59 50	 mov	 DWORD PTR [ecx+80], ebx

; 401  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  00354	89 51 5c	 mov	 DWORD PTR [ecx+92], edx

; 402  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  00357	66 89 51 60	 mov	 WORD PTR [ecx+96], dx

; 403  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 404  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  0035b	83 c1 64	 add	 ecx, 100		; 00000064H
  0035e	4f		 dec	 edi
  0035f	89 98 00 02 00
	00		 mov	 DWORD PTR [eax+512], ebx
  00365	0f 85 4d fe ff
	ff		 jne	 $LL4@ClearBridg
  0036b	5f		 pop	 edi
  0036c	5b		 pop	 ebx
$LN12@ClearBridg:
  0036d	5e		 pop	 esi

; 405  : 	}
; 406  : }

  0036e	5d		 pop	 ebp
  0036f	c2 04 00	 ret	 4
?ClearBridgeData@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ClearBridgeData
_TEXT	ENDS
PUBLIC	?ProcState_None@CBloodCastle@@IAEXH@Z		; CBloodCastle::ProcState_None
; Function compile flags: /Ogtp
;	COMDAT ?ProcState_None@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?ProcState_None@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_None, COMDAT
; _this$ = ecx

; 497  : 	return;
; 498  : }

  00000	c2 04 00	 ret	 4
?ProcState_None@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_None
_TEXT	ENDS
PUBLIC	?GetCurrentState@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetCurrentState
; Function compile flags: /Ogtp
;	COMDAT ?GetCurrentState@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetCurrentState@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetCurrentState, COMDAT
; _this$ = ecx

; 898  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@GetCurrent
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 07		 jne	 SHORT $LN1@GetCurrent
$LN6@GetCurrent:

; 900  : 	{
; 901  : 		return -1;

  00016	83 c8 ff	 or	 eax, -1

; 905  : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN1@GetCurrent:

; 902  : 	}
; 903  : 
; 904  : 	return this->m_BridgeData[iBridgeIndex].m_iBC_STATE;

  0001d	c1 e0 09	 shl	 eax, 9
  00020	8b 84 08 50 01
	00 00		 mov	 eax, DWORD PTR [eax+ecx+336]

; 905  : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?GetCurrentState@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetCurrentState
_TEXT	ENDS
PUBLIC	?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetCurrentRemainSec
; Function compile flags: /Ogtp
;	COMDAT ?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetCurrentRemainSec, COMDAT
; _this$ = ecx

; 913  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 914  : 	return this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	c1 e0 09	 shl	 eax, 9
  00009	8b 8c 08 54 01
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+340]
  00010	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00015	f7 e9		 imul	 ecx
  00017	c1 fa 06	 sar	 edx, 6
  0001a	8b c2		 mov	 eax, edx
  0001c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001f	03 c2		 add	 eax, edx

; 915  : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetCurrentRemainSec
_TEXT	ENDS
PUBLIC	?CheckEnterLevel@CBloodCastle@@QAEHHH@Z		; CBloodCastle::CheckEnterLevel
; Function compile flags: /Ogtp
;	COMDAT ?CheckEnterLevel@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iLevel$ = 12						; size = 4
?CheckEnterLevel@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CheckEnterLevel, COMDAT
; _this$ = ecx

; 923  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 924  : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 88 b5 00 00
	00		 js	 $LN10@CheckEnter
  0000e	33 c9		 xor	 ecx, ecx
  00010	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00015	0f 9e c1	 setle	 cl
  00018	85 c9		 test	 ecx, ecx

; 925  : 	{
; 926  : 		return 2;

  0001a	0f 84 a3 00 00
	00		 je	 $LN10@CheckEnter

; 927  : 	}
; 928  : 
; 929  : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00020	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00026	66 83 b8 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 1
  0002e	0f 85 8f 00 00
	00		 jne	 $LN10@CheckEnter
  00034	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  0003b	0f 86 82 00 00
	00		 jbe	 $LN10@CheckEnter

; 932  : 	}
; 933  : 
; 934  : 	if ( gObj[iIndex].Class == CLASS_DARKLORD || gObj[iIndex].Class == CLASS_MAGUMSA )

  00041	0f b7 88 98 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+152]
  00048	83 f9 04	 cmp	 ecx, 4
  0004b	74 39		 je	 SHORT $LN8@CheckEnter
  0004d	83 f9 03	 cmp	 ecx, 3
  00050	74 34		 je	 SHORT $LN8@CheckEnter

; 949  : 		}
; 950  : 	}
; 951  : 	else
; 952  : 	{
; 953  : 		if ( gObj[iIndex].Level >= g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND && gObj[iIndex].Level <= g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  00052	0f bf 88 9c 00
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+156]
  00059	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  0005c	c1 e0 04	 shl	 eax, 4
  0005f	8b 90 f0 ff ff
	ff		 mov	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax-16]
  00065	3b ca		 cmp	 ecx, edx
  00067	7c 46		 jl	 SHORT $LN21@CheckEnter
  00069	3b 88 f4 ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax-12]

; 954  : 		{
; 955  : 			return 0;

  0006f	7e 34		 jle	 SHORT $LN22@CheckEnter

; 956  : 		}
; 957  : 
; 958  : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND )

  00071	3b ca		 cmp	 ecx, edx

; 959  : 		{
; 960  : 			return -1;

  00073	7c 3a		 jl	 SHORT $LN21@CheckEnter

; 961  : 		}
; 962  : 
; 963  : 		if ( gObj[iIndex].Level > g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  00075	3b 88 f4 ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax-12]
  0007b	7e 46		 jle	 SHORT $LN10@CheckEnter

; 964  : 		{
; 965  : 			return 1;

  0007d	b8 01 00 00 00	 mov	 eax, 1

; 966  : 		}
; 967  : 	}
; 968  : 
; 969  : 	return 2;
; 970  : }

  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
$LN8@CheckEnter:

; 935  : 	{
; 936  : 		if ( gObj[iIndex].Level >= g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA && gObj[iIndex].Level <= g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  00086	0f bf 88 9c 00
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+156]
  0008d	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  00090	c1 e0 04	 shl	 eax, 4
  00093	8b 90 f8 ff ff
	ff		 mov	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax-8]
  00099	3b ca		 cmp	 ecx, edx
  0009b	7c 12		 jl	 SHORT $LN21@CheckEnter
  0009d	3b 88 fc ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax-4]
  000a3	7f 06		 jg	 SHORT $LN7@CheckEnter
$LN22@CheckEnter:

; 937  : 		{
; 938  : 			return 0;

  000a5	33 c0		 xor	 eax, eax

; 966  : 		}
; 967  : 	}
; 968  : 
; 969  : 	return 2;
; 970  : }

  000a7	5d		 pop	 ebp
  000a8	c2 08 00	 ret	 8
$LN7@CheckEnter:

; 939  : 		}
; 940  : 
; 941  : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA )

  000ab	3b ca		 cmp	 ecx, edx
  000ad	7d 07		 jge	 SHORT $LN6@CheckEnter
$LN21@CheckEnter:

; 942  : 		{
; 943  : 			return -1;

  000af	83 c8 ff	 or	 eax, -1

; 966  : 		}
; 967  : 	}
; 968  : 
; 969  : 	return 2;
; 970  : }

  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
$LN6@CheckEnter:

; 944  : 		}
; 945  : 
; 946  : 		if ( gObj[iIndex].Level > g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  000b6	3b 88 fc ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax-4]

; 947  : 		{
; 948  : 			return 1;

  000bc	b8 01 00 00 00	 mov	 eax, 1
  000c1	7f 05		 jg	 SHORT $LN13@CheckEnter
$LN10@CheckEnter:

; 930  : 	{
; 931  : 		return 2;

  000c3	b8 02 00 00 00	 mov	 eax, 2
$LN13@CheckEnter:

; 966  : 		}
; 967  : 	}
; 968  : 
; 969  : 	return 2;
; 970  : }

  000c8	5d		 pop	 ebp
  000c9	c2 08 00	 ret	 8
?CheckEnterLevel@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CheckEnterLevel
_TEXT	ENDS
PUBLIC	?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckEnterFreeTicket
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckEnterFreeTicket, COMDAT
; _this$ = ecx

; 976  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 977  : 	if ( !OBJMAX_RANGE(iIndex) )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	78 0f		 js	 SHORT $LN16@CheckEnter@2
  0000b	33 c0		 xor	 eax, eax
  0000d	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 07		 jne	 SHORT $LN8@CheckEnter@2
$LN16@CheckEnter@2:

; 978  : 		return false;

  0001a	32 c0		 xor	 al, al
  0001c	5f		 pop	 edi

; 995  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN8@CheckEnter@2:

; 979  : 
; 980  : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00021	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00027	66 83 bf 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+96], 1
  0002f	75 e9		 jne	 SHORT $LN16@CheckEnter@2
  00031	80 bf 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+4], 2
  00038	76 e0		 jbe	 SHORT $LN16@CheckEnter@2

; 981  : 		return false;
; 982  : 
; 983  : 	for (int x=0;x<MAIN_INVENTORY_SIZE;x++)

  0003a	56		 push	 esi
  0003b	33 f6		 xor	 esi, esi
  0003d	8d 49 00	 npad	 3
$LL5@CheckEnter@2:

; 984  : 	{
; 985  : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00040	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3212]
  00046	03 ce		 add	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004d	83 f8 01	 cmp	 eax, 1
  00050	75 12		 jne	 SHORT $LN4@CheckEnter@2

; 986  : 		{
; 987  : 			if ( gObj[iIndex].pInventory [x].m_Type == ITEMGET(13,47) )

  00052	8b 87 8c 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3212]
  00058	b9 2f 1a 00 00	 mov	 ecx, 6703		; 00001a2fH
  0005d	66 39 4c 30 06	 cmp	 WORD PTR [eax+esi+6], cx
  00062	74 16		 je	 SHORT $LN14@CheckEnter@2
$LN4@CheckEnter@2:

; 981  : 		return false;
; 982  : 
; 983  : 	for (int x=0;x<MAIN_INVENTORY_SIZE;x++)

  00064	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  0006a	81 fe e0 31 00
	00		 cmp	 esi, 12768		; 000031e0H
  00070	7c ce		 jl	 SHORT $LL5@CheckEnter@2

; 990  : 			}
; 991  : 		}
; 992  : 	}
; 993  : 
; 994  : 	return false;

  00072	5e		 pop	 esi
  00073	32 c0		 xor	 al, al
  00075	5f		 pop	 edi

; 995  : }

  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
$LN14@CheckEnter@2:
  0007a	5e		 pop	 esi

; 988  : 			{
; 989  : 				return true;

  0007b	b0 01		 mov	 al, 1
  0007d	5f		 pop	 edi

; 995  : }

  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckEnterFreeTicket
_TEXT	ENDS
EXTRN	__localtime64:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _localtime
_TEXT	SEGMENT
_localtime PROC						; COMDAT
; __Time$ = eax

; 114  : #pragma warning( push )
; 115  : #pragma warning( disable : 4996 )
; 116  :     return _localtime64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __localtime64
  00006	83 c4 04	 add	 esp, 4

; 117  : #pragma warning( pop )
; 118  : }

  00009	c3		 ret	 0
_localtime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FK@JBBPPAMC@?$FLBlood?5Castle?$FNMix?5Chaos?5Mix?5Fail@ ; `string'
PUBLIC	??_C@_0CL@BPNNCCDO@?$FLMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5?$CFd?5Mon@ ; `string'
PUBLIC	??_C@_0CO@FCLAGPLL@?$FLMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Success?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	??_C@_03BHCFKDFC@Mix?$AA@			; `string'
PUBLIC	??_C@_0ED@OIEHENPN@?$FLBlood?5Castle?$FN?5Mix?5Chaos?5Mix?5Sta@ ; `string'
PUBLIC	_iLEVEL$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::BloodCastleChaosMix
EXTRN	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GCUserChaosBoxSend
EXTRN	?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; ChaosBoxInit
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	_rand:PROC
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z:PROC	; CCastleSiegeSync::AddTributeMoney
EXTRN	?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateChaos
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z:PROC	; LogChaosItem
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__alldiv:PROC
;	COMDAT ??_C@_0FK@JBBPPAMC@?$FLBlood?5Castle?$FNMix?5Chaos?5Mix?5Fail@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\bloodcastle.cpp
CONST	SEGMENT
??_C@_0FK@JBBPPAMC@?$FLBlood?5Castle?$FNMix?5Chaos?5Mix?5Fail@ DB '[Blood'
	DB	' Castle]Mix Chaos Mix Failed - MixRate Out of Bound (Account:'
	DB	'%s, Name:%s, Level:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BPNNCCDO@?$FLMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5?$CFd?5Mon@
CONST	SEGMENT
??_C@_0CL@BPNNCCDO@?$FLMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5?$CFd?5Mon@ DB '['
	DB	'Mix] [%s][%s] CBMix Fail %d Money : %d-%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FCLAGPLL@?$FLMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Success?5?$CFd?5@
CONST	SEGMENT
??_C@_0CO@FCLAGPLL@?$FLMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Success?5?$CFd?5@ DB '['
	DB	'Mix] [%s][%s] CBMix Success %d Money : %d-%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
CONST	SEGMENT
??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - Not Enough Money (Account:%s, Name:%s'
	DB	', Level:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
CONST	SEGMENT
??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - MixMoney < 0 (Account:%s, Name:%s, Le'
	DB	'vel:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03BHCFKDFC@Mix?$AA@
CONST	SEGMENT
??_C@_03BHCFKDFC@Mix?$AA@ DB 'Mix', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@OIEHENPN@?$FLBlood?5Castle?$FN?5Mix?5Chaos?5Mix?5Sta@
CONST	SEGMENT
??_C@_0ED@OIEHENPN@?$FLBlood?5Castle?$FN?5Mix?5Chaos?5Mix?5Sta@ DB '[Bloo'
	DB	'd Castle] Mix Chaos Mix Start (Account:%s, Name:%s, Level:%d)'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iLEVEL$GSCopy$ = -32					; size = 4
tv331 = -28						; size = 4
tv330 = -24						; size = 4
_iMIX_NEED_MONEY$ = -20					; size = 4
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iLEVEL$ = 12						; size = 4
?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::BloodCastleChaosMix, COMDAT
; _this$ = ecx

; 1002 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _iLEVEL$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 1089 : 	}
; 1090 : 	else	// Failure
; 1091 : 	{
; 1092 : 		ChaosBoxInit(&gObj[iIndex]);

  00018	89 5d e0	 mov	 DWORD PTR _iLEVEL$GSCopy$[ebp], ebx
  0001b	85 ff		 test	 edi, edi
  0001d	78 0f		 js	 SHORT $LN18@BloodCastl

; 1003 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  0001f	33 c0		 xor	 eax, eax
  00021	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	75 14		 jne	 SHORT $LN11@BloodCastl
$LN18@BloodCastl:
  0002e	5f		 pop	 edi

; 1004 : 	{
; 1005 : 		return false;

  0002f	32 c0		 xor	 al, al
  00031	5b		 pop	 ebx

; 1104 : }

  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	33 cd		 xor	 ecx, ebp
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN11@BloodCastl:

; 1006 : 	}
; 1007 : 
; 1008 : 	if ( BC_MAP_RANGE( (iLEVEL + 10) )  == FALSE )

  00042	8d 43 0a	 lea	 eax, DWORD PTR [ebx+10]
  00045	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00048	7c e4		 jl	 SHORT $LN18@BloodCastl
  0004a	33 c9		 xor	 ecx, ecx
  0004c	83 f8 11	 cmp	 eax, 17			; 00000011H
  0004f	0f 9e c1	 setle	 cl
  00052	8b c1		 mov	 eax, ecx
  00054	85 c0		 test	 eax, eax

; 1009 : 	{
; 1010 : 		return false;

  00056	74 d6		 je	 SHORT $LN18@BloodCastl

; 1011 : 	}
; 1012 : 
; 1013 : 	BOOL bMIX_RESULT = FALSE;
; 1014 : 
; 1015 : 	PMSG_CHAOSMIXRESULT pMsg;
; 1016 : 
; 1017 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00058	56		 push	 esi
  00059	6a 0b		 push	 11			; 0000000bH
  0005b	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0005e	68 86 00 00 00	 push	 134			; 00000086H
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1018 : 	pMsg.Result = CB_ERROR;
; 1019 : 	gObj[iIndex].ChaosLock = TRUE;

  00069	8b f7		 mov	 esi, edi
  0006b	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H

; 1020 : 
; 1021 : 	LogAdd(LOG_BLACK, "[Blood Castle] Mix Chaos Mix Start (Account:%s, Name:%s, Level:%d)",
; 1022 : 		gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);

  00071	53		 push	 ebx
  00072	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00078	50		 push	 eax
  00079	8d 8e 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  0007f	51		 push	 ecx
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@OIEHENPN@?$FLBlood?5Castle?$FN?5Mix?5Chaos?5Mix?5Sta@
  00085	6a 00		 push	 0
  00087	c6 45 f3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  0008b	c7 86 ec 0c 00
	00 01 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3308], 1
  00095	89 45 e8	 mov	 DWORD PTR tv330[ebp], eax
  00098	89 4d e4	 mov	 DWORD PTR tv331[ebp], ecx
  0009b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 1023 : 	LogChaosItem(&gObj[iIndex], "Mix");

  000a0	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_03BHCFKDFC@Mix?$AA@
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?LogChaosItem@@YAXPAUOBJECTSTRUCT@@PAD@Z ; LogChaosItem

; 1024 : 
; 1025 : 	int iMIX_SUCCESS_RATE = g_iBC_ChoasMixSuccessRate[iLEVEL - 1];

  000b1	8b 1c 9d fc ff
	ff ff		 mov	 ebx, DWORD PTR _g_iBC_ChoasMixSuccessRate[ebx*4-4]
  000b8	83 c4 28	 add	 esp, 40			; 00000028H

; 1026 : 
; 1027 : 	if ( iMIX_SUCCESS_RATE < 0 || iMIX_SUCCESS_RATE > 100 )

  000bb	83 fb 64	 cmp	 ebx, 100		; 00000064H
  000be	0f 87 ad 01 00
	00		 ja	 $LN8@BloodCastl

; 1032 : 
; 1033 : 		return false;
; 1034 : 	}
; 1035 : 
; 1036 : 	if ( iMIX_SUCCESS_RATE > 80 )

  000c4	83 fb 50	 cmp	 ebx, 80			; 00000050H
  000c7	7e 05		 jle	 SHORT $LN7@BloodCastl

; 1037 : 	{
; 1038 : 		iMIX_SUCCESS_RATE = 80;

  000c9	bb 50 00 00 00	 mov	 ebx, 80			; 00000050H
$LN7@BloodCastl:

; 1039 : 	}
; 1040 : 
; 1041 : 	if ( gObj[iIndex].ChaosSuccessRate > 10 )

  000ce	83 be e8 0c 00
	00 0a		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3304], 10 ; 0000000aH
  000d5	7e 20		 jle	 SHORT $LN6@BloodCastl

; 1042 : 	{
; 1043 : 		pMsg.Result = 0xF0;
; 1044 : 		gObj[iIndex].ChaosLock = FALSE;
; 1045 : 
; 1046 : 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000d7	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000db	50		 push	 eax
  000dc	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000df	51		 push	 ecx
  000e0	57		 push	 edi
  000e1	c6 45 f3 f0	 mov	 BYTE PTR _pMsg$[ebp+3], 240 ; 000000f0H
  000e5	c7 86 ec 0c 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3308], 0
  000ef	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@BloodCastl:

; 1047 : 	}
; 1048 : 
; 1049 : 	iMIX_SUCCESS_RATE += gObj[iIndex].ChaosSuccessRate;
; 1050 : 	int iMIX_NEED_MONEY = g_iBC_ChoasMixMoney[iLEVEL - 1];

  000f7	8b 55 e0	 mov	 edx, DWORD PTR _iLEVEL$GSCopy$[ebp]
  000fa	8b 04 95 fc ff
	ff ff		 mov	 eax, DWORD PTR _g_iBC_ChoasMixMoney[edx*4-4]
  00101	03 9e e8 0c 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3304]

; 1051 : 	int iChaosTaxMoney = (int)((__int64)(iMIX_NEED_MONEY) * (__int64)(g_CastleSiegeSync.GetTaxRateChaos(iIndex)) / (__int64)100);

  00107	57		 push	 edi
  00108	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0010d	89 45 ec	 mov	 DWORD PTR _iMIX_NEED_MONEY$[ebp], eax
  00110	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00115	f7 6d ec	 imul	 DWORD PTR _iMIX_NEED_MONEY$[ebp]
  00118	6a 00		 push	 0
  0011a	6a 64		 push	 100			; 00000064H
  0011c	52		 push	 edx
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 __alldiv

; 1052 : 
; 1053 : 	if ( iChaosTaxMoney < 0 )

  00123	85 c0		 test	 eax, eax
  00125	79 02		 jns	 SHORT $LN5@BloodCastl

; 1054 : 	{
; 1055 : 		iChaosTaxMoney = 0;

  00127	33 c0		 xor	 eax, eax
$LN5@BloodCastl:

; 1056 : 	}
; 1057 : 
; 1058 : 	iMIX_NEED_MONEY += iChaosTaxMoney;

  00129	01 45 ec	 add	 DWORD PTR _iMIX_NEED_MONEY$[ebp], eax

; 1059 : 
; 1060 : 	if ( iMIX_NEED_MONEY <  0 )

  0012c	79 25		 jns	 SHORT $LN4@BloodCastl

; 1061 : 	{
; 1062 : 		DataSend(iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0012e	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00132	51		 push	 ecx
  00133	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00136	52		 push	 edx
  00137	57		 push	 edi
  00138	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1063 : 		LogAdd(LOG_BLACK, "[Blood Castle]  Mix Chaos Mix Failed - MixMoney < 0 (Account:%s, Name:%s, Level:%d)",
; 1064 : 			gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);

  0013d	8b 45 e0	 mov	 eax, DWORD PTR _iLEVEL$GSCopy$[ebp]
  00140	8b 4d e8	 mov	 ecx, DWORD PTR tv330[ebp]
  00143	8b 55 e4	 mov	 edx, DWORD PTR tv331[ebp]
  00146	50		 push	 eax
  00147	51		 push	 ecx
  00148	52		 push	 edx
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@

; 1065 : 
; 1066 : 		return false;

  0014e	e9 3e 01 00 00	 jmp	 $LN21@BloodCastl
$LN4@BloodCastl:

; 1067 : 	}
; 1068 : 
; 1069 : 	if ( (gObj[iIndex].Money - iMIX_NEED_MONEY) < 0 )	// Not enoght zen

  00153	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176]
  00159	2b 4d ec	 sub	 ecx, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  0015c	79 29		 jns	 SHORT $LN3@BloodCastl

; 1070 : 	{
; 1071 : 		pMsg.Result = CB_BC_NOT_ENOUGH_ZEN;
; 1072 : 		DataSend(iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0015e	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00162	50		 push	 eax
  00163	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00166	51		 push	 ecx
  00167	57		 push	 edi
  00168	c6 45 f3 0b	 mov	 BYTE PTR _pMsg$[ebp+3], 11 ; 0000000bH
  0016c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1073 : 		LogAdd(LOG_BLACK, "[Blood Castle]  Mix Chaos Mix Failed - Not Enough Money (Account:%s, Name:%s, Level:%d)",
; 1074 : 			gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);

  00171	8b 55 e0	 mov	 edx, DWORD PTR _iLEVEL$GSCopy$[ebp]
  00174	8b 45 e8	 mov	 eax, DWORD PTR tv330[ebp]
  00177	8b 4d e4	 mov	 ecx, DWORD PTR tv331[ebp]
  0017a	52		 push	 edx
  0017b	50		 push	 eax
  0017c	51		 push	 ecx
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@

; 1075 : 
; 1076 : 		return false;

  00182	e9 0a 01 00 00	 jmp	 $LN21@BloodCastl
$LN3@BloodCastl:

; 1077 : 	}
; 1078 : 
; 1079 : 	gObj[iIndex].Money -= iMIX_NEED_MONEY;

  00187	89 8e b0 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176], ecx

; 1080 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  0018d	50		 push	 eax
  0018e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00193	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 1081 : 	GCMoneySend(iIndex, gObj[iIndex].Money);

  00198	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176]
  0019e	52		 push	 edx
  0019f	57		 push	 edi
  001a0	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  001a5	83 c4 08	 add	 esp, 8

; 1082 : 
; 1083 : 	if ( (rand()%100) < iMIX_SUCCESS_RATE )	// Siccess

  001a8	e8 00 00 00 00	 call	 _rand
  001ad	99		 cdq
  001ae	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001b3	f7 f9		 idiv	 ecx
  001b5	3b d3		 cmp	 edx, ebx
  001b7	7d 6a		 jge	 SHORT $LN2@BloodCastl

; 1084 : 	{
; 1085 : 		int item_num = ITEMGET(13,18);	// Invisibility Cloak
; 1086 : 		ItemSerialCreateSend(iIndex, -1, 0, 0, item_num, iLEVEL, 255, 0, 0, 0, -1, 0, 0);

  001b9	8b 55 e0	 mov	 edx, DWORD PTR _iLEVEL$GSCopy$[ebp]
  001bc	6a 00		 push	 0
  001be	6a 00		 push	 0
  001c0	6a ff		 push	 -1
  001c2	6a 00		 push	 0
  001c4	6a 00		 push	 0
  001c6	6a 00		 push	 0
  001c8	68 ff 00 00 00	 push	 255			; 000000ffH
  001cd	52		 push	 edx
  001ce	68 12 1a 00 00	 push	 6674			; 00001a12H
  001d3	6a 00		 push	 0
  001d5	6a 00		 push	 0
  001d7	68 ff 00 00 00	 push	 255			; 000000ffH
  001dc	57		 push	 edi
  001dd	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 1087 : 		LogAdd(LOG_BLACK, "[Mix] [%s][%s] CBMix Success %d Money : %d-%d",
; 1088 : 			gObj[iIndex].AccountID, gObj[iIndex].Name, iMIX_SUCCESS_RATE, gObj[iIndex].Money, iMIX_NEED_MONEY);

  001e2	8b 45 ec	 mov	 eax, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  001e5	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176]
  001eb	8b 55 e8	 mov	 edx, DWORD PTR tv330[ebp]
  001ee	50		 push	 eax
  001ef	8b 45 e4	 mov	 eax, DWORD PTR tv331[ebp]
  001f2	51		 push	 ecx
  001f3	53		 push	 ebx
  001f4	52		 push	 edx
  001f5	50		 push	 eax
  001f6	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@FCLAGPLL@?$FLMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Success?5?$CFd?5@
  001fb	6a 00		 push	 0
  001fd	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00202	83 c4 50	 add	 esp, 80			; 00000050H

; 1099 : 	}
; 1100 : 
; 1101 : 	::gObjInventoryCommit(iIndex);

  00205	57		 push	 edi
  00206	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  0020b	83 c4 04	 add	 esp, 4
  0020e	5e		 pop	 esi
  0020f	5f		 pop	 edi

; 1102 : 
; 1103 : 	return true;

  00210	b0 01		 mov	 al, 1
  00212	5b		 pop	 ebx

; 1104 : }

  00213	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00216	33 cd		 xor	 ecx, ebp
  00218	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021d	8b e5		 mov	 esp, ebp
  0021f	5d		 pop	 ebp
  00220	c2 08 00	 ret	 8
$LN2@BloodCastl:

; 1089 : 	}
; 1090 : 	else	// Failure
; 1091 : 	{
; 1092 : 		ChaosBoxInit(&gObj[iIndex]);

  00223	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 ?ChaosBoxInit@@YAHPAUOBJECTSTRUCT@@@Z ; ChaosBoxInit

; 1093 : 		GCUserChaosBoxSend(&gObj[iIndex], 0);

  0022f	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00235	6a 00		 push	 0
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 1094 : 		DataSend(iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0023d	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00241	51		 push	 ecx
  00242	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00245	52		 push	 edx
  00246	57		 push	 edi
  00247	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1095 : 		LogAdd(LOG_BLACK, "[Mix] [%s][%s] CBMix Fail %d Money : %d-%d",
; 1096 : 			gObj[iIndex].AccountID, gObj[iIndex].Name, iMIX_SUCCESS_RATE, gObj[iIndex].Money, iMIX_NEED_MONEY);

  0024c	8b 45 ec	 mov	 eax, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  0024f	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176]
  00255	8b 55 e8	 mov	 edx, DWORD PTR tv330[ebp]
  00258	50		 push	 eax
  00259	8b 45 e4	 mov	 eax, DWORD PTR tv331[ebp]
  0025c	51		 push	 ecx
  0025d	53		 push	 ebx
  0025e	52		 push	 edx
  0025f	50		 push	 eax
  00260	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@BPNNCCDO@?$FLMix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fail?5?$CFd?5Mon@
  00265	6a 00		 push	 0
  00267	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0026c	83 c4 34	 add	 esp, 52			; 00000034H

; 1097 : 
; 1098 : 		return false;

  0026f	eb 2a		 jmp	 SHORT $LN22@BloodCastl
$LN8@BloodCastl:

; 1028 : 	{
; 1029 : 		DataSend(iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00271	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00275	51		 push	 ecx
  00276	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00279	52		 push	 edx
  0027a	57		 push	 edi
  0027b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1030 : 		LogAdd(LOG_BLACK, "[Blood Castle]Mix Chaos Mix Failed - MixRate Out of Bound (Account:%s, Name:%s, Level:%d)",
; 1031 : 			gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);

  00280	8b 45 e0	 mov	 eax, DWORD PTR _iLEVEL$GSCopy$[ebp]
  00283	8b 4d e8	 mov	 ecx, DWORD PTR tv330[ebp]
  00286	8b 55 e4	 mov	 edx, DWORD PTR tv331[ebp]
  00289	50		 push	 eax
  0028a	51		 push	 ecx
  0028b	52		 push	 edx
  0028c	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@JBBPPAMC@?$FLBlood?5Castle?$FNMix?5Chaos?5Mix?5Fail@
$LN21@BloodCastl:
  00291	6a 00		 push	 0
  00293	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00298	83 c4 20	 add	 esp, 32			; 00000020H
$LN22@BloodCastl:

; 1104 : }

  0029b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029e	5e		 pop	 esi
  0029f	5f		 pop	 edi
  002a0	33 cd		 xor	 ecx, ebp
  002a2	32 c0		 xor	 al, al
  002a4	5b		 pop	 ebx
  002a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002aa	8b e5		 mov	 esp, ebp
  002ac	5d		 pop	 ebp
  002ad	c2 08 00	 ret	 8
?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::BloodCastleChaosMix
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	?CheckChoasMixItem@CBloodCastle@@QAEHH@Z	; CBloodCastle::CheckChoasMixItem
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\bloodcastle.cpp
;	COMDAT ?CheckChoasMixItem@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_bIsChaosGemExist$ = -24				; size = 4
_iBloodBoneLevel$ = -20					; size = 4
_iAngelKingPaperLevel$ = -16				; size = 4
_bIsAngelKingPaperExist$ = -12				; size = 4
_bIsOtherItemExist$ = -8				; size = 4
_bIsBloodBoneExist$ = -4				; size = 4
_iCharmOfLuckCount$ = 8					; size = 4
_iIndex$ = 8						; size = 4
?CheckChoasMixItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckChoasMixItem, COMDAT
; _this$ = ecx

; 1162 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 1163 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00007	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000a	57		 push	 edi
  0000b	33 ff		 xor	 edi, edi
  0000d	3b f7		 cmp	 esi, edi
  0000f	7c 0f		 jl	 SHORT $LN41@CheckChoas
  00011	33 c0		 xor	 eax, eax
  00013	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00019	0f 9e c0	 setle	 al
  0001c	3b c7		 cmp	 eax, edi
  0001e	75 0a		 jne	 SHORT $LN29@CheckChoas
$LN41@CheckChoas:
  00020	5f		 pop	 edi

; 1164 : 	{
; 1165 : 		return false;

  00021	33 c0		 xor	 eax, eax
  00023	5e		 pop	 esi

; 1276 : 	}
; 1277 : 
; 1278 : 	return 0;
; 1279 : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN29@CheckChoas:
  0002a	53		 push	 ebx

; 1166 : 	}
; 1167 : 
; 1168 : 	int iCHAOS_MIX_LEVEL = 0;
; 1169 : 	BOOL bIsChaosGemExist = FALSE;
; 1170 : 	BOOL bIsAngelKingPaperExist = FALSE;
; 1171 : 	BOOL bIsBloodBoneExist = FALSE;
; 1172 : 	BOOL bIsOtherItemExist = FALSE;
; 1173 : 	int iEventItemCount = 0;

  0002b	33 db		 xor	 ebx, ebx
  0002d	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00033	89 7d e8	 mov	 DWORD PTR _bIsChaosGemExist$[ebp], edi
  00036	89 7d f4	 mov	 DWORD PTR _bIsAngelKingPaperExist$[ebp], edi
  00039	89 7d fc	 mov	 DWORD PTR _bIsBloodBoneExist$[ebp], edi
  0003c	89 7d f8	 mov	 DWORD PTR _bIsOtherItemExist$[ebp], edi

; 1174 : 	int iAngelKingPaperLevel = 0;

  0003f	89 7d f0	 mov	 DWORD PTR _iAngelKingPaperLevel$[ebp], edi

; 1175 : 	int iBloodBoneLevel = 0;

  00042	89 7d ec	 mov	 DWORD PTR _iBloodBoneLevel$[ebp], edi

; 1176 : 	int iCharmOfLuckCount=0;

  00045	89 7d 08	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], edi
  00048	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL28@CheckChoas:

; 1179 : 	{
; 1180 : 		if ( gObj[iIndex].pChaosBox[i].IsItem() == TRUE )

  00050	8b 8e dc 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3292]
  00056	03 cf		 add	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005d	83 f8 01	 cmp	 eax, 1
  00060	75 77		 jne	 SHORT $LN27@CheckChoas

; 1181 : 		{
; 1182 : 			if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(12,15) ) // Chaos

  00062	8b 86 dc 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3292]
  00068	0f b7 4c 38 06	 movzx	 ecx, WORD PTR [eax+edi+6]
  0006d	03 c7		 add	 eax, edi
  0006f	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  00074	66 3b ca	 cmp	 cx, dx
  00077	75 09		 jne	 SHORT $LN24@CheckChoas

; 1183 : 			{
; 1184 : 				bIsChaosGemExist = TRUE;

  00079	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bIsChaosGemExist$[ebp], 1
  00080	eb 57		 jmp	 SHORT $LN27@CheckChoas
$LN24@CheckChoas:

; 1185 : 			}
; 1186 : 			else if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(13,16) ) //Scroll of Archangel

  00082	ba 10 1a 00 00	 mov	 edx, 6672		; 00001a10H
  00087	66 3b ca	 cmp	 cx, dx
  0008a	75 11		 jne	 SHORT $LN22@CheckChoas

; 1187 : 			{
; 1188 : 				int iSCROLL_LEVEL = gObj[iIndex].pChaosBox[i].m_Level;
; 1189 : 				iEventItemCount++;
; 1190 : 				bIsAngelKingPaperExist = TRUE;
; 1191 : 				iAngelKingPaperLevel = iSCROLL_LEVEL;

  0008c	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  00090	43		 inc	 ebx
  00091	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _bIsAngelKingPaperExist$[ebp], 1
  00098	89 45 f0	 mov	 DWORD PTR _iAngelKingPaperLevel$[ebp], eax
  0009b	eb 3c		 jmp	 SHORT $LN27@CheckChoas
$LN22@CheckChoas:

; 1192 : 			}
; 1193 : 			else if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(13,17) ) //Blood Bone

  0009d	ba 11 1a 00 00	 mov	 edx, 6673		; 00001a11H
  000a2	66 3b ca	 cmp	 cx, dx
  000a5	75 11		 jne	 SHORT $LN20@CheckChoas

; 1194 : 			{
; 1195 : 				int iBLOOD_BONE_LEVEL = gObj[iIndex].pChaosBox[i].m_Level;
; 1196 : 				iEventItemCount++;
; 1197 : 				bIsBloodBoneExist = TRUE;
; 1198 : 				iBloodBoneLevel = iBLOOD_BONE_LEVEL;

  000a7	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  000ab	43		 inc	 ebx
  000ac	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bIsBloodBoneExist$[ebp], 1
  000b3	89 45 ec	 mov	 DWORD PTR _iBloodBoneLevel$[ebp], eax
  000b6	eb 21		 jmp	 SHORT $LN27@CheckChoas
$LN20@CheckChoas:

; 1199 : 			}
; 1200 : 			else if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(14,53) ) //Charm

  000b8	ba 35 1c 00 00	 mov	 edx, 7221		; 00001c35H
  000bd	66 3b ca	 cmp	 cx, dx
  000c0	75 10		 jne	 SHORT $LN18@CheckChoas

; 1201 : 			{
; 1202 : 				iCharmOfLuckCount += gObj[iIndex].pChaosBox[i].m_Durability;

  000c2	db 45 08	 fild	 DWORD PTR _iCharmOfLuckCount$[ebp]
  000c5	d8 40 24	 fadd	 DWORD PTR [eax+36]
  000c8	e8 00 00 00 00	 call	 __ftol2_sse
  000cd	89 45 08	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], eax

; 1203 : 			}
; 1204 : 			else

  000d0	eb 07		 jmp	 SHORT $LN27@CheckChoas
$LN18@CheckChoas:

; 1205 : 			{
; 1206 : 				bIsOtherItemExist = TRUE;

  000d2	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bIsOtherItemExist$[ebp], 1
$LN27@CheckChoas:

; 1177 : 
; 1178 : 	for ( int i=0;i<CHAOS_BOX_SIZE;i++)

  000d9	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  000df	81 ff 00 15 00
	00		 cmp	 edi, 5376		; 00001500H
  000e5	0f 8c 65 ff ff
	ff		 jl	 $LL28@CheckChoas

; 1207 : 			}
; 1208 : 		}
; 1209 : 	}
; 1210 : 
; 1211 : 	gObj[iIndex].ChaosSuccessRate = iCharmOfLuckCount;
; 1212 : 
; 1213 : 	if ( bIsOtherItemExist != FALSE )

  000eb	83 7d f8 00	 cmp	 DWORD PTR _bIsOtherItemExist$[ebp], 0
  000ef	8b 45 08	 mov	 eax, DWORD PTR _iCharmOfLuckCount$[ebp]
  000f2	89 86 e8 0c 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3304], eax
  000f8	74 0e		 je	 SHORT $LN16@CheckChoas

; 1214 : 	{
; 1215 : 		return 8;

  000fa	5b		 pop	 ebx
  000fb	5f		 pop	 edi
  000fc	b8 08 00 00 00	 mov	 eax, 8
  00101	5e		 pop	 esi

; 1276 : 	}
; 1277 : 
; 1278 : 	return 0;
; 1279 : }

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c2 04 00	 ret	 4
$LN16@CheckChoas:

; 1216 : 	}
; 1217 : 
; 1218 : 	if ( bIsAngelKingPaperExist == FALSE && bIsBloodBoneExist == FALSE )

  00108	83 7d f4 00	 cmp	 DWORD PTR _bIsAngelKingPaperExist$[ebp], 0
  0010c	75 15		 jne	 SHORT $LN40@CheckChoas
  0010e	83 7d fc 00	 cmp	 DWORD PTR _bIsBloodBoneExist$[ebp], 0
  00112	0f 85 e7 00 00
	00		 jne	 $LN13@CheckChoas

; 1219 : 	{
; 1220 : 		return 0;

  00118	5b		 pop	 ebx
  00119	5f		 pop	 edi
  0011a	33 c0		 xor	 eax, eax
  0011c	5e		 pop	 esi

; 1276 : 	}
; 1277 : 
; 1278 : 	return 0;
; 1279 : }

  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c2 04 00	 ret	 4
$LN40@CheckChoas:

; 1221 : 	}
; 1222 : 
; 1223 : 	if ( bIsAngelKingPaperExist == FALSE || bIsBloodBoneExist == FALSE )

  00123	83 7d fc 00	 cmp	 DWORD PTR _bIsBloodBoneExist$[ebp], 0
  00127	0f 84 d2 00 00
	00		 je	 $LN13@CheckChoas

; 1226 : 	}
; 1227 : 
; 1228 : 	if ( iEventItemCount > 2 )

  0012d	83 fb 02	 cmp	 ebx, 2
  00130	7e 0e		 jle	 SHORT $LN12@CheckChoas

; 1229 : 	{
; 1230 : 		return 12;

  00132	5b		 pop	 ebx
  00133	5f		 pop	 edi
  00134	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00139	5e		 pop	 esi

; 1276 : 	}
; 1277 : 
; 1278 : 	return 0;
; 1279 : }

  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c2 04 00	 ret	 4
$LN12@CheckChoas:

; 1231 : 	}
; 1232 : 
; 1233 : 	if ( iCharmOfLuckCount > 10 )

  00140	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00143	7e 0e		 jle	 SHORT $LN11@CheckChoas

; 1234 : 	{
; 1235 : 		return 15;

  00145	5b		 pop	 ebx
  00146	5f		 pop	 edi
  00147	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  0014c	5e		 pop	 esi

; 1276 : 	}
; 1277 : 
; 1278 : 	return 0;
; 1279 : }

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 04 00	 ret	 4
$LN11@CheckChoas:

; 1236 : 	}
; 1237 : 
; 1238 : 	if ( iAngelKingPaperLevel != iBloodBoneLevel )

  00153	8b 7d f0	 mov	 edi, DWORD PTR _iAngelKingPaperLevel$[ebp]
  00156	8b 4d ec	 mov	 ecx, DWORD PTR _iBloodBoneLevel$[ebp]
  00159	3b f9		 cmp	 edi, ecx

; 1239 : 	{
; 1240 : 		return 9;

  0015b	75 2a		 jne	 SHORT $LN43@CheckChoas

; 1241 : 	}
; 1242 : 
; 1243 : 	if ( BC_BRIDGE_RANGE(iAngelKingPaperLevel-1) == FALSE )

  0015d	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00160	85 c0		 test	 eax, eax
  00162	78 23		 js	 SHORT $LN43@CheckChoas
  00164	33 d2		 xor	 edx, edx
  00166	83 f8 06	 cmp	 eax, 6
  00169	0f 9e c2	 setle	 dl
  0016c	8b c2		 mov	 eax, edx
  0016e	85 c0		 test	 eax, eax

; 1244 : 	{
; 1245 : 		return 9;

  00170	74 15		 je	 SHORT $LN43@CheckChoas

; 1246 : 	}
; 1247 : 
; 1248 : 	if ( BC_BRIDGE_RANGE(iBloodBoneLevel-1) == FALSE )

  00172	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00175	85 c0		 test	 eax, eax
  00177	78 0e		 js	 SHORT $LN43@CheckChoas
  00179	33 c9		 xor	 ecx, ecx
  0017b	83 f8 06	 cmp	 eax, 6
  0017e	0f 9e c1	 setle	 cl
  00181	8b c1		 mov	 eax, ecx
  00183	85 c0		 test	 eax, eax
  00185	75 0e		 jne	 SHORT $LN8@CheckChoas
$LN43@CheckChoas:
  00187	5b		 pop	 ebx
  00188	5f		 pop	 edi

; 1249 : 	{
; 1250 : 		return 9;

  00189	b8 09 00 00 00	 mov	 eax, 9
  0018e	5e		 pop	 esi

; 1276 : 	}
; 1277 : 
; 1278 : 	return 0;
; 1279 : }

  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c2 04 00	 ret	 4
$LN8@CheckChoas:

; 1251 : 	}
; 1252 : 
; 1253 : 	if ( bIsChaosGemExist == FALSE )

  00195	83 7d e8 00	 cmp	 DWORD PTR _bIsChaosGemExist$[ebp], 0
  00199	75 0e		 jne	 SHORT $LN7@CheckChoas

; 1254 : 	{
; 1255 : 		return 10;

  0019b	5b		 pop	 ebx
  0019c	5f		 pop	 edi
  0019d	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  001a2	5e		 pop	 esi

; 1276 : 	}
; 1277 : 
; 1278 : 	return 0;
; 1279 : }

  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c2 04 00	 ret	 4
$LN7@CheckChoas:

; 1256 : 	}
; 1257 : 
; 1258 : 	if ( gObj[iIndex].Class == CLASS_DARKLORD || gObj[iIndex].Class == CLASS_MAGUMSA )

  001a9	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152]
  001b0	83 f8 04	 cmp	 eax, 4
  001b3	74 22		 je	 SHORT $LN5@CheckChoas
  001b5	83 f8 03	 cmp	 eax, 3
  001b8	74 1d		 je	 SHORT $LN5@CheckChoas

; 1263 : 		}
; 1264 : 	}
; 1265 : 	else
; 1266 : 	{
; 1267 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[0].iLOWER_BOUND )

  001ba	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156]
  001c1	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL
  001c7	7d 2b		 jge	 SHORT $LN4@CheckChoas

; 1268 : 		{
; 1269 : 			return 14;

  001c9	5b		 pop	 ebx
  001ca	5f		 pop	 edi
  001cb	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  001d0	5e		 pop	 esi

; 1276 : 	}
; 1277 : 
; 1278 : 	return 0;
; 1279 : }

  001d1	8b e5		 mov	 esp, ebp
  001d3	5d		 pop	 ebp
  001d4	c2 04 00	 ret	 4
$LN5@CheckChoas:

; 1259 : 	{
; 1260 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[0].iLOWER_BOUND_MAGUMSA )

  001d7	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156]
  001de	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR _g_sttBLOODCASTLE_LEVEL+8
  001e4	7d 0e		 jge	 SHORT $LN4@CheckChoas

; 1261 : 		{
; 1262 : 			return 14;

  001e6	5b		 pop	 ebx
  001e7	5f		 pop	 edi
  001e8	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  001ed	5e		 pop	 esi

; 1276 : 	}
; 1277 : 
; 1278 : 	return 0;
; 1279 : }

  001ee	8b e5		 mov	 esp, ebp
  001f0	5d		 pop	 ebp
  001f1	c2 04 00	 ret	 4
$LN4@CheckChoas:
  001f4	5b		 pop	 ebx

; 1270 : 		}
; 1271 : 	}
; 1272 : 
; 1273 : 	if ( bIsChaosGemExist != FALSE && bIsAngelKingPaperExist != FALSE && bIsBloodBoneExist != FALSE )
; 1274 : 	{
; 1275 : 		return iAngelKingPaperLevel;

  001f5	8b c7		 mov	 eax, edi
  001f7	5f		 pop	 edi
  001f8	5e		 pop	 esi

; 1276 : 	}
; 1277 : 
; 1278 : 	return 0;
; 1279 : }

  001f9	8b e5		 mov	 esp, ebp
  001fb	5d		 pop	 ebp
  001fc	c2 04 00	 ret	 4
$LN13@CheckChoas:
  001ff	5b		 pop	 ebx
  00200	5f		 pop	 edi

; 1224 : 	{
; 1225 : 		return 11;

  00201	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00206	5e		 pop	 esi

; 1276 : 	}
; 1277 : 
; 1278 : 	return 0;
; 1279 : }

  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c2 04 00	 ret	 4
?CheckChoasMixItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckChoasMixItem
_TEXT	ENDS
PUBLIC	?CheckEnterItem@CBloodCastle@@QAEHH@Z		; CBloodCastle::CheckEnterItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckEnterItem@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckEnterItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckEnterItem, COMDAT
; _this$ = ecx

; 1288 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1289 : 	int iITEM_LEVEL = 0;
; 1290 : 
; 1291 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	56		 push	 esi
  00007	33 f6		 xor	 esi, esi
  00009	85 c0		 test	 eax, eax
  0000b	78 0e		 js	 SHORT $LN21@CheckEnter@3
  0000d	33 c9		 xor	 ecx, ecx
  0000f	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00014	0f 9e c1	 setle	 cl
  00017	85 c9		 test	 ecx, ecx
  00019	75 07		 jne	 SHORT $LN11@CheckEnter@3
$LN21@CheckEnter@3:

; 1292 : 	{
; 1293 : 		return 0;

  0001b	33 c0		 xor	 eax, eax
  0001d	5e		 pop	 esi

; 1329 : }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN11@CheckEnter@3:
  00022	53		 push	 ebx

; 1294 : 	}
; 1295 : 
; 1296 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00023	8b d8		 mov	 ebx, eax
  00025	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  0002b	66 83 bb 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+96], 1
  00033	75 76		 jne	 SHORT $LN9@CheckEnter@3
  00035	80 bb 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+4], 2
  0003c	76 6d		 jbe	 SHORT $LN9@CheckEnter@3

; 1299 : 	}
; 1300 : 
; 1301 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  0003e	57		 push	 edi
  0003f	33 ff		 xor	 edi, edi
$LL8@CheckEnter@3:

; 1302 : 	{
; 1303 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00041	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3212]
  00047	03 cf		 add	 ecx, edi
  00049	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004e	83 f8 01	 cmp	 eax, 1
  00051	75 41		 jne	 SHORT $LN7@CheckEnter@3

; 1304 : 		{
; 1305 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,18) ) // Invisibility Cloak

  00053	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3212]
  00059	0f b7 4c 38 06	 movzx	 ecx, WORD PTR [eax+edi+6]
  0005e	ba 12 1a 00 00	 mov	 edx, 6674		; 00001a12H
  00063	66 3b ca	 cmp	 cx, dx
  00066	75 1d		 jne	 SHORT $LN2@CheckEnter@3

; 1306 : 			{
; 1307 : 				iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;

  00068	0f bf 74 38 08	 movsx	 esi, WORD PTR [eax+edi+8]

; 1308 : 
; 1309 : 				if ( CHECK_LIMIT(iITEM_LEVEL, MAX_CLOACK_LEVEL) == FALSE )

  0006d	85 f6		 test	 esi, esi
  0006f	78 0c		 js	 SHORT $LN22@CheckEnter@3
  00071	33 c0		 xor	 eax, eax
  00073	83 fe 07	 cmp	 esi, 7
  00076	0f 9e c0	 setle	 al
  00079	85 c0		 test	 eax, eax
  0007b	75 04		 jne	 SHORT $LN3@CheckEnter@3
$LN22@CheckEnter@3:

; 1310 : 				{
; 1311 : 					iITEM_LEVEL = 0;

  0007d	33 f6		 xor	 esi, esi

; 1312 : 
; 1313 : 				}
; 1314 : 
; 1315 : 				if ( iITEM_LEVEL != 0 )

  0007f	eb 04		 jmp	 SHORT $LN2@CheckEnter@3
$LN3@CheckEnter@3:
  00081	85 f6		 test	 esi, esi
  00083	75 1d		 jne	 SHORT $LN6@CheckEnter@3
$LN2@CheckEnter@3:

; 1316 : 				{
; 1317 : 					return iITEM_LEVEL;
; 1318 : 				}
; 1319 : 			}
; 1320 : 			
; 1321 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,47) ) // 

  00085	b8 2f 1a 00 00	 mov	 eax, 6703		; 00001a2fH
  0008a	66 3b c8	 cmp	 cx, ax
  0008d	75 05		 jne	 SHORT $LN7@CheckEnter@3

; 1322 : 			{
; 1323 : 				iITEM_LEVEL = 10;

  0008f	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
$LN7@CheckEnter@3:

; 1299 : 	}
; 1300 : 
; 1301 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  00094	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  0009a	81 ff e0 31 00
	00		 cmp	 edi, 12768		; 000031e0H
  000a0	7c 9f		 jl	 SHORT $LL8@CheckEnter@3
$LN6@CheckEnter@3:
  000a2	5f		 pop	 edi
  000a3	5b		 pop	 ebx

; 1324 : 			}
; 1325 : 		}
; 1326 : 	}
; 1327 : 
; 1328 : 	return iITEM_LEVEL;

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi

; 1329 : }

  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
$LN9@CheckEnter@3:
  000ab	5b		 pop	 ebx

; 1297 : 	{
; 1298 : 		return 0;

  000ac	33 c0		 xor	 eax, eax
  000ae	5e		 pop	 esi

; 1329 : }

  000af	5d		 pop	 ebp
  000b0	c2 04 00	 ret	 4
?CheckEnterItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckEnterItem
_TEXT	ENDS
PUBLIC	?CheckQuestItem@CBloodCastle@@QAEHH@Z		; CBloodCastle::CheckQuestItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckQuestItem@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iITEM_LEVEL$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?CheckQuestItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckQuestItem, COMDAT
; _this$ = ecx

; 1338 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1339 : 	int iITEM_LEVEL = -1;
; 1340 : 
; 1341 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00008	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  0000b	83 ce ff	 or	 esi, -1
  0000e	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00011	89 75 fc	 mov	 DWORD PTR _iITEM_LEVEL$[ebp], esi
  00014	85 ff		 test	 edi, edi
  00016	78 0f		 js	 SHORT $LN23@CheckQuest
  00018	33 d2		 xor	 edx, edx
  0001a	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  00020	0f 9e c2	 setle	 dl
  00023	85 d2		 test	 edx, edx
  00025	75 0a		 jne	 SHORT $LN13@CheckQuest
$LN23@CheckQuest:
  00027	5f		 pop	 edi

; 1342 : 	{
; 1343 : 		return -1;

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi

; 1375 : 						
; 1376 : 					}
; 1377 : 
; 1378 : 					break;
; 1379 : 				}
; 1380 : 			}
; 1381 : 		}
; 1382 : 	}
; 1383 : 
; 1384 : 	return iITEM_LEVEL;
; 1385 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
$LN13@CheckQuest:

; 1344 : 	}
; 1345 : 
; 1346 : 	if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) == FALSE )

  00031	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00037	53		 push	 ebx
  00038	8a 9f 09 01 00
	00		 mov	 bl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+265]
  0003e	80 fb 0b	 cmp	 bl, 11			; 0000000bH
  00041	0f 82 ce 00 00
	00		 jb	 $LN9@CheckQuest
  00047	b0 11		 mov	 al, 17			; 00000011H
  00049	3a c3		 cmp	 al, bl
  0004b	1b d2		 sbb	 edx, edx
  0004d	42		 inc	 edx

; 1347 : 	{
; 1348 : 		return -1;

  0004e	0f 84 c1 00 00
	00		 je	 $LN9@CheckQuest

; 1349 : 	}
; 1350 : 
; 1351 : 
; 1352 : 	if ( this->m_BridgeData[gObj[iIndex].MapNumber - MAP_INDEX_BLOODCASTLE1 ].m_nBC_QUESTITEM_SERIAL == -1 )

  00054	0f b6 d3	 movzx	 edx, bl
  00057	c1 e2 09	 shl	 edx, 9
  0005a	39 b4 0a 90 eb
	ff ff		 cmp	 DWORD PTR [edx+ecx-5232], esi

; 1353 : 	{
; 1354 : 		return -1;

  00061	0f 84 ae 00 00
	00		 je	 $LN9@CheckQuest

; 1355 : 	}
; 1356 : 
; 1357 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00067	66 83 bf 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+96], 1
  0006f	0f 85 a0 00 00
	00		 jne	 $LN9@CheckQuest
  00075	80 bf 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+4], 2
  0007c	0f 86 93 00 00
	00		 jbe	 $LN9@CheckQuest

; 1360 : 	}
; 1361 : 
; 1362 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  00082	33 db		 xor	 ebx, ebx
  00084	33 f6		 xor	 esi, esi
  00086	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL8@CheckQuest:

; 1363 : 	{
; 1364 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00090	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3212]
  00096	03 ce		 add	 ecx, esi
  00098	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0009d	83 f8 01	 cmp	 eax, 1
  000a0	75 2b		 jne	 SHORT $LN7@CheckQuest

; 1365 : 		{
; 1366 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) ) // Absolute Weapon of Archangel QUEST ITEM

  000a2	8b 87 8c 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3212]
  000a8	b9 13 1a 00 00	 mov	 ecx, 6675		; 00001a13H
  000ad	66 39 4c 30 06	 cmp	 WORD PTR [eax+esi+6], cx
  000b2	75 19		 jne	 SHORT $LN7@CheckQuest

; 1367 : 			{
; 1368 : 				if ( gObj[iIndex].pInventory[x].m_Number	== this->m_BridgeData[gObj[iIndex].MapNumber - MAP_INDEX_BLOODCASTLE1].m_nBC_QUESTITEM_SERIAL )

  000b4	0f b6 97 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+265]
  000bb	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  000be	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	c1 e2 09	 shl	 edx, 9
  000c4	3b 84 0a 90 eb
	ff ff		 cmp	 eax, DWORD PTR [edx+ecx-5232]
  000cb	74 1b		 je	 SHORT $LN21@CheckQuest
$LN7@CheckQuest:

; 1360 : 	}
; 1361 : 
; 1362 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  000cd	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  000d3	43		 inc	 ebx
  000d4	81 fe e0 31 00
	00		 cmp	 esi, 12768		; 000031e0H
  000da	7c b4		 jl	 SHORT $LL8@CheckQuest

; 1373 : 					{
; 1374 : 						iITEM_LEVEL = -1;

  000dc	8b 45 fc	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  000df	5b		 pop	 ebx
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi

; 1375 : 						
; 1376 : 					}
; 1377 : 
; 1378 : 					break;
; 1379 : 				}
; 1380 : 			}
; 1381 : 		}
; 1382 : 	}
; 1383 : 
; 1384 : 	return iITEM_LEVEL;
; 1385 : }

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
$LN21@CheckQuest:

; 1369 : 				{
; 1370 : 					iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;

  000e8	8b 97 8c 0c 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3212]
  000ee	69 db a8 00 00
	00		 imul	 ebx, 168		; 000000a8H
  000f4	0f bf 44 13 08	 movsx	 eax, WORD PTR [ebx+edx+8]

; 1371 : 
; 1372 : 					if ( iITEM_LEVEL < 0 || iITEM_LEVEL > 2 )

  000f9	85 c0		 test	 eax, eax
  000fb	78 05		 js	 SHORT $LN1@CheckQuest
  000fd	83 f8 02	 cmp	 eax, 2
  00100	7e 15		 jle	 SHORT $LN25@CheckQuest
$LN1@CheckQuest:
  00102	5b		 pop	 ebx

; 1373 : 					{
; 1374 : 						iITEM_LEVEL = -1;

  00103	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], -1
  0010a	8b 45 fc	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi

; 1375 : 						
; 1376 : 					}
; 1377 : 
; 1378 : 					break;
; 1379 : 				}
; 1380 : 			}
; 1381 : 		}
; 1382 : 	}
; 1383 : 
; 1384 : 	return iITEM_LEVEL;
; 1385 : }

  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 04 00	 ret	 4
$LN9@CheckQuest:

; 1358 : 	{
; 1359 : 		return -1;

  00115	8b c6		 mov	 eax, esi
$LN25@CheckQuest:
  00117	5b		 pop	 ebx
  00118	5f		 pop	 edi
  00119	5e		 pop	 esi

; 1375 : 						
; 1376 : 					}
; 1377 : 
; 1378 : 					break;
; 1379 : 				}
; 1380 : 			}
; 1381 : 		}
; 1382 : 	}
; 1383 : 
; 1384 : 	return iITEM_LEVEL;
; 1385 : }

  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 04 00	 ret	 4
?CheckQuestItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckQuestItem
_TEXT	ENDS
PUBLIC	?CheckWalk@CBloodCastle@@QAE_NHHH@Z		; CBloodCastle::CheckWalk
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
; Function compile flags: /Ogtp
;	COMDAT ?CheckWalk@CBloodCastle@@QAE_NHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iMoveX$ = 12						; size = 4
_iMoveY$ = 16						; size = 4
?CheckWalk@CBloodCastle@@QAE_NHHH@Z PROC		; CBloodCastle::CheckWalk, COMDAT
; _this$ = ecx

; 1393 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1394 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	85 c0		 test	 eax, eax
  0000b	78 0e		 js	 SHORT $LN13@CheckWalk
  0000d	33 d2		 xor	 edx, edx
  0000f	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00014	0f 9e c2	 setle	 dl
  00017	85 d2		 test	 edx, edx
  00019	75 07		 jne	 SHORT $LN6@CheckWalk
$LN13@CheckWalk:

; 1395 : 	{
; 1396 : 		return false;

  0001b	32 c0		 xor	 al, al
  0001d	5f		 pop	 edi

; 1420 : }

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
$LN6@CheckWalk:

; 1397 : 	}
; 1398 : 	
; 1399 : 	if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) == FALSE )

  00022	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00028	53		 push	 ebx
  00029	8a 98 09 01 00
	00		 mov	 bl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  0002f	80 fb 0b	 cmp	 bl, 11			; 0000000bH
  00032	72 5e		 jb	 SHORT $LN3@CheckWalk
  00034	b1 11		 mov	 cl, 17			; 00000011H
  00036	3a cb		 cmp	 cl, bl
  00038	1b d2		 sbb	 edx, edx
  0003a	42		 inc	 edx

; 1400 : 	{
; 1401 : 		return false;

  0003b	74 55		 je	 SHORT $LN3@CheckWalk

; 1402 : 	}
; 1403 : 
; 1404 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  0003d	66 83 b8 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 1
  00045	75 4b		 jne	 SHORT $LN3@CheckWalk
  00047	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  0004e	76 42		 jbe	 SHORT $LN3@CheckWalk

; 1407 : 	}
; 1408 : 
; 1409 : 	if ( this->GetCurrentState(gObj[iIndex].MapNumber ) == TRUE )	// Apply Deathway fix here : Add -MAP_INDEX_BLOODCASTLE1

  00050	56		 push	 esi
  00051	0f b6 f3	 movzx	 esi, bl
  00054	56		 push	 esi
  00055	8b cf		 mov	 ecx, edi
  00057	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  0005c	83 f8 01	 cmp	 eax, 1
  0005f	75 28		 jne	 SHORT $LN1@CheckWalk

; 1410 : 	{
; 1411 : 		BYTE btMapAttr = MapC[gObj[iIndex].MapNumber].GetAttr(iMoveX, iMoveY);

  00061	8b 55 10	 mov	 edx, DWORD PTR _iMoveY$[ebp]
  00064	8b 45 0c	 mov	 eax, DWORD PTR _iMoveX$[ebp]
  00067	8b ce		 mov	 ecx, esi
  00069	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  0006f	52		 push	 edx
  00070	50		 push	 eax
  00071	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00077	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 1412 : 
; 1413 : 		if ( (btMapAttr&1) != 1 )

  0007c	a8 01		 test	 al, 1
  0007e	75 09		 jne	 SHORT $LN1@CheckWalk

; 1414 : 		{
; 1415 : 			return true;

  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	b0 01		 mov	 al, 1
  00084	5f		 pop	 edi

; 1420 : }

  00085	5d		 pop	 ebp
  00086	c2 0c 00	 ret	 12			; 0000000cH
$LN1@CheckWalk:
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx

; 1416 : 		}
; 1417 : 	}
; 1418 : 
; 1419 : 	return false;

  0008b	32 c0		 xor	 al, al
  0008d	5f		 pop	 edi

; 1420 : }

  0008e	5d		 pop	 ebp
  0008f	c2 0c 00	 ret	 12			; 0000000cH
$LN3@CheckWalk:
  00092	5b		 pop	 ebx

; 1405 : 	{
; 1406 : 		return false;

  00093	32 c0		 xor	 al, al
  00095	5f		 pop	 edi

; 1420 : }

  00096	5d		 pop	 ebp
  00097	c2 0c 00	 ret	 12			; 0000000cH
?CheckWalk@CBloodCastle@@QAE_NHHH@Z ENDP		; CBloodCastle::CheckWalk
_TEXT	ENDS
PUBLIC	?CheckCanEnter@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckCanEnter
; Function compile flags: /Ogtp
;	COMDAT ?CheckCanEnter@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckCanEnter@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckCanEnter, COMDAT
; _this$ = ecx

; 1428 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1429 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckCanEn
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckCanEn
$LN6@CheckCanEn:

; 1430 : 	{
; 1431 : 		return false;

  00016	32 c0		 xor	 al, al

; 1435 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckCanEn:

; 1432 : 	}
; 1433 : 
; 1434 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER;

  0001c	c1 e0 09	 shl	 eax, 9
  0001f	8a 84 08 63 01
	00 00		 mov	 al, BYTE PTR [eax+ecx+355]

; 1435 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?CheckCanEnter@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckCanEnter
_TEXT	ENDS
PUBLIC	?CheckCanParty@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckCanParty
; Function compile flags: /Ogtp
;	COMDAT ?CheckCanParty@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckCanParty@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckCanParty, COMDAT
; _this$ = ecx

; 1443 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1444 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckCanPa
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckCanPa
$LN6@CheckCanPa:

; 1445 : 	{
; 1446 : 		return false;

  00016	32 c0		 xor	 al, al

; 1450 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckCanPa:

; 1447 : 	}
; 1448 : 
; 1449 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY;

  0001c	c1 e0 09	 shl	 eax, 9
  0001f	8a 84 08 64 01
	00 00		 mov	 al, BYTE PTR [eax+ecx+356]

; 1450 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?CheckCanParty@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckCanParty
_TEXT	ENDS
PUBLIC	?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ; CBloodCastle::CheckQuestItemSerial
; Function compile flags: /Ogtp
;	COMDAT ?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_lpItem$ = 12						; size = 4
?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z PROC ; CBloodCastle::CheckQuestItemSerial, COMDAT
; _this$ = ecx

; 1459 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1460 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN13@CheckQuest@2
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN6@CheckQuest@2
$LN13@CheckQuest@2:

; 1461 : 	{
; 1462 : 		return false;

  00016	32 c0		 xor	 al, al

; 1488 : 
; 1489 : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN6@CheckQuest@2:

; 1463 : 	}
; 1464 : 
; 1465 : 	if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == -1 )

  0001c	c1 e0 09	 shl	 eax, 9
  0001f	83 bc 08 90 01
	00 00 ff	 cmp	 DWORD PTR [eax+ecx+400], -1
  00027	53		 push	 ebx
  00028	8d 9c 08 90 01
	00 00		 lea	 ebx, DWORD PTR [eax+ecx+400]
  0002f	75 07		 jne	 SHORT $LN5@CheckQuest@2

; 1466 : 	{
; 1467 : 		return false;

  00031	32 c0		 xor	 al, al
  00033	5b		 pop	 ebx

; 1488 : 
; 1489 : }

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN5@CheckQuest@2:
  00038	56		 push	 esi

; 1468 : 	}
; 1469 : 	
; 1470 : 	if ( lpItem->IsItem() == TRUE )

  00039	8b 75 0c	 mov	 esi, DWORD PTR _lpItem$[ebp]
  0003c	57		 push	 edi
  0003d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00040	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00045	83 f8 01	 cmp	 eax, 1
  00048	75 31		 jne	 SHORT $LN1@CheckQuest@2

; 1471 : 	{
; 1472 : 		if ( lpItem->m_Type == ITEMGET(13,19) ) // Absolute Weapon

  0004a	b8 13 1a 00 00	 mov	 eax, 6675		; 00001a13H
  0004f	66 39 46 0a	 cmp	 WORD PTR [esi+10], ax
  00053	75 26		 jne	 SHORT $LN1@CheckQuest@2

; 1473 : 		{
; 1474 : 			int iLEVEL = lpItem->m_Level;

  00055	0f bf 46 0c	 movsx	 eax, WORD PTR [esi+12]

; 1475 : 
; 1476 : 			if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  00059	85 c0		 test	 eax, eax
  0005b	78 1e		 js	 SHORT $LN1@CheckQuest@2
  0005d	33 c9		 xor	 ecx, ecx
  0005f	83 f8 02	 cmp	 eax, 2
  00062	0f 9e c1	 setle	 cl
  00065	8b c1		 mov	 eax, ecx
  00067	85 c0		 test	 eax, eax
  00069	74 10		 je	 SHORT $LN1@CheckQuest@2

; 1477 : 			{
; 1478 : 				if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == lpItem->m_Number )

  0006b	8b 13		 mov	 edx, DWORD PTR [ebx]
  0006d	3b 56 04	 cmp	 edx, DWORD PTR [esi+4]
  00070	75 09		 jne	 SHORT $LN1@CheckQuest@2

; 1479 : 				{
; 1480 : 					return true;

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	b0 01		 mov	 al, 1
  00076	5b		 pop	 ebx

; 1488 : 
; 1489 : }

  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
$LN1@CheckQuest@2:
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 1481 : 				}
; 1482 : 			}
; 1483 : 		}
; 1484 : 	}
; 1485 : 	
; 1486 : 
; 1487 : 	return false;

  0007d	32 c0		 xor	 al, al
  0007f	5b		 pop	 ebx

; 1488 : 
; 1489 : }

  00080	5d		 pop	 ebp
  00081	c2 08 00	 ret	 8
?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ENDP ; CBloodCastle::CheckQuestItemSerial
_TEXT	ENDS
PUBLIC	?CheckPlayStart@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckPlayStart
; Function compile flags: /Ogtp
;	COMDAT ?CheckPlayStart@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckPlayStart@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckPlayStart, COMDAT
; _this$ = ecx

; 1497 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1498 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckPlayS
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckPlayS
$LN6@CheckPlayS:

; 1499 : 	{
; 1500 : 		return false;

  00016	32 c0		 xor	 al, al

; 1504 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckPlayS:

; 1501 : 	}
; 1502 : 
; 1503 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START;

  0001c	c1 e0 09	 shl	 eax, 9
  0001f	8a 84 08 65 01
	00 00		 mov	 al, BYTE PTR [eax+ecx+357]

; 1504 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?CheckPlayStart@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckPlayStart
_TEXT	ENDS
PUBLIC	?GetRemainTime@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetRemainTime
EXTRN	?g_iBloodCastle_StartHour@@3HA:DWORD		; g_iBloodCastle_StartHour
; Function compile flags: /Odtp
;	COMDAT ?GetRemainTime@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_ltime$157750 = -24					; size = 8
_iSTART_HOUR$157751 = -12				; size = 4
_today$157749 = -8					; size = 4
_iREMAIN_MINUTE$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetRemainTime@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetRemainTime, COMDAT
; _this$ = ecx

; 1512 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 1513 : 	int iREMAIN_MINUTE = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], 0

; 1514 : 
; 1515 : 	if ( this->GetCurrentState(iBridgeIndex) == 1 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00013	50		 push	 eax
  00014	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  0001c	83 f8 01	 cmp	 eax, 1
  0001f	75 2c		 jne	 SHORT $LN12@GetRemainT

; 1516 : 	{
; 1517 : 		iREMAIN_MINUTE = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 60000 - this->m_iBC_TIME_MIN_OPEN + 1;

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00024	c1 e1 09	 shl	 ecx, 9
  00027	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	8b 84 0a 54 01
	00 00		 mov	 eax, DWORD PTR [edx+ecx+340]
  00031	99		 cdq
  00032	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  00037	f7 f9		 idiv	 ecx
  00039	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	2b 82 08 0e 00
	00		 sub	 eax, DWORD PTR [edx+3592]
  00042	83 c0 01	 add	 eax, 1
  00045	89 45 fc	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax

; 1518 : 	}
; 1519 : 	else

  00048	e9 35 01 00 00	 jmp	 $skip$157759
$LN12@GetRemainT:

; 1520 : 	{
; 1521 : 		tm * today;
; 1522 : 		time_t ltime;
; 1523 : 		time(&ltime);

  0004d	8d 45 e8	 lea	 eax, DWORD PTR _ltime$157750[ebp]
  00050	e8 00 00 00 00	 call	 _time

; 1524 : 		today = localtime(&ltime);

  00055	8d 45 e8	 lea	 eax, DWORD PTR _ltime$157750[ebp]
  00058	e8 00 00 00 00	 call	 _localtime
  0005d	89 45 f8	 mov	 DWORD PTR _today$157749[ebp], eax

; 1525 : 
; 1526 : 		int iSTART_HOUR = g_iBloodCastle_StartHour;

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_iBloodCastle_StartHour@@3HA ; g_iBloodCastle_StartHour
  00065	89 45 f4	 mov	 DWORD PTR _iSTART_HOUR$157751[ebp], eax

; 1527 : 
; 1528 : 		if ( iSTART_HOUR != 2 )

  00068	83 7d f4 02	 cmp	 DWORD PTR _iSTART_HOUR$157751[ebp], 2
  0006c	74 05		 je	 SHORT $LN10@GetRemainT

; 1529 : 		{
; 1530 : 			//__asm JMP label2
; 1531 : 		}
; 1532 : 		else

  0006e	e9 a6 00 00 00	 jmp	 $LN9@GetRemainT
$LN10@GetRemainT:

; 1533 : 		{
; 1534 : 			if ( (today->tm_hour % 2) == 0 )

  00073	8b 4d f8	 mov	 ecx, DWORD PTR _today$157749[ebp]
  00076	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00079	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  0007f	79 05		 jns	 SHORT $LN19@GetRemainT
  00081	4a		 dec	 edx
  00082	83 ca fe	 or	 edx, -2			; fffffffeH
  00085	42		 inc	 edx
$LN19@GetRemainT:
  00086	85 d2		 test	 edx, edx
  00088	75 5c		 jne	 SHORT $LN8@GetRemainT

; 1535 : 			{
; 1536 : 				if ( (today->tm_min * 60 + today->tm_sec) >= 1800 )

  0008a	8b 45 f8	 mov	 eax, DWORD PTR _today$157749[ebp]
  0008d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00090	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  00093	8b 55 f8	 mov	 edx, DWORD PTR _today$157749[ebp]
  00096	03 0a		 add	 ecx, DWORD PTR [edx]
  00098	81 f9 08 07 00
	00		 cmp	 ecx, 1800		; 00000708H
  0009e	7c 22		 jl	 SHORT $LN7@GetRemainT

; 1537 : 				{
; 1538 : 					iREMAIN_MINUTE = (9000 - (today->tm_min * 60 + today->tm_sec)) / 60;

  000a0	8b 45 f8	 mov	 eax, DWORD PTR _today$157749[ebp]
  000a3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a6	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  000a9	8b 55 f8	 mov	 edx, DWORD PTR _today$157749[ebp]
  000ac	03 0a		 add	 ecx, DWORD PTR [edx]
  000ae	b8 28 23 00 00	 mov	 eax, 9000		; 00002328H
  000b3	2b c1		 sub	 eax, ecx
  000b5	99		 cdq
  000b6	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  000bb	f7 f9		 idiv	 ecx
  000bd	89 45 fc	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax

; 1539 : 				}
; 1540 : 				else

  000c0	eb 22		 jmp	 SHORT $LN6@GetRemainT
$LN7@GetRemainT:

; 1541 : 				{
; 1542 : 					iREMAIN_MINUTE = (1800 - (today->tm_min * 60 + today->tm_sec)) / 60;

  000c2	8b 55 f8	 mov	 edx, DWORD PTR _today$157749[ebp]
  000c5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c8	6b c0 3c	 imul	 eax, 60			; 0000003cH
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _today$157749[ebp]
  000ce	03 01		 add	 eax, DWORD PTR [ecx]
  000d0	ba 08 07 00 00	 mov	 edx, 1800		; 00000708H
  000d5	2b d0		 sub	 edx, eax
  000d7	8b c2		 mov	 eax, edx
  000d9	99		 cdq
  000da	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  000df	f7 f9		 idiv	 ecx
  000e1	89 45 fc	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax
$LN6@GetRemainT:

; 1543 : 				}
; 1544 : 			}
; 1545 : 			else

  000e4	eb 22		 jmp	 SHORT $LN5@GetRemainT
$LN8@GetRemainT:

; 1546 : 			{
; 1547 : 				iREMAIN_MINUTE = (1800 - (today->tm_min * 60 + today->tm_sec)) / 60;

  000e6	8b 55 f8	 mov	 edx, DWORD PTR _today$157749[ebp]
  000e9	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ec	6b c0 3c	 imul	 eax, 60			; 0000003cH
  000ef	8b 4d f8	 mov	 ecx, DWORD PTR _today$157749[ebp]
  000f2	03 01		 add	 eax, DWORD PTR [ecx]
  000f4	ba 08 07 00 00	 mov	 edx, 1800		; 00000708H
  000f9	2b d0		 sub	 edx, eax
  000fb	8b c2		 mov	 eax, edx
  000fd	99		 cdq
  000fe	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00103	f7 f9		 idiv	 ecx
  00105	89 45 fc	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax
$LN5@GetRemainT:

; 1548 : 			}
; 1549 : 
; 1550 : 			if ( iREMAIN_MINUTE < 0 )

  00108	83 7d fc 00	 cmp	 DWORD PTR _iREMAIN_MINUTE$[ebp], 0
  0010c	7d 09		 jge	 SHORT $LN4@GetRemainT

; 1551 : 			{
; 1552 : 				iREMAIN_MINUTE += 60;

  0010e	8b 55 fc	 mov	 edx, DWORD PTR _iREMAIN_MINUTE$[ebp]
  00111	83 c2 3c	 add	 edx, 60			; 0000003cH
  00114	89 55 fc	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], edx
$LN4@GetRemainT:

; 1553 : 				
; 1554 : 			}
; 1555 : 
; 1556 : 			__asm JMP skip;

  00117	eb 69		 jmp	 SHORT $skip$157759
$LN9@GetRemainT:

; 1557 : 		}
; 1558 : 		
; 1559 : 		if ( today->tm_min * 60 + today->tm_sec >= 1800 )

  00119	8b 45 f8	 mov	 eax, DWORD PTR _today$157749[ebp]
  0011c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0011f	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  00122	8b 55 f8	 mov	 edx, DWORD PTR _today$157749[ebp]
  00125	03 0a		 add	 ecx, DWORD PTR [edx]
  00127	81 f9 08 07 00
	00		 cmp	 ecx, 1800		; 00000708H
  0012d	7c 22		 jl	 SHORT $LN3@GetRemainT

; 1560 : 		{
; 1561 : 			iREMAIN_MINUTE = (5400 - (today->tm_min * 60 + today->tm_sec)) / 60;

  0012f	8b 45 f8	 mov	 eax, DWORD PTR _today$157749[ebp]
  00132	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00135	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  00138	8b 55 f8	 mov	 edx, DWORD PTR _today$157749[ebp]
  0013b	03 0a		 add	 ecx, DWORD PTR [edx]
  0013d	b8 18 15 00 00	 mov	 eax, 5400		; 00001518H
  00142	2b c1		 sub	 eax, ecx
  00144	99		 cdq
  00145	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0014a	f7 f9		 idiv	 ecx
  0014c	89 45 fc	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax

; 1562 : 		}
; 1563 : 		else

  0014f	eb 22		 jmp	 SHORT $LN2@GetRemainT
$LN3@GetRemainT:

; 1564 : 		{
; 1565 : 			iREMAIN_MINUTE = (1800 - (today->tm_min * 60 + today->tm_sec)) / 60;

  00151	8b 55 f8	 mov	 edx, DWORD PTR _today$157749[ebp]
  00154	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00157	6b c0 3c	 imul	 eax, 60			; 0000003cH
  0015a	8b 4d f8	 mov	 ecx, DWORD PTR _today$157749[ebp]
  0015d	03 01		 add	 eax, DWORD PTR [ecx]
  0015f	ba 08 07 00 00	 mov	 edx, 1800		; 00000708H
  00164	2b d0		 sub	 edx, eax
  00166	8b c2		 mov	 eax, edx
  00168	99		 cdq
  00169	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0016e	f7 f9		 idiv	 ecx
  00170	89 45 fc	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax
$LN2@GetRemainT:

; 1566 : 		}
; 1567 : 
; 1568 : 		if ( iREMAIN_MINUTE < 0 )

  00173	83 7d fc 00	 cmp	 DWORD PTR _iREMAIN_MINUTE$[ebp], 0
  00177	7d 09		 jge	 SHORT $skip$157759

; 1569 : 		{
; 1570 : 			iREMAIN_MINUTE += 60;

  00179	8b 55 fc	 mov	 edx, DWORD PTR _iREMAIN_MINUTE$[ebp]
  0017c	83 c2 3c	 add	 edx, 60			; 0000003cH
  0017f	89 55 fc	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], edx
$skip$157759:

; 1571 : 		}
; 1572 : 
; 1573 : 
; 1574 : 	}
; 1575 : 
; 1576 : 	skip:
; 1577 : 	return iREMAIN_MINUTE;

  00182	8b 45 fc	 mov	 eax, DWORD PTR _iREMAIN_MINUTE$[ebp]

; 1578 : }

  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c2 04 00	 ret	 4
?GetRemainTime@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetRemainTime
_TEXT	ENDS
PUBLIC	?ClearMonster@CBloodCastle@@QAEXH_N@Z		; CBloodCastle::ClearMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
; Function compile flags: /Ogtp
;	COMDAT ?ClearMonster@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_bClearCastleDoor$ = 12					; size = 1
?ClearMonster@CBloodCastle@@QAEXH_N@Z PROC		; CBloodCastle::ClearMonster, COMDAT
; _this$ = ecx

; 1586 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1587 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 56		 js	 SHORT $LN4@ClearMonst
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c1	 setle	 cl
  00012	85 c9		 test	 ecx, ecx
  00014	74 4a		 je	 SHORT $LN4@ClearMonst

; 1588 : 	{
; 1589 : 		return;
; 1590 : 	}
; 1591 : 
; 1592 : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	33 ff		 xor	 edi, edi
  0001b	8d 58 0b	 lea	 ebx, DWORD PTR [eax+11]
  0001e	be 98 00 00 00	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+152
$LL6@ClearMonst:

; 1593 : 	{
; 1594 : 		if ( gObj[n].MapNumber == (iBridgeIndex+MAP_INDEX_BLOODCASTLE1))

  00023	0f b6 46 71	 movzx	 eax, BYTE PTR [esi+113]
  00027	3b c3		 cmp	 eax, ebx
  00029	75 23		 jne	 SHORT $LN5@ClearMonst

; 1595 : 		{
; 1596 : 			if ( bClearCastleDoor == false && gObj[n].Class == 131)

  0002b	80 7d 0c 00	 cmp	 BYTE PTR _bClearCastleDoor$[ebp], 0
  0002f	75 0a		 jne	 SHORT $LN2@ClearMonst
  00031	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00036	66 39 0e	 cmp	 WORD PTR [esi], cx
  00039	74 13		 je	 SHORT $LN5@ClearMonst
$LN2@ClearMonst:

; 1597 : 			{
; 1598 : 				continue;
; 1599 : 			}
; 1600 : 
; 1601 : 			if ( gObj[n].Class == 232 )

  0003b	ba e8 00 00 00	 mov	 edx, 232		; 000000e8H
  00040	66 39 16	 cmp	 WORD PTR [esi], dx
  00043	74 09		 je	 SHORT $LN5@ClearMonst

; 1602 : 			{
; 1603 : 				continue;
; 1604 : 			}
; 1605 : 
; 1606 : 			gObjDel(n);

  00045	57		 push	 edi
  00046	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0004b	83 c4 04	 add	 esp, 4
$LN5@ClearMonst:

; 1588 : 	{
; 1589 : 		return;
; 1590 : 	}
; 1591 : 
; 1592 : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  0004e	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  00054	47		 inc	 edi
  00055	81 fe 38 a2 e4
	01		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+31760952
  0005b	7c c6		 jl	 SHORT $LL6@ClearMonst
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
$LN4@ClearMonst:

; 1607 : 		}
; 1608 : 	}
; 1609 : }

  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
?ClearMonster@CBloodCastle@@QAEXH_N@Z ENDP		; CBloodCastle::ClearMonster
_TEXT	ENDS
PUBLIC	?SetBossMonster@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetBossMonster
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjSetPosMonster@@YAHHH@Z:PROC		; gObjSetPosMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
; Function compile flags: /Ogtp
;	COMDAT ?SetBossMonster@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv167 = -12						; size = 4
tv296 = -8						; size = 4
_btBloodCastleIndex$157819 = -1				; size = 1
_iBridgeIndex$ = 8					; size = 4
?SetBossMonster@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetBossMonster, COMDAT
; _this$ = ecx

; 1719 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1720 : 	int result;
; 1721 : 
; 1722 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00006	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00009	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	85 d2		 test	 edx, edx
  0000e	0f 88 01 01 00
	00		 js	 $LN6@SetBossMon
  00014	33 c0		 xor	 eax, eax
  00016	83 fa 06	 cmp	 edx, 6
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 f1 00 00
	00		 je	 $LN6@SetBossMon

; 1723 : 	{
; 1724 : 		return;
; 1725 : 	}
; 1726 : 
; 1727 : 	for ( int x=0;x<MAX_BLOOD_CASTLE_BOSS_MONSTER;x++)

  00024	8b c2		 mov	 eax, edx
  00026	53		 push	 ebx
  00027	c1 e0 09	 shl	 eax, 9
  0002a	56		 push	 esi
  0002b	8d 8c 08 e4 00
	00 00		 lea	 ecx, DWORD PTR [eax+ecx+228]
  00032	57		 push	 edi
  00033	89 4d f8	 mov	 DWORD PTR tv296[ebp], ecx
  00036	c7 45 f4 14 00
	00 00		 mov	 DWORD PTR tv167[ebp], 20 ; 00000014H
  0003d	eb 04		 jmp	 SHORT $LN8@SetBossMon
  0003f	90		 npad	 1
$LL17@SetBossMon:
  00040	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
$LN8@SetBossMon:

; 1728 : 	{
; 1729 : 		if ( this->m_BridgeData[iBridgeIndex].m_nBossMonsterPosNum[x] != -1 )

  00043	8b 39		 mov	 edi, DWORD PTR [ecx]
  00045	83 ff ff	 cmp	 edi, -1
  00048	0f 84 b2 00 00
	00		 je	 $LN7@SetBossMon

; 1730 : 		{
; 1731 : 			int nBossMonsterPosNum = this->m_BridgeData[iBridgeIndex].m_nBossMonsterPosNum[x];
; 1732 : 			BYTE btMonsterType = gMSetBase.m_Mp[nBossMonsterPosNum].m_Type;

  0004e	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00051	03 c0		 add	 eax, eax
  00053	8a 9c 00 06 00
	00 00		 mov	 bl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+eax+6]
  0005a	03 c0		 add	 eax, eax

; 1733 : 			BYTE btMapNumber = gMSetBase.m_Mp[nBossMonsterPosNum].m_MapNumber;

  0005c	8a 80 08 00 00
	00		 mov	 al, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]

; 1734 : 			BYTE btBloodCastleIndex = btMapNumber - MAP_INDEX_BLOODCASTLE1;

  00062	8d 48 f5	 lea	 ecx, DWORD PTR [eax-11]
  00065	88 4d ff	 mov	 BYTE PTR _btBloodCastleIndex$157819[ebp], cl

; 1735 : 
; 1736 : 			if ( btBloodCastleIndex != iBridgeIndex )

  00068	0f b6 c9	 movzx	 ecx, cl
  0006b	3b ca		 cmp	 ecx, edx
  0006d	0f 85 8d 00 00
	00		 jne	 $LN7@SetBossMon

; 1737 : 			{
; 1738 : 				continue;
; 1739 : 			}
; 1740 : 
; 1741 : 			if ( btMonsterType == 89 || btMonsterType == 95 || btMonsterType == 112 || btMonsterType == 118 || btMonsterType == 124 || btMonsterType == 130 || btMonsterType == 143 )

  00073	80 fb 59	 cmp	 bl, 89			; 00000059H
  00076	74 1e		 je	 SHORT $LN2@SetBossMon
  00078	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  0007b	74 19		 je	 SHORT $LN2@SetBossMon
  0007d	80 fb 70	 cmp	 bl, 112			; 00000070H
  00080	74 14		 je	 SHORT $LN2@SetBossMon
  00082	80 fb 76	 cmp	 bl, 118			; 00000076H
  00085	74 0f		 je	 SHORT $LN2@SetBossMon
  00087	80 fb 7c	 cmp	 bl, 124			; 0000007cH
  0008a	74 0a		 je	 SHORT $LN2@SetBossMon
  0008c	80 fb 82	 cmp	 bl, 130			; 00000082H
  0008f	74 05		 je	 SHORT $LN2@SetBossMon
  00091	80 fb 8f	 cmp	 bl, 143			; 0000008fH
  00094	75 6a		 jne	 SHORT $LN7@SetBossMon
$LN2@SetBossMon:

; 1742 : 			{
; 1743 : 				result = ::gObjAddMonster(btMapNumber);

  00096	0f b6 d0	 movzx	 edx, al
  00099	52		 push	 edx
  0009a	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0009f	0f bf f0	 movsx	 esi, ax
  000a2	83 c4 04	 add	 esp, 4

; 1744 : 
; 1745 : 				if ( result >= 0 )

  000a5	85 f6		 test	 esi, esi
  000a7	78 57		 js	 SHORT $LN7@SetBossMon

; 1746 : 				{
; 1747 : 					::gObjSetPosMonster(result, nBossMonsterPosNum);

  000a9	57		 push	 edi
  000aa	56		 push	 esi
  000ab	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 1748 : 					::gObjSetMonster(result, btMonsterType);

  000b0	0f b6 c3	 movzx	 eax, bl
  000b3	50		 push	 eax
  000b4	56		 push	 esi
  000b5	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1749 : 					gObj[result].MaxRegenTime = this->m_iBC_MONSTER_REGEN;

  000ba	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000c0	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]

; 1750 : 					gObj[result].m_cBloodCastleIndex = btBloodCastleIndex;

  000c9	8a 55 ff	 mov	 dl, BYTE PTR _btBloodCastleIndex$157819[ebp]
  000cc	89 8e 0c 02 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+524], ecx
  000d2	88 96 02 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3330], dl

; 1751 : 					gObj[result].m_ItemRate = this->m_iBC_NORMAL_ITEM_DROP;

  000d8	66 8b 80 14 0e
	00 00		 mov	 ax, WORD PTR [eax+3604]
  000df	83 c4 10	 add	 esp, 16			; 00000010H
  000e2	66 89 86 28 03
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+808], ax

; 1752 : 					gObj[result].Dir = rand() % 8;

  000e9	e8 00 00 00 00	 call	 _rand
  000ee	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  000f3	79 05		 jns	 SHORT $LN18@SetBossMon
  000f5	48		 dec	 eax
  000f6	83 c8 f8	 or	 eax, -8			; fffffff8H
  000f9	40		 inc	 eax
$LN18@SetBossMon:
  000fa	88 86 08 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+264], al
$LN7@SetBossMon:

; 1723 : 	{
; 1724 : 		return;
; 1725 : 	}
; 1726 : 
; 1727 : 	for ( int x=0;x<MAX_BLOOD_CASTLE_BOSS_MONSTER;x++)

  00100	8b 4d f8	 mov	 ecx, DWORD PTR tv296[ebp]
  00103	83 c1 04	 add	 ecx, 4
  00106	ff 4d f4	 dec	 DWORD PTR tv167[ebp]
  00109	89 4d f8	 mov	 DWORD PTR tv296[ebp], ecx
  0010c	0f 85 2e ff ff
	ff		 jne	 $LL17@SetBossMon
  00112	5f		 pop	 edi
  00113	5e		 pop	 esi
  00114	5b		 pop	 ebx
$LN6@SetBossMon:

; 1753 : 				}
; 1754 : 			}
; 1755 : 		}
; 1756 : 	}
; 1757 : }

  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c2 04 00	 ret	 4
?SetBossMonster@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetBossMonster
_TEXT	ENDS
PUBLIC	??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	?SetSaintStatue@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetSaintStatue
;	COMDAT ??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) It''s not Saint Statue( Map:%d'
	DB	', BloodCastleIndex:%d, Type:%d )', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetSaintStatue@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
tv241 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetSaintStatue@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetSaintStatue, COMDAT
; _this$ = ecx

; 1764 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 1765 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000b	85 ff		 test	 edi, edi
  0000d	0f 88 3d 01 00
	00		 js	 $LN1@SetSaintSt
  00013	33 c0		 xor	 eax, eax
  00015	83 ff 06	 cmp	 edi, 6
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 2d 01 00
	00		 je	 $LN1@SetSaintSt

; 1766 : 	{
; 1767 : 		return;
; 1768 : 	}
; 1769 : 
; 1770 : 	int nSaintStatuePosNum = this->m_BridgeData[iBridgeIndex].m_nSaintStatuePosNum;

  00023	53		 push	 ebx
  00024	8b c7		 mov	 eax, edi
  00026	c1 e0 09	 shl	 eax, 9
  00029	56		 push	 esi
  0002a	8b b4 08 34 01
	00 00		 mov	 esi, DWORD PTR [eax+ecx+308]

; 1771 : 	BYTE btMonsterType = gMSetBase.m_Mp[nSaintStatuePosNum].m_Type;

  00031	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00034	03 c0		 add	 eax, eax
  00036	8a 8c 00 06 00
	00 00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+eax+6]
  0003d	03 c0		 add	 eax, eax

; 1772 : 	BYTE btMapNumber = gMSetBase.m_Mp[nSaintStatuePosNum].m_MapNumber;

  0003f	8a 80 08 00 00
	00		 mov	 al, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]

; 1773 : 	BYTE btBloodCastleIndex = btMapNumber - MAP_INDEX_BLOODCASTLE1;

  00045	8d 58 f5	 lea	 ebx, DWORD PTR [eax-11]

; 1774 : 
; 1775 : 	if ( nSaintStatuePosNum != -1 )

  00048	83 fe ff	 cmp	 esi, -1
  0004b	0f 84 fd 00 00
	00		 je	 $LN14@SetSaintSt

; 1776 : 	{
; 1777 : 		if ( BC_STATUE_RANGE(btMonsterType-132) != FALSE )

  00051	0f b6 c9	 movzx	 ecx, cl
  00054	8d 91 7c ff ff
	ff		 lea	 edx, DWORD PTR [ecx-132]
  0005a	89 4d 08	 mov	 DWORD PTR tv241[ebp], ecx
  0005d	85 d2		 test	 edx, edx
  0005f	0f 88 cf 00 00
	00		 js	 $LN13@SetSaintSt
  00065	33 c9		 xor	 ecx, ecx
  00067	83 fa 02	 cmp	 edx, 2
  0006a	0f 9e c1	 setle	 cl
  0006d	85 c9		 test	 ecx, ecx
  0006f	0f 84 bc 00 00
	00		 je	 $LN12@SetSaintSt

; 1778 : 		{
; 1779 : 			int result = gObjAddMonster(btMapNumber);

  00075	0f b6 c8	 movzx	 ecx, al
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0007e	0f bf f8	 movsx	 edi, ax
  00081	83 c4 04	 add	 esp, 4

; 1780 : 
; 1781 : 			if ( result >= 0 )

  00084	85 ff		 test	 edi, edi
  00086	0f 88 c2 00 00
	00		 js	 $LN14@SetSaintSt

; 1782 : 			{
; 1783 : 				::gObjSetPosMonster(result, nSaintStatuePosNum);

  0008c	56		 push	 esi
  0008d	57		 push	 edi
  0008e	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 1784 : 				::gObjSetMonster(result, btMonsterType);

  00093	8b 55 08	 mov	 edx, DWORD PTR tv241[ebp]
  00096	52		 push	 edx
  00097	57		 push	 edi
  00098	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1785 : 				gObj[result].Class = rand() % 3 + 132;

  0009d	8b f7		 mov	 esi, edi
  0009f	83 c4 10	 add	 esp, 16			; 00000010H
  000a2	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000a8	e8 00 00 00 00	 call	 _rand
  000ad	99		 cdq
  000ae	b9 03 00 00 00	 mov	 ecx, 3
  000b3	f7 f9		 idiv	 ecx

; 1786 : 				gObj[result].m_cBloodCastleIndex = btBloodCastleIndex;
; 1787 : 				gObj[result].m_ItemRate = this->m_iBC_NORMAL_ITEM_DROP;

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	88 9e 02 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3330], bl

; 1788 : 				gObj[result].Dir = 1;

  000be	b8 01 00 00 00	 mov	 eax, 1
  000c3	81 c2 84 00 00
	00		 add	 edx, 132		; 00000084H
  000c9	66 89 96 98 00
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152], dx
  000d0	66 8b 91 14 0e
	00 00		 mov	 dx, WORD PTR [ecx+3604]
  000d7	88 86 08 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+264], al

; 1789 : 				gObj[result].m_PosNum = -1;
; 1790 : 				gObj[result].Live = TRUE;

  000dd	88 86 62 00 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+98], al

; 1791 : 				gObj[result].DieRegen = 0;
; 1792 : 				gObj[result].m_State = 1;

  000e3	89 86 bc 01 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+444], eax
  000e9	66 89 96 28 03
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+808], dx

; 1793 : 				gObj[result].MaxRegenTime = 0;
; 1794 : 				gObj[result].MaxLife = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;// Maybe here Deathway Fix

  000f0	0f b6 c3	 movzx	 eax, bl
  000f3	83 ca ff	 or	 edx, -1
  000f6	c1 e0 09	 shl	 eax, 9
  000f9	66 89 96 10 02
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+528], dx
  00100	c6 86 02 02 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+514], 0
  00107	c7 86 0c 02 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+524], 0
  00111	8d 84 08 6c 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+364]
  00118	d9 00		 fld	 DWORD PTR [eax]
  0011a	d9 9e c0 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]

; 1795 : 				gObj[result].Life = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth; // Maybe here Deathway Fix

  00120	d9 00		 fld	 DWORD PTR [eax]
  00122	d9 9e bc 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+188]
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
  0012a	5f		 pop	 edi

; 1802 : 		}
; 1803 : 	}
; 1804 : 
; 1805 : }

  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c2 04 00	 ret	 4
$LN12@SetSaintSt:

; 1776 : 	{
; 1777 : 		if ( BC_STATUE_RANGE(btMonsterType-132) != FALSE )

  00131	8b 4d 08	 mov	 ecx, DWORD PTR tv241[ebp]
$LN13@SetSaintSt:

; 1796 : 			}
; 1797 : 		}
; 1798 : 		else
; 1799 : 		{
; 1800 : 			LogAdd(LOG_BLACK, "[Blood Castle][Bug Tracer] (%d) It's not Saint Statue( Map:%d, BloodCastleIndex:%d, Type:%d )",
; 1801 : 				iBridgeIndex+1, btMapNumber, gMSetBase.m_Mp[nSaintStatuePosNum].m_MapNumber-11, btMonsterType);

  00134	51		 push	 ecx
  00135	0f b6 c0	 movzx	 eax, al
  00138	8d 48 f5	 lea	 ecx, DWORD PTR [eax-11]
  0013b	51		 push	 ecx
  0013c	50		 push	 eax
  0013d	47		 inc	 edi
  0013e	57		 push	 edi
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  00144	6a 00		 push	 0
  00146	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0014b	83 c4 18	 add	 esp, 24			; 00000018H
$LN14@SetSaintSt:
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
$LN1@SetSaintSt:
  00150	5f		 pop	 edi

; 1802 : 		}
; 1803 : 	}
; 1804 : 
; 1805 : }

  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c2 04 00	 ret	 4
?SetSaintStatue@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetSaintStatue
_TEXT	ENDS
PUBLIC	?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z	; CBloodCastle::LeaveUserBridge
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z
_TEXT	SEGMENT
_iRET_VAL$ = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
tv200 = 12						; size = 4
_iBridgeSubIndex$ = 12					; size = 4
_iUserIndex$ = 16					; size = 4
?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z PROC		; CBloodCastle::LeaveUserBridge, COMDAT
; _this$ = ecx

; 1812 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1813 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 0c		 js	 SHORT $LN10@LeaveUserB
  0000e	33 c0		 xor	 eax, eax
  00010	83 fe 06	 cmp	 esi, 6
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 09		 jne	 SHORT $LN3@LeaveUserB
$LN10@LeaveUserB:
  0001a	5e		 pop	 esi

; 1814 : 	{
; 1815 : 		return -1;

  0001b	83 c8 ff	 or	 eax, -1
  0001e	5b		 pop	 ebx

; 1839 : }

  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
$LN3@LeaveUserB:
  00023	57		 push	 edi

; 1816 : 	}
; 1817 : 
; 1818 : 	if ( BC_SUB_BRIDGE_RANGE(iBridgeSubIndex) == FALSE )

  00024	8b 7d 0c	 mov	 edi, DWORD PTR _iBridgeSubIndex$[ebp]
  00027	85 ff		 test	 edi, edi
  00029	78 0c		 js	 SHORT $LN11@LeaveUserB
  0002b	33 c0		 xor	 eax, eax
  0002d	83 ff 09	 cmp	 edi, 9
  00030	0f 9e c0	 setle	 al
  00033	85 c0		 test	 eax, eax
  00035	75 0a		 jne	 SHORT $LN2@LeaveUserB
$LN11@LeaveUserB:
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 1819 : 	{
; 1820 : 		return -1;

  00039	83 c8 ff	 or	 eax, -1
  0003c	5b		 pop	 ebx

; 1839 : }

  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
$LN2@LeaveUserB:

; 1821 : 	}
; 1822 : 
; 1823 : 	int iRET_VAL = -1;
; 1824 : 
; 1825 : 	::EnterCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00041	c1 e6 09	 shl	 esi, 9
  00044	8d 44 1e 04	 lea	 eax, DWORD PTR [esi+ebx+4]
  00048	50		 push	 eax
  00049	c7 45 08 ff ff
	ff ff		 mov	 DWORD PTR _iRET_VAL$[ebp], -1
  00050	89 45 0c	 mov	 DWORD PTR tv200[ebp], eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1826 : 
; 1827 : 	if ( this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iIndex == iUserIndex )

  00059	8b 4d 10	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  0005c	8d 04 bf	 lea	 eax, DWORD PTR [edi+edi*4]
  0005f	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00062	03 c3		 add	 eax, ebx
  00064	39 48 1c	 cmp	 DWORD PTR [eax+28], ecx
  00067	75 1c		 jne	 SHORT $LN1@LeaveUserB

; 1828 : 	{
; 1829 : 		iRET_VAL = iUserIndex;

  00069	89 4d 08	 mov	 DWORD PTR _iRET_VAL$[ebp], ecx

; 1830 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iIndex = -1;
; 1831 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iEXP = 0;

  0006c	33 c9		 xor	 ecx, ecx

; 1832 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iScore = 0;
; 1833 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 0;

  0006e	8d 54 bf 0a	 lea	 edx, DWORD PTR [edi+edi*4+10]
  00072	c7 40 1c ff ff
	ff ff		 mov	 DWORD PTR [eax+28], -1
  00079	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  0007c	89 48 24	 mov	 DWORD PTR [eax+36], ecx
  0007f	8d 04 96	 lea	 eax, DWORD PTR [esi+edx*4]
  00082	89 0c 18	 mov	 DWORD PTR [eax+ebx], ecx
$LN1@LeaveUserB:

; 1834 : 	}
; 1835 : 
; 1836 : 	::LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00085	8b 4d 0c	 mov	 ecx, DWORD PTR tv200[ebp]
  00088	51		 push	 ecx
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1837 : 
; 1838 : 	return iRET_VAL;

  0008f	8b 45 08	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx

; 1839 : }

  00095	5d		 pop	 ebp
  00096	c2 0c 00	 ret	 12			; 0000000cH
?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z ENDP		; CBloodCastle::LeaveUserBridge
_TEXT	ENDS
PUBLIC	?EnterUserBridge@CBloodCastle@@QAEHHH@Z		; CBloodCastle::EnterUserBridge
; Function compile flags: /Ogtp
;	COMDAT ?EnterUserBridge@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
tv197 = -4						; size = 4
_iRET_VAL$ = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?EnterUserBridge@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::EnterUserBridge, COMDAT
; _this$ = ecx

; 1847 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1848 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	85 f6		 test	 esi, esi
  0000d	78 0c		 js	 SHORT $LN16@EnterUserB
  0000f	33 c0		 xor	 eax, eax
  00011	83 fe 06	 cmp	 esi, 6
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	75 0b		 jne	 SHORT $LN7@EnterUserB
$LN16@EnterUserB:
  0001b	5f		 pop	 edi

; 1849 : 	{
; 1850 : 		return -1;

  0001c	83 c8 ff	 or	 eax, -1
  0001f	5e		 pop	 esi

; 1883 : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN7@EnterUserB:

; 1851 : 	}
; 1852 : 
; 1853 : 	int iRET_VAL = -1;
; 1854 : 
; 1855 : 	::EnterCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00026	c1 e6 09	 shl	 esi, 9
  00029	8d 44 3e 04	 lea	 eax, DWORD PTR [esi+edi+4]
  0002d	50		 push	 eax
  0002e	c7 45 08 ff ff
	ff ff		 mov	 DWORD PTR _iRET_VAL$[ebp], -1
  00035	89 45 fc	 mov	 DWORD PTR tv197[ebp], eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _iUserIndex$[ebp]

; 1856 : 
; 1857 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00041	33 c0		 xor	 eax, eax
  00043	8d 4c 3e 1c	 lea	 ecx, DWORD PTR [esi+edi+28]
  00047	53		 push	 ebx
$LL6@EnterUserB:

; 1858 : 	{
; 1859 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00048	8b 19		 mov	 ebx, DWORD PTR [ecx]
  0004a	83 fb ff	 cmp	 ebx, -1
  0004d	74 14		 je	 SHORT $LN14@EnterUserB

; 1860 : 		{
; 1861 : 			if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == iUserIndex )

  0004f	3b da		 cmp	 ebx, edx
  00051	74 0b		 je	 SHORT $LN13@EnterUserB

; 1856 : 
; 1857 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00053	40		 inc	 eax
  00054	83 c1 14	 add	 ecx, 20			; 00000014H
  00057	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0005a	7c ec		 jl	 SHORT $LL6@EnterUserB

; 1865 : 			}
; 1866 : 		}
; 1867 : 
; 1868 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  0005c	eb 32		 jmp	 SHORT $LN4@EnterUserB
$LN13@EnterUserB:

; 1862 : 			{
; 1863 : 				iRET_VAL = i;

  0005e	89 45 08	 mov	 DWORD PTR _iRET_VAL$[ebp], eax

; 1864 : 				break;

  00061	eb 2d		 jmp	 SHORT $LN4@EnterUserB
$LN14@EnterUserB:

; 1869 : 		{
; 1870 : 			iRET_VAL = i;
; 1871 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = iUserIndex;

  00063	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00066	8d 0c 8e	 lea	 ecx, DWORD PTR [esi+ecx*4]

; 1872 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  00069	33 db		 xor	 ebx, ebx
  0006b	89 54 39 1c	 mov	 DWORD PTR [ecx+edi+28], edx

; 1873 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;
; 1874 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 0;
; 1875 : 			gObj[iUserIndex].m_bBloodCastleComplete = false;

  0006f	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00075	89 45 08	 mov	 DWORD PTR _iRET_VAL$[ebp], eax
  00078	89 5c 39 20	 mov	 DWORD PTR [ecx+edi+32], ebx
  0007c	89 5c 39 24	 mov	 DWORD PTR [ecx+edi+36], ebx
  00080	8d 44 80 0a	 lea	 eax, DWORD PTR [eax+eax*4+10]
  00084	8d 0c 86	 lea	 ecx, DWORD PTR [esi+eax*4]
  00087	89 1c 39	 mov	 DWORD PTR [ecx+edi], ebx
  0008a	88 9a 08 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+3336], bl
$LN4@EnterUserB:

; 1876 : 			break;
; 1877 : 		}
; 1878 : 	}
; 1879 : 
; 1880 : 	::LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00090	8b 55 fc	 mov	 edx, DWORD PTR tv197[ebp]
  00093	52		 push	 edx
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1881 : 
; 1882 : 	return iRET_VAL;

  0009a	8b 45 08	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
  0009d	5b		 pop	 ebx
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi

; 1883 : }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 08 00	 ret	 8
?EnterUserBridge@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::EnterUserBridge
_TEXT	ENDS
PUBLIC	??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ ; `string'
PUBLIC	??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ ; `string'
PUBLIC	?LevelUp@CBloodCastle@@QAEHHHH@Z		; CBloodCastle::LevelUp
EXTRN	?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z:PROC ; GJSetCharacterInfo
EXTRN	?gObjCalcMaxLifePower@@YAXH@Z:PROC		; gObjCalcMaxLifePower
EXTRN	?GCLevelUpMsgSend@@YAXHH@Z:PROC			; GCLevelUpMsgSend
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjNextExpCal
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?gObjSetExpPetItem@@YAXHH@Z:PROC		; gObjSetExpPetItem
;	COMDAT ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
CONST	SEGMENT
??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ DB '['
	DB	'%s][%s] LevelUp PlusStatQuest Clear AddStat %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ DB 'E'
	DB	'xperience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex :'
	DB	' %d, EventType : %d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LevelUp@CBloodCastle@@QAEHHHH@Z
_TEXT	SEGMENT
_iLEFT_EXP$ = -4					; size = 4
tv453 = 8						; size = 4
tv443 = 8						; size = 4
tv396 = 8						; size = 4
_iIndex$ = 8						; size = 4
_iAddExp$ = 12						; size = 4
_iEventType$ = 16					; size = 4
?LevelUp@CBloodCastle@@QAEHHHH@Z PROC			; CBloodCastle::LevelUp, COMDAT
; _this$ = ecx

; 1891 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1892 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00008	85 db		 test	 ebx, ebx
  0000a	78 0f		 js	 SHORT $LN13@LevelUp
  0000c	33 c0		 xor	 eax, eax
  0000e	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	75 09		 jne	 SHORT $LN8@LevelUp
$LN13@LevelUp:

; 1893 : 	{
; 1894 : 		return 0;

  0001b	33 c0		 xor	 eax, eax
  0001d	5b		 pop	 ebx

; 1960 : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
$LN8@LevelUp:

; 1895 : 	}
; 1896 : 
; 1897 : 	int iLEFT_EXP = 0;
; 1898 : 
; 1899 :     #if LOG_DECREASE == 0
; 1900 : 	LogAdd(LOG_BLACK, "Experience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex : %d, EventType : %d",
; 1901 : 	gObj[iIndex].MapNumber, gObj[iIndex].X, gObj[iIndex].X,	 
; 1902 : 	gObj[iIndex].AccountID,	gObj[iIndex].Name,
; 1903 : 	gObj[iIndex].Level, gObj[iIndex].Experience,
; 1904 : 	iAddExp, 0, iEventType);

  00024	8b 55 10	 mov	 edx, DWORD PTR _iEventType$[ebp]
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	8b 7d 0c	 mov	 edi, DWORD PTR _iAddExp$[ebp]
  0002c	52		 push	 edx
  0002d	8b f3		 mov	 esi, ebx
  0002f	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00035	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+168]
  0003b	6a 00		 push	 0
  0003d	57		 push	 edi
  0003e	52		 push	 edx
  0003f	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156]
  00046	52		 push	 edx
  00047	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]
  0004e	8d 86 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  00054	8d 8e 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  0005a	51		 push	 ecx
  0005b	89 45 08	 mov	 DWORD PTR tv396[ebp], eax
  0005e	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  00065	8b 4d 08	 mov	 ecx, DWORD PTR tv396[ebp]
  00068	51		 push	 ecx
  00069	50		 push	 eax
  0006a	50		 push	 eax
  0006b	52		 push	 edx
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
  00071	6a 00		 push	 0
  00073	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iLEFT_EXP$[ebp], 0
  0007a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 1905 :     #endif
; 1906 : 
; 1907 : 	::gObjSetExpPetItem(iIndex, iAddExp);

  0007f	57		 push	 edi
  00080	53		 push	 ebx
  00081	e8 00 00 00 00	 call	 ?gObjSetExpPetItem@@YAXHH@Z ; gObjSetExpPetItem

; 1908 : 
; 1909 : 	if ( gObj[iIndex].Level >= MAX_CHAR_LEVEL )

  00086	0f b7 96 9c 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156]
  0008d	b8 90 01 00 00	 mov	 eax, 400		; 00000190H
  00092	83 c4 38	 add	 esp, 56			; 00000038H
  00095	66 3b d0	 cmp	 dx, ax
  00098	7c 2c		 jl	 SHORT $LN7@LevelUp

; 1910 : 	{
; 1911 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 112)), gObj[iIndex].m_Index, 1);

  0009a	8b 8e 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000a0	6a 01		 push	 1
  000a2	51		 push	 ecx
  000a3	68 70 04 00 00	 push	 1136			; 00000470H
  000a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ad	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi

; 1912 : 		return 0;

  000bd	33 c0		 xor	 eax, eax
  000bf	5b		 pop	 ebx

; 1960 : }

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 0c 00	 ret	 12			; 0000000cH
$LN7@LevelUp:

; 1913 : 	}
; 1914 : 
; 1915 : 	if ( (gObj[iIndex].Experience + iAddExp) < gObj[iIndex].NextExp )

  000c6	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+168]
  000cc	8b 8e ac 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+172]
  000d2	8d 1c 38	 lea	 ebx, DWORD PTR [eax+edi]
  000d5	3b d9		 cmp	 ebx, ecx
  000d7	73 0e		 jae	 SHORT $LN6@LevelUp

; 1916 : 	{
; 1917 : 		gObj[iIndex].Experience += iAddExp;

  000d9	89 9e a8 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+168], ebx

; 1918 : 	}
; 1919 : 	else

  000df	8b 5d fc	 mov	 ebx, DWORD PTR _iLEFT_EXP$[ebp]
  000e2	e9 09 01 00 00	 jmp	 $LN5@LevelUp
$LN6@LevelUp:

; 1920 : 	{
; 1921 : 		iLEFT_EXP = gObj[iIndex].Experience + iAddExp - gObj[iIndex].NextExp;

  000e7	2b c1		 sub	 eax, ecx
  000e9	8d 1c 07	 lea	 ebx, DWORD PTR [edi+eax]

; 1922 : 		gObj[iIndex].Experience = gObj[iIndex].NextExp;
; 1923 : 		gObj[iIndex].Level++;
; 1924 : 
; 1925 : 		if ( gObj[iIndex].Class == CLASS_DARKLORD || gObj[iIndex].Class == CLASS_MAGUMSA )

  000ec	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152]
  000f3	42		 inc	 edx
  000f4	89 8e a8 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+168], ecx
  000fa	66 89 96 9c 00
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156], dx
  00101	83 f8 04	 cmp	 eax, 4
  00104	74 0e		 je	 SHORT $LN3@LevelUp
  00106	83 f8 03	 cmp	 eax, 3
  00109	74 09		 je	 SHORT $LN3@LevelUp

; 1928 : 		}
; 1929 : 		else
; 1930 : 		{
; 1931 : 			gObj[iIndex].LevelUpPoint += 5;

  0010b	83 86 a0 00 00
	00 05		 add	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+160], 5
  00112	eb 07		 jmp	 SHORT $LN2@LevelUp
$LN3@LevelUp:

; 1926 : 		{
; 1927 : 			gObj[iIndex].LevelUpPoint += 7;

  00114	83 86 a0 00 00
	00 07		 add	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+160], 7
$LN2@LevelUp:

; 1932 : 		}
; 1933 : 
; 1934 : 		if ( gObj[iIndex].PlusStatQuestClear != false )

  0011b	80 be 88 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+136], 0
  00122	74 2a		 je	 SHORT $LN14@LevelUp

; 1935 : 		{
; 1936 : 			gObj[iIndex].LevelUpPoint++;

  00124	ff 86 a0 00 00
	00		 inc	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+160]
  0012a	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+160]

; 1937 : 
; 1938 : 			LogAdd(LOG_BLACK, "[%s][%s] LevelUp PlusStatQuest Clear AddStat %d",
; 1939 : 				gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].LevelUpPoint);

  00130	50		 push	 eax
  00131	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00137	50		 push	 eax
  00138	8d 86 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  0013e	50		 push	 eax
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
  00144	6a 00		 push	 0
  00146	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0014b	83 c4 14	 add	 esp, 20			; 00000014H
$LN14@LevelUp:

; 1940 : 		}
; 1941 : 
; 1942 : 		gObj[iIndex].MaxLife += DCInfo.DefClass[gObj[iIndex].Class].LevelLife;

  0014e	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152]
  00155	69 c0 60 09 00
	00		 imul	 eax, 2400		; 00000960H

; 1943 : 		gObj[iIndex].MaxMana += DCInfo.DefClass[gObj[iIndex].Class].LevelMana;
; 1944 : 
; 1945 : 		gObj[iIndex].Life = gObj[iIndex].MaxLife;
; 1946 : 		gObj[iIndex].Mana = gObj[iIndex].MaxMana;
; 1947 : 
; 1948 : 		gObjNextExpCal(&gObj[iIndex]);

  0015b	8d be 00 00 00
	00		 lea	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  00161	57		 push	 edi
  00162	d9 80 10 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  00168	d8 86 c0 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]
  0016e	d9 5d 08	 fstp	 DWORD PTR tv443[ebp]
  00171	d9 45 08	 fld	 DWORD PTR tv443[ebp]
  00174	d9 96 c0 00 00
	00		 fst	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+192]
  0017a	d9 80 1c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  00180	d8 86 d4 00 00
	00		 fadd	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  00186	d9 5d 08	 fstp	 DWORD PTR tv453[ebp]
  00189	d9 45 08	 fld	 DWORD PTR tv453[ebp]
  0018c	d9 96 d4 00 00
	00		 fst	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+212]
  00192	d9 9e d0 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+208]
  00198	d9 9e bc 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+188]
  0019e	e8 00 00 00 00	 call	 ?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNextExpCal

; 1949 : 		gObjSetBP(gObj[iIndex].m_Index);

  001a3	8b 17		 mov	 edx, DWORD PTR [edi]
  001a5	52		 push	 edx
  001a6	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 1950 : 
; 1951 : 		GCLevelUpMsgSend(gObj[iIndex].m_Index, 1);

  001ab	8b 07		 mov	 eax, DWORD PTR [edi]
  001ad	6a 01		 push	 1
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 ?GCLevelUpMsgSend@@YAXHH@Z ; GCLevelUpMsgSend

; 1952 : 
; 1953 : 		gObjCalcMaxLifePower(gObj[iIndex].m_Index);

  001b5	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001b7	51		 push	 ecx
  001b8	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower

; 1954 : 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2, 8)), gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].Level);

  001bd	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+156]
  001c4	83 c4 14	 add	 esp, 20			; 00000014H
  001c7	52		 push	 edx
  001c8	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  001ce	50		 push	 eax
  001cf	8d 86 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  001d5	50		 push	 eax
  001d6	68 08 02 00 00	 push	 520			; 00000208H
  001db	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001e0	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001e5	50		 push	 eax
  001e6	6a 00		 push	 0
  001e8	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001ed	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@LevelUp:

; 1955 : 	}
; 1956 : 
; 1957 : 	GJSetCharacterInfo(&gObj[iIndex], gObj[iIndex].m_Index, 0);

  001f0	8b 86 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  001f6	8d b6 00 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  001fc	6a 00		 push	 0
  001fe	50		 push	 eax
  001ff	56		 push	 esi
  00200	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  00205	83 c4 0c	 add	 esp, 12			; 0000000cH
  00208	5f		 pop	 edi
  00209	5e		 pop	 esi

; 1958 : 	
; 1959 : 	return iLEFT_EXP;

  0020a	8b c3		 mov	 eax, ebx
  0020c	5b		 pop	 ebx

; 1960 : }

  0020d	8b e5		 mov	 esp, ebp
  0020f	5d		 pop	 ebp
  00210	c2 0c 00	 ret	 12			; 0000000cH
?LevelUp@CBloodCastle@@QAEHHHH@Z ENDP			; CBloodCastle::LevelUp
_TEXT	ENDS
PUBLIC	?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z	; CBloodCastle::CheckUsersOnConnect
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
; Function compile flags: /Ogtp
;	COMDAT ?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv197 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::CheckUsersOnConnect, COMDAT
; _this$ = ecx

; 1967 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1968 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	78 6c		 js	 SHORT $LN9@CheckUsers
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fb 06	 cmp	 ebx, 6
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	74 60		 je	 SHORT $LN9@CheckUsers

; 1969 : 	{
; 1970 : 		return;
; 1971 : 	}
; 1972 : 
; 1973 : 	::EnterCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00017	56		 push	 esi
  00018	8b f3		 mov	 esi, ebx
  0001a	c1 e6 09	 shl	 esi, 9
  0001d	03 f1		 add	 esi, ecx
  0001f	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	89 45 08	 mov	 DWORD PTR tv197[ebp], eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0002d	83 c6 1c	 add	 esi, 28			; 0000001cH
  00030	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
$LL7@CheckUsers:

; 1976 : 	{
; 1977 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00035	8b 06		 mov	 eax, DWORD PTR [esi]
  00037	83 f8 ff	 cmp	 eax, -1
  0003a	74 29		 je	 SHORT $LN6@CheckUsers

; 1978 : 		{
; 1979 : 			if ( gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex) == FALSE )

  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00042	83 c4 04	 add	 esp, 4
  00045	85 c0		 test	 eax, eax

; 1980 : 			{
; 1981 : 				this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;
; 1982 : 			}
; 1983 : 			else

  00047	74 16		 je	 SHORT $LN15@CheckUsers

; 1984 : 			{
; 1985 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber != (iBridgeIndex + MAP_INDEX_BLOODCASTLE1) )

  00049	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004b	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00051	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  00058	8d 43 0b	 lea	 eax, DWORD PTR [ebx+11]
  0005b	3b d0		 cmp	 edx, eax
  0005d	74 06		 je	 SHORT $LN6@CheckUsers
$LN15@CheckUsers:

; 1986 : 				{
; 1987 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  0005f	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN6@CheckUsers:

; 1974 : 
; 1975 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00065	83 c6 14	 add	 esi, 20			; 00000014H
  00068	4f		 dec	 edi
  00069	75 ca		 jne	 SHORT $LL7@CheckUsers

; 1988 : 				}
; 1989 : 			}
; 1990 : 		}
; 1991 : 	}
; 1992 : 
; 1993 : 	::LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR tv197[ebp]
  0006e	51		 push	 ecx
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
$LN9@CheckUsers:
  00077	5b		 pop	 ebx

; 1994 : 
; 1995 : }

  00078	5d		 pop	 ebp
  00079	c2 04 00	 ret	 4
?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::CheckUsersOnConnect
_TEXT	ENDS
PUBLIC	?AddExperience@CBloodCastle@@QAE_NHH@Z		; CBloodCastle::AddExperience
; Function compile flags: /Ogtp
;	COMDAT ?AddExperience@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iEXP$ = 12						; size = 4
?AddExperience@CBloodCastle@@QAE_NHH@Z PROC		; CBloodCastle::AddExperience, COMDAT
; _this$ = ecx

; 2004 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2005 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	85 c0		 test	 eax, eax
  0000b	78 0e		 js	 SHORT $LN13@AddExperie
  0000d	33 c9		 xor	 ecx, ecx
  0000f	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00014	0f 9e c1	 setle	 cl
  00017	85 c9		 test	 ecx, ecx
  00019	75 07		 jne	 SHORT $LN4@AddExperie
$LN13@AddExperie:

; 2006 : 	{
; 2007 : 		return false;

  0001b	32 c0		 xor	 al, al
  0001d	5f		 pop	 edi

; 2027 : }

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
$LN4@AddExperie:

; 2008 : 	}
; 2009 : 
; 2010 : 	if ( BC_BRIDGE_RANGE(gObj[iIndex].m_cBloodCastleIndex) == FALSE )

  00022	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00028	8a 88 02 0d 00
	00		 mov	 cl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330]
  0002e	84 c9		 test	 cl, cl
  00030	78 e9		 js	 SHORT $LN13@AddExperie
  00032	33 d2		 xor	 edx, edx
  00034	80 f9 06	 cmp	 cl, 6
  00037	0f 9e c2	 setle	 dl
  0003a	85 d2		 test	 edx, edx

; 2011 : 	{
; 2012 : 		return false;

  0003c	74 dd		 je	 SHORT $LN13@AddExperie

; 2013 : 	}
; 2014 : 
; 2015 : 	if ( BC_SUB_BRIDGE_RANGE(gObj[iIndex].m_cBloodCastleSubIndex) == FALSE )

  0003e	8a 90 03 0d 00
	00		 mov	 dl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3331]
  00044	56		 push	 esi
  00045	84 d2		 test	 dl, dl
  00047	78 10		 js	 SHORT $LN15@AddExperie
  00049	53		 push	 ebx
  0004a	33 db		 xor	 ebx, ebx
  0004c	80 fa 09	 cmp	 dl, 9
  0004f	0f 9e c3	 setle	 bl
  00052	8b f3		 mov	 esi, ebx
  00054	5b		 pop	 ebx
  00055	85 f6		 test	 esi, esi
  00057	75 08		 jne	 SHORT $LN2@AddExperie
$LN15@AddExperie:
  00059	5e		 pop	 esi

; 2016 : 	{
; 2017 : 		return false;

  0005a	32 c0		 xor	 al, al
  0005c	5f		 pop	 edi

; 2027 : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
$LN2@AddExperie:

; 2018 : 	}
; 2019 : 
; 2020 : 	if ( iEXP > 0 )

  00061	8b 75 0c	 mov	 esi, DWORD PTR _iEXP$[ebp]
  00064	85 f6		 test	 esi, esi
  00066	7e 1c		 jle	 SHORT $LN1@AddExperie

; 2021 : 	{
; 2022 : 		this->m_BridgeData[gObj[iIndex].m_cBloodCastleIndex].m_UserData[gObj[iIndex].m_cBloodCastleSubIndex].m_iEXP += iEXP;

  00068	0f be c9	 movsx	 ecx, cl
  0006b	c1 e1 09	 shl	 ecx, 9
  0006e	0f be d2	 movsx	 edx, dl
  00071	03 cf		 add	 ecx, edi
  00073	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  00076	01 74 91 20	 add	 DWORD PTR [ecx+edx*4+32], esi

; 2023 : 		gObj[iIndex].m_iBloodCastleEXP += iEXP;

  0007a	01 b0 04 0d 00
	00		 add	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3332], esi
  00080	8d 4c 91 20	 lea	 ecx, DWORD PTR [ecx+edx*4+32]
$LN1@AddExperie:

; 2024 : 	}
; 2025 : 
; 2026 : 	return true;

  00084	5e		 pop	 esi
  00085	b0 01		 mov	 al, 1
  00087	5f		 pop	 edi

; 2027 : }

  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
?AddExperience@CBloodCastle@@QAE_NHH@Z ENDP		; CBloodCastle::AddExperience
_TEXT	ENDS
PUBLIC	?BlockCastleEntrance@CBloodCastle@@QAEXH@Z	; CBloodCastle::BlockCastleEntrance
; Function compile flags: /Ogtp
;	COMDAT ?BlockCastleEntrance@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?BlockCastleEntrance@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleEntrance, COMDAT
; _this$ = ecx

; 2034 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2035 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	78 7f		 js	 SHORT $LN4@BlockCastl
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fb 06	 cmp	 ebx, 6
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	74 73		 je	 SHORT $LN4@BlockCastl

; 2036 : 	{
; 2037 : 		return;
; 2038 : 	}
; 2039 : 
; 2040 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  00017	0f b6 04 9d 02
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+2]
  0001f	57		 push	 edi
  00020	0f b6 3c 9d 00
	00 00 00	 movzx	 edi, BYTE PTR _g_btCastleEntranceMapXY[ebx*4]
  00028	3b f8		 cmp	 edi, eax
  0002a	7f 5d		 jg	 SHORT $LN16@BlockCastl
  0002c	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+3]
  00034	56		 push	 esi
  00035	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL6@BlockCastl:

; 2041 : 	{
; 2042 : 		for ( int j= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;j++)

  00040	0f b6 14 9d 01
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+1]
  00048	3b d0		 cmp	 edx, eax
  0004a	7f 2f		 jg	 SHORT $LN5@BlockCastl
  0004c	8b cb		 mov	 ecx, ebx
  0004e	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00054	8d b1 68 4d 37
	00		 lea	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+3624296]
  0005a	8b ca		 mov	 ecx, edx
  0005c	c1 e1 08	 shl	 ecx, 8
  0005f	90		 npad	 1
$LL3@BlockCastl:

; 2043 : 		{
; 2044 : 			MapC[iBridgeIndex + MAP_INDEX_BLOODCASTLE1].m_attrbuf[j * 256 + i] |= 4;

  00060	8b 06		 mov	 eax, DWORD PTR [esi]
  00062	03 c1		 add	 eax, ecx
  00064	80 0c 38 04	 or	 BYTE PTR [eax+edi], 4
  00068	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+3]
  00070	42		 inc	 edx
  00071	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00077	3b d0		 cmp	 edx, eax
  00079	7e e5		 jle	 SHORT $LL3@BlockCastl
$LN5@BlockCastl:

; 2036 : 	{
; 2037 : 		return;
; 2038 : 	}
; 2039 : 
; 2040 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  0007b	0f b6 0c 9d 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+2]
  00083	47		 inc	 edi
  00084	3b f9		 cmp	 edi, ecx
  00086	7e b8		 jle	 SHORT $LL6@BlockCastl
  00088	5e		 pop	 esi
$LN16@BlockCastl:
  00089	5f		 pop	 edi
$LN4@BlockCastl:
  0008a	5b		 pop	 ebx

; 2045 : 		}
; 2046 : 	}
; 2047 : }

  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
?BlockCastleEntrance@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleEntrance
_TEXT	ENDS
PUBLIC	?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleEntrance
; Function compile flags: /Ogtp
;	COMDAT ?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::ReleaseCastleEntrance, COMDAT
; _this$ = ecx

; 2055 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2056 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	78 7f		 js	 SHORT $LN4@ReleaseCas
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fb 06	 cmp	 ebx, 6
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	74 73		 je	 SHORT $LN4@ReleaseCas

; 2057 : 	{
; 2058 : 		return;
; 2059 : 	}
; 2060 : 
; 2061 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  00017	0f b6 04 9d 02
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+2]
  0001f	57		 push	 edi
  00020	0f b6 3c 9d 00
	00 00 00	 movzx	 edi, BYTE PTR _g_btCastleEntranceMapXY[ebx*4]
  00028	3b f8		 cmp	 edi, eax
  0002a	7f 5d		 jg	 SHORT $LN16@ReleaseCas
  0002c	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+3]
  00034	56		 push	 esi
  00035	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL6@ReleaseCas:

; 2062 : 	{
; 2063 : 		for ( int j= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;j++)

  00040	0f b6 14 9d 01
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+1]
  00048	3b d0		 cmp	 edx, eax
  0004a	7f 2f		 jg	 SHORT $LN5@ReleaseCas
  0004c	8b cb		 mov	 ecx, ebx
  0004e	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00054	8d b1 68 4d 37
	00		 lea	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+3624296]
  0005a	8b ca		 mov	 ecx, edx
  0005c	c1 e1 08	 shl	 ecx, 8
  0005f	90		 npad	 1
$LL3@ReleaseCas:

; 2064 : 		{
; 2065 : 			MapC[iBridgeIndex + MAP_INDEX_BLOODCASTLE1].m_attrbuf[j * 256 + i] &= ~4;

  00060	8b 06		 mov	 eax, DWORD PTR [esi]
  00062	03 c1		 add	 eax, ecx
  00064	80 24 38 fb	 and	 BYTE PTR [eax+edi], 251	; 000000fbH
  00068	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+3]
  00070	42		 inc	 edx
  00071	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00077	3b d0		 cmp	 edx, eax
  00079	7e e5		 jle	 SHORT $LL3@ReleaseCas
$LN5@ReleaseCas:

; 2057 : 	{
; 2058 : 		return;
; 2059 : 	}
; 2060 : 
; 2061 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  0007b	0f b6 0c 9d 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+2]
  00083	47		 inc	 edi
  00084	3b f9		 cmp	 edi, ecx
  00086	7e b8		 jle	 SHORT $LL6@ReleaseCas
  00088	5e		 pop	 esi
$LN16@ReleaseCas:
  00089	5f		 pop	 edi
$LN4@ReleaseCas:
  0008a	5b		 pop	 ebx

; 2066 : 		}
; 2067 : 	}
; 2068 : }

  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::ReleaseCastleEntrance
_TEXT	ENDS
PUBLIC	?BlockCastleBridge@CBloodCastle@@QAEXH@Z	; CBloodCastle::BlockCastleBridge
; Function compile flags: /Ogtp
;	COMDAT ?BlockCastleBridge@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?BlockCastleBridge@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleBridge, COMDAT
; _this$ = ecx

; 2077 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2078 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	78 7f		 js	 SHORT $LN4@BlockCastl@2
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fb 06	 cmp	 ebx, 6
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	74 73		 je	 SHORT $LN4@BlockCastl@2

; 2079 : 	{
; 2080 : 		return;
; 2081 : 	}
; 2082 : 
; 2083 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  00017	0f b6 04 9d 02
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+2]
  0001f	57		 push	 edi
  00020	0f b6 3c 9d 00
	00 00 00	 movzx	 edi, BYTE PTR _g_btCastleBridgeMapXY[ebx*4]
  00028	3b f8		 cmp	 edi, eax
  0002a	7f 5d		 jg	 SHORT $LN16@BlockCastl@2
  0002c	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+3]
  00034	56		 push	 esi
  00035	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL6@BlockCastl@2:

; 2084 : 	{
; 2085 : 		for ( int j= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndY;j++)

  00040	0f b6 14 9d 01
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+1]
  00048	3b d0		 cmp	 edx, eax
  0004a	7f 2f		 jg	 SHORT $LN5@BlockCastl@2
  0004c	8b cb		 mov	 ecx, ebx
  0004e	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00054	8d b1 68 4d 37
	00		 lea	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+3624296]
  0005a	8b ca		 mov	 ecx, edx
  0005c	c1 e1 08	 shl	 ecx, 8
  0005f	90		 npad	 1
$LL3@BlockCastl@2:

; 2086 : 		{
; 2087 : 			MapC[iBridgeIndex + MAP_INDEX_BLOODCASTLE1].m_attrbuf[j * 256 + i] |= 8;

  00060	8b 06		 mov	 eax, DWORD PTR [esi]
  00062	03 c1		 add	 eax, ecx
  00064	80 0c 38 08	 or	 BYTE PTR [eax+edi], 8
  00068	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+3]
  00070	42		 inc	 edx
  00071	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00077	3b d0		 cmp	 edx, eax
  00079	7e e5		 jle	 SHORT $LL3@BlockCastl@2
$LN5@BlockCastl@2:

; 2079 : 	{
; 2080 : 		return;
; 2081 : 	}
; 2082 : 
; 2083 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  0007b	0f b6 0c 9d 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+2]
  00083	47		 inc	 edi
  00084	3b f9		 cmp	 edi, ecx
  00086	7e b8		 jle	 SHORT $LL6@BlockCastl@2
  00088	5e		 pop	 esi
$LN16@BlockCastl@2:
  00089	5f		 pop	 edi
$LN4@BlockCastl@2:
  0008a	5b		 pop	 ebx

; 2088 : 		}
; 2089 : 	}
; 2090 : }

  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
?BlockCastleBridge@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleBridge
_TEXT	ENDS
PUBLIC	??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@ ; `string'
PUBLIC	?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleBridge
;	COMDAT ??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@
CONST	SEGMENT
??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@ DB '['
	DB	'Blood Castle][Bug Tracer] ReleaseCastleBridge-> %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_i$157946 = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::ReleaseCastleBridge, COMDAT
; _this$ = ecx

; 2096 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2097 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 c9		 test	 ecx, ecx
  00009	0f 88 98 00 00
	00		 js	 $LN4@ReleaseCas@2
  0000f	33 c0		 xor	 eax, eax
  00011	83 f9 06	 cmp	 ecx, 6
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	0f 84 88 00 00
	00		 je	 $LN4@ReleaseCas@2

; 2098 : 	{
; 2099 : 		return;
; 2100 : 	}
; 2101 : 
; 2102 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  0001f	0f b6 14 8d 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleBridgeMapXY[ecx*4]
  00027	0f b6 04 8d 02
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleBridgeMapXY[ecx*4+2]
  0002f	89 55 fc	 mov	 DWORD PTR _i$157946[ebp], edx
  00032	3b d0		 cmp	 edx, eax
  00034	7f 71		 jg	 SHORT $LN4@ReleaseCas@2
  00036	0f b6 04 8d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleBridgeMapXY[ecx*4+3]
  0003e	53		 push	 ebx
  0003f	56		 push	 esi
  00040	57		 push	 edi
$LL6@ReleaseCas@2:

; 2103 : 	{
; 2104 : 		for ( int j= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndY;j++)

  00041	0f b6 3c 8d 01
	00 00 00	 movzx	 edi, BYTE PTR _g_btCastleBridgeMapXY[ecx*4+1]
  00049	3b f8		 cmp	 edi, eax
  0004b	7f 47		 jg	 SHORT $LN5@ReleaseCas@2
  0004d	8b c1		 mov	 eax, ecx
  0004f	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  00055	8b f7		 mov	 esi, edi
  00057	8d 98 68 4d 37
	00		 lea	 ebx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+3624296]
  0005d	c1 e6 08	 shl	 esi, 8
$LL16@ReleaseCas@2:

; 2105 : 		{
; 2106 : 			MapC[iBridgeIndex + MAP_INDEX_BLOODCASTLE1].m_attrbuf[j * 256 + i] &= ~8;

  00060	8b 03		 mov	 eax, DWORD PTR [ebx]
  00062	03 c6		 add	 eax, esi
  00064	80 24 10 f7	 and	 BYTE PTR [eax+edx], 247	; 000000f7H

; 2107 : 
; 2108 : 			LogAdd(LOG_BLACK, "[Blood Castle][Bug Tracer] ReleaseCastleBridge-> %d", iBridgeIndex+1);

  00068	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0006b	50		 push	 eax
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@
  00071	6a 00		 push	 0
  00073	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00078	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0007b	0f b6 04 8d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleBridgeMapXY[ecx*4+3]
  00083	8b 55 fc	 mov	 edx, DWORD PTR _i$157946[ebp]
  00086	47		 inc	 edi
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	81 c6 00 01 00
	00		 add	 esi, 256		; 00000100H
  00090	3b f8		 cmp	 edi, eax
  00092	7e cc		 jle	 SHORT $LL16@ReleaseCas@2
$LN5@ReleaseCas@2:

; 2098 : 	{
; 2099 : 		return;
; 2100 : 	}
; 2101 : 
; 2102 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  00094	0f b6 34 8d 02
	00 00 00	 movzx	 esi, BYTE PTR _g_btCastleBridgeMapXY[ecx*4+2]
  0009c	42		 inc	 edx
  0009d	89 55 fc	 mov	 DWORD PTR _i$157946[ebp], edx
  000a0	3b d6		 cmp	 edx, esi
  000a2	7e 9d		 jle	 SHORT $LL6@ReleaseCas@2
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
$LN4@ReleaseCas@2:

; 2109 : 		}
; 2110 : 	}
; 2111 : }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::ReleaseCastleBridge
_TEXT	ENDS
PUBLIC	?BlockCastleDoor@CBloodCastle@@QAEXH@Z		; CBloodCastle::BlockCastleDoor
; Function compile flags: /Ogtp
;	COMDAT ?BlockCastleDoor@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv425 = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?BlockCastleDoor@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleDoor, COMDAT
; _this$ = ecx

; 2118 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2119 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 c9		 test	 ecx, ecx
  00009	0f 88 7e 00 00
	00		 js	 $LN7@BlockCastl@3
  0000f	33 c0		 xor	 eax, eax
  00011	83 f9 06	 cmp	 ecx, 6
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	74 72		 je	 SHORT $LN7@BlockCastl@3

; 2120 : 	{
; 2121 : 		return;
; 2122 : 	}
; 2123 : 
; 2124 : 	for ( int x=0;x<3;x++)

  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	8d 34 49	 lea	 esi, DWORD PTR [ecx+ecx*2]
  00020	57		 push	 edi
  00021	8d 34 b5 03 00
	00 00		 lea	 esi, DWORD PTR _g_btCastleDoorMapXY[esi*4+3]
  00028	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR tv425[ebp], 3
  0002f	90		 npad	 1
$LL9@BlockCastl@3:

; 2125 : 	{
; 2126 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  00030	0f b6 7e fd	 movzx	 edi, BYTE PTR [esi-3]
  00034	0f b6 46 ff	 movzx	 eax, BYTE PTR [esi-1]
  00038	3b f8		 cmp	 edi, eax
  0003a	7f 46		 jg	 SHORT $LN8@BlockCastl@3
  0003c	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0003f	90		 npad	 1
$LL6@BlockCastl@3:

; 2127 : 		{
; 2128 : 			for ( int z = ::g_btCastleDoorMapXY[iBridgeIndex][x].btStartY; z <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndY ; z++)

  00040	0f b6 56 fe	 movzx	 edx, BYTE PTR [esi-2]
  00044	3b d0		 cmp	 edx, eax
  00046	7f 31		 jg	 SHORT $LN5@BlockCastl@3
  00048	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  0004e	8d 99 68 4d 37
	00		 lea	 ebx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+3624296]
  00054	8b ca		 mov	 ecx, edx
  00056	c1 e1 08	 shl	 ecx, 8
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL3@BlockCastl@3:

; 2129 : 			{
; 2130 : 				MapC[iBridgeIndex + MAP_INDEX_BLOODCASTLE1].m_attrbuf[z * 256 + y] |= 4;

  00060	8b 03		 mov	 eax, DWORD PTR [ebx]
  00062	03 c1		 add	 eax, ecx
  00064	80 0c 38 04	 or	 BYTE PTR [eax+edi], 4
  00068	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0006b	42		 inc	 edx
  0006c	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00072	3b d0		 cmp	 edx, eax
  00074	7e ea		 jle	 SHORT $LL3@BlockCastl@3

; 2127 : 		{
; 2128 : 			for ( int z = ::g_btCastleDoorMapXY[iBridgeIndex][x].btStartY; z <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndY ; z++)

  00076	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
$LN5@BlockCastl@3:

; 2125 : 	{
; 2126 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  00079	0f b6 56 ff	 movzx	 edx, BYTE PTR [esi-1]
  0007d	47		 inc	 edi
  0007e	3b fa		 cmp	 edi, edx
  00080	7e be		 jle	 SHORT $LL6@BlockCastl@3
$LN8@BlockCastl@3:

; 2120 : 	{
; 2121 : 		return;
; 2122 : 	}
; 2123 : 
; 2124 : 	for ( int x=0;x<3;x++)

  00082	83 c6 04	 add	 esi, 4
  00085	ff 4d fc	 dec	 DWORD PTR tv425[ebp]
  00088	75 a6		 jne	 SHORT $LL9@BlockCastl@3
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
$LN7@BlockCastl@3:

; 2131 : 			}
; 2132 : 		}
; 2133 : 	}
; 2134 : }

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 04 00	 ret	 4
?BlockCastleDoor@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleDoor
_TEXT	ENDS
PUBLIC	?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleDoor
; Function compile flags: /Ogtp
;	COMDAT ?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv425 = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::ReleaseCastleDoor, COMDAT
; _this$ = ecx

; 2142 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2143 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 c9		 test	 ecx, ecx
  00009	0f 88 7e 00 00
	00		 js	 $LN7@ReleaseCas@3
  0000f	33 c0		 xor	 eax, eax
  00011	83 f9 06	 cmp	 ecx, 6
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	74 72		 je	 SHORT $LN7@ReleaseCas@3

; 2144 : 	{
; 2145 : 		return;
; 2146 : 	}
; 2147 : 
; 2148 : 	for ( int x=0;x<3;x++)

  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	8d 34 49	 lea	 esi, DWORD PTR [ecx+ecx*2]
  00020	57		 push	 edi
  00021	8d 34 b5 03 00
	00 00		 lea	 esi, DWORD PTR _g_btCastleDoorMapXY[esi*4+3]
  00028	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR tv425[ebp], 3
  0002f	90		 npad	 1
$LL9@ReleaseCas@3:

; 2149 : 	{
; 2150 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  00030	0f b6 7e fd	 movzx	 edi, BYTE PTR [esi-3]
  00034	0f b6 46 ff	 movzx	 eax, BYTE PTR [esi-1]
  00038	3b f8		 cmp	 edi, eax
  0003a	7f 46		 jg	 SHORT $LN8@ReleaseCas@3
  0003c	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0003f	90		 npad	 1
$LL6@ReleaseCas@3:

; 2151 : 		{
; 2152 : 			for ( int z = ::g_btCastleDoorMapXY[iBridgeIndex][x].btStartY; z <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndY ; z++)

  00040	0f b6 56 fe	 movzx	 edx, BYTE PTR [esi-2]
  00044	3b d0		 cmp	 edx, eax
  00046	7f 31		 jg	 SHORT $LN5@ReleaseCas@3
  00048	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  0004e	8d 99 68 4d 37
	00		 lea	 ebx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+3624296]
  00054	8b ca		 mov	 ecx, edx
  00056	c1 e1 08	 shl	 ecx, 8
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL3@ReleaseCas@3:

; 2153 : 			{
; 2154 : 				MapC[iBridgeIndex + MAP_INDEX_BLOODCASTLE1].m_attrbuf[z * 256 + y] &= ~4;

  00060	8b 03		 mov	 eax, DWORD PTR [ebx]
  00062	03 c1		 add	 eax, ecx
  00064	80 24 38 fb	 and	 BYTE PTR [eax+edi], 251	; 000000fbH
  00068	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0006b	42		 inc	 edx
  0006c	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00072	3b d0		 cmp	 edx, eax
  00074	7e ea		 jle	 SHORT $LL3@ReleaseCas@3

; 2151 : 		{
; 2152 : 			for ( int z = ::g_btCastleDoorMapXY[iBridgeIndex][x].btStartY; z <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndY ; z++)

  00076	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
$LN5@ReleaseCas@3:

; 2149 : 	{
; 2150 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  00079	0f b6 56 ff	 movzx	 edx, BYTE PTR [esi-1]
  0007d	47		 inc	 edi
  0007e	3b fa		 cmp	 edi, edx
  00080	7e be		 jle	 SHORT $LL6@ReleaseCas@3
$LN8@ReleaseCas@3:

; 2144 : 	{
; 2145 : 		return;
; 2146 : 	}
; 2147 : 
; 2148 : 	for ( int x=0;x<3;x++)

  00082	83 c6 04	 add	 esi, 4
  00085	ff 4d fc	 dec	 DWORD PTR tv425[ebp]
  00088	75 a6		 jne	 SHORT $LL9@ReleaseCas@3
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
$LN7@ReleaseCas@3:

; 2155 : 			}
; 2156 : 		}
; 2157 : 	}
; 2158 : }

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 04 00	 ret	 4
?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::ReleaseCastleDoor
_TEXT	ENDS
PUBLIC	?BlockSector@CBloodCastle@@IAEXHHHHH@Z		; CBloodCastle::BlockSector
; Function compile flags: /Ogtp
;	COMDAT ?BlockSector@CBloodCastle@@IAEXHHHHH@Z
_TEXT	SEGMENT
_iMAP_NUM$ = 8						; size = 4
_iSTART_X$ = 12						; size = 4
_iSTART_Y$ = 16						; size = 4
_iEND_X$ = 20						; size = 4
_iEND_Y$ = 24						; size = 4
?BlockSector@CBloodCastle@@IAEXHHHHH@Z PROC		; CBloodCastle::BlockSector, COMDAT
; _this$ = ecx

; 2166 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2167 : 	if ( BC_MAP_RANGE(iMAP_NUM) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
  00006	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00009	7c 51		 jl	 SHORT $LN4@BlockSecto
  0000b	33 c9		 xor	 ecx, ecx
  0000d	83 f8 11	 cmp	 eax, 17			; 00000011H
  00010	0f 9e c1	 setle	 cl
  00013	85 c9		 test	 ecx, ecx
  00015	74 45		 je	 SHORT $LN4@BlockSecto

; 2168 : 	{
; 2169 : 		return;
; 2170 : 	}
; 2171 : 
; 2172 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _iSTART_X$[ebp]
  0001b	3b 7d 14	 cmp	 edi, DWORD PTR _iEND_X$[ebp]
  0001e	7f 3b		 jg	 SHORT $LN16@BlockSecto
  00020	53		 push	 ebx
  00021	8b 5d 10	 mov	 ebx, DWORD PTR _iSTART_Y$[ebp]
  00024	56		 push	 esi
$LL6@BlockSecto:

; 2173 : 	{
; 2174 : 		for ( int j=iSTART_Y;j<=iEND_Y;j++ )

  00025	8b 55 18	 mov	 edx, DWORD PTR _iEND_Y$[ebp]
  00028	3b da		 cmp	 ebx, edx
  0002a	7f 27		 jg	 SHORT $LN5@BlockSecto
  0002c	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  00032	8d b0 10 00 00
	00		 lea	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00038	8b c3		 mov	 eax, ebx
  0003a	2b d3		 sub	 edx, ebx
  0003c	c1 e0 08	 shl	 eax, 8
  0003f	42		 inc	 edx
$LL3@BlockSecto:

; 2175 : 		{
; 2176 : 			MapC[iMAP_NUM].m_attrbuf[j * 256 + i] |= 4;

  00040	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00042	03 c8		 add	 ecx, eax
  00044	80 0c 39 04	 or	 BYTE PTR [ecx+edi], 4
  00048	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0004d	4a		 dec	 edx
  0004e	75 f0		 jne	 SHORT $LL3@BlockSecto

; 2173 : 	{
; 2174 : 		for ( int j=iSTART_Y;j<=iEND_Y;j++ )

  00050	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
$LN5@BlockSecto:

; 2168 : 	{
; 2169 : 		return;
; 2170 : 	}
; 2171 : 
; 2172 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  00053	47		 inc	 edi
  00054	3b 7d 14	 cmp	 edi, DWORD PTR _iEND_X$[ebp]
  00057	7e cc		 jle	 SHORT $LL6@BlockSecto
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
$LN16@BlockSecto:
  0005b	5f		 pop	 edi
$LN4@BlockSecto:

; 2177 : 		}
; 2178 : 	}
; 2179 : }

  0005c	5d		 pop	 ebp
  0005d	c2 14 00	 ret	 20			; 00000014H
?BlockSector@CBloodCastle@@IAEXHHHHH@Z ENDP		; CBloodCastle::BlockSector
_TEXT	ENDS
PUBLIC	?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z	; CBloodCastle::ReleaseSector
; Function compile flags: /Ogtp
;	COMDAT ?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z
_TEXT	SEGMENT
_iMAP_NUM$ = 8						; size = 4
_iSTART_X$ = 12						; size = 4
_iSTART_Y$ = 16						; size = 4
_iEND_X$ = 20						; size = 4
_iEND_Y$ = 24						; size = 4
?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z PROC		; CBloodCastle::ReleaseSector, COMDAT
; _this$ = ecx

; 2186 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2187 : 
; 2188 : 	if ( BC_MAP_RANGE(iMAP_NUM) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
  00006	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00009	7c 51		 jl	 SHORT $LN4@ReleaseSec
  0000b	33 c9		 xor	 ecx, ecx
  0000d	83 f8 11	 cmp	 eax, 17			; 00000011H
  00010	0f 9e c1	 setle	 cl
  00013	85 c9		 test	 ecx, ecx
  00015	74 45		 je	 SHORT $LN4@ReleaseSec

; 2189 : 	{
; 2190 : 		return;
; 2191 : 	}
; 2192 : 
; 2193 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _iSTART_X$[ebp]
  0001b	3b 7d 14	 cmp	 edi, DWORD PTR _iEND_X$[ebp]
  0001e	7f 3b		 jg	 SHORT $LN16@ReleaseSec
  00020	53		 push	 ebx
  00021	8b 5d 10	 mov	 ebx, DWORD PTR _iSTART_Y$[ebp]
  00024	56		 push	 esi
$LL6@ReleaseSec:

; 2194 : 	{
; 2195 : 		for ( int j=iSTART_Y;j<=iEND_Y;j++ )

  00025	8b 55 18	 mov	 edx, DWORD PTR _iEND_Y$[ebp]
  00028	3b da		 cmp	 ebx, edx
  0002a	7f 27		 jg	 SHORT $LN5@ReleaseSec
  0002c	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  00032	8d b0 10 00 00
	00		 lea	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00038	8b c3		 mov	 eax, ebx
  0003a	2b d3		 sub	 edx, ebx
  0003c	c1 e0 08	 shl	 eax, 8
  0003f	42		 inc	 edx
$LL3@ReleaseSec:

; 2196 : 		{
; 2197 : 			MapC[iMAP_NUM].m_attrbuf[j * 256 + i] &= ~4;

  00040	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00042	03 c8		 add	 ecx, eax
  00044	80 24 39 fb	 and	 BYTE PTR [ecx+edi], 251	; 000000fbH
  00048	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0004d	4a		 dec	 edx
  0004e	75 f0		 jne	 SHORT $LL3@ReleaseSec

; 2194 : 	{
; 2195 : 		for ( int j=iSTART_Y;j<=iEND_Y;j++ )

  00050	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
$LN5@ReleaseSec:

; 2189 : 	{
; 2190 : 		return;
; 2191 : 	}
; 2192 : 
; 2193 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  00053	47		 inc	 edi
  00054	3b 7d 14	 cmp	 edi, DWORD PTR _iEND_X$[ebp]
  00057	7e cc		 jle	 SHORT $LL6@ReleaseSec
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
$LN16@ReleaseSec:
  0005b	5f		 pop	 edi
$LN4@ReleaseSec:

; 2198 : 		}
; 2199 : 	}
; 2200 : 
; 2201 : }

  0005c	5d		 pop	 ebp
  0005d	c2 14 00	 ret	 20			; 00000014H
?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z ENDP		; CBloodCastle::ReleaseSector
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleEntranceBlockInfo
; Function compile flags: /Ogtp
;	COMDAT ?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
_cTEMP_BUF$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z PROC ; CBloodCastle::SendCastleEntranceBlockInfo, COMDAT
; _this$ = ecx

; 2212 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 2213 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00014	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	0f 88 be 00 00
	00		 js	 $LN3@SendCastle
  0001f	33 c0		 xor	 eax, eax
  00021	83 fe 06	 cmp	 esi, 6
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 ae 00 00
	00		 je	 $LN3@SendCastle

; 2214 : 	{
; 2215 : 		return;
; 2216 : 	}
; 2217 : 
; 2218 : 	char cTEMP_BUF[256];
; 2219 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;
; 2220 : 
; 2221 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  0002f	53		 push	 ebx
  00030	57		 push	 edi
  00031	6a 13		 push	 19			; 00000013H
  00033	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  00039	6a 46		 push	 70			; 00000046H
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2222 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];
; 2223 : 	lpMsg->btType = 0;
; 2224 : 	lpMsg->btCount = 1;
; 2225 : 	lpMsg->btMapAttr = 4;
; 2226 : 	(bLive)?(lpMsg->btMapSetType=0) :( lpMsg->btMapSetType=1);
; 2227 : 
; 2228 : 	lpMsgBody[0].btX = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;

  00041	0f b6 14 b5 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleEntranceMapXY[esi*4]

; 2229 : 	lpMsgBody[0].btY = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;

  00049	8a 04 b5 01 00
	00 00		 mov	 al, BYTE PTR _g_btCastleEntranceMapXY[esi*4+1]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	80 7d 0c 00	 cmp	 BYTE PTR _bLive$[ebp], 0
  00057	88 95 03 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+7], dl

; 2230 : 	lpMsgBody[1].btX   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;
; 2231 : 	lpMsgBody[1].btY   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;

  0005d	0f b6 14 b5 03
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleEntranceMapXY[esi*4+3]
  00065	0f 94 c1	 sete	 cl
  00068	88 8d 01 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+5], cl
  0006e	8a 0c b5 02 00
	00 00		 mov	 cl, BYTE PTR _g_btCastleEntranceMapXY[esi*4+2]
  00075	8d 5e 0b	 lea	 ebx, DWORD PTR [esi+11]
  00078	c6 85 02 ff ff
	ff 01		 mov	 BYTE PTR _cTEMP_BUF$[ebp+6], 1
  0007f	66 c7 85 ff fe
	ff ff 00 04	 mov	 WORD PTR _cTEMP_BUF$[ebp+3], 1024 ; 00000400H
  00088	88 85 04 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+8], al
  0008e	88 8d 05 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+9], cl
  00094	88 95 06 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+10], dl

; 2232 : 
; 2233 : 	for (int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  0009a	bf a8 16 00 00	 mov	 edi, 5800		; 000016a8H
  0009f	be a4 a1 e4 01	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+31760804
$LL5@SendCastle:

; 2234 : 	{
; 2235 : 		if ( gObj[i].MapNumber == (iBridgeIndex + MAP_INDEX_BLOODCASTLE1) )

  000a4	0f b6 86 05 01
	00 00		 movzx	 eax, BYTE PTR [esi+261]
  000ab	3b c3		 cmp	 eax, ebx
  000ad	75 1d		 jne	 SHORT $LN4@SendCastle

; 2236 : 		{
; 2237 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  000af	80 3e 02	 cmp	 BYTE PTR [esi], 2
  000b2	76 18		 jbe	 SHORT $LN4@SendCastle

; 2238 : 			{
; 2239 : 				DataSend(i, (unsigned char *)lpMsg, lpMsg->h.size);

  000b4	0f b6 8d fd fe
	ff ff		 movzx	 ecx, BYTE PTR _cTEMP_BUF$[ebp+1]
  000bb	51		 push	 ecx
  000bc	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _cTEMP_BUF$[ebp]
  000c2	52		 push	 edx
  000c3	57		 push	 edi
  000c4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendCastle:

; 2232 : 
; 2233 : 	for (int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  000cc	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  000d2	47		 inc	 edi
  000d3	81 fe a4 52 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522404
  000d9	7c c9		 jl	 SHORT $LL5@SendCastle
  000db	5f		 pop	 edi
  000dc	5b		 pop	 ebx
$LN3@SendCastle:

; 2240 : 			}
; 2241 : 		}
; 2242 : 	}
; 2243 : 
; 2244 : }

  000dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e0	33 cd		 xor	 ecx, ebp
  000e2	5e		 pop	 esi
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 08 00	 ret	 8
?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP ; CBloodCastle::SendCastleEntranceBlockInfo
_TEXT	ENDS
PUBLIC	??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleBridgeBlockInfo
;	COMDAT ??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@
CONST	SEGMENT
??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@ DB '['
	DB	'Blood Castle][Bug Tracer] SendCastleBridgeBlockInfo-> Bridge:'
	DB	'%d/Live:%d, (%d,%d,%d,%d)', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
_cTEMP_BUF$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z PROC	; CBloodCastle::SendCastleBridgeBlockInfo, COMDAT
; _this$ = ecx

; 2252 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]

; 2253 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00017	85 f6		 test	 esi, esi
  00019	0f 88 f3 00 00
	00		 js	 $LN3@SendCastle@2
  0001f	33 c0		 xor	 eax, eax
  00021	83 fe 06	 cmp	 esi, 6
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 e3 00 00
	00		 je	 $LN3@SendCastle@2

; 2254 : 	{
; 2255 : 		return;
; 2256 : 	}
; 2257 : 
; 2258 : 	char cTEMP_BUF[256];
; 2259 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;
; 2260 : 
; 2261 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  0002f	53		 push	 ebx
  00030	57		 push	 edi
  00031	6a 13		 push	 19			; 00000013H
  00033	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  00039	6a 46		 push	 70			; 00000046H
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2262 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];
; 2263 : 	lpMsg->btType = 0;
; 2264 : 	lpMsg->btCount = 1;
; 2265 : 	lpMsg->btMapAttr = 8;
; 2266 : 	(bLive)?lpMsg->btMapSetType=0:lpMsg->btMapSetType=1;
; 2267 : 
; 2268 : 	lpMsgBody[0].btX = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;

  00041	0f b6 14 b5 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleEntranceMapXY[esi*4]

; 2269 : 	lpMsgBody[0].btY = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;

  00049	8a 04 b5 01 00
	00 00		 mov	 al, BYTE PTR _g_btCastleEntranceMapXY[esi*4+1]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	80 7d 0c 00	 cmp	 BYTE PTR _bLive$[ebp], 0
  00057	88 95 03 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+7], dl

; 2270 : 	lpMsgBody[1].btX   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;
; 2271 : 	lpMsgBody[1].btY   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;

  0005d	0f b6 14 b5 03
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleEntranceMapXY[esi*4+3]
  00065	0f 94 c1	 sete	 cl
  00068	88 8d 01 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+5], cl
  0006e	8a 0c b5 02 00
	00 00		 mov	 cl, BYTE PTR _g_btCastleEntranceMapXY[esi*4+2]
  00075	c6 85 02 ff ff
	ff 01		 mov	 BYTE PTR _cTEMP_BUF$[ebp+6], 1
  0007c	66 c7 85 ff fe
	ff ff 00 08	 mov	 WORD PTR _cTEMP_BUF$[ebp+3], 2048 ; 00000800H
  00085	88 85 04 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+8], al
  0008b	88 8d 05 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+9], cl
  00091	88 95 06 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+10], dl

; 2272 : 
; 2273 : 	for ( int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  00097	bb a8 16 00 00	 mov	 ebx, 5800		; 000016a8H
  0009c	bf a4 a1 e4 01	 mov	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+31760804
$LL5@SendCastle@2:

; 2274 : 	{
; 2275 : 		if ( gObj[i].MapNumber == (iBridgeIndex + MAP_INDEX_BLOODCASTLE1) )

  000a1	0f b6 8f 05 01
	00 00		 movzx	 ecx, BYTE PTR [edi+261]
  000a8	8d 46 0b	 lea	 eax, DWORD PTR [esi+11]
  000ab	3b c8		 cmp	 ecx, eax
  000ad	75 52		 jne	 SHORT $LN4@SendCastle@2

; 2276 : 		{
; 2277 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  000af	80 3f 02	 cmp	 BYTE PTR [edi], 2
  000b2	76 4d		 jbe	 SHORT $LN4@SendCastle@2

; 2278 : 			{
; 2279 : 				DataSend(i, (UCHAR *)lpMsg, lpMsg->h.size);

  000b4	0f b6 95 fd fe
	ff ff		 movzx	 edx, BYTE PTR _cTEMP_BUF$[ebp+1]
  000bb	52		 push	 edx
  000bc	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  000c2	50		 push	 eax
  000c3	53		 push	 ebx
  000c4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2280 : 
; 2281 : 				LogAdd(LOG_BLACK, "[Blood Castle][Bug Tracer] SendCastleBridgeBlockInfo-> Bridge:%d/Live:%d, (%d,%d,%d,%d)",
; 2282 : 					iBridgeIndex+1, bLive, lpMsgBody[0].btX, lpMsgBody[0].btY, lpMsgBody[1].btX, lpMsgBody[1].btY);

  000c9	0f b6 8d 06 ff
	ff ff		 movzx	 ecx, BYTE PTR _cTEMP_BUF$[ebp+10]
  000d0	0f b6 95 05 ff
	ff ff		 movzx	 edx, BYTE PTR _cTEMP_BUF$[ebp+9]
  000d7	0f b6 85 04 ff
	ff ff		 movzx	 eax, BYTE PTR _cTEMP_BUF$[ebp+8]
  000de	51		 push	 ecx
  000df	0f b6 8d 03 ff
	ff ff		 movzx	 ecx, BYTE PTR _cTEMP_BUF$[ebp+7]
  000e6	52		 push	 edx
  000e7	0f b6 55 0c	 movzx	 edx, BYTE PTR _bLive$[ebp]
  000eb	50		 push	 eax
  000ec	51		 push	 ecx
  000ed	52		 push	 edx
  000ee	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000f1	50		 push	 eax
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@
  000f7	6a 00		 push	 0
  000f9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000fe	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN4@SendCastle@2:

; 2272 : 
; 2273 : 	for ( int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  00101	81 c7 64 15 00
	00		 add	 edi, 5476		; 00001564H
  00107	43		 inc	 ebx
  00108	81 ff a4 52 6a
	02		 cmp	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522404
  0010e	7c 91		 jl	 SHORT $LL5@SendCastle@2
  00110	5f		 pop	 edi
  00111	5b		 pop	 ebx
$LN3@SendCastle@2:

; 2283 : 			}
; 2284 : 		}
; 2285 : 	}
; 2286 : }

  00112	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00115	33 cd		 xor	 ecx, ebp
  00117	5e		 pop	 esi
  00118	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c2 08 00	 ret	 8
?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP	; CBloodCastle::SendCastleBridgeBlockInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleDoorBlockInfo
; Function compile flags: /Ogtp
;	COMDAT ?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
_cTEMP_BUF$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z PROC	; CBloodCastle::SendCastleDoorBlockInfo, COMDAT
; _this$ = ecx

; 2293 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 2294 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00014	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	0f 88 2b 01 00
	00		 js	 $LN3@SendCastle@3
  0001f	33 c0		 xor	 eax, eax
  00021	83 fe 06	 cmp	 esi, 6
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 1b 01 00
	00		 je	 $LN3@SendCastle@3

; 2295 : 	{
; 2296 : 		return;
; 2297 : 	}
; 2298 : 
; 2299 : 	char cTEMP_BUF[256];
; 2300 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;
; 2301 : 
; 2302 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  0002f	53		 push	 ebx
  00030	57		 push	 edi
  00031	6a 13		 push	 19			; 00000013H
  00033	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  00039	6a 46		 push	 70			; 00000046H
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2303 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];
; 2304 : 	lpMsg->btType = 0;
; 2305 : 	lpMsg->btCount = 3;
; 2306 : 	lpMsg->btMapAttr = 4;
; 2307 : 	(bLive)?lpMsg->btMapSetType=0:lpMsg->btMapSetType=1;

  00044	80 7d 0c 00	 cmp	 BYTE PTR _bLive$[ebp], 0

; 2308 : 
; 2309 : 	lpMsgBody[0].btX = ::g_btCastleDoorMapXY[iBridgeIndex][0].btStartX;

  00048	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  0004b	0f 94 c1	 sete	 cl
  0004e	03 c0		 add	 eax, eax
  00050	0f b6 94 00 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+eax]
  00058	03 c0		 add	 eax, eax
  0005a	88 8d 01 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+5], cl

; 2310 : 	lpMsgBody[0].btY = ::g_btCastleDoorMapXY[iBridgeIndex][0].btStartY;

  00060	0f b6 88 01 00
	00 00		 movzx	 ecx, BYTE PTR _g_btCastleDoorMapXY[eax+1]
  00067	88 95 03 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+7], dl

; 2311 : 	lpMsgBody[1].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][0].btEndX;

  0006d	0f b6 90 02 00
	00 00		 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+2]
  00074	88 8d 04 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+8], cl

; 2312 : 	lpMsgBody[1].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][0].btEndY;

  0007a	0f b6 88 03 00
	00 00		 movzx	 ecx, BYTE PTR _g_btCastleDoorMapXY[eax+3]
  00081	88 95 05 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+9], dl

; 2313 : 
; 2314 : 	lpMsgBody[2].btX = ::g_btCastleDoorMapXY[iBridgeIndex][1].btStartX;

  00087	0f b6 90 04 00
	00 00		 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+4]
  0008e	88 8d 06 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+10], cl

; 2315 : 	lpMsgBody[2].btY = ::g_btCastleDoorMapXY[iBridgeIndex][1].btStartY;

  00094	0f b6 88 05 00
	00 00		 movzx	 ecx, BYTE PTR _g_btCastleDoorMapXY[eax+5]
  0009b	88 95 07 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+11], dl

; 2316 : 	lpMsgBody[3].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][1].btEndX;

  000a1	0f b6 90 06 00
	00 00		 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+6]
  000a8	88 8d 08 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+12], cl

; 2317 : 	lpMsgBody[3].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][1].btEndY;

  000ae	0f b6 88 07 00
	00 00		 movzx	 ecx, BYTE PTR _g_btCastleDoorMapXY[eax+7]
  000b5	88 95 09 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+13], dl

; 2318 : 
; 2319 : 	lpMsgBody[4].btX = ::g_btCastleDoorMapXY[iBridgeIndex][2].btStartX;

  000bb	0f b6 90 08 00
	00 00		 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+8]
  000c2	88 8d 0a ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+14], cl

; 2320 : 	lpMsgBody[4].btY = ::g_btCastleDoorMapXY[iBridgeIndex][2].btStartY;

  000c8	0f b6 88 09 00
	00 00		 movzx	 ecx, BYTE PTR _g_btCastleDoorMapXY[eax+9]
  000cf	88 95 0b ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+15], dl

; 2321 : 	lpMsgBody[5].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][2].btEndX;

  000d5	0f b6 90 0a 00
	00 00		 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+10]

; 2322 : 	lpMsgBody[5].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][2].btEndY;

  000dc	8a 80 0b 00 00
	00		 mov	 al, BYTE PTR _g_btCastleDoorMapXY[eax+11]
  000e2	8d 5e 0b	 lea	 ebx, DWORD PTR [esi+11]
  000e5	c6 85 02 ff ff
	ff 03		 mov	 BYTE PTR _cTEMP_BUF$[ebp+6], 3
  000ec	66 c7 85 ff fe
	ff ff 00 04	 mov	 WORD PTR _cTEMP_BUF$[ebp+3], 1024 ; 00000400H
  000f5	88 8d 0c ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+16], cl
  000fb	88 95 0d ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+17], dl
  00101	88 85 0e ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+18], al

; 2323 : 
; 2324 : 	for ( int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  00107	bf a8 16 00 00	 mov	 edi, 5800		; 000016a8H
  0010c	be a4 a1 e4 01	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+31760804
$LL5@SendCastle@3:

; 2325 : 	{
; 2326 : 		if ( gObj[i].MapNumber == (iBridgeIndex + MAP_INDEX_BLOODCASTLE1) )

  00111	0f b6 8e 05 01
	00 00		 movzx	 ecx, BYTE PTR [esi+261]
  00118	3b cb		 cmp	 ecx, ebx
  0011a	75 1d		 jne	 SHORT $LN4@SendCastle@3

; 2327 : 		{
; 2328 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  0011c	80 3e 02	 cmp	 BYTE PTR [esi], 2
  0011f	76 18		 jbe	 SHORT $LN4@SendCastle@3

; 2329 : 			{
; 2330 : 				DataSend(i, (UCHAR *)lpMsg, lpMsg->h.size);

  00121	0f b6 95 fd fe
	ff ff		 movzx	 edx, BYTE PTR _cTEMP_BUF$[ebp+1]
  00128	52		 push	 edx
  00129	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  0012f	50		 push	 eax
  00130	57		 push	 edi
  00131	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00136	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendCastle@3:

; 2323 : 
; 2324 : 	for ( int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  00139	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  0013f	47		 inc	 edi
  00140	81 fe a4 52 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522404
  00146	7c c9		 jl	 SHORT $LL5@SendCastle@3
  00148	5f		 pop	 edi
  00149	5b		 pop	 ebx
$LN3@SendCastle@3:

; 2331 : 			}
; 2332 : 		}
; 2333 : 	}
; 2334 : }

  0014a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014d	33 cd		 xor	 ecx, ebp
  0014f	5e		 pop	 esi
  00150	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c2 08 00	 ret	 8
?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP	; CBloodCastle::SendCastleDoorBlockInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z	; CBloodCastle::SendNoticeMessage
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
; Function compile flags: /Ogtp
;	COMDAT ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_lpszMSG$ = 12						; size = 4
?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z PROC	; CBloodCastle::SendNoticeMessage, COMDAT
; _this$ = ecx

; 2341 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _lpszMSG$[ebp]
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  0001a	57		 push	 edi
  0001b	8b f9		 mov	 edi, ecx

; 2342 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0001d	85 f6		 test	 esi, esi
  0001f	78 75		 js	 SHORT $LN5@SendNotice
  00021	33 c9		 xor	 ecx, ecx
  00023	83 fe 06	 cmp	 esi, 6
  00026	0f 9e c1	 setle	 cl
  00029	85 c9		 test	 ecx, ecx
  0002b	74 69		 je	 SHORT $LN5@SendNotice

; 2343 : 	{
; 2344 : 		return;
; 2345 : 	}
; 2346 : 
; 2347 : 	PMSG_NOTICE pNotice;
; 2348 : 
; 2349 : 	TNotice::MakeNoticeMsg( &pNotice, 0, lpszMSG);

  0002d	53		 push	 ebx
  0002e	50		 push	 eax
  0002f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00035	6a 00		 push	 0
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  0003d	c1 e6 09	 shl	 esi, 9
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	8d 74 3e 1c	 lea	 esi, DWORD PTR [esi+edi+28]
  00047	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  0004c	83 cb ff	 or	 ebx, -1
  0004f	90		 npad	 1
$LL7@SendNotice:

; 2352 : 	{
; 2353 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00050	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00052	3b cb		 cmp	 ecx, ebx
  00054	74 39		 je	 SHORT $LN6@SendNotice

; 2354 : 		{
; 2355 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00056	8b c1		 mov	 eax, ecx
  00058	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0005e	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  00065	76 28		 jbe	 SHORT $LN6@SendNotice

; 2356 : 			{
; 2357 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 )

  00067	38 98 02 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330], bl
  0006d	74 20		 je	 SHORT $LN6@SendNotice

; 2358 : 				{
; 2359 : 					if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  0006f	38 98 03 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3331], bl
  00075	74 18		 je	 SHORT $LN6@SendNotice

; 2360 : 					{
; 2361 : 						DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (UCHAR*)&pNotice, pNotice.h.size);

  00077	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$[ebp+1]
  0007e	52		 push	 edx
  0007f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00085	50		 push	 eax
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@SendNotice:

; 2350 : 
; 2351 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0008f	83 c6 14	 add	 esi, 20			; 00000014H
  00092	4f		 dec	 edi
  00093	75 bb		 jne	 SHORT $LL7@SendNotice
  00095	5b		 pop	 ebx
$LN5@SendNotice:

; 2362 : 					}
; 2363 : 				}
; 2364 : 			}
; 2365 : 		}
; 2366 : 	}
; 2367 : }

  00096	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00099	5f		 pop	 edi
  0009a	33 cd		 xor	 ecx, ebp
  0009c	5e		 pop	 esi
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 08 00	 ret	 8
?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ENDP	; CBloodCastle::SendNoticeMessage
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendNoticeScore@CBloodCastle@@QAEXH@Z		; CBloodCastle::SendNoticeScore
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
; Function compile flags: /Ogtp
;	COMDAT ?SendNoticeScore@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?SendNoticeScore@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SendNoticeScore, COMDAT
; _this$ = ecx

; 2374 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]

; 2375 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00017	85 ff		 test	 edi, edi
  00019	0f 88 97 00 00
	00		 js	 $LN5@SendNotice@2
  0001f	33 c0		 xor	 eax, eax
  00021	83 ff 06	 cmp	 edi, 6
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 87 00 00
	00		 je	 $LN5@SendNotice@2

; 2376 : 	{
; 2377 : 		return;
; 2378 : 	}
; 2379 : 
; 2380 : 	PMSG_NOTICE pNotice;
; 2381 : 	pNotice.type = 0;

  0002f	53		 push	 ebx
  00030	8b c7		 mov	 eax, edi
  00032	c1 e0 09	 shl	 eax, 9
  00035	56		 push	 esi
  00036	c6 85 ef fe ff
	ff 00		 mov	 BYTE PTR _pNotice$[ebp+3], 0
  0003d	8d 74 08 1c	 lea	 esi, DWORD PTR [eax+ecx+28]
  00041	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
$LL7@SendNotice@2:

; 2384 : 	{
; 2385 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00046	8b 06		 mov	 eax, DWORD PTR [esi]
  00048	83 f8 ff	 cmp	 eax, -1
  0004b	74 61		 je	 SHORT $LN6@SendNotice@2

; 2386 : 		{
; 2387 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  0004d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00053	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  0005a	76 52		 jbe	 SHORT $LN6@SendNotice@2

; 2388 : 			{
; 2389 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 )

  0005c	80 b8 02 0d 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330], -1
  00063	74 49		 je	 SHORT $LN6@SendNotice@2

; 2390 : 				{
; 2391 : 					if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  00065	80 b8 03 0d 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3331], -1
  0006c	74 40		 je	 SHORT $LN6@SendNotice@2

; 2392 : 					{
; 2393 : 						TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get(MSGGET(4, 140)), iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP);

  0006e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00071	51		 push	 ecx
  00072	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
  00075	52		 push	 edx
  00076	68 8c 04 00 00	 push	 1164			; 0000048cH
  0007b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00080	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00085	50		 push	 eax
  00086	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  0008c	6a 00		 push	 0
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 2394 : 						DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (UCHAR*)&pNotice, pNotice.h.size);

  00094	0f b6 8d ed fe
	ff ff		 movzx	 ecx, BYTE PTR _pNotice$[ebp+1]
  0009b	8b 06		 mov	 eax, DWORD PTR [esi]
  0009d	51		 push	 ecx
  0009e	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$[ebp]
  000a4	52		 push	 edx
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ab	83 c4 20	 add	 esp, 32			; 00000020H
$LN6@SendNotice@2:

; 2382 : 
; 2383 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  000ae	83 c6 14	 add	 esi, 20			; 00000014H
  000b1	4b		 dec	 ebx
  000b2	75 92		 jne	 SHORT $LL7@SendNotice@2
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
$LN5@SendNotice@2:

; 2395 : 					}
; 2396 : 				}
; 2397 : 			}
; 2398 : 		}
; 2399 : 	}
; 2400 : }

  000b6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b9	33 cd		 xor	 ecx, ebp
  000bb	5f		 pop	 edi
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
?SendNoticeScore@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SendNoticeScore
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendNoticeState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SendNoticeState
; Function compile flags: /Ogtp
;	COMDAT ?SendNoticeState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_iPlayState$ = 12					; size = 4
?SendNoticeState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::SendNoticeState, COMDAT
; _this$ = ecx

; 2407 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00014	57		 push	 edi
  00015	8b f9		 mov	 edi, ecx

; 2408 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00017	85 f6		 test	 esi, esi
  00019	0f 88 d5 00 00
	00		 js	 $LN5@SendNotice@3
  0001f	33 c0		 xor	 eax, eax
  00021	83 fe 06	 cmp	 esi, 6
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 c5 00 00
	00		 je	 $LN5@SendNotice@3

; 2409 : 	{
; 2410 : 		return;
; 2411 : 	}
; 2412 : 
; 2413 : 	PMSG_STATEBLOODCASTLE pMsg;
; 2414 : 
; 2415 : 	PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(PMSG_STATEBLOODCASTLE));

  0002f	53		 push	 ebx
  00030	6a 0e		 push	 14			; 0000000eH
  00032	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00035	68 9b 00 00 00	 push	 155			; 0000009bH
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2416 : 	pMsg.btPlayState = iPlayState;

  00040	8b 5d 0c	 mov	 ebx, DWORD PTR _iPlayState$[ebp]

; 2417 : 	pMsg.wRemainSec = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;

  00043	c1 e6 09	 shl	 esi, 9
  00046	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00049	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0004e	f7 a9 54 01 00
	00		 imul	 DWORD PTR [ecx+340]
  00054	c1 fa 06	 sar	 edx, 6
  00057	8b c2		 mov	 eax, edx
  00059	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005c	03 c2		 add	 eax, edx
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	88 5d ef	 mov	 BYTE PTR _pMsg$[ebp+3], bl
  00064	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 2418 : 
; 2419 : 	if ( iPlayState == 4 )

  00068	83 fb 04	 cmp	 ebx, 4
  0006b	75 10		 jne	 SHORT $LN9@SendNotice@3

; 2420 : 	{
; 2421 : 		pMsg.wMaxKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT;

  0006d	66 8b 91 84 01
	00 00		 mov	 dx, WORD PTR [ecx+388]

; 2422 : 		pMsg.wCurKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT;

  00074	66 8b 81 88 01
	00 00		 mov	 ax, WORD PTR [ecx+392]

; 2423 : 	}
; 2424 : 	else

  0007b	eb 0e		 jmp	 SHORT $LN17@SendNotice@3
$LN9@SendNotice@3:

; 2425 : 	{
; 2426 : 		pMsg.wMaxKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT;

  0007d	66 8b 91 74 01
	00 00		 mov	 dx, WORD PTR [ecx+372]

; 2427 : 		pMsg.wCurKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT;

  00084	66 8b 81 78 01
	00 00		 mov	 ax, WORD PTR [ecx+376]
$LN17@SendNotice@3:
  0008b	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+8], ax

; 2428 : 	}
; 2429 : 
; 2430 : 	pMsg.wUserHaveWeapon = this->m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX;
; 2431 : 	pMsg.btWeaponNum = this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER + 1;

  0008f	8a 81 98 01 00
	00		 mov	 al, BYTE PTR [ecx+408]
  00095	66 89 55 f2	 mov	 WORD PTR _pMsg$[ebp+6], dx
  00099	66 8b 91 94 01
	00 00		 mov	 dx, WORD PTR [ecx+404]
  000a0	fe c0		 inc	 al
  000a2	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+10], dx
  000a6	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
  000a9	8d 71 1c	 lea	 esi, DWORD PTR [ecx+28]
  000ac	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  000b1	83 cb ff	 or	 ebx, -1
$LL7@SendNotice@3:

; 2434 : 	{
; 2435 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  000b4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b6	3b cb		 cmp	 ecx, ebx
  000b8	74 33		 je	 SHORT $LN6@SendNotice@3

; 2436 : 		{
; 2437 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000ba	8b c1		 mov	 eax, ecx
  000bc	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000c2	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  000c9	76 22		 jbe	 SHORT $LN6@SendNotice@3

; 2438 : 			{
; 2439 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 )

  000cb	38 98 02 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330], bl
  000d1	74 1a		 je	 SHORT $LN6@SendNotice@3

; 2440 : 				{
; 2441 : 					if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  000d3	38 98 03 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3331], bl
  000d9	74 12		 je	 SHORT $LN6@SendNotice@3

; 2442 : 					{
; 2443 : 						DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (UCHAR *)&pMsg, pMsg.h.size);

  000db	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  000df	52		 push	 edx
  000e0	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000e3	50		 push	 eax
  000e4	51		 push	 ecx
  000e5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@SendNotice@3:

; 2432 : 
; 2433 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  000ed	83 c6 14	 add	 esi, 20			; 00000014H
  000f0	4f		 dec	 edi
  000f1	75 c1		 jne	 SHORT $LL7@SendNotice@3
  000f3	5b		 pop	 ebx
$LN5@SendNotice@3:

; 2444 : 					}
; 2445 : 				}
; 2446 : 			}
; 2447 : 		}
; 2448 : 	}
; 2449 : }

  000f4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f7	5f		 pop	 edi
  000f8	33 cd		 xor	 ecx, ebp
  000fa	5e		 pop	 esi
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 08 00	 ret	 8
?SendNoticeState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::SendNoticeState
_TEXT	ENDS
PUBLIC	?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::CheckUserBridgeMember
; Function compile flags: /Ogtp
;	COMDAT ?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::CheckUserBridgeMember, COMDAT
; _this$ = ecx

; 2459 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2460 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0c		 js	 SHORT $LN16@CheckUserB
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 06	 cmp	 edx, 6
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	75 06		 jne	 SHORT $LN6@CheckUserB
$LN16@CheckUserB:

; 2461 : 	{
; 2462 : 		return false;

  00016	32 c0		 xor	 al, al

; 2479 : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN6@CheckUserB:
  0001c	56		 push	 esi

; 2463 : 	}
; 2464 : 
; 2465 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  0001d	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00020	85 f6		 test	 esi, esi
  00022	78 29		 js	 SHORT $LN2@CheckUserB
  00024	33 c0		 xor	 eax, eax
  00026	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  0002c	0f 9e c0	 setle	 al
  0002f	85 c0		 test	 eax, eax

; 2466 : 	{
; 2467 : 		return false;

  00031	74 1a		 je	 SHORT $LN2@CheckUserB

; 2468 : 	}
; 2469 : 
; 2470 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00033	33 c0		 xor	 eax, eax
  00035	c1 e2 09	 shl	 edx, 9
  00038	8d 4c 0a 1c	 lea	 ecx, DWORD PTR [edx+ecx+28]
  0003c	8d 64 24 00	 npad	 4
$LL4@CheckUserB:

; 2471 : 	{
; 2472 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == iIndex )

  00040	39 31		 cmp	 DWORD PTR [ecx], esi
  00042	74 10		 je	 SHORT $LN14@CheckUserB

; 2468 : 	}
; 2469 : 
; 2470 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00044	40		 inc	 eax
  00045	83 c1 14	 add	 ecx, 20			; 00000014H
  00048	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0004b	7c f3		 jl	 SHORT $LL4@CheckUserB
$LN2@CheckUserB:

; 2475 : 		}
; 2476 : 	}
; 2477 : 
; 2478 : 	return false;

  0004d	32 c0		 xor	 al, al
  0004f	5e		 pop	 esi

; 2479 : }

  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
$LN14@CheckUserB:

; 2473 : 		{
; 2474 : 			return true;

  00054	b0 01		 mov	 al, 1
  00056	5e		 pop	 esi

; 2479 : }

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::CheckUserBridgeMember
_TEXT	ENDS
PUBLIC	?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z	; CBloodCastle::GetAliveUserTotalEXP
; Function compile flags: /Ogtp
;	COMDAT ?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z PROC	; CBloodCastle::GetAliveUserTotalEXP, COMDAT
; _this$ = ecx

; 2486 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2487 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0c		 js	 SHORT $LN29@GetAliveUs
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 06	 cmp	 edx, 6
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	75 06		 jne	 SHORT $LN7@GetAliveUs
$LN29@GetAliveUs:

; 2488 : 	{
; 2489 : 		return 0;

  00016	33 c0		 xor	 eax, eax

; 2509 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN7@GetAliveUs:
  0001c	53		 push	 ebx
  0001d	56		 push	 esi

; 2490 : 	}
; 2491 : 
; 2492 : 	int iRET_EXP = 0;

  0001e	33 f6		 xor	 esi, esi
  00020	c1 e2 09	 shl	 edx, 9
  00023	b8 02 00 00 00	 mov	 eax, 2
  00028	57		 push	 edi
  00029	8d 54 0a 1c	 lea	 edx, DWORD PTR [edx+ecx+28]
  0002d	8b f8		 mov	 edi, eax
  0002f	90		 npad	 1
$LL35@GetAliveUs:

; 2495 : 	{
; 2496 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00030	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00032	83 f9 ff	 cmp	 ecx, -1
  00035	74 26		 je	 SHORT $LN5@GetAliveUs

; 2497 : 		{
; 2498 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00037	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0003d	38 81 04 00 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], al
  00043	76 18		 jbe	 SHORT $LN5@GetAliveUs

; 2499 : 			{
; 2500 : 				if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  00045	0f b6 89 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  0004c	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0004f	72 0c		 jb	 SHORT $LN5@GetAliveUs
  00051	b3 11		 mov	 bl, 17			; 00000011H
  00053	3a d9		 cmp	 bl, cl
  00055	1b c9		 sbb	 ecx, ecx
  00057	41		 inc	 ecx
  00058	74 03		 je	 SHORT $LN5@GetAliveUs

; 2501 : 				{
; 2502 : 					iRET_EXP += this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP;

  0005a	03 72 04	 add	 esi, DWORD PTR [edx+4]
$LN5@GetAliveUs:

; 2495 : 	{
; 2496 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  0005d	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00060	83 f9 ff	 cmp	 ecx, -1
  00063	74 26		 je	 SHORT $LN31@GetAliveUs

; 2497 : 		{
; 2498 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00065	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0006b	38 81 04 00 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], al
  00071	76 18		 jbe	 SHORT $LN31@GetAliveUs

; 2499 : 			{
; 2500 : 				if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  00073	0f b6 89 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  0007a	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0007d	72 0c		 jb	 SHORT $LN31@GetAliveUs
  0007f	b3 11		 mov	 bl, 17			; 00000011H
  00081	3a d9		 cmp	 bl, cl
  00083	1b c9		 sbb	 ecx, ecx
  00085	41		 inc	 ecx
  00086	74 03		 je	 SHORT $LN31@GetAliveUs

; 2501 : 				{
; 2502 : 					iRET_EXP += this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP;

  00088	03 72 18	 add	 esi, DWORD PTR [edx+24]
$LN31@GetAliveUs:

; 2495 : 	{
; 2496 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  0008b	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  0008e	83 f9 ff	 cmp	 ecx, -1
  00091	74 26		 je	 SHORT $LN32@GetAliveUs

; 2497 : 		{
; 2498 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00093	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00099	38 81 04 00 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], al
  0009f	76 18		 jbe	 SHORT $LN32@GetAliveUs

; 2499 : 			{
; 2500 : 				if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  000a1	0f b6 89 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  000a8	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  000ab	72 0c		 jb	 SHORT $LN32@GetAliveUs
  000ad	b3 11		 mov	 bl, 17			; 00000011H
  000af	3a d9		 cmp	 bl, cl
  000b1	1b c9		 sbb	 ecx, ecx
  000b3	41		 inc	 ecx
  000b4	74 03		 je	 SHORT $LN32@GetAliveUs

; 2501 : 				{
; 2502 : 					iRET_EXP += this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP;

  000b6	03 72 2c	 add	 esi, DWORD PTR [edx+44]
$LN32@GetAliveUs:

; 2495 : 	{
; 2496 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  000b9	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  000bc	83 f9 ff	 cmp	 ecx, -1
  000bf	74 26		 je	 SHORT $LN33@GetAliveUs

; 2497 : 		{
; 2498 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000c1	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000c7	38 81 04 00 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], al
  000cd	76 18		 jbe	 SHORT $LN33@GetAliveUs

; 2499 : 			{
; 2500 : 				if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  000cf	0f b6 89 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  000d6	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  000d9	72 0c		 jb	 SHORT $LN33@GetAliveUs
  000db	b3 11		 mov	 bl, 17			; 00000011H
  000dd	3a d9		 cmp	 bl, cl
  000df	1b c9		 sbb	 ecx, ecx
  000e1	41		 inc	 ecx
  000e2	74 03		 je	 SHORT $LN33@GetAliveUs

; 2501 : 				{
; 2502 : 					iRET_EXP += this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP;

  000e4	03 72 40	 add	 esi, DWORD PTR [edx+64]
$LN33@GetAliveUs:

; 2495 : 	{
; 2496 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  000e7	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  000ea	83 f9 ff	 cmp	 ecx, -1
  000ed	74 26		 je	 SHORT $LN34@GetAliveUs

; 2497 : 		{
; 2498 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000ef	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000f5	38 81 04 00 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], al
  000fb	76 18		 jbe	 SHORT $LN34@GetAliveUs

; 2499 : 			{
; 2500 : 				if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  000fd	0f b6 89 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  00104	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00107	72 0c		 jb	 SHORT $LN34@GetAliveUs
  00109	b3 11		 mov	 bl, 17			; 00000011H
  0010b	3a d9		 cmp	 bl, cl
  0010d	1b c9		 sbb	 ecx, ecx
  0010f	41		 inc	 ecx
  00110	74 03		 je	 SHORT $LN34@GetAliveUs

; 2501 : 				{
; 2502 : 					iRET_EXP += this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP;

  00112	03 72 54	 add	 esi, DWORD PTR [edx+84]
$LN34@GetAliveUs:

; 2490 : 	}
; 2491 : 
; 2492 : 	int iRET_EXP = 0;

  00115	83 c2 64	 add	 edx, 100		; 00000064H

; 2493 : 
; 2494 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00118	4f		 dec	 edi
  00119	0f 85 11 ff ff
	ff		 jne	 $LL35@GetAliveUs

; 2503 : 				}
; 2504 : 			}
; 2505 : 		}
; 2506 : 	}
; 2507 : 
; 2508 : 	return iRET_EXP;

  0011f	5f		 pop	 edi
  00120	8b c6		 mov	 eax, esi
  00122	5e		 pop	 esi
  00123	5b		 pop	 ebx

; 2509 : }

  00124	5d		 pop	 ebp
  00125	c2 04 00	 ret	 4
?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z ENDP	; CBloodCastle::GetAliveUserTotalEXP
_TEXT	ENDS
PUBLIC	??_C@_0FK@LLMALHHB@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
;	COMDAT ??_C@_0FK@LLMALHHB@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FK@LLMALHHB@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Delete Angel Kin'
	DB	'g''s Weapon (%d) [Serial:%d]', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_iLEVEL$158174 = -4					; size = 4
_iIndex$ = 8						; size = 4
?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::SearchUserDeleteQuestItem, COMDAT
; _this$ = ecx

; 2514 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2515 : 	if ( gObjIsConnected(iIndex) == FALSE )

  00005	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000e	83 c4 04	 add	 esp, 4
  00011	85 c0		 test	 eax, eax
  00013	0f 84 ba 00 00
	00		 je	 $LN4@SearchUser

; 2516 : 	{
; 2517 : 		return;
; 2518 : 	}
; 2519 : 
; 2520 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  00019	53		 push	 ebx
  0001a	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00020	57		 push	 edi
  00021	33 ff		 xor	 edi, edi
  00023	33 db		 xor	 ebx, ebx
  00025	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL6@SearchUser:

; 2521 : 	{
; 2522 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00030	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  00036	03 cb		 add	 ecx, ebx
  00038	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0003d	83 f8 01	 cmp	 eax, 1
  00040	75 7c		 jne	 SHORT $LN5@SearchUser

; 2523 : 		{
; 2524 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  00042	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  00048	b9 13 1a 00 00	 mov	 ecx, 6675		; 00001a13H
  0004d	66 39 4c 18 06	 cmp	 WORD PTR [eax+ebx+6], cx
  00052	75 6a		 jne	 SHORT $LN5@SearchUser

; 2525 : 			{
; 2526 : 				int iLEVEL = gObj[iIndex].pInventory[x].m_Level;

  00054	0f bf 44 18 08	 movsx	 eax, WORD PTR [eax+ebx+8]
  00059	89 45 fc	 mov	 DWORD PTR _iLEVEL$158174[ebp], eax

; 2527 : 
; 2528 : 				if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  0005c	85 c0		 test	 eax, eax
  0005e	78 5e		 js	 SHORT $LN5@SearchUser
  00060	33 d2		 xor	 edx, edx
  00062	83 f8 02	 cmp	 eax, 2
  00065	0f 9e c2	 setle	 dl
  00068	8b c2		 mov	 eax, edx
  0006a	85 c0		 test	 eax, eax
  0006c	74 50		 je	 SHORT $LN5@SearchUser

; 2529 : 				{
; 2530 : 					::gObjInventoryItemSet(iIndex, x, -1);

  0006e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00071	68 ff 00 00 00	 push	 255			; 000000ffH
  00076	57		 push	 edi
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 2531 : 					::gObjInventoryDeleteItem(iIndex, x);

  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00080	57		 push	 edi
  00081	51		 push	 ecx
  00082	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 2532 : 					::GCInventoryItemDeleteSend(iIndex, x, TRUE);

  00087	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0008a	6a 01		 push	 1
  0008c	57		 push	 edi
  0008d	52		 push	 edx
  0008e	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 2533 : 
; 2534 : 					LogAdd(LOG_BLACK, "[Blood Castle] Force (Account:%s, Name:%s) to Delete Angel King's Weapon (%d) [Serial:%d]",
; 2535 : 						gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL, gObj[iIndex].pInventory[x].m_Number);

  00093	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  00099	8b 0c 18	 mov	 ecx, DWORD PTR [eax+ebx]
  0009c	8b 55 fc	 mov	 edx, DWORD PTR _iLEVEL$158174[ebp]
  0009f	51		 push	 ecx
  000a0	52		 push	 edx
  000a1	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  000a7	50		 push	 eax
  000a8	8d 8e 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  000ae	51		 push	 ecx
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@LLMALHHB@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
  000b4	6a 00		 push	 0
  000b6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000bb	83 c4 38	 add	 esp, 56			; 00000038H
$LN5@SearchUser:

; 2516 : 	{
; 2517 : 		return;
; 2518 : 	}
; 2519 : 
; 2520 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  000be	81 c3 a8 00 00
	00		 add	 ebx, 168		; 000000a8H
  000c4	47		 inc	 edi
  000c5	81 fb e0 46 00
	00		 cmp	 ebx, 18144		; 000046e0H
  000cb	0f 8c 5f ff ff
	ff		 jl	 $LL6@SearchUser
  000d1	5f		 pop	 edi
  000d2	5b		 pop	 ebx
$LN4@SearchUser:
  000d3	5e		 pop	 esi

; 2536 : 				}
; 2537 : 			}
; 2538 : 		}
; 2539 : 	}
; 2540 : }

  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::SearchUserDeleteQuestItem
_TEXT	ENDS
PUBLIC	?SetUserState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SetUserState
; Function compile flags: /Ogtp
;	COMDAT ?SetUserState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv803 = -8						; size = 4
_iBridgeSubIndex$ = -4					; size = 4
tv1060 = 8						; size = 4
_iIndex$ = 8						; size = 4
_iState$ = 12						; size = 4
?SetUserState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::SetUserState, COMDAT
; _this$ = ecx

; 2609 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2610 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	85 c0		 test	 eax, eax
  0000e	0f 88 dd 02 00
	00		 js	 $LN14@SetUserSta
  00014	33 c9		 xor	 ecx, ecx
  00016	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  0001b	0f 9e c1	 setle	 cl
  0001e	85 c9		 test	 ecx, ecx
  00020	0f 84 cb 02 00
	00		 je	 $LN14@SetUserSta

; 2611 : 	{
; 2612 : 		return;
; 2613 : 	}
; 2614 : 
; 2615 : 	int iBridgeIndex = gObj[iIndex].m_cBloodCastleIndex;

  00026	53		 push	 ebx
  00027	8b d8		 mov	 ebx, eax
  00029	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  0002f	0f be 93 02 0d
	00 00		 movsx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3330]

; 2616 : 	int iBridgeSubIndex = gObj[iIndex].m_cBloodCastleSubIndex;

  00036	0f be 8b 03 0d
	00 00		 movsx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3331]
  0003d	89 5d f8	 mov	 DWORD PTR tv803[ebp], ebx
  00040	89 4d fc	 mov	 DWORD PTR _iBridgeSubIndex$[ebp], ecx

; 2617 : 
; 2618 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00043	85 d2		 test	 edx, edx
  00045	0f 88 a5 02 00
	00		 js	 $LN55@SetUserSta
  0004b	33 c0		 xor	 eax, eax
  0004d	83 fa 06	 cmp	 edx, 6
  00050	0f 9e c0	 setle	 al
  00053	85 c0		 test	 eax, eax
  00055	0f 84 95 02 00
	00		 je	 $LN55@SetUserSta

; 2619 : 	{
; 2620 : 		return;
; 2621 : 	}
; 2622 : 
; 2623 : 	if ( BC_SUB_BRIDGE_RANGE(iBridgeSubIndex) == FALSE )

  0005b	85 c9		 test	 ecx, ecx
  0005d	0f 88 8d 02 00
	00		 js	 $LN55@SetUserSta
  00063	33 c0		 xor	 eax, eax
  00065	83 f9 09	 cmp	 ecx, 9
  00068	0f 9e c0	 setle	 al
  0006b	85 c0		 test	 eax, eax
  0006d	0f 84 7d 02 00
	00		 je	 $LN55@SetUserSta

; 2624 : 	{
; 2625 : 		return;
; 2626 : 	}
; 2627 : 
; 2628 : 	switch ( iState )

  00073	8b 45 0c	 mov	 eax, DWORD PTR _iState$[ebp]
  00076	83 f8 04	 cmp	 eax, 4
  00079	0f 87 71 02 00
	00		 ja	 $LN55@SetUserSta
  0007f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN56@SetUserSta[eax*4]
$LN13@SetUserSta:

; 2629 : 	{
; 2630 : 		case 0:
; 2631 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 0;

  00086	c1 e2 09	 shl	 edx, 9
  00089	03 d6		 add	 edx, esi
  0008b	8d 44 89 0a	 lea	 eax, DWORD PTR [ecx+ecx*4+10]
  0008f	5b		 pop	 ebx
  00090	c7 04 82 00 00
	00 00		 mov	 DWORD PTR [edx+eax*4], 0
  00097	5e		 pop	 esi

; 2672 : 			break;
; 2673 : 	}
; 2674 : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
$LN12@SetUserSta:

; 2632 : 			break;
; 2633 : 
; 2634 : 		case 1:
; 2635 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 1;

  0009e	c1 e2 09	 shl	 edx, 9
  000a1	03 d6		 add	 edx, esi
  000a3	8d 4c 89 0a	 lea	 ecx, DWORD PTR [ecx+ecx*4+10]
  000a7	5b		 pop	 ebx
  000a8	c7 04 8a 01 00
	00 00		 mov	 DWORD PTR [edx+ecx*4], 1
  000af	5e		 pop	 esi

; 2672 : 			break;
; 2673 : 	}
; 2674 : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
$LN11@SetUserSta:

; 2636 : 			break;
; 2637 : 
; 2638 : 		case 2:
; 2639 : 			if ( gObj[iIndex].PartyNumber >= 0 )

  000b6	83 bb a8 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+680], 0
  000bd	0f 8c e5 01 00
	00		 jl	 $LN31@SetUserSta

; 2640 : 			{
; 2641 : 				for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  000c3	57		 push	 edi
  000c4	bf 02 00 00 00	 mov	 edi, 2
  000c9	33 c0		 xor	 eax, eax
  000cb	89 7d 08	 mov	 DWORD PTR tv1060[ebp], edi
  000ce	eb 03		 jmp	 SHORT $LN9@SetUserSta
$LL53@SetUserSta:
  000d0	8b 5d f8	 mov	 ebx, DWORD PTR tv803[ebp]
$LN9@SetUserSta:

; 2642 : 				{
; 2643 : 					if ( i == iBridgeSubIndex )

  000d3	83 c7 fe	 add	 edi, -2			; fffffffeH
  000d6	3b f9		 cmp	 edi, ecx
  000d8	74 4d		 je	 SHORT $LN8@SetUserSta

; 2644 : 					{
; 2645 : 						continue;
; 2646 : 					}
; 2647 : 
; 2648 : 					if ( gObj[iIndex].PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber )

  000da	8b 9b a8 02 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+680]
  000e0	8b fa		 mov	 edi, edx
  000e2	c1 e7 09	 shl	 edi, 9
  000e5	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  000e8	8b 4c 31 1c	 mov	 ecx, DWORD PTR [ecx+esi+28]
  000ec	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000f2	3b 99 a8 02 00
	00		 cmp	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+680]
  000f8	75 2d		 jne	 SHORT $LN8@SetUserSta

; 2649 : 					{
; 2650 : 						if ( BC_MAP_RANGE( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].MapNumber ) != FALSE )

  000fa	0f b6 89 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  00101	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00104	72 16		 jb	 SHORT $LN4@SetUserSta
  00106	b3 11		 mov	 bl, 17			; 00000011H
  00108	3a d9		 cmp	 bl, cl
  0010a	1b c9		 sbb	 ecx, ecx
  0010c	41		 inc	 ecx
  0010d	74 0d		 je	 SHORT $LN4@SetUserSta

; 2651 : 						{
; 2652 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  0010f	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00112	c7 44 31 28 03
	00 00 00	 mov	 DWORD PTR [ecx+esi+40], 3

; 2653 : 						}
; 2654 : 						else

  0011a	eb 0b		 jmp	 SHORT $LN8@SetUserSta
$LN4@SetUserSta:

; 2655 : 						{
; 2656 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  0011c	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  0011f	c7 44 31 28 04
	00 00 00	 mov	 DWORD PTR [ecx+esi+40], 4
$LN8@SetUserSta:

; 2642 : 				{
; 2643 : 					if ( i == iBridgeSubIndex )

  00127	8b 4d 08	 mov	 ecx, DWORD PTR tv1060[ebp]
  0012a	49		 dec	 ecx
  0012b	3b 4d fc	 cmp	 ecx, DWORD PTR _iBridgeSubIndex$[ebp]
  0012e	74 50		 je	 SHORT $LN49@SetUserSta

; 2644 : 					{
; 2645 : 						continue;
; 2646 : 					}
; 2647 : 
; 2648 : 					if ( gObj[iIndex].PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber )

  00130	8b 5d f8	 mov	 ebx, DWORD PTR tv803[ebp]
  00133	8b 9b a8 02 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+680]
  00139	8b fa		 mov	 edi, edx
  0013b	c1 e7 09	 shl	 edi, 9
  0013e	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00141	8b 4c 31 30	 mov	 ecx, DWORD PTR [ecx+esi+48]
  00145	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0014b	3b 99 a8 02 00
	00		 cmp	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+680]
  00151	75 2d		 jne	 SHORT $LN49@SetUserSta

; 2649 : 					{
; 2650 : 						if ( BC_MAP_RANGE( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].MapNumber ) != FALSE )

  00153	0f b6 89 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  0015a	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0015d	72 16		 jb	 SHORT $LN34@SetUserSta
  0015f	b3 11		 mov	 bl, 17			; 00000011H
  00161	3a d9		 cmp	 bl, cl
  00163	1b c9		 sbb	 ecx, ecx
  00165	41		 inc	 ecx
  00166	74 0d		 je	 SHORT $LN34@SetUserSta

; 2651 : 						{
; 2652 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  00168	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  0016b	c7 44 31 3c 03
	00 00 00	 mov	 DWORD PTR [ecx+esi+60], 3

; 2653 : 						}
; 2654 : 						else

  00173	eb 0b		 jmp	 SHORT $LN49@SetUserSta
$LN34@SetUserSta:

; 2655 : 						{
; 2656 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  00175	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00178	c7 44 31 3c 04
	00 00 00	 mov	 DWORD PTR [ecx+esi+60], 4
$LN49@SetUserSta:

; 2642 : 				{
; 2643 : 					if ( i == iBridgeSubIndex )

  00180	8b 4d fc	 mov	 ecx, DWORD PTR _iBridgeSubIndex$[ebp]
  00183	39 4d 08	 cmp	 DWORD PTR tv1060[ebp], ecx
  00186	74 50		 je	 SHORT $LN50@SetUserSta

; 2644 : 					{
; 2645 : 						continue;
; 2646 : 					}
; 2647 : 
; 2648 : 					if ( gObj[iIndex].PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber )

  00188	8b 5d f8	 mov	 ebx, DWORD PTR tv803[ebp]
  0018b	8b 9b a8 02 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+680]
  00191	8b fa		 mov	 edi, edx
  00193	c1 e7 09	 shl	 edi, 9
  00196	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00199	8b 4c 31 44	 mov	 ecx, DWORD PTR [ecx+esi+68]
  0019d	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  001a3	3b 99 a8 02 00
	00		 cmp	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+680]
  001a9	75 2d		 jne	 SHORT $LN50@SetUserSta

; 2649 : 					{
; 2650 : 						if ( BC_MAP_RANGE( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].MapNumber ) != FALSE )

  001ab	0f b6 89 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  001b2	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  001b5	72 16		 jb	 SHORT $LN38@SetUserSta
  001b7	b3 11		 mov	 bl, 17			; 00000011H
  001b9	3a d9		 cmp	 bl, cl
  001bb	1b c9		 sbb	 ecx, ecx
  001bd	41		 inc	 ecx
  001be	74 0d		 je	 SHORT $LN38@SetUserSta

; 2651 : 						{
; 2652 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  001c0	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  001c3	c7 44 31 50 03
	00 00 00	 mov	 DWORD PTR [ecx+esi+80], 3

; 2653 : 						}
; 2654 : 						else

  001cb	eb 0b		 jmp	 SHORT $LN50@SetUserSta
$LN38@SetUserSta:

; 2655 : 						{
; 2656 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  001cd	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  001d0	c7 44 31 50 04
	00 00 00	 mov	 DWORD PTR [ecx+esi+80], 4
$LN50@SetUserSta:

; 2642 : 				{
; 2643 : 					if ( i == iBridgeSubIndex )

  001d8	8b 4d 08	 mov	 ecx, DWORD PTR tv1060[ebp]
  001db	41		 inc	 ecx
  001dc	3b 4d fc	 cmp	 ecx, DWORD PTR _iBridgeSubIndex$[ebp]
  001df	74 50		 je	 SHORT $LN51@SetUserSta

; 2644 : 					{
; 2645 : 						continue;
; 2646 : 					}
; 2647 : 
; 2648 : 					if ( gObj[iIndex].PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber )

  001e1	8b 5d f8	 mov	 ebx, DWORD PTR tv803[ebp]
  001e4	8b 9b a8 02 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+680]
  001ea	8b fa		 mov	 edi, edx
  001ec	c1 e7 09	 shl	 edi, 9
  001ef	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  001f2	8b 4c 31 58	 mov	 ecx, DWORD PTR [ecx+esi+88]
  001f6	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  001fc	3b 99 a8 02 00
	00		 cmp	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+680]
  00202	75 2d		 jne	 SHORT $LN51@SetUserSta

; 2649 : 					{
; 2650 : 						if ( BC_MAP_RANGE( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].MapNumber ) != FALSE )

  00204	0f b6 89 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  0020b	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0020e	72 16		 jb	 SHORT $LN42@SetUserSta
  00210	b3 11		 mov	 bl, 17			; 00000011H
  00212	3a d9		 cmp	 bl, cl
  00214	1b c9		 sbb	 ecx, ecx
  00216	41		 inc	 ecx
  00217	74 0d		 je	 SHORT $LN42@SetUserSta

; 2651 : 						{
; 2652 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  00219	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  0021c	c7 44 31 64 03
	00 00 00	 mov	 DWORD PTR [ecx+esi+100], 3

; 2653 : 						}
; 2654 : 						else

  00224	eb 0b		 jmp	 SHORT $LN51@SetUserSta
$LN42@SetUserSta:

; 2655 : 						{
; 2656 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  00226	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00229	c7 44 31 64 04
	00 00 00	 mov	 DWORD PTR [ecx+esi+100], 4
$LN51@SetUserSta:

; 2642 : 				{
; 2643 : 					if ( i == iBridgeSubIndex )

  00231	8b 4d 08	 mov	 ecx, DWORD PTR tv1060[ebp]
  00234	83 c1 02	 add	 ecx, 2
  00237	3b 4d fc	 cmp	 ecx, DWORD PTR _iBridgeSubIndex$[ebp]
  0023a	74 50		 je	 SHORT $LN52@SetUserSta

; 2644 : 					{
; 2645 : 						continue;
; 2646 : 					}
; 2647 : 
; 2648 : 					if ( gObj[iIndex].PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber )

  0023c	8b 5d f8	 mov	 ebx, DWORD PTR tv803[ebp]
  0023f	8b 9b a8 02 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+680]
  00245	8b fa		 mov	 edi, edx
  00247	c1 e7 09	 shl	 edi, 9
  0024a	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  0024d	8b 4c 31 6c	 mov	 ecx, DWORD PTR [ecx+esi+108]
  00251	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00257	3b 99 a8 02 00
	00		 cmp	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+680]
  0025d	75 2d		 jne	 SHORT $LN52@SetUserSta

; 2649 : 					{
; 2650 : 						if ( BC_MAP_RANGE( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].MapNumber ) != FALSE )

  0025f	0f b6 89 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  00266	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00269	72 16		 jb	 SHORT $LN46@SetUserSta
  0026b	b3 11		 mov	 bl, 17			; 00000011H
  0026d	3a d9		 cmp	 bl, cl
  0026f	1b c9		 sbb	 ecx, ecx
  00271	41		 inc	 ecx
  00272	74 0d		 je	 SHORT $LN46@SetUserSta

; 2651 : 						{
; 2652 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  00274	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00277	c7 44 31 78 03
	00 00 00	 mov	 DWORD PTR [ecx+esi+120], 3

; 2653 : 						}
; 2654 : 						else

  0027f	eb 0b		 jmp	 SHORT $LN52@SetUserSta
$LN46@SetUserSta:

; 2655 : 						{
; 2656 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  00281	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00284	c7 44 31 78 04
	00 00 00	 mov	 DWORD PTR [ecx+esi+120], 4
$LN52@SetUserSta:

; 2640 : 			{
; 2641 : 				for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0028c	8b 7d 08	 mov	 edi, DWORD PTR tv1060[ebp]
  0028f	83 c7 05	 add	 edi, 5
  00292	8d 4f fe	 lea	 ecx, DWORD PTR [edi-2]
  00295	83 c0 64	 add	 eax, 100		; 00000064H
  00298	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0029b	8b 4d fc	 mov	 ecx, DWORD PTR _iBridgeSubIndex$[ebp]
  0029e	89 7d 08	 mov	 DWORD PTR tv1060[ebp], edi
  002a1	0f 8c 29 fe ff
	ff		 jl	 $LL53@SetUserSta
  002a7	5f		 pop	 edi
$LN31@SetUserSta:

; 2657 : 						}
; 2658 : 					}
; 2659 : 				}
; 2660 : 			}
; 2661 : 
; 2662 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 2;

  002a8	c1 e2 09	 shl	 edx, 9
  002ab	8d 44 89 0a	 lea	 eax, DWORD PTR [ecx+ecx*4+10]
  002af	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  002b2	c7 04 30 02 00
	00 00		 mov	 DWORD PTR [eax+esi], 2
  002b9	5b		 pop	 ebx

; 2663 : 			this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS = iBridgeSubIndex;

  002ba	89 8c 32 48 01
	00 00		 mov	 DWORD PTR [edx+esi+328], ecx
  002c1	5e		 pop	 esi

; 2672 : 			break;
; 2673 : 	}
; 2674 : }

  002c2	8b e5		 mov	 esp, ebp
  002c4	5d		 pop	 ebp
  002c5	c2 08 00	 ret	 8
$LN2@SetUserSta:

; 2664 : 			break;
; 2665 : 
; 2666 : 		case 3:
; 2667 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 3;

  002c8	c1 e2 09	 shl	 edx, 9
  002cb	03 d6		 add	 edx, esi
  002cd	8d 4c 89 0a	 lea	 ecx, DWORD PTR [ecx+ecx*4+10]
  002d1	5b		 pop	 ebx
  002d2	c7 04 8a 03 00
	00 00		 mov	 DWORD PTR [edx+ecx*4], 3
  002d9	5e		 pop	 esi

; 2672 : 			break;
; 2673 : 	}
; 2674 : }

  002da	8b e5		 mov	 esp, ebp
  002dc	5d		 pop	 ebp
  002dd	c2 08 00	 ret	 8
$LN1@SetUserSta:

; 2668 : 			break;
; 2669 : 
; 2670 : 		case 4:
; 2671 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 4;

  002e0	c1 e2 09	 shl	 edx, 9
  002e3	8d 44 89 0a	 lea	 eax, DWORD PTR [ecx+ecx*4+10]
  002e7	03 d6		 add	 edx, esi
  002e9	c7 04 82 04 00
	00 00		 mov	 DWORD PTR [edx+eax*4], 4
$LN55@SetUserSta:
  002f0	5b		 pop	 ebx
$LN14@SetUserSta:
  002f1	5e		 pop	 esi

; 2672 : 			break;
; 2673 : 	}
; 2674 : }

  002f2	8b e5		 mov	 esp, ebp
  002f4	5d		 pop	 ebp
  002f5	c2 08 00	 ret	 8
$LN56@SetUserSta:
  002f8	00 00 00 00	 DD	 $LN13@SetUserSta
  002fc	00 00 00 00	 DD	 $LN12@SetUserSta
  00300	00 00 00 00	 DD	 $LN11@SetUserSta
  00304	00 00 00 00	 DD	 $LN2@SetUserSta
  00308	00 00 00 00	 DD	 $LN1@SetUserSta
?SetUserState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::SetUserState
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z	; CBloodCastle::CalcSendRewardEXP
EXTRN	?PHeadSetBE@@YAXPAEEH@Z:PROC			; PHeadSetBE
; Function compile flags: /Ogtp
;	COMDAT ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
_pMsg$158361 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iEXP$ = 12						; size = 4
?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CalcSendRewardEXP, COMDAT
; _this$ = ecx

; 3004 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx

; 3005 : 	if ( iEXP <= 0 )

  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _iEXP$[ebp]
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00018	57		 push	 edi
  00019	8b f9		 mov	 edi, ecx
  0001b	85 db		 test	 ebx, ebx
  0001d	7f 15		 jg	 SHORT $LN7@CalcSendRe
$LN14@CalcSendRe:
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi

; 3006 : 	{
; 3007 : 		return 0;

  00021	33 c0		 xor	 eax, eax
  00023	5b		 pop	 ebx

; 3055 : 	}
; 3056 : 
; 3057 : 	return iRET_EXP;
; 3058 : }

  00024	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00027	33 cd		 xor	 ecx, ebp
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
$LN7@CalcSendRe:

; 3008 : 	}
; 3009 : 
; 3010 : 	int iRET_EXP = 0;
; 3011 : 	int iCAL_EXP = iEXP;

  00034	8b c3		 mov	 eax, ebx

; 3012 : 
; 3013 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00036	85 f6		 test	 esi, esi
  00038	78 e5		 js	 SHORT $LN14@CalcSendRe
  0003a	33 c9		 xor	 ecx, ecx
  0003c	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00042	0f 9e c1	 setle	 cl
  00045	85 c9		 test	 ecx, ecx

; 3014 : 	{
; 3015 : 		return 0;

  00047	74 d6		 je	 SHORT $LN14@CalcSendRe

; 3016 : 	}
; 3017 : 
; 3018 : 	if ( gObj[iIndex].Connected < PLAYER_PLAYING )

  00049	8b ce		 mov	 ecx, esi
  0004b	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00051	80 b9 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], 3

; 3019 : 	{
; 3020 : 		return 0;

  00058	72 c5		 jb	 SHORT $LN14@CalcSendRe

; 3021 : 	}
; 3022 : 
; 3023 : 	iRET_EXP = iCAL_EXP;
; 3024 : 
; 3025 : 	if ( gObj[iIndex].Type == OBJ_USER )

  0005a	66 83 b9 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+96], 1
  00062	75 4e		 jne	 SHORT $LN4@CalcSendRe

; 3026 : 	{
; 3027 : 		while ( iCAL_EXP > 0 )
; 3028 : 		{
; 3029 : 			if ( iCAL_EXP > 0 )

  00064	85 c0		 test	 eax, eax
  00066	7e 0f		 jle	 SHORT $LN13@CalcSendRe
$LN17@CalcSendRe:

; 3030 : 			{
; 3031 : 				/*if ( gObj[iIndex].m_wExprienceRate > 0 )
; 3032 : 				{*/
; 3033 : 					iCAL_EXP = this->LevelUp(iIndex, iCAL_EXP, 4);

  00068	6a 04		 push	 4
  0006a	50		 push	 eax
  0006b	56		 push	 esi
  0006c	8b cf		 mov	 ecx, edi
  0006e	e8 00 00 00 00	 call	 ?LevelUp@CBloodCastle@@QAEHHHH@Z ; CBloodCastle::LevelUp
  00073	85 c0		 test	 eax, eax
  00075	7f f1		 jg	 SHORT $LN17@CalcSendRe
$LN13@CalcSendRe:

; 3034 : 				/*}
; 3035 : 				else
; 3036 : 				{
; 3037 : 					iEXP = 0;
; 3038 : 					iCAL_EXP = 0;
; 3039 : 					iRET_EXP = 0;
; 3040 : 				}*/
; 3041 : 			}
; 3042 : 		}
; 3043 : 
; 3044 : 		PMSG_KILLPLAYER_EXT pMsg;
; 3045 : 
; 3046 : 		PHeadSetBE((LPBYTE)&pMsg, 0x9C, sizeof(pMsg));

  00077	6a 0c		 push	 12			; 0000000cH
  00079	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$158361[ebp]
  0007c	68 9c 00 00 00	 push	 156			; 0000009cH
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 3047 : 		pMsg.NumberH = -1;
; 3048 : 		pMsg.NumberL = -1;
; 3049 : 		pMsg.ExpH = SET_NUMBERHW(iEXP);
; 3050 : 		pMsg.ExpL = SET_NUMBERLW(iEXP);
; 3051 : 		pMsg.DamageH = 0;
; 3052 : 		pMsg.DamageL = 0;
; 3053 : 
; 3054 : 		DataSend(iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00087	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$158361[ebp+1]
  0008b	52		 push	 edx
  0008c	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$158361[ebp]
  0008f	8b cb		 mov	 ecx, ebx
  00091	50		 push	 eax
  00092	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00095	56		 push	 esi
  00096	66 c7 45 f3 ff
	ff		 mov	 WORD PTR _pMsg$158361[ebp+3], 65535 ; 0000ffffH
  0009c	66 89 4d f6	 mov	 WORD PTR _pMsg$158361[ebp+6], cx
  000a0	66 89 5d f8	 mov	 WORD PTR _pMsg$158361[ebp+8], bx
  000a4	66 c7 45 fa 00
	00		 mov	 WORD PTR _pMsg$158361[ebp+10], 0
  000aa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000af	83 c4 18	 add	 esp, 24			; 00000018H
$LN4@CalcSendRe:

; 3055 : 	}
; 3056 : 
; 3057 : 	return iRET_EXP;
; 3058 : }

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	8b c3		 mov	 eax, ebx
  000b9	33 cd		 xor	 ecx, ebp
  000bb	5b		 pop	 ebx
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 08 00	 ret	 8
?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CalcSendRewardEXP
_TEXT	ENDS
PUBLIC	?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z	; CBloodCastle::CalcSendRewardZEN
EXTRN	?gObjCheckMaxZen@@YAHHH@Z:PROC			; gObjCheckMaxZen
; Function compile flags: /Ogtp
;	COMDAT ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iZEN$ = 12						; size = 4
?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CalcSendRewardZEN, COMDAT
; _this$ = ecx

; 3063 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 3064 : 	if ( iZEN <= 0 )

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _iZEN$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	7f 07		 jg	 SHORT $LN4@CalcSendRe@2

; 3065 : 	{
; 3066 : 		return 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	5b		 pop	 ebx

; 3095 : }

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
$LN4@CalcSendRe@2:
  00012	57		 push	 edi

; 3067 : 	}
; 3068 : 
; 3069 : 	int iRET_ZEN = 0;
; 3070 : 
; 3071 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00013	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00016	85 ff		 test	 edi, edi
  00018	78 0f		 js	 SHORT $LN9@CalcSendRe@2
  0001a	33 c0		 xor	 eax, eax
  0001c	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  00022	0f 9e c0	 setle	 al
  00025	85 c0		 test	 eax, eax
  00027	75 08		 jne	 SHORT $LN3@CalcSendRe@2
$LN9@CalcSendRe@2:
  00029	5f		 pop	 edi

; 3072 : 	{
; 3073 : 		return 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	5b		 pop	 ebx

; 3095 : }

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
$LN3@CalcSendRe@2:
  00031	56		 push	 esi

; 3074 : 	}
; 3075 : 
; 3076 : 	if ( gObj[iIndex].Connected < PLAYER_PLAYING )

  00032	8b f7		 mov	 esi, edi
  00034	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0003a	80 be 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+4], 3
  00041	73 09		 jae	 SHORT $LN2@CalcSendRe@2

; 3077 : 	{
; 3078 : 		return 0;

  00043	5e		 pop	 esi
  00044	5f		 pop	 edi
  00045	33 c0		 xor	 eax, eax
  00047	5b		 pop	 ebx

; 3095 : }

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN2@CalcSendRe@2:

; 3079 : 	}
; 3080 : 
; 3081 : 	if ( gObjCheckMaxZen(iIndex, iZEN) == FALSE )

  0004c	53		 push	 ebx
  0004d	57		 push	 edi
  0004e	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  00053	83 c4 08	 add	 esp, 8
  00056	85 c0		 test	 eax, eax
  00058	75 1c		 jne	 SHORT $LN1@CalcSendRe@2

; 3082 : 	{
; 3083 : 		iRET_ZEN = MAX_ZEN - gObj[iIndex].Money;

  0005a	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176]
  00060	b8 00 94 35 77	 mov	 eax, 2000000000		; 77359400H
  00065	2b c1		 sub	 eax, ecx

; 3084 : 		gObj[iIndex].Money += iRET_ZEN;

  00067	03 c8		 add	 ecx, eax
  00069	89 8e b0 00 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176], ecx
  0006f	5e		 pop	 esi
  00070	5f		 pop	 edi
  00071	5b		 pop	 ebx

; 3095 : }

  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
$LN1@CalcSendRe@2:

; 3085 : 
; 3086 : 		return iRET_ZEN;
; 3087 : 	}
; 3088 : 
; 3089 : 	gObj[iIndex].Money += iZEN;

  00076	01 9e b0 00 00
	00		 add	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176], ebx
  0007c	8b b6 b0 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+176]

; 3090 : 	iRET_ZEN = iZEN;
; 3091 : 	GCMoneySend(iIndex, gObj[iIndex].Money);

  00082	56		 push	 esi
  00083	57		 push	 edi
  00084	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00089	83 c4 08	 add	 esp, 8
  0008c	5e		 pop	 esi
  0008d	5f		 pop	 edi

; 3092 : 
; 3093 : 
; 3094 : 	return iRET_ZEN;

  0008e	8b c3		 mov	 eax, ebx
  00090	5b		 pop	 ebx

; 3095 : }

  00091	5d		 pop	 ebp
  00092	c2 08 00	 ret	 8
?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CalcSendRewardZEN
_TEXT	ENDS
PUBLIC	?DropChaosGem@CBloodCastle@@QAEXH@Z		; CBloodCastle::DropChaosGem
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
; Function compile flags: /Ogtp
;	COMDAT ?DropChaosGem@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?DropChaosGem@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::DropChaosGem, COMDAT
; _this$ = ecx

; 3102 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3103 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 5b		 js	 SHORT $LN2@DropChaosG
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 4c		 je	 SHORT $LN2@DropChaosG

; 3104 : 	{
; 3105 : 		return;
; 3106 : 	}
; 3107 : 
; 3108 : 	int iMaxHitUser = iIndex;
; 3109 : 	int iType = ::ItemGetNumberMake(12, 15);	// Chaos Gem

  0001a	6a 0f		 push	 15			; 0000000fH
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 3110 : 	ItemSerialCreateSend(gObj[iIndex].m_Index, gObj[iIndex].MapNumber + 227, gObj[iIndex].X,
; 3111 : 		gObj[iIndex].Y, iType, 0, 0, 0, 0, 0, iMaxHitUser, 0, 0);

  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	56		 push	 esi
  00028	6a 00		 push	 0
  0002a	6a 00		 push	 0
  0002c	8b ce		 mov	 ecx, esi
  0002e	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00034	0f b6 91 04 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+260]
  0003b	6a 00		 push	 0
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	50		 push	 eax
  00042	0f b6 81 06 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+262]
  00049	50		 push	 eax
  0004a	8a 81 09 01 00
	00		 mov	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  00050	52		 push	 edx
  00051	2c 1d		 sub	 al, 29			; 0000001dH
  00053	0f b6 d0	 movzx	 edx, al
  00056	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx]
  0005c	52		 push	 edx
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00063	83 c4 3c	 add	 esp, 60			; 0000003cH
$LN2@DropChaosG:
  00066	5e		 pop	 esi

; 3112 : }

  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?DropChaosGem@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::DropChaosGem
_TEXT	ENDS
PUBLIC	??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?SendRewardScore@CBloodCastle@@QAEXHHHH@Z	; CBloodCastle::SendRewardScore
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?GMRankingServerConnect@@YAHPADK@Z:PROC		; GMRankingServerConnect
EXTRN	?gDevilSquareEventServerIp@@3PADA:BYTE		; gDevilSquareEventServerIp
EXTRN	?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z:PROC ; MyWinsockBase::CreateSocket
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?Close@MyWinsockBase@@QAEHXZ:PROC		; MyWinsockBase::Close
EXTRN	?wsRServerCli@@3VwsJoinServerCli@@A:BYTE	; wsRServerCli
EXTRN	?DevilSquareEventConnect@@3HA:DWORD		; DevilSquareEventConnect
EXTRN	?IsDevilSquareEventConnected@@3HA:DWORD		; IsDevilSquareEventConnected
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
;	COMDAT ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@
CONST	SEGMENT
??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@ DB 'Can not co'
	DB	'nnect Ranking Server', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z
_TEXT	SEGMENT
_pMsg$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iSCORE$ = 12						; size = 4
_iLeftTime$ = 16					; size = 4
_iAlivePartyCount$ = 20					; size = 4
?SendRewardScore@CBloodCastle@@QAEXHHHH@Z PROC		; CBloodCastle::SendRewardScore, COMDAT
; _this$ = ecx

; 3136 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]

; 3137 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00013	85 c0		 test	 eax, eax
  00015	0f 88 1b 01 00
	00		 js	 $LN1@SendReward
  0001b	33 c9		 xor	 ecx, ecx
  0001d	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00022	0f 9e c1	 setle	 cl
  00025	85 c9		 test	 ecx, ecx
  00027	0f 84 09 01 00
	00		 je	 $LN1@SendReward

; 3138 : 	{
; 3139 : 		return;
; 3140 : 	}
; 3141 : 
; 3142 : 	PMSG_ANS_BLOODCASTLESCORE_5TH pMsg;
; 3143 : 
; 3144 : 	pMsg.h.c = 0xC1;
; 3145 : 	pMsg.h.headcode = 0x0D;
; 3146 : 	pMsg.h.size = sizeof(pMsg);
; 3147 : 	pMsg.Score = iSCORE;

  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _iSCORE$[ebp]

; 3148 : 	pMsg.BridgeNum = gObj[iIndex].m_cBloodCastleIndex;

  00030	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00036	0f be 90 02 0d
	00 00		 movsx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330]
  0003d	89 4d e8	 mov	 DWORD PTR _pMsg$[ebp+28], ecx

; 3149 : 	pMsg.Class = gObj[iIndex].Class;

  00040	0f b7 88 98 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+152]
  00047	89 55 f0	 mov	 DWORD PTR _pMsg$[ebp+36], edx

; 3150 : 	pMsg.ServerCode = gGameServerCode;

  0004a	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00051	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+32], ecx

; 3151 : 	pMsg.iLeftTime = iLeftTime;

  00054	8b 4d 10	 mov	 ecx, DWORD PTR _iLeftTime$[ebp]
  00057	89 55 e4	 mov	 DWORD PTR _pMsg$[ebp+24], edx

; 3152 : 	memcpy(pMsg.AccountID, gObj[iIndex].AccountID, MAX_ACCOUNT_LEN);

  0005a	8b 90 64 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00060	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+40], ecx
  00063	8b 88 68 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+104]
  00069	89 55 cf	 mov	 DWORD PTR _pMsg$[ebp+3], edx
  0006c	66 8b 90 6c 00
	00 00		 mov	 dx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+108]
  00073	89 4d d3	 mov	 DWORD PTR _pMsg$[ebp+7], ecx

; 3153 : 	memcpy(pMsg.GameID, gObj[iIndex].Name, MAX_ACCOUNT_LEN);

  00076	8b 88 6f 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  0007c	66 89 55 d7	 mov	 WORD PTR _pMsg$[ebp+11], dx
  00080	8b 90 73 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+115]
  00086	66 8b 80 77 00
	00 00		 mov	 ax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+119]
  0008d	66 89 45 e1	 mov	 WORD PTR _pMsg$[ebp+21], ax

; 3154 : 	pMsg.iAlivePartyCount = iAlivePartyCount;
; 3155 : 
; 3156 : 	if( ::IsDevilSquareEventConnected == FALSE && ::DevilSquareEventConnect == FALSE )

  00091	a1 00 00 00 00	 mov	 eax, DWORD PTR ?IsDevilSquareEventConnected@@3HA ; IsDevilSquareEventConnected
  00096	89 4d d9	 mov	 DWORD PTR _pMsg$[ebp+13], ecx
  00099	8b 4d 14	 mov	 ecx, DWORD PTR _iAlivePartyCount$[ebp]
  0009c	c6 45 cc c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H
  000a0	66 c7 45 cd 30
	0d		 mov	 WORD PTR _pMsg$[ebp+1], 3376 ; 00000d30H
  000a6	89 55 dd	 mov	 DWORD PTR _pMsg$[ebp+17], edx
  000a9	89 4d f8	 mov	 DWORD PTR _pMsg$[ebp+44], ecx
  000ac	85 c0		 test	 eax, eax
  000ae	75 66		 jne	 SHORT $LN3@SendReward
  000b0	39 05 00 00 00
	00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, eax ; DevilSquareEventConnect
  000b6	75 7e		 jne	 SHORT $LN1@SendReward

; 3157 : 	{
; 3158 : 		wsRServerCli.Close();

  000b8	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  000bd	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 3159 : 		wsRServerCli.CreateSocket(ghWnd);

  000c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000c8	52		 push	 edx
  000c9	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  000ce	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 3160 : 
; 3161 : 		if ( GMRankingServerConnect(gDevilSquareEventServerIp, WM_GM_RANKING_CLIENT_MSG_PROC) == FALSE )

  000d3	68 0c 04 00 00	 push	 1036			; 0000040cH
  000d8	68 00 00 00 00	 push	 OFFSET ?gDevilSquareEventServerIp@@3PADA ; gDevilSquareEventServerIp
  000dd	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  000e2	83 c4 08	 add	 esp, 8
  000e5	85 c0		 test	 eax, eax
  000e7	75 23		 jne	 SHORT $LN2@SendReward

; 3162 : 		{
; 3163 : 			::IsDevilSquareEventConnected = FALSE;
; 3164 : 			LogAdd(LOG_BLACK, "Can not connect Ranking Server");

  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@
  000ee	50		 push	 eax
  000ef	a3 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, eax ; IsDevilSquareEventConnected
  000f4	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000f9	83 c4 08	 add	 esp, 8

; 3175 : 	}
; 3176 : }

  000fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ff	33 cd		 xor	 ecx, ebp
  00101	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c2 10 00	 ret	 16			; 00000010H
$LN2@SendReward:

; 3165 : 
; 3166 : 			return;
; 3167 : 		}
; 3168 : 
; 3169 : 		::IsDevilSquareEventConnected = TRUE;

  0010c	b8 01 00 00 00	 mov	 eax, 1
  00111	a3 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, eax ; IsDevilSquareEventConnected
$LN3@SendReward:

; 3170 : 	}
; 3171 : 
; 3172 : 	if ( ::DevilSquareEventConnect == FALSE && ::IsDevilSquareEventConnected != FALSE )

  00116	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  0011d	75 17		 jne	 SHORT $LN1@SendReward
  0011f	85 c0		 test	 eax, eax
  00121	74 13		 je	 SHORT $LN1@SendReward

; 3173 : 	{
; 3174 : 		wsRServerCli.DataSend((char *)&pMsg, pMsg.h.size);

  00123	0f b6 45 cd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00127	50		 push	 eax
  00128	8d 4d cc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0012b	51		 push	 ecx
  0012c	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  00131	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
$LN1@SendReward:

; 3175 : 	}
; 3176 : }

  00136	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00139	33 cd		 xor	 ecx, ebp
  0013b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c2 10 00	 ret	 16			; 00000010H
?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ENDP		; CBloodCastle::SendRewardScore
_TEXT	ENDS
PUBLIC	?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z	; CBloodCastle::SendBridgeAnyMsg
; Function compile flags: /Ogtp
;	COMDAT ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
_iBridgeIndex$ = 16					; size = 4
?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z PROC	; CBloodCastle::SendBridgeAnyMsg, COMDAT
; _this$ = ecx

; 3184 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3185 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 10	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 5f		 js	 SHORT $LN4@SendBridge
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	74 53		 je	 SHORT $LN4@SendBridge

; 3186 : 	{
; 3187 : 		return;
; 3188 : 	}
; 3189 : 
; 3190 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	c1 e0 09	 shl	 eax, 9
  0001b	57		 push	 edi
  0001c	8d 74 08 1c	 lea	 esi, DWORD PTR [eax+ecx+28]
  00020	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  00025	83 cb ff	 or	 ebx, -1
$LL6@SendBridge:

; 3191 : 	{
; 3192 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00028	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002a	3b cb		 cmp	 ecx, ebx
  0002c	74 32		 je	 SHORT $LN5@SendBridge

; 3193 : 		{
; 3194 : 			if ( gObj[ this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].Connected == PLAYER_PLAYING )

  0002e	8b c1		 mov	 eax, ecx
  00030	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00036	80 b8 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 3
  0003d	75 21		 jne	 SHORT $LN5@SendBridge

; 3195 : 			{
; 3196 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  0003f	38 98 02 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330], bl
  00045	74 19		 je	 SHORT $LN5@SendBridge
  00047	38 98 03 0d 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3331], bl
  0004d	74 11		 je	 SHORT $LN5@SendBridge

; 3197 : 				{
; 3198 : 					DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, lpMsg, iSize);

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  00052	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00055	50		 push	 eax
  00056	52		 push	 edx
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@SendBridge:

; 3186 : 	{
; 3187 : 		return;
; 3188 : 	}
; 3189 : 
; 3190 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00060	83 c6 14	 add	 esi, 20			; 00000014H
  00063	4f		 dec	 edi
  00064	75 c2		 jne	 SHORT $LL6@SendBridge
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
$LN4@SendBridge:

; 3199 : 				}
; 3200 : 			}
; 3201 : 		}
; 3202 : 	}
; 3203 : 
; 3204 : }

  00069	5d		 pop	 ebp
  0006a	c2 0c 00	 ret	 12			; 0000000cH
?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ENDP	; CBloodCastle::SendBridgeAnyMsg
_TEXT	ENDS
PUBLIC	?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z	; CBloodCastle::SendAllUserAnyMsg
; Function compile flags: /Ogtp
;	COMDAT ?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z PROC	; CBloodCastle::SendAllUserAnyMsg, COMDAT
; _this$ = ecx

; 3211 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 3212 : 	for ( int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _iSize$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	bf 00 19 00 00	 mov	 edi, 6400		; 00001900H
  0000e	be 60 c4 16 02	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046496
$LL5@SendAllUse:

; 3213 : 	{
; 3214 : 		if ( gObj[i].Connected == PLAYER_PLAYING )

  00013	80 7e a4 03	 cmp	 BYTE PTR [esi-92], 3
  00017	75 14		 jne	 SHORT $LN4@SendAllUse

; 3215 : 		{
; 3216 : 			if ( gObj[i].Type == OBJ_USER )

  00019	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  0001d	75 0e		 jne	 SHORT $LN4@SendAllUse

; 3217 : 			{
; 3218 : 				DataSend(i, lpMsg, iSize);

  0001f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00022	53		 push	 ebx
  00023	50		 push	 eax
  00024	57		 push	 edi
  00025	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendAllUse:

; 3212 : 	for ( int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  0002d	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  00033	47		 inc	 edi
  00034	81 fe 00 53 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522496
  0003a	7c d7		 jl	 SHORT $LL5@SendAllUse
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 3219 : 			}
; 3220 : 		}
; 3221 : 	}
; 3222 : }

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z ENDP	; CBloodCastle::SendAllUserAnyMsg
_TEXT	ENDS
PUBLIC	??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@ ; `string'
PUBLIC	?SetMonsterKillCount@CBloodCastle@@QAEXH@Z	; CBloodCastle::SetMonsterKillCount
;	COMDAT ??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@
CONST	SEGMENT
??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@ DB '['
	DB	'Blood Castle] (%d) Monster Kill Count Set - Monster:%d, Curre'
	DB	'nt Monster:%d, USER TOT:%d, LIVE:%d, DEAD:%d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetMonsterKillCount@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv501 = -12						; size = 4
tv366 = -8						; size = 4
_iLIVE_USER_COUNT$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetMonsterKillCount@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetMonsterKillCount, COMDAT
; _this$ = ecx

; 3230 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3231 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	85 d2		 test	 edx, edx
  0000b	0f 88 75 01 00
	00		 js	 $LN10@SetMonster
  00011	33 c0		 xor	 eax, eax
  00013	83 fa 06	 cmp	 edx, 6
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 65 01 00
	00		 je	 $LN10@SetMonster

; 3232 : 	{
; 3233 : 		return;
; 3234 : 	}
; 3235 : 
; 3236 : 	int iTOT_USER_COUNT = 0;

  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	c1 e2 09	 shl	 edx, 9
  00026	57		 push	 edi
  00027	33 f6		 xor	 esi, esi

; 3237 : 	int iLIVE_USER_COUNT = 0;
; 3238 : 	int iKILL_USER_COUNT = 0;

  00029	33 ff		 xor	 edi, edi
  0002b	03 ca		 add	 ecx, edx
  0002d	89 75 fc	 mov	 DWORD PTR _iLIVE_USER_COUNT$[ebp], esi
  00030	89 4d f4	 mov	 DWORD PTR tv501[ebp], ecx
  00033	8d 51 30	 lea	 edx, DWORD PTR [ecx+48]
  00036	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR tv366[ebp], 2
  0003d	8d 49 00	 npad	 3
$LL48@SetMonster:

; 3241 : 	{
; 3242 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00040	8b 42 ec	 mov	 eax, DWORD PTR [edx-20]
  00043	83 f8 ff	 cmp	 eax, -1
  00046	74 2b		 je	 SHORT $LN7@SetMonster

; 3243 : 		{
; 3244 : 			iTOT_USER_COUNT++;
; 3245 : 
; 3246 : 			if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  00048	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0004e	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00055	46		 inc	 esi
  00056	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00059	72 17		 jb	 SHORT $LN43@SetMonster
  0005b	b3 11		 mov	 bl, 17			; 00000011H
  0005d	3a d9		 cmp	 bl, cl
  0005f	1b c9		 sbb	 ecx, ecx
  00061	41		 inc	 ecx
  00062	74 0e		 je	 SHORT $LN43@SetMonster

; 3247 : 			{
; 3248 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00064	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  0006b	76 05		 jbe	 SHORT $LN43@SetMonster

; 3249 : 				{
; 3250 : 					iLIVE_USER_COUNT++;

  0006d	ff 45 fc	 inc	 DWORD PTR _iLIVE_USER_COUNT$[ebp]

; 3251 : 				}
; 3252 : 				else

  00070	eb 01		 jmp	 SHORT $LN7@SetMonster
$LN43@SetMonster:

; 3253 : 				{
; 3254 : 					iKILL_USER_COUNT++;
; 3255 : 				}
; 3256 : 			}
; 3257 : 			else
; 3258 : 			{
; 3259 : 				iKILL_USER_COUNT++;

  00072	47		 inc	 edi
$LN7@SetMonster:

; 3241 : 	{
; 3242 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00073	8b 02		 mov	 eax, DWORD PTR [edx]
  00075	83 f8 ff	 cmp	 eax, -1
  00078	74 2b		 je	 SHORT $LN24@SetMonster

; 3243 : 		{
; 3244 : 			iTOT_USER_COUNT++;
; 3245 : 
; 3246 : 			if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  0007a	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00080	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00087	46		 inc	 esi
  00088	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0008b	72 17		 jb	 SHORT $LN44@SetMonster
  0008d	b3 11		 mov	 bl, 17			; 00000011H
  0008f	3a d9		 cmp	 bl, cl
  00091	1b c9		 sbb	 ecx, ecx
  00093	41		 inc	 ecx
  00094	74 0e		 je	 SHORT $LN44@SetMonster

; 3247 : 			{
; 3248 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00096	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  0009d	76 05		 jbe	 SHORT $LN44@SetMonster

; 3249 : 				{
; 3250 : 					iLIVE_USER_COUNT++;

  0009f	ff 45 fc	 inc	 DWORD PTR _iLIVE_USER_COUNT$[ebp]

; 3251 : 				}
; 3252 : 				else

  000a2	eb 01		 jmp	 SHORT $LN24@SetMonster
$LN44@SetMonster:

; 3253 : 				{
; 3254 : 					iKILL_USER_COUNT++;
; 3255 : 				}
; 3256 : 			}
; 3257 : 			else
; 3258 : 			{
; 3259 : 				iKILL_USER_COUNT++;

  000a4	47		 inc	 edi
$LN24@SetMonster:

; 3241 : 	{
; 3242 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  000a5	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000a8	83 f8 ff	 cmp	 eax, -1
  000ab	74 2b		 je	 SHORT $LN30@SetMonster

; 3243 : 		{
; 3244 : 			iTOT_USER_COUNT++;
; 3245 : 
; 3246 : 			if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  000ad	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000b3	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  000ba	46		 inc	 esi
  000bb	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  000be	72 17		 jb	 SHORT $LN45@SetMonster
  000c0	b3 11		 mov	 bl, 17			; 00000011H
  000c2	3a d9		 cmp	 bl, cl
  000c4	1b c9		 sbb	 ecx, ecx
  000c6	41		 inc	 ecx
  000c7	74 0e		 je	 SHORT $LN45@SetMonster

; 3247 : 			{
; 3248 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000c9	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  000d0	76 05		 jbe	 SHORT $LN45@SetMonster

; 3249 : 				{
; 3250 : 					iLIVE_USER_COUNT++;

  000d2	ff 45 fc	 inc	 DWORD PTR _iLIVE_USER_COUNT$[ebp]

; 3251 : 				}
; 3252 : 				else

  000d5	eb 01		 jmp	 SHORT $LN30@SetMonster
$LN45@SetMonster:

; 3253 : 				{
; 3254 : 					iKILL_USER_COUNT++;
; 3255 : 				}
; 3256 : 			}
; 3257 : 			else
; 3258 : 			{
; 3259 : 				iKILL_USER_COUNT++;

  000d7	47		 inc	 edi
$LN30@SetMonster:

; 3241 : 	{
; 3242 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  000d8	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000db	83 f8 ff	 cmp	 eax, -1
  000de	74 2b		 je	 SHORT $LN36@SetMonster

; 3243 : 		{
; 3244 : 			iTOT_USER_COUNT++;
; 3245 : 
; 3246 : 			if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  000e0	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000e6	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  000ed	46		 inc	 esi
  000ee	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  000f1	72 17		 jb	 SHORT $LN46@SetMonster
  000f3	b3 11		 mov	 bl, 17			; 00000011H
  000f5	3a d9		 cmp	 bl, cl
  000f7	1b c9		 sbb	 ecx, ecx
  000f9	41		 inc	 ecx
  000fa	74 0e		 je	 SHORT $LN46@SetMonster

; 3247 : 			{
; 3248 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000fc	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  00103	76 05		 jbe	 SHORT $LN46@SetMonster

; 3249 : 				{
; 3250 : 					iLIVE_USER_COUNT++;

  00105	ff 45 fc	 inc	 DWORD PTR _iLIVE_USER_COUNT$[ebp]

; 3251 : 				}
; 3252 : 				else

  00108	eb 01		 jmp	 SHORT $LN36@SetMonster
$LN46@SetMonster:

; 3253 : 				{
; 3254 : 					iKILL_USER_COUNT++;
; 3255 : 				}
; 3256 : 			}
; 3257 : 			else
; 3258 : 			{
; 3259 : 				iKILL_USER_COUNT++;

  0010a	47		 inc	 edi
$LN36@SetMonster:

; 3241 : 	{
; 3242 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  0010b	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0010e	83 f8 ff	 cmp	 eax, -1
  00111	74 2b		 je	 SHORT $LN42@SetMonster

; 3243 : 		{
; 3244 : 			iTOT_USER_COUNT++;
; 3245 : 
; 3246 : 			if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  00113	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00119	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00120	46		 inc	 esi
  00121	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00124	72 17		 jb	 SHORT $LN47@SetMonster
  00126	b3 11		 mov	 bl, 17			; 00000011H
  00128	3a d9		 cmp	 bl, cl
  0012a	1b c9		 sbb	 ecx, ecx
  0012c	41		 inc	 ecx
  0012d	74 0e		 je	 SHORT $LN47@SetMonster

; 3247 : 			{
; 3248 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  0012f	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  00136	76 05		 jbe	 SHORT $LN47@SetMonster

; 3249 : 				{
; 3250 : 					iLIVE_USER_COUNT++;

  00138	ff 45 fc	 inc	 DWORD PTR _iLIVE_USER_COUNT$[ebp]

; 3251 : 				}
; 3252 : 				else

  0013b	eb 01		 jmp	 SHORT $LN42@SetMonster
$LN47@SetMonster:

; 3253 : 				{
; 3254 : 					iKILL_USER_COUNT++;
; 3255 : 				}
; 3256 : 			}
; 3257 : 			else
; 3258 : 			{
; 3259 : 				iKILL_USER_COUNT++;

  0013d	47		 inc	 edi
$LN42@SetMonster:

; 3232 : 	{
; 3233 : 		return;
; 3234 : 	}
; 3235 : 
; 3236 : 	int iTOT_USER_COUNT = 0;

  0013e	83 c2 64	 add	 edx, 100		; 00000064H

; 3239 : 
; 3240 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00141	ff 4d f8	 dec	 DWORD PTR tv366[ebp]
  00144	0f 85 f6 fe ff
	ff		 jne	 $LL48@SetMonster

; 3260 : 			}
; 3261 : 
; 3262 : 		}
; 3263 : 	}
; 3264 : 
; 3265 : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT = iLIVE_USER_COUNT * 40;

  0014a	8b 4d fc	 mov	 ecx, DWORD PTR _iLIVE_USER_COUNT$[ebp]
  0014d	8b 55 f4	 mov	 edx, DWORD PTR tv501[ebp]

; 3266 : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT = 0;
; 3267 : 
; 3268 : 	LogAdd(LOG_BLACK, "[Blood Castle] (%d) Monster Kill Count Set - Monster:%d, Current Monster:%d, USER TOT:%d, LIVE:%d, DEAD:%d",
; 3269 : 		iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT,
; 3270 : 		this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT, 
; 3271 : 		iTOT_USER_COUNT, iLIVE_USER_COUNT, iKILL_USER_COUNT);

  00150	57		 push	 edi
  00151	51		 push	 ecx
  00152	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00155	03 c0		 add	 eax, eax
  00157	56		 push	 esi
  00158	03 c0		 add	 eax, eax
  0015a	03 c0		 add	 eax, eax
  0015c	6a 00		 push	 0
  0015e	50		 push	 eax
  0015f	89 82 74 01 00
	00		 mov	 DWORD PTR [edx+372], eax
  00165	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00168	40		 inc	 eax
  00169	50		 push	 eax
  0016a	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@
  0016f	6a 00		 push	 0
  00171	c7 82 78 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+376], 0
  0017b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00180	83 c4 20	 add	 esp, 32			; 00000020H
  00183	5f		 pop	 edi
  00184	5e		 pop	 esi
  00185	5b		 pop	 ebx
$LN10@SetMonster:

; 3272 : }

  00186	8b e5		 mov	 esp, ebp
  00188	5d		 pop	 ebp
  00189	c2 04 00	 ret	 4
?SetMonsterKillCount@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetMonsterKillCount
_TEXT	ENDS
PUBLIC	??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckMonsterKillCount
;	COMDAT ??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) All Monster Kill Success(Max K'
	DB	'ill Count:%d / Kill Count:%d)', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckMonsterKillCount, COMDAT
; _this$ = ecx

; 3281 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3282 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 3c		 js	 SHORT $LN1@CheckMonst
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 06	 cmp	 edx, 6
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax

; 3283 : 	{
; 3284 : 		return false;

  00014	74 30		 je	 SHORT $LN1@CheckMonst

; 3285 : 	}
; 3286 : 
; 3287 : 	if( this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT >= this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT )

  00016	8b c2		 mov	 eax, edx
  00018	c1 e0 09	 shl	 eax, 9
  0001b	03 c1		 add	 eax, ecx
  0001d	8b 88 78 01 00
	00		 mov	 ecx, DWORD PTR [eax+376]
  00023	8b 80 74 01 00
	00		 mov	 eax, DWORD PTR [eax+372]
  00029	3b c8		 cmp	 ecx, eax
  0002b	7c 19		 jl	 SHORT $LN1@CheckMonst

; 3288 : 	{
; 3289 : 		LogAdd(LOG_BLACK, "[Blood Castle][Bug Tracer] (%d) All Monster Kill Success(Max Kill Count:%d / Kill Count:%d)",
; 3290 : 			iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT,
; 3291 : 			this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT);

  0002d	51		 push	 ecx
  0002e	50		 push	 eax
  0002f	42		 inc	 edx
  00030	52		 push	 edx
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  00036	6a 00		 push	 0
  00038	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0003d	83 c4 14	 add	 esp, 20			; 00000014H

; 3292 : 
; 3293 : 		return true;

  00040	b0 01		 mov	 al, 1

; 3297 : }

  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
$LN1@CheckMonst:

; 3294 : 	}
; 3295 : 
; 3296 : 	return false;

  00046	32 c0		 xor	 al, al

; 3297 : }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckMonsterKillCount
_TEXT	ENDS
PUBLIC	?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckMonsterKillSuccess
; Function compile flags: /Ogtp
;	COMDAT ?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckMonsterKillSuccess, COMDAT
; _this$ = ecx

; 3304 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3305 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckMonst@2
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckMonst@2
$LN6@CheckMonst@2:

; 3306 : 	{
; 3307 : 		return false;

  00016	32 c0		 xor	 al, al

; 3311 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckMonst@2:

; 3308 : 	}
; 3309 : 
; 3310 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE;

  0001c	c1 e0 09	 shl	 eax, 9
  0001f	8a 84 08 60 01
	00 00		 mov	 al, BYTE PTR [eax+ecx+352]

; 3311 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckMonsterKillSuccess
_TEXT	ENDS
PUBLIC	??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	?CheckBossKillCount@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckBossKillCount
;	COMDAT ??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) All Boss Monster Kill Success('
	DB	'Max Boss Kill Count:%d / Boss Kill Count:%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckBossKillCount@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckBossKillCount@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckBossKillCount, COMDAT
; _this$ = ecx

; 3317 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3318 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 3c		 js	 SHORT $LN1@CheckBossK
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 06	 cmp	 edx, 6
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax

; 3319 : 	{
; 3320 : 		return false;

  00014	74 30		 je	 SHORT $LN1@CheckBossK

; 3321 : 	}
; 3322 : 
; 3323 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT >= this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT )

  00016	8b c2		 mov	 eax, edx
  00018	c1 e0 09	 shl	 eax, 9
  0001b	03 c1		 add	 eax, ecx
  0001d	8b 88 88 01 00
	00		 mov	 ecx, DWORD PTR [eax+392]
  00023	8b 80 84 01 00
	00		 mov	 eax, DWORD PTR [eax+388]
  00029	3b c8		 cmp	 ecx, eax
  0002b	7c 19		 jl	 SHORT $LN1@CheckBossK

; 3324 : 	{
; 3325 : 		LogAdd(LOG_BLACK, "[Blood Castle][Bug Tracer] (%d) All Boss Monster Kill Success(Max Boss Kill Count:%d / Boss Kill Count:%d)",
; 3326 : 			iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT,
; 3327 : 			this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT);

  0002d	51		 push	 ecx
  0002e	50		 push	 eax
  0002f	42		 inc	 edx
  00030	52		 push	 edx
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  00036	6a 00		 push	 0
  00038	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0003d	83 c4 14	 add	 esp, 20			; 00000014H

; 3328 : 
; 3329 : 		return true;

  00040	b0 01		 mov	 al, 1

; 3333 : }

  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
$LN1@CheckBossK:

; 3330 : 	}
; 3331 : 
; 3332 : 	return false;

  00046	32 c0		 xor	 al, al

; 3333 : }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
?CheckBossKillCount@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckBossKillCount
_TEXT	ENDS
PUBLIC	?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckBossKillSuccess
; Function compile flags: /Ogtp
;	COMDAT ?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckBossKillSuccess, COMDAT
; _this$ = ecx

; 3340 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3341 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckBossK@2
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckBossK@2
$LN6@CheckBossK@2:

; 3342 : 	{
; 3343 : 		return false;

  00016	32 c0		 xor	 al, al

; 3347 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckBossK@2:

; 3344 : 	}
; 3345 : 
; 3346 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE;

  0001c	c1 e0 09	 shl	 eax, 9
  0001f	8a 84 08 61 01
	00 00		 mov	 al, BYTE PTR [eax+ecx+353]

; 3347 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckBossKillSuccess
_TEXT	ENDS
PUBLIC	??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@ ; `string'
PUBLIC	??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@ ; `string'
PUBLIC	_iBridgeIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckEveryUserDie
;	COMDAT ??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@
CONST	SEGMENT
??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@ DB 'e'
	DB	'rror-L3 : [Blood Castle] (%d) Connection Closed UserIndex:%d,'
	DB	' SubIndex:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@
CONST	SEGMENT
??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@ DB 'e'
	DB	'rror-L3 : [Blood Castle] (%d) User Out of Bound UserIndex:%d,'
	DB	' SubIndex:%d', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$GSCopy$ = -28				; size = 4
_bRET_VAL$ = -21					; size = 1
_pMsg$158502 = -20					; size = 14
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckEveryUserDie, COMDAT
; _this$ = ecx

; 3354 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00014	8b c1		 mov	 eax, ecx

; 3361 : 
; 3362 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00016	89 5d e4	 mov	 DWORD PTR _iBridgeIndex$GSCopy$[ebp], ebx
  00019	85 db		 test	 ebx, ebx
  0001b	78 0c		 js	 SHORT $LN20@CheckEvery

; 3355 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0001d	33 c9		 xor	 ecx, ecx
  0001f	83 fb 06	 cmp	 ebx, 6
  00022	0f 9e c1	 setle	 cl
  00025	85 c9		 test	 ecx, ecx
  00027	75 13		 jne	 SHORT $LN11@CheckEvery
$LN20@CheckEvery:

; 3356 : 	{
; 3357 : 		return false;

  00029	32 c0		 xor	 al, al
  0002b	5b		 pop	 ebx

; 3403 : 				}
; 3404 : 			}
; 3405 : 		}
; 3406 : 	}
; 3407 : 
; 3408 : 	return bRET_VAL;
; 3409 : }

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002f	33 cd		 xor	 ecx, ebp
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
$LN11@CheckEvery:
  0003c	56		 push	 esi
  0003d	57		 push	 edi

; 3358 : 	}
; 3359 : 
; 3360 : 	bool bRET_VAL = true;

  0003e	8b cb		 mov	 ecx, ebx

; 3361 : 
; 3362 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00040	33 ff		 xor	 edi, edi
  00042	c1 e1 09	 shl	 ecx, 9
  00045	c6 45 eb 01	 mov	 BYTE PTR _bRET_VAL$[ebp], 1
  00049	8d 74 01 1c	 lea	 esi, DWORD PTR [ecx+eax+28]
  0004d	8d 49 00	 npad	 3
$LL23@CheckEvery:

; 3363 : 	{
; 3364 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00050	8b 06		 mov	 eax, DWORD PTR [esi]
  00052	83 f8 ff	 cmp	 eax, -1
  00055	0f 84 ae 00 00
	00		 je	 $LN9@CheckEvery

; 3365 : 		{
; 3366 : 			if ( OBJMAX_RANGE(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex) == FALSE )

  0005b	85 c0		 test	 eax, eax
  0005d	78 0e		 js	 SHORT $LN21@CheckEvery
  0005f	33 c9		 xor	 ecx, ecx
  00061	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00066	0f 9e c1	 setle	 cl
  00069	85 c9		 test	 ecx, ecx
  0006b	75 1a		 jne	 SHORT $LN6@CheckEvery
$LN21@CheckEvery:

; 3367 : 			{
; 3368 : 				LogAdd(LOG_BLACK, "error-L3 : [Blood Castle] (%d) User Out of Bound UserIndex:%d, SubIndex:%d",
; 3369 : 					iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, i);

  0006d	57		 push	 edi
  0006e	50		 push	 eax
  0006f	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  00072	52		 push	 edx
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@
  00078	6a 00		 push	 0
  0007a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0007f	83 c4 14	 add	 esp, 20			; 00000014H

; 3370 : 				
; 3371 : 				continue;

  00082	e9 82 00 00 00	 jmp	 $LN9@CheckEvery
$LN6@CheckEvery:

; 3372 : 			}
; 3373 : 
; 3374 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber == (iBridgeIndex + MAP_INDEX_BLOODCASTLE1) )

  00087	8b c8		 mov	 ecx, eax
  00089	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0008f	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  00096	83 c3 0b	 add	 ebx, 11			; 0000000bH
  00099	3b d3		 cmp	 edx, ebx
  0009b	75 29		 jne	 SHORT $LN5@CheckEvery

; 3375 : 			{
; 3376 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  0009d	80 b9 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], 2

; 3379 : 				}
; 3380 : 				else

  000a4	8b 5d e4	 mov	 ebx, DWORD PTR _iBridgeIndex$GSCopy$[ebp]
  000a7	76 06		 jbe	 SHORT $LN4@CheckEvery

; 3377 : 				{
; 3378 : 					bRET_VAL = false;

  000a9	c6 45 eb 00	 mov	 BYTE PTR _bRET_VAL$[ebp], 0

; 3379 : 				}
; 3380 : 				else

  000ad	eb 5a		 jmp	 SHORT $LN9@CheckEvery
$LN4@CheckEvery:

; 3381 : 				{
; 3382 : 					LogAdd(LOG_BLACK, "error-L3 : [Blood Castle] (%d) Connection Closed UserIndex:%d, SubIndex:%d",
; 3383 : 						iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, i);

  000af	57		 push	 edi
  000b0	50		 push	 eax
  000b1	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  000b4	50		 push	 eax
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@
  000ba	6a 00		 push	 0
  000bc	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000c1	83 c4 14	 add	 esp, 20			; 00000014H

; 3384 : 				}
; 3385 : 			}
; 3386 : 			else

  000c4	eb 43		 jmp	 SHORT $LN9@CheckEvery
$LN5@CheckEvery:

; 3387 : 			{
; 3388 : 				if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg == false )

  000c6	80 7e 10 00	 cmp	 BYTE PTR [esi+16], 0
  000ca	75 3a		 jne	 SHORT $LN22@CheckEvery

; 3389 : 				{
; 3390 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = true;
; 3391 : 
; 3392 : 					PMSG_STATEBLOODCASTLE pMsg;
; 3393 : 
; 3394 : 					PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(PMSG_STATEBLOODCASTLE));

  000cc	6a 0e		 push	 14			; 0000000eH
  000ce	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$158502[ebp]
  000d1	68 9b 00 00 00	 push	 155			; 0000009bH
  000d6	51		 push	 ecx
  000d7	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1
  000db	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3395 : 					pMsg.btPlayState = 2;
; 3396 : 					pMsg.wRemainSec = 0;
; 3397 : 					pMsg.wMaxKillMonster = 0;
; 3398 : 					pMsg.wCurKillMonster = 0;
; 3399 : 					pMsg.wUserHaveWeapon = 0;
; 3400 : 					pMsg.btWeaponNum = -1;
; 3401 : 
; 3402 : 					DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  000e0	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$158502[ebp+1]
  000e4	33 c9		 xor	 ecx, ecx
  000e6	33 d2		 xor	 edx, edx
  000e8	89 4d f4	 mov	 DWORD PTR _pMsg$158502[ebp+8], ecx
  000eb	50		 push	 eax
  000ec	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$158502[ebp]
  000ef	89 55 f0	 mov	 DWORD PTR _pMsg$158502[ebp+4], edx
  000f2	8b 16		 mov	 edx, DWORD PTR [esi]
  000f4	51		 push	 ecx
  000f5	52		 push	 edx
  000f6	c6 45 ef 02	 mov	 BYTE PTR _pMsg$158502[ebp+3], 2
  000fa	c6 45 f8 ff	 mov	 BYTE PTR _pMsg$158502[ebp+12], 255 ; 000000ffH
  000fe	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00103	83 c4 18	 add	 esp, 24			; 00000018H
$LN22@CheckEvery:
  00106	8b 5d e4	 mov	 ebx, DWORD PTR _iBridgeIndex$GSCopy$[ebp]
$LN9@CheckEvery:

; 3361 : 
; 3362 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00109	47		 inc	 edi
  0010a	83 c6 14	 add	 esi, 20			; 00000014H
  0010d	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  00110	0f 8c 3a ff ff
	ff		 jl	 $LL23@CheckEvery

; 3403 : 				}
; 3404 : 			}
; 3405 : 		}
; 3406 : 	}
; 3407 : 
; 3408 : 	return bRET_VAL;
; 3409 : }

  00116	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00119	8a 45 eb	 mov	 al, BYTE PTR _bRET_VAL$[ebp]
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	33 cd		 xor	 ecx, ebp
  00120	5b		 pop	 ebx
  00121	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 04 00	 ret	 4
?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckEveryUserDie
_TEXT	ENDS
PUBLIC	??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@ ; `string'
PUBLIC	??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@ ; `string'
PUBLIC	?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckAngelKingExist
;	COMDAT ??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@
CONST	SEGMENT
??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@ DB '['
	DB	'Blood Castle] (%d) Angel King - gObjAdd() failed (no space to'
	DB	' add monster, result:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@
CONST	SEGMENT
??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@ DB '['
	DB	'Blood Castle] (%d) Angel King''s Monster Position Doesn''t Ex'
	DB	'ist', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckAngelKingExist, COMDAT
; _this$ = ecx

; 3415 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 3416 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	78 0c		 js	 SHORT $LN19@CheckAngel
  0000b	33 c0		 xor	 eax, eax
  0000d	83 ff 06	 cmp	 edi, 6
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	75 07		 jne	 SHORT $LN11@CheckAngel
$LN19@CheckAngel:

; 3417 : 	{
; 3418 : 		return false;

  00017	32 c0		 xor	 al, al
  00019	5f		 pop	 edi

; 3467 : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
$LN11@CheckAngel:

; 3419 : 	}
; 3420 : 
; 3421 : 	bool bRET_VAL = false;
; 3422 : 
; 3423 : 	if ( this->m_BridgeData[iBridgeIndex].m_iAngelKingPosNum == -1 )

  0001e	8b c7		 mov	 eax, edi
  00020	c1 e0 09	 shl	 eax, 9
  00023	83 bc 08 9c 01
	00 00 ff	 cmp	 DWORD PTR [eax+ecx+412], -1
  0002b	53		 push	 ebx
  0002c	8d 9c 08 9c 01
	00 00		 lea	 ebx, DWORD PTR [eax+ecx+412]
  00033	75 19		 jne	 SHORT $LN10@CheckAngel

; 3424 : 	{
; 3425 : 		LogAdd(LOG_BLACK, "[Blood Castle] (%d) Angel King's Monster Position Doesn't Exist",
; 3426 : 			iBridgeIndex+1);

  00035	47		 inc	 edi
  00036	57		 push	 edi
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@
  0003c	6a 00		 push	 0
  0003e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	5b		 pop	 ebx

; 3427 : 
; 3428 : 		return false;

  00047	32 c0		 xor	 al, al
  00049	5f		 pop	 edi

; 3467 : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
$LN10@CheckAngel:

; 3429 : 	}
; 3430 : 
; 3431 : 	for ( int i=0;i<OBJ_STARTUSERINDEX;i++)

  0004e	b8 60 00 00 00	 mov	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+96
  00053	b9 03 00 00 00	 mov	 ecx, 3
  00058	56		 push	 esi
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL9@CheckAngel:

; 3432 : 	{
; 3433 : 		if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_NPC )

  00060	38 48 a4	 cmp	 BYTE PTR [eax-92], cl
  00063	75 1e		 jne	 SHORT $LN8@CheckAngel
  00065	66 39 08	 cmp	 WORD PTR [eax], cx
  00068	75 19		 jne	 SHORT $LN8@CheckAngel

; 3434 : 		{
; 3435 : 			if ( gObj[i].Class == 232 )

  0006a	ba e8 00 00 00	 mov	 edx, 232		; 000000e8H
  0006f	66 39 50 38	 cmp	 WORD PTR [eax+56], dx
  00073	75 0e		 jne	 SHORT $LN8@CheckAngel

; 3436 : 			{
; 3437 : 				if (gObj[i].MapNumber == (iBridgeIndex + MAP_INDEX_BLOODCASTLE1) )

  00075	0f b6 90 a9 00
	00 00		 movzx	 edx, BYTE PTR [eax+169]
  0007c	8d 77 0b	 lea	 esi, DWORD PTR [edi+11]
  0007f	3b d6		 cmp	 edx, esi
  00081	74 4b		 je	 SHORT $LN1@CheckAngel
$LN8@CheckAngel:

; 3429 : 	}
; 3430 : 
; 3431 : 	for ( int i=0;i<OBJ_STARTUSERINDEX;i++)

  00083	05 64 15 00 00	 add	 eax, 5476		; 00001564H
  00088	3d 60 c4 16 02	 cmp	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046496
  0008d	7c d1		 jl	 SHORT $LL9@CheckAngel

; 3438 : 				{
; 3439 : 					bRET_VAL = true;
; 3440 : 					break;
; 3441 : 				}
; 3442 : 			}
; 3443 : 		}
; 3444 : 	}
; 3445 : 
; 3446 : 	if ( bRET_VAL == false )
; 3447 : 	{
; 3448 : 		int result = gObjAddMonster(iBridgeIndex+MAP_INDEX_BLOODCASTLE1);

  0008f	8d 47 0b	 lea	 eax, DWORD PTR [edi+11]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00098	0f bf f0	 movsx	 esi, ax
  0009b	83 c4 04	 add	 esp, 4

; 3449 : 
; 3450 : 		if ( result >= 0 )

  0009e	85 f6		 test	 esi, esi
  000a0	78 35		 js	 SHORT $LN2@CheckAngel

; 3451 : 		{
; 3452 : 			gObjSetPosMonster(result, this->m_BridgeData[iBridgeIndex].m_iAngelKingPosNum);

  000a2	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000a4	51		 push	 ecx
  000a5	56		 push	 esi
  000a6	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 3453 : 			gObjSetMonster(result, 232);

  000ab	68 e8 00 00 00	 push	 232			; 000000e8H
  000b0	56		 push	 esi
  000b1	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 3454 : 			gObj[result].m_cBloodCastleIndex = gObj[result].MapNumber - MAP_INDEX_BLOODCASTLE1;

  000b6	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  000bc	8a 96 09 01 00
	00		 mov	 dl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]
  000c2	83 c4 10	 add	 esp, 16			; 00000010H
  000c5	80 ea 0b	 sub	 dl, 11			; 0000000bH
  000c8	88 96 02 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3330], dl
$LN1@CheckAngel:

; 3463 : 		}
; 3464 : 	}
; 3465 : 
; 3466 : 	return bRET_VAL;

  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	b0 01		 mov	 al, 1
  000d2	5f		 pop	 edi

; 3467 : }

  000d3	5d		 pop	 ebp
  000d4	c2 04 00	 ret	 4
$LN2@CheckAngel:

; 3455 : 			bRET_VAL = true;
; 3456 : 		}
; 3457 : 		else
; 3458 : 		{
; 3459 : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) Angel King - gObjAdd() failed (no space to add monster, result:%d)",
; 3460 : 				iBridgeIndex+1, result);

  000d7	56		 push	 esi
  000d8	47		 inc	 edi
  000d9	57		 push	 edi
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@
  000df	6a 00		 push	 0
  000e1	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000e6	83 c4 10	 add	 esp, 16			; 00000010H
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx

; 3461 : 
; 3462 : 			return false;

  000eb	32 c0		 xor	 al, al
  000ed	5f		 pop	 edi

; 3467 : }

  000ee	5d		 pop	 ebp
  000ef	c2 04 00	 ret	 4
?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckAngelKingExist
_TEXT	ENDS
PUBLIC	?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetWhoGotUltimateWeapon
; Function compile flags: /Ogtp
;	COMDAT ?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv271 = -12						; size = 4
_iBridgeUserIndex$ = -8					; size = 4
tv89 = -4						; size = 4
tv379 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWhoGotUltimateWeapon, COMDAT
; _this$ = ecx

; 3475 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3476 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	85 c0		 test	 eax, eax
  0000b	78 0c		 js	 SHORT $LN32@GetWhoGotU
  0000d	33 d2		 xor	 edx, edx
  0000f	83 f8 06	 cmp	 eax, 6
  00012	0f 9e c2	 setle	 dl
  00015	85 d2		 test	 edx, edx
  00017	75 09		 jne	 SHORT $LN16@GetWhoGotU
$LN32@GetWhoGotU:

; 3477 : 	{
; 3478 : 		return -1;

  00019	83 c8 ff	 or	 eax, -1

; 3528 : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN16@GetWhoGotU:
  00022	c1 e0 09	 shl	 eax, 9

; 3479 : 	}
; 3480 : 
; 3481 : 	int iBridgeUserIndex = -1;

  00025	03 c1		 add	 eax, ecx
  00027	53		 push	 ebx
  00028	89 45 f4	 mov	 DWORD PTR tv271[ebp], eax
  0002b	83 c0 1c	 add	 eax, 28			; 0000001cH
  0002e	56		 push	 esi
  0002f	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iBridgeUserIndex$[ebp], -1
  00036	89 45 08	 mov	 DWORD PTR tv379[ebp], eax
  00039	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR tv89[ebp], 10	; 0000000aH
  00040	57		 push	 edi
$LL34@GetWhoGotU:

; 3484 : 	{
; 3485 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  00041	8b 18		 mov	 ebx, DWORD PTR [eax]

; 3486 : 
; 3487 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  00043	85 db		 test	 ebx, ebx
  00045	0f 88 b6 00 00
	00		 js	 $LN14@GetWhoGotU
  0004b	33 c0		 xor	 eax, eax
  0004d	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  00053	0f 9e c0	 setle	 al
  00056	85 c0		 test	 eax, eax
  00058	0f 84 a3 00 00
	00		 je	 $LN14@GetWhoGotU

; 3488 : 		{
; 3489 : 			continue;
; 3490 : 		}
; 3491 : 
; 3492 : 		if( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  0005e	8b fb		 mov	 edi, ebx
  00060	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00066	66 83 bf 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+96], 1
  0006e	0f 85 8d 00 00
	00		 jne	 $LN14@GetWhoGotU
  00074	80 bf 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+4], 2
  0007b	0f 86 80 00 00
	00		 jbe	 $LN14@GetWhoGotU

; 3493 : 		{
; 3494 : 			continue;
; 3495 : 		}
; 3496 : 
; 3497 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  00081	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+265]
  00088	3c 0b		 cmp	 al, 11			; 0000000bH
  0008a	72 75		 jb	 SHORT $LN14@GetWhoGotU
  0008c	b1 11		 mov	 cl, 17			; 00000011H
  0008e	3a c8		 cmp	 cl, al
  00090	1b c0		 sbb	 eax, eax
  00092	40		 inc	 eax
  00093	74 6c		 je	 SHORT $LN14@GetWhoGotU

; 3498 : 		{
; 3499 : 			continue;
; 3500 : 		}
; 3501 : 
; 3502 : 		for ( int x=0;x<INVENTORY_SIZE;x++)

  00095	33 f6		 xor	 esi, esi
  00097	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL8@GetWhoGotU:

; 3503 : 		{
; 3504 : 			if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  000a0	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3212]
  000a6	03 ce		 add	 ecx, esi
  000a8	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ad	83 f8 01	 cmp	 eax, 1
  000b0	75 3c		 jne	 SHORT $LN7@GetWhoGotU

; 3505 : 			{
; 3506 : 				if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  000b2	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3212]
  000b8	b8 13 1a 00 00	 mov	 eax, 6675		; 00001a13H
  000bd	66 39 44 31 06	 cmp	 WORD PTR [ecx+esi+6], ax
  000c2	75 2a		 jne	 SHORT $LN7@GetWhoGotU

; 3507 : 				{
; 3508 : 					int iLEVEL = gObj[iIndex].pInventory[x].m_Level;

  000c4	0f bf 44 31 08	 movsx	 eax, WORD PTR [ecx+esi+8]

; 3509 : 
; 3510 : 					if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  000c9	85 c0		 test	 eax, eax
  000cb	78 21		 js	 SHORT $LN7@GetWhoGotU
  000cd	33 d2		 xor	 edx, edx
  000cf	83 f8 02	 cmp	 eax, 2
  000d2	0f 9e c2	 setle	 dl
  000d5	8b c2		 mov	 eax, edx
  000d7	85 c0		 test	 eax, eax
  000d9	74 13		 je	 SHORT $LN7@GetWhoGotU

; 3511 : 					{
; 3512 : 						if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL != -1 )

  000db	8b 45 f4	 mov	 eax, DWORD PTR tv271[ebp]
  000de	8b 80 90 01 00
	00		 mov	 eax, DWORD PTR [eax+400]
  000e4	83 f8 ff	 cmp	 eax, -1
  000e7	74 05		 je	 SHORT $LN7@GetWhoGotU

; 3513 : 						{
; 3514 : 							if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == gObj[iIndex].pInventory[x].m_Number )

  000e9	3b 04 31	 cmp	 eax, DWORD PTR [ecx+esi]
  000ec	74 10		 je	 SHORT $LN29@GetWhoGotU
$LN7@GetWhoGotU:

; 3498 : 		{
; 3499 : 			continue;
; 3500 : 		}
; 3501 : 
; 3502 : 		for ( int x=0;x<INVENTORY_SIZE;x++)

  000ee	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  000f4	81 fe e0 46 00
	00		 cmp	 esi, 18144		; 000046e0H
  000fa	7c a4		 jl	 SHORT $LL8@GetWhoGotU

; 3513 : 						{
; 3514 : 							if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == gObj[iIndex].pInventory[x].m_Number )

  000fc	eb 03		 jmp	 SHORT $LN14@GetWhoGotU
$LN29@GetWhoGotU:

; 3515 : 							{
; 3516 : 								iBridgeUserIndex = iIndex;

  000fe	89 5d f8	 mov	 DWORD PTR _iBridgeUserIndex$[ebp], ebx
$LN14@GetWhoGotU:

; 3482 : 
; 3483 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00101	8b 45 08	 mov	 eax, DWORD PTR tv379[ebp]
  00104	83 c0 14	 add	 eax, 20			; 00000014H
  00107	ff 4d fc	 dec	 DWORD PTR tv89[ebp]
  0010a	89 45 08	 mov	 DWORD PTR tv379[ebp], eax
  0010d	0f 85 2e ff ff
	ff		 jne	 $LL34@GetWhoGotU

; 3517 : 								break;
; 3518 : 							}
; 3519 : 						}
; 3520 : 					}
; 3521 : 				}
; 3522 : 			}
; 3523 : 		}
; 3524 : 
; 3525 : 	}
; 3526 : 
; 3527 : 	return iBridgeUserIndex;

  00113	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeUserIndex$[ebp]
  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx

; 3528 : }

  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c2 04 00	 ret	 4
?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWhoGotUltimateWeapon
_TEXT	ENDS
PUBLIC	?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetCurrentLiveUserCount
; Function compile flags: /Ogtp
;	COMDAT ?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv558 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetCurrentLiveUserCount, COMDAT
; _this$ = ecx

; 3536 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3537 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0c		 js	 SHORT $LN40@GetCurrent@2
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 06	 cmp	 edx, 6
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	75 07		 jne	 SHORT $LN8@GetCurrent@2
$LN40@GetCurrent@2:

; 3538 : 	{
; 3539 : 		return -1;

  00016	83 c8 ff	 or	 eax, -1

; 3570 : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN8@GetCurrent@2:
  0001d	53		 push	 ebx
  0001e	56		 push	 esi
  0001f	57		 push	 edi

; 3540 : 	}
; 3541 : 
; 3542 : 	int iRetLiveUserCount = 0;

  00020	33 ff		 xor	 edi, edi
  00022	c1 e2 09	 shl	 edx, 9
  00025	8d 74 0a 30	 lea	 esi, DWORD PTR [edx+ecx+48]
  00029	c7 45 08 02 00
	00 00		 mov	 DWORD PTR tv558[ebp], 2
  00030	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
$LL46@GetCurrent@2:

; 3545 : 	{
; 3546 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  00033	8b 4e ec	 mov	 ecx, DWORD PTR [esi-20]

; 3547 : 
; 3548 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  00036	85 c9		 test	 ecx, ecx
  00038	78 3e		 js	 SHORT $LN6@GetCurrent@2
  0003a	33 d2		 xor	 edx, edx
  0003c	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  00042	0f 9e c2	 setle	 dl
  00045	85 d2		 test	 edx, edx
  00047	74 2f		 je	 SHORT $LN6@GetCurrent@2

; 3549 : 		{
; 3550 : 			continue;
; 3551 : 		}
; 3552 : 
; 3553 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  00049	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0004f	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  00056	80 fa 0b	 cmp	 dl, 11			; 0000000bH
  00059	72 1d		 jb	 SHORT $LN6@GetCurrent@2
  0005b	b3 11		 mov	 bl, 17			; 00000011H
  0005d	3a da		 cmp	 bl, dl
  0005f	1b d2		 sbb	 edx, edx
  00061	42		 inc	 edx
  00062	74 14		 je	 SHORT $LN6@GetCurrent@2

; 3554 : 		{
; 3555 : 			continue;
; 3556 : 		}
; 3557 : 
; 3558 : 		if( gObj[iIndex].Type != OBJ_USER  )

  00064	66 39 81 60 00
	00 00		 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+96], ax
  0006b	75 0b		 jne	 SHORT $LN6@GetCurrent@2

; 3559 : 		{
; 3560 : 			continue;
; 3561 : 		}
; 3562 : 
; 3563 : 		if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  0006d	80 b9 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], 2
  00074	76 02		 jbe	 SHORT $LN6@GetCurrent@2

; 3564 : 		{
; 3565 : 			iRetLiveUserCount++;

  00076	03 f8		 add	 edi, eax
$LN6@GetCurrent@2:

; 3545 : 	{
; 3546 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  00078	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 3547 : 
; 3548 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  0007a	85 c9		 test	 ecx, ecx
  0007c	78 3e		 js	 SHORT $LN42@GetCurrent@2
  0007e	33 d2		 xor	 edx, edx
  00080	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  00086	0f 9e c2	 setle	 dl
  00089	85 d2		 test	 edx, edx
  0008b	74 2f		 je	 SHORT $LN42@GetCurrent@2

; 3549 : 		{
; 3550 : 			continue;
; 3551 : 		}
; 3552 : 
; 3553 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  0008d	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00093	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  0009a	80 fa 0b	 cmp	 dl, 11			; 0000000bH
  0009d	72 1d		 jb	 SHORT $LN42@GetCurrent@2
  0009f	b3 11		 mov	 bl, 17			; 00000011H
  000a1	3a da		 cmp	 bl, dl
  000a3	1b d2		 sbb	 edx, edx
  000a5	42		 inc	 edx
  000a6	74 14		 je	 SHORT $LN42@GetCurrent@2

; 3554 : 		{
; 3555 : 			continue;
; 3556 : 		}
; 3557 : 
; 3558 : 		if( gObj[iIndex].Type != OBJ_USER  )

  000a8	66 39 81 60 00
	00 00		 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+96], ax
  000af	75 0b		 jne	 SHORT $LN42@GetCurrent@2

; 3559 : 		{
; 3560 : 			continue;
; 3561 : 		}
; 3562 : 
; 3563 : 		if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  000b1	80 b9 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], 2
  000b8	76 02		 jbe	 SHORT $LN42@GetCurrent@2

; 3564 : 		{
; 3565 : 			iRetLiveUserCount++;

  000ba	03 f8		 add	 edi, eax
$LN42@GetCurrent@2:

; 3545 : 	{
; 3546 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  000bc	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 3547 : 
; 3548 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  000bf	85 c9		 test	 ecx, ecx
  000c1	78 3e		 js	 SHORT $LN43@GetCurrent@2
  000c3	33 d2		 xor	 edx, edx
  000c5	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  000cb	0f 9e c2	 setle	 dl
  000ce	85 d2		 test	 edx, edx
  000d0	74 2f		 je	 SHORT $LN43@GetCurrent@2

; 3549 : 		{
; 3550 : 			continue;
; 3551 : 		}
; 3552 : 
; 3553 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  000d2	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  000d8	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  000df	80 fa 0b	 cmp	 dl, 11			; 0000000bH
  000e2	72 1d		 jb	 SHORT $LN43@GetCurrent@2
  000e4	b3 11		 mov	 bl, 17			; 00000011H
  000e6	3a da		 cmp	 bl, dl
  000e8	1b d2		 sbb	 edx, edx
  000ea	42		 inc	 edx
  000eb	74 14		 je	 SHORT $LN43@GetCurrent@2

; 3554 : 		{
; 3555 : 			continue;
; 3556 : 		}
; 3557 : 
; 3558 : 		if( gObj[iIndex].Type != OBJ_USER  )

  000ed	66 39 81 60 00
	00 00		 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+96], ax
  000f4	75 0b		 jne	 SHORT $LN43@GetCurrent@2

; 3559 : 		{
; 3560 : 			continue;
; 3561 : 		}
; 3562 : 
; 3563 : 		if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  000f6	80 b9 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], 2
  000fd	76 02		 jbe	 SHORT $LN43@GetCurrent@2

; 3564 : 		{
; 3565 : 			iRetLiveUserCount++;

  000ff	03 f8		 add	 edi, eax
$LN43@GetCurrent@2:

; 3545 : 	{
; 3546 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  00101	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]

; 3547 : 
; 3548 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  00104	85 c9		 test	 ecx, ecx
  00106	78 3e		 js	 SHORT $LN44@GetCurrent@2
  00108	33 d2		 xor	 edx, edx
  0010a	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  00110	0f 9e c2	 setle	 dl
  00113	85 d2		 test	 edx, edx
  00115	74 2f		 je	 SHORT $LN44@GetCurrent@2

; 3549 : 		{
; 3550 : 			continue;
; 3551 : 		}
; 3552 : 
; 3553 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  00117	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0011d	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  00124	80 fa 0b	 cmp	 dl, 11			; 0000000bH
  00127	72 1d		 jb	 SHORT $LN44@GetCurrent@2
  00129	b3 11		 mov	 bl, 17			; 00000011H
  0012b	3a da		 cmp	 bl, dl
  0012d	1b d2		 sbb	 edx, edx
  0012f	42		 inc	 edx
  00130	74 14		 je	 SHORT $LN44@GetCurrent@2

; 3554 : 		{
; 3555 : 			continue;
; 3556 : 		}
; 3557 : 
; 3558 : 		if( gObj[iIndex].Type != OBJ_USER  )

  00132	66 39 81 60 00
	00 00		 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+96], ax
  00139	75 0b		 jne	 SHORT $LN44@GetCurrent@2

; 3559 : 		{
; 3560 : 			continue;
; 3561 : 		}
; 3562 : 
; 3563 : 		if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  0013b	80 b9 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], 2
  00142	76 02		 jbe	 SHORT $LN44@GetCurrent@2

; 3564 : 		{
; 3565 : 			iRetLiveUserCount++;

  00144	03 f8		 add	 edi, eax
$LN44@GetCurrent@2:

; 3545 : 	{
; 3546 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  00146	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]

; 3547 : 
; 3548 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  00149	85 c9		 test	 ecx, ecx
  0014b	78 3e		 js	 SHORT $LN45@GetCurrent@2
  0014d	33 d2		 xor	 edx, edx
  0014f	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  00155	0f 9e c2	 setle	 dl
  00158	85 d2		 test	 edx, edx
  0015a	74 2f		 je	 SHORT $LN45@GetCurrent@2

; 3549 : 		{
; 3550 : 			continue;
; 3551 : 		}
; 3552 : 
; 3553 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  0015c	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00162	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  00169	80 fa 0b	 cmp	 dl, 11			; 0000000bH
  0016c	72 1d		 jb	 SHORT $LN45@GetCurrent@2
  0016e	b3 11		 mov	 bl, 17			; 00000011H
  00170	3a da		 cmp	 bl, dl
  00172	1b d2		 sbb	 edx, edx
  00174	42		 inc	 edx
  00175	74 14		 je	 SHORT $LN45@GetCurrent@2

; 3554 : 		{
; 3555 : 			continue;
; 3556 : 		}
; 3557 : 
; 3558 : 		if( gObj[iIndex].Type != OBJ_USER  )

  00177	66 39 81 60 00
	00 00		 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+96], ax
  0017e	75 0b		 jne	 SHORT $LN45@GetCurrent@2

; 3559 : 		{
; 3560 : 			continue;
; 3561 : 		}
; 3562 : 
; 3563 : 		if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  00180	80 b9 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], 2
  00187	76 02		 jbe	 SHORT $LN45@GetCurrent@2

; 3564 : 		{
; 3565 : 			iRetLiveUserCount++;

  00189	03 f8		 add	 edi, eax
$LN45@GetCurrent@2:

; 3540 : 	}
; 3541 : 
; 3542 : 	int iRetLiveUserCount = 0;

  0018b	83 c6 64	 add	 esi, 100		; 00000064H

; 3543 : 
; 3544 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0018e	29 45 08	 sub	 DWORD PTR tv558[ebp], eax
  00191	0f 85 9c fe ff
	ff		 jne	 $LL46@GetCurrent@2

; 3566 : 		}
; 3567 : 	}
; 3568 : 
; 3569 : 	return iRetLiveUserCount;

  00197	8b c7		 mov	 eax, edi
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
  0019b	5b		 pop	 ebx

; 3570 : }

  0019c	5d		 pop	 ebp
  0019d	c2 04 00	 ret	 4
?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetCurrentLiveUserCount
_TEXT	ENDS
PUBLIC	??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@ ; `string'
PUBLIC	_iItemPos$GSCopy$
PUBLIC	_iIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z	; CBloodCastle::DropItemDirectly
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?LevelSmallConvert@@YAEHH@Z:PROC		; LevelSmallConvert
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?gObjMakePreviewCharSet@@YAXH@Z:PROC		; gObjMakePreviewCharSet
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:BYTE		; gObjUseSkill
EXTRN	?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHE@Z:PROC	; MapClass::ItemDrop
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
;	COMDAT ??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@
CONST	SEGMENT
??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@ DB '['
	DB	'Blood Castle] [%s][%s] DropItemDirectly() failed (iBridgeInde'
	DB	'x wrong - %d)', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z
_TEXT	SEGMENT
_Option3$ = -76						; size = 1
_dur$ = -72						; size = 4
_NOption$ = -68						; size = 1
_PetExp$ = -64						; size = 4
_SOption$ = -60						; size = 1
_Option1$ = -56						; size = 1
_type$ = -52						; size = 4
_level$ = -48						; size = 4
_Option2$ = -44						; size = 1
_iItemPos$GSCopy$ = -40					; size = 4
_pResult$ = -36						; size = 5
_iIndex$GSCopy$ = -28					; size = 4
_pMsg$158602 = -24					; size = 12
_NewOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_iItemType$ = 16					; size = 4
_iItemPos$ = 20						; size = 4
?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z PROC		; CBloodCastle::DropItemDirectly, COMDAT
; _this$ = ecx

; 3577 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 14	 mov	 ebx, DWORD PTR _iItemPos$[ebp]
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00018	57		 push	 edi

; 3578 : 	if ( BC_MAP_RANGE(iBridgeIndex+MAP_INDEX_BLOODCASTLE1) == FALSE )

  00019	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  0001c	8d 47 0b	 lea	 eax, DWORD PTR [edi+11]

; 3634 : 			}
; 3635 : 
; 3636 : 			::gObjMakePreviewCharSet(iIndex);

  0001f	89 75 e4	 mov	 DWORD PTR _iIndex$GSCopy$[ebp], esi
  00022	89 5d d8	 mov	 DWORD PTR _iItemPos$GSCopy$[ebp], ebx
  00025	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00028	7c 0e		 jl	 SHORT $LN13@DropItemDi

; 3578 : 	if ( BC_MAP_RANGE(iBridgeIndex+MAP_INDEX_BLOODCASTLE1) == FALSE )

  0002a	33 c9		 xor	 ecx, ecx
  0002c	83 f8 11	 cmp	 eax, 17			; 00000011H
  0002f	0f 9e c1	 setle	 cl
  00032	8b c1		 mov	 eax, ecx
  00034	85 c0		 test	 eax, eax
  00036	75 39		 jne	 SHORT $LN7@DropItemDi
$LN13@DropItemDi:

; 3579 : 	{
; 3580 : 		LogAdd(LOG_BLACK, "[Blood Castle] [%s][%s] DropItemDirectly() failed (iBridgeIndex wrong - %d)",
; 3581 : 			gObj[iIndex].AccountID, gObj[iIndex].Name, iBridgeIndex);

  00038	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0003e	57		 push	 edi
  0003f	8d 96 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00045	52		 push	 edx
  00046	8d 86 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@
  00052	6a 00		 push	 0
  00054	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00059	83 c4 14	 add	 esp, 20			; 00000014H

; 3582 : 
; 3583 : 		return false;

  0005c	33 c0		 xor	 eax, eax

; 3649 : 		}
; 3650 : 	}
; 3651 : 
; 3652 : 	return (pResult.Result);
; 3653 : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00064	33 cd		 xor	 ecx, ebp
  00066	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 10 00	 ret	 16			; 00000010H
$LN7@DropItemDi:

; 3584 : 	}
; 3585 : 
; 3586 : 	PMSG_ITEMTHROW_RESULT pResult;
; 3587 : 
; 3588 : 	PHeadSetB((LPBYTE)&pResult, 0x23, sizeof(pResult));

  00071	6a 05		 push	 5
  00073	8d 4d dc	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00076	6a 23		 push	 35			; 00000023H
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3589 : 	pResult.Result = TRUE;
; 3590 : 	pResult.Ipos = iItemPos;
; 3591 : 	int map_num = gObj[iIndex].MapNumber;
; 3592 : 	int type = gObj[iIndex].pInventory[iItemPos].m_Type;

  0007e	8b 7d d8	 mov	 edi, DWORD PTR _iItemPos$GSCopy$[ebp]
  00081	88 5d e0	 mov	 BYTE PTR _pResult$[ebp+4], bl
  00084	69 ff a8 00 00
	00		 imul	 edi, 168		; 000000a8H
  0008a	8b de		 mov	 ebx, esi
  0008c	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  00092	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3212]
  00098	0f b6 b3 09 01
	00 00		 movzx	 esi, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+265]
  0009f	03 cf		 add	 ecx, edi
  000a1	c6 45 df 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  000a5	0f bf 41 06	 movsx	 eax, WORD PTR [ecx+6]

; 3593 : 	int level = gObj[iIndex].pInventory[iItemPos].m_Level;
; 3594 : 	float dur = gObj[iIndex].pInventory[iItemPos].m_Durability;

  000a9	d9 41 24	 fld	 DWORD PTR [ecx+36]
  000ac	d9 5d b8	 fstp	 DWORD PTR _dur$[ebp]
  000af	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b6	89 45 cc	 mov	 DWORD PTR _type$[ebp], eax
  000b9	89 55 d0	 mov	 DWORD PTR _level$[ebp], edx

; 3595 : 	BOOL ret = gObj[iIndex].pInventory[iItemPos].IsItem();

  000bc	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem

; 3596 : 	BYTE Option1 = gObj[iIndex].pInventory[iItemPos].m_Option1;

  000c1	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3212]
  000c7	0f b6 4c 38 78	 movzx	 ecx, BYTE PTR [eax+edi+120]

; 3597 : 	BYTE Option2 = gObj[iIndex].pInventory[iItemPos].m_Option2;

  000cc	0f b6 54 38 79	 movzx	 edx, BYTE PTR [eax+edi+121]
  000d1	03 c7		 add	 eax, edi
  000d3	88 4d c8	 mov	 BYTE PTR _Option1$[ebp], cl

; 3598 : 	BYTE Option3 = gObj[iIndex].pInventory[iItemPos].m_Option3;

  000d6	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  000da	88 55 d4	 mov	 BYTE PTR _Option2$[ebp], dl

; 3599 : 	BYTE NOption = gObj[iIndex].pInventory[iItemPos].m_NewOption;

  000dd	0f b6 50 7b	 movzx	 edx, BYTE PTR [eax+123]

; 3600 : 	DWORD s_num = gObj[iIndex].pInventory[iItemPos].m_Number;
; 3601 : 	BYTE NewOption[MAX_EXOPTION_SIZE];
; 3602 : 	::ItemIsBufExOption(NewOption, &gObj[iIndex].pInventory[iItemPos]);

  000e1	50		 push	 eax
  000e2	8d 45 f4	 lea	 eax, DWORD PTR _NewOption$[ebp]
  000e5	50		 push	 eax
  000e6	88 4d b4	 mov	 BYTE PTR _Option3$[ebp], cl
  000e9	88 55 bc	 mov	 BYTE PTR _NOption$[ebp], dl
  000ec	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 3603 : 	int PetLevel = gObj[iIndex].pInventory[iItemPos].m_PetItem_Level;

  000f1	8b 83 8c 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3212]

; 3604 : 	int PetExp = gObj[iIndex].pInventory[iItemPos].m_PetItem_Exp;

  000f7	8b 94 38 a4 00
	00 00		 mov	 edx, DWORD PTR [eax+edi+164]

; 3605 : 	BYTE SOption = gObj[iIndex].pInventory[iItemPos].m_SetOption;
; 3606 : 	int item_number = gObj[iIndex].pInventory[iItemPos].m_Number;
; 3607 : 	char szItemName[50] = "Item";
; 3608 : 	int aAntiLootIndex = -1;
; 3609 : 
; 3610 : 	if ( MapC[map_num].ItemDrop(type, level, dur, gObj[iIndex].X, gObj[iIndex].Y,Option1, Option2, Option3, NOption, SOption, item_number, aAntiLootIndex, PetLevel, PetExp, 0) == TRUE )

  000fe	d9 45 b8	 fld	 DWORD PTR _dur$[ebp]
  00101	8b 8c 38 a0 00
	00 00		 mov	 ecx, DWORD PTR [eax+edi+160]
  00108	83 c4 08	 add	 esp, 8
  0010b	03 c7		 add	 eax, edi
  0010d	6a 00		 push	 0
  0010f	89 55 c0	 mov	 DWORD PTR _PetExp$[ebp], edx
  00112	0f b6 90 92 00
	00 00		 movzx	 edx, BYTE PTR [eax+146]
  00119	8b 00		 mov	 eax, DWORD PTR [eax]
  0011b	88 55 c4	 mov	 BYTE PTR _SOption$[ebp], dl
  0011e	8b 55 c0	 mov	 edx, DWORD PTR _PetExp$[ebp]
  00121	52		 push	 edx
  00122	8b 55 b4	 mov	 edx, DWORD PTR _Option3$[ebp]
  00125	51		 push	 ecx
  00126	8b 4d bc	 mov	 ecx, DWORD PTR _NOption$[ebp]
  00129	6a ff		 push	 -1
  0012b	50		 push	 eax
  0012c	8b 45 c4	 mov	 eax, DWORD PTR _SOption$[ebp]
  0012f	50		 push	 eax
  00130	8b 45 d4	 mov	 eax, DWORD PTR _Option2$[ebp]
  00133	51		 push	 ecx
  00134	8b 4d c8	 mov	 ecx, DWORD PTR _Option1$[ebp]
  00137	52		 push	 edx
  00138	0f bf 93 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+262]
  0013f	50		 push	 eax
  00140	0f bf 83 04 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+260]
  00147	51		 push	 ecx
  00148	52		 push	 edx
  00149	8b 55 cc	 mov	 edx, DWORD PTR _type$[ebp]
  0014c	50		 push	 eax
  0014d	51		 push	 ecx
  0014e	8b 4d d0	 mov	 ecx, DWORD PTR _level$[ebp]
  00151	d9 1c 24	 fstp	 DWORD PTR [esp]
  00154	51		 push	 ecx
  00155	8b ce		 mov	 ecx, esi
  00157	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  0015d	52		 push	 edx
  0015e	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00164	e8 00 00 00 00	 call	 ?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHE@Z ; MapClass::ItemDrop
  00169	83 f8 01	 cmp	 eax, 1
  0016c	75 16		 jne	 SHORT $LN6@DropItemDi

; 3611 : 	{
; 3612 : 		::gObjInventoryDeleteItem(iIndex, iItemPos);

  0016e	8b 45 d8	 mov	 eax, DWORD PTR _iItemPos$GSCopy$[ebp]
  00171	8b 4d e4	 mov	 ecx, DWORD PTR _iIndex$GSCopy$[ebp]
  00174	50		 push	 eax
  00175	51		 push	 ecx
  00176	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  0017b	83 c4 08	 add	 esp, 8

; 3613 : 		pResult.Result = TRUE;

  0017e	c6 45 df 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 3614 : 
; 3615 : 		/*LogAddTD(lMsg.Get(MSGGET(1, 223)), gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].MapNumber,
; 3616 : 			gObj[iIndex].X, gObj[iIndex].Y, s_num, szItemName, type, level, Option1, Option2, Option3, (int)dur, NewOption[0],
; 3617 : 			NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6], SOption,
; 3618 : 			ItemEffectEx>>7, ItemExOption, ItemExLevel);*/
; 3619 : 	}
; 3620 : 	else

  00182	eb 04		 jmp	 SHORT $LN5@DropItemDi
$LN6@DropItemDi:

; 3621 : 	{
; 3622 : 		pResult.Result = FALSE;

  00184	c6 45 df 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN5@DropItemDi:

; 3623 : 	}
; 3624 : 
; 3625 : 	DataSend(iIndex, (UCHAR*)&pResult, pResult.h.size);

  00188	0f b6 55 dd	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0018c	8b 4d e4	 mov	 ecx, DWORD PTR _iIndex$GSCopy$[ebp]
  0018f	52		 push	 edx
  00190	8d 45 dc	 lea	 eax, DWORD PTR _pResult$[ebp]
  00193	50		 push	 eax
  00194	51		 push	 ecx
  00195	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0019a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3626 : 
; 3627 : 	if ( pResult.Result == TRUE )

  0019d	80 7d df 01	 cmp	 BYTE PTR _pResult$[ebp+3], 1
  001a1	0f 85 b2 00 00
	00		 jne	 $LN3@DropItemDi

; 3628 : 	{
; 3629 : 		if ( iItemPos < INVENTORY_BAG_START )

  001a7	8b 45 d8	 mov	 eax, DWORD PTR _iItemPos$GSCopy$[ebp]
  001aa	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  001ad	0f 8d a6 00 00
	00		 jge	 $LN3@DropItemDi

; 3630 : 		{
; 3631 : 			if ( iItemPos== 10 || iItemPos == 11 )

  001b3	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  001b6	74 05		 je	 SHORT $LN1@DropItemDi
  001b8	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  001bb	75 0e		 jne	 SHORT $LN2@DropItemDi
$LN1@DropItemDi:

; 3632 : 			{
; 3633 : 				gObjUseSkill.SkillChangeUse(iIndex);

  001bd	8b 55 e4	 mov	 edx, DWORD PTR _iIndex$GSCopy$[ebp]
  001c0	52		 push	 edx
  001c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  001c6	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN2@DropItemDi:

; 3634 : 			}
; 3635 : 
; 3636 : 			::gObjMakePreviewCharSet(iIndex);

  001cb	8b 45 e4	 mov	 eax, DWORD PTR _iIndex$GSCopy$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 3637 : 
; 3638 : 			PMSG_USEREQUIPMENTCHANGED pMsg;
; 3639 : 
; 3640 : 			PHeadSetB((LPBYTE)&pMsg, 0x25, sizeof(PMSG_USEREQUIPMENTCHANGED));

  001d4	6a 0c		 push	 12			; 0000000cH
  001d6	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$158602[ebp]
  001d9	6a 25		 push	 37			; 00000025H
  001db	51		 push	 ecx
  001dc	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3641 : 			pMsg.NumberH = SET_NUMBERH(iIndex);

  001e1	8b 45 e4	 mov	 eax, DWORD PTR _iIndex$GSCopy$[ebp]

; 3642 : 			pMsg.NumberL = SET_NUMBERL(iIndex);
; 3643 : 			ItemByteConvert(pMsg.ItemInfo, gObj[iIndex].pInventory[iItemPos]);

  001e4	8b b3 8c 0c 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+3212]
  001ea	8b d0		 mov	 edx, eax
  001ec	88 45 ec	 mov	 BYTE PTR _pMsg$158602[ebp+4], al
  001ef	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  001f5	c1 ea 08	 shr	 edx, 8
  001f8	03 f7		 add	 esi, edi
  001fa	8d 45 ed	 lea	 eax, DWORD PTR _pMsg$158602[ebp+5]
  001fd	8b fc		 mov	 edi, esp
  001ff	88 55 eb	 mov	 BYTE PTR _pMsg$158602[ebp+3], dl
  00202	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00207	50		 push	 eax
  00208	f3 a5		 rep movsd
  0020a	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 3644 : 			pMsg.ItemInfo[I_OPTION] = iItemPos * 16; // iItemPos << 16;

  0020f	8b 45 d8	 mov	 eax, DWORD PTR _iItemPos$GSCopy$[ebp]

; 3645 : 			pMsg.ItemInfo[I_OPTION] |= LevelSmallConvert(iIndex, iItemPos) & 0x0F;

  00212	8b 55 e4	 mov	 edx, DWORD PTR _iIndex$GSCopy$[ebp]
  00215	8a c8		 mov	 cl, al
  00217	50		 push	 eax
  00218	c0 e1 04	 shl	 cl, 4
  0021b	52		 push	 edx
  0021c	88 4d ee	 mov	 BYTE PTR _pMsg$158602[ebp+6], cl
  0021f	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert

; 3646 : 
; 3647 : 			DataSend(iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00224	8b 55 e4	 mov	 edx, DWORD PTR _iIndex$GSCopy$[ebp]
  00227	24 0f		 and	 al, 15			; 0000000fH
  00229	08 45 ee	 or	 BYTE PTR _pMsg$158602[ebp+6], al
  0022c	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$158602[ebp+1]
  00230	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H
  00236	50		 push	 eax
  00237	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$158602[ebp]
  0023a	51		 push	 ecx
  0023b	52		 push	 edx
  0023c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3648 : 			MsgSendV2(&gObj[iIndex], (UCHAR*)&pMsg, pMsg.h.size);

  00241	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$158602[ebp+1]
  00245	50		 push	 eax
  00246	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$158602[ebp]
  00249	51		 push	 ecx
  0024a	8d 93 00 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx]
  00250	52		 push	 edx
  00251	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00256	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@DropItemDi:

; 3649 : 		}
; 3650 : 	}
; 3651 : 
; 3652 : 	return (pResult.Result);
; 3653 : }

  00259	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025c	0f b6 45 df	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  00260	5f		 pop	 edi
  00261	5e		 pop	 esi
  00262	33 cd		 xor	 ecx, ebp
  00264	5b		 pop	 ebx
  00265	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0026a	8b e5		 mov	 esp, ebp
  0026c	5d		 pop	 ebp
  0026d	c2 10 00	 ret	 16			; 00000010H
?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z ENDP		; CBloodCastle::DropItemDirectly
_TEXT	ENDS
PUBLIC	?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckUserHaveUlimateWeapon
; Function compile flags: /Ogtp
;	COMDAT ?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckUserHaveUlimateWeapon, COMDAT
; _this$ = ecx

; 3660 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 3661 : 	if ( OBJMAX_RANGE(iIndex ) == FALSE )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	0f 88 8a 00 00
	00		 js	 $LN7@CheckUserH
  0000f	33 c0		 xor	 eax, eax
  00011	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax

; 3662 : 	{
; 3663 : 		return false;

  0001c	74 7b		 je	 SHORT $LN7@CheckUserH

; 3664 : 	}
; 3665 : 
; 3666 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  0001e	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00024	66 83 bf 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+96], 1
  0002c	75 6b		 jne	 SHORT $LN7@CheckUserH
  0002e	80 bf 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+4], 2
  00035	76 62		 jbe	 SHORT $LN7@CheckUserH

; 3669 : 	}
; 3670 : 
; 3671 : 	bool bRetVal = false;

  00037	53		 push	 ebx
  00038	56		 push	 esi
  00039	32 db		 xor	 bl, bl
  0003b	33 f6		 xor	 esi, esi
  0003d	8d 49 00	 npad	 3
$LL6@CheckUserH:

; 3674 : 	{
; 3675 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00040	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3212]
  00046	03 ce		 add	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004d	83 f8 01	 cmp	 eax, 1
  00050	75 25		 jne	 SHORT $LN5@CheckUserH

; 3676 : 		{
; 3677 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(0,19) || gObj[iIndex].pInventory[x].m_Type == ITEMGET(5,10) || gObj[iIndex].pInventory[x].m_Type == ITEMGET(4,18) )

  00052	8b 87 8c 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+3212]
  00058	0f b7 44 30 06	 movzx	 eax, WORD PTR [eax+esi+6]
  0005d	66 83 f8 13	 cmp	 ax, 19			; 00000013H
  00061	74 2b		 je	 SHORT $LN1@CheckUserH
  00063	b9 0a 0a 00 00	 mov	 ecx, 2570		; 00000a0aH
  00068	66 3b c1	 cmp	 ax, cx
  0006b	74 21		 je	 SHORT $LN1@CheckUserH
  0006d	ba 12 08 00 00	 mov	 edx, 2066		; 00000812H
  00072	66 3b c2	 cmp	 ax, dx
  00075	74 17		 je	 SHORT $LN1@CheckUserH
$LN5@CheckUserH:

; 3672 : 
; 3673 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  00077	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  0007d	81 fe e0 46 00
	00		 cmp	 esi, 18144		; 000046e0H
  00083	7c bb		 jl	 SHORT $LL6@CheckUserH

; 3680 : 				break;
; 3681 : 			}
; 3682 : 		}
; 3683 : 	}
; 3684 : 
; 3685 : 	return bRetVal;

  00085	5e		 pop	 esi
  00086	8a c3		 mov	 al, bl
  00088	5b		 pop	 ebx
  00089	5f		 pop	 edi

; 3686 : }

  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
$LN1@CheckUserH:

; 3678 : 			{
; 3679 : 				bRetVal = true;

  0008e	b3 01		 mov	 bl, 1
  00090	5e		 pop	 esi

; 3680 : 				break;
; 3681 : 			}
; 3682 : 		}
; 3683 : 	}
; 3684 : 
; 3685 : 	return bRetVal;

  00091	8a c3		 mov	 al, bl
  00093	5b		 pop	 ebx
  00094	5f		 pop	 edi

; 3686 : }

  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
$LN7@CheckUserH:

; 3667 : 	{
; 3668 : 		return false;

  00099	32 c0		 xor	 al, al
  0009b	5f		 pop	 edi

; 3686 : }

  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckUserHaveUlimateWeapon
_TEXT	ENDS
PUBLIC	?CheckWinnerExist@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckWinnerExist
; Function compile flags: /Ogtp
;	COMDAT ?CheckWinnerExist@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerExist@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckWinnerExist, COMDAT
; _this$ = ecx

; 3690 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3691 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex))

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN7@CheckWinne
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN2@CheckWinne
$LN7@CheckWinne:

; 3692 : 		return false;

  00016	32 c0		 xor	 al, al

; 3695 : 		return true;
; 3696 : 
; 3697 : 	return false;
; 3698 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@CheckWinne:

; 3693 : 
; 3694 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX != -1 )

  0001c	40		 inc	 eax
  0001d	c1 e0 09	 shl	 eax, 9
  00020	83 3c 08 ff	 cmp	 DWORD PTR [eax+ecx], -1
  00024	0f 95 c0	 setne	 al

; 3695 : 		return true;
; 3696 : 
; 3697 : 	return false;
; 3698 : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CheckWinnerExist@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckWinnerExist
_TEXT	ENDS
PUBLIC	??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	?CheckWinnerValid@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckWinnerValid
;	COMDAT ??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m'
	DB	'_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBlood'
	DB	'CastleIndex == -1) ...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_'
	DB	'BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_US'
	DB	'ER_INDEX].MapNumber)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !gObjIs'
	DB	'Connected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDE'
	DB	'X)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - m_Bridg'
	DB	'eData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_'
	DB	'LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckWinnerValid@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerValid@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckWinnerValid, COMDAT
; _this$ = ecx

; 3703 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3704 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 0c		 js	 SHORT $LN13@CheckWinne@2
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fe 06	 cmp	 esi, 6
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	75 18		 jne	 SHORT $LN6@CheckWinne@2
$LN13@CheckWinne@2:

; 3705 : 	{
; 3706 : 		LogAdd(LOG_BLACK, "[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)",
; 3707 : 			iBridgeIndex+1);

  00017	46		 inc	 esi
  00018	56		 push	 esi
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
  0001e	6a 00		 push	 0
  00020	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3708 : 
; 3709 : 		return false;

  00028	32 c0		 xor	 al, al
  0002a	5e		 pop	 esi

; 3745 : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN6@CheckWinne@2:
  0002f	57		 push	 edi

; 3710 : 	}
; 3711 : 
; 3712 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1 )

  00030	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
  00033	c1 e7 09	 shl	 edi, 9
  00036	8b 04 0f	 mov	 eax, DWORD PTR [edi+ecx]
  00039	03 f9		 add	 edi, ecx
  0003b	83 f8 ff	 cmp	 eax, -1
  0003e	75 19		 jne	 SHORT $LN5@CheckWinne@2

; 3713 : 	{
; 3714 : 		LogAdd(LOG_BLACK, "[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1",
; 3715 : 			iBridgeIndex+1);

  00040	46		 inc	 esi
  00041	56		 push	 esi
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@

; 3729 : 	{
; 3730 : 		LogAdd(LOG_BLACK, "[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1) ...",
; 3731 : 			iBridgeIndex+1);

  00047	6a 00		 push	 0
  00049	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	5f		 pop	 edi

; 3732 : 
; 3733 : 		return false;

  00052	32 c0		 xor	 al, al
  00054	5e		 pop	 esi

; 3745 : }

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN5@CheckWinne@2:

; 3716 : 
; 3717 : 		return false;
; 3718 : 	}
; 3719 : 
; 3720 : 	if ( !gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX) )

  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0005f	83 c4 04	 add	 esp, 4
  00062	85 c0		 test	 eax, eax
  00064	75 18		 jne	 SHORT $LN4@CheckWinne@2

; 3721 : 	{
; 3722 : 		LogAdd(LOG_BLACK, "[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !gObjIsConnected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX)",
; 3723 : 			iBridgeIndex+1);

  00066	46		 inc	 esi
  00067	56		 push	 esi
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@

; 3729 : 	{
; 3730 : 		LogAdd(LOG_BLACK, "[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1) ...",
; 3731 : 			iBridgeIndex+1);

  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	5f		 pop	 edi

; 3732 : 
; 3733 : 		return false;

  00077	32 c0		 xor	 al, al
  00079	5e		 pop	 esi

; 3745 : }

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
$LN4@CheckWinne@2:

; 3724 : 
; 3725 : 		return false;
; 3726 : 	}
; 3727 : 
; 3728 : 	if ( gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleSubIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex != iBridgeIndex )

  0007e	8b 07		 mov	 eax, DWORD PTR [edi]
  00080	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00086	8a 88 02 0d 00
	00		 mov	 cl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330]
  0008c	80 f9 ff	 cmp	 cl, -1
  0008f	74 45		 je	 SHORT $LN2@CheckWinne@2
  00091	80 b8 03 0d 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3331], -1
  00098	74 3c		 je	 SHORT $LN2@CheckWinne@2
  0009a	0f be c9	 movsx	 ecx, cl
  0009d	3b ce		 cmp	 ecx, esi
  0009f	75 35		 jne	 SHORT $LN2@CheckWinne@2

; 3734 : 	}
; 3735 : 
; 3736 : 	if ( !BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].MapNumber) )

  000a1	0f b6 80 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  000a8	3c 0b		 cmp	 al, 11			; 0000000bH
  000aa	72 09		 jb	 SHORT $LN14@CheckWinne@2
  000ac	b2 11		 mov	 dl, 17			; 00000011H
  000ae	3a d0		 cmp	 dl, al
  000b0	1b c0		 sbb	 eax, eax
  000b2	40		 inc	 eax
  000b3	75 19		 jne	 SHORT $LN1@CheckWinne@2
$LN14@CheckWinne@2:

; 3737 : 	{
; 3738 : 		LogAdd(LOG_BLACK, "[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].MapNumber)",
; 3739 : 			iBridgeIndex+1);

  000b5	46		 inc	 esi
  000b6	56		 push	 esi
  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
  000bc	6a 00		 push	 0
  000be	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	5f		 pop	 edi
  000c7	32 c0		 xor	 al, al
  000c9	5e		 pop	 esi

; 3745 : }

  000ca	5d		 pop	 ebp
  000cb	c2 04 00	 ret	 4
$LN1@CheckWinne@2:
  000ce	5f		 pop	 edi

; 3740 : 
; 3741 : 		return false;
; 3742 : 	}
; 3743 : 
; 3744 : 	return true;

  000cf	b0 01		 mov	 al, 1
  000d1	5e		 pop	 esi

; 3745 : }

  000d2	5d		 pop	 ebp
  000d3	c2 04 00	 ret	 4
$LN2@CheckWinne@2:

; 3729 : 	{
; 3730 : 		LogAdd(LOG_BLACK, "[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1) ...",
; 3731 : 			iBridgeIndex+1);

  000d6	46		 inc	 esi
  000d7	56		 push	 esi
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
  000dd	6a 00		 push	 0
  000df	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e7	5f		 pop	 edi

; 3732 : 
; 3733 : 		return false;

  000e8	32 c0		 xor	 al, al
  000ea	5e		 pop	 esi

; 3745 : }

  000eb	5d		 pop	 ebp
  000ec	c2 04 00	 ret	 4
?CheckWinnerValid@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckWinnerValid
_TEXT	ENDS
PUBLIC	?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::CheckUserWinnerParty
; Function compile flags: /Ogtp
;	COMDAT ?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::CheckUserWinnerParty, COMDAT
; _this$ = ecx

; 3751 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3752 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex))

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN11@CheckUserW
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN4@CheckUserW
$LN11@CheckUserW:

; 3753 : 		return false;

  00016	32 c0		 xor	 al, al

; 3768 : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN4@CheckUserW:
  0001c	57		 push	 edi

; 3754 : 
; 3755 : 	if ( gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX) == FALSE )

  0001d	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  00020	c1 e7 09	 shl	 edi, 9
  00023	8b 04 0f	 mov	 eax, DWORD PTR [edi+ecx]
  00026	03 f9		 add	 edi, ecx
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	75 07		 jne	 SHORT $LN3@CheckUserW

; 3756 : 		return false;

  00035	32 c0		 xor	 al, al
  00037	5f		 pop	 edi

; 3768 : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN3@CheckUserW:
  0003c	56		 push	 esi

; 3757 : 
; 3758 : 	if ( gObjIsConnected(iIndex) == FALSE )

  0003d	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00046	83 c4 04	 add	 esp, 4
  00049	85 c0		 test	 eax, eax

; 3759 : 		return false;

  0004b	74 39		 je	 SHORT $LN1@CheckUserW

; 3760 : 
; 3761 : 	int iPartyIndex1 = gObj[iIndex].PartyNumber;
; 3762 : 	int iPartyIndex2 = gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  0004d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0004f	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00055	8b b6 a8 02 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+680]
  0005b	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00061	8b 89 a8 02 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+680]

; 3763 : 
; 3764 : 	if ( OBJMAX_RANGE(iPartyIndex1) != FALSE && iPartyIndex1 == iPartyIndex2 )

  00067	85 f6		 test	 esi, esi
  00069	78 1b		 js	 SHORT $LN1@CheckUserW
  0006b	33 c0		 xor	 eax, eax
  0006d	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  00073	0f 9e c0	 setle	 al
  00076	85 c0		 test	 eax, eax
  00078	74 0c		 je	 SHORT $LN1@CheckUserW
  0007a	3b f1		 cmp	 esi, ecx
  0007c	75 08		 jne	 SHORT $LN1@CheckUserW

; 3765 : 		return true;

  0007e	5e		 pop	 esi
  0007f	b0 01		 mov	 al, 1
  00081	5f		 pop	 edi

; 3768 : }

  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
$LN1@CheckUserW:
  00086	5e		 pop	 esi

; 3766 : 
; 3767 : 	return false;

  00087	32 c0		 xor	 al, al
  00089	5f		 pop	 edi

; 3768 : }

  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::CheckUserWinnerParty
_TEXT	ENDS
PUBLIC	?CheckPartyExist@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckPartyExist
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
; Function compile flags: /Ogtp
;	COMDAT ?CheckPartyExist@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckPartyExist@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckPartyExist, COMDAT
; _this$ = ecx

; 3773 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3774 : 	if ( !gObjIsConnected(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 07		 jne	 SHORT $LN9@CheckParty
$LN21@CheckParty:

; 3775 : 		return false;

  00014	32 c0		 xor	 al, al
  00016	5e		 pop	 esi

; 3803 : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN9@CheckParty:

; 3776 : 
; 3777 : 	int iPartyIndex = gObj[iIndex].PartyNumber;

  0001b	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00021	8b 86 a8 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+680]

; 3778 : 	int iUserIndex;
; 3779 : 
; 3780 : 	if ( !OBJMAX_RANGE(iPartyIndex))

  00027	85 c0		 test	 eax, eax
  00029	78 e9		 js	 SHORT $LN21@CheckParty
  0002b	33 c9		 xor	 ecx, ecx
  0002d	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00032	0f 9e c1	 setle	 cl
  00035	85 c9		 test	 ecx, ecx

; 3781 : 		return false;

  00037	74 db		 je	 SHORT $LN21@CheckParty

; 3782 : 
; 3783 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  00039	53		 push	 ebx
  0003a	57		 push	 edi
  0003b	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  0003e	c1 e7 04	 shl	 edi, 4
  00041	33 db		 xor	 ebx, ebx
  00043	81 c7 0c 00 00
	00		 add	 edi, OFFSET ?gParty@@3VPartyClass@@A+12
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL7@CheckParty:

; 3784 : 	{
; 3785 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  00050	8b 37		 mov	 esi, DWORD PTR [edi]

; 3786 : 
; 3787 : 		if ( gObjIsConnected(iUserIndex))

  00052	56		 push	 esi
  00053	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00058	83 c4 04	 add	 esp, 4
  0005b	85 c0		 test	 eax, eax
  0005d	74 47		 je	 SHORT $LN6@CheckParty

; 3788 : 		{
; 3789 : 			if ( BC_MAP_RANGE(gObj[iUserIndex].MapNumber) && BC_BRIDGE_RANGE(gObj[iUserIndex].m_cBloodCastleIndex) )

  0005f	8b c6		 mov	 eax, esi
  00061	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00067	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  0006e	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00071	72 33		 jb	 SHORT $LN6@CheckParty
  00073	b2 11		 mov	 dl, 17			; 00000011H
  00075	3a d1		 cmp	 dl, cl
  00077	1b c9		 sbb	 ecx, ecx
  00079	41		 inc	 ecx
  0007a	74 2a		 je	 SHORT $LN6@CheckParty
  0007c	8a 88 02 0d 00
	00		 mov	 cl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330]
  00082	84 c9		 test	 cl, cl
  00084	78 20		 js	 SHORT $LN6@CheckParty
  00086	33 d2		 xor	 edx, edx
  00088	80 f9 06	 cmp	 cl, 6
  0008b	0f 9e c2	 setle	 dl
  0008e	8b ca		 mov	 ecx, edx
  00090	85 c9		 test	 ecx, ecx
  00092	74 12		 je	 SHORT $LN6@CheckParty

; 3790 : 			{
; 3791 : 				if ( gObj[iUserIndex].Live == 1 )

  00094	80 b8 62 00 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+98], 1
  0009b	75 09		 jne	 SHORT $LN6@CheckParty

; 3792 : 				{
; 3793 : 					if ( gObj[iUserIndex].m_bBloodCastleComplete == false )

  0009d	80 b8 08 0d 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3336], 0
  000a4	74 12		 je	 SHORT $LN19@CheckParty
$LN6@CheckParty:

; 3782 : 
; 3783 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  000a6	43		 inc	 ebx
  000a7	83 c7 04	 add	 edi, 4
  000aa	83 fb 05	 cmp	 ebx, 5
  000ad	7c a1		 jl	 SHORT $LL7@CheckParty

; 3796 : 					}
; 3797 : 				}
; 3798 : 			}
; 3799 : 		}
; 3800 : 	}
; 3801 : 
; 3802 : 	return false;

  000af	5f		 pop	 edi
  000b0	5b		 pop	 ebx
  000b1	32 c0		 xor	 al, al
  000b3	5e		 pop	 esi

; 3803 : }

  000b4	5d		 pop	 ebp
  000b5	c2 04 00	 ret	 4
$LN19@CheckParty:
  000b8	5f		 pop	 edi
  000b9	5b		 pop	 ebx

; 3794 : 					{
; 3795 : 						return true;

  000ba	b0 01		 mov	 al, 1
  000bc	5e		 pop	 esi

; 3803 : }

  000bd	5d		 pop	 ebp
  000be	c2 04 00	 ret	 4
?CheckPartyExist@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckPartyExist
_TEXT	ENDS
PUBLIC	?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerPartyComplete
; Function compile flags: /Ogtp
;	COMDAT ?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckWinnerPartyComplete, COMDAT
; _this$ = ecx

; 3807 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3808 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN24@CheckWinne@3
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN10@CheckWinne@3
$LN24@CheckWinne@3:

; 3809 : 		return false;

  00016	32 c0		 xor	 al, al

; 3840 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN10@CheckWinne@3:
  0001c	56		 push	 esi

; 3810 : 
; 3811 : 	if ( !gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX))

  0001d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00020	c1 e6 09	 shl	 esi, 9
  00023	8b 04 0e	 mov	 eax, DWORD PTR [esi+ecx]
  00026	03 f1		 add	 esi, ecx
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	75 07		 jne	 SHORT $LN9@CheckWinne@3

; 3812 : 		return false;

  00035	32 c0		 xor	 al, al
  00037	5e		 pop	 esi

; 3840 : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
$LN9@CheckWinne@3:

; 3813 : 
; 3814 : 	int iPartyIndex = gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  0003c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003e	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00044	8b 81 a8 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+680]

; 3815 : 	int iUserIndex;
; 3816 : 
; 3817 : 	if ( !OBJMAX_RANGE(iPartyIndex))

  0004a	85 c0		 test	 eax, eax
  0004c	78 0e		 js	 SHORT $LN25@CheckWinne@3
  0004e	33 c9		 xor	 ecx, ecx
  00050	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00055	0f 9e c1	 setle	 cl
  00058	85 c9		 test	 ecx, ecx
  0005a	75 07		 jne	 SHORT $LN8@CheckWinne@3
$LN25@CheckWinne@3:

; 3818 : 		return true;	// #error why true??

  0005c	b0 01		 mov	 al, 1
  0005e	5e		 pop	 esi

; 3840 : }

  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
$LN8@CheckWinne@3:
  00063	53		 push	 ebx
  00064	57		 push	 edi

; 3819 : 
; 3820 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  00065	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  00068	c1 e7 04	 shl	 edi, 4
  0006b	33 db		 xor	 ebx, ebx
  0006d	81 c7 0c 00 00
	00		 add	 edi, OFFSET ?gParty@@3VPartyClass@@A+12
$LL7@CheckWinne@3:

; 3821 : 	{
; 3822 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  00073	8b 37		 mov	 esi, DWORD PTR [edi]

; 3823 : 
; 3824 : 		if ( gObjIsConnected(iUserIndex))

  00075	56		 push	 esi
  00076	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0007b	83 c4 04	 add	 esp, 4
  0007e	85 c0		 test	 eax, eax
  00080	74 47		 je	 SHORT $LN6@CheckWinne@3

; 3825 : 		{
; 3826 : 			if ( BC_MAP_RANGE(gObj[iUserIndex].MapNumber) && BC_BRIDGE_RANGE(gObj[iUserIndex].m_cBloodCastleIndex) )

  00082	8b c6		 mov	 eax, esi
  00084	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0008a	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00091	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00094	72 33		 jb	 SHORT $LN6@CheckWinne@3
  00096	b2 11		 mov	 dl, 17			; 00000011H
  00098	3a d1		 cmp	 dl, cl
  0009a	1b c9		 sbb	 ecx, ecx
  0009c	41		 inc	 ecx
  0009d	74 2a		 je	 SHORT $LN6@CheckWinne@3
  0009f	8a 88 02 0d 00
	00		 mov	 cl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330]
  000a5	84 c9		 test	 cl, cl
  000a7	78 20		 js	 SHORT $LN6@CheckWinne@3
  000a9	33 d2		 xor	 edx, edx
  000ab	80 f9 06	 cmp	 cl, 6
  000ae	0f 9e c2	 setle	 dl
  000b1	8b ca		 mov	 ecx, edx
  000b3	85 c9		 test	 ecx, ecx
  000b5	74 12		 je	 SHORT $LN6@CheckWinne@3

; 3827 : 			{
; 3828 : 				if ( gObj[iUserIndex].Live == 1 )

  000b7	80 b8 62 00 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+98], 1
  000be	75 09		 jne	 SHORT $LN6@CheckWinne@3

; 3829 : 				{
; 3830 : 					if ( gObj[iUserIndex].m_bBloodCastleComplete == false )

  000c0	80 b8 08 0d 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3336], 0
  000c7	74 12		 je	 SHORT $LN22@CheckWinne@3
$LN6@CheckWinne@3:

; 3819 : 
; 3820 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  000c9	43		 inc	 ebx
  000ca	83 c7 04	 add	 edi, 4
  000cd	83 fb 05	 cmp	 ebx, 5
  000d0	7c a1		 jl	 SHORT $LL7@CheckWinne@3

; 3833 : 					}
; 3834 : 				}
; 3835 : 			}
; 3836 : 		}
; 3837 : 	}
; 3838 : 
; 3839 : 	return true;

  000d2	5f		 pop	 edi
  000d3	5b		 pop	 ebx
  000d4	b0 01		 mov	 al, 1
  000d6	5e		 pop	 esi

; 3840 : }

  000d7	5d		 pop	 ebp
  000d8	c2 04 00	 ret	 4
$LN22@CheckWinne@3:
  000db	5f		 pop	 edi
  000dc	5b		 pop	 ebx

; 3831 : 					{
; 3832 : 						return false;

  000dd	32 c0		 xor	 al, al
  000df	5e		 pop	 esi

; 3840 : }

  000e0	5d		 pop	 ebp
  000e1	c2 04 00	 ret	 4
?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckWinnerPartyComplete
_TEXT	ENDS
PUBLIC	?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::SetBridgeWinner
; Function compile flags: /Ogtp
;	COMDAT ?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z PROC		; CBloodCastle::SetBridgeWinner, COMDAT
; _this$ = ecx

; 3845 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3846 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN11@SetBridgeW
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN4@SetBridgeW
$LN11@SetBridgeW:

; 3847 : 		return false;

  00016	32 c0		 xor	 al, al

; 3861 : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN4@SetBridgeW:
  0001c	56		 push	 esi

; 3848 : 
; 3849 : 	if ( gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX) != 0 )

  0001d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00020	c1 e6 09	 shl	 esi, 9
  00023	8b 04 0e	 mov	 eax, DWORD PTR [esi+ecx]
  00026	03 f1		 add	 esi, ecx
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	74 07		 je	 SHORT $LN3@SetBridgeW

; 3850 : 		return false;

  00035	32 c0		 xor	 al, al
  00037	5e		 pop	 esi

; 3861 : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN3@SetBridgeW:
  0003c	57		 push	 edi

; 3851 : 
; 3852 : 	if ( !gObjIsConnected(iIndex))

  0003d	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00040	57		 push	 edi
  00041	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00046	83 c4 04	 add	 esp, 4
  00049	85 c0		 test	 eax, eax

; 3853 : 		return false;

  0004b	74 1c		 je	 SHORT $LN12@SetBridgeW

; 3854 : 
; 3855 : 	if ( !BC_MAP_RANGE(gObj[iIndex].MapNumber))

  0004d	8b cf		 mov	 ecx, edi
  0004f	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00055	0f b6 81 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  0005c	3c 0b		 cmp	 al, 11			; 0000000bH
  0005e	72 09		 jb	 SHORT $LN12@SetBridgeW
  00060	b2 11		 mov	 dl, 17			; 00000011H
  00062	3a d0		 cmp	 dl, al
  00064	1b c0		 sbb	 eax, eax
  00066	40		 inc	 eax
  00067	75 08		 jne	 SHORT $LN1@SetBridgeW
$LN12@SetBridgeW:
  00069	5f		 pop	 edi

; 3856 : 		return false;

  0006a	32 c0		 xor	 al, al
  0006c	5e		 pop	 esi

; 3861 : }

  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
$LN1@SetBridgeW:

; 3857 : 
; 3858 : 	this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = iIndex;

  00071	89 3e		 mov	 DWORD PTR [esi], edi
  00073	5f		 pop	 edi

; 3859 : 
; 3860 : 	return true;

  00074	b0 01		 mov	 al, 1
  00076	5e		 pop	 esi

; 3861 : }

  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z ENDP		; CBloodCastle::SetBridgeWinner
_TEXT	ENDS
PUBLIC	?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount
; Function compile flags: /Ogtp
;	COMDAT ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iPartyComplete$ = 8					; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWinnerPartyCompleteCount, COMDAT
; _this$ = ecx

; 3866 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3867 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN23@GetWinnerP
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN10@GetWinnerP
$LN23@GetWinnerP:

; 3868 : 		return false;

  00016	33 c0		 xor	 eax, eax

; 3901 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN10@GetWinnerP:
  0001c	56		 push	 esi

; 3869 : 
; 3870 : 	if ( !gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX))

  0001d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00020	c1 e6 09	 shl	 esi, 9
  00023	8b 04 0e	 mov	 eax, DWORD PTR [esi+ecx]
  00026	03 f1		 add	 esi, ecx
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax

; 3871 : 		return false;

  00033	74 20		 je	 SHORT $LN24@GetWinnerP

; 3872 : 
; 3873 : 	int iPartyIndex = gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  0003d	8b 81 a8 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+680]

; 3874 : 	
; 3875 : 	if ( !OBJMAX_RANGE(iPartyIndex))

  00043	85 c0		 test	 eax, eax
  00045	78 0e		 js	 SHORT $LN24@GetWinnerP
  00047	33 c9		 xor	 ecx, ecx
  00049	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  0004e	0f 9e c1	 setle	 cl
  00051	85 c9		 test	 ecx, ecx
  00053	75 07		 jne	 SHORT $LN8@GetWinnerP
$LN24@GetWinnerP:

; 3876 : 		return false;

  00055	33 c0		 xor	 eax, eax
  00057	5e		 pop	 esi

; 3901 : }

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN8@GetWinnerP:
  0005c	53		 push	 ebx
  0005d	57		 push	 edi

; 3877 : 
; 3878 : 	int iPartyComplete=0;

  0005e	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  00061	c1 e7 04	 shl	 edi, 4
  00064	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iPartyComplete$[ebp], 0
  0006b	81 c7 0c 00 00
	00		 add	 edi, OFFSET ?gParty@@3VPartyClass@@A+12
  00071	bb 05 00 00 00	 mov	 ebx, 5
$LL7@GetWinnerP:

; 3882 : 	{
; 3883 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  00076	8b 37		 mov	 esi, DWORD PTR [edi]

; 3884 : 
; 3885 : 		if ( gObjIsConnected(iUserIndex))

  00078	56		 push	 esi
  00079	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0007e	83 c4 04	 add	 esp, 4
  00081	85 c0		 test	 eax, eax
  00083	74 4a		 je	 SHORT $LN6@GetWinnerP

; 3886 : 		{
; 3887 : 			if ( BC_MAP_RANGE(gObj[iUserIndex].MapNumber) && BC_BRIDGE_RANGE(gObj[iUserIndex].m_cBloodCastleIndex) )

  00085	8b c6		 mov	 eax, esi
  00087	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0008d	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00094	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00097	72 36		 jb	 SHORT $LN6@GetWinnerP
  00099	b2 11		 mov	 dl, 17			; 00000011H
  0009b	3a d1		 cmp	 dl, cl
  0009d	1b c9		 sbb	 ecx, ecx
  0009f	41		 inc	 ecx
  000a0	74 2d		 je	 SHORT $LN6@GetWinnerP
  000a2	8a 88 02 0d 00
	00		 mov	 cl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330]
  000a8	84 c9		 test	 cl, cl
  000aa	78 23		 js	 SHORT $LN6@GetWinnerP
  000ac	33 d2		 xor	 edx, edx
  000ae	80 f9 06	 cmp	 cl, 6
  000b1	0f 9e c2	 setle	 dl
  000b4	8b ca		 mov	 ecx, edx
  000b6	85 c9		 test	 ecx, ecx
  000b8	74 15		 je	 SHORT $LN6@GetWinnerP

; 3888 : 			{
; 3889 : 				if ( gObj[iUserIndex].Live == 1 )

  000ba	80 b8 62 00 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+98], 1
  000c1	75 0c		 jne	 SHORT $LN6@GetWinnerP

; 3890 : 				{
; 3891 : 					if ( gObj[iUserIndex].m_bBloodCastleComplete == true )

  000c3	80 b8 08 0d 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3336], 1
  000ca	75 03		 jne	 SHORT $LN6@GetWinnerP

; 3892 : 					{
; 3893 : 						iPartyComplete++;

  000cc	ff 45 08	 inc	 DWORD PTR _iPartyComplete$[ebp]
$LN6@GetWinnerP:

; 3879 : 	int iUserIndex;
; 3880 : 
; 3881 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  000cf	83 c7 04	 add	 edi, 4
  000d2	4b		 dec	 ebx
  000d3	75 a1		 jne	 SHORT $LL7@GetWinnerP

; 3894 : 					}
; 3895 : 				}
; 3896 : 			}
; 3897 : 		}
; 3898 : 	}
; 3899 : 
; 3900 : 	return iPartyComplete;

  000d5	8b 45 08	 mov	 eax, DWORD PTR _iPartyComplete$[ebp]
  000d8	5f		 pop	 edi
  000d9	5b		 pop	 ebx
  000da	5e		 pop	 esi

; 3901 : }

  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWinnerPartyCompleteCount
_TEXT	ENDS
PUBLIC	?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompletePoint
; Function compile flags: /Ogtp
;	COMDAT ?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWinnerPartyCompletePoint, COMDAT
; _this$ = ecx

; 3906 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3907 : 	int iPartyComplete = this->GetWinnerPartyCompleteCount(iBridgeIndex);

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount

; 3908 : 	iPartyComplete--;

  0000c	48		 dec	 eax

; 3909 : 
; 3910 : 	if ( CHECK_LIMIT(iPartyComplete, MAX_USER_IN_PARTY) )

  0000d	78 17		 js	 SHORT $LN1@GetWinnerP@2
  0000f	33 c9		 xor	 ecx, ecx
  00011	83 f8 04	 cmp	 eax, 4
  00014	0f 9e c1	 setle	 cl
  00017	85 c9		 test	 ecx, ecx
  00019	74 0b		 je	 SHORT $LN1@GetWinnerP@2

; 3911 : 		return g_iBC_Party_EventPoint[iPartyComplete];

  0001b	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _g_iBC_Party_EventPoint[eax*4]

; 3914 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN1@GetWinnerP@2:

; 3912 : 
; 3913 : 	return 0;

  00026	33 c0		 xor	 eax, eax

; 3914 : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWinnerPartyCompletePoint
_TEXT	ENDS
PUBLIC	?ChangeMonsterState@CBloodCastle@@QAEXHH@Z	; CBloodCastle::ChangeMonsterState
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
; Function compile flags: /Ogtp
;	COMDAT ?ChangeMonsterState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iAddDefense$ = 8					; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?ChangeMonsterState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::ChangeMonsterState, COMDAT
; _this$ = ecx

; 3918 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3919 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	57		 push	 edi
  00007	33 ff		 xor	 edi, edi
  00009	3b c7		 cmp	 eax, edi
  0000b	0f 8c 90 00 00
	00		 jl	 $LN6@ChangeMons
  00011	33 d2		 xor	 edx, edx
  00013	83 f8 06	 cmp	 eax, 6
  00016	0f 9e c2	 setle	 dl
  00019	3b d7		 cmp	 edx, edi
  0001b	0f 84 80 00 00
	00		 je	 $LN6@ChangeMons

; 3920 : 		return;
; 3921 : 
; 3922 : 	int iAddDamageMax = 0;
; 3923 : 	int iAddDamageMin = 0;
; 3924 : 	int iAddDefense = 0;
; 3925 : 
; 3926 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 300000 )

  00021	c1 e0 09	 shl	 eax, 9
  00024	8b 84 08 54 01
	00 00		 mov	 eax, DWORD PTR [eax+ecx+340]
  0002b	53		 push	 ebx
  0002c	33 db		 xor	 ebx, ebx
  0002e	89 7d 08	 mov	 DWORD PTR _iAddDefense$[ebp], edi
  00031	3d e0 93 04 00	 cmp	 eax, 300000		; 000493e0H
  00036	7d 0f		 jge	 SHORT $LN4@ChangeMons

; 3927 : 	{
; 3928 : 		iAddDamageMin = g_iBC_MONSTER_CHANGE_STATE[1][0];

  00038	8d 7b 14	 lea	 edi, DWORD PTR [ebx+20]

; 3929 : 		iAddDamageMax = g_iBC_MONSTER_CHANGE_STATE[1][1];

  0003b	8d 5f 14	 lea	 ebx, DWORD PTR [edi+20]

; 3930 : 		iAddDefense = g_iBC_MONSTER_CHANGE_STATE[1][2];

  0003e	c7 45 08 e0 ff
	ff ff		 mov	 DWORD PTR _iAddDefense$[ebp], -32 ; ffffffe0H
  00045	eb 16		 jmp	 SHORT $LN2@ChangeMons
$LN4@ChangeMons:

; 3931 : 	}
; 3932 : 	else if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 600000 )

  00047	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  0004c	7d 0f		 jge	 SHORT $LN2@ChangeMons

; 3933 : 	{
; 3934 : 		iAddDamageMin = g_iBC_MONSTER_CHANGE_STATE[0][0];

  0004e	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH

; 3935 : 		iAddDamageMax = g_iBC_MONSTER_CHANGE_STATE[0][1];

  00053	8d 5f 0a	 lea	 ebx, DWORD PTR [edi+10]

; 3936 : 		iAddDefense = g_iBC_MONSTER_CHANGE_STATE[0][2];

  00056	c7 45 08 f2 ff
	ff ff		 mov	 DWORD PTR _iAddDefense$[ebp], -14 ; fffffff2H
$LN2@ChangeMons:

; 3937 : 	}
; 3938 : 
; 3939 : 	LPMONSTER_ATTRIBUTE lpMA = gMAttr.GetAttr(gObj[iIndex].Class);

  0005d	56		 push	 esi
  0005e	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00061	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00067	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+152]
  0006e	50		 push	 eax
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00074	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr

; 3940 : 
; 3941 : 	if ( lpMA == NULL )

  00079	85 c0		 test	 eax, eax
  0007b	74 22		 je	 SHORT $LN11@ChangeMons

; 3942 : 		return;
; 3943 : 
; 3944 : 	gObj[iIndex].m_AttackDamageMin = lpMA->m_DamageMin + iAddDamageMin;

  0007d	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00080	03 cf		 add	 ecx, edi
  00082	89 8e dc 02 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+732], ecx

; 3945 : 	gObj[iIndex].m_AttackDamageMax = lpMA->m_DamageMax + iAddDamageMax;

  00088	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  0008b	03 d3		 add	 edx, ebx
  0008d	89 96 e0 02 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+736], edx

; 3946 : 	gObj[iIndex].m_Defense = lpMA->m_Defense + iAddDefense;

  00093	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00096	03 45 08	 add	 eax, DWORD PTR _iAddDefense$[ebp]
  00099	89 86 10 03 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+784], eax
$LN11@ChangeMons:
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
$LN6@ChangeMons:
  000a1	5f		 pop	 edi

; 3947 : }

  000a2	5d		 pop	 ebp
  000a3	c2 08 00	 ret	 8
?ChangeMonsterState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::ChangeMonsterState
_TEXT	ENDS
PUBLIC	??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ ; `string'
PUBLIC	__real@00000000
PUBLIC	?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z	; CBloodCastle::FixUsersPlayStateWin
;	COMDAT ??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
CONST	SEGMENT
??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ DB '['
	DB	'Blood Castle] (%d) [%s][%s] FixUsersPlayStateWin() - State : '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv251 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::FixUsersPlayStateWin, COMDAT
; _this$ = ecx

; 3953 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 3954 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	0f 88 a2 02 00
	00		 js	 $LN26@FixUsersPl
  0000f	33 c0		 xor	 eax, eax
  00011	83 fb 06	 cmp	 ebx, 6
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	0f 84 92 02 00
	00		 je	 $LN26@FixUsersPl

; 3955 : 		return;
; 3956 : 
; 3957 : 	if ( this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS != -1 )

  0001f	8b c3		 mov	 eax, ebx
  00021	c1 e0 09	 shl	 eax, 9
  00024	83 bc 08 48 01
	00 00 ff	 cmp	 DWORD PTR [eax+ecx+328], -1
  0002c	57		 push	 edi
  0002d	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  00030	0f 84 7a 02 00
	00		 je	 $LN60@FixUsersPl

; 3958 : 	{
; 3959 : 		for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00036	d9 ee		 fldz
  00038	56		 push	 esi
  00039	8d 77 28	 lea	 esi, DWORD PTR [edi+40]
  0003c	c7 45 08 0a 00
	00 00		 mov	 DWORD PTR tv251[ebp], 10 ; 0000000aH
$LN59@FixUsersPl:

; 3960 : 		{
; 3961 : 			if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  00043	8b 4e f4	 mov	 ecx, DWORD PTR [esi-12]
  00046	83 f9 ff	 cmp	 ecx, -1
  00049	0f 84 52 02 00
	00		 je	 $LN27@FixUsersPl

; 3962 : 				continue;
; 3963 : 
; 3964 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected < PLAYER_PLAYING )

  0004f	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00055	80 b9 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], 3
  0005c	0f 82 3f 02 00
	00		 jb	 $LN27@FixUsersPl

; 3965 : 				continue;
; 3966 : 
; 3967 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 ||
; 3968 : 				 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 ||
; 3969 : 				 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex )

  00062	8a 81 02 0d 00
	00		 mov	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3330]
  00068	3c ff		 cmp	 al, -1
  0006a	0f 84 31 02 00
	00		 je	 $LN27@FixUsersPl
  00070	80 b9 03 0d 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3331], -1
  00077	0f 84 24 02 00
	00		 je	 $LN27@FixUsersPl
  0007d	0f be d0	 movsx	 edx, al
  00080	3b d3		 cmp	 edx, ebx
  00082	0f 85 19 02 00
	00		 jne	 $LN27@FixUsersPl

; 3970 : 				continue;
; 3971 : 
; 3972 : 			LPOBJ lpObj = &gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex];
; 3973 : 
; 3974 : 			switch ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState )

  00088	8b 06		 mov	 eax, DWORD PTR [esi]
  0008a	83 f8 04	 cmp	 eax, 4
  0008d	0f 87 e6 01 00
	00		 ja	 $LN77@FixUsersPl
  00093	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN136@FixUsersPl[eax*4]
$LN19@FixUsersPl:

; 3975 : 			{
; 3976 : 				case 0:
; 3977 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  0009a	8b 81 a8 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+680]
  000a0	85 c0		 test	 eax, eax
  000a2	78 64		 js	 SHORT $LN53@FixUsersPl
  000a4	33 d2		 xor	 edx, edx
  000a6	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  000ab	0f 9e c2	 setle	 dl
  000ae	85 d2		 test	 edx, edx
  000b0	74 56		 je	 SHORT $LN53@FixUsersPl
  000b2	8b 97 00 02 00
	00		 mov	 edx, DWORD PTR [edi+512]
  000b8	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  000be	3b 82 a8 02 00
	00		 cmp	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+680]
  000c4	75 42		 jne	 SHORT $LN53@FixUsersPl

; 3978 : 					{
; 3979 : 						if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Live == TRUE && lpObj->Life > 0.0 )

  000c6	0f b6 81 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  000cd	3c 0b		 cmp	 al, 11			; 0000000bH
  000cf	72 2a		 jb	 SHORT $LN96@FixUsersPl
  000d1	b2 11		 mov	 dl, 17			; 00000011H
  000d3	3a d0		 cmp	 dl, al
  000d5	1b c0		 sbb	 eax, eax
  000d7	40		 inc	 eax
  000d8	74 21		 je	 SHORT $LN96@FixUsersPl
  000da	80 b9 62 00 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+98], 1
  000e1	75 18		 jne	 SHORT $LN96@FixUsersPl
  000e3	d8 99 bc 00 00
	00		 fcomp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+188]
  000e9	df e0		 fnstsw	 ax
  000eb	f6 c4 05	 test	 ah, 5
  000ee	7a 0d		 jp	 SHORT $LN17@FixUsersPl

; 3980 : 						{
; 3981 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  000f0	c7 06 03 00 00
	00		 mov	 DWORD PTR [esi], 3

; 3982 : 						}
; 3983 : 						else

  000f6	e9 80 01 00 00	 jmp	 $LN58@FixUsersPl
$LN96@FixUsersPl:

; 3978 : 					{
; 3979 : 						if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Live == TRUE && lpObj->Life > 0.0 )

  000fb	dd d8		 fstp	 ST(0)
$LN17@FixUsersPl:

; 3984 : 						{
; 3985 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  000fd	c7 06 04 00 00
	00		 mov	 DWORD PTR [esi], 4

; 3986 : 						}
; 3987 : 					}
; 3988 : 					else 

  00103	e9 73 01 00 00	 jmp	 $LN58@FixUsersPl
$LN53@FixUsersPl:

; 3989 : 					{
; 3990 : 						if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  00108	0f b6 81 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  0010f	3c 0b		 cmp	 al, 11			; 0000000bH
  00111	72 2e		 jb	 SHORT $LN105@FixUsersPl
  00113	b2 11		 mov	 dl, 17			; 00000011H
  00115	3a d0		 cmp	 dl, al
  00117	1b c0		 sbb	 eax, eax
  00119	40		 inc	 eax
  0011a	74 25		 je	 SHORT $LN105@FixUsersPl
  0011c	80 b9 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+98], 0
  00123	74 1c		 je	 SHORT $LN105@FixUsersPl
  00125	d8 99 bc 00 00
	00		 fcomp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+188]
  0012b	df e0		 fnstsw	 ax
  0012d	f6 c4 01	 test	 ah, 1
  00130	0f 85 45 01 00
	00		 jne	 $LN58@FixUsersPl

; 3991 : 						{
; 3992 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  00136	c7 06 01 00 00
	00		 mov	 DWORD PTR [esi], 1

; 3993 : 						}
; 3994 : 					}
; 3995 : 					break;

  0013c	e9 3a 01 00 00	 jmp	 $LN58@FixUsersPl
$LN105@FixUsersPl:

; 3989 : 					{
; 3990 : 						if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  00141	dd d8		 fstp	 ST(0)
$LN54@FixUsersPl:

; 3991 : 						{
; 3992 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  00143	c7 06 01 00 00
	00		 mov	 DWORD PTR [esi], 1

; 3993 : 						}
; 3994 : 					}
; 3995 : 					break;

  00149	e9 2d 01 00 00	 jmp	 $LN58@FixUsersPl
$LN79@FixUsersPl:

; 3996 : 				case 1:
; 3997 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  0014e	8b 81 a8 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+680]

; 4024 : 					{
; 4025 : 						this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  00154	dd d8		 fstp	 ST(0)
  00156	85 c0		 test	 eax, eax
  00158	0f 88 1d 01 00
	00		 js	 $LN58@FixUsersPl

; 3996 : 				case 1:
; 3997 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  0015e	33 d2		 xor	 edx, edx
  00160	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00165	0f 9e c2	 setle	 dl
  00168	85 d2		 test	 edx, edx
  0016a	0f 84 0b 01 00
	00		 je	 $LN58@FixUsersPl
  00170	8b 97 00 02 00
	00		 mov	 edx, DWORD PTR [edi+512]
  00176	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  0017c	3b 82 a8 02 00
	00		 cmp	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+680]
  00182	0f 85 f3 00 00
	00		 jne	 $LN58@FixUsersPl

; 3998 : 					{
; 3999 : 						this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  00188	c7 06 04 00 00
	00		 mov	 DWORD PTR [esi], 4

; 4000 : 					}
; 4001 : 					break;

  0018e	e9 e8 00 00 00	 jmp	 $LN58@FixUsersPl
$LN10@FixUsersPl:

; 4002 : 				case 3:
; 4003 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  00193	8b 81 a8 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+680]
  00199	85 c0		 test	 eax, eax
  0019b	78 64		 js	 SHORT $LN55@FixUsersPl
  0019d	33 d2		 xor	 edx, edx
  0019f	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  001a4	0f 9e c2	 setle	 dl
  001a7	85 d2		 test	 edx, edx
  001a9	74 56		 je	 SHORT $LN55@FixUsersPl
  001ab	8b 97 00 02 00
	00		 mov	 edx, DWORD PTR [edi+512]
  001b1	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  001b7	3b 82 a8 02 00
	00		 cmp	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+680]
  001bd	75 42		 jne	 SHORT $LN55@FixUsersPl

; 4004 : 					{
; 4005 : 						if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  001bf	0f b6 81 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  001c6	3c 0b		 cmp	 al, 11			; 0000000bH
  001c8	0f 82 2d ff ff
	ff		 jb	 $LN96@FixUsersPl
  001ce	b2 11		 mov	 dl, 17			; 00000011H
  001d0	3a d0		 cmp	 dl, al
  001d2	1b c0		 sbb	 eax, eax
  001d4	40		 inc	 eax
  001d5	0f 84 20 ff ff
	ff		 je	 $LN96@FixUsersPl
  001db	80 b9 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+98], 0
  001e2	0f 84 13 ff ff
	ff		 je	 $LN96@FixUsersPl
  001e8	d8 99 bc 00 00
	00		 fcomp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+188]
  001ee	df e0		 fnstsw	 ax
  001f0	f6 c4 01	 test	 ah, 1
  001f3	0f 85 82 00 00
	00		 jne	 $LN58@FixUsersPl

; 3984 : 						{
; 3985 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  001f9	c7 06 04 00 00
	00		 mov	 DWORD PTR [esi], 4

; 3986 : 						}
; 3987 : 					}
; 3988 : 					else 

  001ff	eb 7a		 jmp	 SHORT $LN58@FixUsersPl
$LN55@FixUsersPl:

; 4006 : 						{
; 4007 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;
; 4008 : 						}
; 4009 : 					}
; 4010 : 					else 
; 4011 : 					{
; 4012 : 						if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Live == TRUE && lpObj->Life > 0.0 )

  00201	0f b6 81 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  00208	3c 0b		 cmp	 al, 11			; 0000000bH
  0020a	0f 82 31 ff ff
	ff		 jb	 $LN105@FixUsersPl
  00210	b2 11		 mov	 dl, 17			; 00000011H
  00212	3a d0		 cmp	 dl, al
  00214	1b c0		 sbb	 eax, eax
  00216	40		 inc	 eax
  00217	0f 84 24 ff ff
	ff		 je	 $LN105@FixUsersPl
  0021d	80 b9 62 00 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+98], 1
  00224	0f 85 17 ff ff
	ff		 jne	 $LN105@FixUsersPl
  0022a	d8 99 bc 00 00
	00		 fcomp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+188]
  00230	df e0		 fnstsw	 ax
  00232	f6 c4 05	 test	 ah, 5
  00235	0f 8a 08 ff ff
	ff		 jp	 $LN54@FixUsersPl

; 4013 : 						{
; 4014 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 0;

  0023b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4015 : 						}
; 4016 : 						else

  00241	eb 38		 jmp	 SHORT $LN58@FixUsersPl
$LN78@FixUsersPl:

; 4017 : 						{
; 4018 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;
; 4019 : 						}
; 4020 : 					}
; 4021 : 					break;
; 4022 : 				case 4:
; 4023 : 					if ( !OBJMAX_RANGE(lpObj->PartyNumber) || lpObj->PartyNumber != gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  00243	8b 81 a8 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+680]

; 4024 : 					{
; 4025 : 						this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  00249	dd d8		 fstp	 ST(0)
  0024b	85 c0		 test	 eax, eax
  0024d	78 22		 js	 SHORT $LN57@FixUsersPl

; 4017 : 						{
; 4018 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;
; 4019 : 						}
; 4020 : 					}
; 4021 : 					break;
; 4022 : 				case 4:
; 4023 : 					if ( !OBJMAX_RANGE(lpObj->PartyNumber) || lpObj->PartyNumber != gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  0024f	33 d2		 xor	 edx, edx
  00251	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00256	0f 9e c2	 setle	 dl
  00259	85 d2		 test	 edx, edx
  0025b	74 14		 je	 SHORT $LN57@FixUsersPl
  0025d	8b 97 00 02 00
	00		 mov	 edx, DWORD PTR [edi+512]
  00263	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00269	3b 82 a8 02 00
	00		 cmp	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+680]
  0026f	74 0a		 je	 SHORT $LN58@FixUsersPl
$LN57@FixUsersPl:

; 4024 : 					{
; 4025 : 						this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  00271	c7 06 01 00 00
	00		 mov	 DWORD PTR [esi], 1
  00277	eb 02		 jmp	 SHORT $LN58@FixUsersPl
$LN77@FixUsersPl:
  00279	dd d8		 fstp	 ST(0)
$LN58@FixUsersPl:

; 4026 : 					}
; 4027 : 					break;
; 4028 : 			}
; 4029 : 
; 4030 : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) [%s][%s] FixUsersPlayStateWin() - State : %d",
; 4031 : 				iBridgeIndex+1, lpObj->AccountID, lpObj->Name, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState);

  0027b	8b 06		 mov	 eax, DWORD PTR [esi]
  0027d	50		 push	 eax
  0027e	8d 91 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+111]
  00284	52		 push	 edx
  00285	8d 81 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+100]
  0028b	50		 push	 eax
  0028c	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0028f	51		 push	 ecx
  00290	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
  00295	6a 00		 push	 0
  00297	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0029c	d9 ee		 fldz
  0029e	83 c4 18	 add	 esp, 24			; 00000018H
$LN27@FixUsersPl:

; 3958 : 	{
; 3959 : 		for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  002a1	83 c6 14	 add	 esi, 20			; 00000014H
  002a4	ff 4d 08	 dec	 DWORD PTR tv251[ebp]
  002a7	0f 85 96 fd ff
	ff		 jne	 $LN59@FixUsersPl
  002ad	dd d8		 fstp	 ST(0)
  002af	5e		 pop	 esi
$LN60@FixUsersPl:
  002b0	5f		 pop	 edi
$LN26@FixUsersPl:
  002b1	5b		 pop	 ebx

; 4032 : 
; 4033 : 		}
; 4034 : 	}
; 4035 : }

  002b2	5d		 pop	 ebp
  002b3	c2 04 00	 ret	 4
  002b6	8b ff		 npad	 2
$LN136@FixUsersPl:
  002b8	00 00 00 00	 DD	 $LN19@FixUsersPl
  002bc	00 00 00 00	 DD	 $LN79@FixUsersPl
  002c0	00 00 00 00	 DD	 $LN77@FixUsersPl
  002c4	00 00 00 00	 DD	 $LN10@FixUsersPl
  002c8	00 00 00 00	 DD	 $LN78@FixUsersPl
?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::FixUsersPlayStateWin
_TEXT	ENDS
PUBLIC	??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ ; `string'
PUBLIC	?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z	; CBloodCastle::FixUsersPlayStateFail
;	COMDAT ??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
CONST	SEGMENT
??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ DB '['
	DB	'Blood Castle] (%d) [%s][%s] FixUsersPlayStateFail() - State :'
	DB	' %d', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv206 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::FixUsersPlayStateFail, COMDAT
; _this$ = ecx

; 4040 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 4041 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	0f 88 95 00 00
	00		 js	 $LN12@FixUsersPl@2
  0000f	33 c0		 xor	 eax, eax
  00011	83 ff 06	 cmp	 edi, 6
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	0f 84 85 00 00
	00		 je	 $LN12@FixUsersPl@2

; 4042 : 		return;
; 4043 : 
; 4044 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0001f	53		 push	 ebx
  00020	8b c7		 mov	 eax, edi
  00022	c1 e0 09	 shl	 eax, 9
  00025	56		 push	 esi
  00026	8d 74 08 1c	 lea	 esi, DWORD PTR [eax+ecx+28]
  0002a	c7 45 08 0a 00
	00 00		 mov	 DWORD PTR tv206[ebp], 10 ; 0000000aH
  00031	bb 01 00 00 00	 mov	 ebx, 1
$LL14@FixUsersPl@2:

; 4045 : 	{
; 4046 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  00036	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00038	83 f9 ff	 cmp	 ecx, -1
  0003b	74 5d		 je	 SHORT $LN13@FixUsersPl@2

; 4047 : 			continue;
; 4048 : 
; 4049 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected < PLAYER_PLAYING )

  0003d	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00043	80 b9 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+4], 3
  0004a	72 4e		 jb	 SHORT $LN13@FixUsersPl@2

; 4050 : 			continue;
; 4051 : 
; 4052 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 ||
; 4053 : 			 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 ||
; 4054 : 			 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex )

  0004c	8a 81 02 0d 00
	00		 mov	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3330]
  00052	3c ff		 cmp	 al, -1
  00054	74 44		 je	 SHORT $LN13@FixUsersPl@2
  00056	80 b9 03 0d 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+3331], -1
  0005d	74 3b		 je	 SHORT $LN13@FixUsersPl@2
  0005f	0f be d0	 movsx	 edx, al
  00062	3b d7		 cmp	 edx, edi
  00064	75 34		 jne	 SHORT $LN13@FixUsersPl@2

; 4055 : 			continue;
; 4056 : 
; 4057 : 		LPOBJ lpObj = &gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex];
; 4058 : 
; 4059 : 		switch ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState )

  00066	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00069	83 e8 03	 sub	 eax, 3
  0006c	74 3b		 je	 SHORT $LN5@FixUsersPl@2
  0006e	2b c3		 sub	 eax, ebx
  00070	75 03		 jne	 SHORT $LN2@FixUsersPl@2
$LN24@FixUsersPl@2:

; 4063 : 				{
; 4064 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  00072	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
$LN2@FixUsersPl@2:

; 4069 : 				}
; 4070 : 				break;
; 4071 : 			case 4:
; 4072 : 				this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;
; 4073 : 				break;
; 4074 : 		}
; 4075 : 
; 4076 : 		LogAdd(LOG_BLACK, "[Blood Castle] (%d) [%s][%s] FixUsersPlayStateFail() - State : %d",
; 4077 : 			iBridgeIndex+1, lpObj->AccountID, lpObj->Name,
; 4078 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState);

  00075	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00078	50		 push	 eax
  00079	8d 91 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+111]
  0007f	52		 push	 edx
  00080	8d 81 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+100]
  00086	50		 push	 eax
  00087	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0008a	51		 push	 ecx
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
  00090	6a 00		 push	 0
  00092	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00097	83 c4 18	 add	 esp, 24			; 00000018H
$LN13@FixUsersPl@2:

; 4042 : 		return;
; 4043 : 
; 4044 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0009a	83 c6 14	 add	 esi, 20			; 00000014H
  0009d	29 5d 08	 sub	 DWORD PTR tv206[ebp], ebx
  000a0	75 94		 jne	 SHORT $LL14@FixUsersPl@2
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
$LN12@FixUsersPl@2:
  000a4	5f		 pop	 edi

; 4079 : 	}
; 4080 : }

  000a5	5d		 pop	 ebp
  000a6	c2 04 00	 ret	 4
$LN5@FixUsersPl@2:

; 4060 : 		{
; 4061 : 			case 3:
; 4062 : 				if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  000a9	0f b6 81 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+265]
  000b0	3c 0b		 cmp	 al, 11			; 0000000bH
  000b2	72 be		 jb	 SHORT $LN24@FixUsersPl@2
  000b4	b2 11		 mov	 dl, 17			; 00000011H
  000b6	3a d0		 cmp	 dl, al
  000b8	1b c0		 sbb	 eax, eax
  000ba	40		 inc	 eax
  000bb	74 b5		 je	 SHORT $LN24@FixUsersPl@2
  000bd	80 b9 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+98], 0
  000c4	74 ac		 je	 SHORT $LN24@FixUsersPl@2
  000c6	d9 ee		 fldz
  000c8	d8 99 bc 00 00
	00		 fcomp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+188]
  000ce	df e0		 fnstsw	 ax
  000d0	f6 c4 01	 test	 ah, 1
  000d3	74 9d		 je	 SHORT $LN24@FixUsersPl@2

; 4065 : 				}
; 4066 : 				else
; 4067 : 				{
; 4068 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 0;

  000d5	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  000dc	eb 97		 jmp	 SHORT $LN2@FixUsersPl@2
?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::FixUsersPlayStateFail
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::allocator<std::pair<unsigned long const ,TokenizerSection> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::allocator<std::pair<unsigned long const ,TokenizerSection> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::allocator<std::pair<unsigned long const ,TokenizerSection> >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::allocator<std::pair<unsigned long const ,TokenizerSection> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::allocator<std::pair<unsigned long const ,TokenizerSection> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::allocator<std::pair<unsigned long const ,TokenizerSection> >
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z ; std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z PROC ; std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 41   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z ENDP ; std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBKVTokenizerSection@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node><std::pair<unsigned long const ,TokenizerSection> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBKVTokenizerSection@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBKVTokenizerSection@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node><std::pair<unsigned long const ,TokenizerSection> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBKVTokenizerSection@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node><std::pair<unsigned long const ,TokenizerSection> >
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long const ,TokenizerRow> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long const ,TokenizerRow> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long const ,TokenizerRow> >
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT

; 485  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 486  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00006	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 10	 mov	 esi, DWORD PTR __Count$[ebp]
  0000d	57		 push	 edi
  0000e	83 fe 04	 cmp	 esi, 4
  00011	72 14		 jb	 SHORT $LN11@compare
$LL4@compare:
  00013	8b 02		 mov	 eax, DWORD PTR [edx]
  00015	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00017	75 12		 jne	 SHORT $LN5@compare
  00019	83 ee 04	 sub	 esi, 4
  0001c	83 c1 04	 add	 ecx, 4
  0001f	83 c2 04	 add	 edx, 4
  00022	83 fe 04	 cmp	 esi, 4
  00025	73 ec		 jae	 SHORT $LL4@compare
$LN11@compare:
  00027	85 f6		 test	 esi, esi
  00029	74 45		 je	 SHORT $LN6@compare
$LN5@compare:
  0002b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0002e	0f b6 39	 movzx	 edi, BYTE PTR [ecx]
  00031	2b c7		 sub	 eax, edi
  00033	75 31		 jne	 SHORT $LN7@compare
  00035	83 fe 01	 cmp	 esi, 1
  00038	76 36		 jbe	 SHORT $LN6@compare
  0003a	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  0003e	0f b6 79 01	 movzx	 edi, BYTE PTR [ecx+1]
  00042	2b c7		 sub	 eax, edi
  00044	75 20		 jne	 SHORT $LN7@compare
  00046	83 fe 02	 cmp	 esi, 2
  00049	76 25		 jbe	 SHORT $LN6@compare
  0004b	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0004f	0f b6 79 02	 movzx	 edi, BYTE PTR [ecx+2]
  00053	2b c7		 sub	 eax, edi
  00055	75 0f		 jne	 SHORT $LN7@compare
  00057	83 fe 03	 cmp	 esi, 3
  0005a	76 14		 jbe	 SHORT $LN6@compare
  0005c	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00060	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00064	2b c1		 sub	 eax, ecx
$LN7@compare:
  00066	c1 f8 1f	 sar	 eax, 31			; 0000001fH
  00069	5f		 pop	 edi
  0006a	83 c8 01	 or	 eax, 1
  0006d	5e		 pop	 esi

; 487  : 		}

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
$LN6@compare:
  00070	5f		 pop	 edi

; 486  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00071	33 c0		 xor	 eax, eax
  00073	5e		 pop	 esi

; 487  : 		}

  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Ogtp
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 490  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 491  : 		return (_CSTD strlen(_First));

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL3@length:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL3@length
  00017	2b c2		 sub	 eax, edx

; 492  : 		}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 496  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 498  : 		}

  00003	5d		 pop	 ebp

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00004	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?find@?$char_traits@D@std@@SAPBDPBDIABD@Z	; std::char_traits<char>::find
EXTRN	_memchr:PROC
; Function compile flags: /Ogtp
;	COMDAT ?find@?$char_traits@D@std@@SAPBDPBDIABD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 4
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z PROC		; std::char_traits<char>::find, COMDAT

; 510  : 		{	// look for _Ch in [_First, _First + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 511  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Ch$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00009	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0000c	50		 push	 eax
  0000d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00010	52		 push	 edx
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _memchr
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 512  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z ENDP		; std::char_traits<char>::find
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
EXTRN	_memmove:PROC
; Function compile flags: /Ogtp
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 516  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 518  : 		}

  00003	5d		 pop	 ebp

; 517  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00004	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 521  : 		{	// assign _Count * _Ch to [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 522  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	0f be 4d 10	 movsx	 ecx, BYTE PTR __Ch$[ebp]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	52		 push	 edx
  00010	e8 00 00 00 00	 call	 _memset
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 523  : 		}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 526  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 527  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  0000b	88 0a		 mov	 BYTE PTR [edx], cl

; 528  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
; Function compile flags: /Ogtp
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 541  : 		{	// convert metacharacter to character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 542  : 		return ((_Elem)_Meta);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	8a 00		 mov	 al, BYTE PTR [eax]

; 543  : 		}

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
; Function compile flags: /Ogtp
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 546  : 		{	// convert character to metacharacter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 547  : 		return ((unsigned char)_Ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 548  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
; Function compile flags: /Ogtp
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 552  : 		{	// test for metacharacter equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 		return (_Left == _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0000f	0f 94 c0	 sete	 al

; 554  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
; Function compile flags: /Ogtp
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 563  : 		return (EOF);

  00000	83 c8 ff	 or	 eax, -1

; 564  : 		}

  00003	c3		 ret	 0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??0runtime_error@std@@QAE@PBD@Z			; std::runtime_error::runtime_error
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0runtime_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@PBD@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 170  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 171  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@PBD@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
; Function compile flags: /Ogtp
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
EXTRN	__Getctype:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T161140 = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 117  : 		{	// return ctype stuff

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  : 		return (::_Getctype());

  00003	8d 45 f0	 lea	 eax, DWORD PTR $T161140[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __Getctype
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	89 11		 mov	 DWORD PTR [ecx], edx
  00016	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00019	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0001f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00022	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00025	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00028	83 c4 04	 add	 esp, 4
  0002b	8b c1		 mov	 eax, ecx

; 119  : 		}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 71   : 			{	// construct with specified stamp value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 72   : 			}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
; Function compile flags: /Ogtp
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$103592 = -4					; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 75   : 			{	// get stamp, with lazy allocation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 76   : 			if (_Id == 0)

  00007	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0000a	75 24		 jne	 SHORT $LN6@operator

; 77   : 				{	// still zero, allocate stamp
; 78   : 				_BEGIN_LOCK(_LOCK_LOCALE)

  0000c	6a 00		 push	 0
  0000e	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$103592[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 79   : 					if (_Id == 0)

  00016	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00019	75 0d		 jne	 SHORT $LN1@operator

; 80   : 						_Id = ++_Id_cnt;

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00020	40		 inc	 eax
  00021	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00026	89 06		 mov	 DWORD PTR [esi], eax
$LN1@operator:

; 81   : 				_END_LOCK()

  00028	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$103592[ebp]
  0002b	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN6@operator:

; 82   : 				}
; 83   : 			return (_Id);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	5e		 pop	 esi

; 84   : 			}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
PUBLIC	?_Incref@facet@locale@std@@QAEXXZ		; std::locale::facet::_Incref
; Function compile flags: /Ogtp
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
__Lock$103598 = -4					; size = 4
?_Incref@facet@locale@std@@QAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 111  : 			{	// safely increment the reference count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 112  : 			_BEGIN_LOCK(_LOCK_LOCALE)

  00007	6a 00		 push	 0
  00009	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$103598[ebp]
  0000c	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 113  : 				if (_Refs < (size_t)(-1))

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	83 f8 ff	 cmp	 eax, -1
  00017	73 04		 jae	 SHORT $LN1@Incref

; 114  : 					++_Refs;

  00019	40		 inc	 eax
  0001a	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@Incref:

; 115  : 			_END_LOCK()

  0001d	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$103598[ebp]
  00020	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00025	5e		 pop	 esi

; 116  : 			}

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?_Incref@facet@locale@std@@QAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
PUBLIC	?_Decref@facet@locale@std@@QAEPAV123@XZ		; std::locale::facet::_Decref
; Function compile flags: /Ogtp
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT
__Lock$103603 = -4					; size = 4
?_Decref@facet@locale@std@@QAEPAV123@XZ PROC		; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 119  : 			{	// safely decrement the reference count, return this when dead

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 120  : 			_BEGIN_LOCK(_LOCK_LOCALE)

  00008	6a 00		 push	 0
  0000a	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$103603[ebp]
  0000d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 121  : 				if (0 < _Refs && _Refs < (size_t)(-1))

  00012	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00015	85 c0		 test	 eax, eax
  00017	74 09		 je	 SHORT $LN1@Decref
  00019	83 f8 ff	 cmp	 eax, -1
  0001c	73 04		 jae	 SHORT $LN1@Decref

; 122  : 					--_Refs;

  0001e	48		 dec	 eax
  0001f	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN1@Decref:

; 123  : 				return (_Refs == 0 ? this : 0);

  00022	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00025	f7 de		 neg	 esi
  00027	1b f6		 sbb	 esi, esi
  00029	f7 d6		 not	 esi
  0002b	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$103603[ebp]
  0002e	23 f7		 and	 esi, edi
  00030	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00035	5f		 pop	 edi
  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi

; 124  : 			_END_LOCK()
; 125  : 			}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?_Decref@facet@locale@std@@QAEPAV123@XZ ENDP		; std::locale::facet::_Decref
_TEXT	ENDS
PUBLIC	?_Register@facet@locale@std@@QAEXXZ		; std::locale::facet::_Register
EXTRN	?_Facet_Register@facet@locale@std@@CAXPAV123@@Z:PROC ; std::locale::facet::_Facet_Register
; Function compile flags: /Ogtp
;	COMDAT ?_Register@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
?_Register@facet@locale@std@@QAEXXZ PROC		; std::locale::facet::_Register, COMDAT
; _this$ = ecx

; 129  :  #if defined(_M_CEE)
; 130  : 			_Facet_Register_m(this);
; 131  : 
; 132  :  #else /* defined(_M_CEE) */
; 133  : 			_Facet_Register(this);

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 ?_Facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::_Facet_Register
  00006	59		 pop	 ecx

; 134  :  #endif /* defined(_M_CEE) */
; 135  : 			}

  00007	c3		 ret	 0
?_Register@facet@locale@std@@QAEXXZ ENDP		; std::locale::facet::_Register
_TEXT	ENDS
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??1facet@locale@std@@UAE@XZ			; std::locale::facet::~facet
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Efacet@locale@std@@UAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@UAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 164  : 			{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@

; 165  : 			}

  00006	c3		 ret	 0
??1facet@locale@std@@UAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
; Function compile flags: /Ogtp
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 170  : 			{	// construct with initial reference count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Initrefs$[ebp]
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
  0000e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 171  : 			}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
; Function compile flags: /Ogtp
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Lock$161166 = 8					; size = 4
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 309  : 		{	// construct by copying

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b 30		 mov	 esi, DWORD PTR [eax]
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx

; 310  : 		_Ptr->_Incref();

  0000c	6a 00		 push	 0
  0000e	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$161166[ebp]
  00011	89 37		 mov	 DWORD PTR [edi], esi
  00013	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	83 f8 ff	 cmp	 eax, -1
  0001e	73 04		 jae	 SHORT $LN3@locale
  00020	40		 inc	 eax
  00021	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN3@locale:
  00024	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$161166[ebp]
  00027	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit

; 311  : 		}

  0002c	8b c7		 mov	 eax, edi
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
PUBLIC	??0locale@std@@QAE@XZ				; std::locale::locale
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	?_Init@locale@std@@CAPAV_Locimp@12@XZ:PROC	; std::locale::_Init
; Function compile flags: /Ogtp
;	COMDAT ??0locale@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$161174 = -4					; size = 4
??0locale@std@@QAE@XZ PROC				; std::locale::locale, COMDAT
; _this$ = ecx

; 315  : 		{	// construct from current locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Init
  0000d	89 07		 mov	 DWORD PTR [edi], eax

; 316  : 		_Getgloballocale()->_Incref();

  0000f	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  00014	6a 00		 push	 0
  00016	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$161174[ebp]
  00019	8b f0		 mov	 esi, eax
  0001b	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	83 f8 ff	 cmp	 eax, -1
  00026	73 04		 jae	 SHORT $LN3@locale@2
  00028	40		 inc	 eax
  00029	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN3@locale@2:
  0002c	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$161174[ebp]
  0002f	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit

; 317  : 		}

  00034	8b c7		 mov	 eax, edi
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??0locale@std@@QAE@XZ ENDP				; std::locale::locale
_TEXT	ENDS
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
; Function compile flags: /Ogtp
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$161187 = -4					; size = 4
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 409  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 410  : 		if (_Ptr != 0)

  00005	8b 39		 mov	 edi, DWORD PTR [ecx]
  00007	85 ff		 test	 edi, edi
  00009	74 3b		 je	 SHORT $LN4@locale@3

; 411  : 			_DELETE_CRT(_Ptr->_Decref());

  0000b	6a 00		 push	 0
  0000d	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$161187[ebp]
  00010	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00015	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00018	85 c0		 test	 eax, eax
  0001a	74 09		 je	 SHORT $LN6@locale@3
  0001c	83 f8 ff	 cmp	 eax, -1
  0001f	73 04		 jae	 SHORT $LN6@locale@3
  00021	48		 dec	 eax
  00022	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN6@locale@3:
  00025	56		 push	 esi
  00026	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00029	f7 de		 neg	 esi
  0002b	1b f6		 sbb	 esi, esi
  0002d	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$161187[ebp]
  00030	f7 d6		 not	 esi
  00032	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00037	23 f7		 and	 esi, edi
  00039	74 0a		 je	 SHORT $LN9@locale@3
  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	8b 10		 mov	 edx, DWORD PTR [eax]
  0003f	6a 01		 push	 1
  00041	8b ce		 mov	 ecx, esi
  00043	ff d2		 call	 edx
$LN9@locale@3:
  00045	5e		 pop	 esi
$LN4@locale@3:
  00046	5f		 pop	 edi

; 412  : 		}

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
; Function compile flags: /Ogtp
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 436  : 		{	// look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 437  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 438  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR __Id$[ebp]
  00009	3b 71 0c	 cmp	 esi, DWORD PTR [ecx+12]
  0000c	73 25		 jae	 SHORT $LN6@Getfacet
  0000e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00011	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]

; 439  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00014	85 c0		 test	 eax, eax
  00016	75 21		 jne	 SHORT $LN1@Getfacet
$LN10@Getfacet:
  00018	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  0001c	74 1b		 je	 SHORT $LN1@Getfacet

; 440  : 			return (_Facptr);	// found facet or not transparent
; 441  : 		else
; 442  : 			{	// look in current locale
; 443  : 			locale::_Locimp *_Ptr = _Getgloballocale();

  0001e	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 444  : 			return (_Id < _Ptr->_Facetcount
; 445  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 446  : 				: 0);	// no entry in current locale

  00023	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  00026	73 0f		 jae	 SHORT $LN8@Getfacet
  00028	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002b	8b 04 b1	 mov	 eax, DWORD PTR [ecx+esi*4]
  0002e	5e		 pop	 esi

; 447  : 			}
; 448  : 		}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN6@Getfacet:

; 437  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 438  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

  00033	33 c0		 xor	 eax, eax

; 439  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00035	eb e1		 jmp	 SHORT $LN10@Getfacet
$LN8@Getfacet:

; 444  : 			return (_Id < _Ptr->_Facetcount
; 445  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 446  : 				: 0);	// no entry in current locale

  00037	33 c0		 xor	 eax, eax
$LN1@Getfacet:
  00039	5e		 pop	 esi

; 447  : 			}
; 448  : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@UAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar@2
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar@2:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_Gfacet@locale@std@@UAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7codecvt_base@std@@6B@			; std::codecvt_base::`vftable'
PUBLIC	??0codecvt_base@std@@QAE@I@Z			; std::codecvt_base::codecvt_base
PUBLIC	??_R4codecvt_base@std@@6B@			; std::codecvt_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVcodecvt_base@std@@@8			; std::codecvt_base `RTTI Type Descriptor'
PUBLIC	??_R3codecvt_base@std@@8			; std::codecvt_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2codecvt_base@std@@8			; std::codecvt_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@codecvt_base@std@@8		; std::codecvt_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?do_always_noconv@codecvt_base@std@@MBE_NXZ	; std::codecvt_base::do_always_noconv
PUBLIC	?do_max_length@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_max_length
PUBLIC	?do_encoding@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_encoding
EXTRN	??_Ecodecvt_base@std@@UAEPAXI@Z:PROC		; std::codecvt_base::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@codecvt_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@codecvt_base@std@@8 DD FLAT:??_R0?AVcodecvt_base@std@@@8 ; std::codecvt_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2codecvt_base@std@@8
rdata$r	SEGMENT
??_R2codecvt_base@std@@8 DD FLAT:??_R1A@?0A@EA@codecvt_base@std@@8 ; std::codecvt_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3codecvt_base@std@@8
rdata$r	SEGMENT
??_R3codecvt_base@std@@8 DD 00H				; std::codecvt_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcodecvt_base@std@@@8
_DATA	SEGMENT
??_R0?AVcodecvt_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::codecvt_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcodecvt_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4codecvt_base@std@@6B@
rdata$r	SEGMENT
??_R4codecvt_base@std@@6B@ DD 00H			; std::codecvt_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcodecvt_base@std@@@8
	DD	FLAT:??_R3codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7codecvt_base@std@@6B@
CONST	SEGMENT
??_7codecvt_base@std@@6B@ DD FLAT:??_R4codecvt_base@std@@6B@ ; std::codecvt_base::`vftable'
	DD	FLAT:??_Ecodecvt_base@std@@UAEPAXI@Z
	DD	FLAT:?do_always_noconv@codecvt_base@std@@MBE_NXZ
	DD	FLAT:?do_max_length@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_encoding@codecvt_base@std@@MBEHXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0codecvt_base@std@@QAE@I@Z
_TEXT	SEGMENT
__Refs$ = 8						; size = 4
??0codecvt_base@std@@QAE@I@Z PROC			; std::codecvt_base::codecvt_base, COMDAT
; _this$ = ecx

; 752  : 		{	// default constructor

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Refs$[ebp]
  00008	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7codecvt_base@std@@6B@

; 753  : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0codecvt_base@std@@QAE@I@Z ENDP			; std::codecvt_base::codecvt_base
_TEXT	ENDS
PUBLIC	?always_noconv@codecvt_base@std@@QBE_NXZ	; std::codecvt_base::always_noconv
; Function compile flags: /Ogtp
;	COMDAT ?always_noconv@codecvt_base@std@@QBE_NXZ
_TEXT	SEGMENT
?always_noconv@codecvt_base@std@@QBE_NXZ PROC		; std::codecvt_base::always_noconv, COMDAT
; _this$ = ecx

; 757  : 		return (do_always_noconv());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00005	ff e2		 jmp	 edx
?always_noconv@codecvt_base@std@@QBE_NXZ ENDP		; std::codecvt_base::always_noconv
_TEXT	ENDS
PUBLIC	??1codecvt_base@std@@UAE@XZ			; std::codecvt_base::~codecvt_base
; Function compile flags: /Ogtp
;	COMDAT ??1codecvt_base@std@@UAE@XZ
_TEXT	SEGMENT
??1codecvt_base@std@@UAE@XZ PROC			; std::codecvt_base::~codecvt_base, COMDAT
; _this$ = ecx

; 772  : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00006	c3		 ret	 0
??1codecvt_base@std@@UAE@XZ ENDP			; std::codecvt_base::~codecvt_base
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_always_noconv@codecvt_base@std@@MBE_NXZ
_TEXT	SEGMENT
?do_always_noconv@codecvt_base@std@@MBE_NXZ PROC	; std::codecvt_base::do_always_noconv, COMDAT
; _this$ = ecx

; 777  : 		return (true);

  00000	b0 01		 mov	 al, 1

; 778  : 		}

  00002	c3		 ret	 0
?do_always_noconv@codecvt_base@std@@MBE_NXZ ENDP	; std::codecvt_base::do_always_noconv
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_max_length@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
?do_max_length@codecvt_base@std@@MBEHXZ PROC		; std::codecvt_base::do_max_length, COMDAT
; _this$ = ecx

; 782  : 		return (1);

  00000	b8 01 00 00 00	 mov	 eax, 1

; 783  : 		}

  00005	c3		 ret	 0
?do_max_length@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_max_length
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_encoding@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
?do_encoding@codecvt_base@std@@MBEHXZ PROC		; std::codecvt_base::do_encoding, COMDAT
; _this$ = ecx

; 787  : 		return (1);	// -1 ==> state dependent, 0 ==> varying length

  00000	b8 01 00 00 00	 mov	 eax, 1

; 788  : 		}

  00005	c3		 ret	 0
?do_encoding@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_encoding
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gcodecvt_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gcodecvt_base@std@@UAEPAXI@Z PROC			; std::codecvt_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00010	74 09		 je	 SHORT $LN8@scalar@3
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN8@scalar@3:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_Gcodecvt_base@std@@UAEPAXI@Z ENDP			; std::codecvt_base::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 2011 : 		{	// default constructor

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Refs$[ebp]
  00008	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 2012 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
; Function compile flags: /Ogtp
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 2016 : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00006	c3		 ret	 0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00010	74 09		 je	 SHORT $LN8@scalar@4
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN8@scalar@4:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?is@?$ctype@D@std@@QBE_NFD@Z			; std::ctype<char>::is
; Function compile flags: /Ogtp
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 1
?is@?$ctype@D@std@@QBE_NFD@Z PROC			; std::ctype<char>::is, COMDAT
; _this$ = ecx

; 2271 : 		{	// test if element fits any mask classifications

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2272 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

  00003	0f b6 45 0c	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00007	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000a	66 8b 55 08	 mov	 dx, WORD PTR __Maskval$[ebp]
  0000e	66 85 14 41	 test	 WORD PTR [ecx+eax*2], dx
  00012	b8 00 00 00 00	 mov	 eax, 0
  00017	0f 95 c0	 setne	 al

; 2273 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?is@?$ctype@D@std@@QBE_NFD@Z ENDP			; std::ctype<char>::is
_TEXT	ENDS
PUBLIC	?widen@?$ctype@D@std@@QBEDD@Z			; std::ctype<char>::widen
; Function compile flags: /Ogtp
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?widen@?$ctype@D@std@@QBEDD@Z PROC			; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2324 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2325 : 		return (do_widen(_Byte));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 2326 : 		}

  00008	5d		 pop	 ebp

; 2325 : 		return (do_widen(_Byte));

  00009	ff e0		 jmp	 eax
?widen@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::widen
_TEXT	ENDS
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
; Function compile flags: /Ogtp
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T161280 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2399 : 		{	// initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 2400 : 		_Ctype = _Lobj._Getctype();

  00007	8d 45 f0	 lea	 eax, DWORD PTR $T161280[ebp]
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 __Getctype
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  0001d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00020	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00023	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00026	83 c4 04	 add	 esp, 4
  00029	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0002c	5e		 pop	 esi

; 2401 : 		}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
PUBLIC	??0error_code@std@@QAE@HABVerror_category@1@@Z	; std::error_code::error_code
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 204  : 		{	// construct from error code and category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 0c	 mov	 edx, DWORD PTR __Cat$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx
  0000d	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 205  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z ; std::make_error_code
EXTRN	?iostream_category@std@@YAABVerror_category@1@XZ:PROC ; std::iostream_category
; Function compile flags: /Ogtp
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z PROC ; std::make_error_code, COMDAT

; 446  : 	{	// make an error_code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	return (error_code(_Errno, iostream_category()));

  00003	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  00008	8b 55 0c	 mov	 edx, DWORD PTR __Errno$[ebp]
  0000b	8b c8		 mov	 ecx, eax
  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00010	89 10		 mov	 DWORD PTR [eax], edx
  00012	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 448  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z ENDP ; std::make_error_code
_TEXT	ENDS
PUBLIC	?_Makestr@system_error@std@@AAEXXZ		; std::system_error::_Makestr
; Function compile flags: /Ogtp
;	COMDAT ?_Makestr@system_error@std@@AAEXXZ
_TEXT	SEGMENT
?_Makestr@system_error@std@@AAEXXZ PROC			; std::system_error::_Makestr, COMDAT
; _this$ = ecx

; 563  : //		_Mymes = this->runtime_error::what();
; 564  : //		if (!_Mymes.empty())
; 565  : //			_Mymes.append(": ");
; 566  : //		_Mymes.append(_Mycode.message());
; 567  : 		}

  00000	c3		 ret	 0
?_Makestr@system_error@std@@AAEXXZ ENDP			; std::system_error::_Makestr
_TEXT	ENDS
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
; Function compile flags: /Ogtp
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 336  : 		return (_Mystate);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 337  : 		}

  00003	c3		 ret	 0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
; Function compile flags: /Ogtp
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 358  : 		return (rdstate() == goodbit);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00005	0f 94 c0	 sete	 al

; 359  : 		}

  00008	c3		 ret	 0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
PUBLIC	?eof@ios_base@std@@QBE_NXZ			; std::ios_base::eof
; Function compile flags: /Ogtp
;	COMDAT ?eof@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?eof@ios_base@std@@QBE_NXZ PROC				; std::ios_base::eof, COMDAT
; _this$ = ecx

; 363  : 		return ((int)rdstate() & (int)eofbit);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	83 e0 01	 and	 eax, 1

; 364  : 		}

  00006	c3		 ret	 0
?eof@ios_base@std@@QBE_NXZ ENDP				; std::ios_base::eof
_TEXT	ENDS
PUBLIC	?fail@ios_base@std@@QBE_NXZ			; std::ios_base::fail
; Function compile flags: /Ogtp
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?fail@ios_base@std@@QBE_NXZ PROC			; std::ios_base::fail, COMDAT
; _this$ = ecx

; 368  : 		return (((int)rdstate()
; 369  : 			& ((int)badbit | (int)failbit)) != 0);

  00000	f6 41 0c 06	 test	 BYTE PTR [ecx+12], 6
  00004	b8 00 00 00 00	 mov	 eax, 0
  00009	0f 95 c0	 setne	 al

; 370  : 		}

  0000c	c3		 ret	 0
?fail@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::fail
_TEXT	ENDS
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
; Function compile flags: /Ogtp
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 395  : 		return (_Fmtfl);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 396  : 		}

  00003	c3		 ret	 0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
; Function compile flags: /Ogtp
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
$T161332 = -4						; size = 4
__Lock$161345 = 8					; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 451  : 		{	// get locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 452  : 		return (*_Ploc);

  00004	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00007	56		 push	 esi
  00008	8b 30		 mov	 esi, DWORD PTR [eax]
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	6a 00		 push	 0
  00010	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$161345[ebp]
  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T161332[ebp], 0
  0001a	89 37		 mov	 DWORD PTR [edi], esi
  0001c	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00021	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00024	83 f8 ff	 cmp	 eax, -1
  00027	73 04		 jae	 SHORT $LN7@getloc
  00029	40		 inc	 eax
  0002a	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN7@getloc:
  0002d	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$161345[ebp]
  00030	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00035	8b c7		 mov	 eax, edi
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 453  : 		}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
PUBLIC	??_7ios_base@std@@6B@				; std::ios_base::`vftable'
PUBLIC	??1ios_base@std@@UAE@XZ				; std::ios_base::~ios_base
PUBLIC	??_R4ios_base@std@@6B@				; std::ios_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z:PROC	; std::ios_base::_Ios_base_dtor
EXTRN	??_Eios_base@std@@UAEPAXI@Z:PROC		; std::ios_base::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
_DATA	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ios_base@std@@6B@
rdata$r	SEGMENT
??_R4ios_base@std@@6B@ DD 00H				; std::ios_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVios_base@std@@@8
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT
??_7ios_base@std@@6B@ DD FLAT:??_R4ios_base@std@@6B@	; std::ios_base::`vftable'
	DD	FLAT:??_Eios_base@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ios_base@std@@UAE@XZ PROC				; std::ios_base::~ios_base, COMDAT
; _this$ = ecx

; 541  : 		_Ios_base_dtor(this);

  00000	51		 push	 ecx
  00001	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00007	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0000c	59		 pop	 ecx

; 542  : 		}

  0000d	c3		 ret	 0
??1ios_base@std@@UAE@XZ ENDP				; std::ios_base::~ios_base
_TEXT	ENDS
PUBLIC	??0ios_base@std@@IAE@XZ				; std::ios_base::ios_base
; Function compile flags: /Ogtp
;	COMDAT ??0ios_base@std@@IAE@XZ
_TEXT	SEGMENT
??0ios_base@std@@IAE@XZ PROC				; std::ios_base::ios_base, COMDAT
; _this$ = ecx

; 549  : 	__CLR_OR_THIS_CALL ios_base()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@

; 550  : 		{	// default constructor
; 551  : 		}

  00008	c3		 ret	 0
??0ios_base@std@@IAE@XZ ENDP				; std::ios_base::ios_base
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gios_base@std@@UAEPAXI@Z PROC			; std::ios_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	56		 push	 esi
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  0000d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00012	83 c4 04	 add	 esp, 4
  00015	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00019	74 09		 je	 SHORT $LN6@scalar@5
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00021	83 c4 04	 add	 esp, 4
$LN6@scalar@5:
  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??_Gios_base@std@@UAEPAXI@Z ENDP			; std::ios_base::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1507 : 		return (this->_Mysize);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1508 : 		}

  00003	c3		 ret	 0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1512 : 		return (this->_Mysize);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1513 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	??0?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::_Yarn<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 3315 : 		{	// default construct

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00008	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 3316 : 		}

  0000c	c3		 ret	 0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
PUBLIC	?c_str@?$_Yarn@D@std@@QBEPBDXZ			; std::_Yarn<char>::c_str
; Function compile flags: /Ogtp
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 3376 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	75 03		 jne	 SHORT $LN4@c_str
  00006	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
$LN4@c_str:

; 3377 : 		}

  00009	c3		 ret	 0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
PUBLIC	??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
PUBLIC	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
EXTRN	??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ostream
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 79   : 		{	// destroy the object

  00000	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00003	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00006	c7 44 0a f8 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@

; 80   : 		}

  0000e	c3		 ret	 0
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 38   : 		}

  00000	51		 push	 ecx
  00001	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00007	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
; Function compile flags: /Ogtp
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 86   : 		return (_Mystrbuf);

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]

; 87   : 		}

  00003	c3		 ret	 0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
PUBLIC	??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
PUBLIC	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	010H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 63   : 		{	// destroy the object

  00000	8b 41 f0	 mov	 eax, DWORD PTR [ecx-16]
  00003	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00006	c7 44 0a f0 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-16], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@

; 64   : 		}

  0000e	c3		 ret	 0
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct::*
; Function compile flags: /Ogtp
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct::*, COMDAT
; _this$ = ecx

; 105  : 			return (_Ok ? _CONVERTIBLE_TO_TRUE : 0);

  00000	33 c0		 xor	 eax, eax
  00002	38 41 04	 cmp	 BYTE PTR [ecx+4], al
  00005	0f 95 c0	 setne	 al
  00008	48		 dec	 eax

; 106  : 			}

  00009	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct::*
_TEXT	ENDS
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 83   : 			if (_Myistr.rdbuf() != 0)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 44 02 38	 mov	 eax, DWORD PTR [edx+eax+56]
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN1@Sentry_bas

; 84   : 				_Myistr.rdbuf()->_Unlock();

  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	8b c8		 mov	 ecx, eax
  00013	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00016	ff e0		 jmp	 eax
$LN1@Sentry_bas:

; 85   : 			}

  00018	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator==
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 331  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator==
_TEXT	ENDS
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 331  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator==
_TEXT	ENDS
PUBLIC	??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`vftable'
PUBLIC	??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
EXTRN	??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_iostream<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	FLAT:??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	018H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 963  : 		{	// destroy the object

  00000	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00003	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00006	c7 44 0a e8 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-24], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@

; 964  : 		}

  0000e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	c7 44 0a f8 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  0001c	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  0001f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00022	c7 44 0a e8 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  0002a	c3		 ret	 0
??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??_Glocale@std@@QAEPAXI@Z			; std::locale::`scalar deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT
__Lock$161445 = -4					; size = 4
___flags$ = 8						; size = 4
??_Glocale@std@@QAEPAXI@Z PROC				; std::locale::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	57		 push	 edi
  00008	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0000a	85 ff		 test	 edi, edi
  0000c	74 3b		 je	 SHORT $LN7@scalar@6
  0000e	6a 00		 push	 0
  00010	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$161445[ebp]
  00013	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00018	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001b	85 c0		 test	 eax, eax
  0001d	74 09		 je	 SHORT $LN9@scalar@6
  0001f	83 f8 ff	 cmp	 eax, -1
  00022	73 04		 jae	 SHORT $LN9@scalar@6
  00024	48		 dec	 eax
  00025	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN9@scalar@6:
  00028	56		 push	 esi
  00029	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0002c	f7 de		 neg	 esi
  0002e	1b f6		 sbb	 esi, esi
  00030	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$161445[ebp]
  00033	f7 d6		 not	 esi
  00035	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0003a	23 f7		 and	 esi, edi
  0003c	74 0a		 je	 SHORT $LN13@scalar@6
  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	6a 01		 push	 1
  00044	8b ce		 mov	 ecx, esi
  00046	ff d2		 call	 edx
$LN13@scalar@6:
  00048	5e		 pop	 esi
$LN7@scalar@6:
  00049	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0004d	74 09		 je	 SHORT $LN12@scalar@6
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00055	83 c4 04	 add	 esp, 4
$LN12@scalar@6:
  00058	5f		 pop	 edi
  00059	8b c3		 mov	 eax, ebx
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??_Glocale@std@@QAEPAXI@Z ENDP				; std::locale::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00003	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	c7 44 02 f8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00011	50		 push	 eax
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  00018	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0001d	59		 pop	 ecx
  0001e	c3		 ret	 0
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
PUBLIC	??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00003	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	c7 44 02 f0 00
	00 00 00	 mov	 DWORD PTR [edx+eax-16], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00011	50		 push	 eax
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  00018	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0001d	59		 pop	 ecx
  0001e	c3		 ret	 0
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
PUBLIC	??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00003	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	c7 44 02 e8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-24], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  00011	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00014	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00017	c7 44 02 f8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  0001f	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  00022	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00025	c7 44 02 e8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  0002d	50		 push	 eax
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  00034	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00039	59		 pop	 ecx
  0003a	c3		 ret	 0
??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2003 : 		{	// determine current pointer to buffer for mutable string

  00000	8b c1		 mov	 eax, ecx

; 2004 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2005 : 			: this->_Bx._Buf);

  00002	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00006	72 02		 jb	 SHORT $LN4@Myptr
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Myptr:

; 2006 : 		}

  0000a	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2009 : 		{	// determine current pointer to buffer for nonmutable string

  00000	8b c1		 mov	 eax, ecx

; 2010 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2011 : 			: this->_Bx._Buf);

  00002	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00006	72 02		 jb	 SHORT $LN4@Myptr@2
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Myptr@2:

; 2012 : 		}

  0000a	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2021 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 459  : 		}

  00000	c3		 ret	 0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Yarn@D@std@@AAEXXZ			; std::_Yarn<char>::_Tidy
EXTRN	_free:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 3391 : 		{	// discard any string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3392 : 		if (_Myptr != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN4@Tidy

; 3393 : 
; 3394 :  #ifdef _DEBUG
; 3395 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3396 : 
; 3397 :  #else /* _DEBUG */
; 3398 : 			_CSTD free(_Myptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN4@Tidy:

; 3399 :  #endif /* _DEBUG */
; 3400 : 
; 3401 : 		_Myptr = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3402 : 		}

  00019	c3		 ret	 0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
PUBLIC	??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
PUBLIC	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
EXTRN	??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ios<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
rdata$r	SEGMENT
??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
CONST	ENDS
;	COMDAT ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 167  : 	__CLR_OR_THIS_CALL basic_ios()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@

; 168  : 		{	// default constructor, do nothing
; 169  : 		}

  00008	c3		 ret	 0
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	56		 push	 esi
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  0000d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00012	83 c4 04	 add	 esp, 4
  00015	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00019	74 09		 je	 SHORT $LN9@scalar@7
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00021	83 c4 04	 add	 esp, 4
$LN9@scalar@7:
  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 76   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 77   : 			if (_Myistr.rdbuf() != 0)

  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00010	8b 4c 02 38	 mov	 ecx, DWORD PTR [edx+eax+56]
  00014	85 c9		 test	 ecx, ecx
  00016	74 07		 je	 SHORT $LN8@Sentry_bas@2

; 78   : 				_Myistr.rdbuf()->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001d	ff d2		 call	 edx
$LN8@Sentry_bas@2:

; 79   : 			}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 141  : 		return (sync());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  00005	ff e2		 jmp	 edx
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
PUBLIC	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
; Function compile flags: /Ogtp
;	COMDAT ?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::eback, COMDAT
; _this$ = ecx

; 218  : 		return (*_IGfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 219  : 		}

  00005	c3		 ret	 0
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::eback
_TEXT	ENDS
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
; Function compile flags: /Ogtp
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = ecx

; 223  : 		return (*_IGnext);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 224  : 		}

  00005	c3		 ret	 0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
_TEXT	ENDS
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
; Function compile flags: /Ogtp
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 267  : 		--*_IGcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 268  : 		return ((*_IGnext)++);

  00005	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000d	89 11		 mov	 DWORD PTR [ecx], edx

; 269  : 		}

  0000f	c3		 ret	 0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
_TEXT	ENDS
PUBLIC	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
; Function compile flags: /Ogtp
;	COMDAT ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc, COMDAT
; _this$ = ecx

; 273  : 		--*_IGcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 274  : 		return (++(*_IGnext));

  00005	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	40		 inc	 eax
  0000b	89 01		 mov	 DWORD PTR [ecx], eax

; 275  : 		}

  0000d	c3		 ret	 0
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
_TEXT	ENDS
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
; Function compile flags: /Ogtp
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = ecx

; 279  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Gnavail
  00008	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  0000b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000d	99		 cdq

; 280  : 		}

  0000e	c3		 ret	 0
$LN3@Gnavail:

; 279  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 280  : 		}

  00012	c3		 ret	 0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??R?$less@K@std@@QBE_NABK0@Z			; std::less<unsigned long>::operator()
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xfunctional
;	COMDAT ??R?$less@K@std@@QBE_NABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@K@std@@QBE_NABK0@Z PROC			; std::less<unsigned long>::operator(), COMDAT
; _this$ = ecx

; 124  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 125  : 		return (_Left < _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0000b	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0000d	1b c0		 sbb	 eax, eax
  0000f	f7 d8		 neg	 eax

; 126  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??R?$less@K@std@@QBE_NABK0@Z ENDP			; std::less<unsigned long>::operator()
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::allocator<std::pair<unsigned long const ,TokenizerRow> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::allocator<std::pair<unsigned long const ,TokenizerRow> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::allocator<std::pair<unsigned long const ,TokenizerRow> >
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::is_open
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
;	COMDAT ?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::is_open, COMDAT
; _this$ = ecx

; 212  : 		return (_Myfile != 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 54	 cmp	 DWORD PTR [ecx+84], eax
  00005	0f 95 c0	 setne	 al

; 213  : 		}

  00008	c3		 ret	 0
?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::is_open
_TEXT	ENDS
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator==
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 331  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 1911 : 		{	// assign _Count copies of _Ch beginning at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1912 : 		if (_Count == 1)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	83 f8 01	 cmp	 eax, 1
  00009	75 15		 jne	 SHORT $LN2@Chassign

; 1913 : 			_Traits::assign(*(_Myptr() + _Off), _Ch);

  0000b	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0000f	72 02		 jb	 SHORT $LN7@Chassign
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN7@Chassign:
  00013	8a 45 10	 mov	 al, BYTE PTR __Ch$[ebp]
  00016	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00019	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1916 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Chassign:

; 1914 : 		else
; 1915 : 			_Traits::assign(_Myptr() + _Off, _Count, _Ch);

  00020	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00024	72 02		 jb	 SHORT $LN13@Chassign
  00026	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN13@Chassign:
  00028	03 4d 08	 add	 ecx, DWORD PTR __Off$[ebp]
  0002b	50		 push	 eax
  0002c	0f be 45 10	 movsx	 eax, BYTE PTR __Ch$[ebp]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _memset
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1916 : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtp
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1973 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1974 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + this->_Mysize <= _Ptr)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 2d		 je	 SHORT $LN2@Inside
  0000b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0000e	83 fa 10	 cmp	 edx, 16			; 00000010H
  00011	72 04		 jb	 SHORT $LN8@Inside
  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN9@Inside
$LN8@Inside:
  00017	8b c1		 mov	 eax, ecx
$LN9@Inside:
  00019	3b f0		 cmp	 esi, eax
  0001b	72 1b		 jb	 SHORT $LN2@Inside
  0001d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00020	72 04		 jb	 SHORT $LN12@Inside
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN13@Inside
$LN12@Inside:
  00026	8b c1		 mov	 eax, ecx
$LN13@Inside:
  00028	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0002b	03 c8		 add	 ecx, eax
  0002d	3b ce		 cmp	 ecx, esi
  0002f	76 07		 jbe	 SHORT $LN2@Inside

; 1976 : 		else
; 1977 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 1978 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN2@Inside:

; 1975 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 1978 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2016 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
EXTRN	?_Addstd@ios_base@std@@SAXPAV12@@Z:PROC		; std::ios_base::_Addstd
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
CONST	SEGMENT
??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
	DD	08H
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0
__ehfuncinfo$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T161665 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
__Addit$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 54   : 	__CLR_OR_THIS_CALL basic_ostream(_Uninitialized, bool _Addit = true)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002b	33 c0		 xor	 eax, eax
  0002d	89 45 f0	 mov	 DWORD PTR $T161665[ebp], eax
  00030	39 45 10	 cmp	 DWORD PTR _$initVBases$[ebp], eax
  00033	74 17		 je	 SHORT $LN2@basic_ostr
  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
  0003b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  00042	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  00045	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T161665[ebp], 1
$LN2@basic_ostr:
  0004c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00051	c7 04 16 00 00
	00 00		 mov	 DWORD PTR [esi+edx], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@

; 55   : 		{	// construct uninitialized
; 56   : 		if (_Addit)

  00058	38 45 0c	 cmp	 BYTE PTR __Addit$[ebp], al
  0005b	74 10		 je	 SHORT $LN13@basic_ostr

; 57   : 			ios_base::_Addstd(this);	// suppress for basic_iostream

  0005d	8b 06		 mov	 eax, DWORD PTR [esi]
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	03 c6		 add	 eax, esi
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  0006a	83 c4 04	 add	 esp, 4
$LN13@basic_ostr:

; 58   : 		}

  0006d	8b c6		 mov	 eax, esi
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	5e		 pop	 esi
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T161665[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN8@basic_ostr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T161665[ebp], -2 ; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 08	 add	 ecx, 8
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN8@basic_ostr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 74   : 		return (_Tiestr);

  00000	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]

; 75   : 		}

  00003	c3		 ret	 0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
PUBLIC	?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ; std::basic_streambuf<char,std::char_traits<char> >::getloc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
$T161693 = -4						; size = 4
__Lock$161706 = 8					; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::getloc, COMDAT
; _this$ = ecx

; 129  : 		{	// get locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 130  : 		return (*_Plocale);

  00004	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00007	56		 push	 esi
  00008	8b 30		 mov	 esi, DWORD PTR [eax]
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	6a 00		 push	 0
  00010	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$161706[ebp]
  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T161693[ebp], 0
  0001a	89 37		 mov	 DWORD PTR [edi], esi
  0001c	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00021	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00024	83 f8 ff	 cmp	 eax, -1
  00027	73 04		 jae	 SHORT $LN7@getloc@2
  00029	40		 inc	 eax
  0002a	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN7@getloc@2:
  0002d	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$161706[ebp]
  00030	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00035	8b c7		 mov	 eax, edi
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 131  : 		}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::getloc
_TEXT	ENDS
PUBLIC	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
; Function compile flags: /Ogtp
;	COMDAT ?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setg, COMDAT
; _this$ = ecx

; 248  : 		{	// set pointers for read buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 249  : 		*_IGfirst = _First;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00009	89 10		 mov	 DWORD PTR [eax], edx

; 250  : 		*_IGnext = _Next;

  0000b	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Next$[ebp]
  00011	89 02		 mov	 DWORD PTR [edx], eax

; 251  : 		*_IGcount = (int)(_Last - _Next);

  00013	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00016	2b d0		 sub	 edx, eax
  00018	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0001b	89 10		 mov	 DWORD PTR [eax], edx

; 252  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 0c 00	 ret	 12			; 0000000cH
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setg
_TEXT	ENDS
PUBLIC	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z ; std::basic_streambuf<char,std::char_traits<char> >::_Init
; Function compile flags: /Ogtp
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z
_TEXT	SEGMENT
__Gf$ = 8						; size = 4
__Gn$ = 12						; size = 4
__Gc$ = 16						; size = 4
__Pf$ = 20						; size = 4
__Pn$ = 24						; size = 4
__Pc$ = 28						; size = 4
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 327  : 		{	// initialize buffer parameters as specified

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 328  : 		_IGfirst = _Gf;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Gf$[ebp]

; 329  : 		_IPfirst = _Pf;

  00006	8b 55 14	 mov	 edx, DWORD PTR __Pf$[ebp]
  00009	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 330  : 		_IGnext = _Gn;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Gn$[ebp]
  0000f	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 331  : 		_IPnext = _Pn;

  00012	8b 55 18	 mov	 edx, DWORD PTR __Pn$[ebp]
  00015	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 332  : 		_IGcount = _Gc;

  00018	8b 45 10	 mov	 eax, DWORD PTR __Gc$[ebp]
  0001b	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 333  : 		_IPcount = _Pc;

  0001e	8b 55 1c	 mov	 edx, DWORD PTR __Pc$[ebp]
  00021	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  00024	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 334  : 		}

  00027	5d		 pop	 ebp
  00028	c2 18 00	 ret	 24			; 00000018H
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Myval
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator*, COMDAT
; _this$ = ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator*
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerRow@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Myval
; Function compile flags: /Ogtp
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerRow@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerRow@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerRow@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::allocator<std::pair<unsigned long const ,TokenizerRow> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::allocator<std::pair<unsigned long const ,TokenizerRow> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::allocator<std::pair<unsigned long const ,TokenizerRow> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerSection@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Myval
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerSection@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerSection@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerSection@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerSection@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerSection@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerSection@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerSection@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ PROC ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*, COMDAT
; _this$ = ecx

; 71   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 72   : 		if (this->_Getcont() == 0
; 73   : 			|| this->_Ptr == 0
; 74   : 			|| this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 75   : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 76   : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 77   : 			{	// report error
; 78   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 79   : 			_SCL_SECURE_OUT_OF_RANGE;
; 80   : 			}
; 81   : 
; 82   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 83   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 84   : 		_SCL_SECURE_VALIDATE_RANGE(
; 85   : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr
; 86   : 			&& this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 87   : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 88   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 89   : 
; 90   : 		__analysis_assume(this->_Ptr != 0);
; 91   : 
; 92   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 93   : 		}

  00002	c3		 ret	 0
??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerRow@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerRow@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerRow@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerRow@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z	; std::codecvt<char,char,int>::unshift
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__First2$ = 12						; size = 4
__Last2$ = 16						; size = 4
__Mid2$ = 20						; size = 4
?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z PROC	; std::codecvt<char,char,int>::unshift, COMDAT
; _this$ = ecx

; 823  : 		{	// generate bytes to return to default shift state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 824  : 		return (do_unshift(_State, _First2, _Last2, _Mid2));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 825  : 		}

  00008	5d		 pop	 ebp

; 824  : 		return (do_unshift(_State, _First2, _Last2, _Mid2));

  00009	ff e0		 jmp	 eax
?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z ENDP	; std::codecvt<char,char,int>::unshift
_TEXT	ENDS
PUBLIC	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setp, COMDAT
; _this$ = ecx

; 289  : 		{	// set pointers for write buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 290  : 		*_IPfirst = _First;

  00003	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 02		 mov	 DWORD PTR [edx], eax

; 291  : 		*_IPnext = _First;

  0000b	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 292  : 		*_IPcount = (int)(_Last - _First);

  00010	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00013	2b d0		 sub	 edx, eax
  00015	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00018	89 10		 mov	 DWORD PTR [eax], edx

; 293  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setp
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::size, COMDAT
; _this$ = ecx

; 869  : 		return (this->_Mysize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 870  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::size
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Color
; Function compile flags: /Ogtp
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		return ((char&)(*_Pnode)._Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 2c	 add	 eax, 44			; 0000002cH

; 608  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Isnil
; Function compile flags: /Ogtp
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 2d	 add	 eax, 45			; 0000002dH

; 613  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Left
; Function compile flags: /Ogtp
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Parent
; Function compile flags: /Ogtp
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 628  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Right
; Function compile flags: /Ogtp
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 633  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max
; Function compile flags: /Ogtp
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0000d	75 0c		 jne	 SHORT $LN1@Max
  0000f	90		 npad	 1
$LL2@Max:

; 643  : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN1@Max:

; 644  : 		return (_Pnode);
; 645  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min
; Function compile flags: /Ogtp
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0000c	75 0c		 jne	 SHORT $LN1@Min
  0000e	8b ff		 npad	 2
$LL2@Min:

; 650  : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00018	74 f6		 je	 SHORT $LL2@Min
$LN1@Min:

; 651  : 		return (_Pnode);
; 652  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min
_TEXT	ENDS
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 336  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::size, COMDAT
; _this$ = ecx

; 869  : 		return (this->_Mysize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 870  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::size
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Color
; Function compile flags: /Ogtp
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		return ((char&)(*_Pnode)._Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 24	 add	 eax, 36			; 00000024H

; 608  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Isnil
; Function compile flags: /Ogtp
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 25	 add	 eax, 37			; 00000025H

; 613  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Left
; Function compile flags: /Ogtp
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Parent
; Function compile flags: /Ogtp
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 628  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Right
; Function compile flags: /Ogtp
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 633  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Max
; Function compile flags: /Ogtp
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000d	75 0c		 jne	 SHORT $LN1@Max@2
  0000f	90		 npad	 1
$LL2@Max@2:

; 643  : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00019	74 f5		 je	 SHORT $LL2@Max@2
$LN1@Max@2:

; 644  : 		return (_Pnode);
; 645  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Min
; Function compile flags: /Ogtp
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000c	75 0c		 jne	 SHORT $LN1@Min@2
  0000e	8b ff		 npad	 2
$LL2@Min@2:

; 650  : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00018	74 f6		 je	 SHORT $LL2@Min@2
$LN1@Min@2:

; 651  : 		return (_Pnode);
; 652  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Isnil
; Function compile flags: /Ogtp
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 25	 add	 eax, 37			; 00000025H

; 613  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Left
; Function compile flags: /Ogtp
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Right
; Function compile flags: /Ogtp
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 633  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Right
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 50   : 	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 51   : 		{	// construct with pointer _Parg
; 52   : 		this->_Adopt(_Pstring);
; 53   : 		this->_Ptr = _Parg;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 54   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator!=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 336  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 220  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@K@1@@Z ; std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@K@1@@Z PROC ; std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 41   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@K@1@@Z ENDP ; std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z ; std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z PROC ; std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 41   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z ENDP ; std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Parent
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 628  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::key_comp
; Function compile flags: /Ogtp
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::key_comp, COMDAT
; _this$ = ecx

; 888  : 		{	// return object for comparing keys

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 889  : 		return (this->comp);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 890  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?key_comp@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::key_comp
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 10		 mov	 edx, DWORD PTR [eax]
  00004	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00008	75 40		 jne	 SHORT $LN3@operator@2

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0000d	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00011	75 1a		 jne	 SHORT $LN34@operator@2

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00019	75 0f		 jne	 SHORT $LN17@operator@2
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator@2:
  00020	8b ca		 mov	 ecx, edx
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00028	74 f6		 je	 SHORT $LL18@operator@2
$LN17@operator@2:
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0002c	c3		 ret	 0
$LN34@operator@2:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00030	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00034	75 12		 jne	 SHORT $LN1@operator@2
$LL2@operator@2:
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0003b	75 0b		 jne	 SHORT $LN1@operator@2

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003d	89 10		 mov	 DWORD PTR [eax], edx
  0003f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00042	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00046	74 ee		 je	 SHORT $LL2@operator@2
$LN1@operator@2:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00048	89 10		 mov	 DWORD PTR [eax], edx
$LN3@operator@2:

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0004a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::key_comp
; Function compile flags: /Ogtp
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 888  : 		{	// return object for comparing keys

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 889  : 		return (this->comp);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 890  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?key_comp@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 10		 mov	 edx, DWORD PTR [eax]
  00004	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00008	75 40		 jne	 SHORT $LN3@operator@3

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0000d	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00011	75 1a		 jne	 SHORT $LN34@operator@3

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00019	75 0f		 jne	 SHORT $LN17@operator@3
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator@3:
  00020	8b ca		 mov	 ecx, edx
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00028	74 f6		 je	 SHORT $LL18@operator@3
$LN17@operator@3:
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0002c	c3		 ret	 0
$LN34@operator@3:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00030	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00034	75 12		 jne	 SHORT $LN1@operator@3
$LL2@operator@3:
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0003b	75 0b		 jne	 SHORT $LN1@operator@3

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003d	89 10		 mov	 DWORD PTR [eax], edx
  0003f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00042	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00046	74 ee		 je	 SHORT $LL2@operator@3
$LN1@operator@3:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00048	89 10		 mov	 DWORD PTR [eax], edx
$LN3@operator@3:

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0004a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$move@AAK@std@@YA$$QAKAAK@Z			; std::move<unsigned long &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAK@std@@YA$$QAKAAK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAK@std@@YA$$QAKAAK@Z PROC			; std::move<unsigned long &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAK@std@@YA$$QAKAAK@Z ENDP			; std::move<unsigned long &>
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBKVTokenizerRow@@@?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>::_Kfn<unsigned long const ,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??$_Kfn@$$CBKVTokenizerRow@@@?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBKVTokenizerRow@@@?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerRow@@@1@@Z PROC ; std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>::_Kfn<unsigned long const ,TokenizerRow>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBKVTokenizerRow@@@?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerRow@@@1@@Z ENDP ; std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>::_Kfn<unsigned long const ,TokenizerRow>
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBKVTokenizerSection@@@?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerSection@@@1@@Z ; std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>::_Kfn<unsigned long const ,TokenizerSection>
; Function compile flags: /Ogtp
;	COMDAT ??$_Kfn@$$CBKVTokenizerSection@@@?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerSection@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBKVTokenizerSection@@@?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerSection@@@1@@Z PROC ; std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>::_Kfn<unsigned long const ,TokenizerSection>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBKVTokenizerSection@@@?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerSection@@@1@@Z ENDP ; std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>::_Kfn<unsigned long const ,TokenizerSection>
_TEXT	ENDS
PUBLIC	??$move@AAVTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z ; std::move<TokenizerSection &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAVTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAVTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z PROC ; std::move<TokenizerSection &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAVTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z ENDP ; std::move<TokenizerSection &>
_TEXT	ENDS
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
PUBLIC	??$move@AAVTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z ; std::move<TokenizerRow &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAVTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAVTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z PROC ; std::move<TokenizerRow &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAVTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z ENDP ; std::move<TokenizerRow &>
_TEXT	ENDS
PUBLIC	??$addressof@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z ; std::addressof<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z PROC ; std::addressof<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node><std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
;	COMDAT ??$?0U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node><std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node><std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T162016 = -12						; size = 12
$T162021 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 43		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 55 55 55
	05		 cmp	 ecx, 89478485		; 05555555H
  00015	77 13		 ja	 SHORT $LN1@Allocate
  00017	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0001a	c1 e0 04	 shl	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00028	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002a	8d 4d 08	 lea	 ecx, DWORD PTR $T162021[ebp]
  0002d	51		 push	 ecx
  0002e	8d 4d f4	 lea	 ecx, DWORD PTR $T162016[ebp]
  00031	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T162021[ebp], 0
  00038	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003d	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00042	8d 55 f4	 lea	 edx, DWORD PTR $T162016[ebp]
  00045	52		 push	 edx
  00046	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T162016[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$addressof@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z ; std::addressof<std::pair<unsigned long const ,TokenizerRow> >
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z PROC ; std::addressof<std::pair<unsigned long const ,TokenizerRow> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<unsigned long const ,TokenizerRow> >
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node><std::pair<unsigned long const ,TokenizerRow> >
; Function compile flags: /Ogtp
;	COMDAT ??$?0U?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node><std::pair<unsigned long const ,TokenizerRow> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node><std::pair<unsigned long const ,TokenizerRow> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T162031 = -12						; size = 12
$T162035 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 46		 je	 SHORT $LN5@Allocate@2

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 66 66 66
	06		 cmp	 ecx, 107374182		; 06666666H
  00015	77 16		 ja	 SHORT $LN1@Allocate@2
  00017	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0002b	75 28		 jne	 SHORT $LN5@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T162035[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T162031[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T162035[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T162031[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T162031[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:

; 40   : 	}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN9@Allocate@2:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T162040 = -12						; size = 12
$T162044 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3a		 je	 SHORT $LN5@Allocate@3

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	83 f9 ff	 cmp	 ecx, -1
  00012	77 0d		 ja	 SHORT $LN1@Allocate@3
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0001f	75 28		 jne	 SHORT $LN5@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00021	8d 45 08	 lea	 eax, DWORD PTR $T162044[ebp]
  00024	50		 push	 eax
  00025	8d 4d f4	 lea	 ecx, DWORD PTR $T162040[ebp]
  00028	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T162044[ebp], 0
  0002f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00034	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00039	8d 4d f4	 lea	 ecx, DWORD PTR $T162040[ebp]
  0003c	51		 push	 ecx
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T162040[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00044	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@3:
$LN5@Allocate@3:

; 40   : 	}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN9@Allocate@3:
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::size, COMDAT
; _this$ = ecx

; 869  : 		return (this->_Mysize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 870  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::size
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rmost
; Function compile flags: /Ogtp
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00008	74 06		 je	 SHORT $LN8@operator@4

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0000f	c3		 ret	 0
$LN8@operator@4:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00016	75 17		 jne	 SHORT $LN40@operator@4

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  00018	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001b	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0001f	75 30		 jne	 SHORT $LN21@operator@4
$LL22@operator@4:
  00021	8b d1		 mov	 edx, ecx
  00023	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00026	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0002a	74 f5		 je	 SHORT $LL22@operator@4

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0002e	c3		 ret	 0
$LN40@operator@4:

; 89   : 		else
; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00036	75 11		 jne	 SHORT $LN3@operator@4
$LL4@operator@4:
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0003c	75 0b		 jne	 SHORT $LN3@operator@4

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  0003e	89 10		 mov	 DWORD PTR [eax], edx
  00040	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00043	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00047	74 ef		 je	 SHORT $LL4@operator@4
$LN3@operator@4:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0004f	75 02		 jne	 SHORT $LN1@operator@4

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

$LN21@operator@4:

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00051	89 10		 mov	 DWORD PTR [eax], edx
$LN1@operator@4:

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00053	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lmost
; Function compile flags: /Ogtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Color
; Function compile flags: /Ogtp
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		return ((char&)(*_Pnode)._Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 24	 add	 eax, 36			; 00000024H

; 608  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00008	74 06		 je	 SHORT $LN8@operator@5

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0000f	c3		 ret	 0
$LN8@operator@5:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00016	75 17		 jne	 SHORT $LN40@operator@5

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  00018	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001b	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0001f	75 30		 jne	 SHORT $LN21@operator@5
$LL22@operator@5:
  00021	8b d1		 mov	 edx, ecx
  00023	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00026	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0002a	74 f5		 je	 SHORT $LL22@operator@5

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0002e	c3		 ret	 0
$LN40@operator@5:

; 89   : 		else
; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00036	75 11		 jne	 SHORT $LN3@operator@5
$LL4@operator@5:
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0003c	75 0b		 jne	 SHORT $LN3@operator@5

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  0003e	89 10		 mov	 DWORD PTR [eax], edx
  00040	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00043	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00047	74 ef		 je	 SHORT $LL4@operator@5
$LN3@operator@5:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0004f	75 02		 jne	 SHORT $LN1@operator@5

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

$LN21@operator@5:

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00051	89 10		 mov	 DWORD PTR [eax], edx
$LN1@operator@5:

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00053	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
PUBLIC	?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z	; std::codecvt<char,char,int>::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z PROC	; std::codecvt<char,char,int>::_Init, COMDAT
; _this$ = ecx

; 863  : 		}

  00000	c2 04 00	 ret	 4
?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z ENDP	; std::codecvt<char,char,int>::_Init
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::max_size
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Max
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000d	75 0c		 jne	 SHORT $LN1@Max@3
  0000f	90		 npad	 1
$LL2@Max@3:

; 643  : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00019	74 f5		 je	 SHORT $LL2@Max@3
$LN1@Max@3:

; 644  : 		return (_Pnode);
; 645  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Min
; Function compile flags: /Ogtp
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000c	75 0c		 jne	 SHORT $LN1@Min@3
  0000e	8b ff		 npad	 2
$LL2@Min@3:

; 650  : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00018	74 f6		 je	 SHORT $LL2@Min@3
$LN1@Min@3:

; 651  : 		return (_Pnode);
; 652  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::max_size
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@KVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@KVTokenizerRow@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long,TokenizerRow> >
; Function compile flags: /Ogtp
;	COMDAT ??$forward@U?$pair@KVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@KVTokenizerRow@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@KVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@KVTokenizerRow@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long,TokenizerRow> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@KVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@KVTokenizerRow@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long,TokenizerRow> >
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long const ,TokenizerSection> >
; Function compile flags: /Ogtp
;	COMDAT ??$forward@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long const ,TokenizerSection> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long const ,TokenizerSection> >
_TEXT	ENDS
PUBLIC	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator==<char,char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 263  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 264  : 	}

  00002	c3		 ret	 0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
PUBLIC	??$forward@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
_TEXT	ENDS
PUBLIC	??$forward@AAU?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAAAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long const ,TokenizerRow> &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAU?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAAAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAAAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long const ,TokenizerRow> &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAAAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long const ,TokenizerRow> &>
_TEXT	ENDS
PUBLIC	??$addressof@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z ; std::addressof<std::pair<unsigned long const ,TokenizerSection> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z PROC ; std::addressof<std::pair<unsigned long const ,TokenizerSection> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<unsigned long const ,TokenizerSection> >
_TEXT	ENDS
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &>
_TEXT	ENDS
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
_TEXT	ENDS
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &>
_TEXT	ENDS
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T162300 = -12						; size = 12
$T162304 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 46		 je	 SHORT $LN5@Allocate@4

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 66 66 66
	06		 cmp	 ecx, 107374182		; 06666666H
  00015	77 16		 ja	 SHORT $LN1@Allocate@4
  00017	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0002b	75 28		 jne	 SHORT $LN5@Allocate@4
$LN1@Allocate@4:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T162304[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T162300[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T162304[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T162300[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T162300[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@4:
$LN5@Allocate@4:

; 40   : 	}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN9@Allocate@4:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$forward@$$CBK@std@@YA$$QBKABK@Z		; std::forward<unsigned long const >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@$$CBK@std@@YA$$QBKABK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@$$CBK@std@@YA$$QBKABK@Z PROC			; std::forward<unsigned long const >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@$$CBK@std@@YA$$QBKABK@Z ENDP			; std::forward<unsigned long const >
_TEXT	ENDS
PUBLIC	??$forward@VTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z ; std::forward<TokenizerSection>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@VTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@VTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z PROC ; std::forward<TokenizerSection>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@VTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z ENDP ; std::forward<TokenizerSection>
_TEXT	ENDS
PUBLIC	??$move@ABK@std@@YA$$QBKABK@Z			; std::move<unsigned long const &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@ABK@std@@YA$$QBKABK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@ABK@std@@YA$$QBKABK@Z PROC			; std::move<unsigned long const &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@ABK@std@@YA$$QBKABK@Z ENDP			; std::move<unsigned long const &>
_TEXT	ENDS
PUBLIC	??$forward@K@std@@YA$$QAKAAK@Z			; std::forward<unsigned long>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@K@std@@YA$$QAKAAK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@K@std@@YA$$QAKAAK@Z PROC			; std::forward<unsigned long>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@K@std@@YA$$QAKAAK@Z ENDP			; std::forward<unsigned long>
_TEXT	ENDS
PUBLIC	??$forward@VTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z ; std::forward<TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@VTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@VTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z PROC ; std::forward<TokenizerRow>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@VTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z ENDP ; std::forward<TokenizerRow>
_TEXT	ENDS
PUBLIC	??$forward@ABK@std@@YAABKABK@Z			; std::forward<unsigned long const &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@ABK@std@@YAABKABK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABK@std@@YAABKABK@Z PROC			; std::forward<unsigned long const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABK@std@@YAABKABK@Z ENDP			; std::forward<unsigned long const &>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
PUBLIC	??$forward@AAVTokenizerRow@@@std@@YAAAVTokenizerRow@@AAV1@@Z ; std::forward<TokenizerRow &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAVTokenizerRow@@@std@@YAAAVTokenizerRow@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAVTokenizerRow@@@std@@YAAAVTokenizerRow@@AAV1@@Z PROC ; std::forward<TokenizerRow &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAVTokenizerRow@@@std@@YAAAVTokenizerRow@@AAV1@@Z ENDP ; std::forward<TokenizerRow &>
_TEXT	ENDS
PUBLIC	??0CBloodCastle@@QAE@XZ				; CBloodCastle::CBloodCastle
EXTRN	__imp__InitializeCriticalSection@4:PROC
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\bloodcastle.cpp
;	COMDAT ??0CBloodCastle@@QAE@XZ
_TEXT	SEGMENT
??0CBloodCastle@@QAE@XZ PROC				; CBloodCastle::CBloodCastle, COMDAT
; _this$ = ecx

; 103  : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi
  00004	57		 push	 edi

; 104  : 	this->m_bBC_EVENT_ENABLE = false;
; 105  : 	this->m_iBC_TIME_MIN_OPEN = 10;
; 106  : 	this->m_iBC_NORMAL_ITEM_DROP = 100;
; 107  : 	this->m_iBC_EXCEL_ITEM_DROP = 1200;
; 108  : 	this->m_iBC_MONSTER_REGEN = 0;

  00005	33 ff		 xor	 edi, edi
  00007	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7CBloodCastle@@6B@
  0000d	c6 83 04 0e 00
	00 00		 mov	 BYTE PTR [ebx+3588], 0
  00014	c7 83 08 0e 00
	00 0a 00 00 00	 mov	 DWORD PTR [ebx+3592], 10 ; 0000000aH
  0001e	c7 83 14 0e 00
	00 64 00 00 00	 mov	 DWORD PTR [ebx+3604], 100 ; 00000064H
  00028	c7 83 18 0e 00
	00 b0 04 00 00	 mov	 DWORD PTR [ebx+3608], 1200 ; 000004b0H
  00032	89 bb 1c 0e 00
	00		 mov	 DWORD PTR [ebx+3612], edi
  00038	8d b3 40 01 00
	00		 lea	 esi, DWORD PTR [ebx+320]
  0003e	8b ff		 npad	 2
$LL8@CBloodCast@2:

; 109  : 
; 110  : 	for ( int i =0; i<MAX_BLOOD_CASTLE_LEVEL ; i++ )
; 111  : 	{
; 112  : 		this->m_BridgeData[i].m_iBC_STATE = BC_STATE_NONE;
; 113  : 		this->m_BridgeData[i].m_iMapNumber = i + MAP_INDEX_BLOODCASTLE1;

  00040	8d 47 0b	 lea	 eax, DWORD PTR [edi+11]
  00043	89 06		 mov	 DWORD PTR [esi], eax

; 114  : 		this->m_BridgeData[i].m_iBridgeIndex = i;
; 115  : 		this->m_BridgeData[i].m_iBC_REMAIN_MSEC = -1;

  00045	83 c8 ff	 or	 eax, -1

; 116  : 		this->m_BridgeData[i].m_iBC_TICK_COUNT = -1;
; 117  : 		this->m_BridgeData[i].m_nSaintStatuePosNum = -1;
; 118  : 		this->m_BridgeData[i].m_nCastleDoorPosNum = -1;
; 119  : 		this->m_BridgeData[i].m_iAngelKingPosNum = -1;
; 120  : 		InitializeCriticalSection(&this->m_BridgeData[i].m_critUserData);

  00048	8d 8e c4 fe ff
	ff		 lea	 ecx, DWORD PTR [esi-316]
  0004e	51		 push	 ecx
  0004f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00056	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00059	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0005c	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0005f	89 46 f4	 mov	 DWORD PTR [esi-12], eax
  00062	89 46 f8	 mov	 DWORD PTR [esi-8], eax
  00065	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 121  : 		this->ClearBridgeData(i);

  0006e	57		 push	 edi
  0006f	8b cb		 mov	 ecx, ebx
  00071	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData
  00076	47		 inc	 edi
  00077	81 c6 00 02 00
	00		 add	 esi, 512		; 00000200H
  0007d	83 ff 07	 cmp	 edi, 7
  00080	7c be		 jl	 SHORT $LL8@CBloodCast@2

; 122  : 	}
; 123  : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	8b c3		 mov	 eax, ebx
  00086	5b		 pop	 ebx
  00087	c3		 ret	 0
??0CBloodCastle@@QAE@XZ ENDP				; CBloodCastle::CBloodCastle
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCBloodCastle@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCBloodCastle@@UAEPAXI@Z PROC			; CBloodCastle::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CBloodCastle@@UAE@XZ	; CBloodCastle::~CBloodCastle
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@8
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@8:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCBloodCastle@@UAEPAXI@Z ENDP			; CBloodCastle::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Ti@ ; `string'
PUBLIC	?CheckSync@CBloodCastle@@IAEXH@Z		; CBloodCastle::CheckSync
EXTRN	__imp__GetTickCount@0:PROC
;	COMDAT ??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Ti@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
CONST	SEGMENT
??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Ti@ DB '['
	DB	'Blood Castle] (%d) Sync Open Time. [%d] min remain', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\bloodcastle.cpp
CONST	ENDS
;	COMDAT ?CheckSync@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_ltime$ = -8						; size = 8
_iBridgeIndex$ = 8					; size = 4
?CheckSync@CBloodCastle@@IAEXH@Z PROC			; CBloodCastle::CheckSync, COMDAT
; _this$ = ecx

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 265  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 db		 test	 ebx, ebx
  0000f	0f 88 38 01 00
	00		 js	 $LN15@CheckSync
  00015	33 c0		 xor	 eax, eax
  00017	83 fb 06	 cmp	 ebx, 6
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 28 01 00
	00		 je	 $LN15@CheckSync

; 266  : 	{
; 267  : 		return;
; 268  : 	}
; 269  : 
; 270  : 	tm * today;
; 271  : 	time_t ltime;
; 272  : 
; 273  : 	time(&ltime);

  00025	8d 45 f8	 lea	 eax, DWORD PTR _ltime$[ebp]
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 __time64

; 274  : 	today = localtime(&ltime);

  0002f	8d 4d f8	 lea	 ecx, DWORD PTR _ltime$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 __localtime64

; 275  : 
; 276  : 	if ( BC_TIME_RANGE(g_iBloodCastle_StartHour-1) == FALSE )

  00038	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_iBloodCastle_StartHour@@3HA ; g_iBloodCastle_StartHour
  0003e	8d 7a ff	 lea	 edi, DWORD PTR [edx-1]
  00041	83 c4 08	 add	 esp, 8
  00044	85 ff		 test	 edi, edi
  00046	78 0c		 js	 SHORT $LN25@CheckSync
  00048	33 c9		 xor	 ecx, ecx
  0004a	83 ff 01	 cmp	 edi, 1
  0004d	0f 9e c1	 setle	 cl
  00050	85 c9		 test	 ecx, ecx
  00052	75 0b		 jne	 SHORT $LN13@CheckSync
$LN25@CheckSync:

; 277  : 	{
; 278  : 		g_iBloodCastle_StartHour = 1;

  00054	ba 01 00 00 00	 mov	 edx, 1
  00059	89 15 00 00 00
	00		 mov	 DWORD PTR ?g_iBloodCastle_StartHour@@3HA, edx ; g_iBloodCastle_StartHour
$LN13@CheckSync:

; 279  : 	}
; 280  : 
; 281  : 	switch ( g_iBloodCastle_StartHour )

  0005f	83 ea 02	 sub	 edx, 2
  00062	74 46		 je	 SHORT $LN10@CheckSync

; 307  : 			break;
; 308  : 
; 309  : 		default:
; 310  : 
; 311  : 			if ( ( today->tm_min*60 + today->tm_sec ) >= 1800 )

  00064	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00067	8b 10		 mov	 edx, DWORD PTR [eax]
  00069	8b c1		 mov	 eax, ecx
  0006b	c1 e0 04	 shl	 eax, 4
  0006e	2b c1		 sub	 eax, ecx

; 312  : 			{
; 313  : 				this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (5400 - (today->tm_min*60 + today->tm_sec)) * 1000;

  00070	8b fb		 mov	 edi, ebx
  00072	c1 e7 09	 shl	 edi, 9
  00075	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  00078	03 fe		 add	 edi, esi
  0007a	3d 08 07 00 00	 cmp	 eax, 1800		; 00000708H
  0007f	8d b7 54 01 00
	00		 lea	 esi, DWORD PTR [edi+340]
  00085	b8 5a 00 00 00	 mov	 eax, 90			; 0000005aH
  0008a	7d 05		 jge	 SHORT $LN30@CheckSync
$LN8@CheckSync:

; 314  : 			}
; 315  : 			else
; 316  : 			{
; 317  : 				this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (1800 - (today->tm_min*60 + today->tm_sec)) * 1000;

  0008c	b8 1e 00 00 00	 mov	 eax, 30			; 0000001eH
$LN30@CheckSync:
  00091	2b c1		 sub	 eax, ecx
  00093	8b c8		 mov	 ecx, eax
  00095	c1 e1 04	 shl	 ecx, 4
  00098	2b c8		 sub	 ecx, eax
  0009a	03 c9		 add	 ecx, ecx
  0009c	03 c9		 add	 ecx, ecx
  0009e	2b ca		 sub	 ecx, edx
  000a0	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  000a6	89 0e		 mov	 DWORD PTR [esi], ecx

; 318  : 			}
; 319  : 
; 320  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 0 )
; 321  : 			{
; 322  : 				this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC += 3600000;
; 323  : 			}
; 324  : 			this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();
; 325  : 
; 326  : 			break;

  000a8	eb 64		 jmp	 SHORT $LN6@CheckSync
$LN10@CheckSync:

; 282  : 	{
; 283  : 		case 2:
; 284  : 			
; 285  : 			if ( (today->tm_hour%2) == 0 )

  000aa	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ad	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  000b3	79 05		 jns	 SHORT $LN26@CheckSync
  000b5	4a		 dec	 edx
  000b6	83 ca fe	 or	 edx, -2			; fffffffeH
  000b9	42		 inc	 edx
$LN26@CheckSync:

; 288  : 				{
; 289  : 					this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (9000 - (today->tm_min*60 + today->tm_sec)) * 1000;

  000ba	8b fb		 mov	 edi, ebx

; 282  : 	{
; 283  : 		case 2:
; 284  : 			
; 285  : 			if ( (today->tm_hour%2) == 0 )

  000bc	75 28		 jne	 SHORT $LN9@CheckSync

; 286  : 			{
; 287  : 				if ( ( today->tm_min*60 + today->tm_sec ) >= 1800 )

  000be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c1	8b 10		 mov	 edx, DWORD PTR [eax]
  000c3	8b c1		 mov	 eax, ecx
  000c5	c1 e0 04	 shl	 eax, 4
  000c8	2b c1		 sub	 eax, ecx

; 288  : 				{
; 289  : 					this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (9000 - (today->tm_min*60 + today->tm_sec)) * 1000;

  000ca	c1 e7 09	 shl	 edi, 9
  000cd	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  000d0	03 fe		 add	 edi, esi
  000d2	8d b7 54 01 00
	00		 lea	 esi, DWORD PTR [edi+340]
  000d8	3d 08 07 00 00	 cmp	 eax, 1800		; 00000708H
  000dd	7c ad		 jl	 SHORT $LN8@CheckSync
  000df	b8 96 00 00 00	 mov	 eax, 150		; 00000096H

; 290  : 				}
; 291  : 				else

  000e4	eb ab		 jmp	 SHORT $LN30@CheckSync
$LN9@CheckSync:

; 292  : 				{
; 293  : 					this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (1800 - (today->tm_min*60 + today->tm_sec)) * 1000;
; 294  : 				}
; 295  : 			}
; 296  : 			else
; 297  : 			{
; 298  : 				this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (5400 - (today->tm_min*60 + today->tm_sec)) * 1000;

  000e6	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  000eb	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  000ee	c1 e7 09	 shl	 edi, 9
  000f1	8b d1		 mov	 edx, ecx
  000f3	c1 e2 04	 shl	 edx, 4
  000f6	2b d1		 sub	 edx, ecx
  000f8	03 d2		 add	 edx, edx
  000fa	03 d2		 add	 edx, edx
  000fc	2b 10		 sub	 edx, DWORD PTR [eax]
  000fe	03 fe		 add	 edi, esi
  00100	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  00106	8d b7 54 01 00
	00		 lea	 esi, DWORD PTR [edi+340]
  0010c	89 16		 mov	 DWORD PTR [esi], edx
$LN6@CheckSync:

; 299  : 			}
; 300  : 
; 301  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 0 )

  0010e	8b 06		 mov	 eax, DWORD PTR [esi]
  00110	85 c0		 test	 eax, eax
  00112	79 07		 jns	 SHORT $LN5@CheckSync

; 302  : 			{
; 303  : 				this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC += 3600000;

  00114	05 80 ee 36 00	 add	 eax, 3600000		; 0036ee80H
  00119	89 06		 mov	 DWORD PTR [esi], eax
$LN5@CheckSync:

; 304  : 			}
; 305  : 
; 306  : 			this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 327  : 
; 328  : 	}
; 329  : 
; 330  : 	LogAdd(LOG_BLACK, "[Blood Castle] (%d) Sync Open Time. [%d] min remain",
; 331  : 		iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 60000);

  00121	8b 36		 mov	 esi, DWORD PTR [esi]
  00123	89 87 58 01 00
	00		 mov	 DWORD PTR [edi+344], eax
  00129	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  0012e	f7 ee		 imul	 esi
  00130	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00133	8b c2		 mov	 eax, edx
  00135	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00138	03 c2		 add	 eax, edx
  0013a	50		 push	 eax
  0013b	43		 inc	 ebx
  0013c	53		 push	 ebx
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Ti@
  00142	6a 00		 push	 0
  00144	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00149	83 c4 10	 add	 esp, 16			; 00000010H
  0014c	5f		 pop	 edi
$LN15@CheckSync:
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx

; 332  : 
; 333  : 
; 334  : }

  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c2 04 00	 ret	 4
?CheckSync@CBloodCastle@@IAEXH@Z ENDP			; CBloodCastle::CheckSync
_TEXT	ENDS
PUBLIC	?SetState_None@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_None
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
; Function compile flags: /Ogtp
;	COMDAT ?SetState_None@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_n$157469 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_None@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_None, COMDAT
; _this$ = ecx

; 766  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 767  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	0f 88 8a 00 00
	00		 js	 $LN6@SetState_N
  00012	33 c0		 xor	 eax, eax
  00014	83 fe 06	 cmp	 esi, 6
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 7a 00 00
	00		 je	 $LN6@SetState_N

; 768  : 	{
; 769  : 		return;
; 770  : 	}
; 771  : 
; 772  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = -1;

  00022	57		 push	 edi
  00023	83 c9 ff	 or	 ecx, -1
  00026	8b c6		 mov	 eax, esi
  00028	c1 e0 09	 shl	 eax, 9

; 773  : 	this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = -1;
; 774  : 	this->SendNoticeState(iBridgeIndex, 2);

  0002b	6a 02		 push	 2
  0002d	89 8c 18 54 01
	00 00		 mov	 DWORD PTR [eax+ebx+340], ecx
  00034	89 8c 18 58 01
	00 00		 mov	 DWORD PTR [eax+ebx+344], ecx
  0003b	56		 push	 esi
  0003c	8b cb		 mov	 ecx, ebx
  0003e	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 775  : 	this->ClearBridgeData(iBridgeIndex);

  00043	56		 push	 esi
  00044	8b cb		 mov	 ecx, ebx
  00046	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData

; 776  : 	this->ClearMonster(iBridgeIndex, 1);

  0004b	6a 01		 push	 1
  0004d	56		 push	 esi
  0004e	8b cb		 mov	 ecx, ebx
  00050	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 777  : 
; 778  : 	for (int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  00055	c7 45 08 00 19
	00 00		 mov	 DWORD PTR _n$157469[ebp], 6400 ; 00001900H
  0005c	bf 04 c4 16 02	 mov	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046404
$LL4@SetState_N:

; 779  : 	{
; 780  : 		if ( gObj[n].MapNumber == iBridgeIndex + 11 && gObj[n].Connected == PLAYER_PLAYING )

  00061	0f b6 8f 05 01
	00 00		 movzx	 ecx, BYTE PTR [edi+261]
  00068	8d 46 0b	 lea	 eax, DWORD PTR [esi+11]
  0006b	3b c8		 cmp	 ecx, eax
  0006d	75 13		 jne	 SHORT $LN3@SetState_N
  0006f	80 3f 03	 cmp	 BYTE PTR [edi], 3
  00072	75 0e		 jne	 SHORT $LN3@SetState_N

; 781  : 		{
; 782  : 			gObjMoveGate(n, 22);

  00074	8b 55 08	 mov	 edx, DWORD PTR _n$157469[ebp]
  00077	6a 16		 push	 22			; 00000016H
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0007f	83 c4 08	 add	 esp, 8
$LN3@SetState_N:

; 777  : 
; 778  : 	for (int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  00082	ff 45 08	 inc	 DWORD PTR _n$157469[ebp]
  00085	81 c7 64 15 00
	00		 add	 edi, 5476		; 00001564H
  0008b	81 ff a4 52 6a
	02		 cmp	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522404
  00091	7c ce		 jl	 SHORT $LL4@SetState_N

; 783  : 		}
; 784  : 	}
; 785  : 
; 786  : 	this->BlockCastleDoor(iBridgeIndex);

  00093	56		 push	 esi
  00094	8b cb		 mov	 ecx, ebx
  00096	e8 00 00 00 00	 call	 ?BlockCastleDoor@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleDoor
  0009b	5f		 pop	 edi
$LN6@SetState_N:
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx

; 787  : }

  0009e	5d		 pop	 ebp
  0009f	c2 04 00	 ret	 4
?SetState_None@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_None
_TEXT	ENDS
PUBLIC	??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ ; `string'
PUBLIC	?SetState_Closed@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_Closed
;	COMDAT ??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
CONST	SEGMENT
??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ DB '['
	DB	'Blood Castle] (%d) SetState CLOSED', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_Closed@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_n$157479 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_Closed@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_Closed, COMDAT
; _this$ = ecx

; 793  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 794  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	0f 88 ae 00 00
	00		 js	 $LN6@SetState_C
  00012	33 c0		 xor	 eax, eax
  00014	83 fe 06	 cmp	 esi, 6
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 9e 00 00
	00		 je	 $LN6@SetState_C

; 795  : 	{
; 796  : 		return;
; 797  : 	}
; 798  : 
; 799  : 	this->SendNoticeState(iBridgeIndex, 2);

  00022	53		 push	 ebx
  00023	6a 02		 push	 2
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 800  : 	this->ClearBridgeData(iBridgeIndex);

  0002b	56		 push	 esi
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData

; 801  : 	this->ClearMonster(iBridgeIndex, 1);

  00033	6a 01		 push	 1
  00035	56		 push	 esi
  00036	8b cf		 mov	 ecx, edi
  00038	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 802  : 	this->CheckAngelKingExist(iBridgeIndex);

  0003d	56		 push	 esi
  0003e	8b cf		 mov	 ecx, edi
  00040	e8 00 00 00 00	 call	 ?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckAngelKingExist

; 803  : 
; 804  : 	for (int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  00045	c7 45 08 00 19
	00 00		 mov	 DWORD PTR _n$157479[ebp], 6400 ; 00001900H
  0004c	bb 04 c4 16 02	 mov	 ebx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046404
$LL4@SetState_C:

; 805  : 	{
; 806  : 		if ( gObj[n].MapNumber == iBridgeIndex + 11 && gObj[n].Connected > PLAYER_LOGGED )

  00051	0f b6 8b 05 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+261]
  00058	8d 46 0b	 lea	 eax, DWORD PTR [esi+11]
  0005b	3b c8		 cmp	 ecx, eax
  0005d	75 1e		 jne	 SHORT $LN3@SetState_C
  0005f	80 3b 02	 cmp	 BYTE PTR [ebx], 2
  00062	76 19		 jbe	 SHORT $LN3@SetState_C

; 807  : 		{
; 808  : 			this->SearchUserDeleteQuestItem(n);

  00064	8b 55 08	 mov	 edx, DWORD PTR _n$157479[ebp]
  00067	52		 push	 edx
  00068	8b cf		 mov	 ecx, edi
  0006a	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem

; 809  : 			gObjMoveGate(n, 22);

  0006f	8b 45 08	 mov	 eax, DWORD PTR _n$157479[ebp]
  00072	6a 16		 push	 22			; 00000016H
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0007a	83 c4 08	 add	 esp, 8
$LN3@SetState_C:

; 803  : 
; 804  : 	for (int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  0007d	ff 45 08	 inc	 DWORD PTR _n$157479[ebp]
  00080	81 c3 64 15 00
	00		 add	 ebx, 5476		; 00001564H
  00086	81 fb a4 52 6a
	02		 cmp	 ebx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522404
  0008c	7c c3		 jl	 SHORT $LL4@SetState_C

; 810  : 		}
; 811  : 	}
; 812  : 
; 813  : 	this->BlockCastleDoor(iBridgeIndex);

  0008e	56		 push	 esi
  0008f	8b cf		 mov	 ecx, edi
  00091	e8 00 00 00 00	 call	 ?BlockCastleDoor@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleDoor

; 814  : 	this->BlockCastleBridge(iBridgeIndex);

  00096	56		 push	 esi
  00097	8b cf		 mov	 ecx, edi
  00099	e8 00 00 00 00	 call	 ?BlockCastleBridge@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleBridge

; 815  : 	this->BlockCastleEntrance(iBridgeIndex);

  0009e	56		 push	 esi
  0009f	8b cf		 mov	 ecx, edi
  000a1	e8 00 00 00 00	 call	 ?BlockCastleEntrance@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleEntrance

; 816  : 	this->CheckSync(iBridgeIndex);

  000a6	56		 push	 esi
  000a7	8b cf		 mov	 ecx, edi
  000a9	e8 00 00 00 00	 call	 ?CheckSync@CBloodCastle@@IAEXH@Z ; CBloodCastle::CheckSync

; 817  : 	LogAdd(LOG_BLACK, "[Blood Castle] (%d) SetState CLOSED", iBridgeIndex+1);

  000ae	46		 inc	 esi
  000af	56		 push	 esi
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
  000b5	6a 00		 push	 0
  000b7	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bf	5b		 pop	 ebx
$LN6@SetState_C:
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi

; 818  : }

  000c2	5d		 pop	 ebp
  000c3	c2 04 00	 ret	 4
?SetState_Closed@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_Closed
_TEXT	ENDS
PUBLIC	??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?SetState_Playing@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_Playing
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
;	COMDAT ??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
CONST	SEGMENT
??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Blood Castle] (%d) SetState PLAYING', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_Playing@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv214 = -292						; size = 4
tv205 = -288						; size = 4
_ServerCmd$ = -284					; size = 7
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_Playing@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_Playing, COMDAT
; _this$ = ecx

; 826  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00017	57		 push	 edi
  00018	8b f9		 mov	 edi, ecx

; 827  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0001a	85 f6		 test	 esi, esi
  0001c	0f 88 11 01 00
	00		 js	 $LN6@SetState_P
  00022	33 c0		 xor	 eax, eax
  00024	83 fe 06	 cmp	 esi, 6
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 01 01 00
	00		 je	 $LN6@SetState_P

; 828  : 	{
; 829  : 		return;
; 830  : 	}
; 831  : 
; 832  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;

  00032	8b c6		 mov	 eax, esi
  00034	c1 e0 09	 shl	 eax, 9
  00037	c6 84 38 63 01
	00 00 00	 mov	 BYTE PTR [eax+edi+355], 0

; 833  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = this->m_iBC_TIME_MIN_PLAY*60*1000;

  0003f	8b 8f 0c 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3596]
  00045	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H
  0004b	53		 push	 ebx
  0004c	89 8c 38 54 01
	00 00		 mov	 DWORD PTR [eax+edi+340], ecx

; 834  : 	this->CheckUsersOnConnect(iBridgeIndex);

  00053	56		 push	 esi
  00054	8b cf		 mov	 ecx, edi
  00056	e8 00 00 00 00	 call	 ?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z ; CBloodCastle::CheckUsersOnConnect

; 835  : 
; 836  : 	PMSG_NOTICE pNotice;
; 837  : 
; 838  : 	TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 139)), iBridgeIndex+1, 60);

  0005b	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0005e	6a 3c		 push	 60			; 0000003cH
  00060	50		 push	 eax
  00061	68 8b 04 00 00	 push	 1163			; 0000048bH
  00066	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0006b	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv205[ebp], eax
  00071	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00076	50		 push	 eax
  00077	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$[ebp]
  0007d	6a 01		 push	 1
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 839  : 	this->SendBridgeAnyMsg( (LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  00085	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  0008c	83 c4 14	 add	 esp, 20			; 00000014H
  0008f	56		 push	 esi
  00090	50		 push	 eax
  00091	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  00097	51		 push	 ecx
  00098	8b cf		 mov	 ecx, edi
  0009a	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 840  : 
; 841  : 	PMSG_SERVERCMD ServerCmd;
; 842  : 
; 843  : 	PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  0009f	6a 07		 push	 7
  000a1	6a 40		 push	 64			; 00000040H
  000a3	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _ServerCmd$[ebp]
  000a9	68 f3 00 00 00	 push	 243			; 000000f3H
  000ae	52		 push	 edx
  000af	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 844  : 	ServerCmd.CmdType = 1;
; 845  : 	ServerCmd.X = 45;
; 846  : 	ServerCmd.Y = 0;
; 847  : 
; 848  : 	this->SendBridgeAnyMsg((BYTE *)&ServerCmd, ServerCmd.h.size, iBridgeIndex);

  000b4	0f b6 85 e5 fe
	ff ff		 movzx	 eax, BYTE PTR _ServerCmd$[ebp+1]
  000bb	83 c4 10	 add	 esp, 16			; 00000010H
  000be	56		 push	 esi
  000bf	50		 push	 eax
  000c0	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _ServerCmd$[ebp]
  000c6	51		 push	 ecx
  000c7	8b cf		 mov	 ecx, edi
  000c9	66 c7 85 e8 fe
	ff ff 01 2d	 mov	 WORD PTR _ServerCmd$[ebp+4], 11521 ; 00002d01H
  000d2	c6 85 ea fe ff
	ff 00		 mov	 BYTE PTR _ServerCmd$[ebp+6], 0
  000d9	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 851  : 	{
; 852  : 		if ( gObj[n].MapNumber == iBridgeIndex + 11 && gObj[n].Connected > PLAYER_LOGGED )

  000de	83 c6 0b	 add	 esi, 11			; 0000000bH
  000e1	89 b5 dc fe ff
	ff		 mov	 DWORD PTR tv214[ebp], esi
  000e7	bb 00 19 00 00	 mov	 ebx, 6400		; 00001900H
  000ec	be 04 c4 16 02	 mov	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046404
$LL12@SetState_P:
  000f1	0f b6 96 05 01
	00 00		 movzx	 edx, BYTE PTR [esi+261]
  000f8	3b 95 dc fe ff
	ff		 cmp	 edx, DWORD PTR tv214[ebp]
  000fe	75 0d		 jne	 SHORT $LN3@SetState_P
  00100	80 3e 02	 cmp	 BYTE PTR [esi], 2
  00103	76 08		 jbe	 SHORT $LN3@SetState_P

; 853  : 		{
; 854  : 			this->SearchUserDeleteQuestItem(n);

  00105	53		 push	 ebx
  00106	8b cf		 mov	 ecx, edi
  00108	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN3@SetState_P:

; 849  : 
; 850  : 	for (int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  0010d	81 c6 64 15 00
	00		 add	 esi, 5476		; 00001564H
  00113	43		 inc	 ebx
  00114	81 fe a4 52 6a
	02		 cmp	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522404
  0011a	7c d5		 jl	 SHORT $LL12@SetState_P

; 855  : 		}
; 856  : 	}
; 857  : 
; 858  : 	LogAdd(LOG_BLACK, "[Blood Castle] (%d) SetState PLAYING", iBridgeIndex+1);

  0011c	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv205[ebp]
  00122	50		 push	 eax
  00123	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  00128	6a 00		 push	 0
  0012a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0012f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00132	5b		 pop	 ebx
$LN6@SetState_P:

; 859  : }

  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	5f		 pop	 edi
  00137	33 cd		 xor	 ecx, ebp
  00139	5e		 pop	 esi
  0013a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c2 04 00	 ret	 4
?SetState_Playing@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_Playing
_TEXT	ENDS
PUBLIC	??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
PUBLIC	?SetState_PlayEnd@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_PlayEnd
;	COMDAT ??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
CONST	SEGMENT
??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Blood Castle] (%d) SetState PLAYEND', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_PlayEnd@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?SetState_PlayEnd@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_PlayEnd, COMDAT
; _this$ = ecx

; 867  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 868  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 7b		 js	 SHORT $LN2@SetState_P@2
  0000e	33 c0		 xor	 eax, eax
  00010	83 fe 06	 cmp	 esi, 6
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 6f		 je	 SHORT $LN2@SetState_P@2

; 869  : 	{
; 870  : 		return;
; 871  : 	}
; 872  : 
; 873  : 	this->SendNoticeState(iBridgeIndex, 2);

  0001a	57		 push	 edi
  0001b	6a 02		 push	 2
  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 874  : 	this->ClearMonster(iBridgeIndex, 0);

  00023	6a 00		 push	 0
  00025	56		 push	 esi
  00026	8b cb		 mov	 ecx, ebx
  00028	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 875  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;

  0002d	8b fe		 mov	 edi, esi
  0002f	c1 e7 09	 shl	 edi, 9
  00032	03 fb		 add	 edi, ebx
  00034	c6 87 63 01 00
	00 00		 mov	 BYTE PTR [edi+355], 0

; 876  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = this->m_iBC_TIME_MIN_REST*60*1000;

  0003b	8b 8b 10 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3600]
  00041	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H

; 877  : 
; 878  : 	LogAdd(LOG_BLACK, "[Blood Castle] (%d) SetState PLAYEND", iBridgeIndex+1);

  00047	46		 inc	 esi
  00048	56		 push	 esi
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  0004e	6a 00		 push	 0
  00050	89 8f 54 01 00
	00		 mov	 DWORD PTR [edi+340], ecx
  00056	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	83 c7 1c	 add	 edi, 28			; 0000001cH
  00061	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
$LL4@SetState_P@2:

; 881  : 	{
; 882  : 		if ( OBJMAX_RANGE(this->m_BridgeData[iBridgeIndex].m_UserData[n].m_iIndex) != FALSE )

  00066	8b 07		 mov	 eax, DWORD PTR [edi]
  00068	85 c0		 test	 eax, eax
  0006a	78 16		 js	 SHORT $LN3@SetState_P@2
  0006c	33 c9		 xor	 ecx, ecx
  0006e	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00073	0f 9e c1	 setle	 cl
  00076	85 c9		 test	 ecx, ecx
  00078	74 08		 je	 SHORT $LN3@SetState_P@2

; 883  : 		{
; 884  : 			this->SearchUserDeleteQuestItem(this->m_BridgeData[iBridgeIndex].m_UserData[n].m_iIndex);

  0007a	50		 push	 eax
  0007b	8b cb		 mov	 ecx, ebx
  0007d	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN3@SetState_P@2:

; 879  : 
; 880  : 	for (int n=0;n<MAX_BLOOD_CASTLE_SUB_BRIDGE;n++)

  00082	83 c7 14	 add	 edi, 20			; 00000014H
  00085	4e		 dec	 esi
  00086	75 de		 jne	 SHORT $LL4@SetState_P@2
  00088	5f		 pop	 edi
$LN2@SetState_P@2:
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx

; 885  : 		}
; 886  : 	}
; 887  : }

  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
?SetState_PlayEnd@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_PlayEnd
_TEXT	ENDS
PUBLIC	?SetMonster@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetMonster
; Function compile flags: /Ogtp
;	COMDAT ?SetMonster@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv427 = -12						; size = 4
_n$157790 = -8						; size = 4
_iIndex$157787 = -8					; size = 4
_btBridgeIndex$157797 = -1				; size = 1
_iBridgeIndex$ = 8					; size = 4
?SetMonster@CBloodCastle@@QAEXH@Z PROC			; CBloodCastle::SetMonster, COMDAT
; _this$ = ecx

; 1617 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 1618 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00007	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  00010	85 f6		 test	 esi, esi
  00012	0f 88 6b 02 00
	00		 js	 $LN9@SetMonster@2
  00018	33 c0		 xor	 eax, eax
  0001a	83 fe 06	 cmp	 esi, 6
  0001d	0f 9e c0	 setle	 al
  00020	85 c0		 test	 eax, eax
  00022	0f 84 5b 02 00
	00		 je	 $LN9@SetMonster@2

; 1619 : 	{
; 1620 : 		return;
; 1621 : 	}
; 1622 : 
; 1623 : 	this->SetMonsterKillCount(iBridgeIndex);

  00028	53		 push	 ebx
  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ?SetMonsterKillCount@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetMonsterKillCount

; 1624 : 	int nCastleDoorPosNum = this->m_BridgeData[iBridgeIndex].m_nCastleDoorPosNum;

  0002f	c1 e6 09	 shl	 esi, 9
  00032	8b b4 3e 38 01
	00 00		 mov	 esi, DWORD PTR [esi+edi+312]

; 1625 : 	BYTE btMonsterType = gMSetBase.m_Mp[nCastleDoorPosNum].m_Type;

  00039	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  0003c	03 c0		 add	 eax, eax
  0003e	8a 8c 00 06 00
	00 00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+eax+6]
  00045	03 c0		 add	 eax, eax

; 1626 : 	BYTE btMapNumber = gMSetBase.m_Mp[nCastleDoorPosNum].m_MapNumber;

  00047	8a 80 08 00 00
	00		 mov	 al, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]

; 1627 : 	BYTE btBloodCastleIndex = btMapNumber - MAP_INDEX_BLOODCASTLE1;

  0004d	8d 58 f5	 lea	 ebx, DWORD PTR [eax-11]

; 1628 : 
; 1629 : 	if ( nCastleDoorPosNum != -1 )

  00050	83 fe ff	 cmp	 esi, -1
  00053	0f 84 a5 00 00
	00		 je	 $LN29@SetMonster@2

; 1630 : 	{
; 1631 : 		if ( btMonsterType == 131 )

  00059	80 f9 83	 cmp	 cl, 131			; 00000083H
  0005c	0f 85 9c 00 00
	00		 jne	 $LN29@SetMonster@2

; 1632 : 		{
; 1633 : 			int iIndex = ::gObjAddMonster(btMapNumber);

  00062	0f b6 c0	 movzx	 eax, al
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0006b	98		 cwde
  0006c	83 c4 04	 add	 esp, 4
  0006f	89 45 f8	 mov	 DWORD PTR _iIndex$157787[ebp], eax

; 1634 : 
; 1635 : 			if ( iIndex >= 0 )

  00072	85 c0		 test	 eax, eax
  00074	0f 88 84 00 00
	00		 js	 $LN29@SetMonster@2

; 1636 : 			{
; 1637 : 				::gObjSetPosMonster(iIndex, nCastleDoorPosNum);

  0007a	56		 push	 esi
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 1638 : 				::gObjSetMonster(iIndex, btMonsterType);

  00081	8b 75 f8	 mov	 esi, DWORD PTR _iIndex$157787[ebp]
  00084	68 83 00 00 00	 push	 131			; 00000083H
  00089	56		 push	 esi
  0008a	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1639 : 
; 1640 : 				gObj[iIndex].m_cBloodCastleIndex = btBloodCastleIndex;

  0008f	8b c6		 mov	 eax, esi
  00091	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00097	88 98 02 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330], bl

; 1641 : 				gObj[iIndex].m_ItemRate = this->m_iBC_NORMAL_ITEM_DROP;

  0009d	66 8b 8f 14 0e
	00 00		 mov	 cx, WORD PTR [edi+3604]
  000a4	66 89 88 28 03
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+808], cx

; 1642 : 				gObj[iIndex].Dir = 1;
; 1643 : 				gObj[iIndex].m_PosNum = -1;
; 1644 : 				gObj[iIndex].Live = TRUE;
; 1645 : 				gObj[iIndex].DieRegen = FALSE;
; 1646 : 				gObj[iIndex].m_State = 1;
; 1647 : 				gObj[iIndex].MaxRegenTime = 0;
; 1648 : 				gObj[iIndex].MaxLife = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  000ab	0f b6 cb	 movzx	 ecx, bl
  000ae	83 ca ff	 or	 edx, -1
  000b1	83 c4 10	 add	 esp, 16			; 00000010H
  000b4	c1 e1 09	 shl	 ecx, 9
  000b7	8d bc 39 6c 01
	00 00		 lea	 edi, DWORD PTR [ecx+edi+364]
  000be	c6 80 08 01 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+264], 1
  000c5	66 89 90 10 02
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+528], dx
  000cc	c6 80 62 00 00
	00 01		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+98], 1
  000d3	c6 80 02 02 00
	00 00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+514], 0
  000da	c7 80 bc 01 00
	00 01 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+444], 1
  000e4	c7 80 0c 02 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+524], 0
  000ee	d9 07		 fld	 DWORD PTR [edi]
  000f0	d9 98 c0 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+192]

; 1649 : 				gObj[iIndex].Life = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  000f6	d9 07		 fld	 DWORD PTR [edi]
  000f8	d9 98 bc 00 00
	00		 fstp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+188]
$LN29@SetMonster@2:

; 1650 : 			}
; 1651 : 		}
; 1652 : 	}
; 1653 : 
; 1654 : 	int result;
; 1655 : 	for ( int n=0;n<gMSetBase.m_Count;n++)

  000fe	33 db		 xor	 ebx, ebx
  00100	89 5d f8	 mov	 DWORD PTR _n$157790[ebp], ebx
  00103	39 1d e4 0f 01
	00		 cmp	 DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+69604, ebx
  00109	0f 8e 73 01 00
	00		 jle	 $LN30@SetMonster@2
  0010f	bf 08 00 00 00	 mov	 edi, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A+8
$LL11@SetMonster@2:

; 1656 : 	{
; 1657 : 		if ( BC_MAP_RANGE(gMSetBase.m_Mp[n].m_MapNumber) != FALSE  )

  00114	8a 17		 mov	 dl, BYTE PTR [edi]
  00116	80 fa 0b	 cmp	 dl, 11			; 0000000bH
  00119	0f 82 50 01 00
	00		 jb	 $LN10@SetMonster@2
  0011f	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  00124	3a c2		 cmp	 al, dl
  00126	1b c0		 sbb	 eax, eax
  00128	40		 inc	 eax
  00129	0f 84 40 01 00
	00		 je	 $LN10@SetMonster@2

; 1658 : 		{
; 1659 : 			BYTE btIndex = gMSetBase.m_Mp[n].m_Type;

  0012f	8a 47 fe	 mov	 al, BYTE PTR [edi-2]

; 1660 : 			BYTE btMap   = gMSetBase.m_Mp[n].m_MapNumber;
; 1661 : 			BYTE btBridgeIndex = btMap - MAP_INDEX_BLOODCASTLE1;

  00132	8d 4a f5	 lea	 ecx, DWORD PTR [edx-11]
  00135	88 4d ff	 mov	 BYTE PTR _btBridgeIndex$157797[ebp], cl

; 1662 : 			
; 1663 : 			if ( btBridgeIndex != iBridgeIndex )

  00138	0f b6 c9	 movzx	 ecx, cl
  0013b	3b 4d 08	 cmp	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0013e	0f 85 2b 01 00
	00		 jne	 $LN10@SetMonster@2

; 1664 : 			{
; 1665 : 				continue;
; 1666 : 			}
; 1667 : 
; 1668 : 			if ( btIndex == 232 )

  00144	3c e8		 cmp	 al, 232			; 000000e8H
  00146	0f 84 23 01 00
	00		 je	 $LN10@SetMonster@2

; 1669 : 			{
; 1670 : 				continue;
; 1671 : 			}
; 1672 : 
; 1673 : 			if ( btIndex == 131 )

  0014c	3c 83		 cmp	 al, 131			; 00000083H
  0014e	0f 84 1b 01 00
	00		 je	 $LN10@SetMonster@2

; 1674 : 			{
; 1675 : 				continue;
; 1676 : 			}
; 1677 : 
; 1678 : 			if ( btIndex == 89 || btIndex == 95 || btIndex == 112  || btIndex == 118 || btIndex == 124 || btIndex == 130 || btIndex == 143 )

  00154	3c 59		 cmp	 al, 89			; 00000059H
  00156	0f 84 13 01 00
	00		 je	 $LN10@SetMonster@2
  0015c	3c 5f		 cmp	 al, 95			; 0000005fH
  0015e	0f 84 0b 01 00
	00		 je	 $LN10@SetMonster@2
  00164	3c 70		 cmp	 al, 112			; 00000070H
  00166	0f 84 03 01 00
	00		 je	 $LN10@SetMonster@2
  0016c	3c 76		 cmp	 al, 118			; 00000076H
  0016e	0f 84 fb 00 00
	00		 je	 $LN10@SetMonster@2
  00174	3c 7c		 cmp	 al, 124			; 0000007cH
  00176	0f 84 f3 00 00
	00		 je	 $LN10@SetMonster@2
  0017c	3c 82		 cmp	 al, 130			; 00000082H
  0017e	0f 84 eb 00 00
	00		 je	 $LN10@SetMonster@2
  00184	3c 8f		 cmp	 al, 143			; 0000008fH
  00186	0f 84 e3 00 00
	00		 je	 $LN10@SetMonster@2

; 1679 : 			{
; 1680 : 				continue;
; 1681 : 			}
; 1682 : 
; 1683 : 			if ( BC_STATUE_RANGE(btIndex-132) != FALSE )

  0018c	0f b6 c0	 movzx	 eax, al
  0018f	89 45 f4	 mov	 DWORD PTR tv427[ebp], eax
  00192	05 7c ff ff ff	 add	 eax, -132		; ffffff7cH
  00197	78 12		 js	 SHORT $LN26@SetMonster@2
  00199	33 c9		 xor	 ecx, ecx
  0019b	83 f8 02	 cmp	 eax, 2
  0019e	0f 9e c1	 setle	 cl
  001a1	8b c1		 mov	 eax, ecx
  001a3	85 c0		 test	 eax, eax
  001a5	0f 85 c4 00 00
	00		 jne	 $LN10@SetMonster@2
$LN26@SetMonster@2:

; 1684 : 			{
; 1685 : 				continue;
; 1686 : 			}
; 1687 : 
; 1688 : 			result = gObjAddMonster(gMSetBase.m_Mp[n].m_MapNumber);

  001ab	0f b6 d2	 movzx	 edx, dl
  001ae	52		 push	 edx
  001af	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  001b4	0f bf d0	 movsx	 edx, ax
  001b7	83 c4 04	 add	 esp, 4

; 1689 : 
; 1690 : 			if ( result >= 0 )

  001ba	85 d2		 test	 edx, edx
  001bc	0f 88 ad 00 00
	00		 js	 $LN10@SetMonster@2

; 1691 : 			{
; 1692 : 				gObj[result].m_PosNum = n;
; 1693 : 				gObj[result].X = gMSetBase.m_Mp[n].m_X;

  001c2	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]

; 1694 : 				gObj[result].Y = gMSetBase.m_Mp[n].m_Y;

  001c6	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  001ca	8b f2		 mov	 esi, edx
  001cc	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  001d2	66 89 86 04 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260], ax
  001d9	66 89 8e 06 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262], cx

; 1695 : 				gObj[result].MapNumber = gMSetBase.m_Mp[n].m_MapNumber;
; 1696 : 				gObj[result].TX = gObj[result].X;
; 1697 : 				gObj[result].TY = gObj[result].Y;

  001e0	66 89 8e 22 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+290], cx

; 1698 : 				gObj[result].m_OldX = gObj[result].X;
; 1699 : 				gObj[result].m_OldY = gObj[result].Y;

  001e7	66 89 8e 1e 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+286], cx

; 1700 : 				gObj[result].Dir = gMSetBase.m_Mp[n].m_Dir;
; 1701 : 				gObj[result].StartX = gObj[result].X;

  001ee	0f b6 8e 04 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  001f5	66 89 86 20 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+288], ax
  001fc	66 89 86 1c 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+284], ax
  00203	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00207	88 8e 1a 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+282], cl

; 1702 : 				gObj[result].StartY = gObj[result].Y;
; 1703 : 				gObjSetMonster(result, btIndex);

  0020d	8b 4d f4	 mov	 ecx, DWORD PTR tv427[ebp]
  00210	88 86 08 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+264], al
  00216	0f b6 86 06 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  0021d	66 89 9e 10 02
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+528], bx
  00224	8a 1f		 mov	 bl, BYTE PTR [edi]
  00226	51		 push	 ecx
  00227	52		 push	 edx
  00228	88 9e 09 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265], bl
  0022e	88 86 1b 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+283], al
  00234	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1704 : 				gObj[result].MaxRegenTime = this->m_iBC_MONSTER_REGEN;

  00239	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]

; 1705 : 				gObj[result].m_cBloodCastleIndex = btBridgeIndex;

  0023c	0f b6 4d ff	 movzx	 ecx, BYTE PTR _btBridgeIndex$157797[ebp]
  00240	8b 82 1c 0e 00
	00		 mov	 eax, DWORD PTR [edx+3612]
  00246	83 c4 08	 add	 esp, 8
  00249	89 86 0c 02 00
	00		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+524], eax
  0024f	88 8e 02 0d 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3330], cl

; 1706 : 				gObj[result].Dir = rand() % 8;

  00255	e8 00 00 00 00	 call	 _rand
  0025a	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0025f	79 05		 jns	 SHORT $LN31@SetMonster@2
  00261	48		 dec	 eax
  00262	83 c8 f8	 or	 eax, -8			; fffffff8H
  00265	40		 inc	 eax
$LN31@SetMonster@2:
  00266	8b 5d f8	 mov	 ebx, DWORD PTR _n$157790[ebp]
  00269	88 86 08 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+264], al
$LN10@SetMonster@2:

; 1650 : 			}
; 1651 : 		}
; 1652 : 	}
; 1653 : 
; 1654 : 	int result;
; 1655 : 	for ( int n=0;n<gMSetBase.m_Count;n++)

  0026f	43		 inc	 ebx
  00270	83 c7 0c	 add	 edi, 12			; 0000000cH
  00273	89 5d f8	 mov	 DWORD PTR _n$157790[ebp], ebx
  00276	3b 1d e4 0f 01
	00		 cmp	 ebx, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+69604
  0027c	0f 8c 92 fe ff
	ff		 jl	 $LL11@SetMonster@2
$LN30@SetMonster@2:
  00282	5b		 pop	 ebx
$LN9@SetMonster@2:
  00283	5f		 pop	 edi
  00284	5e		 pop	 esi

; 1707 : 			}
; 1708 : 		}
; 1709 : 	}
; 1710 : 	
; 1711 : }

  00285	8b e5		 mov	 esp, ebp
  00287	5d		 pop	 ebp
  00288	c2 04 00	 ret	 4
?SetMonster@CBloodCastle@@QAEXH@Z ENDP			; CBloodCastle::SetMonster
_TEXT	ENDS
PUBLIC	??_C@_0FI@OICDBHD@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	??_C@_0FL@LNKJMMJP@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z	; CBloodCastle::SearchUserDropQuestItem
;	COMDAT ??_C@_0FI@OICDBHD@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FI@OICDBHD@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King'''
	DB	's Weapon (%d) [Serial:%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@LNKJMMJP@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FL@LNKJMMJP@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King'''
	DB	's Weapon (%d) [Serial:%d-%d]', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$158184 = 8						; size = 4
_iIndex$ = 8						; size = 4
?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::SearchUserDropQuestItem, COMDAT
; _this$ = ecx

; 2546 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2547 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00005	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	3b f7		 cmp	 esi, edi
  00010	0f 8c 4c 01 00
	00		 jl	 $LN11@SearchUser@2
  00016	33 c0		 xor	 eax, eax
  00018	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  0001e	0f 9e c0	 setle	 al
  00021	3b c7		 cmp	 eax, edi
  00023	0f 84 39 01 00
	00		 je	 $LN11@SearchUser@2

; 2548 : 	{
; 2549 : 		return;
; 2550 : 	}
; 2551 : 
; 2552 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00029	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0002f	66 83 be 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+96], 1
  00037	0f 85 25 01 00
	00		 jne	 $LN11@SearchUser@2
  0003d	80 be 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+4], 2
  00044	0f 86 18 01 00
	00		 jbe	 $LN11@SearchUser@2

; 2553 : 	{
; 2554 : 		return;
; 2555 : 	}
; 2556 : 
; 2557 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  0004a	89 7d 08	 mov	 DWORD PTR _x$158184[ebp], edi
  0004d	53		 push	 ebx
  0004e	8b ff		 npad	 2
$LL10@SearchUser@2:

; 2558 : 	{
; 2559 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00050	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  00056	03 cf		 add	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005d	83 f8 01	 cmp	 eax, 1
  00060	0f 85 e6 00 00
	00		 jne	 $LN9@SearchUser@2

; 2560 : 		{
; 2561 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  00066	8b 86 8c 0c 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  0006c	b9 13 1a 00 00	 mov	 ecx, 6675		; 00001a13H
  00071	66 39 4c 38 06	 cmp	 WORD PTR [eax+edi+6], cx
  00076	0f 85 d0 00 00
	00		 jne	 $LN9@SearchUser@2

; 2562 : 			{
; 2563 : 				int iLEVEL = gObj[iIndex].pInventory[x].m_Level;

  0007c	0f bf 5c 38 08	 movsx	 ebx, WORD PTR [eax+edi+8]

; 2564 : 
; 2565 : 				if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  00081	85 db		 test	 ebx, ebx
  00083	0f 88 c3 00 00
	00		 js	 $LN9@SearchUser@2
  00089	33 c0		 xor	 eax, eax
  0008b	83 fb 02	 cmp	 ebx, 2
  0008e	0f 9e c0	 setle	 al
  00091	85 c0		 test	 eax, eax
  00093	0f 84 b3 00 00
	00		 je	 $LN9@SearchUser@2

; 2566 : 				{
; 2567 : 					BYTE pMsg[6];
; 2568 : 					pMsg[5] = x;
; 2569 : 					pMsg[3] = gObj[iIndex].X;
; 2570 : 					pMsg[4] = gObj[iIndex].Y;
; 2571 : 
; 2572 : 					this->DropItemDirectly(gObj[iIndex].MapNumber - MAP_INDEX_BLOODCASTLE1,
; 2573 : 						gObj[iIndex].m_Index, ITEMGET(13, 19), x);

  00099	8b 55 08	 mov	 edx, DWORD PTR _x$158184[ebp]
  0009c	8b 86 00 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000a2	52		 push	 edx
  000a3	51		 push	 ecx
  000a4	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]
  000ab	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  000ae	50		 push	 eax
  000af	51		 push	 ecx
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z ; CBloodCastle::DropItemDirectly

; 2574 : 
; 2575 : 					if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) != FALSE )

  000b8	8a 86 09 01 00
	00		 mov	 al, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]
  000be	3c 0b		 cmp	 al, 11			; 0000000bH
  000c0	72 62		 jb	 SHORT $LN25@SearchUser@2
  000c2	b2 11		 mov	 dl, 17			; 00000011H
  000c4	3a d0		 cmp	 dl, al
  000c6	1b c9		 sbb	 ecx, ecx
  000c8	41		 inc	 ecx
  000c9	74 59		 je	 SHORT $LN25@SearchUser@2

; 2576 : 					{
; 2577 : 						int iBC_INDEX = gObj[iIndex].MapNumber - MAP_INDEX_BLOODCASTLE1;
; 2578 : 
; 2579 : 						if ( this->m_BridgeData[iBC_INDEX].m_nBC_QUESTITEM_SERIAL != -1 )

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	0f b6 c0	 movzx	 eax, al
  000d1	83 e8 0b	 sub	 eax, 11			; 0000000bH
  000d4	c1 e0 09	 shl	 eax, 9
  000d7	03 c8		 add	 ecx, eax
  000d9	8b 81 90 01 00
	00		 mov	 eax, DWORD PTR [ecx+400]
  000df	83 f8 ff	 cmp	 eax, -1
  000e2	74 15		 je	 SHORT $LN24@SearchUser@2

; 2580 : 						{
; 2581 : 							if ( this->m_BridgeData[iBC_INDEX].m_nBC_QUESTITEM_SERIAL == gObj[iIndex].pInventory[x].m_Number )

  000e4	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  000ea	3b 04 17	 cmp	 eax, DWORD PTR [edi+edx]
  000ed	75 0a		 jne	 SHORT $LN24@SearchUser@2

; 2582 : 							{
; 2583 : 								this->m_BridgeData[iBC_INDEX].m_iBC_QUEST_ITEM_USER_INDEX = -1;

  000ef	c7 81 94 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+404], -1
$LN24@SearchUser@2:

; 2584 : 							}
; 2585 : 						}
; 2586 : 
; 2587 : 						LogAdd(LOG_BLACK, "[Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King's Weapon (%d) [Serial:%d-%d]",
; 2588 : 							gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL, this->m_BridgeData[iBC_INDEX].m_nBC_QUESTITEM_SERIAL,
; 2589 : 							gObj[iIndex].pInventory[x].m_Number);

  000f9	8b 8e 8c 0c 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  000ff	8b 14 0f	 mov	 edx, DWORD PTR [edi+ecx]
  00102	52		 push	 edx
  00103	50		 push	 eax
  00104	53		 push	 ebx
  00105	8d 86 6f 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  0010b	50		 push	 eax
  0010c	8d 8e 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  00112	51		 push	 ecx
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@LNKJMMJP@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
  00118	6a 00		 push	 0
  0011a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0011f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2590 : 
; 2591 : 					}
; 2592 : 					else

  00122	eb 28		 jmp	 SHORT $LN9@SearchUser@2
$LN25@SearchUser@2:

; 2593 : 					{
; 2594 : 						LogAdd(LOG_BLACK, "[Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King's Weapon (%d) [Serial:%d]",
; 2595 : 							gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL,
; 2596 : 							gObj[iIndex].pInventory[x].m_Number);

  00124	8b 96 8c 0c 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+3212]
  0012a	8b 04 17	 mov	 eax, DWORD PTR [edi+edx]
  0012d	50		 push	 eax
  0012e	53		 push	 ebx
  0012f	8d 8e 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+111]
  00135	51		 push	 ecx
  00136	8d 96 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+100]
  0013c	52		 push	 edx
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@OICDBHD@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
  00142	6a 00		 push	 0
  00144	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00149	83 c4 18	 add	 esp, 24			; 00000018H
$LN9@SearchUser@2:

; 2553 : 	{
; 2554 : 		return;
; 2555 : 	}
; 2556 : 
; 2557 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  0014c	ff 45 08	 inc	 DWORD PTR _x$158184[ebp]
  0014f	81 c7 a8 00 00
	00		 add	 edi, 168		; 000000a8H
  00155	81 ff e0 46 00
	00		 cmp	 edi, 18144		; 000046e0H
  0015b	0f 8c ef fe ff
	ff		 jl	 $LL10@SearchUser@2
  00161	5b		 pop	 ebx
$LN11@SearchUser@2:
  00162	5f		 pop	 edi
  00163	5e		 pop	 esi

; 2597 : 					}
; 2598 : 				}
; 2599 : 			}
; 2600 : 		}
; 2601 : 	}
; 2602 : }

  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c2 04 00	 ret	 4
?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::SearchUserDropQuestItem
_TEXT	ENDS
PUBLIC	??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ ; `string'
PUBLIC	??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ ; `string'
PUBLIC	??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@ ; `string'
PUBLIC	_iIndex$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GiveReward_Win@CBloodCastle@@QAEXHH@Z		; CBloodCastle::GiveReward_Win
EXTRN	?SendNoticeToUser@TNotice@@SAXHPAX@Z:PROC	; TNotice::SendNoticeToUser
EXTRN	?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z:PROC	; TNotice::SetNoticeProperty
EXTRN	__imp__wsprintfA:PROC
;	COMDAT ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\tnotice.h
CONST	SEGMENT
??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ DB '['
	DB	'Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:'
	DB	'%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:'
	DB	'%d, MapNumber:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
CONST	SEGMENT
??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ DB '['
	DB	'Blood Castle] (%d) Quest Complete - All Alive User''s Total E'
	DB	'XP:%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@
CONST	SEGMENT
??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@ DB '['
	DB	'Blood Castle] (%d) Winner Party Point - Alive Party Member : '
	DB	'%d, Alive Party Point : %d', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\bloodcastle.cpp
CONST	ENDS
;	COMDAT ?GiveReward_Win@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iADD_PARTYPOINT$ = -840				; size = 4
_iALIVE_PARTYCOUNT$ = -836				; size = 4
_iIndex$GSCopy$ = -832					; size = 4
tv826 = -832						; size = 4
tv2033 = -828						; size = 4
tv1153 = -824						; size = 4
_iLEFT_TIME$ = -820					; size = 4
_iREWARD_EXP$ = -816					; size = 4
_iREWARD_ZEN$ = -812					; size = 4
_this$GSCopy$ = -808					; size = 4
_pNotice$158279 = -804					; size = 272
_pMsg$158306 = -532					; size = 269
_szNOTIFY_MSG$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iBridgeIndex$ = 12					; size = 4
?GiveReward_Win@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::GiveReward_Win, COMDAT
; _this$ = ecx

; 2706 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 03 00
	00		 sub	 esp, 840		; 00000348H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  0001b	57		 push	 edi
  0001c	8b f9		 mov	 edi, ecx

; 2707 : 	this->FixUsersPlayStateWin(iBridgeIndex);

  0001e	56		 push	 esi

; 2708 : 	char szNOTIFY_MSG[256];
; 2709 : 	int iREWARD_EXP = 0;

  0001f	89 bd d8 fc ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], edi

; 2745 : 	{
; 2746 : 		int iTOTAL_EXP = this->GetAliveUserTotalEXP(iBridgeIndex);

  00025	89 85 c0 fc ff
	ff		 mov	 DWORD PTR _iIndex$GSCopy$[ebp], eax
  0002b	e8 00 00 00 00	 call	 ?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z ; CBloodCastle::FixUsersPlayStateWin
  00030	8b c6		 mov	 eax, esi
  00032	c1 e0 09	 shl	 eax, 9
  00035	8b 8c 38 54 01
	00 00		 mov	 ecx, DWORD PTR [eax+edi+340]
  0003c	03 c7		 add	 eax, edi
  0003e	89 85 c8 fc ff
	ff		 mov	 DWORD PTR tv1153[ebp], eax
  00044	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00049	f7 e9		 imul	 ecx
  0004b	c1 fa 06	 sar	 edx, 6
  0004e	8b c2		 mov	 eax, edx
  00050	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00053	33 db		 xor	 ebx, ebx
  00055	03 c2		 add	 eax, edx
  00057	56		 push	 esi
  00058	8b cf		 mov	 ecx, edi
  0005a	89 9d d0 fc ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], ebx
  00060	89 9d d4 fc ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], ebx
  00066	89 85 cc fc ff
	ff		 mov	 DWORD PTR _iLEFT_TIME$[ebp], eax
  0006c	e8 00 00 00 00	 call	 ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount
  00071	56		 push	 esi
  00072	8b cf		 mov	 ecx, edi
  00074	89 85 bc fc ff
	ff		 mov	 DWORD PTR _iALIVE_PARTYCOUNT$[ebp], eax
  0007a	e8 00 00 00 00	 call	 ?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompletePoint
  0007f	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  00085	50		 push	 eax
  00086	52		 push	 edx
  00087	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0008a	51		 push	 ecx
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@
  00090	53		 push	 ebx
  00091	89 85 b8 fc ff
	ff		 mov	 DWORD PTR _iADD_PARTYPOINT$[ebp], eax
  00097	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0009c	8b 85 c0 fc ff
	ff		 mov	 eax, DWORD PTR _iIndex$GSCopy$[ebp]
  000a2	83 c4 14	 add	 esp, 20			; 00000014H
  000a5	85 c0		 test	 eax, eax
  000a7	0f 88 a1 06 00
	00		 js	 $LN29@GiveReward

; 2710 : 	int iREWARD_ZEN = 0;
; 2711 : 	int iREWARD_SCR = 0;
; 2712 : 	int iLEFT_TIME = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;
; 2713 : 	int iALIVE_PARTYCOUNT = this->GetWinnerPartyCompleteCount(iBridgeIndex);
; 2714 : 	int iADD_PARTYPOINT = this->GetWinnerPartyCompletePoint(iBridgeIndex);
; 2715 : 
; 2716 : 	LogAdd(LOG_BLACK, "[Blood Castle] (%d) Winner Party Point - Alive Party Member : %d, Alive Party Point : %d",
; 2717 : 		iBridgeIndex+1, iALIVE_PARTYCOUNT, iADD_PARTYPOINT);
; 2718 : 
; 2719 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  000ad	33 c9		 xor	 ecx, ecx
  000af	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  000b4	0f 9e c1	 setle	 cl
  000b7	85 c9		 test	 ecx, ecx
  000b9	0f 84 8f 06 00
	00		 je	 $LN29@GiveReward

; 2720 : 	{
; 2721 : 		return;
; 2722 : 	}
; 2723 : 
; 2724 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  000bf	85 f6		 test	 esi, esi
  000c1	0f 88 87 06 00
	00		 js	 $LN29@GiveReward
  000c7	33 c9		 xor	 ecx, ecx
  000c9	83 fe 06	 cmp	 esi, 6
  000cc	0f 9e c1	 setle	 cl
  000cf	85 c9		 test	 ecx, ecx
  000d1	0f 84 77 06 00
	00		 je	 $LN29@GiveReward

; 2725 : 	{
; 2726 : 		return;
; 2727 : 	}
; 2728 : 	
; 2729 : 	if ( this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED != false )

  000d7	8b 8d c8 fc ff
	ff		 mov	 ecx, DWORD PTR tv1153[ebp]
  000dd	38 99 66 01 00
	00		 cmp	 BYTE PTR [ecx+358], bl
  000e3	0f 85 65 06 00
	00		 jne	 $LN29@GiveReward

; 2730 : 	{
; 2731 : 		return;
; 2732 : 	}
; 2733 : 
; 2734 : 	if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  000e9	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000ef	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2

; 2735 : 	{
; 2736 : 		gObj[iIndex].Name[MAX_ACCOUNT_LEN] = 0;
; 2737 : 		wsprintf(szNOTIFY_MSG, lMsg.Get(MSGGET(4, 141)), gObj[iIndex].Name);

  000f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000fb	76 2a		 jbe	 SHORT $LN31@GiveReward
  000fd	8d 90 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  00103	52		 push	 edx
  00104	68 8d 04 00 00	 push	 1165			; 0000048dH
  00109	88 98 79 00 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+121], bl
  0010f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00114	50		 push	 eax
  00115	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szNOTIFY_MSG$[ebp]
  0011b	50		 push	 eax
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00122	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2738 : 	}
; 2739 : 	else

  00125	eb 1b		 jmp	 SHORT $LN30@GiveReward
$LN31@GiveReward:

; 2740 : 	{
; 2741 : 		wsprintf(szNOTIFY_MSG, lMsg.Get(MSGGET(4, 142)));

  00127	68 8e 04 00 00	 push	 1166			; 0000048eH
  0012c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00131	50		 push	 eax
  00132	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szNOTIFY_MSG$[ebp]
  00138	51		 push	 ecx
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0013f	83 c4 08	 add	 esp, 8
$LN30@GiveReward:

; 2742 : 	}
; 2743 : 
; 2744 : 	if ( this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS != -1 )

  00142	8b 95 c8 fc ff
	ff		 mov	 edx, DWORD PTR tv1153[ebp]
  00148	83 ba 48 01 00
	00 ff		 cmp	 DWORD PTR [edx+328], -1
  0014f	0f 84 f9 05 00
	00		 je	 $LN29@GiveReward

; 2745 : 	{
; 2746 : 		int iTOTAL_EXP = this->GetAliveUserTotalEXP(iBridgeIndex);

  00155	56		 push	 esi
  00156	8b cf		 mov	 ecx, edi
  00158	e8 00 00 00 00	 call	 ?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z ; CBloodCastle::GetAliveUserTotalEXP

; 2747 : 		LogAdd(LOG_BLACK, "[Blood Castle] (%d) Quest Complete - All Alive User's Total EXP:%d",
; 2748 : 			iBridgeIndex+1, iTOTAL_EXP);

  0015d	50		 push	 eax
  0015e	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00161	50		 push	 eax
  00162	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
  00167	6a 00		 push	 0
  00169	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0016e	8b bd c8 fc ff
	ff		 mov	 edi, DWORD PTR tv1153[ebp]
  00174	83 c4 10	 add	 esp, 16			; 00000010H
  00177	83 c7 1c	 add	 edi, 28			; 0000001cH
  0017a	c7 85 c0 fc ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv826[ebp], 10 ; 0000000aH
$LL52@GiveReward:

; 2751 : 		{
; 2752 : 			if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  00184	8b 07		 mov	 eax, DWORD PTR [edi]
  00186	83 f8 ff	 cmp	 eax, -1
  00189	0f 84 a3 05 00
	00		 je	 $LN27@GiveReward

; 2753 : 			{
; 2754 : 				continue;
; 2755 : 			}
; 2756 : 
; 2757 : 			if ( gObj[ this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].Connected < PLAYER_PLAYING )

  0018f	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00195	80 b8 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 3
  0019c	0f 82 90 05 00
	00		 jb	 $LN27@GiveReward

; 2758 : 			{
; 2759 : 				continue;
; 2760 : 			}
; 2761 : 
; 2762 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 ||  gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex )

  001a2	8a 88 02 0d 00
	00		 mov	 cl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330]
  001a8	80 f9 ff	 cmp	 cl, -1
  001ab	0f 84 81 05 00
	00		 je	 $LN27@GiveReward
  001b1	80 b8 03 0d 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3331], -1
  001b8	0f 84 74 05 00
	00		 je	 $LN27@GiveReward
  001be	0f be c1	 movsx	 eax, cl
  001c1	3b c6		 cmp	 eax, esi
  001c3	0f 85 69 05 00
	00		 jne	 $LN27@GiveReward

; 2763 : 			{
; 2764 : 				continue;
; 2765 : 			}
; 2766 : 
; 2767 : 			PMSG_NOTICE pNotice;
; 2768 : 			TNotice::MakeNoticeMsg(&pNotice, 10, szNOTIFY_MSG);

  001c9	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szNOTIFY_MSG$[ebp]
  001cf	51		 push	 ecx
  001d0	8d 95 dc fc ff
	ff		 lea	 edx, DWORD PTR _pNotice$158279[ebp]
  001d6	6a 0a		 push	 10			; 0000000aH
  001d8	52		 push	 edx
  001d9	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 2769 : 			TNotice::SetNoticeProperty(&pNotice, 10, _ARGB(255, 128, 149, 196), 1, 0, 20);

  001de	6a 14		 push	 20			; 00000014H
  001e0	6a 00		 push	 0
  001e2	6a 01		 push	 1
  001e4	68 80 95 c4 ff	 push	 -3893888		; ffc49580H
  001e9	8d 85 dc fc ff
	ff		 lea	 eax, DWORD PTR _pNotice$158279[ebp]
  001ef	6a 0a		 push	 10			; 0000000aH
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 ?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z ; TNotice::SetNoticeProperty

; 2770 : 			TNotice::SendNoticeToUser(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (TNotice*)&pNotice);

  001f7	8b 17		 mov	 edx, DWORD PTR [edi]
  001f9	8d 8d dc fc ff
	ff		 lea	 ecx, DWORD PTR _pNotice$158279[ebp]
  001ff	51		 push	 ecx
  00200	52		 push	 edx
  00201	e8 00 00 00 00	 call	 ?SendNoticeToUser@TNotice@@SAXHPAX@Z ; TNotice::SendNoticeToUser

; 2771 : 
; 2772 : 			int iADD_EXP = 0;
; 2773 : 
; 2774 : 			if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index)

  00206	8b 07		 mov	 eax, DWORD PTR [edi]
  00208	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0020e	8b 90 a8 02 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+680]
  00214	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR tv1153[ebp]
  0021a	83 c4 2c	 add	 esp, 44			; 0000002cH
  0021d	33 c9		 xor	 ecx, ecx
  0021f	89 95 c4 fc ff
	ff		 mov	 DWORD PTR tv2033[ebp], edx
  00225	83 fa ff	 cmp	 edx, -1
  00228	74 08		 je	 SHORT $LN19@GiveReward
  0022a	3b 90 a0 01 00
	00		 cmp	 edx, DWORD PTR [eax+416]
  00230	74 10		 je	 SHORT $LN20@GiveReward
$LN19@GiveReward:
  00232	8b 17		 mov	 edx, DWORD PTR [edi]
  00234	3b 90 a4 01 00
	00		 cmp	 edx, DWORD PTR [eax+420]
  0023a	75 13		 jne	 SHORT $LN21@GiveReward
  0023c	8b 95 c4 fc ff
	ff		 mov	 edx, DWORD PTR tv2033[ebp]
$LN20@GiveReward:

; 2775 : 			{
; 2776 : 				iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0;

  00242	8b ce		 mov	 ecx, esi
  00244	c1 e1 04	 shl	 ecx, 4
  00247	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _g_iBC_Add_Exp[ecx]

; 2777 : 			}
; 2778 : 			else

  0024d	eb 2c		 jmp	 SHORT $LN16@GiveReward
$LN21@GiveReward:

; 2779 : 			{
; 2780 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 )

  0024f	83 bd c4 fc ff
	ff ff		 cmp	 DWORD PTR tv2033[ebp], -1
  00256	74 1d		 je	 SHORT $LN50@GiveReward

; 2781 : 				{
; 2782 : 					if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak != false )

  00258	38 4f 11	 cmp	 BYTE PTR [edi+17], cl
  0025b	74 18		 je	 SHORT $LN50@GiveReward

; 2783 : 					{
; 2784 : 						iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0 / 2;

  0025d	8b d6		 mov	 edx, esi
  0025f	c1 e2 04	 shl	 edx, 4
  00262	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _g_iBC_Add_Exp[edx]
  00268	99		 cdq
  00269	2b c2		 sub	 eax, edx
  0026b	8b c8		 mov	 ecx, eax
  0026d	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR tv1153[ebp]
  00273	d1 f9		 sar	 ecx, 1
$LN50@GiveReward:
  00275	8b 95 c4 fc ff
	ff		 mov	 edx, DWORD PTR tv2033[ebp]
$LN16@GiveReward:

; 2785 : 					}
; 2786 : 				}
; 2787 : 			}
; 2788 : 
; 2789 : 			if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index)

  0027b	83 fa ff	 cmp	 edx, -1
  0027e	74 08		 je	 SHORT $LN13@GiveReward
  00280	3b 90 c0 01 00
	00		 cmp	 edx, DWORD PTR [eax+448]
  00286	74 0a		 je	 SHORT $LN14@GiveReward
$LN13@GiveReward:
  00288	8b 17		 mov	 edx, DWORD PTR [edi]
  0028a	3b 90 c4 01 00
	00		 cmp	 edx, DWORD PTR [eax+452]
  00290	75 0b		 jne	 SHORT $LN51@GiveReward
$LN14@GiveReward:

; 2790 : 			{
; 2791 : 				iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk4;

  00292	8b d6		 mov	 edx, esi
  00294	c1 e2 04	 shl	 edx, 4
  00297	03 8a 04 00 00
	00		 add	 ecx, DWORD PTR _g_iBC_Add_Exp[edx+4]
$LN51@GiveReward:

; 2792 : 			}
; 2793 : 
; 2794 : 			if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Index)

  0029d	8b 95 c4 fc ff
	ff		 mov	 edx, DWORD PTR tv2033[ebp]
  002a3	83 fa ff	 cmp	 edx, -1
  002a6	74 08		 je	 SHORT $LN10@GiveReward
  002a8	3b 90 e0 01 00
	00		 cmp	 edx, DWORD PTR [eax+480]
  002ae	74 0a		 je	 SHORT $LN11@GiveReward
$LN10@GiveReward:
  002b0	8b 17		 mov	 edx, DWORD PTR [edi]
  002b2	3b 90 e4 01 00
	00		 cmp	 edx, DWORD PTR [eax+484]
  002b8	75 0b		 jne	 SHORT $LN12@GiveReward
$LN11@GiveReward:

; 2795 : 			{
; 2796 : 				iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk8;

  002ba	8b d6		 mov	 edx, esi
  002bc	c1 e2 04	 shl	 edx, 4
  002bf	03 8a 08 00 00
	00		 add	 ecx, DWORD PTR _g_iBC_Add_Exp[edx+8]
$LN12@GiveReward:

; 2797 : 			}
; 2798 : 
; 2799 : 			switch ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState  )

  002c5	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  002c8	83 fa 04	 cmp	 edx, 4
  002cb	0f 87 e4 03 00
	00		 ja	 $LN8@GiveReward
  002d1	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN54@GiveReward[edx*4]
$LN7@GiveReward:

; 2800 : 			{
; 2801 : 				case 0:
; 2802 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  002d8	8b 90 54 01 00
	00		 mov	 edx, DWORD PTR [eax+340]
  002de	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  002e3	f7 ea		 imul	 edx
  002e5	c1 fa 06	 sar	 edx, 6
  002e8	8b c2		 mov	 eax, edx
  002ea	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002ed	8b de		 mov	 ebx, esi
  002ef	03 c2		 add	 eax, edx
  002f1	c1 e3 04	 shl	 ebx, 4
  002f4	0f af 83 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[ebx+12]

; 2803 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  002fb	8b 9d d8 fc ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
  00301	03 c8		 add	 ecx, eax
  00303	8b 07		 mov	 eax, DWORD PTR [edi]
  00305	51		 push	 ecx
  00306	50		 push	 eax
  00307	8b cb		 mov	 ecx, ebx
  00309	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 2804 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].SpecialCharacter);

  0030e	8b 0c f5 04 00
	00 00		 mov	 ecx, DWORD PTR _g_iQuestWinExpendZEN[esi*8+4]
  00315	8b 17		 mov	 edx, DWORD PTR [edi]
  00317	51		 push	 ecx
  00318	52		 push	 edx
  00319	8b cb		 mov	 ecx, ebx
  0031b	89 85 d0 fc ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax
  00321	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 2805 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk0;
; 2806 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, 0);

  00326	8b 8d cc fc ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  0032c	8b 17		 mov	 edx, DWORD PTR [edi]
  0032e	6a 00		 push	 0
  00330	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax
  00336	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  00339	8b 1c 85 00 00
	00 00		 mov	 ebx, DWORD PTR _g_iBC_EventScore[eax*4]
  00340	51		 push	 ecx
  00341	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00347	53		 push	 ebx
  00348	52		 push	 edx
  00349	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2807 : 
; 2808 : 					LogAdd(LOG_BLACK, "[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)",
; 2809 : 						iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 2810 : 						gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 2811 : 						0, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 2812 : 						iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  0034e	8b 07		 mov	 eax, DWORD PTR [edi]
  00350	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR _iLEFT_TIME$[ebp]
  00356	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0035c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00363	51		 push	 ecx
  00364	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_ZEN$[ebp]
  0036a	52		 push	 edx
  0036b	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _iREWARD_EXP$[ebp]
  00371	53		 push	 ebx
  00372	51		 push	 ecx
  00373	8b 88 04 0d 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3332]
  00379	52		 push	 edx
  0037a	51		 push	 ecx
  0037b	6a 00		 push	 0

; 2813 : 					break;

  0037d	e9 12 03 00 00	 jmp	 $LN53@GiveReward
$LN6@GiveReward:

; 2814 : 
; 2815 : 				case 1:
; 2816 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  00382	8b 90 54 01 00
	00		 mov	 edx, DWORD PTR [eax+340]
  00388	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0038d	f7 ea		 imul	 edx
  0038f	c1 fa 06	 sar	 edx, 6
  00392	8b c2		 mov	 eax, edx
  00394	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00397	8b de		 mov	 ebx, esi
  00399	03 c2		 add	 eax, edx
  0039b	c1 e3 04	 shl	 ebx, 4
  0039e	0f af 83 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[ebx+12]

; 2817 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  003a5	8b 9d d8 fc ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
  003ab	03 c8		 add	 ecx, eax
  003ad	8b 07		 mov	 eax, DWORD PTR [edi]
  003af	51		 push	 ecx
  003b0	50		 push	 eax
  003b1	8b cb		 mov	 ecx, ebx
  003b3	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 2818 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].SpecialCharacter);

  003b8	8b 0c f5 04 00
	00 00		 mov	 ecx, DWORD PTR _g_iQuestWinExpendZEN[esi*8+4]
  003bf	8b 17		 mov	 edx, DWORD PTR [edi]
  003c1	51		 push	 ecx
  003c2	52		 push	 edx
  003c3	8b cb		 mov	 ecx, ebx
  003c5	89 85 d0 fc ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax
  003cb	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 2819 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk4;
; 2820 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, 0);

  003d0	8b 8d cc fc ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  003d6	8b 17		 mov	 edx, DWORD PTR [edi]
  003d8	6a 00		 push	 0
  003da	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax
  003e0	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  003e3	8b 1c 85 04 00
	00 00		 mov	 ebx, DWORD PTR _g_iBC_EventScore[eax*4+4]
  003ea	51		 push	 ecx
  003eb	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  003f1	53		 push	 ebx
  003f2	52		 push	 edx
  003f3	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2821 : 
; 2822 : 					LogAdd(LOG_BLACK, "[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)",
; 2823 : 						iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 2824 : 						gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 2825 : 						1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 2826 : 						iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  003f8	8b 07		 mov	 eax, DWORD PTR [edi]
  003fa	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR _iLEFT_TIME$[ebp]
  00400	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00406	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  0040d	51		 push	 ecx
  0040e	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_ZEN$[ebp]
  00414	52		 push	 edx
  00415	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _iREWARD_EXP$[ebp]
  0041b	53		 push	 ebx
  0041c	51		 push	 ecx
  0041d	8b 88 04 0d 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3332]
  00423	52		 push	 edx
  00424	51		 push	 ecx
  00425	6a 01		 push	 1

; 2827 : 					break;

  00427	e9 68 02 00 00	 jmp	 $LN53@GiveReward
$LN5@GiveReward:

; 2828 : 
; 2829 : 				case 2:
; 2830 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  0042c	8b 90 54 01 00
	00		 mov	 edx, DWORD PTR [eax+340]
  00432	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00437	f7 ea		 imul	 edx
  00439	c1 fa 06	 sar	 edx, 6
  0043c	8b c2		 mov	 eax, edx
  0043e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00441	8b de		 mov	 ebx, esi
  00443	03 c2		 add	 eax, edx
  00445	c1 e3 04	 shl	 ebx, 4
  00448	0f af 83 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[ebx+12]

; 2831 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  0044f	8b 9d d8 fc ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
  00455	03 c8		 add	 ecx, eax
  00457	8b 07		 mov	 eax, DWORD PTR [edi]
  00459	51		 push	 ecx
  0045a	50		 push	 eax
  0045b	8b cb		 mov	 ecx, ebx
  0045d	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 2832 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].NormalCharacter);

  00462	8b 0c f5 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iQuestWinExpendZEN[esi*8]
  00469	8b 17		 mov	 edx, DWORD PTR [edi]
  0046b	51		 push	 ecx
  0046c	52		 push	 edx
  0046d	8b cb		 mov	 ecx, ebx
  0046f	89 85 d0 fc ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax
  00475	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 2833 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk8;
; 2834 : 					iREWARD_SCR += iADD_PARTYPOINT;
; 2835 : 
; 2836 : 					if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber ) != FALSE )

  0047a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0047c	8b d1		 mov	 edx, ecx
  0047e	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00484	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax
  0048a	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  0048d	8b 1c 85 08 00
	00 00		 mov	 ebx, DWORD PTR _g_iBC_EventScore[eax*4+8]
  00494	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+265]
  0049b	03 9d b8 fc ff
	ff		 add	 ebx, DWORD PTR _iADD_PARTYPOINT$[ebp]
  004a1	3c 0b		 cmp	 al, 11			; 0000000bH
  004a3	72 15		 jb	 SHORT $LN4@GiveReward
  004a5	b2 11		 mov	 dl, 17			; 00000011H
  004a7	3a d0		 cmp	 dl, al
  004a9	1b c0		 sbb	 eax, eax
  004ab	40		 inc	 eax
  004ac	74 0c		 je	 SHORT $LN4@GiveReward

; 2837 : 					{
; 2838 : 						this->DropChaosGem(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex);

  004ae	51		 push	 ecx
  004af	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  004b5	e8 00 00 00 00	 call	 ?DropChaosGem@CBloodCastle@@QAEXH@Z ; CBloodCastle::DropChaosGem
$LN4@GiveReward:

; 2839 : 					}
; 2840 : 
; 2841 : 
; 2842 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  004ba	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  004c0	8b 8d cc fc ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  004c6	8b 17		 mov	 edx, DWORD PTR [edi]
  004c8	50		 push	 eax
  004c9	51		 push	 ecx
  004ca	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  004d0	53		 push	 ebx
  004d1	52		 push	 edx
  004d2	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2843 : 
; 2844 : 					LogAdd(LOG_BLACK, "[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)",
; 2845 : 						iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 2846 : 						gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 2847 : 						2, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 2848 : 						iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  004d7	8b 07		 mov	 eax, DWORD PTR [edi]
  004d9	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR _iLEFT_TIME$[ebp]
  004df	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  004e5	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  004ec	51		 push	 ecx
  004ed	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_ZEN$[ebp]
  004f3	52		 push	 edx
  004f4	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _iREWARD_EXP$[ebp]
  004fa	53		 push	 ebx
  004fb	51		 push	 ecx
  004fc	8b 88 04 0d 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3332]
  00502	52		 push	 edx
  00503	51		 push	 ecx
  00504	6a 02		 push	 2

; 2849 : 					break;

  00506	e9 89 01 00 00	 jmp	 $LN53@GiveReward
$LN3@GiveReward:

; 2850 : 
; 2851 : 				case 3:
; 2852 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  0050b	8b 90 54 01 00
	00		 mov	 edx, DWORD PTR [eax+340]
  00511	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00516	f7 ea		 imul	 edx
  00518	c1 fa 06	 sar	 edx, 6
  0051b	8b c2		 mov	 eax, edx
  0051d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00520	8b de		 mov	 ebx, esi
  00522	03 c2		 add	 eax, edx
  00524	c1 e3 04	 shl	 ebx, 4
  00527	0f af 83 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[ebx+12]

; 2853 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  0052e	8b 9d d8 fc ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
  00534	03 c8		 add	 ecx, eax
  00536	8b 07		 mov	 eax, DWORD PTR [edi]
  00538	51		 push	 ecx
  00539	50		 push	 eax
  0053a	8b cb		 mov	 ecx, ebx
  0053c	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 2854 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].NormalCharacter);

  00541	8b 0c f5 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iQuestWinExpendZEN[esi*8]
  00548	8b 17		 mov	 edx, DWORD PTR [edi]
  0054a	51		 push	 ecx
  0054b	52		 push	 edx
  0054c	8b cb		 mov	 ecx, ebx
  0054e	89 85 d0 fc ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax
  00554	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 2855 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unkC;
; 2856 : 					iREWARD_SCR += iADD_PARTYPOINT;
; 2857 : 
; 2858 : 					if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber ) != FALSE )

  00559	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0055b	8b d1		 mov	 edx, ecx
  0055d	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00563	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax
  00569	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  0056c	8b 1c 85 0c 00
	00 00		 mov	 ebx, DWORD PTR _g_iBC_EventScore[eax*4+12]
  00573	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+265]
  0057a	03 9d b8 fc ff
	ff		 add	 ebx, DWORD PTR _iADD_PARTYPOINT$[ebp]
  00580	3c 0b		 cmp	 al, 11			; 0000000bH
  00582	72 15		 jb	 SHORT $LN2@GiveReward
  00584	b2 11		 mov	 dl, 17			; 00000011H
  00586	3a d0		 cmp	 dl, al
  00588	1b c0		 sbb	 eax, eax
  0058a	40		 inc	 eax
  0058b	74 0c		 je	 SHORT $LN2@GiveReward

; 2859 : 					{
; 2860 : 						this->DropChaosGem(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex);

  0058d	51		 push	 ecx
  0058e	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00594	e8 00 00 00 00	 call	 ?DropChaosGem@CBloodCastle@@QAEXH@Z ; CBloodCastle::DropChaosGem
$LN2@GiveReward:

; 2861 : 					}
; 2862 : 
; 2863 : 
; 2864 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  00599	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  0059f	8b 8d cc fc ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  005a5	8b 17		 mov	 edx, DWORD PTR [edi]
  005a7	50		 push	 eax
  005a8	51		 push	 ecx
  005a9	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  005af	53		 push	 ebx
  005b0	52		 push	 edx
  005b1	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2865 : 
; 2866 : 					LogAdd(LOG_BLACK, "[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)",
; 2867 : 						iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 2868 : 						gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 2869 : 						3, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 2870 : 						iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  005b6	8b 07		 mov	 eax, DWORD PTR [edi]
  005b8	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR _iLEFT_TIME$[ebp]
  005be	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  005c4	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  005cb	51		 push	 ecx
  005cc	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_ZEN$[ebp]
  005d2	52		 push	 edx
  005d3	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _iREWARD_EXP$[ebp]
  005d9	53		 push	 ebx
  005da	51		 push	 ecx
  005db	8b 88 04 0d 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3332]
  005e1	52		 push	 edx
  005e2	51		 push	 ecx
  005e3	6a 03		 push	 3

; 2871 : 					break;

  005e5	e9 aa 00 00 00	 jmp	 $LN53@GiveReward
$LN1@GiveReward:

; 2872 : 
; 2873 : 				case 4:
; 2874 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  005ea	8b 90 54 01 00
	00		 mov	 edx, DWORD PTR [eax+340]
  005f0	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  005f5	f7 ea		 imul	 edx
  005f7	c1 fa 06	 sar	 edx, 6
  005fa	8b c2		 mov	 eax, edx
  005fc	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  005ff	8b de		 mov	 ebx, esi
  00601	03 c2		 add	 eax, edx
  00603	c1 e3 04	 shl	 ebx, 4
  00606	0f af 83 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[ebx+12]

; 2875 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  0060d	8b 9d d8 fc ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
  00613	03 c8		 add	 ecx, eax
  00615	8b 07		 mov	 eax, DWORD PTR [edi]
  00617	51		 push	 ecx
  00618	50		 push	 eax
  00619	8b cb		 mov	 ecx, ebx
  0061b	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 2876 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].NormalCharacter);

  00620	8b 0c f5 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iQuestWinExpendZEN[esi*8]
  00627	8b 17		 mov	 edx, DWORD PTR [edi]
  00629	51		 push	 ecx
  0062a	52		 push	 edx
  0062b	8b cb		 mov	 ecx, ebx
  0062d	89 85 d0 fc ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax
  00633	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 2877 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk10;
; 2878 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  00638	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  0063e	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR _iLEFT_TIME$[ebp]
  00644	51		 push	 ecx
  00645	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0064b	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax
  00651	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  00654	8b 1c 85 10 00
	00 00		 mov	 ebx, DWORD PTR _g_iBC_EventScore[eax*4+16]
  0065b	8b 07		 mov	 eax, DWORD PTR [edi]
  0065d	52		 push	 edx
  0065e	53		 push	 ebx
  0065f	50		 push	 eax
  00660	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2879 : 
; 2880 : 					LogAdd(LOG_BLACK, "[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)",
; 2881 : 						iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 2882 : 						gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 2883 : 						4, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 2884 : 						iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  00665	8b 07		 mov	 eax, DWORD PTR [edi]
  00667	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR _iLEFT_TIME$[ebp]
  0066d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00673	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  0067a	51		 push	 ecx
  0067b	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_ZEN$[ebp]
  00681	52		 push	 edx
  00682	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _iREWARD_EXP$[ebp]
  00688	53		 push	 ebx
  00689	51		 push	 ecx
  0068a	8b 88 04 0d 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3332]
  00690	52		 push	 edx
  00691	51		 push	 ecx
  00692	6a 04		 push	 4
$LN53@GiveReward:
  00694	8d 90 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  0069a	52		 push	 edx
  0069b	8d 80 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  006a1	50		 push	 eax
  006a2	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  006a5	50		 push	 eax
  006a6	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
  006ab	6a 00		 push	 0
  006ad	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  006b2	83 c4 30	 add	 esp, 48			; 00000030H
$LN8@GiveReward:

; 2885 : 					break;
; 2886 : 			}
; 2887 : 
; 2888 : 			GCS_BC_GIVE_REWARD pMsg;
; 2889 : 
; 2890 : 			pMsg.bWinner = true;
; 2891 : 			pMsg.btType = -1;
; 2892 : 			memcpy(pMsg.m_stBCCharScore[0].CharName , gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, MAX_ACCOUNT_LEN);

  006b5	8b 07		 mov	 eax, DWORD PTR [edi]
  006b7	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  006bd	05 6f 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+111
  006c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  006c4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  006c7	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]

; 2893 : 			pMsg.m_stBCCharScore[0].iEXP = iREWARD_EXP;
; 2894 : 			pMsg.m_stBCCharScore[0].iZEN = iREWARD_ZEN;
; 2895 : 			pMsg.m_stBCCharScore[0].iSCORE = iREWARD_SCR;
; 2896 : 			PHeadSetB((LPBYTE)&pMsg.PHeader, 0x93, sizeof(GCS_BC_GIVE_REWARD) - (sizeof(ST_BC_SCORE) * (MAX_BLOOD_CASTLE_SUB_BRIDGE -1)) );

  006cb	6a 35		 push	 53			; 00000035H
  006cd	66 89 85 f9 fd
	ff ff		 mov	 WORD PTR _pMsg$158306[ebp+13], ax
  006d4	89 8d f1 fd ff
	ff		 mov	 DWORD PTR _pMsg$158306[ebp+5], ecx
  006da	8b 8d d0 fc ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_EXP$[ebp]
  006e0	89 95 f5 fd ff
	ff		 mov	 DWORD PTR _pMsg$158306[ebp+9], edx
  006e6	8b 95 d4 fc ff
	ff		 mov	 edx, DWORD PTR _iREWARD_ZEN$[ebp]
  006ec	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _pMsg$158306[ebp]
  006f2	68 93 00 00 00	 push	 147			; 00000093H
  006f7	50		 push	 eax
  006f8	66 c7 85 ef fd
	ff ff 01 ff	 mov	 WORD PTR _pMsg$158306[ebp+3], 65281 ; 0000ff01H
  00701	89 8d 01 fe ff
	ff		 mov	 DWORD PTR _pMsg$158306[ebp+21], ecx
  00707	89 95 05 fe ff
	ff		 mov	 DWORD PTR _pMsg$158306[ebp+25], edx
  0070d	89 9d fd fd ff
	ff		 mov	 DWORD PTR _pMsg$158306[ebp+17], ebx
  00713	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2897 : 
; 2898 : 			DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (UCHAR*)&pMsg, pMsg.PHeader.uSize);

  00718	0f b6 8d ed fd
	ff ff		 movzx	 ecx, BYTE PTR _pMsg$158306[ebp+1]
  0071f	8b 07		 mov	 eax, DWORD PTR [edi]
  00721	51		 push	 ecx
  00722	8d 95 ec fd ff
	ff		 lea	 edx, DWORD PTR _pMsg$158306[ebp]
  00728	52		 push	 edx
  00729	50		 push	 eax
  0072a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0072f	83 c4 18	 add	 esp, 24			; 00000018H
$LN27@GiveReward:

; 2749 : 
; 2750 : 		for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00732	83 c7 14	 add	 edi, 20			; 00000014H
  00735	ff 8d c0 fc ff
	ff		 dec	 DWORD PTR tv826[ebp]
  0073b	0f 85 43 fa ff
	ff		 jne	 $LL52@GiveReward

; 2899 : 		}
; 2900 : 
; 2901 : 		this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED = true;

  00741	8b 8d c8 fc ff
	ff		 mov	 ecx, DWORD PTR tv1153[ebp]
  00747	c6 81 66 01 00
	00 01		 mov	 BYTE PTR [ecx+358], 1
$LN29@GiveReward:

; 2902 : 	}
; 2903 : }

  0074e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00751	5f		 pop	 edi
  00752	5e		 pop	 esi
  00753	33 cd		 xor	 ecx, ebp
  00755	5b		 pop	 ebx
  00756	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0075b	8b e5		 mov	 esp, ebp
  0075d	5d		 pop	 ebp
  0075e	c2 08 00	 ret	 8
  00761	8d 49 00	 npad	 3
$LN54@GiveReward:
  00764	00 00 00 00	 DD	 $LN7@GiveReward
  00768	00 00 00 00	 DD	 $LN6@GiveReward
  0076c	00 00 00 00	 DD	 $LN5@GiveReward
  00770	00 00 00 00	 DD	 $LN3@GiveReward
  00774	00 00 00 00	 DD	 $LN1@GiveReward
?GiveReward_Win@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::GiveReward_Win
_TEXT	ENDS
PUBLIC	??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@ ; `string'
PUBLIC	??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@ ; `string'
PUBLIC	??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GiveReward_Fail@CBloodCastle@@QAEXH@Z		; CBloodCastle::GiveReward_Fail
;	COMDAT ??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@
CONST	SEGMENT
??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@ DB '['
	DB	'Blood Castle] (%d) Send User Quest Fail Message (Account:%s, '
	DB	'Name:%s [State:%d], MapNumber:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@
CONST	SEGMENT
??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@ DB '['
	DB	'Blood Castle] (%d) Quest Fail Rewarded (Account:%s, Name:%s, '
	DB	'Score:%d, ExtEXP:%d, LeftTime:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) got Ultimate Weapon '
	DB	'(%d) but Failed - Time Out', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GiveReward_Fail@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv906 = -292						; size = 4
_this$GSCopy$ = -288					; size = 4
tv452 = -284						; size = 4
tv488 = -280						; size = 4
_pMsg$158339 = -276					; size = 269
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?GiveReward_Fail@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::GiveReward_Fail, COMDAT
; _this$ = ecx

; 2909 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00018	8b f1		 mov	 esi, ecx

; 2910 : 	this->FixUsersPlayStateFail(iBridgeIndex);

  0001a	57		 push	 edi

; 2967 : 		}
; 2968 : 
; 2969 : 		this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  0001b	89 b5 e0 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  00021	e8 00 00 00 00	 call	 ?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z ; CBloodCastle::FixUsersPlayStateFail
  00026	85 ff		 test	 edi, edi
  00028	0f 88 6d 02 00
	00		 js	 $LN15@GiveReward@2

; 2911 : 
; 2912 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0002e	33 c0		 xor	 eax, eax
  00030	83 ff 06	 cmp	 edi, 6
  00033	0f 9e c0	 setle	 al
  00036	85 c0		 test	 eax, eax
  00038	0f 84 5d 02 00
	00		 je	 $LN15@GiveReward@2

; 2913 : 	{
; 2914 : 		return;
; 2915 : 	}
; 2916 : 
; 2917 : 	int iUserWhoGotUltimateWeapon = -1;
; 2918 : 	iUserWhoGotUltimateWeapon = this->GetWhoGotUltimateWeapon(iBridgeIndex);

  0003e	57		 push	 edi
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWhoGotUltimateWeapon

; 2919 : 
; 2920 : 	if ( iUserWhoGotUltimateWeapon != -1 )

  00046	83 f8 ff	 cmp	 eax, -1
  00049	74 47		 je	 SHORT $LN18@GiveReward@2

; 2921 : 	{
; 2922 : 		if ( OBJMAX_RANGE(iUserWhoGotUltimateWeapon) != FALSE )

  0004b	85 c0		 test	 eax, eax
  0004d	78 43		 js	 SHORT $LN18@GiveReward@2
  0004f	33 c9		 xor	 ecx, ecx
  00051	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00056	0f 9e c1	 setle	 cl
  00059	85 c9		 test	 ecx, ecx
  0005b	74 35		 je	 SHORT $LN18@GiveReward@2

; 2923 : 		{
; 2924 : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) (Account:%s, Name:%s) got Ultimate Weapon (%d) but Failed - Time Out",
; 2925 : 				iBridgeIndex+1, gObj[iUserWhoGotUltimateWeapon].AccountID, gObj[iUserWhoGotUltimateWeapon].Name,
; 2926 : 				this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER);

  0005d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00063	8b cf		 mov	 ecx, edi
  00065	c1 e1 09	 shl	 ecx, 9
  00068	0f b6 94 31 98
	01 00 00	 movzx	 edx, BYTE PTR [ecx+esi+408]
  00070	52		 push	 edx
  00071	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  00077	51		 push	 ecx
  00078	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  0007e	52		 push	 edx
  0007f	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00082	50		 push	 eax
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  00088	6a 00		 push	 0
  0008a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0008f	83 c4 18	 add	 esp, 24			; 00000018H
$LN18@GiveReward@2:
  00092	8b d7		 mov	 edx, edi
  00094	c1 e2 09	 shl	 edx, 9

; 2927 : 		}
; 2928 : 	}
; 2929 : 
; 2930 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00097	03 d6		 add	 edx, esi
  00099	89 95 e8 fe ff
	ff		 mov	 DWORD PTR tv488[ebp], edx
  0009f	8d 72 1c	 lea	 esi, DWORD PTR [edx+28]
  000a2	c7 85 e4 fe ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv452[ebp], 10 ; 0000000aH
  000ac	53		 push	 ebx
  000ad	8d 49 00	 npad	 3
$LL32@GiveReward@2:

; 2931 : 	{
; 2932 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  000b0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b2	83 f9 ff	 cmp	 ecx, -1
  000b5	0f 84 d0 01 00
	00		 je	 $LN16@GiveReward@2

; 2933 : 		{
; 2934 : 			continue;
; 2935 : 		}
; 2936 : 
; 2937 : 		if ( gObj[ this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].Connected < PLAYER_PLAYING )

  000bb	8b c1		 mov	 eax, ecx
  000bd	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000c3	80 b8 04 00 00
	00 03		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 3
  000ca	0f 82 bb 01 00
	00		 jb	 $LN16@GiveReward@2

; 2938 : 		{
; 2939 : 			continue;
; 2940 : 		}
; 2941 : 
; 2942 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 )

  000d0	80 b8 02 0d 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330], -1
  000d7	0f 84 ae 01 00
	00		 je	 $LN16@GiveReward@2
  000dd	80 b8 03 0d 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3331], -1
  000e4	0f 84 a1 01 00
	00		 je	 $LN16@GiveReward@2

; 2943 : 		{
; 2944 : 			continue;
; 2945 : 		}	
; 2946 : 
; 2947 : 		int iADD_EXP = 0;
; 2948 : 
; 2949 : 		if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index)

  000ea	8b 80 a8 02 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+680]
  000f0	33 db		 xor	 ebx, ebx
  000f2	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv906[ebp], eax
  000f8	83 f8 ff	 cmp	 eax, -1
  000fb	74 08		 je	 SHORT $LN8@GiveReward@2
  000fd	3b 82 a0 01 00
	00		 cmp	 eax, DWORD PTR [edx+416]
  00103	74 08		 je	 SHORT $LN30@GiveReward@2
$LN8@GiveReward@2:
  00105	3b 8a a4 01 00
	00		 cmp	 ecx, DWORD PTR [edx+420]
  0010b	75 0d		 jne	 SHORT $LN10@GiveReward@2
$LN30@GiveReward@2:

; 2950 : 		{
; 2951 : 			iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0;

  0010d	8b df		 mov	 ebx, edi
  0010f	c1 e3 04	 shl	 ebx, 4
  00112	8b 9b 00 00 00
	00		 mov	 ebx, DWORD PTR _g_iBC_Add_Exp[ebx]

; 2952 : 		}
; 2953 : 		else

  00118	eb 28		 jmp	 SHORT $LN5@GiveReward@2
$LN10@GiveReward@2:

; 2954 : 		{
; 2955 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 )

  0011a	83 f8 ff	 cmp	 eax, -1
  0011d	74 30		 je	 SHORT $LN2@GiveReward@2

; 2956 : 			{
; 2957 : 				if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak != false )

  0011f	38 5e 11	 cmp	 BYTE PTR [esi+17], bl
  00122	74 1e		 je	 SHORT $LN5@GiveReward@2

; 2958 : 				{
; 2959 : 					iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0 / 2;

  00124	8b d7		 mov	 edx, edi
  00126	c1 e2 04	 shl	 edx, 4
  00129	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _g_iBC_Add_Exp[edx]
  0012f	99		 cdq
  00130	2b c2		 sub	 eax, edx
  00132	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv488[ebp]
  00138	8b d8		 mov	 ebx, eax
  0013a	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv906[ebp]
  00140	d1 fb		 sar	 ebx, 1
$LN5@GiveReward@2:

; 2960 : 				}
; 2961 : 			}
; 2962 : 		}
; 2963 : 
; 2964 : 		if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index)

  00142	83 f8 ff	 cmp	 eax, -1
  00145	74 08		 je	 SHORT $LN2@GiveReward@2
  00147	3b 82 c0 01 00
	00		 cmp	 eax, DWORD PTR [edx+448]
  0014d	74 08		 je	 SHORT $LN3@GiveReward@2
$LN2@GiveReward@2:
  0014f	3b 8a c4 01 00
	00		 cmp	 ecx, DWORD PTR [edx+452]
  00155	75 0b		 jne	 SHORT $LN4@GiveReward@2
$LN3@GiveReward@2:

; 2965 : 		{
; 2966 : 			iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk4;

  00157	8b c7		 mov	 eax, edi
  00159	c1 e0 04	 shl	 eax, 4
  0015c	03 98 04 00 00
	00		 add	 ebx, DWORD PTR _g_iBC_Add_Exp[eax+4]
$LN4@GiveReward@2:

; 2967 : 		}
; 2968 : 
; 2969 : 		this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  00162	53		 push	 ebx
  00163	51		 push	 ecx
  00164	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0016a	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 2970 : 		this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iBC_EventScore_Fail[iBridgeIndex], 0, 0);

  0016f	8b 0c bd 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iBC_EventScore_Fail[edi*4]
  00176	8b 16		 mov	 edx, DWORD PTR [esi]
  00178	6a 00		 push	 0
  0017a	6a 00		 push	 0
  0017c	51		 push	 ecx
  0017d	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00183	52		 push	 edx
  00184	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2971 : 
; 2972 : 		LogAdd(LOG_BLACK, "[Blood Castle] (%d) Quest Fail Rewarded (Account:%s, Name:%s, Score:%d, ExtEXP:%d, LeftTime:%d)",
; 2973 : 			iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 2974 : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 2975 : 			::g_iBC_EventScore_Fail[iBridgeIndex], iADD_EXP, 0);

  00189	8b 06		 mov	 eax, DWORD PTR [esi]
  0018b	8b 14 bd 00 00
	00 00		 mov	 edx, DWORD PTR _g_iBC_EventScore_Fail[edi*4]
  00192	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00198	6a 00		 push	 0
  0019a	53		 push	 ebx
  0019b	52		 push	 edx
  0019c	8d 90 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  001a2	52		 push	 edx
  001a3	8d 80 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  001a9	50		 push	 eax
  001aa	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  001ad	51		 push	 ecx
  001ae	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@
  001b3	6a 00		 push	 0
  001b5	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2976 : 
; 2977 : 		GCS_BC_GIVE_REWARD pMsg;
; 2978 : 
; 2979 : 		pMsg.bWinner = false;
; 2980 : 		pMsg.btType = -1;
; 2981 : 		memcpy(pMsg.m_stBCCharScore[0].CharName, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, MAX_ACCOUNT_LEN);

  001ba	8b 06		 mov	 eax, DWORD PTR [esi]
  001bc	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  001c2	05 6f 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+111
  001c7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cc	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]

; 2982 : 		pMsg.m_stBCCharScore[0].iEXP = iADD_EXP;
; 2983 : 		pMsg.m_stBCCharScore[0].iZEN = 0;
; 2984 : 		pMsg.m_stBCCharScore[0].iSCORE = g_iBC_EventScore_Fail[iBridgeIndex];
; 2985 : 		PHeadSetB((LPBYTE)&pMsg.PHeader, 0x93, sizeof(GCS_BC_GIVE_REWARD) - (sizeof(ST_BC_SCORE) * (MAX_BLOOD_CASTLE_SUB_BRIDGE -1)) );

  001d0	6a 35		 push	 53			; 00000035H
  001d2	89 95 f5 fe ff
	ff		 mov	 DWORD PTR _pMsg$158339[ebp+9], edx
  001d8	89 8d f1 fe ff
	ff		 mov	 DWORD PTR _pMsg$158339[ebp+5], ecx
  001de	8b 0c bd 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iBC_EventScore_Fail[edi*4]
  001e5	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$158339[ebp]
  001eb	68 93 00 00 00	 push	 147			; 00000093H
  001f0	52		 push	 edx
  001f1	66 c7 85 ef fe
	ff ff 00 ff	 mov	 WORD PTR _pMsg$158339[ebp+3], 65280 ; 0000ff00H
  001fa	66 89 85 f9 fe
	ff ff		 mov	 WORD PTR _pMsg$158339[ebp+13], ax
  00201	89 9d 01 ff ff
	ff		 mov	 DWORD PTR _pMsg$158339[ebp+21], ebx
  00207	c7 85 05 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pMsg$158339[ebp+25], 0
  00211	89 8d fd fe ff
	ff		 mov	 DWORD PTR _pMsg$158339[ebp+17], ecx
  00217	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2986 : 
; 2987 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  0021c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0021e	8b c1		 mov	 eax, ecx
  00220	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00226	83 c4 2c	 add	 esp, 44			; 0000002cH
  00229	80 b8 02 0d 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3330], -1
  00230	74 53		 je	 SHORT $LN29@GiveReward@2
  00232	80 b8 03 0d 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3331], -1
  00239	74 4a		 je	 SHORT $LN29@GiveReward@2

; 2988 : 		{
; 2989 : 			DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (UCHAR*)&pMsg, pMsg.PHeader.uSize);			

  0023b	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$158339[ebp+1]
  00242	50		 push	 eax
  00243	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$158339[ebp]
  00249	52		 push	 edx
  0024a	51		 push	 ecx
  0024b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2990 : 
; 2991 : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) Send User Quest Fail Message (Account:%s, Name:%s [State:%d], MapNumber:%d)",
; 2992 : 				iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 2993 : 				gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, 
; 2994 : 				this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState,
; 2995 : 				gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  00250	8b 06		 mov	 eax, DWORD PTR [esi]
  00252	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00255	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0025b	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00262	51		 push	 ecx
  00263	52		 push	 edx
  00264	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  0026a	51		 push	 ecx
  0026b	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00271	52		 push	 edx
  00272	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00275	50		 push	 eax
  00276	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@
  0027b	6a 00		 push	 0
  0027d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00282	83 c4 28	 add	 esp, 40			; 00000028H
$LN29@GiveReward@2:
  00285	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv488[ebp]
$LN16@GiveReward@2:

; 2927 : 		}
; 2928 : 	}
; 2929 : 
; 2930 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0028b	83 c6 14	 add	 esi, 20			; 00000014H
  0028e	ff 8d e4 fe ff
	ff		 dec	 DWORD PTR tv452[ebp]
  00294	0f 85 16 fe ff
	ff		 jne	 $LL32@GiveReward@2
  0029a	5b		 pop	 ebx
$LN15@GiveReward@2:

; 2996 : 		}	
; 2997 : 	}
; 2998 : }

  0029b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029e	5f		 pop	 edi
  0029f	33 cd		 xor	 ecx, ebp
  002a1	5e		 pop	 esi
  002a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a7	8b e5		 mov	 esp, ebp
  002a9	5d		 pop	 ebp
  002aa	c2 04 00	 ret	 4
?GiveReward_Fail@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::GiveReward_Fail
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >, COMDAT
; _this$ = ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 556  : 		}

  0000a	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 483  : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
_TEXT	ENDS
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 336  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN7@scalar@9
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN7@scalar@9:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?c_str@locale@std@@QBEPBDXZ			; std::locale::c_str
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ?c_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@locale@std@@QBEPBDXZ PROC			; std::locale::c_str, COMDAT
; _this$ = ecx

; 432  : 		return (_Ptr->_Name.c_str());

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00005	85 c0		 test	 eax, eax
  00007	75 03		 jne	 SHORT $LN6@c_str@2
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN6@c_str@2:

; 433  : 		}

  0000c	c3		 ret	 0
?c_str@locale@std@@QBEPBDXZ ENDP			; std::locale::c_str
_TEXT	ENDS
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z		; std::ctype<char>::ctype<char>
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
CONST	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T162518 = -16						; size = 16
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 2365 : 		{	// construct from current locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx

; 2366 : 		_Init(_Lobj);

  0000c	8d 4d f0	 lea	 ecx, DWORD PTR $T162518[ebp]
  0000f	51		 push	 ecx
  00010	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  00019	e8 00 00 00 00	 call	 __Getctype
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00023	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00026	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00029	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0002c	89 56 10	 mov	 DWORD PTR [esi+16], edx
  0002f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00032	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00035	83 c4 04	 add	 esp, 4

; 2367 : 		}

  00038	8b c6		 mov	 eax, esi
  0003a	5e		 pop	 esi
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
_TEXT	ENDS
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2405 : 		if (0 < _Ctype._Delfl)

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	85 c0		 test	 eax, eax
  00005	7e 0d		 jle	 SHORT $LN6@Tidy@2

; 2406 : 			free((void *)_Ctype._Table);

  00007	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _free
  00010	83 c4 04	 add	 esp, 4

; 2409 : 		}

  00013	c3		 ret	 0
$LN6@Tidy@2:

; 2407 : 		else if (_Ctype._Delfl < 0)

  00014	79 0a		 jns	 SHORT $LN1@Tidy@2

; 2408 : 			delete[] (void *)_Ctype._Table;

  00016	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001f	59		 pop	 ecx
$LN1@Tidy@2:

; 2409 : 		}

  00020	c3		 ret	 0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
EXTRN	__Tolower:PROC
; Function compile flags: /Ogtp
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2412 : 		{	// convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2413 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00007	83 c1 08	 add	 ecx, 8
  0000a	51		 push	 ecx
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Tolower
  00011	83 c4 08	 add	 esp, 8

; 2414 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2418 : 		{	// convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2419 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2420 : 		for (; _First != _Last; ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 19		 je	 SHORT $LN8@do_tolower
  0000f	57		 push	 edi
  00010	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
$LL3@do_tolower:

; 2421 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

  00013	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00016	57		 push	 edi
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 __Tolower
  0001d	88 06		 mov	 BYTE PTR [esi], al
  0001f	46		 inc	 esi
  00020	83 c4 08	 add	 esp, 8
  00023	3b f3		 cmp	 esi, ebx
  00025	75 ec		 jne	 SHORT $LL3@do_tolower
  00027	5f		 pop	 edi
$LN8@do_tolower:

; 2422 : 		return ((const _Elem *)_First);

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx

; 2423 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
EXTRN	__Toupper:PROC
; Function compile flags: /Ogtp
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2426 : 		{	// convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2427 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00007	83 c1 08	 add	 ecx, 8
  0000a	51		 push	 ecx
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Toupper
  00011	83 c4 08	 add	 esp, 8

; 2428 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2432 : 		{	// convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2433 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2434 : 		for (; _First != _Last; ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 19		 je	 SHORT $LN8@do_toupper
  0000f	57		 push	 edi
  00010	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
$LL3@do_toupper:

; 2435 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

  00013	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00016	57		 push	 edi
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 __Toupper
  0001d	88 06		 mov	 BYTE PTR [esi], al
  0001f	46		 inc	 esi
  00020	83 c4 08	 add	 esp, 8
  00023	3b f3		 cmp	 esi, ebx
  00025	75 ec		 jne	 SHORT $LL3@do_toupper
  00027	5f		 pop	 edi
$LN8@do_toupper:

; 2436 : 		return ((const _Elem *)_First);

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx

; 2437 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2440 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2441 : 		return (_Byte);

  00003	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]

; 2442 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2446 : 		{	// widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2447 : 		_DEBUG_RANGE(_First, _Last);
; 2448 : 		_DEBUG_POINTER(_Dest);
; 2449 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	8b ce		 mov	 ecx, esi
  0000f	2b c8		 sub	 ecx, eax
  00011	51		 push	 ecx
  00012	50		 push	 eax
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _memcpy
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2450 : 		return (_Last);

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi

; 2451 : 		}

  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2454 : 		{	// narrow char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2455 : 		return (_Ch);

  00003	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]

; 2456 : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2460 : 		{	// narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2461 : 		_DEBUG_RANGE(_First, _Last);
; 2462 : 		_DEBUG_POINTER(_Dest);
; 2463 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 14	 mov	 edx, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	8b ce		 mov	 ecx, esi
  0000f	2b c8		 sub	 ecx, eax
  00011	51		 push	 ecx
  00012	50		 push	 eax
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _memcpy
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2464 : 		return (_Last);

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi

; 2465 : 		}

  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
; Function compile flags: /Ogtp
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2394 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2395 : 		_Tidy();

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0000c	85 c0		 test	 eax, eax
  0000e	7e 14		 jle	 SHORT $LN14@ctype
  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _free
  00019	83 c4 04	 add	 esp, 4

; 2396 : 		}

  0001c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00022	5e		 pop	 esi
  00023	c3		 ret	 0
$LN14@ctype:

; 2395 : 		_Tidy();

  00024	79 0c		 jns	 SHORT $LN13@ctype
  00026	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002f	83 c4 04	 add	 esp, 4
$LN13@ctype:

; 2396 : 		}

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00038	5e		 pop	 esi
  00039	c3		 ret	 0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0000f	85 c0		 test	 eax, eax
  00011	7e 0b		 jle	 SHORT $LN16@scalar@10
  00013	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _free
  0001c	eb 0b		 jmp	 SHORT $LN17@scalar@10
$LN16@scalar@10:
  0001e	79 0c		 jns	 SHORT $LN6@scalar@10
  00020	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
$LN17@scalar@10:
  00029	83 c4 04	 add	 esp, 4
$LN6@scalar@10:
  0002c	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00036	74 09		 je	 SHORT $LN15@scalar@10
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
$LN15@scalar@10:
  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\system_error
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
_DATA	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
__Errcode$ = 8						; size = 8
$T162611 = 16						; size = 4
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 516  : 		{	// construct from error code and message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 10	 mov	 eax, DWORD PTR __Message$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8d 4d 10	 lea	 ecx, DWORD PTR $T162611[ebp]
  0000c	51		 push	 ecx
  0000d	8b ce		 mov	 ecx, esi
  0000f	89 45 10	 mov	 DWORD PTR $T162611[ebp], eax
  00012	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00017	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp+4]
  0001a	8b 55 08	 mov	 edx, DWORD PTR __Errcode$[ebp]
  0001d	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@
  00026	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 517  : 		_Makestr();
; 518  : 		}

  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN10@scalar@11
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN10@scalar@11:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
CONST	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
$T162637 = 12						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 237  : 			{	// construct with message

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00006	53		 push	 ebx
  00007	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 38		 mov	 edi, DWORD PTR [eax]
  00010	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00013	8d 4d 0c	 lea	 ecx, DWORD PTR $T162637[ebp]
  00016	51		 push	 ecx
  00017	8b ce		 mov	 ecx, esi
  00019	89 45 0c	 mov	 DWORD PTR $T162637[ebp], eax
  0001c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00021	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00024	5f		 pop	 edi
  00025	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@

; 238  : 			}

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
_TEXT	ENDS
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
; Function compile flags: /Ogtp
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ ; `string'
PUBLIC	__TI4?AVfailure@ios_base@std@@
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@	; `string'
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	__CTA4?AVfailure@ios_base@std@@
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\system_error
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT __CTA4?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA4?AVfailure@ios_base@std@@ DD 04H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ DB 'ios_base::failbit se'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT __TI4?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI4?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA4?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ DB 'ios_base::badbit set', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
CONST	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T162669 = -20						; size = 20
$T162667 = -20						; size = 20
$T162665 = -20						; size = 20
__State$ = 8						; size = 4
$T162760 = 12						; size = 4
$T162724 = 12						; size = 4
$T162688 = 12						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 310  : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  : 		_Mystate = (iostate)(_State & _Statmask);

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	83 e0 17	 and	 eax, 23			; 00000017H
  00009	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 312  : 		if ((_Mystate & _Except) == 0)

  0000c	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000f	83 ec 14	 sub	 esp, 20			; 00000014H
  00012	23 c8		 and	 ecx, eax
  00014	0f 84 bd 00 00
	00		 je	 $LN1@clear

; 313  : 			;
; 314  : 		else if (_Reraise)

  0001a	80 7d 0c 00	 cmp	 BYTE PTR __Reraise$[ebp], 0
  0001e	74 09		 je	 SHORT $LN6@clear

; 315  : 			_RERAISE;

  00020	6a 00		 push	 0
  00022	6a 00		 push	 0
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN57@clear:
$LN6@clear:

; 316  : 		else if (_Mystate & _Except & badbit)
; 317  : 			_THROW_NCEE(failure, "ios_base::badbit set");

  00029	be 01 00 00 00	 mov	 esi, 1
  0002e	f6 c1 04	 test	 cl, 4
  00031	74 35		 je	 SHORT $LN4@clear
  00033	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  00038	8b f8		 mov	 edi, eax
  0003a	8d 45 0c	 lea	 eax, DWORD PTR $T162688[ebp]
  0003d	50		 push	 eax
  0003e	8d 4d ec	 lea	 ecx, DWORD PTR $T162665[ebp]
  00041	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR $T162688[ebp], OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  00048	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0004d	68 00 00 00 00	 push	 OFFSET __TI4?AVfailure@ios_base@std@@
  00052	8d 4d ec	 lea	 ecx, DWORD PTR $T162665[ebp]
  00055	51		 push	 ecx
  00056	89 75 f8	 mov	 DWORD PTR $T162665[ebp+12], esi
  00059	89 7d fc	 mov	 DWORD PTR $T162665[ebp+16], edi
  0005c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T162665[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00063	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN58@clear:
$LN4@clear:

; 318  : 		else if (_Mystate & _Except & failbit)

  00068	f6 c1 02	 test	 cl, 2
  0006b	74 35		 je	 SHORT $LN2@clear

; 319  : 			_THROW_NCEE(failure, "ios_base::failbit set");

  0006d	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  00072	8d 55 0c	 lea	 edx, DWORD PTR $T162724[ebp]
  00075	52		 push	 edx
  00076	8d 4d ec	 lea	 ecx, DWORD PTR $T162667[ebp]
  00079	8b f8		 mov	 edi, eax
  0007b	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR $T162724[ebp], OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  00082	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00087	68 00 00 00 00	 push	 OFFSET __TI4?AVfailure@ios_base@std@@
  0008c	8d 45 ec	 lea	 eax, DWORD PTR $T162667[ebp]
  0008f	50		 push	 eax
  00090	89 75 f8	 mov	 DWORD PTR $T162667[ebp+12], esi
  00093	89 7d fc	 mov	 DWORD PTR $T162667[ebp+16], edi
  00096	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T162667[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  0009d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN59@clear:
$LN2@clear:

; 320  : 		else
; 321  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

  000a2	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  000a7	8d 4d 0c	 lea	 ecx, DWORD PTR $T162760[ebp]
  000aa	51		 push	 ecx
  000ab	8d 4d ec	 lea	 ecx, DWORD PTR $T162669[ebp]
  000ae	8b f8		 mov	 edi, eax
  000b0	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR $T162760[ebp], OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000b7	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000bc	68 00 00 00 00	 push	 OFFSET __TI4?AVfailure@ios_base@std@@
  000c1	8d 55 ec	 lea	 edx, DWORD PTR $T162669[ebp]
  000c4	52		 push	 edx
  000c5	89 75 f8	 mov	 DWORD PTR $T162669[ebp+12], esi
  000c8	89 7d fc	 mov	 DWORD PTR $T162669[ebp+16], edi
  000cb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T162669[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000d2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN60@clear:
$LN1@clear:

; 322  : 		}

  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c2 08 00	 ret	 8
$LN56@clear:
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@
  00016	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00019	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0001c	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0001f	5f		 pop	 edi
  00020	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
PUBLIC	?clear@ios_base@std@@QAEXH@Z			; std::ios_base::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
?clear@ios_base@std@@QAEXH@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 325  : 		{	// set state to argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 326  : 		clear(_State, false);

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	6a 00		 push	 0
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 327  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?clear@ios_base@std@@QAEXH@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
PUBLIC	?_Init@ios_base@std@@IAEXXZ			; std::ios_base::_Init
; Function compile flags: /Ogtp
;	COMDAT ?_Init@ios_base@std@@IAEXXZ
_TEXT	SEGMENT
__Lock$162815 = -8					; size = 4
$T162811 = -4						; size = 4
?_Init@ios_base@std@@IAEXXZ PROC			; std::ios_base::_Init, COMDAT
; _this$ = ecx

; 554  : 		{	// initialize a new ios_base

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 555  : 		_Ploc = 0;

  0000b	33 ff		 xor	 edi, edi

; 556  : 		_Stdstr = 0;
; 557  : 		_Except = goodbit;
; 558  : 		_Fmtfl = (fmtflags)(skipws | dec);
; 559  : 		_Prec = 6;
; 560  : 		_Wide = 0;
; 561  : 		_Arr = 0;
; 562  : 		_Calls = 0;
; 563  : 		clear(goodbit);

  0000d	57		 push	 edi
  0000e	57		 push	 edi
  0000f	89 7e 30	 mov	 DWORD PTR [esi+48], edi
  00012	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00015	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00018	c7 46 14 01 02
	00 00		 mov	 DWORD PTR [esi+20], 513	; 00000201H
  0001f	c7 46 18 06 00
	00 00		 mov	 DWORD PTR [esi+24], 6
  00026	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00029	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  0002c	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  0002f	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  00032	89 7e 2c	 mov	 DWORD PTR [esi+44], edi
  00035	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 564  : 		_Ploc = _NEW_CRT locale;

  0003a	6a 04		 push	 4
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b d8		 mov	 ebx, eax
  00043	83 c4 04	 add	 esp, 4
  00046	3b df		 cmp	 ebx, edi
  00048	74 39		 je	 SHORT $LN3@Init
  0004a	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Init
  0004f	89 03		 mov	 DWORD PTR [ebx], eax
  00051	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  00056	57		 push	 edi
  00057	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$162815[ebp]
  0005a	89 45 fc	 mov	 DWORD PTR $T162811[ebp], eax
  0005d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00062	8b 4d fc	 mov	 ecx, DWORD PTR $T162811[ebp]
  00065	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00068	83 f8 ff	 cmp	 eax, -1
  0006b	73 04		 jae	 SHORT $LN9@Init
  0006d	40		 inc	 eax
  0006e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN9@Init:
  00071	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$162815[ebp]
  00074	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00079	5f		 pop	 edi
  0007a	89 5e 30	 mov	 DWORD PTR [esi+48], ebx
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx

; 565  : 		}

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
$LN3@Init:

; 564  : 		_Ploc = _NEW_CRT locale;

  00083	89 7e 30	 mov	 DWORD PTR [esi+48], edi
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx

; 565  : 		}

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?_Init@ios_base@std@@IAEXXZ ENDP			; std::ios_base::_Init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN13@scalar@12
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN13@scalar@12:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@
  00016	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00019	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0001c	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0001f	5f		 pop	 edi
  00020	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00023	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 44 02 38	 mov	 eax, DWORD PTR [edx+eax+56]
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN4@sentry
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	8b c8		 mov	 ecx, eax
  00013	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00016	ff e0		 jmp	 eax
$LN4@sentry:
  00018	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1496 : 		{	// return pointer to null-terminated nonmutable array

  00000	8b c1		 mov	 eax, ecx

; 1497 : 		return (_Myptr());

  00002	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00006	72 02		 jb	 SHORT $LN6@c_str@3
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
$LN6@c_str@3:

; 1498 : 		}

  0000a	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 3365 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3366 : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Yarn
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN6@Yarn:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3367 : 		}

  00019	c3		 ret	 0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
PUBLIC	??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
PUBLIC	?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<char,std::char_traits<char> >::imbue
EXTRN	??1_Mutex@std@@QAE@XZ:PROC			; std::_Mutex::~_Mutex
EXTRN	??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
CONST	ENDS
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__Lock$162933 = -8					; size = 4
_this$ = -4						; size = 4
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 79   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 80   : 		_DELETE_CRT(_Plocale);

  0000a	8b 5e 38	 mov	 ebx, DWORD PTR [esi+56]
  0000d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  00016	85 db		 test	 ebx, ebx
  00018	74 4d		 je	 SHORT $LN6@basic_stre
  0001a	57		 push	 edi
  0001b	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0001d	85 ff		 test	 edi, edi
  0001f	74 3c		 je	 SHORT $LN12@basic_stre
  00021	6a 00		 push	 0
  00023	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$162933[ebp]
  00026	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  0002b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002e	85 c0		 test	 eax, eax
  00030	74 09		 je	 SHORT $LN14@basic_stre
  00032	83 f8 ff	 cmp	 eax, -1
  00035	73 04		 jae	 SHORT $LN14@basic_stre
  00037	48		 dec	 eax
  00038	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN14@basic_stre:
  0003b	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0003e	f7 de		 neg	 esi
  00040	1b f6		 sbb	 esi, esi
  00042	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$162933[ebp]
  00045	f7 d6		 not	 esi
  00047	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0004c	23 f7		 and	 esi, edi
  0004e	74 0a		 je	 SHORT $LN18@basic_stre
  00050	8b 06		 mov	 eax, DWORD PTR [esi]
  00052	8b 10		 mov	 edx, DWORD PTR [eax]
  00054	6a 01		 push	 1
  00056	8b ce		 mov	 ecx, esi
  00058	ff d2		 call	 edx
$LN18@basic_stre:
  0005a	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
$LN12@basic_stre:
  0005d	53		 push	 ebx
  0005e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00063	83 c4 04	 add	 esp, 4
  00066	5f		 pop	 edi
$LN6@basic_stre:

; 81   : 		}

  00067	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0006a	e8 00 00 00 00	 call	 ??1_Mutex@std@@QAE@XZ	; std::_Mutex::~_Mutex
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
_TEXT	ENDS
EXTRN	?_Lock@_Mutex@std@@QAEXXZ:PROC			; std::_Mutex::_Lock
; Function compile flags: /Ogtp
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 207  : 		_Mylock._Lock();

  00000	83 c1 04	 add	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ?_Lock@_Mutex@std@@QAEXXZ ; std::_Mutex::_Lock
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
EXTRN	?_Unlock@_Mutex@std@@QAEXXZ:PROC		; std::_Mutex::_Unlock
; Function compile flags: /Ogtp
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 212  : 		_Mylock._Unlock();

  00000	83 c1 04	 add	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ?_Unlock@_Mutex@std@@QAEXXZ ; std::_Mutex::_Unlock
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 338  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 339  : 		}

  00003	c2 04 00	 ret	 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::overflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 343  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 344  : 		}

  00003	c2 04 00	 ret	 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
_TEXT	SEGMENT
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc, COMDAT
; _this$ = ecx

; 348  : 		return (0);

  00000	33 c0		 xor	 eax, eax
  00002	33 d2		 xor	 edx, edx

; 349  : 		}

  00004	c3		 ret	 0
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 353  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 354  : 		}

  00003	c3		 ret	 0
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::underflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 434  : 		{	// offer buffer to external agent (do nothing)

  00000	8b c1		 mov	 eax, ecx

; 435  : 		return (this);
; 436  : 		}

  00002	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 440  : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 441  : 		}

  00002	c3		 ret	 0
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sync
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 445  : 		}

  00000	c2 04 00	 ret	 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
PUBLIC	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
; Function compile flags: /Ogtp
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pptr, COMDAT
; _this$ = ecx

; 233  : 		return (*_IPnext);

  00000	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 234  : 		}

  00005	c3		 ret	 0
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pptr
_TEXT	ENDS
PUBLIC	?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::gbump
; Function compile flags: /Ogtp
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::gbump, COMDAT
; _this$ = ecx

; 242  : 		{	// alter current position in read buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 243  : 		*_IGcount -= _Off;

  00003	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 244  : 		*_IGnext += _Off;

  0000b	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0000e	01 11		 add	 DWORD PTR [ecx], edx

; 245  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gbump
_TEXT	ENDS
PUBLIC	?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbump
; Function compile flags: /Ogtp
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbump, COMDAT
; _this$ = ecx

; 283  : 		{	// alter current position in write buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 284  : 		*_IPcount -= _Off;

  00003	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 285  : 		*_IPnext += _Off;

  0000b	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  0000e	01 11		 add	 DWORD PTR [ecx], edx

; 286  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbump
_TEXT	ENDS
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
; Function compile flags: /Ogtp
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 310  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  00000	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Pnavail
  00008	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  0000b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000d	99		 cdq

; 311  : 		}

  0000e	c3		 ret	 0
$LN3@Pnavail:

; 310  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 311  : 		}

  00012	c3		 ret	 0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
PUBLIC	??0?$fpos@H@std@@QAE@_J@Z			; std::fpos<int>::fpos<int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ??0?$fpos@H@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 8
??0?$fpos@H@std@@QAE@_J@Z PROC				; std::fpos<int>::fpos<int>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with stream offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp+4]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx
  0000d	33 c9		 xor	 ecx, ecx
  0000f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00012	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00015	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00018	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 41   : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??0?$fpos@H@std@@QAE@_J@Z ENDP				; std::fpos<int>::fpos<int>
_TEXT	ENDS
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetc, COMDAT
; _this$ = ecx

; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 0e		 je	 SHORT $LN3@sgetc
  00008	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000b	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0000e	7e 06		 jle	 SHORT $LN3@sgetc
  00010	8b 00		 mov	 eax, DWORD PTR [eax]
  00012	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 154  : 		}

  00015	c3		 ret	 0
$LN3@sgetc:

; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001b	ff e0		 jmp	 eax
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 357  : 		{	// get a character from stream, point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 358  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())
; 359  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00008	ff d2		 call	 edx
  0000a	83 f8 ff	 cmp	 eax, -1
  0000d	75 04		 jne	 SHORT $LN3@uflow
  0000f	0b c0		 or	 eax, eax
  00011	5e		 pop	 esi

; 360  : 		}

  00012	c3		 ret	 0
$LN3@uflow:

; 358  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())
; 359  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));

  00013	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00016	ff 08		 dec	 DWORD PTR [eax]
  00018	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00020	89 10		 mov	 DWORD PTR [eax], edx
  00022	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00025	5e		 pop	 esi

; 360  : 		}

  00026	c3		 ret	 0
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
_TEXT	SEGMENT
__Copied$ = -8						; size = 8
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn, COMDAT
; _this$ = ecx

; 364  : 		{	// get _Count characters from stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 365  : 		int_type _Meta;
; 366  : 		streamsize _Size, _Copied;
; 367  : 
; 368  : 		for (_Copied = 0; 0 < _Count; )

  00006	33 c0		 xor	 eax, eax
  00008	53		 push	 ebx
  00009	8b d9		 mov	 ebx, ecx
  0000b	89 45 f8	 mov	 DWORD PTR __Copied$[ebp], eax
  0000e	89 45 fc	 mov	 DWORD PTR __Copied$[ebp+4], eax
  00011	39 45 10	 cmp	 DWORD PTR __Count$[ebp+4], eax
  00014	0f 8c a3 00 00
	00		 jl	 $LN30@xsgetn
  0001a	7f 09		 jg	 SHORT $LN31@xsgetn
  0001c	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001f	0f 86 98 00 00
	00		 jbe	 $LN30@xsgetn
$LN31@xsgetn:
  00025	56		 push	 esi
  00026	57		 push	 edi
$LL7@xsgetn:

; 369  : 			if (0 < (_Size = _Gnavail()))

  00027	8b cb		 mov	 ecx, ebx
  00029	e8 00 00 00 00	 call	 ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
  0002e	8b fa		 mov	 edi, edx
  00030	8b f0		 mov	 esi, eax
  00032	85 ff		 test	 edi, edi
  00034	7c 47		 jl	 SHORT $LN5@xsgetn
  00036	7f 04		 jg	 SHORT $LN25@xsgetn
  00038	85 f6		 test	 esi, esi
  0003a	74 41		 je	 SHORT $LN5@xsgetn
$LN25@xsgetn:

; 370  : 				{	// copy from read buffer
; 371  : 				if (_Count < _Size)

  0003c	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp+4]
  0003f	3b c7		 cmp	 eax, edi
  00041	7f 0c		 jg	 SHORT $LN4@xsgetn
  00043	7c 05		 jl	 SHORT $LN29@xsgetn
  00045	39 75 0c	 cmp	 DWORD PTR __Count$[ebp], esi
  00048	73 05		 jae	 SHORT $LN4@xsgetn
$LN29@xsgetn:

; 372  : 					_Size = _Count;

  0004a	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  0004d	8b f8		 mov	 edi, eax
$LN4@xsgetn:

; 373  : 				_Traits::copy(_Ptr, gptr(), (size_t)_Size);

  0004f	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00052	8b 08		 mov	 ecx, DWORD PTR [eax]
  00054	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00057	56		 push	 esi
  00058	51		 push	 ecx
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 _memcpy

; 374  : 				_Ptr += _Size;

  0005f	01 75 08	 add	 DWORD PTR __Ptr$[ebp], esi

; 375  : 				_Copied += _Size;
; 376  : 				_Count -= _Size;
; 377  : 				gbump((int)_Size);

  00062	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	01 75 f8	 add	 DWORD PTR __Copied$[ebp], esi
  0006b	11 7d fc	 adc	 DWORD PTR __Copied$[ebp+4], edi
  0006e	29 75 0c	 sub	 DWORD PTR __Count$[ebp], esi
  00071	19 7d 10	 sbb	 DWORD PTR __Count$[ebp+4], edi
  00074	29 30		 sub	 DWORD PTR [eax], esi
  00076	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00079	01 30		 add	 DWORD PTR [eax], esi
  0007b	eb 28		 jmp	 SHORT $LN1@xsgetn
$LN5@xsgetn:

; 378  : 				}
; 379  : 			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  0007d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0007f	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00082	8b cb		 mov	 ecx, ebx
  00084	ff d2		 call	 edx
  00086	83 ca ff	 or	 edx, -1
  00089	3b c2		 cmp	 eax, edx
  0008b	74 2e		 je	 SHORT $LN32@xsgetn

; 380  : 				break;	// end of file, quit
; 381  : 			else
; 382  : 				{	// get a single character
; 383  : 				*_Ptr++ = _Traits::to_char_type(_Meta);

  0008d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00090	41		 inc	 ecx

; 384  : 				++_Copied;

  00091	83 45 f8 01	 add	 DWORD PTR __Copied$[ebp], 1
  00095	88 41 ff	 mov	 BYTE PTR [ecx-1], al
  00098	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
  0009b	83 55 fc 00	 adc	 DWORD PTR __Copied$[ebp+4], 0

; 385  : 				--_Count;

  0009f	01 55 0c	 add	 DWORD PTR __Count$[ebp], edx
  000a2	11 55 10	 adc	 DWORD PTR __Count$[ebp+4], edx
$LN1@xsgetn:

; 365  : 		int_type _Meta;
; 366  : 		streamsize _Size, _Copied;
; 367  : 
; 368  : 		for (_Copied = 0; 0 < _Count; )

  000a5	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp+4], 0
  000a9	0f 8f 78 ff ff
	ff		 jg	 $LL7@xsgetn
  000af	7c 0a		 jl	 SHORT $LN32@xsgetn
  000b1	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000b5	0f 87 6c ff ff
	ff		 ja	 $LL7@xsgetn
$LN32@xsgetn:
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
$LN30@xsgetn:

; 386  : 				}
; 387  : 
; 388  : 		return (_Copied);

  000bd	8b 45 f8	 mov	 eax, DWORD PTR __Copied$[ebp]
  000c0	8b 55 fc	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000c3	5b		 pop	 ebx

; 389  : 		}

  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c2 0c 00	 ret	 12			; 0000000cH
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
_TEXT	SEGMENT
__Copied$ = -8						; size = 8
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn, COMDAT
; _this$ = ecx

; 393  : 		{	// put _Count characters to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 394  : 		streamsize _Size, _Copied;
; 395  : 
; 396  : 		for (_Copied = 0; 0 < _Count; )

  00006	33 c0		 xor	 eax, eax
  00008	53		 push	 ebx
  00009	8b d9		 mov	 ebx, ecx
  0000b	89 45 f8	 mov	 DWORD PTR __Copied$[ebp], eax
  0000e	89 45 fc	 mov	 DWORD PTR __Copied$[ebp+4], eax
  00011	39 45 10	 cmp	 DWORD PTR __Count$[ebp+4], eax
  00014	0f 8c a7 00 00
	00		 jl	 $LN30@xsputn
  0001a	7f 09		 jg	 SHORT $LN31@xsputn
  0001c	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001f	0f 86 9c 00 00
	00		 jbe	 $LN30@xsputn
$LN31@xsputn:
  00025	56		 push	 esi
  00026	57		 push	 edi
$LL7@xsputn:

; 397  : 			if (0 < (_Size = _Pnavail()))

  00027	8b cb		 mov	 ecx, ebx
  00029	e8 00 00 00 00	 call	 ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
  0002e	8b fa		 mov	 edi, edx
  00030	8b f0		 mov	 esi, eax
  00032	85 ff		 test	 edi, edi
  00034	7c 47		 jl	 SHORT $LN5@xsputn
  00036	7f 04		 jg	 SHORT $LN25@xsputn
  00038	85 f6		 test	 esi, esi
  0003a	74 41		 je	 SHORT $LN5@xsputn
$LN25@xsputn:

; 398  : 				{	// copy to write buffer
; 399  : 				if (_Count < _Size)

  0003c	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp+4]
  0003f	3b c7		 cmp	 eax, edi
  00041	7f 0c		 jg	 SHORT $LN4@xsputn
  00043	7c 05		 jl	 SHORT $LN29@xsputn
  00045	39 75 0c	 cmp	 DWORD PTR __Count$[ebp], esi
  00048	73 05		 jae	 SHORT $LN4@xsputn
$LN29@xsputn:

; 400  : 					_Size = _Count;

  0004a	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  0004d	8b f8		 mov	 edi, eax
$LN4@xsputn:

; 401  : 				_Traits::copy(pptr(), _Ptr, (size_t)_Size);

  0004f	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00052	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00055	8b 11		 mov	 edx, DWORD PTR [ecx]
  00057	56		 push	 esi
  00058	50		 push	 eax
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 _memcpy

; 402  : 				_Ptr += _Size;

  0005f	01 75 08	 add	 DWORD PTR __Ptr$[ebp], esi

; 403  : 				_Copied += _Size;
; 404  : 				_Count -= _Size;
; 405  : 				pbump((int)_Size);

  00062	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	01 75 f8	 add	 DWORD PTR __Copied$[ebp], esi
  0006b	11 7d fc	 adc	 DWORD PTR __Copied$[ebp+4], edi
  0006e	29 75 0c	 sub	 DWORD PTR __Count$[ebp], esi
  00071	19 7d 10	 sbb	 DWORD PTR __Count$[ebp+4], edi
  00074	29 30		 sub	 DWORD PTR [eax], esi
  00076	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00079	01 30		 add	 DWORD PTR [eax], esi

; 406  : 				}
; 407  : 			else if (_Traits::eq_int_type(_Traits::eof(),

  0007b	eb 2c		 jmp	 SHORT $LN1@xsputn
$LN5@xsputn:

; 408  : 				overflow(_Traits::to_int_type(*_Ptr))))

  0007d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00080	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00083	8b 13		 mov	 edx, DWORD PTR [ebx]
  00085	50		 push	 eax
  00086	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00089	8b cb		 mov	 ecx, ebx
  0008b	ff d0		 call	 eax
  0008d	83 c9 ff	 or	 ecx, -1
  00090	3b c1		 cmp	 eax, ecx
  00092	74 2b		 je	 SHORT $LN32@xsputn

; 409  : 				break;	// single character put failed, quit
; 410  : 			else
; 411  : 				{	// count character successfully put
; 412  : 				++_Ptr;

  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	01 45 08	 add	 DWORD PTR __Ptr$[ebp], eax

; 413  : 				++_Copied;

  0009c	01 45 f8	 add	 DWORD PTR __Copied$[ebp], eax
  0009f	83 55 fc 00	 adc	 DWORD PTR __Copied$[ebp+4], 0

; 414  : 				--_Count;

  000a3	01 4d 0c	 add	 DWORD PTR __Count$[ebp], ecx
  000a6	11 4d 10	 adc	 DWORD PTR __Count$[ebp+4], ecx
$LN1@xsputn:

; 394  : 		streamsize _Size, _Copied;
; 395  : 
; 396  : 		for (_Copied = 0; 0 < _Count; )

  000a9	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp+4], 0
  000ad	0f 8f 74 ff ff
	ff		 jg	 $LL7@xsputn
  000b3	7c 0a		 jl	 SHORT $LN32@xsputn
  000b5	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000b9	0f 87 68 ff ff
	ff		 ja	 $LL7@xsputn
$LN32@xsputn:
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
$LN30@xsputn:

; 415  : 				}
; 416  : 
; 417  : 		return (_Copied);

  000c1	8b 45 f8	 mov	 eax, DWORD PTR __Copied$[ebp]
  000c4	8b 55 fc	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000c7	5b		 pop	 ebx

; 418  : 		}

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 0c 00	 ret	 12			; 0000000cH
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
EXTRN	?_BADOFF@std@@3_JB:QWORD			; std::_BADOFF
; Function compile flags: /Ogtp
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 8
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 423  : 		{	// change position by offset, according to way and mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 424  : 		return (streampos(_BADOFF));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB
  0000c	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00012	89 08		 mov	 DWORD PTR [eax], ecx
  00014	33 c9		 xor	 ecx, ecx
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0001f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 425  : 		}

  00022	5d		 pop	 ebp
  00023	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 429  : 		{	// change to specified position, according to mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 430  : 		return (streampos(_BADOFF));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB
  0000c	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00012	89 08		 mov	 DWORD PTR [eax], ecx
  00014	33 c9		 xor	 ecx, ecx
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0001f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 431  : 		}

  00022	5d		 pop	 ebp
  00023	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
PUBLIC	?is_open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_fstream<char,std::char_traits<char> >::is_open
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
;	COMDAT ?is_open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?is_open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::is_open, COMDAT
; _this$ = ecx

; 1312 : 		return (_Filebuffer.is_open());

  00000	33 c0		 xor	 eax, eax
  00002	39 41 6c	 cmp	 DWORD PTR [ecx+108], eax
  00005	0f 95 c0	 setne	 al

; 1313 : 		}

  00008	c3		 ret	 0
?is_open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::is_open
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 f8	 lea	 esi, DWORD PTR [ecx-8]
  00007	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00009	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000c	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0000f	c7 44 02 f8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00017	50		 push	 eax
  00018	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  0001e	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00023	83 c4 04	 add	 esp, 4
  00026	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0002a	74 09		 je	 SHORT $LN13@scalar@13
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00032	83 c4 04	 add	 esp, 4
$LN13@scalar@13:
  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 f0	 lea	 esi, DWORD PTR [ecx-16]
  00007	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00009	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000c	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  0000f	c7 44 02 f0 00
	00 00 00	 mov	 DWORD PTR [edx+eax-16], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00017	50		 push	 eax
  00018	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  0001e	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00023	83 c4 04	 add	 esp, 4
  00026	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0002a	74 09		 je	 SHORT $LN13@scalar@14
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00032	83 c4 04	 add	 esp, 4
$LN13@scalar@14:
  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@15
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@15:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_iostream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 e8	 lea	 esi, DWORD PTR [ecx-24]
  00007	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00009	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000c	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0000f	c7 44 02 e8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-24], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  00017	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	c7 44 02 f8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00025	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  00028	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002b	c7 44 02 e8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00033	50		 push	 eax
  00034	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  0003a	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0003f	83 c4 04	 add	 esp, 4
  00042	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00046	74 09		 je	 SHORT $LN17@scalar@16
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
$LN17@scalar@16:
  00051	8b c6		 mov	 eax, esi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_iostream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1618 : 		{	// look for [_Ptr, _Ptr + _Count) beginnng at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1619 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1620 : 		if (_Count != 0)
; 1621 : 			_DEBUG_POINTER(_Ptr);
; 1622 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1623 : 
; 1624 : 		if (_Count == 0 && _Off <= this->_Mysize)

  00004	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	85 d2		 test	 edx, edx
  0000f	75 05		 jne	 SHORT $LN6@find
  00011	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]

; 1625 : 			return (_Off);	// null string always matches (if inside string)

  00014	76 76		 jbe	 SHORT $LN7@find
$LN6@find:
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi

; 1626 : 
; 1627 : 		size_type _Nm;
; 1628 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))

  00019	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
  0001c	3b c7		 cmp	 eax, edi
  0001e	73 66		 jae	 SHORT $LN2@find
  00020	2b f8		 sub	 edi, eax
  00022	3b d7		 cmp	 edx, edi
  00024	77 60		 ja	 SHORT $LN2@find

; 1629 : 			{	// room for match, look for it
; 1630 : 			const _Elem *_Uptr, *_Vptr;
; 1631 : 			for (_Nm -= _Count - 1, _Vptr = _Myptr() + _Off;

  00026	be 01 00 00 00	 mov	 esi, 1
  0002b	2b f2		 sub	 esi, edx
  0002d	03 fe		 add	 edi, esi
  0002f	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00033	72 02		 jb	 SHORT $LN11@find
  00035	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN11@find:
  00037	8d 1c 01	 lea	 ebx, DWORD PTR [ecx+eax]

; 1632 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1633 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00040	57		 push	 edi
  00041	51		 push	 ecx
  00042	53		 push	 ebx
  00043	e8 00 00 00 00	 call	 _memchr
  00048	8b f0		 mov	 esi, eax
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	85 f6		 test	 esi, esi
  0004f	74 35		 je	 SHORT $LN2@find
$LL4@find:

; 1634 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)

  00051	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  00054	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00057	52		 push	 edx
  00058	50		 push	 eax
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	85 c0		 test	 eax, eax
  00064	74 2c		 je	 SHORT $LN20@find

; 1632 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1633 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

  00066	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00069	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0006c	2b de		 sub	 ebx, esi
  0006e	8d 7c 1f ff	 lea	 edi, DWORD PTR [edi+ebx-1]
  00072	57		 push	 edi
  00073	52		 push	 edx
  00074	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
  00077	53		 push	 ebx
  00078	e8 00 00 00 00	 call	 _memchr
  0007d	8b f0		 mov	 esi, eax
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	85 f6		 test	 esi, esi
  00084	75 cb		 jne	 SHORT $LL4@find
$LN2@find:
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi

; 1636 : 			}
; 1637 : 
; 1638 : 		return (npos);	// no match

  00088	83 c8 ff	 or	 eax, -1
  0008b	5b		 pop	 ebx
$LN7@find:

; 1639 : 		}

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 0c 00	 ret	 12			; 0000000cH
$LN20@find:

; 1635 : 					return (_Uptr - _Myptr());	// found a match

  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00099	72 02		 jb	 SHORT $LN17@find
  0009b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN17@find:
  0009d	5f		 pop	 edi
  0009e	8b c6		 mov	 eax, esi
  000a0	5e		 pop	 esi
  000a1	2b c1		 sub	 eax, ecx
  000a3	5b		 pop	 ebx

; 1639 : 		}

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 0c 00	 ret	 12			; 0000000cH
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; Function compile flags: /Ogtp
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1888 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1889 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1890 : 		if (_Count != 0)
; 1891 : 			_DEBUG_POINTER(_Ptr);
; 1892 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1893 : 
; 1894 : 		if (this->_Mysize < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 08	 mov	 edi, DWORD PTR __Off$[ebp]
  0000c	3b c7		 cmp	 eax, edi
  0000e	73 0a		 jae	 SHORT $LN2@compare@2

; 1895 : 			_Xran();	// _Off off end

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00015	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@compare@2:
$LN2@compare@2:

; 1896 : 		if (this->_Mysize - _Off < _N0)

  0001a	8b 75 0c	 mov	 esi, DWORD PTR __N0$[ebp]
  0001d	2b c7		 sub	 eax, edi
  0001f	3b c6		 cmp	 eax, esi
  00021	73 02		 jae	 SHORT $LN1@compare@2

; 1897 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size

  00023	8b f0		 mov	 esi, eax
$LN1@compare@2:

; 1898 : 
; 1899 : 		size_type _Ans = _Traits::compare(_Myptr() + _Off, _Ptr,
; 1900 : 			_N0 < _Count ? _N0 : _Count);

  00025	8b 5d 14	 mov	 ebx, DWORD PTR __Count$[ebp]
  00028	8b d6		 mov	 edx, esi
  0002a	3b f3		 cmp	 esi, ebx
  0002c	72 02		 jb	 SHORT $LN6@compare@2
  0002e	8b d3		 mov	 edx, ebx
$LN6@compare@2:
  00030	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00034	72 04		 jb	 SHORT $LN16@compare@2
  00036	8b 01		 mov	 eax, DWORD PTR [ecx]
  00038	eb 02		 jmp	 SHORT $LN17@compare@2
$LN16@compare@2:
  0003a	8b c1		 mov	 eax, ecx
$LN17@compare@2:
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003f	52		 push	 edx
  00040	51		 push	 ecx
  00041	03 c7		 add	 eax, edi
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1901 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 1902 : 			: _N0 == _Count ? 0 : +1);

  0004c	85 c0		 test	 eax, eax
  0004e	75 15		 jne	 SHORT $LN8@compare@2
  00050	3b f3		 cmp	 esi, ebx
  00052	73 0a		 jae	 SHORT $LN7@compare@2
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	83 c8 ff	 or	 eax, -1
  00059	5b		 pop	 ebx

; 1903 : 		}

  0005a	5d		 pop	 ebp
  0005b	c2 10 00	 ret	 16			; 00000010H
$LN7@compare@2:

; 1901 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 1902 : 			: _N0 == _Count ? 0 : +1);

  0005e	33 c0		 xor	 eax, eax
  00060	3b f3		 cmp	 esi, ebx
  00062	0f 95 c0	 setne	 al
$LN8@compare@2:
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx

; 1903 : 		}

  00068	5d		 pop	 ebp
  00069	c2 10 00	 ret	 16			; 00000010H
$LN18@compare@2:
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
; Function compile flags: /Ogtp
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 1906 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1907 : 		return (this->_Alval);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1908 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtp
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1953 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1954 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0000a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000d	72 02		 jb	 SHORT $LN5@Eos
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN5@Eos:
  00011	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1955 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1988 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1989 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 22		 je	 SHORT $LN9@Tidy@3

; 1990 : 			;
; 1991 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 1c		 jb	 SHORT $LN9@Tidy@3

; 1992 : 			{	// copy any leftovers to small buffer and deallocate
; 1993 : 			_Elem *_Ptr = this->_Bx._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 1994 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN7@Tidy@3

; 1995 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@Tidy@3:

; 1996 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

  00028	53		 push	 ebx
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4
  00031	5b		 pop	 ebx
$LN9@Tidy@3:

; 1997 : 			}
; 1998 : 		this->_Myres = this->_BUF_SIZE - 1;
; 1999 : 		_Eos(_Newsize);

  00032	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00035	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0003c	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 2000 : 		}

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 454  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 455  : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 42   : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		ios_base::clear((iostate)(_Mystrbuf == 0
; 44   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

  00003	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00007	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  0000a	75 03		 jne	 SHORT $LN4@clear@2
  0000c	83 c8 04	 or	 eax, 4
$LN4@clear@2:
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Reraise$[ebp]
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 45   : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc, COMDAT
; _this$ = ecx

; 146  : 		return (0 < _Gnavail()
; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 1a		 je	 SHORT $LN3@sbumpc
  00008	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000b	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0000e	7e 12		 jle	 SHORT $LN3@sbumpc
  00010	8b c2		 mov	 eax, edx
  00012	ff 08		 dec	 DWORD PTR [eax]
  00014	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00017	8b 01		 mov	 eax, DWORD PTR [ecx]
  00019	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0001c	89 11		 mov	 DWORD PTR [ecx], edx
  0001e	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 148  : 		}

  00021	c3		 ret	 0
$LN3@sbumpc:

; 146  : 		return (0 < _Gnavail()
; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00027	ff e2		 jmp	 edx
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 556  : 		}

  0000a	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Key
; Function compile flags: /Ogtp
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Key
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator*, COMDAT
; _this$ = ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >, COMDAT
; _this$ = ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 556  : 		}

  0000a	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Key
; Function compile flags: /Ogtp
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Key
; Function compile flags: /Ogtp
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerSection@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerSection@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerSection@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerSection@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; _this$ = ecx

; 641  : 		if (_Mysb::eback() == &_Mychar)

  00000	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00003	8d 41 48	 lea	 eax, DWORD PTR [ecx+72]
  00006	39 02		 cmp	 DWORD PTR [edx], eax
  00008	75 16		 jne	 SHORT $LN6@Reset_back

; 642  : 			_Mysb::setg(_Set_eback, _Set_egptr, _Set_egptr);

  0000a	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  0000d	56		 push	 esi
  0000e	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  00011	89 32		 mov	 DWORD PTR [edx], esi
  00013	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00016	89 02		 mov	 DWORD PTR [edx], eax
  00018	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  0001b	2b c0		 sub	 eax, eax
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	5e		 pop	 esi
$LN6@Reset_back:

; 643  : 		}

  00020	c3		 ret	 0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
PUBLIC	??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ PROC ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*, COMDAT
; _this$ = ecx

; 343  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 344  : 		}

  00002	c3		 ret	 0
??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ENDP ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerRow@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerRow@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerRow@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerRow@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 315  : 		_IGfirst = &_Gfirst;
; 316  : 		_IPfirst = &_Pfirst;
; 317  : 		_IGnext = &_Gnext;

  00000	8d 51 18	 lea	 edx, DWORD PTR [ecx+24]
  00003	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 318  : 		_IPnext = &_Pnext;

  00006	8d 51 1c	 lea	 edx, DWORD PTR [ecx+28]
  00009	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  0000c	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  0000f	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 319  : 		_IGcount = &_Gcount;

  00012	8d 51 28	 lea	 edx, DWORD PTR [ecx+40]
  00015	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00018	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  0001b	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 320  : 		_IPcount = &_Pcount;

  0001e	8d 51 2c	 lea	 edx, DWORD PTR [ecx+44]
  00021	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 321  : 		setp(0, 0);

  00024	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002a	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00033	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00036	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 322  : 		setg(0, 0, 0);

  0003c	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00045	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00048	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0004e	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 323  : 		}

  00057	c3		 ret	 0
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >
_TEXT	ENDS
PUBLIC	??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 325  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 326  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1517 : 		size_type _Num = this->_Alval.max_size();
; 1518 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1519 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lmost
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rmost
; Function compile flags: /Ogtp
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Root
; Function compile flags: /Ogtp
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Root, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Root
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 483  : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
$T163533 = -12						; size = 12
$T163531 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 43		 je	 SHORT $LN1@allocate
  0000f	81 f9 55 55 55
	05		 cmp	 ecx, 89478485		; 05555555H
  00015	77 13		 ja	 SHORT $LN3@allocate
  00017	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0001a	c1 e0 04	 shl	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax
  00028	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  0002a	8d 4d 08	 lea	 ecx, DWORD PTR $T163531[ebp]
  0002d	51		 push	 ecx
  0002e	8d 4d f4	 lea	 ecx, DWORD PTR $T163533[ebp]
  00031	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T163531[ebp], 0
  00038	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003d	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00042	8d 55 f4	 lea	 edx, DWORD PTR $T163533[ebp]
  00045	52		 push	 edx
  00046	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T163533[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lmost
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rmost
; Function compile flags: /Ogtp
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Root
; Function compile flags: /Ogtp
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Root
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 483  : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
$T163587 = -12						; size = 12
$T163585 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 46		 je	 SHORT $LN1@allocate@2
  0000f	81 f9 66 66 66
	06		 cmp	 ecx, 107374182		; 06666666H
  00015	77 16		 ja	 SHORT $LN3@allocate@2
  00017	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 28		 jne	 SHORT $LN1@allocate@2
$LN3@allocate@2:
  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T163585[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T163587[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T163585[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T163587[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T163587[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@2:
$LN1@allocate@2:

; 188  : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN12@allocate@2:
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Root
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Root
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T163632 = -12						; size = 12
$T163624 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 3a		 je	 SHORT $LN1@allocate@3
  0000f	83 f9 ff	 cmp	 ecx, -1
  00012	77 0d		 ja	 SHORT $LN3@allocate@3
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	75 28		 jne	 SHORT $LN1@allocate@3
$LN3@allocate@3:
  00021	8d 45 08	 lea	 eax, DWORD PTR $T163624[ebp]
  00024	50		 push	 eax
  00025	8d 4d f4	 lea	 ecx, DWORD PTR $T163632[ebp]
  00028	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T163624[ebp], 0
  0002f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00034	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00039	8d 4d f4	 lea	 ecx, DWORD PTR $T163632[ebp]
  0003c	51		 push	 ecx
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T163632[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00044	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@3:
$LN1@allocate@3:

; 188  : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN12@allocate@3:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	56		 push	 esi

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
  0000c	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000f	8b 30		 mov	 esi, DWORD PTR [eax]
  00011	80 7e 2d 00	 cmp	 BYTE PTR [esi+45], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0c		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Lrotate:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0b		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003e	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  00040	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate:

; 1775 : 		else
; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	56		 push	 esi

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000c	89 32		 mov	 DWORD PTR [edx], esi

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00011	80 7e 2d 00	 cmp	 BYTE PTR [esi+45], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0d		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN4@Rrotate:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0d		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00041	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00044	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate:

; 1805 : 		else
; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 267  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator++
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	56		 push	 esi

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
  0000c	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000f	8b 30		 mov	 esi, DWORD PTR [eax]
  00011	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate@2

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Lrotate@2:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0c		 jne	 SHORT $LN4@Lrotate@2

; 1772 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Lrotate@2:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0b		 jne	 SHORT $LN2@Lrotate@2

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003e	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  00040	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate@2:

; 1775 : 		else
; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	56		 push	 esi

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000c	89 32		 mov	 DWORD PTR [edx], esi

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00011	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate@2

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Rrotate@2:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0d		 jne	 SHORT $LN4@Rrotate@2

; 1802 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN4@Rrotate@2:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0d		 jne	 SHORT $LN2@Rrotate@2

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00041	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00044	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate@2:

; 1805 : 		else
; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 267  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator!=<char,char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator!=<char,char>, COMDAT

; 271  : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 272  : 	}

  00002	c3		 ret	 0
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator!=<char,char>
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	_Ty _Tmp = _Move(_Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00009	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]
  0000c	8a 16		 mov	 dl, BYTE PTR [esi]
  0000e	88 10		 mov	 BYTE PTR [eax], dl

; 104  : 	_Right = _Move(_Tmp);

  00010	88 0e		 mov	 BYTE PTR [esi], cl
  00012	5e		 pop	 esi

; 105  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T163973 = -16						; size = 12
$T163957 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00007	6a 30		 push	 48			; 00000030H
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 1a		 je	 SHORT $LN5@Buynode

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00024	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00027	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  0002a	66 89 48 2c	 mov	 WORD PTR [eax+44], cx
  0002e	5e		 pop	 esi

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode:
  00033	8d 45 fc	 lea	 eax, DWORD PTR $T163957[ebp]
  00036	89 4d fc	 mov	 DWORD PTR $T163957[ebp], ecx
  00039	50		 push	 eax
  0003a	8d 4d f0	 lea	 ecx, DWORD PTR $T163973[ebp]
  0003d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00042	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00047	8d 4d f0	 lea	 ecx, DWORD PTR $T163973[ebp]
  0004a	51		 push	 ecx
  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T163973[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00052	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode:
$LN26@Buynode:
  00057	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode
; Function compile flags: /Ogtp
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T164027 = -16						; size = 12
$T164010 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00007	6a 28		 push	 40			; 00000028H
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 1a		 je	 SHORT $LN5@Buynode@2

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00024	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00027	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  0002a	66 89 48 24	 mov	 WORD PTR [eax+36], cx
  0002e	5e		 pop	 esi

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode@2:
  00033	8d 45 fc	 lea	 eax, DWORD PTR $T164010[ebp]
  00036	89 4d fc	 mov	 DWORD PTR $T164010[ebp], ecx
  00039	50		 push	 eax
  0003a	8d 4d f0	 lea	 ecx, DWORD PTR $T164027[ebp]
  0003d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00042	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00047	8d 4d f0	 lea	 ecx, DWORD PTR $T164027[ebp]
  0004a	51		 push	 ecx
  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T164027[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00052	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode@2:
$LN26@Buynode@2:
  00057	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >, COMDAT
; _this$ = ecx

; 208  : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 209  : 		}

  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 306  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >, COMDAT
; _this$ = ecx

; 208  : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 209  : 		}

  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >, COMDAT
; _this$ = ecx

; 208  : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 209  : 		}

  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 306  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??_7?$codecvt@DDH@std@@6B@			; std::codecvt<char,char,int>::`vftable'
PUBLIC	??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z	; std::codecvt<char,char,int>::codecvt<char,char,int>
PUBLIC	??_R4?$codecvt@DDH@std@@6B@			; std::codecvt<char,char,int>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$codecvt@DDH@std@@@8			; std::codecvt<char,char,int> `RTTI Type Descriptor'
PUBLIC	??_R3?$codecvt@DDH@std@@8			; std::codecvt<char,char,int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$codecvt@DDH@std@@8			; std::codecvt<char,char,int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$codecvt@DDH@std@@8		; std::codecvt<char,char,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::do_in
PUBLIC	?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::do_out
PUBLIC	?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z ; std::codecvt<char,char,int>::do_unshift
PUBLIC	?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z	; std::codecvt<char,char,int>::do_length
EXTRN	??_E?$codecvt@DDH@std@@MAEPAXI@Z:PROC		; std::codecvt<char,char,int>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$codecvt@DDH@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
rdata$r	SEGMENT
??_R1A@?0A@EA@?$codecvt@DDH@std@@8 DD FLAT:??_R0?AV?$codecvt@DDH@std@@@8 ; std::codecvt<char,char,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$codecvt@DDH@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$codecvt@DDH@std@@8
rdata$r	SEGMENT
??_R2?$codecvt@DDH@std@@8 DD FLAT:??_R1A@?0A@EA@?$codecvt@DDH@std@@8 ; std::codecvt<char,char,int>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@codecvt_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$codecvt@DDH@std@@8
rdata$r	SEGMENT
??_R3?$codecvt@DDH@std@@8 DD 00H			; std::codecvt<char,char,int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$codecvt@DDH@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$codecvt@DDH@std@@@8
_DATA	SEGMENT
??_R0?AV?$codecvt@DDH@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::codecvt<char,char,int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$codecvt@DDH@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$codecvt@DDH@std@@6B@
rdata$r	SEGMENT
??_R4?$codecvt@DDH@std@@6B@ DD 00H			; std::codecvt<char,char,int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$codecvt@DDH@std@@@8
	DD	FLAT:??_R3?$codecvt@DDH@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$codecvt@DDH@std@@6B@
CONST	SEGMENT
??_7?$codecvt@DDH@std@@6B@ DD FLAT:??_R4?$codecvt@DDH@std@@6B@ ; std::codecvt<char,char,int>::`vftable'
	DD	FLAT:??_E?$codecvt@DDH@std@@MAEPAXI@Z
	DD	FLAT:?do_always_noconv@codecvt_base@std@@MBE_NXZ
	DD	FLAT:?do_max_length@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_encoding@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
	DD	FLAT:?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
	DD	FLAT:?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z
	DD	FLAT:?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z PROC	; std::codecvt<char,char,int>::codecvt<char,char,int>, COMDAT
; _this$ = ecx

; 843  : 		{	// construct from specified locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 0c	 mov	 ecx, DWORD PTR __Refs$[ebp]
  00008	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$codecvt@DDH@std@@6B@

; 844  : 		_Init(_Lobj);
; 845  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z ENDP	; std::codecvt<char,char,int>::codecvt<char,char,int>
_TEXT	ENDS
PUBLIC	??1?$codecvt@DDH@std@@MAE@XZ			; std::codecvt<char,char,int>::~codecvt<char,char,int>
; Function compile flags: /Ogtp
;	COMDAT ??1?$codecvt@DDH@std@@MAE@XZ
_TEXT	SEGMENT
??1?$codecvt@DDH@std@@MAE@XZ PROC			; std::codecvt<char,char,int>::~codecvt<char,char,int>, COMDAT
; _this$ = ecx

; 859  : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00006	c3		 ret	 0
??1?$codecvt@DDH@std@@MAE@XZ ENDP			; std::codecvt<char,char,int>::~codecvt<char,char,int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
___formal$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,int>::do_in, COMDAT
; _this$ = ecx

; 868  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 869  : 		_Mid1 = _First1, _Mid2 = _First2;

  00003	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __First1$[ebp]
  00009	8b 55 20	 mov	 edx, DWORD PTR __Mid2$[ebp]
  0000c	89 08		 mov	 DWORD PTR [eax], ecx
  0000e	8b 45 18	 mov	 eax, DWORD PTR __First2$[ebp]
  00011	89 02		 mov	 DWORD PTR [edx], eax

; 870  : 		return (noconv);	// convert nothing

  00013	b8 03 00 00 00	 mov	 eax, 3

; 871  : 		}

  00018	5d		 pop	 ebp
  00019	c2 1c 00	 ret	 28			; 0000001cH
?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::do_in
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
___formal$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,int>::do_out, COMDAT
; _this$ = ecx

; 876  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 877  : 		_Mid1 = _First1, _Mid2 = _First2;

  00003	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __First1$[ebp]
  00009	8b 55 20	 mov	 edx, DWORD PTR __Mid2$[ebp]
  0000c	89 08		 mov	 DWORD PTR [eax], ecx
  0000e	8b 45 18	 mov	 eax, DWORD PTR __First2$[ebp]
  00011	89 02		 mov	 DWORD PTR [edx], eax

; 878  : 		return (noconv);	// convert nothing

  00013	b8 03 00 00 00	 mov	 eax, 3

; 879  : 		}

  00018	5d		 pop	 ebp
  00019	c2 1c 00	 ret	 28			; 0000001cH
?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::do_out
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First2$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid2$ = 20						; size = 4
?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z PROC	; std::codecvt<char,char,int>::do_unshift, COMDAT
; _this$ = ecx

; 883  : 		{	// generate bytes to return to default shift state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 884  : 		_Mid2 = _First2;

  00003	8b 45 14	 mov	 eax, DWORD PTR __Mid2$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 885  : 		return (noconv);	// convert nothing

  0000b	b8 03 00 00 00	 mov	 eax, 3

; 886  : 		}

  00010	5d		 pop	 ebp
  00011	c2 10 00	 ret	 16			; 00000010H
?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z ENDP	; std::codecvt<char,char,int>::do_unshift
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Count$ = 20						; size = 4
?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z PROC	; std::codecvt<char,char,int>::do_length, COMDAT
; _this$ = ecx

; 890  : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 891  : 		return ((int)(_Count < (size_t)(_Last1 - _First1)
; 892  : 			? _Count : _Last1 - _First1));	// assume 1-to-1 conversion

  00003	8b 45 10	 mov	 eax, DWORD PTR __Last1$[ebp]
  00006	2b 45 0c	 sub	 eax, DWORD PTR __First1$[ebp]
  00009	8b 4d 14	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000c	3b c8		 cmp	 ecx, eax
  0000e	73 02		 jae	 SHORT $LN4@do_length
  00010	8b c1		 mov	 eax, ecx
$LN4@do_length:

; 893  : 		}

  00012	5d		 pop	 ebp
  00013	c2 10 00	 ret	 16			; 00000010H
?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z ENDP	; std::codecvt<char,char,int>::do_length
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@DDH@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$codecvt@DDH@std@@MAEPAXI@Z PROC			; std::codecvt<char,char,int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00010	74 09		 je	 SHORT $LN10@scalar@17
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN10@scalar@17:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$codecvt@DDH@std@@MAEPAXI@Z ENDP			; std::codecvt<char,char,int>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_size, COMDAT
; _this$ = ecx

; 874  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_size
_TEXT	ENDS
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 419  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 421  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator--
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::max_size, COMDAT
; _this$ = ecx

; 874  : 		return (this->_Alval.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::max_size, COMDAT
; _this$ = ecx

; 874  : 		return (this->_Alval.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	56		 push	 esi

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
  0000c	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000f	8b 30		 mov	 esi, DWORD PTR [eax]
  00011	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate@3

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Lrotate@3:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0c		 jne	 SHORT $LN4@Lrotate@3

; 1772 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Lrotate@3:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0b		 jne	 SHORT $LN2@Lrotate@3

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003e	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  00040	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate@3:

; 1775 : 		else
; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	56		 push	 esi

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000c	89 32		 mov	 DWORD PTR [edx], esi

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00011	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate@3

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Rrotate@3:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0d		 jne	 SHORT $LN4@Rrotate@3

; 1802 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN4@Rrotate@3:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0d		 jne	 SHORT $LN2@Rrotate@3

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00041	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00044	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate@3:

; 1805 : 		else
; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 10		 mov	 edx, DWORD PTR [eax]
  00004	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00008	75 40		 jne	 SHORT $LN3@operator@6

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0000d	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00011	75 1a		 jne	 SHORT $LN34@operator@6

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00019	75 0f		 jne	 SHORT $LN17@operator@6
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator@6:
  00020	8b ca		 mov	 ecx, edx
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00028	74 f6		 je	 SHORT $LL18@operator@6
$LN17@operator@6:
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0002c	c3		 ret	 0
$LN34@operator@6:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00030	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00034	75 12		 jne	 SHORT $LN1@operator@6
$LL2@operator@6:
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0003b	75 0b		 jne	 SHORT $LN1@operator@6

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003d	89 10		 mov	 DWORD PTR [eax], edx
  0003f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00042	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00046	74 ee		 je	 SHORT $LL2@operator@6
$LN1@operator@6:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00048	89 10		 mov	 DWORD PTR [eax], edx
$LN3@operator@6:

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0004a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00008	74 06		 je	 SHORT $LN8@operator@7

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0000f	c3		 ret	 0
$LN8@operator@7:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00016	75 17		 jne	 SHORT $LN40@operator@7

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  00018	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001b	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0001f	75 30		 jne	 SHORT $LN21@operator@7
$LL22@operator@7:
  00021	8b d1		 mov	 edx, ecx
  00023	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00026	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0002a	74 f5		 je	 SHORT $LL22@operator@7

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0002e	c3		 ret	 0
$LN40@operator@7:

; 89   : 		else
; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00036	75 11		 jne	 SHORT $LN3@operator@7
$LL4@operator@7:
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0003c	75 0b		 jne	 SHORT $LN3@operator@7

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  0003e	89 10		 mov	 DWORD PTR [eax], edx
  00040	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00043	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00047	74 ef		 je	 SHORT $LL4@operator@7
$LN3@operator@7:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0004f	75 02		 jne	 SHORT $LN1@operator@7

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

$LN21@operator@7:

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00051	89 10		 mov	 DWORD PTR [eax], edx
$LN1@operator@7:

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00053	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 419  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 421  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 146  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 146  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 146  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
$T164531 = -12						; size = 12
$T164523 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 46		 je	 SHORT $LN1@allocate@4
  0000f	81 f9 66 66 66
	06		 cmp	 ecx, 107374182		; 06666666H
  00015	77 16		 ja	 SHORT $LN3@allocate@4
  00017	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 28		 jne	 SHORT $LN1@allocate@4
$LN3@allocate@4:
  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T164523[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T164531[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T164523[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T164531[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T164531[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@4:
$LN1@allocate@4:

; 188  : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN12@allocate@4:
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?SetState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SetState
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\bloodcastle.cpp
;	COMDAT ?SetState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_iBC_STATE$ = 12					; size = 4
?SetState@CBloodCastle@@QAEXHH@Z PROC			; CBloodCastle::SetState, COMDAT
; _this$ = ecx

; 413  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 414  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 52		 js	 SHORT $LN7@SetState
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	74 46		 je	 SHORT $LN7@SetState

; 415  : 	{
; 416  : 		return;
; 417  : 	}
; 418  : 
; 419  : 	if ( iBC_STATE < BC_STATE_NONE || iBC_STATE > BC_STATE_PLAYEND )

  00016	8b 55 0c	 mov	 edx, DWORD PTR _iBC_STATE$[ebp]
  00019	83 fa 03	 cmp	 edx, 3
  0001c	77 3e		 ja	 SHORT $LN7@SetState

; 420  : 	{
; 421  : 		return;
; 422  : 	}
; 423  : 
; 424  : 	this->m_BridgeData[iBridgeIndex].m_iBC_STATE = iBC_STATE;

  0001e	56		 push	 esi
  0001f	8b f0		 mov	 esi, eax
  00021	c1 e6 09	 shl	 esi, 9
  00024	89 94 0e 50 01
	00 00		 mov	 DWORD PTR [esi+ecx+336], edx
  0002b	5e		 pop	 esi

; 425  : 
; 426  : 	switch ( this->m_BridgeData[iBridgeIndex].m_iBC_STATE )

  0002c	83 fa 03	 cmp	 edx, 3
  0002f	77 2b		 ja	 SHORT $LN7@SetState
  00031	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN14@SetState[edx*4]
$LN4@SetState:

; 427  : 	{
; 428  : 		case BC_STATE_NONE:
; 429  : 			this->SetState_None(iBridgeIndex);

  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?SetState_None@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_None

; 442  : 			break;
; 443  : 	}
; 444  : }

  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN3@SetState:

; 430  : 			break;
; 431  : 
; 432  : 		case BC_STATE_CLOSED:
; 433  : 			this->SetState_Closed(iBridgeIndex);

  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?SetState_Closed@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_Closed

; 442  : 			break;
; 443  : 	}
; 444  : }

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN2@SetState:

; 434  : 			break;
; 435  : 
; 436  : 		case BC_STATE_PLAYING:
; 437  : 			this->SetState_Playing(iBridgeIndex);

  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?SetState_Playing@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_Playing

; 442  : 			break;
; 443  : 	}
; 444  : }

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN1@SetState:

; 438  : 			break;
; 439  : 
; 440  : 		case BC_STATE_PLAYEND:
; 441  : 			this->SetState_PlayEnd(iBridgeIndex);

  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?SetState_PlayEnd@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_PlayEnd
$LN7@SetState:

; 442  : 			break;
; 443  : 	}
; 444  : }

  0005c	5d		 pop	 ebp
  0005d	c2 08 00	 ret	 8
$LN14@SetState:
  00060	00 00 00 00	 DD	 $LN4@SetState
  00064	00 00 00 00	 DD	 $LN3@SetState
  00068	00 00 00 00	 DD	 $LN2@SetState
  0006c	00 00 00 00	 DD	 $LN1@SetState
?SetState@CBloodCastle@@QAEXHH@Z ENDP			; CBloodCastle::SetState
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	_iBridgeIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ProcState_Closed@CBloodCastle@@IAEXH@Z		; CBloodCastle::ProcState_Closed
; Function compile flags: /Ogtp
;	COMDAT ?ProcState_Closed@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -288					; size = 4
_pMsg$157396 = -284					; size = 4
_iBridgeIndex$GSCopy$ = -280				; size = 4
_pNotice$157392 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_Closed@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_Closed, COMDAT
; _this$ = ecx

; 504  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b d9		 mov	 ebx, ecx

; 543  : 
; 544  : 					for (int i= OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  0001a	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iBridgeIndex$GSCopy$[ebp], eax
  00020	57		 push	 edi
  00021	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  00027	c1 e0 09	 shl	 eax, 9
  0002a	89 9d e0 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ebx
  00030	8d 34 18	 lea	 esi, DWORD PTR [eax+ebx]
  00033	ff d7		 call	 edi
  00035	2b 86 58 01 00
	00		 sub	 eax, DWORD PTR [esi+344]
  0003b	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00040	0f 8c 80 01 00
	00		 jl	 $LN32@ProcState_

; 505  : 	int iTICK_MSEC = GetTickCount() - this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT;
; 506  : 
; 507  : 	if ( iTICK_MSEC >= 1000 )
; 508  : 	{
; 509  : 		this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;
; 510  : 		this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  00046	29 86 54 01 00
	00		 sub	 DWORD PTR [esi+340], eax
  0004c	ff d7		 call	 edi
  0004e	89 86 58 01 00
	00		 mov	 DWORD PTR [esi+344], eax

; 511  : 
; 512  : 		if ( g_bBloodCastle != FALSE )

  00054	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bBloodCastle@@3HA, 0 ; g_bBloodCastle
  0005b	0f 84 65 01 00
	00		 je	 $LN32@ProcState_

; 513  : 		{
; 514  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER == false)

  00061	8b 83 08 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3592]
  00067	8b 8e 54 01 00
	00		 mov	 ecx, DWORD PTR [esi+340]
  0006d	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  00073	3b c8		 cmp	 ecx, eax
  00075	7f 12		 jg	 SHORT $LN14@ProcState_
  00077	80 be 63 01 00
	00 00		 cmp	 BYTE PTR [esi+355], 0
  0007e	75 09		 jne	 SHORT $LN14@ProcState_

; 515  : 			{
; 516  : 				this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = true;

  00080	66 c7 86 63 01
	00 00 01 01	 mov	 WORD PTR [esi+355], 257	; 00000101H
$LN14@ProcState_:

; 517  : 				this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = true;
; 518  : 			}
; 519  : 
; 520  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && (this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC/60000) !=this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT)

  00089	8b 93 08 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3592]
  0008f	69 d2 60 ea 00
	00		 imul	 edx, 60000		; 0000ea60H
  00095	3b ca		 cmp	 ecx, edx
  00097	7f 6b		 jg	 SHORT $LN27@ProcState_
  00099	85 c9		 test	 ecx, ecx
  0009b	7e 67		 jle	 SHORT $LN27@ProcState_
  0009d	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  000a2	f7 e9		 imul	 ecx
  000a4	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  000a7	8b c2		 mov	 eax, edx
  000a9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ac	03 c2		 add	 eax, edx
  000ae	3b 86 5c 01 00
	00		 cmp	 eax, DWORD PTR [esi+348]
  000b4	74 4e		 je	 SHORT $LN27@ProcState_

; 521  : 			{
; 522  : 				this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 60000;
; 523  : 
; 524  : 				if ( iBridgeIndex == 0 )

  000b6	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _iBridgeIndex$GSCopy$[ebp], 0
  000bd	89 86 5c 01 00
	00		 mov	 DWORD PTR [esi+348], eax
  000c3	75 3f		 jne	 SHORT $LN27@ProcState_

; 525  : 				{
; 526  : 					PMSG_NOTICE pNotice;
; 527  : 
; 528  : 					TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get( MSGGET(4, 136)), this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT+1);

  000c5	8b 83 5c 01 00
	00		 mov	 eax, DWORD PTR [ebx+348]
  000cb	40		 inc	 eax
  000cc	50		 push	 eax
  000cd	68 88 04 00 00	 push	 1160			; 00000488H
  000d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000d7	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000dc	50		 push	 eax
  000dd	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$157392[ebp]
  000e3	6a 00		 push	 0
  000e5	51		 push	 ecx
  000e6	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 529  : 					this->SendAllUserAnyMsg((BYTE *)&pNotice, pNotice.h.size);

  000eb	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$157392[ebp+1]
  000f2	83 c4 10	 add	 esp, 16			; 00000010H
  000f5	52		 push	 edx
  000f6	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$157392[ebp]
  000fc	50		 push	 eax
  000fd	8b cb		 mov	 ecx, ebx
  000ff	e8 00 00 00 00	 call	 ?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z ; CBloodCastle::SendAllUserAnyMsg
$LN27@ProcState_:

; 530  : 				}
; 531  : 			}
; 532  : 
; 533  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30000 && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER == false )

  00104	8b 86 54 01 00
	00		 mov	 eax, DWORD PTR [esi+340]
  0010a	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  0010f	0f 8f b1 00 00
	00		 jg	 $LN32@ProcState_
  00115	85 c0		 test	 eax, eax
  00117	0f 8e a9 00 00
	00		 jle	 $LN32@ProcState_
  0011d	80 be 67 01 00
	00 00		 cmp	 BYTE PTR [esi+359], 0
  00124	0f 85 9c 00 00
	00		 jne	 $LN32@ProcState_

; 534  : 			{
; 535  : 				this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER = true;
; 536  : 
; 537  : 				if ( iBridgeIndex == 0 )

  0012a	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _iBridgeIndex$GSCopy$[ebp], 0
  00131	c6 86 67 01 00
	00 01		 mov	 BYTE PTR [esi+359], 1
  00138	0f 85 88 00 00
	00		 jne	 $LN32@ProcState_

; 538  : 				{
; 539  : 					PMSG_SET_DEVILSQUARE pMsg;
; 540  : 
; 541  : 					PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  0013e	6a 04		 push	 4
  00140	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$157396[ebp]
  00146	68 92 00 00 00	 push	 146			; 00000092H
  0014b	51		 push	 ecx
  0014c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00151	83 c4 0c	 add	 esp, 12			; 0000000cH

; 542  : 					pMsg.Type = 3;

  00154	c6 85 e7 fe ff
	ff 03		 mov	 BYTE PTR _pMsg$157396[ebp+3], 3

; 543  : 
; 544  : 					for (int i= OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  0015b	bb 00 19 00 00	 mov	 ebx, 6400		; 00001900H
  00160	bf 09 c5 16 02	 mov	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+35046665
$LL9@ProcState_:

; 545  : 					{
; 546  : 						if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)

  00165	80 bf fb fe ff
	ff 03		 cmp	 BYTE PTR [edi-261], 3
  0016c	75 43		 jne	 SHORT $LN8@ProcState_
  0016e	66 83 bf 57 ff
	ff ff 01	 cmp	 WORD PTR [edi-169], 1
  00176	75 39		 jne	 SHORT $LN8@ProcState_

; 547  : 						{
; 548  : 							if ( BC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  00178	8a 0f		 mov	 cl, BYTE PTR [edi]
  0017a	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0017d	72 09		 jb	 SHORT $LN30@ProcState_
  0017f	b2 11		 mov	 dl, 17			; 00000011H
  00181	3a d1		 cmp	 dl, cl
  00183	1b c0		 sbb	 eax, eax
  00185	40		 inc	 eax
  00186	75 29		 jne	 SHORT $LN8@ProcState_
$LN30@ProcState_:

; 549  : 							{
; 550  : 								if ( CC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  00188	80 f9 12	 cmp	 cl, 18			; 00000012H
  0018b	72 0c		 jb	 SHORT $LN26@ProcState_
  0018d	b8 17 00 00 00	 mov	 eax, 23			; 00000017H
  00192	3a c1		 cmp	 al, cl
  00194	1b c0		 sbb	 eax, eax
  00196	40		 inc	 eax
  00197	75 18		 jne	 SHORT $LN8@ProcState_
$LN26@ProcState_:

; 551  : 								{
; 552  : 									DataSend(i, (UCHAR*)&pMsg, pMsg.h.size);

  00199	0f b6 8d e5 fe
	ff ff		 movzx	 ecx, BYTE PTR _pMsg$157396[ebp+1]
  001a0	51		 push	 ecx
  001a1	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$157396[ebp]
  001a7	52		 push	 edx
  001a8	53		 push	 ebx
  001a9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001ae	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@ProcState_:

; 543  : 
; 544  : 					for (int i= OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  001b1	81 c7 64 15 00
	00		 add	 edi, 5476		; 00001564H
  001b7	43		 inc	 ebx
  001b8	81 ff a9 53 6a
	02		 cmp	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A+40522665
  001be	7c a5		 jl	 SHORT $LL9@ProcState_
  001c0	8b 9d e0 fe ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
$LN32@ProcState_:

; 553  : 								}
; 554  : 							}
; 555  : 						}
; 556  : 					}
; 557  : 				}
; 558  : 			}
; 559  : 		}
; 560  : 	}
; 561  : 
; 562  : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0 )

  001c6	83 be 54 01 00
	00 00		 cmp	 DWORD PTR [esi+340], 0
  001cd	7f 24		 jg	 SHORT $LN1@ProcState_

; 563  : 	{
; 564  : 		if ( g_bBloodCastle != FALSE )

  001cf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bBloodCastle@@3HA, 0 ; g_bBloodCastle
  001d6	74 0b		 je	 SHORT $LN2@ProcState_

; 565  : 		{
; 566  : 			this->SetState(iBridgeIndex, BC_STATE_PLAYING);

  001d8	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _iBridgeIndex$GSCopy$[ebp]
  001de	6a 02		 push	 2
  001e0	50		 push	 eax

; 567  : 		}
; 568  : 		else

  001e1	eb 09		 jmp	 SHORT $LN34@ProcState_
$LN2@ProcState_:

; 569  : 		{
; 570  : 			this->SetState(iBridgeIndex, BC_STATE_CLOSED);

  001e3	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iBridgeIndex$GSCopy$[ebp]
  001e9	6a 01		 push	 1
  001eb	51		 push	 ecx
$LN34@ProcState_:
  001ec	8b cb		 mov	 ecx, ebx
  001ee	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN1@ProcState_:

; 571  : 		}
; 572  : 	}
; 573  : }

  001f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f6	5f		 pop	 edi
  001f7	5e		 pop	 esi
  001f8	33 cd		 xor	 ecx, ebp
  001fa	5b		 pop	 ebx
  001fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c2 04 00	 ret	 4
?ProcState_Closed@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_Closed
_TEXT	ENDS
PUBLIC	??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@ ; `string'
PUBLIC	??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@ ; `string'
PUBLIC	??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ProcState_Playing@CBloodCastle@@IAEXH@Z	; CBloodCastle::ProcState_Playing
;	COMDAT ??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Failed -> Time Out', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@
CONST	SEGMENT
??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@ DB '['
	DB	'Blood Castle] (%d) CheckWinnerValid(iBridgeIndex) == false', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@
CONST	SEGMENT
??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@ DB '['
	DB	'Blood Castle] (%d) CheckWinnerPartyComplete(iBridgeIndex) == '
	DB	'true', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Failed -> Every User Ou'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy '
	DB	'Saint Status [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy '
	DB	'Castle Door [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Start', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@
CONST	SEGMENT
??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@ DB '['
	DB	'Blood Castle] (%d) Bridge Change Bridge Attribute -> Open', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ProcState_Playing@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_pMsg$157430 = -280					; size = 4
_pMsg$157417 = -280					; size = 4
_pNotice$157434 = -276					; size = 272
_pNotice$157425 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_Playing@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_Playing, COMDAT
; _this$ = ecx

; 581  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]

; 582  : 	int iTICK_MSEC = GetTickCount() - this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT;

  00019	8b f7		 mov	 esi, edi
  0001b	8b d9		 mov	 ebx, ecx
  0001d	c1 e6 09	 shl	 esi, 9
  00020	03 f3		 add	 esi, ebx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00028	2b 86 58 01 00
	00		 sub	 eax, DWORD PTR [esi+344]

; 583  : 
; 584  : 	if ( iTICK_MSEC >= 1000 )

  0002e	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00033	0f 8c 27 03 00
	00		 jl	 $LN3@ProcState_@2

; 585  : 	{
; 586  : 		this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;

  00039	29 86 54 01 00
	00		 sub	 DWORD PTR [esi+340], eax

; 587  : 		this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00045	89 86 58 01 00
	00		 mov	 DWORD PTR [esi+344], eax

; 588  : 
; 589  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ((this->m_iBC_TIME_MIN_PLAY*60-30)*1000) )

  0004b	8b 8b 0c 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3596]
  00051	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H
  00057	81 e9 30 75 00
	00		 sub	 ecx, 30000		; 00007530H
  0005d	39 8e 54 01 00
	00		 cmp	 DWORD PTR [esi+340], ecx
  00063	7f 3e		 jg	 SHORT $LN18@ProcState_@2

; 590  : 		{
; 591  : 			if ( this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY == false )

  00065	80 be 68 01 00
	00 00		 cmp	 BYTE PTR [esi+360], 0
  0006c	75 35		 jne	 SHORT $LN18@ProcState_@2

; 592  : 			{
; 593  : 				this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY = true;
; 594  : 				
; 595  : 				PMSG_SET_DEVILSQUARE pMsg;
; 596  : 				PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  0006e	6a 04		 push	 4
  00070	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$157417[ebp]
  00076	68 92 00 00 00	 push	 146			; 00000092H
  0007b	52		 push	 edx
  0007c	c6 86 68 01 00
	00 01		 mov	 BYTE PTR [esi+360], 1
  00083	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH

; 597  : 				pMsg.Type = 4;
; 598  : 				this->SendBridgeAnyMsg((BYTE*)&pMsg, sizeof(pMsg), iBridgeIndex);

  0008b	57		 push	 edi
  0008c	6a 04		 push	 4
  0008e	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$157417[ebp]
  00094	50		 push	 eax
  00095	8b cb		 mov	 ecx, ebx
  00097	c6 85 eb fe ff
	ff 04		 mov	 BYTE PTR _pMsg$157417[ebp+3], 4
  0009e	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN18@ProcState_@2:

; 599  : 			}
; 600  : 		}
; 601  : 
; 602  : 		if ( this->m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE != false	)

  000a3	80 be 60 01 00
	00 00		 cmp	 BYTE PTR [esi+352], 0
  000aa	74 46		 je	 SHORT $LN23@ProcState_@2

; 603  : 		{
; 604  : 			if ( this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN != -1 )

  000ac	83 be 80 01 00
	00 ff		 cmp	 DWORD PTR [esi+384], -1
  000b3	74 3d		 je	 SHORT $LN23@ProcState_@2

; 605  : 			{
; 606  : 				if ( GetTickCount() > this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN )

  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000bb	3b 86 80 01 00
	00		 cmp	 eax, DWORD PTR [esi+384]
  000c1	76 2f		 jbe	 SHORT $LN23@ProcState_@2

; 607  : 				{
; 608  : 					this->ReleaseCastleBridge(iBridgeIndex);

  000c3	57		 push	 edi
  000c4	8b cb		 mov	 ecx, ebx
  000c6	e8 00 00 00 00	 call	 ?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleBridge

; 609  : 					this->SendCastleBridgeBlockInfo(iBridgeIndex, 0);

  000cb	6a 00		 push	 0
  000cd	57		 push	 edi
  000ce	8b cb		 mov	 ecx, ebx
  000d0	e8 00 00 00 00	 call	 ?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleBridgeBlockInfo

; 610  : 					LogAdd(LOG_BLACK, "[Blood Castle] (%d) Bridge Change Bridge Attribute -> Open", iBridgeIndex+1);

  000d5	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  000d8	51		 push	 ecx
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@
  000de	6a 00		 push	 0
  000e0	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 611  : 					this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN = -1; // Prevent multiple openings

  000e8	c7 86 80 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+384], -1
$LN23@ProcState_@2:

; 612  : 				}
; 613  : 			}
; 614  : 		}
; 615  : 
; 616  : 		// Set Play Quest
; 617  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ((this->m_iBC_TIME_MIN_PLAY*60-60)*1000) && this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START == false )

  000f2	8b 83 0c 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3596]
  000f8	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  000fe	8d 90 a0 15 ff
	ff		 lea	 edx, DWORD PTR [eax-60000]
  00104	39 96 54 01 00
	00		 cmp	 DWORD PTR [esi+340], edx
  0010a	0f 8f 94 00 00
	00		 jg	 $LN14@ProcState_@2
  00110	80 be 65 01 00
	00 00		 cmp	 BYTE PTR [esi+357], 0
  00117	0f 85 87 00 00
	00		 jne	 $LN14@ProcState_@2

; 618  : 		{
; 619  : 			PMSG_NOTICE pNotice;
; 620  : 
; 621  : 			this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (this->m_iBC_TIME_MIN_PLAY*60)*1000;

  0011d	89 86 54 01 00
	00		 mov	 DWORD PTR [esi+340], eax

; 622  : 			this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = false;
; 623  : 			TNotice::MakeNoticeMsgEx((TNotice*)&pNotice, 0, lMsg.Get(MSGGET(4, 137)), iBridgeIndex+1);

  00123	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00126	50		 push	 eax
  00127	68 89 04 00 00	 push	 1161			; 00000489H
  0012c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00131	c6 86 64 01 00
	00 00		 mov	 BYTE PTR [esi+356], 0
  00138	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0013d	50		 push	 eax
  0013e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$157425[ebp]
  00144	6a 00		 push	 0
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 624  : 			this->SendBridgeAnyMsg( (LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  0014c	0f b6 8d ed fe
	ff ff		 movzx	 ecx, BYTE PTR _pNotice$157425[ebp+1]
  00153	83 c4 10	 add	 esp, 16			; 00000010H
  00156	57		 push	 edi
  00157	51		 push	 ecx
  00158	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$157425[ebp]
  0015e	52		 push	 edx
  0015f	8b cb		 mov	 ecx, ebx
  00161	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 625  : 			this->ReleaseCastleEntrance(iBridgeIndex);

  00166	57		 push	 edi
  00167	8b cb		 mov	 ecx, ebx
  00169	e8 00 00 00 00	 call	 ?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleEntrance

; 626  : 			this->SendCastleEntranceBlockInfo(iBridgeIndex, 0);

  0016e	6a 00		 push	 0
  00170	57		 push	 edi
  00171	8b cb		 mov	 ecx, ebx
  00173	e8 00 00 00 00	 call	 ?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleEntranceBlockInfo

; 627  : 			this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START = true;
; 628  : 			this->SetMonster(iBridgeIndex);

  00178	57		 push	 edi
  00179	8b cb		 mov	 ecx, ebx
  0017b	c6 86 65 01 00
	00 01		 mov	 BYTE PTR [esi+357], 1
  00182	e8 00 00 00 00	 call	 ?SetMonster@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetMonster

; 629  : 			this->SendNoticeState(iBridgeIndex, false);

  00187	6a 00		 push	 0
  00189	57		 push	 edi
  0018a	8b cb		 mov	 ecx, ebx
  0018c	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 630  : 
; 631  : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) Blood Castle Quest Start", iBridgeIndex+1);

  00191	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00194	50		 push	 eax
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  0019a	6a 00		 push	 0
  0019c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@ProcState_@2:

; 632  : 		}
; 633  : 
; 634  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30000 && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END == false)	// Set counter to kick

  001a4	8b 86 54 01 00
	00		 mov	 eax, DWORD PTR [esi+340]
  001aa	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  001af	7f 42		 jg	 SHORT $LN13@ProcState_@2
  001b1	85 c0		 test	 eax, eax
  001b3	7e 3e		 jle	 SHORT $LN13@ProcState_@2
  001b5	80 be 69 01 00
	00 00		 cmp	 BYTE PTR [esi+361], 0
  001bc	75 35		 jne	 SHORT $LN13@ProcState_@2

; 635  : 		{
; 636  : 			this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END = true;
; 637  : 			PMSG_SET_DEVILSQUARE pMsg;
; 638  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  001be	6a 04		 push	 4
  001c0	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$157430[ebp]
  001c6	68 92 00 00 00	 push	 146			; 00000092H
  001cb	50		 push	 eax
  001cc	c6 86 69 01 00
	00 01		 mov	 BYTE PTR [esi+361], 1
  001d3	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  001d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 639  : 			pMsg.Type = 5;
; 640  : 			this->SendBridgeAnyMsg((BYTE *)&pMsg, sizeof(pMsg), iBridgeIndex);

  001db	57		 push	 edi
  001dc	6a 04		 push	 4
  001de	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$157430[ebp]
  001e4	51		 push	 ecx
  001e5	8b cb		 mov	 ecx, ebx
  001e7	c6 85 eb fe ff
	ff 05		 mov	 BYTE PTR _pMsg$157430[ebp+3], 5
  001ee	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN13@ProcState_@2:

; 641  : 		}
; 642  : 
; 643  : 		if ( this->CheckEveryUserDie(iBridgeIndex) != false )

  001f3	57		 push	 edi
  001f4	8b cb		 mov	 ecx, ebx
  001f6	e8 00 00 00 00	 call	 ?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckEveryUserDie
  001fb	84 c0		 test	 al, al
  001fd	0f 84 9e 00 00
	00		 je	 $LN12@ProcState_@2

; 644  : 		{
; 645  : 			PMSG_NOTICE pNotice;
; 646  : 
; 647  : 			TNotice::MakeNoticeMsg(&pNotice, 0, lMsg.Get(MSGGET(4, 138)));

  00203	68 8a 04 00 00	 push	 1162			; 0000048aH
  00208	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0020d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00212	50		 push	 eax
  00213	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$157434[ebp]
  00219	6a 00		 push	 0
  0021b	52		 push	 edx
  0021c	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 648  : 			this->SendBridgeAnyMsg( (LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  00221	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$157434[ebp+1]
  00228	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022b	57		 push	 edi
  0022c	50		 push	 eax
  0022d	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$157434[ebp]
  00233	51		 push	 ecx
  00234	8b cb		 mov	 ecx, ebx
  00236	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 649  : 
; 650  : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Castle Door [%s][%s]",
; 651  : 				iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID,
; 652  : 				this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName);

  0023b	8d 96 b3 01 00
	00		 lea	 edx, DWORD PTR [esi+435]
  00241	52		 push	 edx
  00242	8d 86 a8 01 00
	00		 lea	 eax, DWORD PTR [esi+424]
  00248	50		 push	 eax
  00249	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0024c	51		 push	 ecx
  0024d	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  00252	6a 00		 push	 0
  00254	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 653  : 
; 654  : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Saint Status [%s][%s]",
; 655  : 				iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID,
; 656  : 				this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName);

  00259	8d 86 c8 01 00
	00		 lea	 eax, DWORD PTR [esi+456]
  0025f	50		 push	 eax
  00260	8d 86 a8 01 00
	00		 lea	 eax, DWORD PTR [esi+424]
  00266	50		 push	 eax
  00267	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0026a	50		 push	 eax
  0026b	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  00270	6a 00		 push	 0
  00272	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00277	83 c4 28	 add	 esp, 40			; 00000028H

; 657  : 			this->GiveReward_Fail(iBridgeIndex);

  0027a	57		 push	 edi
  0027b	8b cb		 mov	 ecx, ebx
  0027d	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 658  : 			this->SetState(iBridgeIndex, BC_STATE_CLOSED);

  00282	6a 01		 push	 1
  00284	57		 push	 edi
  00285	8b cb		 mov	 ecx, ebx
  00287	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 659  : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) Blood Castle Quest Failed -> Every User Out", iBridgeIndex+1);

  0028c	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0028f	50		 push	 eax
  00290	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  00295	6a 00		 push	 0
  00297	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0029c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 660  : 		}
; 661  : 		else

  0029f	eb 29		 jmp	 SHORT $LN7@ProcState_@2
$LN12@ProcState_@2:

; 662  : 		{
; 663  : 			if ( this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START != false )

  002a1	80 be 65 01 00
	00 00		 cmp	 BYTE PTR [esi+357], 0
  002a8	74 20		 je	 SHORT $LN7@ProcState_@2

; 664  : 			{
; 665  : 				if ( this->m_BridgeData[iBridgeIndex].m_bBC_DOOR_TERMINATE_COMPLETE == false || this->m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE != false )

  002aa	80 be 62 01 00
	00 00		 cmp	 BYTE PTR [esi+354], 0
  002b1	74 0d		 je	 SHORT $LN8@ProcState_@2
  002b3	80 be 61 01 00
	00 00		 cmp	 BYTE PTR [esi+353], 0
  002ba	75 04		 jne	 SHORT $LN8@ProcState_@2

; 668  : 				}
; 669  : 				else
; 670  : 				{
; 671  : 					this->SendNoticeState(iBridgeIndex, 4);

  002bc	6a 04		 push	 4
  002be	eb 02		 jmp	 SHORT $LN24@ProcState_@2
$LN8@ProcState_@2:

; 666  : 				{
; 667  : 					this->SendNoticeState(iBridgeIndex, 1);

  002c0	6a 01		 push	 1
$LN24@ProcState_@2:
  002c2	57		 push	 edi
  002c3	8b cb		 mov	 ecx, ebx
  002c5	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState
$LN7@ProcState_@2:

; 672  : 				}
; 673  : 			}
; 674  : 		}
; 675  : 
; 676  : 		if ( this->CheckWinnerExist(iBridgeIndex) == true )

  002ca	57		 push	 edi
  002cb	8b cb		 mov	 ecx, ebx
  002cd	e8 00 00 00 00	 call	 ?CheckWinnerExist@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerExist
  002d2	3c 01		 cmp	 al, 1
  002d4	0f 85 86 00 00
	00		 jne	 $LN3@ProcState_@2

; 677  : 		{
; 678  : 			if ( this->CheckWinnerValid(iBridgeIndex) == true )

  002da	57		 push	 edi
  002db	e8 00 00 00 00	 call	 ?CheckWinnerValid@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerValid

; 679  : 			{
; 680  : 				if ( this->CheckWinnerPartyComplete(iBridgeIndex) == true )

  002e0	57		 push	 edi
  002e1	8b cb		 mov	 ecx, ebx
  002e3	3c 01		 cmp	 al, 1
  002e5	75 46		 jne	 SHORT $LN5@ProcState_@2
  002e7	e8 00 00 00 00	 call	 ?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerPartyComplete
  002ec	3c 01		 cmp	 al, 1
  002ee	75 70		 jne	 SHORT $LN3@ProcState_@2

; 681  : 				{
; 682  : 					this->GiveReward_Win(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX, iBridgeIndex);

  002f0	8b 8e 00 02 00
	00		 mov	 ecx, DWORD PTR [esi+512]
  002f6	57		 push	 edi
  002f7	51		 push	 ecx
  002f8	8b cb		 mov	 ecx, ebx
  002fa	e8 00 00 00 00	 call	 ?GiveReward_Win@CBloodCastle@@QAEXHH@Z ; CBloodCastle::GiveReward_Win

; 683  : 					this->SetState(iBridgeIndex, BC_STATE_PLAYEND);

  002ff	6a 03		 push	 3
  00301	57		 push	 edi
  00302	8b cb		 mov	 ecx, ebx
  00304	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 684  : 
; 685  : 					LogAdd(LOG_BLACK, "[Blood Castle] (%d) CheckWinnerPartyComplete(iBridgeIndex) == true",
; 686  : 						iBridgeIndex+1);

  00309	47		 inc	 edi
  0030a	57		 push	 edi
  0030b	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@
  00310	6a 00		 push	 0
  00312	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00317	83 c4 0c	 add	 esp, 12			; 0000000cH
  0031a	5f		 pop	 edi
  0031b	5e		 pop	 esi
  0031c	5b		 pop	 ebx

; 722  : 	}
; 723  : }

  0031d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00320	33 cd		 xor	 ecx, ebp
  00322	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00327	8b e5		 mov	 esp, ebp
  00329	5d		 pop	 ebp
  0032a	c2 04 00	 ret	 4
$LN5@ProcState_@2:

; 687  : 
; 688  : 					return;
; 689  : 				}
; 690  : 			}
; 691  : 			else
; 692  : 			{
; 693  : 				this->GiveReward_Fail(iBridgeIndex);

  0032d	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 694  : 				this->SetState(iBridgeIndex, BC_STATE_PLAYEND); 

  00332	6a 03		 push	 3
  00334	57		 push	 edi
  00335	8b cb		 mov	 ecx, ebx
  00337	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 695  : 
; 696  : 				LogAdd(LOG_BLACK, "[Blood Castle] (%d) CheckWinnerValid(iBridgeIndex) == false",
; 697  : 					iBridgeIndex+1);

  0033c	47		 inc	 edi
  0033d	57		 push	 edi
  0033e	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@
  00343	6a 00		 push	 0
  00345	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0034a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0034d	5f		 pop	 edi
  0034e	5e		 pop	 esi
  0034f	5b		 pop	 ebx

; 722  : 	}
; 723  : }

  00350	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00353	33 cd		 xor	 ecx, ebp
  00355	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035a	8b e5		 mov	 esp, ebp
  0035c	5d		 pop	 ebp
  0035d	c2 04 00	 ret	 4
$LN3@ProcState_@2:

; 698  : 
; 699  : 				return;
; 700  : 			}
; 701  : 		}
; 702  : 	}
; 703  : 
; 704  : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0 )

  00360	83 be 54 01 00
	00 00		 cmp	 DWORD PTR [esi+340], 0
  00367	7f 6a		 jg	 SHORT $LN2@ProcState_@2

; 705  : 	{
; 706  : 		if ( this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED == false )

  00369	80 be 66 01 00
	00 00		 cmp	 BYTE PTR [esi+358], 0
  00370	75 57		 jne	 SHORT $LN1@ProcState_@2

; 707  : 		{
; 708  : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Castle Door [%s][%s]",
; 709  : 				iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID,
; 710  : 				this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName);

  00372	8d 96 b3 01 00
	00		 lea	 edx, DWORD PTR [esi+435]
  00378	52		 push	 edx
  00379	8d 8e a8 01 00
	00		 lea	 ecx, DWORD PTR [esi+424]
  0037f	51		 push	 ecx
  00380	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00383	50		 push	 eax
  00384	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  00389	6a 00		 push	 0
  0038b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 711  : 
; 712  : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Saint Status [%s][%s]",
; 713  : 				iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID,
; 714  : 				this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName);

  00390	8d 96 c8 01 00
	00		 lea	 edx, DWORD PTR [esi+456]
  00396	52		 push	 edx
  00397	81 c6 d3 01 00
	00		 add	 esi, 467		; 000001d3H
  0039d	56		 push	 esi
  0039e	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  003a1	56		 push	 esi
  003a2	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  003a7	6a 00		 push	 0
  003a9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  003ae	83 c4 28	 add	 esp, 40			; 00000028H

; 715  : 			this->GiveReward_Fail(iBridgeIndex);

  003b1	57		 push	 edi
  003b2	8b cb		 mov	 ecx, ebx
  003b4	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 716  : 
; 717  : 			LogAdd(LOG_BLACK, "[Blood Castle] (%d) Blood Castle Quest Failed -> Time Out", iBridgeIndex+1);

  003b9	56		 push	 esi
  003ba	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  003bf	6a 00		 push	 0
  003c1	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  003c6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ProcState_@2:

; 718  : 			
; 719  : 		}
; 720  : 
; 721  : 		this->SetState(iBridgeIndex, BC_STATE_PLAYEND);

  003c9	6a 03		 push	 3
  003cb	57		 push	 edi
  003cc	8b cb		 mov	 ecx, ebx
  003ce	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN2@ProcState_@2:

; 722  : 	}
; 723  : }

  003d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d6	5f		 pop	 edi
  003d7	5e		 pop	 esi
  003d8	33 cd		 xor	 ecx, ebp
  003da	5b		 pop	 ebx
  003db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003e0	8b e5		 mov	 esp, ebp
  003e2	5d		 pop	 ebp
  003e3	c2 04 00	 ret	 4
?ProcState_Playing@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_Playing
_TEXT	ENDS
PUBLIC	?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z	; CBloodCastle::ProcState_PlayEnd
; Function compile flags: /Ogtp
;	COMDAT ?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_pMsg$157460 = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_PlayEnd, COMDAT
; _this$ = ecx

; 731  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 732  : 	int iTICK_MSEC = GetTickCount() - this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT;

  00005	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	c1 e6 09	 shl	 esi, 9
  00015	03 f7		 add	 esi, edi
  00017	ff d3		 call	 ebx
  00019	2b 86 58 01 00
	00		 sub	 eax, DWORD PTR [esi+344]

; 733  : 
; 734  : 	if ( iTICK_MSEC >= 1000 )

  0001f	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00024	7c 57		 jl	 SHORT $LN6@ProcState_@3

; 735  : 	{
; 736  : 		this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;

  00026	29 86 54 01 00
	00		 sub	 DWORD PTR [esi+340], eax

; 737  : 		this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  0002c	ff d3		 call	 ebx
  0002e	89 86 58 01 00
	00		 mov	 DWORD PTR [esi+344], eax

; 738  : 
; 739  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30000 && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && this->m_BridgeData[iBridgeIndex]. m_bBC_MSG_BEFORE_QUIT == false)

  00034	8b 86 54 01 00
	00		 mov	 eax, DWORD PTR [esi+340]
  0003a	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  0003f	7f 3c		 jg	 SHORT $LN6@ProcState_@3
  00041	85 c0		 test	 eax, eax
  00043	7e 38		 jle	 SHORT $LN6@ProcState_@3
  00045	80 be 6a 01 00
	00 00		 cmp	 BYTE PTR [esi+362], 0
  0004c	75 2f		 jne	 SHORT $LN6@ProcState_@3

; 740  : 		{
; 741  : 			this->m_BridgeData[iBridgeIndex]. m_bBC_MSG_BEFORE_QUIT = true;
; 742  : 
; 743  : 			PMSG_SET_DEVILSQUARE pMsg;
; 744  : 
; 745  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  0004e	6a 04		 push	 4
  00050	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$157460[ebp]
  00053	68 92 00 00 00	 push	 146			; 00000092H
  00058	51		 push	 ecx
  00059	c6 86 6a 01 00
	00 01		 mov	 BYTE PTR [esi+362], 1
  00060	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 746  : 			pMsg.Type = 6;
; 747  : 
; 748  : 			this->SendBridgeAnyMsg((BYTE *)&pMsg, sizeof(pMsg), iBridgeIndex);

  00065	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	52		 push	 edx
  0006c	6a 04		 push	 4
  0006e	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$157460[ebp]
  00071	50		 push	 eax
  00072	8b cf		 mov	 ecx, edi
  00074	c6 45 ff 06	 mov	 BYTE PTR _pMsg$157460[ebp+3], 6
  00078	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN6@ProcState_@3:

; 749  : 		}
; 750  : 
; 751  : 
; 752  : 	}
; 753  : 
; 754  : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0 )

  0007d	83 be 54 01 00
	00 00		 cmp	 DWORD PTR [esi+340], 0
  00084	7f 0d		 jg	 SHORT $LN1@ProcState_@3

; 755  : 	{
; 756  : 		this->SetState(iBridgeIndex, BC_STATE_CLOSED);

  00086	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00089	6a 01		 push	 1
  0008b	51		 push	 ecx
  0008c	8b cf		 mov	 ecx, edi
  0008e	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN1@ProcState_@3:
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx

; 757  : 	}
; 758  : }

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 04 00	 ret	 4
?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_PlayEnd
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z
_TEXT	SEGMENT
$T164632 = -16						; size = 12
$T164609 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN15@Tree_val
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 551  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T164609[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T164632[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T164609[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T164632[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T164632[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val:
$LN36@Tree_val:
  0006e	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
_TEXT	ENDS
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@	; `string'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	__CTA2?AVruntime_error@std@@
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
;	COMDAT __CTA2?AVruntime_error@std@@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdexcept
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T164658 = -28						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T164684 = 8						; size = 4
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 76   :         {	// construct from NTBS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_Locinfo@std@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx
  00029	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002c	33 db		 xor	 ebx, ebx
  0002e	53		 push	 ebx
  0002f	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00034	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00037	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0003a	88 5e 08	 mov	 BYTE PTR [esi+8], bl
  0003d	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00040	88 5e 10	 mov	 BYTE PTR [esi+16], bl
  00043	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00046	88 5e 18	 mov	 BYTE PTR [esi+24], bl
  00049	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  0004c	88 5e 20	 mov	 BYTE PTR [esi+32], bl

; 77   :         if (_Pch == 0)

  0004f	8b 45 08	 mov	 eax, DWORD PTR __Pch$[ebp]
  00052	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00056	3b c3		 cmp	 eax, ebx
  00058	75 28		 jne	 SHORT $LN1@Locinfo

; 78   :             _THROW_NCEE(runtime_error, "bad locale name");

  0005a	8d 45 08	 lea	 eax, DWORD PTR $T164684[ebp]
  0005d	50		 push	 eax
  0005e	8d 4d e4	 lea	 ecx, DWORD PTR $T164658[ebp]
  00061	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T164684[ebp], OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
  00068	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0006d	68 00 00 00 00	 push	 OFFSET __TI2?AVruntime_error@std@@
  00072	8d 4d e4	 lea	 ecx, DWORD PTR $T164658[ebp]
  00075	51		 push	 ecx
  00076	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T164658[ebp], OFFSET ??_7runtime_error@std@@6B@
  0007d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN22@Locinfo:
$LN1@Locinfo:

; 79   :         _Locinfo_ctor(this, _Pch);

  00082	50		 push	 eax
  00083	56		 push	 esi
  00084	e8 00 00 00 00	 call	 ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
  00089	83 c4 08	 add	 esp, 8

; 80   :         }

  0008c	8b c6		 mov	 eax, esi
  0008e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00091	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00098	59		 pop	 ecx
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
$LN21@Locinfo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
  00034	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00038	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003b	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0003e	33 c8		 xor	 ecx, eax
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
  0004a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1_Locinfo@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1_Locinfo@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 93   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Locinfo@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 94   :         _Locinfo_dtor(this);

  0002a	56		 push	 esi
  0002b	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  00032	e8 00 00 00 00	 call	 ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor

; 95   :         }

  00037	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0003a	33 ff		 xor	 edi, edi
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b c7		 cmp	 eax, edi
  00041	74 09		 je	 SHORT $LN10@Locinfo@2
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _free
  00049	83 c4 04	 add	 esp, 4
$LN10@Locinfo@2:
  0004c	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  0004f	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00052	3b c7		 cmp	 eax, edi
  00054	74 09		 je	 SHORT $LN15@Locinfo@2
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _free
  0005c	83 c4 04	 add	 esp, 4
$LN15@Locinfo@2:
  0005f	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00062	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00065	3b c7		 cmp	 eax, edi
  00067	74 09		 je	 SHORT $LN20@Locinfo@2
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _free
  0006f	83 c4 04	 add	 esp, 4
$LN20@Locinfo@2:
  00072	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00075	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00078	3b c7		 cmp	 eax, edi
  0007a	74 09		 je	 SHORT $LN25@Locinfo@2
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _free
  00082	83 c4 04	 add	 esp, 4
$LN25@Locinfo@2:
  00085	8b ce		 mov	 ecx, esi
  00087	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0008a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00091	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00096	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00099	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a0	59		 pop	 ecx
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??1_Locinfo@std@@QAE@XZ:
  00034	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00038	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003b	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0003e	33 c8		 xor	 ecx, eax
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
  0004a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
xdata$x	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T164754 = -68						; size = 36
$T164814 = -32						; size = 16
$T164758 = -16						; size = 4
$T164753 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2371 : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2372 : 		if (_Ppf != 0 && *_Ppf == 0)

  00027	8b 45 08	 mov	 eax, DWORD PTR __Ppf$[ebp]
  0002a	33 db		 xor	 ebx, ebx
  0002c	89 5d f0	 mov	 DWORD PTR $T164758[ebp], ebx
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 8c 00 00
	00		 je	 $LN28@Getcat
  00037	39 18		 cmp	 DWORD PTR [eax], ebx
  00039	0f 85 84 00 00
	00		 jne	 $LN28@Getcat

; 2373 : 			*_Ppf = _NEW_CRT ctype<_Elem>(
; 2374 : 				_Locinfo(_Ploc->c_str()));

  0003f	6a 18		 push	 24			; 00000018H
  00041	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00046	8b f0		 mov	 esi, eax
  00048	83 c4 04	 add	 esp, 4
  0004b	89 75 f0	 mov	 DWORD PTR $T164753[ebp], esi
  0004e	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00051	85 f6		 test	 esi, esi
  00053	74 53		 je	 SHORT $LN4@Getcat
  00055	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0005d	85 c9		 test	 ecx, ecx
  0005f	74 04		 je	 SHORT $LN14@Getcat
  00061	8b c1		 mov	 eax, ecx
  00063	eb 03		 jmp	 SHORT $LN15@Getcat
$LN14@Getcat:
  00065	83 c0 1c	 add	 eax, 28			; 0000001cH
$LN15@Getcat:
  00068	50		 push	 eax
  00069	8d 4d bc	 lea	 ecx, DWORD PTR $T164754[ebp]
  0006c	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00071	8d 4d e0	 lea	 ecx, DWORD PTR $T164814[ebp]
  00074	51		 push	 ecx
  00075	bb 01 00 00 00	 mov	 ebx, 1
  0007a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00081	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  00087	e8 00 00 00 00	 call	 __Getctype
  0008c	8b 10		 mov	 edx, DWORD PTR [eax]
  0008e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00091	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00094	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00097	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0009a	89 56 10	 mov	 DWORD PTR [esi+16], edx
  0009d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000a0	83 c4 04	 add	 esp, 4
  000a3	89 46 14	 mov	 DWORD PTR [esi+20], eax
  000a6	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  000a8	33 f6		 xor	 esi, esi
$LN5@Getcat:
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Ppf$[ebp]
  000ad	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b4	89 31		 mov	 DWORD PTR [ecx], esi
  000b6	f6 c3 01	 test	 bl, 1
  000b9	74 08		 je	 SHORT $LN28@Getcat
  000bb	8d 4d bc	 lea	 ecx, DWORD PTR $T164754[ebp]
  000be	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN28@Getcat:

; 2375 : 		return (_X_CTYPE);

  000c3	b8 02 00 00 00	 mov	 eax, 2

; 2376 : 		}

  000c8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d2	59		 pop	 ecx
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T164753[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 550  : 		{	// construct empty string

  00000	8b c1		 mov	 eax, ecx

; 551  : 		_Tidy();

  00002	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
  00009	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00010	c6 00 00	 mov	 BYTE PTR [eax], 0

; 552  : 		}

  00013	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 753  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 754  : 		_Tidy(true);

  00003	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00007	72 0b		 jb	 SHORT $LN11@basic_stri
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
$LN11@basic_stri:
  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00022	c6 06 00	 mov	 BYTE PTR [esi], 0
  00025	5e		 pop	 esi

; 755  : 		}

  00026	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1109 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1110 : 		if (this->_Mysize < _Off)

  00006	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0000c	57		 push	 edi
  0000d	3b c1		 cmp	 eax, ecx
  0000f	73 0a		 jae	 SHORT $LN3@erase

; 1111 : 			_Xran();	// _Off off end

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00016	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN28@erase:
$LN3@erase:

; 1112 : 		if (this->_Mysize - _Off < _Count)

  0001b	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0001e	2b c1		 sub	 eax, ecx
  00020	3b c7		 cmp	 eax, edi
  00022	73 02		 jae	 SHORT $LN2@erase

; 1113 : 			_Count = this->_Mysize - _Off;	// trim _Count

  00024	8b f8		 mov	 edi, eax
$LN2@erase:

; 1114 : 		if (0 < _Count)

  00026	85 ff		 test	 edi, edi
  00028	74 50		 je	 SHORT $LN25@erase

; 1115 : 			{	// move elements down
; 1116 : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 1117 : 				this->_Mysize - _Off - _Count);

  0002a	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0002d	53		 push	 ebx
  0002e	83 fa 10	 cmp	 edx, 16			; 00000010H
  00031	72 04		 jb	 SHORT $LN11@erase
  00033	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00035	eb 02		 jmp	 SHORT $LN12@erase
$LN11@erase:
  00037	8b de		 mov	 ebx, esi
$LN12@erase:
  00039	83 fa 10	 cmp	 edx, 16			; 00000010H
  0003c	72 04		 jb	 SHORT $LN15@erase
  0003e	8b 16		 mov	 edx, DWORD PTR [esi]
  00040	eb 02		 jmp	 SHORT $LN16@erase
$LN15@erase:
  00042	8b d6		 mov	 edx, esi
$LN16@erase:
  00044	2b c7		 sub	 eax, edi
  00046	03 d9		 add	 ebx, ecx
  00048	50		 push	 eax
  00049	03 df		 add	 ebx, edi
  0004b	03 d1		 add	 edx, ecx
  0004d	53		 push	 ebx
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 _memmove

; 1118 : 			size_type _Newsize = this->_Mysize - _Count;

  00054	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	2b c7		 sub	 eax, edi

; 1119 : 			_Eos(_Newsize);

  0005c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00060	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00063	5b		 pop	 ebx
  00064	72 0e		 jb	 SHORT $LN23@erase
  00066	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00068	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
  0006c	5f		 pop	 edi

; 1120 : 			}
; 1121 : 		return (*this);

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi

; 1122 : 		}

  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8

; 1119 : 			_Eos(_Newsize);

$LN23@erase:
  00074	8b ce		 mov	 ecx, esi
  00076	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
$LN25@erase:

; 1120 : 			}
; 1121 : 		return (*this);

  0007a	5f		 pop	 edi
  0007b	8b c6		 mov	 eax, esi
  0007d	5e		 pop	 esi

; 1122 : 		}

  0007e	5d		 pop	 ebp
  0007f	c2 08 00	 ret	 8
$LN27@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
; Function compile flags: /Ogtp
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
__Off$ = 12						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1648 : 		{	// look for _Ch at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1649 : 		return (find((const _Elem *)&_Ch, _Off, 1));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	6a 01		 push	 1
  00008	50		 push	 eax
  00009	8d 55 08	 lea	 edx, DWORD PTR __Ch$[ebp]
  0000c	52		 push	 edx
  0000d	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find

; 1650 : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; Function compile flags: /Ogtp
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1875 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1876 : 		_DEBUG_POINTER(_Ptr);
; 1877 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	8b c6		 mov	 eax, esi
  00009	57		 push	 edi
  0000a	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000d	8d 49 00	 npad	 3
$LL5@compare@3:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL5@compare@3
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0001d	56		 push	 esi
  0001e	50		 push	 eax
  0001f	6a 00		 push	 0
  00021	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 1878 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 54   : 		{	// merge _State into state, possible reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 		if (_State != goodbit)

  00003	8b 55 08	 mov	 edx, DWORD PTR __State$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 18		 je	 SHORT $LN6@setstate

; 56   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000d	0b c2		 or	 eax, edx
  0000f	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00013	75 03		 jne	 SHORT $LN8@setstate
  00015	83 c8 04	 or	 eax, 4
$LN8@setstate:
  00018	8b 55 0c	 mov	 edx, DWORD PTR __Reraise$[ebp]
  0001b	52		 push	 edx
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN6@setstate:

; 57   : 		}

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::snextc, COMDAT
; _this$ = ecx

; 163  : 		{	// point to next character and return it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

  00003	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	85 c0		 test	 eax, eax
  0000a	74 3b		 je	 SHORT $LN17@snextc
  0000c	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00011	83 f9 01	 cmp	 ecx, 1
  00014	7e 12		 jle	 SHORT $LN5@snextc
  00016	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00019	ff 08		 dec	 DWORD PTR [eax]
  0001b	8b 76 20	 mov	 esi, DWORD PTR [esi+32]
  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
  00020	40		 inc	 eax
  00021	89 06		 mov	 DWORD PTR [esi], eax
  00023	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00026	5e		 pop	 esi

; 168  : 		}

  00027	c3		 ret	 0
$LN5@snextc:

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

  00028	85 c0		 test	 eax, eax
  0002a	74 1b		 je	 SHORT $LN17@snextc
  0002c	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0002f	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00032	7e 13		 jle	 SHORT $LN17@snextc
  00034	8b c2		 mov	 eax, edx
  00036	ff 08		 dec	 DWORD PTR [eax]
  00038	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00040	89 10		 mov	 DWORD PTR [eax], edx
  00042	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00045	eb 09		 jmp	 SHORT $LN18@snextc
$LN17@snextc:
  00047	8b 06		 mov	 eax, DWORD PTR [esi]
  00049	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0004c	8b ce		 mov	 ecx, esi
  0004e	ff d2		 call	 edx
$LN18@snextc:
  00050	83 f8 ff	 cmp	 eax, -1
  00053	75 04		 jne	 SHORT $LN3@snextc
  00055	0b c0		 or	 eax, eax
  00057	5e		 pop	 esi

; 168  : 		}

  00058	c3		 ret	 0
$LN3@snextc:

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

  00059	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0005c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005f	74 0f		 je	 SHORT $LN35@snextc
  00061	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00064	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00067	7e 07		 jle	 SHORT $LN35@snextc
  00069	8b 10		 mov	 edx, DWORD PTR [eax]
  0006b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0006e	5e		 pop	 esi

; 168  : 		}

  0006f	c3		 ret	 0

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

$LN35@snextc:
  00070	8b 06		 mov	 eax, DWORD PTR [esi]
  00072	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00075	8b ce		 mov	 ecx, esi
  00077	5e		 pop	 esi
  00078	ff e2		 jmp	 edx
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::snextc
_TEXT	ENDS
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator->
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator->, COMDAT
; _this$ = ecx

; 401  : 		return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 402  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator->
_TEXT	ENDS
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKVTokenizerSection@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator->
; Function compile flags: /Ogtp
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKVTokenizerSection@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKVTokenizerSection@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator->, COMDAT
; _this$ = ecx

; 401  : 		return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 402  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKVTokenizerSection@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator->
_TEXT	ENDS
PUBLIC	??1?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $LN14@Pair_base
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN14@Pair_base:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi
  00025	c3		 ret	 0
??1?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1351 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1352 : 		return (_STRING_ITERATOR(_Myptr()));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	72 02		 jb	 SHORT $LN5@begin
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN5@begin:
  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 1353 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >
_TEXT	ENDS
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA DD 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
_BSS	ENDS
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
__File$ = 8						; size = 4
__Which$ = 12						; size = 4
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 555  : 		{	// initialize to C stream _File after {new, open, close}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 556  : 		__PURE_APPDOMAIN_GLOBAL static _Myst _Stinit;	// initial state
; 557  : 
; 558  : 		_Closef = _Which == _Openfl;

  00003	83 7d 0c 01	 cmp	 DWORD PTR __Which$[ebp], 1

; 559  : 		_Wrotesome = false;
; 560  : 
; 561  : 		_Mysb::_Init();	// initialize stream buffer base object

  00007	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	8d 51 18	 lea	 edx, DWORD PTR [ecx+24]
  00010	89 51 20	 mov	 DWORD PTR [ecx+32], edx
  00013	8d 51 1c	 lea	 edx, DWORD PTR [ecx+28]
  00016	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  00019	0f 94 c0	 sete	 al
  0001c	88 41 50	 mov	 BYTE PTR [ecx+80], al
  0001f	8d 51 28	 lea	 edx, DWORD PTR [ecx+40]
  00022	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00025	c6 41 49 00	 mov	 BYTE PTR [ecx+73], 0
  00029	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  0002c	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0002f	8d 51 2c	 lea	 edx, DWORD PTR [ecx+44]
  00032	89 51 34	 mov	 DWORD PTR [ecx+52], edx
  00035	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0003b	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0003e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00044	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0004d	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00050	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00056	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00059	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0005f	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00062	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 562  : 
; 563  :  #ifndef _IORCNT
; 564  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 565  :   #define _IOWCNT _IOCNT
; 566  :  #endif /* _IORCNT */
; 567  : 
; 568  :   #pragma warning(push)
; 569  :   #pragma warning(disable: 6240)	/* prefast noise VSW 489858 */
; 570  : 		if (_File != 0 && sizeof (_Elem) == 1)

  00068	8b 45 08	 mov	 eax, DWORD PTR __File$[ebp]
  0006b	85 c0		 test	 eax, eax
  0006d	74 18		 je	 SHORT $LN10@Init@2

; 571  :   #pragma warning(pop)
; 572  : 
; 573  : 			{	// point inside C stream with [first, first + count) buffer
; 574  : 			_Elem **_Pb = (_Elem **)&_File->_IOBASE;

  0006f	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 575  : 			_Elem **_Pn = (_Elem **)&_File->_IOPTR;
; 576  : 			int *_Nr = (int *)&_File->_IORCNT;
; 577  : 			int *_Nw = (int *)&_File->_IOWCNT;
; 578  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);

  00072	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00075	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00078	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0007b	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0007e	89 41 24	 mov	 DWORD PTR [ecx+36], eax
  00081	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00084	89 51 34	 mov	 DWORD PTR [ecx+52], edx
$LN10@Init@2:

; 579  : 			}
; 580  : 
; 581  : 		_Myfile = _File;

  00087	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 582  : 		_State = _Stinit;

  0008a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  00090	89 51 4c	 mov	 DWORD PTR [ecx+76], edx

; 583  : 		_Pcvt = 0;	// pointer to codecvt facet

  00093	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 584  : 		}

  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
; Function compile flags: /Ogtp
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z
_TEXT	SEGMENT
__Newpcvt$ = 8						; size = 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT
; _this$ = ecx

; 628  : 		{	// initialize codecvt pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 629  : 		if (_Newpcvt->always_noconv())

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Newpcvt$[ebp]
  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0000d	8b f1		 mov	 esi, ecx
  0000f	8b cf		 mov	 ecx, edi
  00011	ff d2		 call	 edx
  00013	84 c0		 test	 al, al
  00015	74 0d		 je	 SHORT $LN2@Initcvt

; 630  : 			_Pcvt = 0;	// nothing to do

  00017	5f		 pop	 edi
  00018	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
  0001f	5e		 pop	 esi

; 635  : 			}
; 636  : 		}

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN2@Initcvt:

; 631  : 		else
; 632  : 			{	// set up for nontrivial codecvt facet
; 633  : 			_Pcvt = _Newpcvt;
; 634  : 			_Mysb::_Init();	// reset any buffering

  00024	8b ce		 mov	 ecx, esi
  00026	89 7e 44	 mov	 DWORD PTR [esi+68], edi
  00029	e8 00 00 00 00	 call	 ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 635  : 			}
; 636  : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
PUBLIC	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
EXTRN	??0_Mutex@std@@QAE@XZ:PROC			; std::_Mutex::_Mutex
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0
__ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Lock$165323 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 25   : 		{	// construct with no buffers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  00036	e8 00 00 00 00	 call	 ??0_Mutex@std@@QAE@XZ	; std::_Mutex::_Mutex
  0003b	6a 04		 push	 4
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00049	8b f8		 mov	 edi, eax
  0004b	83 c4 04	 add	 esp, 4
  0004e	85 ff		 test	 edi, edi
  00050	74 2e		 je	 SHORT $LN3@basic_stre@2
  00052	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Init
  00057	89 07		 mov	 DWORD PTR [edi], eax
  00059	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0005e	6a 00		 push	 0
  00060	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$165323[ebp]
  00063	8b d8		 mov	 ebx, eax
  00065	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  0006a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0006d	83 f8 ff	 cmp	 eax, -1
  00070	73 04		 jae	 SHORT $LN8@basic_stre@2
  00072	40		 inc	 eax
  00073	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN8@basic_stre@2:
  00076	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$165323[ebp]
  00079	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0007e	eb 02		 jmp	 SHORT $LN4@basic_stre@2
$LN3@basic_stre@2:
  00080	33 ff		 xor	 edi, edi
$LN4@basic_stre@2:

; 26   : 		_Init();

  00082	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00085	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00088	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  0008b	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  0008e	8d 56 1c	 lea	 edx, DWORD PTR [esi+28]
  00091	89 56 24	 mov	 DWORD PTR [esi+36], edx
  00094	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  00097	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0009a	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0009d	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  000a0	89 4e 30	 mov	 DWORD PTR [esi+48], ecx
  000a3	8d 56 2c	 lea	 edx, DWORD PTR [esi+44]
  000a6	89 56 34	 mov	 DWORD PTR [esi+52], edx
  000a9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000af	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000b2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000b8	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  000bb	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000c1	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  000c4	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  000ca	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000cd	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000d3	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  000d6	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 27   : 		}

  000dc	8b c6		 mov	 eax, esi
  000de	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e8	59		 pop	 ecx
  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1_Mutex@std@@QAE@XZ	; std::_Mutex::~_Mutex
__ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 807  : 		return (iterator(_Lmost(), this));

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound
; Function compile flags: /Ogtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1742 : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00009	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0000d	75 19		 jne	 SHORT $LN3@Lbound@2
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL4@Lbound@2:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	73 05		 jae	 SHORT $LN2@Lbound@2

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  0001c	eb 04		 jmp	 SHORT $LN1@Lbound@2
$LN2@Lbound@2:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound@2:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00026	74 ec		 je	 SHORT $LL4@Lbound@2
$LN3@Lbound@2:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
$T165466 = -16						; size = 12
$T165450 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  00009	6a 30		 push	 48			; 00000030H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN15@Tree_val@2
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 2c	 mov	 BYTE PTR [ecx+44], al

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 2d	 mov	 BYTE PTR [edx+45], al

; 551  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val@2:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T165450[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T165466[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T165450[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T165466[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T165466[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val@2:
$LN36@Tree_val@2:
  0006e	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lbound
; Function compile flags: /Ogtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1742 : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00009	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000d	75 19		 jne	 SHORT $LN3@Lbound@3
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL4@Lbound@3:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	73 05		 jae	 SHORT $LN2@Lbound@3

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  0001c	eb 04		 jmp	 SHORT $LN1@Lbound@3
$LN2@Lbound@3:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound@3:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00026	74 ec		 je	 SHORT $LL4@Lbound@3
$LN3@Lbound@3:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z
_TEXT	SEGMENT
$T165583 = -16						; size = 12
$T165566 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN15@Tree_val@3
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 551  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val@3:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T165566[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T165583[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T165566[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T165583[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T165583[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val@3:
$LN36@Tree_val@3:
  0006e	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lbound
; Function compile flags: /Ogtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1742 : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00009	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000d	75 19		 jne	 SHORT $LN3@Lbound@4
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL4@Lbound@4:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	73 05		 jae	 SHORT $LN2@Lbound@4

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  0001c	eb 04		 jmp	 SHORT $LN1@Lbound@4
$LN2@Lbound@4:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound@4:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00026	74 ec		 je	 SHORT $LL4@Lbound@4
$LN3@Lbound@4:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
$T165769 = -40						; size = 12
__Newres$ = -28						; size = 4
$T165746 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1919 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi

; 1920 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f0		 mov	 esi, eax
  00035	83 ce 0f	 or	 esi, 15			; 0000000fH

; 1921 : 		if (max_size() < _Newres)

  00038	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0003b	76 04		 jbe	 SHORT $LN9@Copy

; 1922 : 			_Newres = _Newsize;	// undo roundup if too big

  0003d	8b f0		 mov	 esi, eax
  0003f	eb 27		 jmp	 SHORT $LN39@Copy
$LN9@Copy:

; 1923 : 		else if (this->_Myres / 2 <= _Newres / 3)

  00041	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]
  00044	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00049	f7 e6		 mul	 esi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	d1 e9		 shr	 ecx, 1
  0004f	d1 ea		 shr	 edx, 1
  00051	3b ca		 cmp	 ecx, edx
  00053	76 13		 jbe	 SHORT $LN39@Copy

; 1924 : 			;
; 1925 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0005a	2b c1		 sub	 eax, ecx

; 1926 : 			_Newres = this->_Myres
; 1927 : 				+ this->_Myres / 2;	// grow exponentially if possible

  0005c	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]
  0005f	3b d8		 cmp	 ebx, eax
  00061	76 05		 jbe	 SHORT $LN39@Copy

; 1928 : 		else
; 1929 : 			_Newres = max_size();	// settle for max_size()

  00063	be fe ff ff ff	 mov	 esi, -2			; fffffffeH
$LN39@Copy:

; 1930 : 
; 1931 : 		_Elem *_Ptr;
; 1932 : 		_TRY_BEGIN

  00068	33 c0		 xor	 eax, eax

; 1933 : 			_Ptr = this->_Alval.allocate(_Newres + 1);

  0006a	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0006d	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  00070	3b c8		 cmp	 ecx, eax
  00072	76 12		 jbe	 SHORT $LN47@Copy
  00074	83 f9 ff	 cmp	 ecx, -1
  00077	77 12		 ja	 SHORT $LN46@Copy
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007f	83 c4 04	 add	 esp, 4
  00082	85 c0		 test	 eax, eax
  00084	74 05		 je	 SHORT $LN46@Copy
$LN47@Copy:
  00086	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  00089	eb 51		 jmp	 SHORT $LN19@Copy
$LN46@Copy:
  0008b	8d 4d e8	 lea	 ecx, DWORD PTR $T165746[ebp]
  0008e	51		 push	 ecx
  0008f	8d 4d d8	 lea	 ecx, DWORD PTR $T165769[ebp]
  00092	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T165746[ebp], 0
  00099	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0009e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000a3	8d 55 d8	 lea	 edx, DWORD PTR $T165769[ebp]
  000a6	52		 push	 edx
  000a7	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T165769[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN112@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 1934 : 		_CATCH_ALL
; 1935 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000b3	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 1936 : 			_TRY_BEGIN
; 1937 : 				_Ptr = this->_Alval.allocate(_Newres + 1);

  000b6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	89 45 e4	 mov	 DWORD PTR __Newres$[ebp], eax
  000bc	40		 inc	 eax
  000bd	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  000c0	50		 push	 eax
  000c1	83 c1 18	 add	 ecx, 24			; 00000018H
  000c4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000c8	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  000cd	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax

; 1941 : 			_CATCH_END
; 1942 : 		_CATCH_END

  000d0	b8 00 00 00 00	 mov	 eax, $LN107@Copy
  000d5	c3		 ret	 0
$LN107@Copy:
  000d6	8b 7d ec	 mov	 edi, DWORD PTR _this$[ebp]
  000d9	8b 75 e4	 mov	 esi, DWORD PTR __Newres$[ebp]
$LN19@Copy:

; 1943 : 
; 1944 : 		if (0 < _Oldlen)

  000dc	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  000df	85 db		 test	 ebx, ebx
  000e1	74 1a		 je	 SHORT $LN78@Copy

; 1945 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  000e3	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  000e7	72 04		 jb	 SHORT $LN76@Copy
  000e9	8b 07		 mov	 eax, DWORD PTR [edi]
  000eb	eb 02		 jmp	 SHORT $LN77@Copy
$LN76@Copy:
  000ed	8b c7		 mov	 eax, edi
$LN77@Copy:
  000ef	53		 push	 ebx
  000f0	50		 push	 eax
  000f1	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _memcpy
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN78@Copy:

; 1946 : 		_Tidy(true);

  000fd	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00101	72 0b		 jb	 SHORT $LN88@Copy
  00103	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00105	51		 push	 ecx
  00106	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0010b	83 c4 04	 add	 esp, 4
$LN88@Copy:

; 1947 : 		this->_Bx._Ptr = _Ptr;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00111	c6 07 00	 mov	 BYTE PTR [edi], 0
  00114	89 07		 mov	 DWORD PTR [edi], eax

; 1948 : 		this->_Myres = _Newres;

  00116	89 77 14	 mov	 DWORD PTR [edi+20], esi

; 1949 : 		_Eos(_Oldlen);

  00119	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
  0011c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0011f	72 02		 jb	 SHORT $LN102@Copy
  00121	8b f8		 mov	 edi, eax
$LN102@Copy:
  00123	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 1950 : 		}

  00127	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0012a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00131	59		 pop	 ecx
  00132	5f		 pop	 edi
  00133	5e		 pop	 esi
  00134	5b		 pop	 ebx
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 1938 : 			_CATCH_ALL
; 1939 : 			_Tidy(true);	// failed again, discard storage and reraise

  0013b	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0013e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00142	72 0b		 jb	 SHORT $LN64@Copy
  00144	8b 16		 mov	 edx, DWORD PTR [esi]
  00146	52		 push	 edx
  00147	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0014c	83 c4 04	 add	 esp, 4
$LN64@Copy:

; 1940 : 			_RERAISE;

  0014f	6a 00		 push	 0
  00151	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00158	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0015f	6a 00		 push	 0
  00161	c6 06 00	 mov	 BYTE PTR [esi], 0
  00164	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN113@Copy:
$LN111@Copy:
  00169	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator++
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 272  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++

; 273  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 274  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 272  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++

; 273  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 274  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
EXTRN	??0bad_cast@std@@QAE@PBD@Z:PROC			; std::bad_cast::bad_cast
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	??1bad_cast@std@@UAE@XZ:PROC			; std::bad_cast::~bad_cast
EXTRN	??0bad_cast@std@@QAE@ABV01@@Z:PROC		; std::bad_cast::bad_cast
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T165931 = -36						; size = 12
__Lock$150864 = -24					; size = 4
__Lock$165939 = -20					; size = 4
__Psave$150865 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Lock$165961 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 504  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 505  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$150864[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 506  : 		const locale::facet *_Psave =
; 507  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 508  : 
; 509  : 		size_t _Id = _Facet::id;

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, 0 ; std::ctype<char>::id
  00039	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	89 5d f0	 mov	 DWORD PTR __Psave$150865[ebp], ebx
  00049	75 2b		 jne	 SHORT $LN11@use_facet
  0004b	6a 00		 push	 0
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$165939[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, 0 ; std::ctype<char>::id
  0005c	75 10		 jne	 SHORT $LN10@use_facet
  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00063	40		 inc	 eax
  00064	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00069	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN10@use_facet:
  0006e	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$165939[ebp]
  00071	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN11@use_facet:

; 510  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00076	8b 7d 08	 mov	 edi, DWORD PTR __Loc$[ebp]
  00079	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
  0007f	8b 07		 mov	 eax, DWORD PTR [edi]
  00081	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  00084	73 22		 jae	 SHORT $LN20@use_facet
  00086	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00089	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  0008c	85 c9		 test	 ecx, ecx
  0008e	75 1c		 jne	 SHORT $LN16@use_facet
$LN30@use_facet:
  00090	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  00094	74 16		 je	 SHORT $LN16@use_facet
  00096	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009b	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  0009e	73 12		 jae	 SHORT $LN31@use_facet
  000a0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000a3	8b 34 b2	 mov	 esi, DWORD PTR [edx+esi*4]
  000a6	eb 06		 jmp	 SHORT $LN15@use_facet
$LN20@use_facet:
  000a8	33 c9		 xor	 ecx, ecx
  000aa	eb e4		 jmp	 SHORT $LN30@use_facet
$LN16@use_facet:
  000ac	8b f1		 mov	 esi, ecx
$LN15@use_facet:

; 511  : 
; 512  : 		if (_Pf != 0)

  000ae	85 f6		 test	 esi, esi
  000b0	75 65		 jne	 SHORT $LN28@use_facet
$LN31@use_facet:

; 513  : 			;	// got facet from locale
; 514  : 		else if (_Psave != 0)

  000b2	85 db		 test	 ebx, ebx
  000b4	74 04		 je	 SHORT $LN4@use_facet

; 515  : 			_Pf = _Psave;	// lazy facet already allocated

  000b6	8b f3		 mov	 esi, ebx
  000b8	eb 5d		 jmp	 SHORT $LN28@use_facet
$LN4@use_facet:

; 516  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000ba	8d 45 f0	 lea	 eax, DWORD PTR __Psave$150865[ebp]
  000bd	57		 push	 edi
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
  000c4	83 c4 08	 add	 esp, 8
  000c7	83 f8 ff	 cmp	 eax, -1
  000ca	75 1b		 jne	 SHORT $LN2@use_facet

; 517  : 
; 518  :  #if _HAS_EXCEPTIONS
; 519  : 
; 520  : 			_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000d1	8d 4d dc	 lea	 ecx, DWORD PTR $T165931[ebp]
  000d4	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@PBD@Z ; std::bad_cast::bad_cast
  000d9	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000de	8d 4d dc	 lea	 ecx, DWORD PTR $T165931[ebp]
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@use_facet:
$LN2@use_facet:

; 521  : 
; 522  :  #else /* _HAS_EXCEPTIONS */
; 523  : 			abort();	// lazy disallowed
; 524  :  #endif /* _HAS_EXCEPTIONS */
; 525  : 
; 526  : 		else
; 527  : 			{	// queue up lazy facet for destruction
; 528  : 			_Pf = _Psave;

  000e7	8b 75 f0	 mov	 esi, DWORD PTR __Psave$150865[ebp]

; 529  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 530  : 
; 531  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 532  : 			_Pfmod->_Incref();

  000ea	6a 00		 push	 0
  000ec	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$165961[ebp]
  000ef	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
  000f5	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  000fa	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000fd	83 f8 ff	 cmp	 eax, -1
  00100	73 04		 jae	 SHORT $LN24@use_facet
  00102	40		 inc	 eax
  00103	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN24@use_facet:
  00106	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$165961[ebp]
  00109	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit

; 533  : 			_Pfmod->_Register();

  0010e	56		 push	 esi
  0010f	e8 00 00 00 00	 call	 ?_Facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::_Facet_Register
  00114	83 c4 04	 add	 esp, 4
$LN28@use_facet:

; 534  : 			}
; 535  : 
; 536  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00117	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$150864[ebp]
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00121	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00126	8b c6		 mov	 eax, esi

; 537  : 	_END_LOCK()
; 538  : 	}

  00128	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00132	59		 pop	 ecx
  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
$LN36@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$150864[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\string
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 186  : 	{	// test for string vs. NTCS equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 	return (_Left.compare(_Right) == 0);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000c	8d 64 24 00	 npad	 4
$LL7@operator@8:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL7@operator@8
  00017	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001a	2b c6		 sub	 eax, esi
  0001c	50		 push	 eax
  0001d	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00020	52		 push	 edx
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00029	f7 d8		 neg	 eax
  0002b	1b c0		 sbb	 eax, eax
  0002d	40		 inc	 eax
  0002e	5e		 pop	 esi

; 188  : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::codecvt<char,char,int>::_Getcat
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T165995 = -52						; size = 36
$T165999 = -16						; size = 4
$T165994 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::codecvt<char,char,int>::_Getcat, COMDAT

; 849  : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 850  : 		if (_Ppf != 0 && *_Ppf == 0)

  00027	8b 45 08	 mov	 eax, DWORD PTR __Ppf$[ebp]
  0002a	33 db		 xor	 ebx, ebx
  0002c	89 5d f0	 mov	 DWORD PTR $T165999[ebp], ebx
  0002f	85 c0		 test	 eax, eax
  00031	74 65		 je	 SHORT $LN26@Getcat@2
  00033	39 18		 cmp	 DWORD PTR [eax], ebx
  00035	75 61		 jne	 SHORT $LN26@Getcat@2

; 851  : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 852  : 				_Locinfo(_Ploc->c_str()));

  00037	6a 08		 push	 8
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	8b f0		 mov	 esi, eax
  00040	83 c4 04	 add	 esp, 4
  00043	89 75 f0	 mov	 DWORD PTR $T165994[ebp], esi
  00046	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00049	85 f6		 test	 esi, esi
  0004b	74 30		 je	 SHORT $LN4@Getcat@2
  0004d	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00055	85 c9		 test	 ecx, ecx
  00057	74 04		 je	 SHORT $LN14@Getcat@2
  00059	8b c1		 mov	 eax, ecx
  0005b	eb 03		 jmp	 SHORT $LN15@Getcat@2
$LN14@Getcat@2:
  0005d	83 c0 1c	 add	 eax, 28			; 0000001cH
$LN15@Getcat@2:
  00060	50		 push	 eax
  00061	8d 4d cc	 lea	 ecx, DWORD PTR $T165995[ebp]
  00064	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00069	bb 01 00 00 00	 mov	 ebx, 1
  0006e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00075	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$codecvt@DDH@std@@6B@
  0007b	eb 02		 jmp	 SHORT $LN5@Getcat@2
$LN4@Getcat@2:
  0007d	33 f6		 xor	 esi, esi
$LN5@Getcat@2:
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR __Ppf$[ebp]
  00082	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00089	89 31		 mov	 DWORD PTR [ecx], esi
  0008b	f6 c3 01	 test	 bl, 1
  0008e	74 08		 je	 SHORT $LN26@Getcat@2
  00090	8d 4d cc	 lea	 ecx, DWORD PTR $T165995[ebp]
  00093	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN26@Getcat@2:

; 853  : 		return (_X_CTYPE);

  00098	b8 02 00 00 00	 mov	 eax, 2

; 854  : 		}

  0009d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a7	59		 pop	 ecx
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T165994[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::codecvt<char,char,int>::_Getcat
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 807  : 		return (iterator(_Lmost(), this));

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::begin
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 267  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 306  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 419  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 421  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 228  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>
; Function compile flags: /Ogtp
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 228  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>
; Function compile flags: /Ogtp
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 228  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??1?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $LN14@Pair_base@2
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN14@Pair_base@2:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi
  00025	c3		 ret	 0
??1?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T166271 = -16						; size = 12
$T166248 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00007	6a 28		 push	 40			; 00000028H
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 1a		 je	 SHORT $LN5@Buynode@3

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00024	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00027	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  0002a	66 89 48 24	 mov	 WORD PTR [eax+36], cx
  0002e	5e		 pop	 esi

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode@3:
  00033	8d 45 fc	 lea	 eax, DWORD PTR $T166248[ebp]
  00036	89 4d fc	 mov	 DWORD PTR $T166248[ebp], ecx
  00039	50		 push	 eax
  0003a	8d 4d f0	 lea	 ecx, DWORD PTR $T166271[ebp]
  0003d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00042	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00047	8d 4d f0	 lea	 ecx, DWORD PTR $T166271[ebp]
  0004a	51		 push	 ecx
  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T166271[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00052	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode@3:
$LN26@Buynode@3:
  00057	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?Init@CBloodCastle@@QAEX_N@Z			; CBloodCastle::Init
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\bloodcastle.cpp
;	COMDAT ?Init@CBloodCastle@@QAEX_N@Z
_TEXT	SEGMENT
tv542 = 8						; size = 4
_bEVENT_ENABLE$ = 8					; size = 1
?Init@CBloodCastle@@QAEX_N@Z PROC			; CBloodCastle::Init, COMDAT
; _this$ = ecx

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 135  : 	this->m_bBC_EVENT_ENABLE = bEVENT_ENABLE;

  00003	8a 45 08	 mov	 al, BYTE PTR _bEVENT_ENABLE$[ebp]
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi
  0000a	88 83 04 0e 00
	00		 mov	 BYTE PTR [ebx+3588], al
  00010	8d 8b e4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+228]
  00016	be 07 00 00 00	 mov	 esi, 7
  0001b	eb 03 8d 49 00	 npad	 5
$LL22@Init@3:

; 138  : 	{
; 139  : 		for ( int n=0;n<MAX_BLOOD_CASTLE_BOSS_MONSTER;n++)

  00020	8b c1		 mov	 eax, ecx
  00022	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  00027	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL19@Init@3:

; 140  : 		{
; 141  : 			this->m_BridgeData[i].m_iAngelKingPosNum = -1;

  00030	c7 81 b8 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+184], -1

; 142  : 			this->m_BridgeData[i].m_nBossMonsterPosNum[n] = -1;

  0003a	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00040	83 c0 04	 add	 eax, 4
  00043	4a		 dec	 edx
  00044	75 ea		 jne	 SHORT $LL19@Init@3

; 136  : 
; 137  : 	for ( int i=0; i<MAX_BLOOD_CASTLE_LEVEL ; i++ )

  00046	81 c1 00 02 00
	00		 add	 ecx, 512		; 00000200H
  0004c	4e		 dec	 esi
  0004d	75 d1		 jne	 SHORT $LL22@Init@3

; 143  : 		}
; 144  : 	}
; 145  : 
; 146  : 	for ( int n =0; n<gMSetBase.m_Count;n++)

  0004f	57		 push	 edi
  00050	33 ff		 xor	 edi, edi
  00052	39 3d e4 0f 01
	00		 cmp	 DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+69604, edi
  00058	0f 8e e4 00 00
	00		 jle	 $LN14@Init@3
  0005e	be 08 00 00 00	 mov	 esi, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A+8
  00063	89 75 08	 mov	 DWORD PTR tv542[ebp], esi
  00066	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL42@Init@3:

; 147  : 	{
; 148  : 		if ( BC_MAP_RANGE(gMSetBase.m_Mp[n].m_MapNumber ) != FALSE )

  00070	8a 16		 mov	 dl, BYTE PTR [esi]
  00072	80 fa 0b	 cmp	 dl, 11			; 0000000bH
  00075	0f 82 b1 00 00
	00		 jb	 $LN15@Init@3
  0007b	b1 11		 mov	 cl, 17			; 00000011H
  0007d	3a ca		 cmp	 cl, dl
  0007f	1b c0		 sbb	 eax, eax
  00081	40		 inc	 eax
  00082	0f 84 a4 00 00
	00		 je	 $LN15@Init@3

; 149  : 		{
; 150  : 			BYTE btMonsterType = gMSetBase.m_Mp[n].m_Type;

  00088	8a 46 fe	 mov	 al, BYTE PTR [esi-2]

; 151  : 			BYTE btMapNumber = gMSetBase.m_Mp[n].m_MapNumber;
; 152  : 			BYTE btBloodCastleIndex = btMapNumber - MAP_INDEX_BLOODCASTLE1;

  0008b	8d 4a f5	 lea	 ecx, DWORD PTR [edx-11]

; 153  : 
; 154  : 			if ( btMonsterType == 232 )

  0008e	3c e8		 cmp	 al, 232			; 000000e8H
  00090	75 12		 jne	 SHORT $LN12@Init@3

; 155  : 			{
; 156  : 				this->m_BridgeData[gMSetBase.m_Mp[n].m_MapNumber - MAP_INDEX_BLOODCASTLE1].m_iAngelKingPosNum = n;

  00092	0f b6 d2	 movzx	 edx, dl
  00095	c1 e2 09	 shl	 edx, 9
  00098	89 bc 1a 9c eb
	ff ff		 mov	 DWORD PTR [edx+ebx-5220], edi

; 157  : 				continue;

  0009f	e9 88 00 00 00	 jmp	 $LN15@Init@3
$LN12@Init@3:

; 158  : 			}
; 159  : 			
; 160  : 			if ( BC_STATUE_RANGE(btMonsterType - 132) != FALSE )

  000a4	0f b6 d0	 movzx	 edx, al
  000a7	8d b2 7c ff ff
	ff		 lea	 esi, DWORD PTR [edx-132]
  000ad	85 f6		 test	 esi, esi
  000af	78 1b		 js	 SHORT $LN40@Init@3
  000b1	33 d2		 xor	 edx, edx
  000b3	83 fe 02	 cmp	 esi, 2
  000b6	0f 9e c2	 setle	 dl
  000b9	85 d2		 test	 edx, edx
  000bb	74 0f		 je	 SHORT $LN40@Init@3

; 161  : 			{
; 162  : 				this->m_BridgeData[btBloodCastleIndex].m_nSaintStatuePosNum = n;

  000bd	0f b6 c1	 movzx	 eax, cl
  000c0	c1 e0 09	 shl	 eax, 9
  000c3	89 bc 18 34 01
	00 00		 mov	 DWORD PTR [eax+ebx+308], edi

; 163  : 				continue;

  000ca	eb 60		 jmp	 SHORT $LN15@Init@3
$LN40@Init@3:

; 164  : 			}
; 165  : 			
; 166  : 			if ( btMonsterType == 131 )

  000cc	3c 83		 cmp	 al, 131			; 00000083H
  000ce	75 0f		 jne	 SHORT $LN10@Init@3

; 167  : 			{
; 168  : 				this->m_BridgeData[btBloodCastleIndex].m_nCastleDoorPosNum = n;

  000d0	0f b6 c9	 movzx	 ecx, cl
  000d3	c1 e1 09	 shl	 ecx, 9
  000d6	89 bc 19 38 01
	00 00		 mov	 DWORD PTR [ecx+ebx+312], edi

; 169  : 				continue;

  000dd	eb 4d		 jmp	 SHORT $LN15@Init@3
$LN10@Init@3:

; 170  : 			}
; 171  : 			
; 172  : 			if ( btMonsterType == 89 || btMonsterType == 95 || btMonsterType == 112 || btMonsterType == 118 || btMonsterType == 124 || btMonsterType == 130 || btMonsterType == 143 )

  000df	3c 59		 cmp	 al, 89			; 00000059H
  000e1	74 18		 je	 SHORT $LN8@Init@3
  000e3	3c 5f		 cmp	 al, 95			; 0000005fH
  000e5	74 14		 je	 SHORT $LN8@Init@3
  000e7	3c 70		 cmp	 al, 112			; 00000070H
  000e9	74 10		 je	 SHORT $LN8@Init@3
  000eb	3c 76		 cmp	 al, 118			; 00000076H
  000ed	74 0c		 je	 SHORT $LN8@Init@3
  000ef	3c 7c		 cmp	 al, 124			; 0000007cH
  000f1	74 08		 je	 SHORT $LN8@Init@3
  000f3	3c 82		 cmp	 al, 130			; 00000082H
  000f5	74 04		 je	 SHORT $LN8@Init@3
  000f7	3c 8f		 cmp	 al, 143			; 0000008fH
  000f9	75 31		 jne	 SHORT $LN15@Init@3
$LN8@Init@3:

; 173  : 			{
; 174  : 				for ( int l=0;l<MAX_BLOOD_CASTLE_BOSS_MONSTER;l++)

  000fb	0f b6 c9	 movzx	 ecx, cl
  000fe	8b d1		 mov	 edx, ecx
  00100	33 c0		 xor	 eax, eax
  00102	c1 e2 09	 shl	 edx, 9
  00105	8d 94 1a e4 00
	00 00		 lea	 edx, DWORD PTR [edx+ebx+228]
  0010c	8d 64 24 00	 npad	 4
$LL7@Init@3:

; 175  : 				{
; 176  : 					if ( this->m_BridgeData[btBloodCastleIndex].m_nBossMonsterPosNum[l] == -1 )

  00110	83 3a ff	 cmp	 DWORD PTR [edx], -1
  00113	74 0b		 je	 SHORT $LN34@Init@3

; 173  : 			{
; 174  : 				for ( int l=0;l<MAX_BLOOD_CASTLE_BOSS_MONSTER;l++)

  00115	40		 inc	 eax
  00116	83 c2 04	 add	 edx, 4
  00119	83 f8 14	 cmp	 eax, 20			; 00000014H
  0011c	7c f2		 jl	 SHORT $LL7@Init@3

; 175  : 				{
; 176  : 					if ( this->m_BridgeData[btBloodCastleIndex].m_nBossMonsterPosNum[l] == -1 )

  0011e	eb 0c		 jmp	 SHORT $LN15@Init@3
$LN34@Init@3:

; 177  : 					{
; 178  : 						this->m_BridgeData[btBloodCastleIndex].m_nBossMonsterPosNum[l] = n;

  00120	c1 e1 07	 shl	 ecx, 7
  00123	03 c8		 add	 ecx, eax
  00125	89 bc 8b e4 00
	00 00		 mov	 DWORD PTR [ebx+ecx*4+228], edi
$LN15@Init@3:

; 143  : 		}
; 144  : 	}
; 145  : 
; 146  : 	for ( int n =0; n<gMSetBase.m_Count;n++)

  0012c	8b 75 08	 mov	 esi, DWORD PTR tv542[ebp]
  0012f	47		 inc	 edi
  00130	83 c6 0c	 add	 esi, 12			; 0000000cH
  00133	89 75 08	 mov	 DWORD PTR tv542[ebp], esi
  00136	3b 3d e4 0f 01
	00		 cmp	 edi, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+69604
  0013c	0f 8c 2e ff ff
	ff		 jl	 $LL42@Init@3
$LN14@Init@3:

; 179  : 						break;
; 180  : 					}
; 181  : 				}
; 182  : 			}
; 183  : 		}
; 184  : 
; 185  : 	}
; 186  : 
; 187  : 	for ( int i=0;i<MAX_BLOOD_CASTLE_LEVEL;i++)

  00142	33 f6		 xor	 esi, esi
  00144	5f		 pop	 edi
$LL3@Init@3:

; 188  : 	{
; 189  : 		this->SetState(i, BC_STATE_CLOSED);

  00145	6a 01		 push	 1
  00147	56		 push	 esi
  00148	8b cb		 mov	 ecx, ebx
  0014a	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
  0014f	46		 inc	 esi
  00150	83 fe 07	 cmp	 esi, 7
  00153	7c f0		 jl	 SHORT $LL3@Init@3
  00155	5e		 pop	 esi
  00156	5b		 pop	 ebx

; 190  : 	}
; 191  : }

  00157	5d		 pop	 ebp
  00158	c2 04 00	 ret	 4
?Init@CBloodCastle@@QAEX_N@Z ENDP			; CBloodCastle::Init
_TEXT	ENDS
PUBLIC	?Run@CBloodCastle@@QAEXXZ			; CBloodCastle::Run
; Function compile flags: /Ogtp
;	COMDAT ?Run@CBloodCastle@@QAEXXZ
_TEXT	SEGMENT
?Run@CBloodCastle@@QAEXXZ PROC				; CBloodCastle::Run, COMDAT
; _this$ = ecx

; 451  : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 452  : 	if ( this->m_bBC_EVENT_ENABLE != false )

  00003	80 bb 04 0e 00
	00 00		 cmp	 BYTE PTR [ebx+3588], 0
  0000a	74 42		 je	 SHORT $LN7@Run

; 453  : 	{
; 454  : 		for (int iBridgeIndex=0;iBridgeIndex<MAX_BLOOD_CASTLE_LEVEL;iBridgeIndex++)

  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	33 f6		 xor	 esi, esi
  00010	8d bb 50 01 00
	00		 lea	 edi, DWORD PTR [ebx+336]
$LL9@Run:

; 455  : 		{
; 456  : 			switch ( this->m_BridgeData[iBridgeIndex].m_iBC_STATE )

  00016	8b 07		 mov	 eax, DWORD PTR [edi]
  00018	83 f8 03	 cmp	 eax, 3
  0001b	77 23		 ja	 SHORT $LN8@Run
  0001d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN15@Run[eax*4]
$LN3@Run:

; 457  : 			{
; 458  : 				case BC_STATE_NONE:
; 459  : 					this->ProcState_None(iBridgeIndex);
; 460  : 					break;
; 461  : 
; 462  : 				case BC_STATE_CLOSED:
; 463  : 					this->ProcState_Closed(iBridgeIndex);

  00024	56		 push	 esi
  00025	8b cb		 mov	 ecx, ebx
  00027	e8 00 00 00 00	 call	 ?ProcState_Closed@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_Closed

; 464  : 					break;

  0002c	eb 12		 jmp	 SHORT $LN8@Run
$LN2@Run:

; 465  : 
; 466  : 				case BC_STATE_PLAYING:
; 467  : 					this->ProcState_Playing(iBridgeIndex);

  0002e	56		 push	 esi
  0002f	8b cb		 mov	 ecx, ebx
  00031	e8 00 00 00 00	 call	 ?ProcState_Playing@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_Playing

; 468  : 					break;

  00036	eb 08		 jmp	 SHORT $LN8@Run
$LN1@Run:

; 469  : 
; 470  : 				case BC_STATE_PLAYEND:
; 471  : 					this->ProcState_PlayEnd(iBridgeIndex);

  00038	56		 push	 esi
  00039	8b cb		 mov	 ecx, ebx
  0003b	e8 00 00 00 00	 call	 ?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_PlayEnd
$LN8@Run:

; 453  : 	{
; 454  : 		for (int iBridgeIndex=0;iBridgeIndex<MAX_BLOOD_CASTLE_LEVEL;iBridgeIndex++)

  00040	46		 inc	 esi
  00041	81 c7 00 02 00
	00		 add	 edi, 512		; 00000200H
  00047	83 fe 07	 cmp	 esi, 7
  0004a	7c ca		 jl	 SHORT $LL9@Run
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
$LN7@Run:
  0004e	5b		 pop	 ebx

; 472  : 					break;
; 473  : 			}
; 474  : 		}
; 475  : 
; 476  : 
; 477  : #if (FOREIGN_GAMESERVER==1)
; 478  : 		if ( szAuthKey[13] != AUTHKEY13 )
; 479  : 		{
; 480  : 			DestroyGIocp();
; 481  : 		}
; 482  : #endif
; 483  : 
; 484  : 	}
; 485  : 
; 486  : }

  0004f	c3		 ret	 0
$LN15@Run:
  00050	00 00 00 00	 DD	 $LN8@Run
  00054	00 00 00 00	 DD	 $LN3@Run
  00058	00 00 00 00	 DD	 $LN2@Run
  0005c	00 00 00 00	 DD	 $LN1@Run
?Run@CBloodCastle@@QAEXXZ ENDP				; CBloodCastle::Run
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z
_TEXT	SEGMENT
$T166424 = -16						; size = 12
$T166358 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN20@Tree
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 699  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 698  : 		{	// construct empty tree

$LN20@Tree:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T166358[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T166424[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T166358[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T166424[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T166424[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@Tree:
$LN42@Tree:
  0006e	cc		 int	 3
??0?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 272  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++

; 273  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 274  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 570  : 		{	// flush output stream

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 571  : 		ios_base::iostate _State = ios_base::goodbit;
; 572  : 		if (!ios_base::fail() && _Myios::rdbuf()->pubsync() == -1)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	f6 44 30 0c 06	 test	 BYTE PTR [eax+esi+12], 6
  00010	75 17		 jne	 SHORT $LN1@flush
  00012	8b 44 30 38	 mov	 eax, DWORD PTR [eax+esi+56]
  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	8b c8		 mov	 ecx, eax
  0001a	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0001d	ff d0		 call	 eax
  0001f	83 f8 ff	 cmp	 eax, -1
  00022	75 05		 jne	 SHORT $LN1@flush

; 573  : 			_State |= ios_base::badbit;	// sync failed

  00024	bf 04 00 00 00	 mov	 edi, 4
$LN1@flush:

; 574  : 		_Myios::setstate(_State);

  00029	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002e	03 ce		 add	 ecx, esi
  00030	85 ff		 test	 edi, edi
  00032	74 16		 je	 SHORT $LN21@flush
  00034	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00037	0b c7		 or	 eax, edi
  00039	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0003d	75 03		 jne	 SHORT $LN19@flush
  0003f	83 c8 04	 or	 eax, 4
$LN19@flush:
  00042	6a 00		 push	 0
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN21@flush:

; 575  : 		return (*this);

  0004a	5f		 pop	 edi
  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi

; 576  : 		}

  0004e	c3		 ret	 0
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (iterator(this->_Myhead, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 818  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (iterator(this->_Myhead, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 818  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::end
_TEXT	ENDS
PUBLIC	??1?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
;	COMDAT ??1?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $LN16@pair
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN16@pair:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi
  00025	c3		 ret	 0
??1?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0
__ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
xdata$x	ENDS
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT
__Lock$166679 = -20					; size = 4
$T166655 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Byte$ = 8						; size = 1
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT
; _this$ = ecx

; 124  : 		{	// convert _Byte to character using imbued locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 125  : 		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);

  00028	8d 45 f0	 lea	 eax, DWORD PTR $T166655[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00031	50		 push	 eax
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00039	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0003e	8b 7d f0	 mov	 edi, DWORD PTR $T166655[ebp]
  00041	83 c4 04	 add	 esp, 4
  00044	8b d8		 mov	 ebx, eax
  00046	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004d	85 ff		 test	 edi, edi
  0004f	74 39		 je	 SHORT $LN7@widen
  00051	6a 00		 push	 0
  00053	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$166679[ebp]
  00056	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  0005b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0005e	85 c0		 test	 eax, eax
  00060	74 09		 je	 SHORT $LN9@widen
  00062	83 f8 ff	 cmp	 eax, -1
  00065	73 04		 jae	 SHORT $LN9@widen
  00067	48		 dec	 eax
  00068	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN9@widen:
  0006b	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0006e	f7 de		 neg	 esi
  00070	1b f6		 sbb	 esi, esi
  00072	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$166679[ebp]
  00075	f7 d6		 not	 esi
  00077	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0007c	23 f7		 and	 esi, edi
  0007e	74 0a		 je	 SHORT $LN7@widen
  00080	8b 16		 mov	 edx, DWORD PTR [esi]
  00082	8b 02		 mov	 eax, DWORD PTR [edx]
  00084	6a 01		 push	 1
  00086	8b ce		 mov	 ecx, esi
  00088	ff d0		 call	 eax
$LN7@widen:

; 126  : 		return (_Ctype_fac.widen(_Byte));

  0008a	8b 13		 mov	 edx, DWORD PTR [ebx]
  0008c	8b 45 08	 mov	 eax, DWORD PTR __Byte$[ebp]
  0008f	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00092	50		 push	 eax
  00093	8b cb		 mov	 ecx, ebx
  00095	ff d2		 call	 edx

; 127  : 		}

  00097	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a1	59		 pop	 ecx
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR $T166655[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$12 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0
__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$12
__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T166694 = 8						; size = 4
__Noskip$ = 8						; size = 1
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT
; _this$ = ecx

; 116  : 		{	// test stream state and skip whitespace as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 117  : 		if (ios_base::good())

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00035	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
  00039	03 ce		 add	 ecx, esi
  0003b	85 c0		 test	 eax, eax
  0003d	0f 85 28 01 00
	00		 jne	 $LN1@Ipfx

; 118  : 			{	// state okay, flush tied stream and skip whitespace
; 119  : 			if (_Myios::tie() != 0)

  00043	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  00046	85 c9		 test	 ecx, ecx
  00048	74 05		 je	 SHORT $LN10@Ipfx

; 120  : 				_Myios::tie()->flush();

  0004a	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN10@Ipfx:

; 121  : 
; 122  : 			if (!_Noskip && ios_base::flags() & ios_base::skipws)

  0004f	80 7d 08 00	 cmp	 BYTE PTR __Noskip$[ebp], 0
  00053	0f 85 a0 00 00
	00		 jne	 $LN17@Ipfx
  00059	8b 06		 mov	 eax, DWORD PTR [esi]
  0005b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005e	8b 4c 32 14	 mov	 ecx, DWORD PTR [edx+esi+20]
  00062	f6 c1 01	 test	 cl, 1
  00065	0f 84 8e 00 00
	00		 je	 $LN17@Ipfx

; 123  : 				{	// skip whitespace
; 124  : 				const _Ctype& _Ctype_fac = _USE(ios_base::getloc(), _Ctype);

  0006b	8d 4d 08	 lea	 ecx, DWORD PTR $T166694[ebp]
  0006e	51		 push	 ecx
  0006f	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  00072	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00077	50		 push	 eax
  00078	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0007f	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00084	83 c4 04	 add	 esp, 4
  00087	8d 4d 08	 lea	 ecx, DWORD PTR $T166694[ebp]
  0008a	8b f8		 mov	 edi, eax
  0008c	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 125  : 
; 126  : 				_TRY_IO_BEGIN
; 127  : 				int_type _Meta = _Myios::rdbuf()->sgetc();

  00091	8b 16		 mov	 edx, DWORD PTR [esi]
  00093	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00096	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  0009a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0009d	83 38 00	 cmp	 DWORD PTR [eax], 0
  000a0	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  000a7	74 0f		 je	 SHORT $LN33@Ipfx
  000a9	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000ac	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000af	7e 07		 jle	 SHORT $LN33@Ipfx
  000b1	8b 00		 mov	 eax, DWORD PTR [eax]
  000b3	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000b6	eb 08		 jmp	 SHORT $LL144@Ipfx
$LN33@Ipfx:
  000b8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ba	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000bd	ff d2		 call	 edx
  000bf	90		 npad	 1
$LL144@Ipfx:

; 130  : 					if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000c0	83 f8 ff	 cmp	 eax, -1
  000c3	75 21		 jne	 SHORT $LN4@Ipfx

; 131  : 						{	// end of file, quit
; 132  : 						_Myios::setstate(ios_base::eofbit);

  000c5	8b 06		 mov	 eax, DWORD PTR [esi]
  000c7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ca	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
  000ce	03 ce		 add	 ecx, esi
  000d0	83 c8 01	 or	 eax, 1
  000d3	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  000d7	75 03		 jne	 SHORT $LN56@Ipfx
  000d9	83 c8 04	 or	 eax, 4
$LN56@Ipfx:
  000dc	6a 00		 push	 0
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 133  : 						break;

  000e4	eb 0c		 jmp	 SHORT $LN5@Ipfx
$LN4@Ipfx:

; 134  : 						}
; 135  : 					else if (!_Ctype_fac.is(_Ctype::space,
; 136  : 						_Traits::to_char_type(_Meta)))

  000e6	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  000e9	0f b6 c8	 movzx	 ecx, al
  000ec	f6 04 4a 48	 test	 BYTE PTR [edx+ecx*2], 72 ; 00000048H
  000f0	75 2a		 jne	 SHORT $LN6@Ipfx
$LN5@Ipfx:
  000f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN17@Ipfx:

; 139  : 				}
; 140  : 
; 141  : 			if (ios_base::good())

  000f9	8b 06		 mov	 eax, DWORD PTR [esi]
  000fb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fe	03 ce		 add	 ecx, esi
  00100	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00104	75 65		 jne	 SHORT $LN1@Ipfx

; 142  : 				return (true);

  00106	b0 01		 mov	 al, 1

; 146  : 		}

  00108	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0010b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00112	59		 pop	 ecx
  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c2 04 00	 ret	 4
$LN6@Ipfx:

; 128  : 
; 129  : 				for (; ; _Meta = _Myios::rdbuf()->snextc())

  0011c	8b 06		 mov	 eax, DWORD PTR [esi]
  0011e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00121	8b 4c 31 38	 mov	 ecx, DWORD PTR [ecx+esi+56]
  00125	e8 00 00 00 00	 call	 ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
  0012a	eb 94		 jmp	 SHORT $LL144@Ipfx
__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0:

; 137  : 						break;	// not whitespace, quit
; 138  : 				_CATCH_IO_END

  0012c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00131	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00134	03 c1		 add	 eax, ecx
  00136	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00139	83 c9 04	 or	 ecx, 4
  0013c	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00140	75 03		 jne	 SHORT $LN69@Ipfx
  00142	83 c9 04	 or	 ecx, 4
$LN69@Ipfx:
  00145	83 e1 17	 and	 ecx, 23			; 00000017H
  00148	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0014b	85 48 10	 test	 DWORD PTR [eax+16], ecx
  0014e	75 12		 jne	 SHORT $LN78@Ipfx
  00150	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00157	b8 00 00 00 00	 mov	 eax, $LN18@Ipfx
  0015c	c3		 ret	 0
$LN18@Ipfx:
  0015d	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00160	eb 97		 jmp	 SHORT $LN17@Ipfx
$LN78@Ipfx:
  00162	6a 00		 push	 0
  00164	6a 00		 push	 0
  00166	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN151@Ipfx:
$LN1@Ipfx:

; 143  : 			}
; 144  : 		_Myios::setstate(ios_base::failbit);

  0016b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0016e	83 c8 02	 or	 eax, 2
  00171	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00175	75 03		 jne	 SHORT $LN140@Ipfx
  00177	83 c8 04	 or	 eax, 4
$LN140@Ipfx:
  0017a	6a 00		 push	 0
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 145  : 		return (false);

  00182	32 c0		 xor	 al, al

; 146  : 		}

  00184	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00187	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0018e	59		 pop	 ecx
  0018f	5f		 pop	 edi
  00190	5e		 pop	 esi
  00191	5b		 pop	 ebx
  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c2 04 00	 ret	 4
$LN150@Ipfx:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR $T166694[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
$T167238 = -16						; size = 12
$T167180 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 30		 push	 48			; 00000030H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN20@Tree@2
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 2c	 mov	 BYTE PTR [ecx+44], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 2d	 mov	 BYTE PTR [edx+45], al

; 699  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 698  : 		{	// construct empty tree

$LN20@Tree@2:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T167180[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T167238[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T167180[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T167238[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T167238[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@Tree@2:
$LN42@Tree@2:
  0006e	cc		 int	 3
??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::lower_bound
; Function compile flags: /Ogtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0000d	75 19		 jne	 SHORT $LN36@lower_boun
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL6@lower_boun:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	73 05		 jae	 SHORT $LN4@lower_boun
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN4@lower_boun:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun:
  00022	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00026	74 ec		 je	 SHORT $LL6@lower_boun
$LN36@lower_boun:
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z
_TEXT	SEGMENT
$T167450 = -16						; size = 12
$T167391 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN20@Tree@3
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 699  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 698  : 		{	// construct empty tree

$LN20@Tree@3:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T167391[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T167450[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T167391[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T167450[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T167450[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@Tree@3:
$LN42@Tree@3:
  0006e	cc		 int	 3
??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (iterator(this->_Myhead, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 818  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::end
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::lower_bound
; Function compile flags: /Ogtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0000d	75 19		 jne	 SHORT $LN36@lower_boun@2
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL6@lower_boun@2:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	73 05		 jae	 SHORT $LN4@lower_boun@2
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $LN3@lower_boun@2
$LN4@lower_boun@2:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun@2:
  00022	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00026	74 ec		 je	 SHORT $LL6@lower_boun@2
$LN36@lower_boun@2:
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::lower_bound
; Function compile flags: /Ogtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0000d	75 19		 jne	 SHORT $LN36@lower_boun@3
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL6@lower_boun@3:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	73 05		 jae	 SHORT $LN4@lower_boun@3
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $LN3@lower_boun@3
$LN4@lower_boun@3:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun@3:
  00022	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00026	74 ec		 je	 SHORT $LL6@lower_boun@3
$LN36@lower_boun@3:
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
	DD	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
_TEXT	SEGMENT
__File$ = 8						; size = 4
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 152  : 		{	// construct from pointer to C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >

; 153  : 		_Init(_File, _Newfl);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __File$[ebp]
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	8b ce		 mov	 ecx, esi
  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00019	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 154  : 		}

  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z		; std::_Fgetc<char>
EXTRN	_fgetc:PROC
; Function compile flags: /Ogtp
;	COMDAT ??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 4
__File$ = 12						; size = 4
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT

; 35   : 	{	// get a char element from a C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   : 	int _Meta;
; 37   : 	if ((_Meta = fgetc(_File)) == EOF)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __File$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _fgetc
  0000c	83 c4 04	 add	 esp, 4
  0000f	83 f8 ff	 cmp	 eax, -1
  00012	75 04		 jne	 SHORT $LN2@Fgetc

; 38   : 		return (false);

  00014	32 c0		 xor	 al, al

; 43   : 		}
; 44   : 	}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN2@Fgetc:

; 39   : 	else
; 40   : 		{	// got one, convert to char
; 41   : 		_Byte = (char)_Meta;

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Byte$[ebp]
  0001b	88 01		 mov	 BYTE PTR [ecx], al

; 42   : 		return (true);

  0001d	b0 01		 mov	 al, 1

; 43   : 		}
; 44   : 	}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
PUBLIC	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z		; std::_Fputc<char>
EXTRN	_fputc:PROC
; Function compile flags: /Ogtp
;	COMDAT ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
__File$ = 12						; size = 4
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT

; 80   : 	{	// put a char element to a C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 81   : 	return (fputc(_Byte, _File) != EOF);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __File$[ebp]
  00006	0f be 4d 08	 movsx	 ecx, BYTE PTR __Byte$[ebp]
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _fputc
  00011	33 d2		 xor	 edx, edx
  00013	83 c4 08	 add	 esp, 8
  00016	83 f8 ff	 cmp	 eax, -1
  00019	0f 95 c0	 setne	 al

; 82   : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
PUBLIC	??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z		; std::_Ungetc<char>
EXTRN	_ungetc:PROC
; Function compile flags: /Ogtp
;	COMDAT ??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 4
__File$ = 12						; size = 4
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT

; 104  : 	{	// put back a char element to a C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 105  : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Byte$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __File$[ebp]
  00009	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0000c	50		 push	 eax
  0000d	52		 push	 edx
  0000e	e8 00 00 00 00	 call	 _ungetc
  00013	33 c9		 xor	 ecx, ecx
  00015	83 c4 08	 add	 esp, 8
  00018	83 f8 ff	 cmp	 eax, -1
  0001b	0f 95 c0	 setne	 al

; 106  : 	}

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
EXTRN	__lock_file:PROC
; Function compile flags: /Ogtp
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 309  : 		if (_Myfile)

  00000	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $LN1@Lock

; 310  : 			_CSTD _lock_file(_Myfile);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 __lock_file
  0000d	59		 pop	 ecx
$LN1@Lock:

; 311  : 		}

  0000e	c3		 ret	 0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
EXTRN	__unlock_file:PROC
; Function compile flags: /Ogtp
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 315  : 		if (_Myfile)

  00000	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $LN1@Unlock

; 316  : 			_CSTD _unlock_file(_Myfile);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 __unlock_file
  0000d	59		 pop	 ecx
$LN1@Unlock:

; 317  : 		}

  0000e	c3		 ret	 0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
EXTRN	_fflush:PROC
; Function compile flags: /Ogtp
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 543  : 		{	// synchronize C stream with external file

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 544  : 		return (_Myfile == 0
; 545  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 546  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);

  00003	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  00007	74 23		 je	 SHORT $LN3@sync
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0000e	6a ff		 push	 -1
  00010	ff d2		 call	 edx
  00012	83 f8 ff	 cmp	 eax, -1
  00015	74 15		 je	 SHORT $LN3@sync
  00017	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _fflush
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	79 05		 jns	 SHORT $LN3@sync
  00027	83 c8 ff	 or	 eax, -1
  0002a	5e		 pop	 esi

; 547  : 		}

  0002b	c3		 ret	 0
$LN3@sync:

; 544  : 		return (_Myfile == 0
; 545  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 546  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 547  : 		}

  0002f	c3		 ret	 0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
PUBLIC	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::egptr, COMDAT
; _this$ = ecx

; 238  : 		return (*_IGnext + *_IGcount);

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	03 01		 add	 eax, DWORD PTR [ecx]

; 239  : 		}

  0000a	c3		 ret	 0
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::egptr
_TEXT	ENDS
PUBLIC	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
; Function compile flags: /Ogtp
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::epptr, COMDAT
; _this$ = ecx

; 256  : 		return (*_IPnext + *_IPcount);

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00003	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	03 01		 add	 eax, DWORD PTR [ecx]

; 257  : 		}

  0000a	c3		 ret	 0
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::epptr
_TEXT	ENDS
PUBLIC	?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec
; Function compile flags: /Ogtp
;	COMDAT ?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec, COMDAT
; _this$ = ecx

; 261  : 		++*_IGcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 00		 inc	 DWORD PTR [eax]

; 262  : 		return (--*_IGnext);

  00005	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	48		 dec	 eax
  0000b	89 01		 mov	 DWORD PTR [ecx], eax

; 263  : 		}

  0000d	c3		 ret	 0
?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec
_TEXT	ENDS
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
; Function compile flags: /Ogtp
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 304  : 		--*_IPcount;

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 305  : 		return ((*_IPnext)++);

  00005	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000d	89 11		 mov	 DWORD PTR [ecx], edx

; 306  : 		}

  0000f	c3		 ret	 0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
PUBLIC	??0?$fpos@H@std@@QAE@H_J@Z			; std::fpos<int>::fpos<int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ??0?$fpos@H@std@@QAE@H_J@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Fileposition$ = 12					; size = 8
??0?$fpos@H@std@@QAE@H_J@Z PROC				; std::fpos<int>::fpos<int>, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with conversion state and C file position

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 10	 mov	 edx, DWORD PTR __Fileposition$[ebp+4]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR __Fileposition$[ebp]
  0000b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __State$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00017	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001e	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00021	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 46   : 		}

  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??0?$fpos@H@std@@QAE@H_J@Z ENDP				; std::fpos<int>::fpos<int>
_TEXT	ENDS
PUBLIC	?state@?$fpos@H@std@@QBEHXZ			; std::fpos<int>::state
; Function compile flags: /Ogtp
;	COMDAT ?state@?$fpos@H@std@@QBEHXZ
_TEXT	SEGMENT
?state@?$fpos@H@std@@QBEHXZ PROC			; std::fpos<int>::state, COMDAT
; _this$ = ecx

; 50   : 		return (_Mystate);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 51   : 		}

  00003	c3		 ret	 0
?state@?$fpos@H@std@@QBEHXZ ENDP			; std::fpos<int>::state
_TEXT	ENDS
PUBLIC	?seekpos@?$fpos@H@std@@QBE_JXZ			; std::fpos<int>::seekpos
; Function compile flags: /Ogtp
;	COMDAT ?seekpos@?$fpos@H@std@@QBE_JXZ
_TEXT	SEGMENT
?seekpos@?$fpos@H@std@@QBE_JXZ PROC			; std::fpos<int>::seekpos, COMDAT
; _this$ = ecx

; 60   : 		return (_Fpos);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]

; 61   : 		}

  00006	c3		 ret	 0
?seekpos@?$fpos@H@std@@QBE_JXZ ENDP			; std::fpos<int>::seekpos
_TEXT	ENDS
PUBLIC	??B?$fpos@H@std@@QBE_JXZ			; std::fpos<int>::operator __int64
; Function compile flags: /Ogtp
;	COMDAT ??B?$fpos@H@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@H@std@@QBE_JXZ PROC				; std::fpos<int>::operator __int64, COMDAT
; _this$ = ecx

; 65   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	99		 cdq
  00004	03 01		 add	 eax, DWORD PTR [ecx]
  00006	13 51 04	 adc	 edx, DWORD PTR [ecx+4]

; 66   : 		}

  00009	c3		 ret	 0
??B?$fpos@H@std@@QBE_JXZ ENDP				; std::fpos<int>::operator __int64
_TEXT	ENDS
PUBLIC	?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::in
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC	; std::codecvt<char,char,int>::in, COMDAT
; _this$ = ecx

; 808  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 809  : 		return (do_in(_State,
; 810  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 811  : 		}

  00008	5d		 pop	 ebp

; 809  : 		return (do_in(_State,
; 810  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

  00009	ff e0		 jmp	 eax
?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP	; std::codecvt<char,char,int>::in
_TEXT	ENDS
PUBLIC	?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::out
; Function compile flags: /Ogtp
;	COMDAT ?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,int>::out, COMDAT
; _this$ = ecx

; 816  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last2)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (do_out(_State,
; 818  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 819  : 		}

  00008	5d		 pop	 ebp

; 817  : 		return (do_out(_State,
; 818  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

  00009	ff e0		 jmp	 eax
?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::out
_TEXT	ENDS
PUBLIC	?not_eof@?$char_traits@D@std@@SAHABH@Z		; std::char_traits<char>::not_eof
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC		; std::char_traits<char>::not_eof, COMDAT

; 557  : 		{	// return anything but EOF

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 558  : 		return (_Meta != eof() ? _Meta : !eof());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0000b	f7 d8		 neg	 eax
  0000d	1b c0		 sbb	 eax, eax
  0000f	23 c1		 and	 eax, ecx

; 559  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 408  : 		{	// get an element from stream, but don't point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 409  : 		int_type _Meta;
; 410  : 		if (_Mysb::gptr() != 0
; 411  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00003	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	85 c9		 test	 ecx, ecx
  0000a	74 12		 je	 SHORT $LN4@underflow
  0000c	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0000f	8b 12		 mov	 edx, DWORD PTR [edx]
  00011	8b c1		 mov	 eax, ecx
  00013	03 d0		 add	 edx, eax
  00015	3b c2		 cmp	 eax, edx
  00017	73 05		 jae	 SHORT $LN4@underflow

; 412  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

  00019	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0001c	5e		 pop	 esi

; 419  : 			}
; 420  : 		}

  0001d	c3		 ret	 0
$LN4@underflow:

; 413  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
  00020	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00023	57		 push	 edi
  00024	8b ce		 mov	 ecx, esi
  00026	ff d2		 call	 edx
  00028	8b f8		 mov	 edi, eax
  0002a	83 ff ff	 cmp	 edi, -1
  0002d	75 05		 jne	 SHORT $LN2@underflow

; 414  : 			return (_Meta);	// uflow failed, return EOF

  0002f	5f		 pop	 edi
  00030	0b c0		 or	 eax, eax
  00032	5e		 pop	 esi

; 419  : 			}
; 420  : 		}

  00033	c3		 ret	 0
$LN2@underflow:

; 415  : 		else
; 416  : 			{	// get a char, don't point past it
; 417  : 			pbackfail(_Meta);

  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00039	57		 push	 edi
  0003a	8b ce		 mov	 ecx, esi
  0003c	ff d2		 call	 edx

; 418  : 			return (_Meta);

  0003e	8b c7		 mov	 eax, edi
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 419  : 			}
; 420  : 		}

  00042	c3		 ret	 0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
; Function compile flags: /Ogtp
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT
; _this$ = ecx

; 647  : 		if (_Mysb::eback() != &_Mychar)

  00000	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00003	56		 push	 esi
  00004	8b 32		 mov	 esi, DWORD PTR [edx]
  00006	8d 41 48	 lea	 eax, DWORD PTR [ecx+72]
  00009	3b f0		 cmp	 esi, eax
  0000b	74 12		 je	 SHORT $LN1@Set_back

; 648  : 			{	// save current get buffer
; 649  : 			_Set_eback = _Mysb::eback();

  0000d	89 71 3c	 mov	 DWORD PTR [ecx+60], esi

; 650  : 			_Set_egptr = _Mysb::egptr();

  00010	8b 71 30	 mov	 esi, DWORD PTR [ecx+48]
  00013	8b 36		 mov	 esi, DWORD PTR [esi]
  00015	57		 push	 edi
  00016	8b 79 20	 mov	 edi, DWORD PTR [ecx+32]
  00019	03 37		 add	 esi, DWORD PTR [edi]
  0001b	5f		 pop	 edi
  0001c	89 71 40	 mov	 DWORD PTR [ecx+64], esi
$LN1@Set_back:

; 651  : 			}
; 652  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00024	89 02		 mov	 DWORD PTR [edx], eax
  00026	8b d1		 mov	 edx, ecx
  00028	2b d0		 sub	 edx, eax
  0002a	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0002d	83 c2 49	 add	 edx, 73			; 00000049H
  00030	89 10		 mov	 DWORD PTR [eax], edx
  00032	5e		 pop	 esi

; 653  : 		}

  00033	c3		 ret	 0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 383  : 		{	// put an element back to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 384  : 		if (_Mysb::gptr() != 0
; 385  : 			&& _Mysb::eback() < _Mysb::gptr()
; 386  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)
; 387  : 			|| _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
; 388  : 				_Meta)))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	85 c0		 test	 eax, eax
  00011	74 2d		 je	 SHORT $LN10@pbackfail
  00013	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00016	39 01		 cmp	 DWORD PTR [ecx], eax
  00018	73 26		 jae	 SHORT $LN10@pbackfail
  0001a	83 fb ff	 cmp	 ebx, -1
  0001d	74 08		 je	 SHORT $LN9@pbackfail
  0001f	0f b6 50 ff	 movzx	 edx, BYTE PTR [eax-1]
  00023	3b d3		 cmp	 edx, ebx
  00025	75 19		 jne	 SHORT $LN10@pbackfail
$LN9@pbackfail:

; 389  : 			{	// just back up position
; 390  : 			_Mysb::_Gndec();

  00027	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0002a	ff 00		 inc	 DWORD PTR [eax]
  0002c	8b 76 20	 mov	 esi, DWORD PTR [esi+32]
  0002f	ff 0e		 dec	 DWORD PTR [esi]

; 391  : 			return (_Traits::not_eof(_Meta));

  00031	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00034	f7 d8		 neg	 eax
  00036	1b c0		 sbb	 eax, eax
  00038	5e		 pop	 esi
  00039	23 c3		 and	 eax, ebx
  0003b	5b		 pop	 ebx

; 402  : 			}
; 403  : 		else
; 404  : 			return (_Traits::eof());	// nowhere to put back
; 405  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
$LN10@pbackfail:

; 392  : 			}
; 393  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

  00040	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00043	85 c0		 test	 eax, eax
  00045	74 38		 je	 SHORT $LN6@pbackfail
  00047	83 fb ff	 cmp	 ebx, -1
  0004a	74 33		 je	 SHORT $LN6@pbackfail

; 395  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

  0004c	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  00050	75 12		 jne	 SHORT $LN4@pbackfail
  00052	50		 push	 eax
  00053	0f b6 c3	 movzx	 eax, bl
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _ungetc
  0005c	83 c4 08	 add	 esp, 8
  0005f	83 f8 ff	 cmp	 eax, -1

; 396  : 			return (_Meta);	// no facet and unget succeeded, return

  00062	75 13		 jne	 SHORT $LN55@pbackfail
$LN4@pbackfail:

; 397  : 		else if (_Mysb::gptr() != &_Mychar)

  00064	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00067	8d 46 48	 lea	 eax, DWORD PTR [esi+72]
  0006a	39 01		 cmp	 DWORD PTR [ecx], eax
  0006c	74 11		 je	 SHORT $LN6@pbackfail

; 398  : 			{	// putback to _Mychar
; 399  : 			_Mychar = _Traits::to_char_type(_Meta);
; 400  : 			_Set_back();	// switch to _Mychar buffer

  0006e	8b ce		 mov	 ecx, esi
  00070	88 18		 mov	 BYTE PTR [eax], bl
  00072	e8 00 00 00 00	 call	 ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
$LN55@pbackfail:

; 401  : 			return (_Meta);

  00077	5e		 pop	 esi
  00078	8b c3		 mov	 eax, ebx
  0007a	5b		 pop	 ebx

; 402  : 			}
; 403  : 		else
; 404  : 			return (_Traits::eof());	// nowhere to put back
; 405  : 		}

  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
$LN6@pbackfail:
  0007f	5e		 pop	 esi

; 394  : 			return (_Traits::eof());	// no open C stream or EOF, fail

  00080	83 c8 ff	 or	 eax, -1
  00083	5b		 pop	 ebx

; 402  : 			}
; 403  : 		else
; 404  : 			return (_Traits::eof());	// nowhere to put back
; 405  : 		}

  00084	5d		 pop	 ebp
  00085	c2 04 00	 ret	 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
EXTRN	_setvbuf:PROC
; Function compile flags: /Ogtp
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Count$ = 12						; size = 8
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 530  : 		{	// offer _Buffer to C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 531  : 		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,
; 532  : 			_Buffer == 0 && _Count == 0 ? _IONBF : _IOFBF,
; 533  : 			(size_t)_Count * sizeof (_Elem)) != 0)

  00006	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  00009	85 c9		 test	 ecx, ecx
  0000b	74 40		 je	 SHORT $LN2@setbuf
  0000d	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  00014	85 d2		 test	 edx, edx
  00016	75 0e		 jne	 SHORT $LN6@setbuf
  00018	8b c6		 mov	 eax, esi
  0001a	0b 45 10	 or	 eax, DWORD PTR __Count$[ebp+4]
  0001d	75 07		 jne	 SHORT $LN6@setbuf
  0001f	b8 04 00 00 00	 mov	 eax, 4
  00024	eb 02		 jmp	 SHORT $LN7@setbuf
$LN6@setbuf:
  00026	33 c0		 xor	 eax, eax
$LN7@setbuf:
  00028	56		 push	 esi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 _setvbuf
  00031	83 c4 10	 add	 esp, 16			; 00000010H
  00034	5e		 pop	 esi
  00035	85 c0		 test	 eax, eax
  00037	75 14		 jne	 SHORT $LN2@setbuf

; 535  : 		else
; 536  : 			{	// new buffer, reinitialize pointers
; 537  : 			_Init(_Myfile, _Openfl);

  00039	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  0003c	6a 01		 push	 1
  0003e	51		 push	 ecx
  0003f	8b cf		 mov	 ecx, edi
  00041	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 538  : 			return (this);

  00046	8b c7		 mov	 eax, edi
  00048	5f		 pop	 edi

; 539  : 			}
; 540  : 		}

  00049	5d		 pop	 ebp
  0004a	c2 0c 00	 ret	 12			; 0000000cH
$LN2@setbuf:

; 534  : 			return (0);	// failed

  0004d	33 c0		 xor	 eax, eax
  0004f	5f		 pop	 edi

; 539  : 			}
; 540  : 		}

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1959 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1960 : 		if (max_size() < _Newsize)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	83 fb fe	 cmp	 ebx, -2			; fffffffeH
  0000d	76 0a		 jbe	 SHORT $LN6@Grow

; 1961 : 			_Xlen();	// result too long

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN49@Grow:
$LN6@Grow:

; 1962 : 		if (this->_Myres < _Newsize)

  00019	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0001c	3b c3		 cmp	 eax, ebx
  0001e	73 18		 jae	 SHORT $LN5@Grow

; 1963 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  00020	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1969 : 		return (0 < _Newsize);	// return true only if more work to do

  0002a	33 c9		 xor	 ecx, ecx
  0002c	3b cb		 cmp	 ecx, ebx
  0002e	1b c0		 sbb	 eax, eax
  00030	5e		 pop	 esi
  00031	f7 d8		 neg	 eax
  00033	5b		 pop	 ebx

; 1970 : 		}

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN5@Grow:

; 1964 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00038	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  0003c	74 4e		 je	 SHORT $LN3@Grow
  0003e	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00041	73 49		 jae	 SHORT $LN3@Grow

; 1965 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1966 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

  00043	57		 push	 edi
  00044	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00047	3b df		 cmp	 ebx, edi
  00049	73 02		 jae	 SHORT $LN9@Grow
  0004b	8b fb		 mov	 edi, ebx
$LN9@Grow:
  0004d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00050	72 1d		 jb	 SHORT $LN30@Grow
  00052	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00054	85 ff		 test	 edi, edi
  00056	74 0b		 je	 SHORT $LN28@Grow
  00058	57		 push	 edi
  00059	53		 push	 ebx
  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 _memcpy
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@Grow:
  00063	53		 push	 ebx
  00064	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00069	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  0006c	83 c4 04	 add	 esp, 4
$LN30@Grow:
  0006f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00072	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 1969 : 		return (0 < _Newsize);	// return true only if more work to do

  00079	33 c9		 xor	 ecx, ecx
  0007b	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0007f	3b cb		 cmp	 ecx, ebx
  00081	5f		 pop	 edi
  00082	1b c0		 sbb	 eax, eax
  00084	5e		 pop	 esi
  00085	f7 d8		 neg	 eax
  00087	5b		 pop	 ebx

; 1970 : 		}

  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
$LN3@Grow:

; 1967 : 		else if (_Newsize == 0)

  0008c	85 db		 test	 ebx, ebx
  0008e	75 0d		 jne	 SHORT $LN46@Grow

; 1968 : 			_Eos(0);	// new size is zero, just null terminate

  00090	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00093	83 f8 10	 cmp	 eax, 16			; 00000010H
  00096	72 02		 jb	 SHORT $LN44@Grow
  00098	8b 36		 mov	 esi, DWORD PTR [esi]
$LN44@Grow:
  0009a	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN46@Grow:

; 1969 : 		return (0 < _Newsize);	// return true only if more work to do

  0009d	33 c9		 xor	 ecx, ecx
  0009f	3b cb		 cmp	 ecx, ebx
  000a1	1b c0		 sbb	 eax, eax
  000a3	5e		 pop	 esi
  000a4	f7 d8		 neg	 eax
  000a6	5b		 pop	 ebx

; 1970 : 		}

  000a7	5d		 pop	 ebp
  000a8	c2 08 00	 ret	 8
$LN48@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 807  : 		return (iterator(_Lmost(), this));

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::begin
_TEXT	ENDS
PUBLIC	?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
_TEXT	SEGMENT
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::init, COMDAT
; _this$ = ecx

; 154  : 		{	// initialize with stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 155  : 		_Init();	// initialize ios_base

  00006	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init

; 156  : 		_Mystrbuf = _Strbuf;

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Strbuf$[ebp]

; 157  : 		_Tiestr = 0;
; 158  : 		_Fillch = widen(' ');

  0000e	6a 20		 push	 32			; 00000020H
  00010	8b ce		 mov	 ecx, esi
  00012	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00015	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  0001c	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen

; 159  : 
; 160  : 		if (_Mystrbuf == 0)

  00021	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00025	88 46 40	 mov	 BYTE PTR [esi+64], al
  00028	75 10		 jne	 SHORT $LN10@init

; 161  : 			setstate(badbit);

  0002a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0002d	83 c8 04	 or	 eax, 4
  00030	6a 00		 push	 0
  00032	50		 push	 eax
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN10@init:

; 162  : 
; 163  : 		if (_Isstd)

  0003a	80 7d 0c 00	 cmp	 BYTE PTR __Isstd$[ebp], 0
  0003e	74 09		 je	 SHORT $LN1@init

; 164  : 			_Addstd(this);	// special handling for standard streams

  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  00046	83 c4 04	 add	 esp, 4
$LN1@init:
  00049	5e		 pop	 esi

; 165  : 		}

  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::init
_TEXT	ENDS
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\string
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z PROC ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 216  : 	{	// test for string vs. NTCS inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 217  : 	return (!(_Left == _Right));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000c	8d 64 24 00	 npad	 4
$LL9@operator@9:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL9@operator@9
  00017	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001a	2b c6		 sub	 eax, esi
  0001c	50		 push	 eax
  0001d	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00020	52		 push	 edx
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00029	f7 d8		 neg	 eax
  0002b	1b c0		 sbb	 eax, eax
  0002d	f7 d8		 neg	 eax
  0002f	5e		 pop	 esi

; 218  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ENDP ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
PUBLIC	??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T168062 = -36						; size = 12
__Lock$151145 = -24					; size = 4
__Lock$168070 = -20					; size = 4
__Psave$151146 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Lock$168092 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,int> >, COMDAT

; 504  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 505  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$151145[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 506  : 		const locale::facet *_Psave =
; 507  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 508  : 
; 509  : 		size_t _Id = _Facet::id;

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A, 0 ; std::codecvt<char,char,int>::id
  00039	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	89 5d f0	 mov	 DWORD PTR __Psave$151146[ebp], ebx
  00049	75 2b		 jne	 SHORT $LN11@use_facet@2
  0004b	6a 00		 push	 0
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$168070[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A, 0 ; std::codecvt<char,char,int>::id
  0005c	75 10		 jne	 SHORT $LN10@use_facet@2
  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00063	40		 inc	 eax
  00064	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00069	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A, eax ; std::codecvt<char,char,int>::id
$LN10@use_facet@2:
  0006e	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$168070[ebp]
  00071	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN11@use_facet@2:

; 510  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00076	8b 7d 08	 mov	 edi, DWORD PTR __Loc$[ebp]
  00079	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A ; std::codecvt<char,char,int>::id
  0007f	8b 07		 mov	 eax, DWORD PTR [edi]
  00081	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  00084	73 22		 jae	 SHORT $LN20@use_facet@2
  00086	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00089	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  0008c	85 c9		 test	 ecx, ecx
  0008e	75 1c		 jne	 SHORT $LN16@use_facet@2
$LN30@use_facet@2:
  00090	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  00094	74 16		 je	 SHORT $LN16@use_facet@2
  00096	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009b	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  0009e	73 12		 jae	 SHORT $LN31@use_facet@2
  000a0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000a3	8b 34 b2	 mov	 esi, DWORD PTR [edx+esi*4]
  000a6	eb 06		 jmp	 SHORT $LN15@use_facet@2
$LN20@use_facet@2:
  000a8	33 c9		 xor	 ecx, ecx
  000aa	eb e4		 jmp	 SHORT $LN30@use_facet@2
$LN16@use_facet@2:
  000ac	8b f1		 mov	 esi, ecx
$LN15@use_facet@2:

; 511  : 
; 512  : 		if (_Pf != 0)

  000ae	85 f6		 test	 esi, esi
  000b0	75 65		 jne	 SHORT $LN28@use_facet@2
$LN31@use_facet@2:

; 513  : 			;	// got facet from locale
; 514  : 		else if (_Psave != 0)

  000b2	85 db		 test	 ebx, ebx
  000b4	74 04		 je	 SHORT $LN4@use_facet@2

; 515  : 			_Pf = _Psave;	// lazy facet already allocated

  000b6	8b f3		 mov	 esi, ebx
  000b8	eb 5d		 jmp	 SHORT $LN28@use_facet@2
$LN4@use_facet@2:

; 516  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000ba	8d 45 f0	 lea	 eax, DWORD PTR __Psave$151146[ebp]
  000bd	57		 push	 edi
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::codecvt<char,char,int>::_Getcat
  000c4	83 c4 08	 add	 esp, 8
  000c7	83 f8 ff	 cmp	 eax, -1
  000ca	75 1b		 jne	 SHORT $LN2@use_facet@2

; 517  : 
; 518  :  #if _HAS_EXCEPTIONS
; 519  : 
; 520  : 			_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000d1	8d 4d dc	 lea	 ecx, DWORD PTR $T168062[ebp]
  000d4	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@PBD@Z ; std::bad_cast::bad_cast
  000d9	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000de	8d 4d dc	 lea	 ecx, DWORD PTR $T168062[ebp]
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@use_facet@2:
$LN2@use_facet@2:

; 521  : 
; 522  :  #else /* _HAS_EXCEPTIONS */
; 523  : 			abort();	// lazy disallowed
; 524  :  #endif /* _HAS_EXCEPTIONS */
; 525  : 
; 526  : 		else
; 527  : 			{	// queue up lazy facet for destruction
; 528  : 			_Pf = _Psave;

  000e7	8b 75 f0	 mov	 esi, DWORD PTR __Psave$151146[ebp]

; 529  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 530  : 
; 531  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 532  : 			_Pfmod->_Incref();

  000ea	6a 00		 push	 0
  000ec	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$168092[ebp]
  000ef	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
  000f5	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  000fa	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000fd	83 f8 ff	 cmp	 eax, -1
  00100	73 04		 jae	 SHORT $LN24@use_facet@2
  00102	40		 inc	 eax
  00103	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN24@use_facet@2:
  00106	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$168092[ebp]
  00109	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit

; 533  : 			_Pfmod->_Register();

  0010e	56		 push	 esi
  0010f	e8 00 00 00 00	 call	 ?_Facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::_Facet_Register
  00114	83 c4 04	 add	 esp, 4
$LN28@use_facet@2:

; 534  : 			}
; 535  : 
; 536  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00117	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$151145[ebp]
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00121	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00126	8b c6		 mov	 eax, esi

; 537  : 	_END_LOCK()
; 538  : 	}

  00128	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00132	59		 pop	 ecx
  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
$LN36@use_facet@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$151145[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,int> >
PUBLIC	??1?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
;	COMDAT ??1?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $LN16@pair@2
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN16@pair@2:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi
  00025	c3		 ret	 0
??1?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 99   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0002c	89 06		 mov	 DWORD PTR [esi], eax
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00033	8b 44 02 38	 mov	 eax, DWORD PTR [edx+eax+56]
  00037	85 c0		 test	 eax, eax
  00039	74 09		 je	 SHORT $LN4@sentry@2
  0003b	8b 10		 mov	 edx, DWORD PTR [eax]
  0003d	8b c8		 mov	 ecx, eax
  0003f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00042	ff d0		 call	 eax
$LN4@sentry@2:

; 100  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00044	8b 4d 0c	 mov	 ecx, DWORD PTR __Noskip$[ebp]
  00047	51		 push	 ecx
  00048	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00051	e8 00 00 00 00	 call	 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
  00056	88 46 04	 mov	 BYTE PTR [esi+4], al

; 101  : 			}

  00059	8b c6		 mov	 eax, esi
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00065	59		 pop	 ecx
  00066	5e		 pop	 esi
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
$T168250 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000a	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  00012	75 18		 jne	 SHORT $LN9@find@2
  00014	56		 push	 esi
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$LL10@find@2:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	73 05		 jae	 SHORT $LN8@find@2
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $LN7@find@2
$LN8@find@2:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@find@2:
  00025	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00029	74 ec		 je	 SHORT $LL10@find@2
  0002b	5e		 pop	 esi
$LN9@find@2:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	89 55 0c	 mov	 DWORD PTR __Where$[ebp], edx
  00032	3b d0		 cmp	 edx, eax
  00034	74 18		 je	 SHORT $LN3@find@2
  00036	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00038	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003b	72 11		 jb	 SHORT $LN3@find@2
  0003d	8d 45 0c	 lea	 eax, DWORD PTR __Where$[ebp]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00045	89 10		 mov	 DWORD PTR [eax], edx
  00047	5f		 pop	 edi

; 1429 : 		}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN3@find@2:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0004e	89 45 fc	 mov	 DWORD PTR $T168250[ebp], eax
  00051	8d 45 fc	 lea	 eax, DWORD PTR $T168250[ebp]
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00059	89 10		 mov	 DWORD PTR [eax], edx
  0005b	5f		 pop	 edi

; 1429 : 		}

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::find
; Function compile flags: /Ogtp
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
$T168473 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000a	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  00012	75 18		 jne	 SHORT $LN9@find@3
  00014	56		 push	 esi
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$LL10@find@3:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	73 05		 jae	 SHORT $LN8@find@3
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $LN7@find@3
$LN8@find@3:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@find@3:
  00025	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00029	74 ec		 je	 SHORT $LL10@find@3
  0002b	5e		 pop	 esi
$LN9@find@3:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	89 55 0c	 mov	 DWORD PTR __Where$[ebp], edx
  00032	3b d0		 cmp	 edx, eax
  00034	74 18		 je	 SHORT $LN3@find@3
  00036	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00038	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003b	72 11		 jb	 SHORT $LN3@find@3
  0003d	8d 45 0c	 lea	 eax, DWORD PTR __Where$[ebp]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00045	89 10		 mov	 DWORD PTR [eax], edx
  00047	5f		 pop	 edi

; 1429 : 		}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN3@find@3:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0004e	89 45 fc	 mov	 DWORD PTR $T168473[ebp], eax
  00051	8d 45 fc	 lea	 eax, DWORD PTR $T168473[ebp]
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00059	89 10		 mov	 DWORD PTR [eax], edx
  0005b	5f		 pop	 edi

; 1429 : 		}

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::find
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
__Loc$ = 8						; size = 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 550  : 		{	// set locale to argument (capture nontrivial codecvt facet)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 551  : 		_Initcvt(&_USE(_Loc, _Cvt));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	50		 push	 eax
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
  00010	8b f0		 mov	 esi, eax
  00012	8b 16		 mov	 edx, DWORD PTR [esi]
  00014	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00017	83 c4 04	 add	 esp, 4
  0001a	8b ce		 mov	 ecx, esi
  0001c	ff d0		 call	 eax
  0001e	84 c0		 test	 al, al
  00020	74 0d		 je	 SHORT $LN4@imbue
  00022	c7 47 44 00 00
	00 00		 mov	 DWORD PTR [edi+68], 0
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi

; 552  : 		}

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4

; 551  : 		_Initcvt(&_USE(_Loc, _Cvt));

$LN4@imbue:
  0002f	8b cf		 mov	 ecx, edi
  00031	89 77 44	 mov	 DWORD PTR [edi+68], esi
  00034	e8 00 00 00 00	 call	 ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi

; 552  : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 845  : 		{	// append _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 846  : 		if (npos - this->_Mysize <= _Count)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000d	83 c9 ff	 or	 ecx, -1
  00010	2b c8		 sub	 ecx, eax
  00012	3b cb		 cmp	 ecx, ebx
  00014	77 0a		 ja	 SHORT $LN2@append

; 847  : 			_Xlen();	// result too long

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0001b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN67@append:
$LN2@append:

; 848  : 
; 849  : 		size_type _Num;
; 850  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  00020	85 db		 test	 ebx, ebx
  00022	74 7c		 je	 SHORT $LN61@append
  00024	57		 push	 edi
  00025	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  00028	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0002b	76 0a		 jbe	 SHORT $LN13@append
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00032	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN68@append:
$LN13@append:
  00037	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0003a	3b cf		 cmp	 ecx, edi
  0003c	73 35		 jae	 SHORT $LN12@append
  0003e	50		 push	 eax
  0003f	57		 push	 edi
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00047	85 ff		 test	 edi, edi
  00049	74 54		 je	 SHORT $LN63@append
$LN66@append:

; 851  : 			{	// make room and append new stuff using assign
; 852  : 			_Chassign(this->_Mysize, _Count, _Ch);

  0004b	8b 55 0c	 mov	 edx, DWORD PTR __Ch$[ebp]
  0004e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00051	52		 push	 edx
  00052	53		 push	 ebx
  00053	50		 push	 eax
  00054	8b ce		 mov	 ecx, esi
  00056	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 853  : 			_Eos(_Num);

  0005b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0005f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00062	72 35		 jb	 SHORT $LN59@append
  00064	8b 06		 mov	 eax, DWORD PTR [esi]
  00066	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0006a	5f		 pop	 edi

; 854  : 			}
; 855  : 		return (*this);

  0006b	8b c6		 mov	 eax, esi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx

; 856  : 		}

  0006f	5d		 pop	 ebp
  00070	c2 08 00	 ret	 8

; 848  : 
; 849  : 		size_type _Num;
; 850  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

$LN12@append:
  00073	85 ff		 test	 edi, edi
  00075	75 d4		 jne	 SHORT $LN66@append
  00077	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0007a	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0007d	72 0e		 jb	 SHORT $LN51@append
  0007f	8b 06		 mov	 eax, DWORD PTR [esi]
  00081	5f		 pop	 edi
  00082	c6 00 00	 mov	 BYTE PTR [eax], 0

; 854  : 			}
; 855  : 		return (*this);

  00085	8b c6		 mov	 eax, esi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx

; 856  : 		}

  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8

; 848  : 
; 849  : 		size_type _Num;
; 850  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

$LN51@append:
  0008d	5f		 pop	 edi
  0008e	8b c6		 mov	 eax, esi
  00090	5e		 pop	 esi
  00091	c6 00 00	 mov	 BYTE PTR [eax], 0
  00094	5b		 pop	 ebx

; 856  : 		}

  00095	5d		 pop	 ebp
  00096	c2 08 00	 ret	 8

; 853  : 			_Eos(_Num);

$LN59@append:
  00099	8b c6		 mov	 eax, esi
  0009b	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN63@append:
  0009f	5f		 pop	 edi
$LN61@append:

; 854  : 			}
; 855  : 		return (*this);

  000a0	8b c6		 mov	 eax, esi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx

; 856  : 		}

  000a4	5d		 pop	 ebp
  000a5	c2 08 00	 ret	 8
$LN64@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 893  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 894  : 		if (_Right.size() < _Roff)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Roff$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	57		 push	 edi
  0000e	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
  00011	3b fb		 cmp	 edi, ebx
  00013	73 0a		 jae	 SHORT $LN5@assign

; 895  : 			_Xran();	// _Roff off end

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN83@assign:
$LN5@assign:

; 896  : 		size_type _Num = _Right.size() - _Roff;
; 897  : 		if (_Count < _Num)

  0001f	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	2b fb		 sub	 edi, ebx
  00024	3b c7		 cmp	 eax, edi
  00026	73 02		 jae	 SHORT $LN4@assign

; 898  : 			_Num = _Count;	// trim _Num to size

  00028	8b f8		 mov	 edi, eax
$LN4@assign:

; 899  : 
; 900  : 		if (this == &_Right)

  0002a	3b f1		 cmp	 esi, ecx
  0002c	75 1f		 jne	 SHORT $LN3@assign

; 901  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002e	6a ff		 push	 -1
  00030	03 fb		 add	 edi, ebx
  00032	57		 push	 edi
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0003a	53		 push	 ebx
  0003b	6a 00		 push	 0
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00044	5f		 pop	 edi

; 906  : 			}
; 907  : 		return (*this);

  00045	8b c6		 mov	 eax, esi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx

; 908  : 		}

  00049	5d		 pop	 ebp
  0004a	c2 0c 00	 ret	 12			; 0000000cH
$LN3@assign:

; 902  : 		else if (_Grow(_Num))

  0004d	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00050	76 0a		 jbe	 SHORT $LN20@assign
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00057	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN84@assign:
$LN20@assign:
  0005c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005f	3b c7		 cmp	 eax, edi
  00061	73 28		 jae	 SHORT $LN19@assign
  00063	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00066	50		 push	 eax
  00067	57		 push	 edi
  00068	8b ce		 mov	 ecx, esi
  0006a	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00072	85 ff		 test	 edi, edi
  00074	74 68		 je	 SHORT $LN78@assign
$LN82@assign:

; 903  : 			{	// make room and assign new stuff
; 904  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  00076	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0007b	39 41 14	 cmp	 DWORD PTR [ecx+20], eax
  0007e	72 02		 jb	 SHORT $LN64@assign
  00080	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN64@assign:
  00082	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00085	72 2a		 jb	 SHORT $LN68@assign
  00087	8b 06		 mov	 eax, DWORD PTR [esi]
  00089	eb 28		 jmp	 SHORT $LN69@assign

; 902  : 		else if (_Grow(_Num))

$LN19@assign:
  0008b	85 ff		 test	 edi, edi
  0008d	75 e7		 jne	 SHORT $LN82@assign
  0008f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00092	83 f8 10	 cmp	 eax, 16			; 00000010H
  00095	72 0e		 jb	 SHORT $LN58@assign
  00097	8b 06		 mov	 eax, DWORD PTR [esi]
  00099	5f		 pop	 edi
  0009a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 906  : 			}
; 907  : 		return (*this);

  0009d	8b c6		 mov	 eax, esi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx

; 908  : 		}

  000a1	5d		 pop	 ebp
  000a2	c2 0c 00	 ret	 12			; 0000000cH

; 902  : 		else if (_Grow(_Num))

$LN58@assign:
  000a5	5f		 pop	 edi
  000a6	8b c6		 mov	 eax, esi
  000a8	5e		 pop	 esi
  000a9	c6 00 00	 mov	 BYTE PTR [eax], 0
  000ac	5b		 pop	 ebx

; 908  : 		}

  000ad	5d		 pop	 ebp
  000ae	c2 0c 00	 ret	 12			; 0000000cH

; 903  : 			{	// make room and assign new stuff
; 904  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

$LN68@assign:
  000b1	8b c6		 mov	 eax, esi
$LN69@assign:
  000b3	57		 push	 edi
  000b4	03 cb		 add	 ecx, ebx
  000b6	51		 push	 ecx
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _memcpy
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 905  : 			_Eos(_Num);

  000c0	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c4	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000c7	72 0f		 jb	 SHORT $LN76@assign
  000c9	8b 06		 mov	 eax, DWORD PTR [esi]
  000cb	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  000cf	5f		 pop	 edi

; 906  : 			}
; 907  : 		return (*this);

  000d0	8b c6		 mov	 eax, esi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx

; 908  : 		}

  000d4	5d		 pop	 ebp
  000d5	c2 0c 00	 ret	 12			; 0000000cH

; 905  : 			_Eos(_Num);

$LN76@assign:
  000d8	8b c6		 mov	 eax, esi
  000da	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN78@assign:

; 906  : 			}
; 907  : 		return (*this);

  000de	5f		 pop	 edi
  000df	8b c6		 mov	 eax, esi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx

; 908  : 		}

  000e3	5d		 pop	 ebp
  000e4	c2 0c 00	 ret	 12			; 0000000cH
$LN80@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 911  : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 912  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 913  : 		if (_Count != 0)
; 914  : 			_DEBUG_POINTER(_Ptr);
; 915  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 916  : 
; 917  : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 59		 je	 SHORT $LN85@assign@2
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN12@assign@2
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN13@assign@2
$LN12@assign@2:
  0001a	8b c6		 mov	 eax, esi
$LN13@assign@2:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 47		 jb	 SHORT $LN85@assign@2
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN16@assign@2
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN17@assign@2
$LN16@assign@2:
  00029	8b c6		 mov	 eax, esi
$LN17@assign@2:
  0002b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0002e	03 d0		 add	 edx, eax
  00030	3b d3		 cmp	 edx, ebx
  00032	76 33		 jbe	 SHORT $LN85@assign@2

; 918  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 17		 jb	 SHORT $LN20@assign@2
  00039	8b 06		 mov	 eax, DWORD PTR [esi]
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0003e	51		 push	 ecx
  0003f	2b d8		 sub	 ebx, eax
  00041	53		 push	 ebx
  00042	56		 push	 esi
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 926  : 		}

  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8

; 918  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

$LN20@assign@2:
  00050	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00053	8b c6		 mov	 eax, esi
  00055	51		 push	 ecx
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx

; 926  : 		}

  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
$LN85@assign@2:
  00067	57		 push	 edi

; 919  : 
; 920  : 		if (_Grow(_Count))

  00068	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0006b	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0006e	76 0a		 jbe	 SHORT $LN27@assign@2
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00075	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN89@assign@2:
$LN27@assign@2:
  0007a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0007d	3b c7		 cmp	 eax, edi
  0007f	73 1a		 jae	 SHORT $LN26@assign@2
  00081	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00084	52		 push	 edx
  00085	57		 push	 edi
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0008d	85 ff		 test	 edi, edi
  0008f	74 5b		 je	 SHORT $LN82@assign@2
$LN88@assign@2:

; 921  : 			{	// make room and assign new stuff
; 922  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

  00091	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00095	72 2a		 jb	 SHORT $LN72@assign@2
  00097	8b 06		 mov	 eax, DWORD PTR [esi]
  00099	eb 28		 jmp	 SHORT $LN73@assign@2

; 919  : 
; 920  : 		if (_Grow(_Count))

$LN26@assign@2:
  0009b	85 ff		 test	 edi, edi
  0009d	75 f2		 jne	 SHORT $LN88@assign@2
  0009f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000a2	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a5	72 0e		 jb	 SHORT $LN65@assign@2
  000a7	8b 06		 mov	 eax, DWORD PTR [esi]
  000a9	5f		 pop	 edi
  000aa	c6 00 00	 mov	 BYTE PTR [eax], 0

; 924  : 			}
; 925  : 		return (*this);

  000ad	8b c6		 mov	 eax, esi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx

; 926  : 		}

  000b1	5d		 pop	 ebp
  000b2	c2 08 00	 ret	 8

; 919  : 
; 920  : 		if (_Grow(_Count))

$LN65@assign@2:
  000b5	5f		 pop	 edi
  000b6	8b c6		 mov	 eax, esi
  000b8	5e		 pop	 esi
  000b9	c6 00 00	 mov	 BYTE PTR [eax], 0
  000bc	5b		 pop	 ebx

; 926  : 		}

  000bd	5d		 pop	 ebp
  000be	c2 08 00	 ret	 8

; 921  : 			{	// make room and assign new stuff
; 922  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

$LN72@assign@2:
  000c1	8b c6		 mov	 eax, esi
$LN73@assign@2:
  000c3	57		 push	 edi
  000c4	53		 push	 ebx
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _memcpy
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 923  : 			_Eos(_Count);

  000ce	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000d2	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000d5	72 0f		 jb	 SHORT $LN80@assign@2
  000d7	8b 06		 mov	 eax, DWORD PTR [esi]
  000d9	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  000dd	5f		 pop	 edi

; 924  : 			}
; 925  : 		return (*this);

  000de	8b c6		 mov	 eax, esi
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx

; 926  : 		}

  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8

; 923  : 			_Eos(_Count);

$LN80@assign@2:
  000e6	8b c6		 mov	 eax, esi
  000e8	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN82@assign@2:

; 924  : 			}
; 925  : 		return (*this);

  000ec	5f		 pop	 edi
  000ed	8b c6		 mov	 eax, esi
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx

; 926  : 		}

  000f1	5d		 pop	 ebp
  000f2	c2 08 00	 ret	 8
$LN86@assign@2:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z ; std::basic_istream<char,std::char_traits<char> >::getline
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
xdata$x	SEGMENT
__catchsym$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$0
__tryblocktable$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$14
__unwindtable$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z
_TEXT	SEGMENT
__Ok$ = -32						; size = 8
_this$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Str$ = 8						; size = 4
__Count$ = 12						; size = 8
__Delim$ = 20						; size = 1
?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z PROC ; std::basic_istream<char,std::char_traits<char> >::getline, COMDAT
; _this$ = ecx

; 628  : 		{	// get up to _Count characters into NTCS, discard _Delim

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi

; 629  : 		_DEBUG_POINTER(_Str);
; 630  : 		ios_base::iostate _State = ios_base::goodbit;

  00030	33 db		 xor	 ebx, ebx

; 631  : 		_Chcount = 0;

  00032	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00035	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx

; 632  : 		const sentry _Ok(*this, true);

  00038	8b 06		 mov	 eax, DWORD PTR [esi]
  0003a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003d	8b 4c 31 38	 mov	 ecx, DWORD PTR [ecx+esi+56]
  00041	89 5d ec	 mov	 DWORD PTR __State$[ebp], ebx
  00044	89 75 e0	 mov	 DWORD PTR __Ok$[ebp], esi
  00047	3b cb		 cmp	 ecx, ebx
  00049	74 07		 je	 SHORT $LN24@getline
  0004b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00050	ff d0		 call	 eax
$LN24@getline:
  00052	6a 01		 push	 1
  00054	8b ce		 mov	 ecx, esi
  00056	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  00059	e8 00 00 00 00	 call	 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
  0005e	88 45 e4	 mov	 BYTE PTR __Ok$[ebp+4], al
  00061	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 633  : 
; 634  : 		if (_Ok && 0 < _Count)

  00068	84 c0		 test	 al, al
  0006a	0f 84 a7 00 00
	00		 je	 $LN19@getline
  00070	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp+4]
  00073	85 ff		 test	 edi, edi
  00075	0f 8c 9c 00 00
	00		 jl	 $LN19@getline
  0007b	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0007e	7f 08		 jg	 SHORT $LN161@getline
  00080	85 db		 test	 ebx, ebx
  00082	0f 84 8c 00 00
	00		 je	 $LN166@getline
$LN161@getline:

; 635  : 			{	// state okay, use facet to extract
; 636  : 			int_type _Metadelim = _Traits::to_int_type(_Delim);
; 637  : 
; 638  : 			_TRY_IO_BEGIN
; 639  : 			int_type _Meta = _Myios::rdbuf()->sgetc();

  00088	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008d	8b 4c 32 38	 mov	 ecx, DWORD PTR [edx+esi+56]
  00091	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00094	83 38 00	 cmp	 DWORD PTR [eax], 0
  00097	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0009b	74 0f		 je	 SHORT $LN39@getline
  0009d	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000a0	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000a3	7e 07		 jle	 SHORT $LN39@getline
  000a5	8b 00		 mov	 eax, DWORD PTR [eax]
  000a7	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000aa	eb 07		 jmp	 SHORT $LL160@getline
$LN39@getline:
  000ac	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ae	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000b1	ff d2		 call	 edx
$LL160@getline:

; 640  : 
; 641  : 			for (; ; _Meta = _Myios::rdbuf()->snextc())
; 642  : 				if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000b3	83 f8 ff	 cmp	 eax, -1
  000b6	75 06		 jne	 SHORT $LN6@getline

; 643  : 					{	// end of file, quit
; 644  : 					_State |= ios_base::eofbit;

  000b8	83 4d ec 01	 or	 DWORD PTR __State$[ebp], 1

; 645  : 					break;

  000bc	eb 4f		 jmp	 SHORT $LN7@getline
$LN6@getline:

; 646  : 					}
; 647  : 				else if (_Meta == _Metadelim)

  000be	0f b6 4d 14	 movzx	 ecx, BYTE PTR __Delim$[ebp]
  000c2	3b c1		 cmp	 eax, ecx
  000c4	75 33		 jne	 SHORT $LN4@getline

; 648  : 					{	// got a delimiter, discard it and quit
; 649  : 					++_Chcount;

  000c6	83 46 08 01	 add	 DWORD PTR [esi+8], 1

; 650  : 					_Myios::rdbuf()->sbumpc();

  000ca	8b 06		 mov	 eax, DWORD PTR [esi]
  000cc	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0
  000d0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d3	8b 4c 31 38	 mov	 ecx, DWORD PTR [ecx+esi+56]
  000d7	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000da	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000dd	74 11		 je	 SHORT $LN59@getline
  000df	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  000e2	83 38 00	 cmp	 DWORD PTR [eax], 0
  000e5	7e 09		 jle	 SHORT $LN59@getline
  000e7	ff 08		 dec	 DWORD PTR [eax]
  000e9	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  000ec	ff 01		 inc	 DWORD PTR [ecx]
  000ee	eb 1d		 jmp	 SHORT $LN7@getline
$LN59@getline:
  000f0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f2	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000f5	ff d0		 call	 eax

; 651  : 					break;

  000f7	eb 14		 jmp	 SHORT $LN7@getline
$LN4@getline:

; 652  : 					}
; 653  : 				else if (--_Count <= 0)

  000f9	83 c3 ff	 add	 ebx, -1
  000fc	83 d7 ff	 adc	 edi, -1
  000ff	85 ff		 test	 edi, edi
  00101	7f 7a		 jg	 SHORT $LN2@getline
  00103	7c 04		 jl	 SHORT $LN162@getline
  00105	85 db		 test	 ebx, ebx
  00107	75 74		 jne	 SHORT $LN2@getline
$LN162@getline:

; 654  : 					{	// buffer full, quit
; 655  : 					_State |= ios_base::failbit;

  00109	83 4d ec 02	 or	 DWORD PTR __State$[ebp], 2
$LN7@getline:
  0010d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN166@getline:

; 662  : 					}
; 663  : 			_CATCH_IO_END

  00114	8b 5d ec	 mov	 ebx, DWORD PTR __State$[ebp]
$LN19@getline:

; 664  : 			}
; 665  : 
; 666  : 		*_Str = _Elem();	// add terminating null character

  00117	8b 4d 08	 mov	 ecx, DWORD PTR __Str$[ebp]
  0011a	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 667  : 		_Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);

  0011d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00120	0b 56 0c	 or	 edx, DWORD PTR [esi+12]
  00123	75 03		 jne	 SHORT $LN14@getline
  00125	83 cb 02	 or	 ebx, 2
$LN14@getline:
  00128	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0012a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0012d	8b c3		 mov	 eax, ebx
  0012f	03 ce		 add	 ecx, esi
  00131	85 c0		 test	 eax, eax
  00133	74 14		 je	 SHORT $LN143@getline
  00135	0b 41 0c	 or	 eax, DWORD PTR [ecx+12]
  00138	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0013c	75 03		 jne	 SHORT $LN145@getline
  0013e	83 c8 04	 or	 eax, 4
$LN145@getline:
  00141	6a 00		 push	 0
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN143@getline:

; 668  : 		return (*this);

  00149	8b 45 e0	 mov	 eax, DWORD PTR __Ok$[ebp]
  0014c	8b 10		 mov	 edx, DWORD PTR [eax]
  0014e	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00151	8b 4c 01 38	 mov	 ecx, DWORD PTR [ecx+eax+56]
  00155	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0015c	85 c9		 test	 ecx, ecx
  0015e	74 07		 je	 SHORT $LN150@getline
  00160	8b 11		 mov	 edx, DWORD PTR [ecx]
  00162	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00165	ff d0		 call	 eax
$LN150@getline:
  00167	8b c6		 mov	 eax, esi

; 669  : 		}

  00169	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0016c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00173	59		 pop	 ecx
  00174	5f		 pop	 edi
  00175	5e		 pop	 esi
  00176	5b		 pop	 ebx
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c2 10 00	 ret	 16			; 00000010H
$LN2@getline:

; 656  : 					break;
; 657  : 					}
; 658  : 				else
; 659  : 					{	// got a character, add it to string
; 660  : 					++_Chcount;

  0017d	83 46 08 01	 add	 DWORD PTR [esi+8], 1

; 661  : 					*_Str++ = _Traits::to_char_type(_Meta);

  00181	8b 4d 08	 mov	 ecx, DWORD PTR __Str$[ebp]
  00184	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0
  00188	88 01		 mov	 BYTE PTR [ecx], al
  0018a	41		 inc	 ecx
  0018b	89 4d 08	 mov	 DWORD PTR __Str$[ebp], ecx
  0018e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00190	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00193	8b 4c 32 38	 mov	 ecx, DWORD PTR [edx+esi+56]
  00197	e8 00 00 00 00	 call	 ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
  0019c	e9 12 ff ff ff	 jmp	 $LL160@getline
__catch$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$0:

; 662  : 					}
; 663  : 			_CATCH_IO_END

  001a1	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a9	03 c1		 add	 eax, ecx
  001ab	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001ae	83 c9 04	 or	 ecx, 4
  001b1	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  001b5	75 03		 jne	 SHORT $LN78@getline
  001b7	83 c9 04	 or	 ecx, 4
$LN78@getline:
  001ba	83 e1 17	 and	 ecx, 23			; 00000017H
  001bd	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  001c0	85 48 10	 test	 DWORD PTR [eax+16], ecx
  001c3	75 15		 jne	 SHORT $LN87@getline
  001c5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  001cc	b8 00 00 00 00	 mov	 eax, $LN20@getline
  001d1	c3		 ret	 0
$LN20@getline:
  001d2	8b 75 e8	 mov	 esi, DWORD PTR _this$[ebp]
  001d5	e9 3a ff ff ff	 jmp	 $LN166@getline
$LN87@getline:
  001da	6a 00		 push	 0
  001dc	6a 00		 push	 0
  001de	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN170@getline:
$LN169@getline:
  001e3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$3:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$2:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::getline
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
EXTRN	?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z:PROC		; std::_Fiopen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0
__ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
$T169820 = 16						; size = 4
__Prot$ = 16						; size = 4
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 218  : 		{	// open a C stream with specified mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 219  : 		_Filet *_File;
; 220  : 		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)

  00026	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  0002a	0f 85 97 00 00
	00		 jne	 $LN1@open
  00030	8b 45 10	 mov	 eax, DWORD PTR __Prot$[ebp]
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR __Mode$[ebp]
  00036	8b 55 08	 mov	 edx, DWORD PTR __Filename$[ebp]
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z ; std::_Fiopen
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	85 c0		 test	 eax, eax
  00046	74 7f		 je	 SHORT $LN1@open

; 222  : 
; 223  : 		_Init(_File, _Openfl);

  00048	6a 01		 push	 1
  0004a	50		 push	 eax
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 224  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

  00052	8d 45 10	 lea	 eax, DWORD PTR $T169820[ebp]
  00055	50		 push	 eax
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ; std::basic_streambuf<char,std::char_traits<char> >::getloc
  0005d	50		 push	 eax
  0005e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00065	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
  0006a	8b f8		 mov	 edi, eax
  0006c	8b 17		 mov	 edx, DWORD PTR [edi]
  0006e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00071	83 c4 04	 add	 esp, 4
  00074	8b cf		 mov	 ecx, edi
  00076	ff d0		 call	 eax
  00078	84 c0		 test	 al, al
  0007a	74 24		 je	 SHORT $LN7@open
  0007c	8d 4d 10	 lea	 ecx, DWORD PTR $T169820[ebp]
  0007f	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
  00086	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 225  : 		return (this);	// open succeeded

  0008b	8b c6		 mov	 eax, esi

; 226  : 		}

  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 0c 00	 ret	 12			; 0000000cH

; 224  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

$LN7@open:
  000a0	8b ce		 mov	 ecx, esi
  000a2	89 7e 44	 mov	 DWORD PTR [esi+68], edi
  000a5	e8 00 00 00 00	 call	 ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
  000aa	8d 4d 10	 lea	 ecx, DWORD PTR $T169820[ebp]
  000ad	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 225  : 		return (this);	// open succeeded

  000b2	8b c6		 mov	 eax, esi

; 226  : 		}

  000b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000be	59		 pop	 ecx
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH
$LN1@open:

; 221  : 			return (0);	// open failed

  000c7	33 c0		 xor	 eax, eax

; 226  : 		}

  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0:
  00000	8d 4d 10	 lea	 ecx, DWORD PTR $T169820[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 935  : 		{	// assign _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 936  : 		if (_Count == npos)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	83 ff ff	 cmp	 edi, -1
  0000d	75 0a		 jne	 SHORT $LN2@assign@3

; 937  : 			_Xlen();	// result too long

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN82@assign@3:
$LN2@assign@3:

; 938  : 
; 939  : 		if (_Grow(_Count))

  00019	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0001c	76 0a		 jbe	 SHORT $LN13@assign@3
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00023	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN83@assign@3:
$LN13@assign@3:
  00028	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002b	3b c7		 cmp	 eax, edi
  0002d	73 22		 jae	 SHORT $LN12@assign@3
  0002f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00032	50		 push	 eax
  00033	57		 push	 edi
  00034	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00039	85 ff		 test	 edi, edi
  0003b	74 79		 je	 SHORT $LN77@assign@3
$LN81@assign@3:

; 940  : 			{	// make room and assign new stuff
; 941  : 			_Chassign(0, _Count, _Ch);

  0003d	83 ff 01	 cmp	 edi, 1
  00040	75 3c		 jne	 SHORT $LN56@assign@3
  00042	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00046	72 2d		 jb	 SHORT $LN61@assign@3
  00048	8b 06		 mov	 eax, DWORD PTR [esi]
  0004a	8a 4d 0c	 mov	 cl, BYTE PTR __Ch$[ebp]
  0004d	88 08		 mov	 BYTE PTR [eax], cl
  0004f	eb 48		 jmp	 SHORT $LN69@assign@3

; 938  : 
; 939  : 		if (_Grow(_Count))

$LN12@assign@3:
  00051	85 ff		 test	 edi, edi
  00053	75 e8		 jne	 SHORT $LN81@assign@3
  00055	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00058	83 f8 10	 cmp	 eax, 16			; 00000010H
  0005b	72 0d		 jb	 SHORT $LN51@assign@3
  0005d	8b 06		 mov	 eax, DWORD PTR [esi]
  0005f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00062	5f		 pop	 edi

; 943  : 			}
; 944  : 		return (*this);

  00063	8b c6		 mov	 eax, esi
  00065	5e		 pop	 esi

; 945  : 		}

  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8

; 938  : 
; 939  : 		if (_Grow(_Count))

$LN51@assign@3:
  0006a	8b c6		 mov	 eax, esi
  0006c	5f		 pop	 edi
  0006d	c6 00 00	 mov	 BYTE PTR [eax], 0
  00070	5e		 pop	 esi

; 945  : 		}

  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8

; 940  : 			{	// make room and assign new stuff
; 941  : 			_Chassign(0, _Count, _Ch);

$LN61@assign@3:
  00075	8a 4d 0c	 mov	 cl, BYTE PTR __Ch$[ebp]
  00078	8b c6		 mov	 eax, esi
  0007a	88 08		 mov	 BYTE PTR [eax], cl
  0007c	eb 1b		 jmp	 SHORT $LN69@assign@3
$LN56@assign@3:
  0007e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00082	72 04		 jb	 SHORT $LN67@assign@3
  00084	8b 06		 mov	 eax, DWORD PTR [esi]
  00086	eb 02		 jmp	 SHORT $LN68@assign@3
$LN67@assign@3:
  00088	8b c6		 mov	 eax, esi
$LN68@assign@3:
  0008a	0f be 55 0c	 movsx	 edx, BYTE PTR __Ch$[ebp]
  0008e	57		 push	 edi
  0008f	52		 push	 edx
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _memset
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN69@assign@3:

; 942  : 			_Eos(_Count);

  00099	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0009d	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000a0	72 0e		 jb	 SHORT $LN75@assign@3
  000a2	8b 06		 mov	 eax, DWORD PTR [esi]
  000a4	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  000a8	5f		 pop	 edi

; 943  : 			}
; 944  : 		return (*this);

  000a9	8b c6		 mov	 eax, esi
  000ab	5e		 pop	 esi

; 945  : 		}

  000ac	5d		 pop	 ebp
  000ad	c2 08 00	 ret	 8

; 942  : 			_Eos(_Count);

$LN75@assign@3:
  000b0	8b c6		 mov	 eax, esi
  000b2	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN77@assign@3:

; 943  : 			}
; 944  : 		return (*this);

  000b6	5f		 pop	 edi
  000b7	8b c6		 mov	 eax, esi
  000b9	5e		 pop	 esi

; 945  : 		}

  000ba	5d		 pop	 ebp
  000bb	c2 08 00	 ret	 8
$LN79@assign@3:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
;	COMDAT ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
CONST	SEGMENT
??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
	DD	010H
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z$0
__ehfuncinfo$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T170063 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 33   : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002d	33 db		 xor	 ebx, ebx
  0002f	89 5d f0	 mov	 DWORD PTR $T170063[ebp], ebx
  00032	39 5d 10	 cmp	 DWORD PTR _$initVBases$[ebp], ebx
  00035	74 17		 je	 SHORT $LN1@basic_istr
  00037	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
  0003d	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  00044	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00047	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T170063[ebp], 1
$LN1@basic_istr:
  0004e	8b 07		 mov	 eax, DWORD PTR [edi]
  00050	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00053	c7 04 0f 00 00
	00 00		 mov	 DWORD PTR [edi+ecx], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@

; 34   : 		_Myios::init(_Strbuf, _Isstd);

  0005a	8b 17		 mov	 edx, DWORD PTR [edi]
  0005c	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0005f	89 5f 0c	 mov	 DWORD PTR [edi+12], ebx
  00062	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00065	03 f7		 add	 esi, edi
  00067	8b ce		 mov	 ecx, esi
  00069	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init
  0006e	8b 45 08	 mov	 eax, DWORD PTR __Strbuf$[ebp]
  00071	6a 20		 push	 32			; 00000020H
  00073	8b ce		 mov	 ecx, esi
  00075	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00078	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  0007b	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
  00080	88 46 40	 mov	 BYTE PTR [esi+64], al
  00083	39 5e 38	 cmp	 DWORD PTR [esi+56], ebx
  00086	75 0f		 jne	 SHORT $LN19@basic_istr
  00088	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0008b	83 c8 04	 or	 eax, 4
  0008e	53		 push	 ebx
  0008f	50		 push	 eax
  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN19@basic_istr:
  00097	38 5d 0c	 cmp	 BYTE PTR __Isstd$[ebp], bl
  0009a	74 09		 je	 SHORT $LN23@basic_istr
  0009c	56		 push	 esi
  0009d	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  000a2	83 c4 04	 add	 esp, 4
$LN23@basic_istr:

; 35   : 		}

  000a5	8b c7		 mov	 eax, edi
  000a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b1	59		 pop	 ecx
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T170063[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_istr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T170063[ebp], -2 ; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@basic_istr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
PUBLIC	??_G?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAXI@Z ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAXI@Z PROC ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  0000a	72 0c		 jb	 SHORT $LN18@scalar@18
  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN18@scalar@18:
  00018	33 c0		 xor	 eax, eax
  0001a	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001e	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00025	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00028	88 46 04	 mov	 BYTE PTR [esi+4], al
  0002b	74 09		 je	 SHORT $LN30@scalar@18
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00033	83 c4 04	 add	 esp, 4
$LN30@scalar@18:
  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??_G?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAXI@Z ENDP ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	?GetInt@TokenizerRow@@QAEHKKH@Z			; TokenizerRow::GetInt
EXTRN	_atoi:PROC
EXTRN	_sscanf_s:PROC
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\tokenizer.h
CONST	ENDS
;	COMDAT ?GetInt@TokenizerRow@@QAEHKKH@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
_Column$ = 8						; size = 4
_pOffset$142290 = 12					; size = 4
_Default$ = 12						; size = 4
_Hex$ = 16						; size = 4
?GetInt@TokenizerRow@@QAEHKKH@Z PROC			; TokenizerRow::GetInt, COMDAT
; _this$ = ecx

; 31   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 32   : 		
; 33   : 		std::map<DWORD, std::string>::iterator it = this->Columns.find(Column);

  00007	8d 45 08	 lea	 eax, DWORD PTR _Column$[ebp]
  0000a	50		 push	 eax
  0000b	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  0000e	51		 push	 ecx
  0000f	8b ce		 mov	 ecx, esi
  00011	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find

; 34   : 		
; 35   : 		if(it == this->Columns.end())

  00016	8b 45 fc	 mov	 eax, DWORD PTR _it$[ebp]
  00019	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0001c	5e		 pop	 esi

; 36   : 		{
; 37   : 			return Default;

  0001d	74 29		 je	 SHORT $LN45@GetInt

; 43   : 			sscanf_s(it->second.c_str(), "%x", &pOffset);

  0001f	83 c0 10	 add	 eax, 16			; 00000010H
  00022	83 7d 10 00	 cmp	 DWORD PTR _Hex$[ebp], 0
  00026	74 29		 je	 SHORT $LN1@GetInt

; 38   : 		}
; 39   : 
; 40   : 		if(Hex)
; 41   : 		{
; 42   : 			unsigned int pOffset = Default;

  00028	8b 55 0c	 mov	 edx, DWORD PTR _Default$[ebp]
  0002b	89 55 0c	 mov	 DWORD PTR _pOffset$142290[ebp], edx

; 43   : 			sscanf_s(it->second.c_str(), "%x", &pOffset);

  0002e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00032	72 02		 jb	 SHORT $LN29@GetInt
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
$LN29@GetInt:
  00036	8d 4d 0c	 lea	 ecx, DWORD PTR _pOffset$142290[ebp]
  00039	51		 push	 ecx
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _sscanf_s
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN45@GetInt:

; 44   : 			return pOffset;

  00048	8b 45 0c	 mov	 eax, DWORD PTR _pOffset$142290[ebp]

; 48   : 
; 49   : 	}

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
$LN1@GetInt:

; 45   : 		}
; 46   : 
; 47   : 		return atoi(it->second.c_str());

  00051	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00055	72 02		 jb	 SHORT $LN43@GetInt
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
$LN43@GetInt:
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _atoi
  0005f	83 c4 04	 add	 esp, 4

; 48   : 
; 49   : 	}

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 0c 00	 ret	 12			; 0000000cH
?GetInt@TokenizerRow@@QAEHKKH@Z ENDP			; TokenizerRow::GetInt
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 543  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 544  : 		_Tidy();
; 545  : 		assign(_Right, 0, npos);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	6a ff		 push	 -1
  00009	8b f1		 mov	 esi, ecx
  0000b	6a 00		 push	 0
  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001b	50		 push	 eax
  0001c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 546  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogtp
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 788  : 		{	// append 1 * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 789  : 		return (append((size_type)1, _Ch));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 790  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 929  : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 930  : 		_DEBUG_POINTER(_Ptr);
; 931  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	8b c6		 mov	 eax, esi
  00009	57		 push	 edi
  0000a	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000d	8d 49 00	 npad	 3
$LL5@assign@4:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL5@assign@4
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 932  : 		}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z ; std::basic_istream<char,std::char_traits<char> >::getline
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
;	COMDAT ?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Count$ = 12						; size = 8
?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z PROC ; std::basic_istream<char,std::char_traits<char> >::getline, COMDAT
; _this$ = ecx

; 622  : 		{	// get up to _Count characters into NTCS, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 623  : 		return (getline(_Str, _Count, _Myios::widen('\n')));

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000b	6a 0a		 push	 10			; 0000000aH
  0000d	03 ce		 add	 ecx, esi
  0000f	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
  00014	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp+4]
  00017	0f b6 c8	 movzx	 ecx, al
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __Str$[ebp]
  00021	52		 push	 edx
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	8b ce		 mov	 ecx, esi
  00026	e8 00 00 00 00	 call	 ?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z ; std::basic_istream<char,std::char_traits<char> >::getline
  0002b	5e		 pop	 esi

; 624  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::getline
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_memcpy_s:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0
__ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
__Dest$148858 = -56					; size = 4
__Src$148859 = -52					; size = 4
__Ch$148857 = -45					; size = 1
__Str$148853 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 423  : 		{	// get an element from stream, point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f1		 mov	 esi, ecx

; 424  : 		if (_Mysb::gptr() != 0
; 425  : 			&& _Mysb::gptr() < _Mysb::egptr())

  0002d	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	33 d2		 xor	 edx, edx
  00034	3b c2		 cmp	 eax, edx
  00036	74 27		 je	 SHORT $LN18@uflow@2
  00038	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0003b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003d	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00040	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00042	03 c8		 add	 ecx, eax
  00044	3b c1		 cmp	 eax, ecx
  00046	73 17		 jae	 SHORT $LN18@uflow@2

; 426  : 			return (_Traits::to_int_type(
; 427  : 				*_Mysb::_Gninc()));	// return buffered

  00048	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0004b	ff 08		 dec	 DWORD PTR [eax]
  0004d	8b 76 20	 mov	 esi, DWORD PTR [esi+32]
  00050	8b 06		 mov	 eax, DWORD PTR [esi]
  00052	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00055	89 16		 mov	 DWORD PTR [esi], edx
  00057	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0005a	e9 33 01 00 00	 jmp	 $LN14@uflow@2
$LN18@uflow@2:

; 428  : 		else if (_Myfile == 0)

  0005f	39 56 54	 cmp	 DWORD PTR [esi+84], edx

; 429  : 			return (_Traits::eof());	// no open C stream, fail

  00062	0f 84 27 01 00
	00		 je	 $LN198@uflow@2

; 430  : 		_Reset_back();	// revert from _Mychar buffer

  00068	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0006b	8d 7e 48	 lea	 edi, DWORD PTR [esi+72]
  0006e	39 39		 cmp	 DWORD PTR [ecx], edi
  00070	75 14		 jne	 SHORT $LN41@uflow@2
  00072	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00075	8b 7e 3c	 mov	 edi, DWORD PTR [esi+60]
  00078	89 39		 mov	 DWORD PTR [ecx], edi
  0007a	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0007d	89 01		 mov	 DWORD PTR [ecx], eax
  0007f	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00082	2b c0		 sub	 eax, eax
  00084	89 01		 mov	 DWORD PTR [ecx], eax
$LN41@uflow@2:

; 431  : 		if (_Pcvt == 0)

  00086	39 56 44	 cmp	 DWORD PTR [esi+68], edx
  00089	75 1d		 jne	 SHORT $LN15@uflow@2

; 432  : 			{	// no codecvt facet, just get it
; 433  : 			_Elem _Ch = 0;
; 434  : 			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)
; 435  : 				: _Traits::eof());

  0008b	8b 76 54	 mov	 esi, DWORD PTR [esi+84]
  0008e	56		 push	 esi
  0008f	e8 00 00 00 00	 call	 _fgetc
  00094	83 c4 04	 add	 esp, 4
  00097	83 f8 ff	 cmp	 eax, -1
  0009a	0f 84 ef 00 00
	00		 je	 $LN198@uflow@2
  000a0	0f b6 c0	 movzx	 eax, al
  000a3	e9 ea 00 00 00	 jmp	 $LN14@uflow@2
$LN15@uflow@2:

; 436  : 			}
; 437  : 		else
; 438  : 			{	// build string until codecvt succeeds
; 439  : 			string _Str;

  000a8	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR __Str$148853[ebp+20], 15 ; 0000000fH
  000af	89 55 e4	 mov	 DWORD PTR __Str$148853[ebp+16], edx
  000b2	88 55 d4	 mov	 BYTE PTR __Str$148853[ebp], dl
  000b5	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx

; 440  : 
; 441  : 			for (; ; )
; 442  : 				{	// get using codecvt facet
; 443  : 				_Elem _Ch, *_Dest;
; 444  : 				const char *_Src;
; 445  : 				int _Nleft;
; 446  : 				int _Meta = fgetc(_Myfile);

  000b8	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 _fgetc
  000c1	83 c4 04	 add	 esp, 4

; 447  : 
; 448  : 				if (_Meta == EOF)

  000c4	83 f8 ff	 cmp	 eax, -1
  000c7	0f 84 ba 00 00
	00		 je	 $LN1@uflow@2
$LN13@uflow@2:

; 449  : 					return (_Traits::eof());	// partial char?
; 450  : 
; 451  : 				_Str.append(1, (char)_Meta);	// append byte and convert

  000cd	50		 push	 eax
  000ce	6a 01		 push	 1
  000d0	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148853[ebp]
  000d3	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 452  : 				switch (_Pcvt->in(_State,
; 453  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
; 454  : 					&_Ch, &_Ch + 1, _Dest))

  000d8	8b 4d e8	 mov	 ecx, DWORD PTR __Str$148853[ebp+20]
  000db	8b 45 d4	 mov	 eax, DWORD PTR __Str$148853[ebp]
  000de	8b d0		 mov	 edx, eax
  000e0	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000e3	73 05		 jae	 SHORT $LN105@uflow@2
  000e5	8d 55 d4	 lea	 edx, DWORD PTR __Str$148853[ebp]
  000e8	8b c2		 mov	 eax, edx
$LN105@uflow@2:
  000ea	03 55 e4	 add	 edx, DWORD PTR __Str$148853[ebp+16]
  000ed	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  000f0	8b 39		 mov	 edi, DWORD PTR [ecx]
  000f2	8d 5d c8	 lea	 ebx, DWORD PTR __Dest$148858[ebp]
  000f5	53		 push	 ebx
  000f6	8d 5d d4	 lea	 ebx, DWORD PTR __Ch$148857[ebp+1]
  000f9	53		 push	 ebx
  000fa	8d 5d d3	 lea	 ebx, DWORD PTR __Ch$148857[ebp]
  000fd	53		 push	 ebx
  000fe	8d 5d cc	 lea	 ebx, DWORD PTR __Src$148859[ebp]
  00101	53		 push	 ebx
  00102	52		 push	 edx
  00103	50		 push	 eax
  00104	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  00107	50		 push	 eax
  00108	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0010b	ff d0		 call	 eax
  0010d	85 c0		 test	 eax, eax
  0010f	78 76		 js	 SHORT $LN1@uflow@2
  00111	83 f8 01	 cmp	 eax, 1
  00114	7e 38		 jle	 SHORT $LN8@uflow@2
  00116	83 f8 03	 cmp	 eax, 3
  00119	75 6c		 jne	 SHORT $LN1@uflow@2

; 468  : 					break;
; 469  : 
; 470  : 				case codecvt_base::noconv:
; 471  : 					if (_Str.size() < sizeof (_Elem))

  0011b	83 7d e4 01	 cmp	 DWORD PTR __Str$148853[ebp+16], 1
  0011f	72 51		 jb	 SHORT $LN4@uflow@2

; 472  : 						break;	// no conversion, but need more chars
; 473  : 
; 474  : 					_CRT_SECURE_MEMCPY(&_Ch, sizeof (_Elem), &*_Str.begin(),

  00121	83 7d e8 10	 cmp	 DWORD PTR __Str$148853[ebp+20], 16 ; 00000010H
  00125	8b 45 d4	 mov	 eax, DWORD PTR __Str$148853[ebp]
  00128	73 03		 jae	 SHORT $LN170@uflow@2
  0012a	8d 45 d4	 lea	 eax, DWORD PTR __Str$148853[ebp]
$LN170@uflow@2:
  0012d	6a 01		 push	 1
  0012f	50		 push	 eax
  00130	8d 4d d3	 lea	 ecx, DWORD PTR __Ch$148857[ebp]
  00133	6a 01		 push	 1
  00135	51		 push	 ecx
  00136	e8 00 00 00 00	 call	 _memcpy_s

; 475  : 						sizeof (_Elem));	// copy raw bytes to element
; 476  : 
; 477  : 					return (_Traits::to_int_type(_Ch));	// return result

  0013b	0f b6 75 d3	 movzx	 esi, BYTE PTR __Ch$148857[ebp]
  0013f	83 c4 10	 add	 esp, 16			; 00000010H
  00142	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148853[ebp]
  00145	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0014a	8b c6		 mov	 eax, esi
  0014c	eb 44		 jmp	 SHORT $LN14@uflow@2
$LN8@uflow@2:

; 455  : 					{	// test result of converting one element
; 456  : 				case codecvt_base::partial:
; 457  : 				case codecvt_base::ok:
; 458  : 					if (_Dest != &_Ch)

  0014e	8d 4d d3	 lea	 ecx, DWORD PTR __Ch$148857[ebp]
  00151	39 4d c8	 cmp	 DWORD PTR __Dest$148858[ebp], ecx
  00154	75 58		 jne	 SHORT $LN192@uflow@2

; 464  : 						}
; 465  : 					else
; 466  : 						_Str.erase((size_t)0,	// partial, discard used input
; 467  : 							(size_t)(_Src - &*_Str.begin()));

  00156	83 7d e8 10	 cmp	 DWORD PTR __Str$148853[ebp+20], 16 ; 00000010H
  0015a	8b 45 d4	 mov	 eax, DWORD PTR __Str$148853[ebp]
  0015d	73 03		 jae	 SHORT $LN149@uflow@2
  0015f	8d 45 d4	 lea	 eax, DWORD PTR __Str$148853[ebp]
$LN149@uflow@2:
  00162	8b 55 cc	 mov	 edx, DWORD PTR __Src$148859[ebp]
  00165	2b d0		 sub	 edx, eax
  00167	52		 push	 edx
  00168	6a 00		 push	 0
  0016a	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148853[ebp]
  0016d	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
$LN4@uflow@2:

; 440  : 
; 441  : 			for (; ; )
; 442  : 				{	// get using codecvt facet
; 443  : 				_Elem _Ch, *_Dest;
; 444  : 				const char *_Src;
; 445  : 				int _Nleft;
; 446  : 				int _Meta = fgetc(_Myfile);

  00172	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 _fgetc
  0017b	83 c4 04	 add	 esp, 4

; 447  : 
; 448  : 				if (_Meta == EOF)

  0017e	83 f8 ff	 cmp	 eax, -1
  00181	0f 85 46 ff ff
	ff		 jne	 $LN13@uflow@2
$LN1@uflow@2:

; 478  : 
; 479  : 				default:
; 480  : 					return (_Traits::eof());	// conversion failed

  00187	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148853[ebp]
  0018a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN198@uflow@2:
  0018f	83 c8 ff	 or	 eax, -1
$LN14@uflow@2:

; 481  : 					}
; 482  : 				}
; 483  : 			}
; 484  : 		}

  00192	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00195	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0019c	59		 pop	 ecx
  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	5b		 pop	 ebx
  001a0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a3	33 cd		 xor	 ecx, ebp
  001a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c3		 ret	 0
$LN192@uflow@2:

; 459  : 						{	// got an element, put back excess and deliver it
; 460  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

  001ae	83 7d e8 10	 cmp	 DWORD PTR __Str$148853[ebp+20], 16 ; 00000010H
  001b2	8b 7d d4	 mov	 edi, DWORD PTR __Str$148853[ebp]
  001b5	73 03		 jae	 SHORT $LN126@uflow@2
  001b7	8d 7d d4	 lea	 edi, DWORD PTR __Str$148853[ebp]
$LN126@uflow@2:
  001ba	2b 7d cc	 sub	 edi, DWORD PTR __Src$148859[ebp]
  001bd	03 7d e4	 add	 edi, DWORD PTR __Str$148853[ebp+16]

; 461  : 						for (; 0 < _Nleft; )

  001c0	85 ff		 test	 edi, edi
  001c2	7e 1a		 jle	 SHORT $LN5@uflow@2
$LN6@uflow@2:

; 462  : 							ungetc(_Src[--_Nleft], _Myfile);

  001c4	8b 45 cc	 mov	 eax, DWORD PTR __Src$148859[ebp]
  001c7	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  001ca	0f be 4c 07 ff	 movsx	 ecx, BYTE PTR [edi+eax-1]
  001cf	4f		 dec	 edi
  001d0	52		 push	 edx
  001d1	51		 push	 ecx
  001d2	e8 00 00 00 00	 call	 _ungetc
  001d7	83 c4 08	 add	 esp, 8
  001da	85 ff		 test	 edi, edi
  001dc	7f e6		 jg	 SHORT $LN6@uflow@2
$LN5@uflow@2:

; 463  : 						return (_Traits::to_int_type(_Ch));

  001de	0f b6 75 d3	 movzx	 esi, BYTE PTR __Ch$148857[ebp]
  001e2	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148853[ebp]
  001e5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001ea	8b c6		 mov	 eax, esi
  001ec	eb a4		 jmp	 SHORT $LN14@uflow@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148853[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 571  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 572  : 		_Tidy();
; 573  : 		assign(_Right, _Roff, _Count);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00018	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001f	52		 push	 edx
  00020	8b ce		 mov	 ecx, esi
  00022	c6 06 00	 mov	 BYTE PTR [esi], 0
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 574  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 606  : 		{	// construct from _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		_Tidy();
; 608  : 		assign(_Count, _Ch);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00015	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001c	8b ce		 mov	 ecx, esi
  0001e	c6 06 00	 mov	 BYTE PTR [esi], 0
  00021	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 609  : 		}

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 887  : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 888  : 		return (assign(_Right, 0, npos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	6a ff		 push	 -1
  00008	6a 00		 push	 0
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 889  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >
;	COMDAT ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
CONST	SEGMENT
??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
	DD	08H
CONST	ENDS
;	COMDAT ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
	DD	018H
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$0
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$1
	DD	02H
	DD	00H
__ehfuncinfo$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T171047 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
_$initVBases$ = 12					; size = 4
??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 939  : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002d	33 db		 xor	 ebx, ebx
  0002f	89 5d f0	 mov	 DWORD PTR $T171047[ebp], ebx
  00032	39 5d 0c	 cmp	 DWORD PTR _$initVBases$[ebp], ebx
  00035	74 1e		 je	 SHORT $LN1@basic_iost
  00037	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0003d	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00044	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  0004b	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T171047[ebp], 1
$LN1@basic_iost:
  00055	8b 07		 mov	 eax, DWORD PTR [edi]
  00057	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005a	c7 04 0f 00 00
	00 00		 mov	 DWORD PTR [edi+ecx], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00061	8b 17		 mov	 edx, DWORD PTR [edi]
  00063	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00066	89 5f 0c	 mov	 DWORD PTR [edi+12], ebx
  00069	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0006c	03 f7		 add	 esi, edi
  0006e	8b ce		 mov	 ecx, esi
  00070	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init
  00075	8b 45 08	 mov	 eax, DWORD PTR __Strbuf$[ebp]
  00078	6a 20		 push	 32			; 00000020H
  0007a	8b ce		 mov	 ecx, esi
  0007c	89 46 38	 mov	 DWORD PTR [esi+56], eax
  0007f	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  00082	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
  00087	88 46 40	 mov	 BYTE PTR [esi+64], al
  0008a	39 5e 38	 cmp	 DWORD PTR [esi+56], ebx
  0008d	75 12		 jne	 SHORT $LN30@basic_iost
  0008f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00092	83 c8 04	 or	 eax, 4
  00095	83 c8 04	 or	 eax, 4
  00098	53		 push	 ebx
  00099	50		 push	 eax
  0009a	8b ce		 mov	 ecx, esi
  0009c	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN30@basic_iost:
  000a1	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  000a4	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a7	c7 44 17 10 00
	00 00 00	 mov	 DWORD PTR [edi+edx+16], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  000af	8b 07		 mov	 eax, DWORD PTR [edi]
  000b1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b4	c7 04 0f 00 00
	00 00		 mov	 DWORD PTR [edi+ecx], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@

; 940  : 		}

  000bb	8b c7		 mov	 eax, edi
  000bd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c7	59		 pop	 ecx
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T171047[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_iost
  0000c	83 65 f0 fe	 and	 DWORD PTR $T171047[ebp], -2 ; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 18	 add	 ecx, 24			; 00000018H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@basic_iost:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$1:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 10	 add	 ecx, 16			; 00000010H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__ehhandler$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >
PUBLIC	__$ArrayPad$
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
EXTRN	_fwrite:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ$0
__ehfuncinfo$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
_TEXT	SEGMENT
__Dest$149739 = -48					; size = 4
__Str$149743 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT
; _this$ = ecx

; 587  : 		{	// put shift to initial conversion state, as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx

; 588  : 		if (_Pcvt == 0 || !_Wrotesome)

  0002d	33 db		 xor	 ebx, ebx
  0002f	39 5f 44	 cmp	 DWORD PTR [edi+68], ebx
  00032	0f 84 e9 00 00
	00		 je	 $LN14@Endwrite
  00038	38 5f 49	 cmp	 BYTE PTR [edi+73], bl
  0003b	0f 84 e0 00 00
	00		 je	 $LN14@Endwrite

; 590  : 		else
; 591  : 			{	// may have to put
; 592  : 			const int _STRING_INC = 8;
; 593  : 			char *_Dest;
; 594  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))

  00041	8b 07		 mov	 eax, DWORD PTR [edi]
  00043	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00046	6a ff		 push	 -1
  00048	ff d2		 call	 edx
  0004a	83 f8 ff	 cmp	 eax, -1

; 595  : 				return (false);

  0004d	0f 84 c2 00 00
	00		 je	 $LN220@Endwrite

; 596  : 
; 597  : 			string _Str(_STRING_INC, '\0');

  00053	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00058	33 c0		 xor	 eax, eax
  0005a	88 5d d4	 mov	 BYTE PTR __Str$149743[ebp], bl
  0005d	89 4d e8	 mov	 DWORD PTR __Str$149743[ebp+20], ecx
  00060	89 45 d4	 mov	 DWORD PTR __Str$149743[ebp], eax
  00063	89 45 d8	 mov	 DWORD PTR __Str$149743[ebp+4], eax
  00066	c7 45 e4 08 00
	00 00		 mov	 DWORD PTR __Str$149743[ebp+16], 8
  0006d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00070	73 03		 jae	 SHORT $LN126@Endwrite
  00072	8d 45 d4	 lea	 eax, DWORD PTR __Str$149743[ebp]
$LN126@Endwrite:
  00075	88 58 08	 mov	 BYTE PTR [eax+8], bl
  00078	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
$LN219@Endwrite:
  0007b	8b 45 d4	 mov	 eax, DWORD PTR __Str$149743[ebp]
  0007e	8b 5d e8	 mov	 ebx, DWORD PTR __Str$149743[ebp+20]
$LN11@Endwrite:

; 598  : 			for (; ; )
; 599  : 				switch (_Pcvt->unshift(_State,
; 600  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

  00081	8b d0		 mov	 edx, eax
  00083	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00086	73 05		 jae	 SHORT $LN157@Endwrite
  00088	8d 55 d4	 lea	 edx, DWORD PTR __Str$149743[ebp]
  0008b	8b c2		 mov	 eax, edx
$LN157@Endwrite:
  0008d	03 55 e4	 add	 edx, DWORD PTR __Str$149743[ebp+16]
  00090	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  00093	8b 31		 mov	 esi, DWORD PTR [ecx]
  00095	8d 5d d0	 lea	 ebx, DWORD PTR __Dest$149739[ebp]
  00098	53		 push	 ebx
  00099	52		 push	 edx
  0009a	50		 push	 eax
  0009b	8d 47 4c	 lea	 eax, DWORD PTR [edi+76]
  0009e	50		 push	 eax
  0009f	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000a2	ff d0		 call	 eax
  000a4	83 e8 00	 sub	 eax, 0
  000a7	74 0d		 je	 SHORT $LN7@Endwrite
  000a9	48		 dec	 eax
  000aa	74 0e		 je	 SHORT $LN6@Endwrite
  000ac	83 e8 02	 sub	 eax, 2

; 620  : 
; 621  : 				default:
; 622  : 					return (false);	// conversion failed

  000af	8d 4d d4	 lea	 ecx, DWORD PTR __Str$149743[ebp]
  000b2	75 5c		 jne	 SHORT $LN221@Endwrite

; 615  : 					break;
; 616  : 					}
; 617  : 
; 618  : 				case codecvt_base::noconv:
; 619  : 					return (true);	// nothing to do

  000b4	eb 66		 jmp	 SHORT $LN222@Endwrite
$LN7@Endwrite:

; 601  : 				{	// test result of homing conversion
; 602  : 				case codecvt_base::ok:
; 603  : 					_Wrotesome = false;	// homed successfully

  000b6	c6 47 49 00	 mov	 BYTE PTR [edi+73], 0
$LN6@Endwrite:

; 604  : 
; 605  : 				case codecvt_base::partial:	// fall through
; 606  : 					{	// put any generated bytes
; 607  : 					size_t _Count = _Dest - &*_Str.begin();

  000ba	8b 5d e8	 mov	 ebx, DWORD PTR __Str$149743[ebp+20]
  000bd	8b 45 d4	 mov	 eax, DWORD PTR __Str$149743[ebp]
  000c0	8b c8		 mov	 ecx, eax
  000c2	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000c5	73 03		 jae	 SHORT $LN178@Endwrite
  000c7	8d 4d d4	 lea	 ecx, DWORD PTR __Str$149743[ebp]
$LN178@Endwrite:
  000ca	8b 75 d0	 mov	 esi, DWORD PTR __Dest$149739[ebp]
  000cd	2b f1		 sub	 esi, ecx

; 608  : 					if (0 < _Count && _Count !=
; 609  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))

  000cf	74 22		 je	 SHORT $LN5@Endwrite
  000d1	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000d4	73 03		 jae	 SHORT $LN197@Endwrite
  000d6	8d 45 d4	 lea	 eax, DWORD PTR __Str$149743[ebp]
$LN197@Endwrite:
  000d9	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  000dc	51		 push	 ecx
  000dd	56		 push	 esi
  000de	6a 01		 push	 1
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _fwrite
  000e6	83 c4 10	 add	 esp, 16			; 00000010H
  000e9	3b f0		 cmp	 esi, eax
  000eb	75 20		 jne	 SHORT $LN212@Endwrite
  000ed	8b 5d e8	 mov	 ebx, DWORD PTR __Str$149743[ebp+20]
  000f0	8b 45 d4	 mov	 eax, DWORD PTR __Str$149743[ebp]
$LN5@Endwrite:

; 611  : 					if (!_Wrotesome)

  000f3	80 7f 49 00	 cmp	 BYTE PTR [edi+73], 0
  000f7	74 20		 je	 SHORT $LN213@Endwrite

; 613  : 					if (_Count == 0)

  000f9	85 f6		 test	 esi, esi
  000fb	75 84		 jne	 SHORT $LN11@Endwrite

; 614  : 						_Str.append(_STRING_INC, '\0');	// try with more space

  000fd	56		 push	 esi
  000fe	6a 08		 push	 8
  00100	8d 4d d4	 lea	 ecx, DWORD PTR __Str$149743[ebp]
  00103	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 623  : 				}

  00108	e9 6e ff ff ff	 jmp	 $LN219@Endwrite
$LN212@Endwrite:

; 610  : 						return (false);	// write failed

  0010d	8d 4d d4	 lea	 ecx, DWORD PTR __Str$149743[ebp]
$LN221@Endwrite:
  00110	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN220@Endwrite:
  00115	32 c0		 xor	 al, al
  00117	eb 0a		 jmp	 SHORT $LN13@Endwrite
$LN213@Endwrite:

; 612  : 						return (true);

  00119	8d 4d d4	 lea	 ecx, DWORD PTR __Str$149743[ebp]
$LN222@Endwrite:
  0011c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN14@Endwrite:

; 589  : 			return (true);

  00121	b0 01		 mov	 al, 1
$LN13@Endwrite:

; 624  : 			}
; 625  : 		}

  00123	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00126	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012d	59		 pop	 ecx
  0012e	5f		 pop	 edi
  0012f	5e		 pop	 esi
  00130	5b		 pop	 ebx
  00131	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00134	33 cd		 xor	 ecx, ebp
  00136	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Str$149743[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	??$_Destroy@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 63   : 	_Ptr->~_Ty();

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  0000b	72 0c		 jb	 SHORT $LN20@Destroy
  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$LN20@Destroy:
  00019	33 c0		 xor	 eax, eax
  0001b	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00022	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00025	88 46 04	 mov	 BYTE PTR [esi+4], al
  00028	5e		 pop	 esi

; 64   : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$_Destroy@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$?0ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Val2$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 0e		 mov	 DWORD PTR [esi], ecx
  00010	6a ff		 push	 -1
  00012	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00015	6a 00		 push	 0
  00017	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0001e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00025	52		 push	 edx
  00026	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00029	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 164  : 		}

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
??$?0ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 592  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		_Tidy();
; 594  : 		assign(_Ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b c2		 mov	 eax, edx
  0000b	57		 push	 edi
  0000c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00013	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001a	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001d	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$LL31@basic_stri@2:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL31@basic_stri@2
  00027	2b c7		 sub	 eax, edi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00032	5f		 pop	 edi

; 595  : 		}

  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 763  : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 764  : 		return (assign(_Right));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	6a ff		 push	 -1
  00008	6a 00		 push	 0
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 765  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 768  : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 769  : 		return (assign(_Ptr));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	8b c6		 mov	 eax, esi
  00009	57		 push	 edi
  0000a	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000d	8d 49 00	 npad	 3
$LL7@operator@10:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL7@operator@10
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 770  : 		}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
; Function compile flags: /Ogtp
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T172253 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 1848 : 		{	// return [_Off, _Off + _Count) as new string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1849 : 		return (_Myt(*this, _Off, _Count, get_allocator()));

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00010	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00017	89 45 fc	 mov	 DWORD PTR $T172253[ebp], eax
  0001a	88 06		 mov	 BYTE PTR [esi], al
  0001c	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0001f	50		 push	 eax
  00020	52		 push	 edx
  00021	51		 push	 ecx
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi

; 1850 : 		}

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z$0
__ehfuncinfo$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Src$148709 = -56					; size = 4
__Dest$148710 = -52					; size = 4
__Ch$148708 = -48					; size = 1
__Str$148711 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Meta$ = 8						; size = 4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 322  : 		{	// put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 323  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  0002b	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]

; 324  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  0002e	33 c0		 xor	 eax, eax
  00030	8b f1		 mov	 esi, ecx
  00032	83 fb ff	 cmp	 ebx, -1
  00035	0f 84 94 01 00
	00		 je	 $LN14@overflow

; 325  : 		else if (_Mysb::pptr() != 0
; 326  : 			&& _Mysb::pptr() < _Mysb::epptr())

  0003b	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	3b d0		 cmp	 edx, eax
  00042	74 20		 je	 SHORT $LN18@overflow
  00044	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00047	8b 39		 mov	 edi, DWORD PTR [ecx]
  00049	03 fa		 add	 edi, edx
  0004b	3b d7		 cmp	 edx, edi
  0004d	73 15		 jae	 SHORT $LN18@overflow

; 327  : 			{	// room in buffer, store it
; 328  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  0004f	ff 09		 dec	 DWORD PTR [ecx]
  00051	8b 76 24	 mov	 esi, DWORD PTR [esi+36]
  00054	8b 06		 mov	 eax, DWORD PTR [esi]
  00056	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00059	89 0e		 mov	 DWORD PTR [esi], ecx
  0005b	88 18		 mov	 BYTE PTR [eax], bl

; 329  : 			return (_Meta);

  0005d	8b c3		 mov	 eax, ebx
  0005f	e9 6b 01 00 00	 jmp	 $LN14@overflow
$LN18@overflow:

; 330  : 			}
; 331  : 		else if (_Myfile == 0)

  00064	39 46 54	 cmp	 DWORD PTR [esi+84], eax

; 332  : 			return (_Traits::eof());	// no open C stream, fail

  00067	0f 84 5f 01 00
	00		 je	 $LN270@overflow

; 333  : 		_Reset_back();	// revert from _Mychar buffer

  0006d	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00070	8d 7e 48	 lea	 edi, DWORD PTR [esi+72]
  00073	39 3a		 cmp	 DWORD PTR [edx], edi
  00075	75 14		 jne	 SHORT $LN57@overflow
  00077	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  0007a	8b 7e 3c	 mov	 edi, DWORD PTR [esi+60]
  0007d	89 3a		 mov	 DWORD PTR [edx], edi
  0007f	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00082	89 0a		 mov	 DWORD PTR [edx], ecx
  00084	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00087	2b c9		 sub	 ecx, ecx
  00089	89 0a		 mov	 DWORD PTR [edx], ecx
$LN57@overflow:

; 334  : 		if (_Pcvt == 0)

  0008b	39 46 44	 cmp	 DWORD PTR [esi+68], eax
  0008e	75 20		 jne	 SHORT $LN15@overflow

; 335  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)
; 336  : 				? _Meta : _Traits::eof());	// no codecvt facet, put as is

  00090	8b 76 54	 mov	 esi, DWORD PTR [esi+84]
  00093	0f be c3	 movsx	 eax, bl
  00096	56		 push	 esi
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _fputc
  0009d	83 c4 08	 add	 esp, 8
  000a0	83 f8 ff	 cmp	 eax, -1
  000a3	0f 84 23 01 00
	00		 je	 $LN270@overflow
  000a9	8b c3		 mov	 eax, ebx
  000ab	e9 1f 01 00 00	 jmp	 $LN14@overflow
$LN15@overflow:

; 337  : 		else
; 338  : 			{	// put using codecvt facet
; 339  : 			const int _STRING_INC = 8;
; 340  : 			const _Elem _Ch = _Traits::to_char_type(_Meta);
; 341  : 			const _Elem *_Src;
; 342  : 			char *_Dest;
; 343  : 
; 344  : 			string _Str(_STRING_INC, '\0');

  000b0	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  000b5	8b d0		 mov	 edx, eax
  000b7	88 45 d4	 mov	 BYTE PTR __Str$148711[ebp], al
  000ba	88 5d d0	 mov	 BYTE PTR __Ch$148708[ebp], bl
  000bd	89 4d e8	 mov	 DWORD PTR __Str$148711[ebp+20], ecx
  000c0	89 55 d4	 mov	 DWORD PTR __Str$148711[ebp], edx
  000c3	89 45 d8	 mov	 DWORD PTR __Str$148711[ebp+4], eax
  000c6	c7 45 e4 08 00
	00 00		 mov	 DWORD PTR __Str$148711[ebp+16], 8
  000cd	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000d0	73 03		 jae	 SHORT $LN168@overflow
  000d2	8d 55 d4	 lea	 edx, DWORD PTR __Str$148711[ebp]
$LN168@overflow:
  000d5	88 42 08	 mov	 BYTE PTR [edx+8], al
  000d8	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
$LN273@overflow:
  000db	8b 45 d4	 mov	 eax, DWORD PTR __Str$148711[ebp]
  000de	8b 5d e8	 mov	 ebx, DWORD PTR __Str$148711[ebp+20]
$LN13@overflow:

; 345  : 			for (; ; )
; 346  : 				switch (_Pcvt->out(_State,
; 347  : 					&_Ch, &_Ch + 1, _Src,
; 348  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

  000e1	8b d0		 mov	 edx, eax
  000e3	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000e6	73 05		 jae	 SHORT $LN199@overflow
  000e8	8d 55 d4	 lea	 edx, DWORD PTR __Str$148711[ebp]
  000eb	8b c2		 mov	 eax, edx
$LN199@overflow:
  000ed	03 55 e4	 add	 edx, DWORD PTR __Str$148711[ebp+16]
  000f0	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  000f3	8b 39		 mov	 edi, DWORD PTR [ecx]
  000f5	8d 5d cc	 lea	 ebx, DWORD PTR __Dest$148710[ebp]
  000f8	53		 push	 ebx
  000f9	52		 push	 edx
  000fa	50		 push	 eax
  000fb	8d 55 c8	 lea	 edx, DWORD PTR __Src$148709[ebp]
  000fe	52		 push	 edx
  000ff	8d 45 d1	 lea	 eax, DWORD PTR __Ch$148708[ebp+1]
  00102	50		 push	 eax
  00103	8d 55 d0	 lea	 edx, DWORD PTR __Ch$148708[ebp]
  00106	52		 push	 edx
  00107	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  0010a	50		 push	 eax
  0010b	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0010e	ff d0		 call	 eax
  00110	85 c0		 test	 eax, eax
  00112	0f 88 ac 00 00
	00		 js	 $LN1@overflow
  00118	83 f8 01	 cmp	 eax, 1
  0011b	7f 63		 jg	 SHORT $LN264@overflow

; 349  : 				{	// test result of converting one element
; 350  : 				case codecvt_base::partial:
; 351  : 				case codecvt_base::ok:
; 352  : 					{	// converted something, try to put it out
; 353  : 					size_t _Count = _Dest - &*_Str.begin();

  0011d	8b 5d e8	 mov	 ebx, DWORD PTR __Str$148711[ebp+20]
  00120	8b 45 d4	 mov	 eax, DWORD PTR __Str$148711[ebp]
  00123	8b c8		 mov	 ecx, eax
  00125	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00128	73 03		 jae	 SHORT $LN220@overflow
  0012a	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
$LN220@overflow:
  0012d	8b 7d cc	 mov	 edi, DWORD PTR __Dest$148710[ebp]
  00130	2b f9		 sub	 edi, ecx

; 354  : 					if (0 < _Count && _Count !=
; 355  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))

  00132	74 22		 je	 SHORT $LN8@overflow
  00134	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00137	73 03		 jae	 SHORT $LN239@overflow
  00139	8d 45 d4	 lea	 eax, DWORD PTR __Str$148711[ebp]
$LN239@overflow:
  0013c	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  0013f	51		 push	 ecx
  00140	57		 push	 edi
  00141	6a 01		 push	 1
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 _fwrite
  00149	83 c4 10	 add	 esp, 16			; 00000010H
  0014c	3b f8		 cmp	 edi, eax
  0014e	75 74		 jne	 SHORT $LN1@overflow
  00150	8b 5d e8	 mov	 ebx, DWORD PTR __Str$148711[ebp+20]
  00153	8b 45 d4	 mov	 eax, DWORD PTR __Str$148711[ebp]
$LN8@overflow:

; 356  : 						return (_Traits::eof());	// write failed
; 357  : 
; 358  : 					_Wrotesome = true;	// write succeeded
; 359  : 					if (_Src != &_Ch)

  00156	8d 55 d0	 lea	 edx, DWORD PTR __Ch$148708[ebp]
  00159	c6 46 49 01	 mov	 BYTE PTR [esi+73], 1
  0015d	39 55 c8	 cmp	 DWORD PTR __Src$148709[ebp], edx
  00160	75 55		 jne	 SHORT $LN266@overflow

; 361  : 
; 362  : 					if (0 < _Count)

  00162	85 ff		 test	 edi, edi
  00164	0f 85 77 ff ff
	ff		 jne	 $LN13@overflow

; 363  : 						;
; 364  : 					else if (_Str.size() < 4 * _STRING_INC)

  0016a	83 7d e4 20	 cmp	 DWORD PTR __Str$148711[ebp+16], 32 ; 00000020H

; 365  : 						_Str.append(_STRING_INC, '\0');	// try with more space

  0016e	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
  00171	73 54		 jae	 SHORT $LN4@overflow
  00173	57		 push	 edi
  00174	6a 08		 push	 8
  00176	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 377  : 				}

  0017b	e9 5b ff ff ff	 jmp	 $LN273@overflow
$LN264@overflow:

; 345  : 			for (; ; )
; 346  : 				switch (_Pcvt->out(_State,
; 347  : 					&_Ch, &_Ch + 1, _Src,
; 348  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

  00180	83 f8 03	 cmp	 eax, 3
  00183	75 3f		 jne	 SHORT $LN1@overflow

; 366  : 					else
; 367  : 						return (_Traits::eof());	// conversion failed
; 368  : 					break;
; 369  : 					}
; 370  : 
; 371  : 				case codecvt_base::noconv:
; 372  : 					return (_Fputc(_Ch, _Myfile) ? _Meta
; 373  : 						: _Traits::eof());	// no conversion, put as is

  00185	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00188	8b 4d d0	 mov	 ecx, DWORD PTR __Ch$148708[ebp]
  0018b	50		 push	 eax
  0018c	51		 push	 ecx
  0018d	e8 00 00 00 00	 call	 ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ; std::_Fputc<char>
  00192	83 c4 08	 add	 esp, 8
  00195	84 c0		 test	 al, al
  00197	74 0f		 je	 SHORT $LN25@overflow
  00199	8b 75 08	 mov	 esi, DWORD PTR __Meta$[ebp]
  0019c	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
  0019f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001a4	8b c6		 mov	 eax, esi
  001a6	eb 27		 jmp	 SHORT $LN14@overflow
$LN25@overflow:
  001a8	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
  001ab	83 ce ff	 or	 esi, -1
  001ae	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001b3	8b c6		 mov	 eax, esi
  001b5	eb 18		 jmp	 SHORT $LN14@overflow
$LN266@overflow:

; 360  : 						return (_Meta);	// converted whole element

  001b7	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
  001ba	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001bf	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  001c2	eb 0b		 jmp	 SHORT $LN14@overflow
$LN1@overflow:

; 374  : 
; 375  : 				default:
; 376  : 					return (_Traits::eof());	// conversion failed

  001c4	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
$LN4@overflow:
  001c7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN270@overflow:
  001cc	83 c8 ff	 or	 eax, -1
$LN14@overflow:

; 378  : 			}
; 379  : 		}

  001cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d9	59		 pop	 ecx
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	5b		 pop	 ebx
  001dd	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e0	33 cd		 xor	 ecx, ebp
  001e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
EXTRN	_fgetpos:PROC
EXTRN	__fseeki64:PROC
; Function compile flags: /Ogtp
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Fileposition$ = 12					; size = 8
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 490  : 		{	// change position by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 491  : 		fpos_t _Fileposition;
; 492  : 
; 493  : 		if (_Mysb::gptr() == &_Mychar	// something putback
; 494  : 			&& _Way == ios_base::cur	// a relative seek
; 495  : 			&& _Pcvt == 0)	// not converting

  00007	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0000a	8d 46 48	 lea	 eax, DWORD PTR [esi+72]
  0000d	57		 push	 edi
  0000e	39 01		 cmp	 DWORD PTR [ecx], eax
  00010	75 1a		 jne	 SHORT $LN22@seekoff
  00012	83 7d 14 01	 cmp	 DWORD PTR __Way$[ebp], 1
  00016	75 14		 jne	 SHORT $LN22@seekoff
  00018	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  0001c	75 0e		 jne	 SHORT $LN22@seekoff

; 496  : 			_Off -= (off_type)sizeof (_Elem);	// back up over _Elem bytes

  0001e	8b 5d 0c	 mov	 ebx, DWORD PTR __Off$[ebp]
  00021	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00024	83 c3 ff	 add	 ebx, -1
  00027	83 d7 ff	 adc	 edi, -1
  0002a	eb 06		 jmp	 SHORT $LN5@seekoff
$LN22@seekoff:
  0002c	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0002f	8b 5d 0c	 mov	 ebx, DWORD PTR __Off$[ebp]
$LN5@seekoff:

; 497  : 
; 498  : 		if (_Myfile == 0 || !_Endwrite()
; 499  : 			|| (_Off != 0 || _Way != ios_base::cur)
; 500  : 				&& _FSEEK_OFF(_Myfile, _Off, _Way) != 0
; 501  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  00032	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  00036	0f 84 88 00 00
	00		 je	 $LN24@seekoff
  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00043	84 c0		 test	 al, al
  00045	74 7d		 je	 SHORT $LN24@seekoff
  00047	8b d3		 mov	 edx, ebx
  00049	0b d7		 or	 edx, edi
  0004b	75 06		 jne	 SHORT $LN23@seekoff
  0004d	83 7d 14 01	 cmp	 DWORD PTR __Way$[ebp], 1
  00051	74 16		 je	 SHORT $LN2@seekoff
$LN23@seekoff:
  00053	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00056	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  00059	50		 push	 eax
  0005a	57		 push	 edi
  0005b	53		 push	 ebx
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 __fseeki64
  00062	83 c4 10	 add	 esp, 16			; 00000010H
  00065	85 c0		 test	 eax, eax
  00067	75 5b		 jne	 SHORT $LN24@seekoff
$LN2@seekoff:
  00069	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0006c	8d 55 0c	 lea	 edx, DWORD PTR __Fileposition$[ebp]
  0006f	52		 push	 edx
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _fgetpos
  00076	83 c4 08	 add	 esp, 8
  00079	85 c0		 test	 eax, eax
  0007b	75 47		 jne	 SHORT $LN24@seekoff

; 503  : 
; 504  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

  0007d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00080	8d 46 48	 lea	 eax, DWORD PTR [esi+72]
  00083	39 01		 cmp	 DWORD PTR [ecx], eax
  00085	75 14		 jne	 SHORT $LN17@seekoff
  00087	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  0008a	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0008d	89 11		 mov	 DWORD PTR [ecx], edx
  0008f	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00092	89 01		 mov	 DWORD PTR [ecx], eax
  00094	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00097	2b c0		 sub	 eax, eax
  00099	89 02		 mov	 DWORD PTR [edx], eax
$LN17@seekoff:

; 505  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  0009b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0009e	8b 4d 0c	 mov	 ecx, DWORD PTR __Fileposition$[ebp]
  000a1	8b 55 10	 mov	 edx, DWORD PTR __Fileposition$[ebp+4]
  000a4	5f		 pop	 edi
  000a5	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000a8	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  000ab	5e		 pop	 esi
  000ac	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000b2	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000b9	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000bc	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000bf	5b		 pop	 ebx

; 506  : 			_Fileposition));	// return new position
; 507  : 		}

  000c0	5d		 pop	 ebp
  000c1	c2 14 00	 ret	 20			; 00000014H
$LN24@seekoff:

; 502  : 			return (pos_type(_BADOFF));	// report failure

  000c4	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000c7	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB+4
  000cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?_BADOFF@std@@3_JB
  000d3	5f		 pop	 edi
  000d4	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000d7	33 c9		 xor	 ecx, ecx
  000d9	5e		 pop	 esi
  000da	89 10		 mov	 DWORD PTR [eax], edx
  000dc	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000df	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  000e2	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000e5	5b		 pop	 ebx

; 506  : 			_Fileposition));	// return new position
; 507  : 		}

  000e6	5d		 pop	 ebp
  000e7	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
EXTRN	_fsetpos:PROC
; Function compile flags: /Ogtp
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT
__Fileposition$ = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 512  : 		{	// change position to _Pos

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 513  : 		fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);

  00006	8b 45 14	 mov	 eax, DWORD PTR __Pos$[ebp+8]
  00009	53		 push	 ebx

; 514  : 		off_type _Off = (off_type)_Pos - (off_type)_FPOSOFF(_Fileposition);

  0000a	8b 5d 10	 mov	 ebx, DWORD PTR __Pos$[ebp+4]
  0000d	56		 push	 esi
  0000e	8b f1		 mov	 esi, ecx
  00010	8b 4d 18	 mov	 ecx, DWORD PTR __Pos$[ebp+12]
  00013	89 4d fc	 mov	 DWORD PTR __Fileposition$[ebp+4], ecx

; 515  : 
; 516  : 		if (_Myfile == 0 || !_Endwrite()
; 517  : 			|| fsetpos(_Myfile, &_Fileposition) != 0
; 518  : 			|| _Off != 0 && _FSEEK_OFF(_Myfile, _Off, SEEK_CUR) != 0
; 519  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  00016	33 c9		 xor	 ecx, ecx
  00018	57		 push	 edi
  00019	8b 7d 0c	 mov	 edi, DWORD PTR __Pos$[ebp]
  0001c	89 45 f8	 mov	 DWORD PTR __Fileposition$[ebp], eax
  0001f	39 4e 54	 cmp	 DWORD PTR [esi+84], ecx
  00022	0f 84 87 00 00
	00		 je	 $LN2@seekpos
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0002f	84 c0		 test	 al, al
  00031	74 7a		 je	 SHORT $LN16@seekpos
  00033	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00036	8d 55 f8	 lea	 edx, DWORD PTR __Fileposition$[ebp]
  00039	52		 push	 edx
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _fsetpos
  00040	83 c4 08	 add	 esp, 8
  00043	85 c0		 test	 eax, eax
  00045	75 66		 jne	 SHORT $LN16@seekpos
  00047	8b cf		 mov	 ecx, edi
  00049	0b cb		 or	 ecx, ebx
  0004b	74 14		 je	 SHORT $LN1@seekpos
  0004d	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  00050	6a 01		 push	 1
  00052	53		 push	 ebx
  00053	57		 push	 edi
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 __fseeki64
  0005a	83 c4 10	 add	 esp, 16			; 00000010H
  0005d	85 c0		 test	 eax, eax
  0005f	75 4c		 jne	 SHORT $LN16@seekpos
$LN1@seekpos:
  00061	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  00064	8d 45 f8	 lea	 eax, DWORD PTR __Fileposition$[ebp]
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _fgetpos
  0006e	83 c4 08	 add	 esp, 8
  00071	85 c0		 test	 eax, eax
  00073	75 38		 jne	 SHORT $LN16@seekpos

; 521  : 
; 522  : 		_State = _POS_TYPE_TO_STATE(_Pos);

  00075	8b 55 1c	 mov	 edx, DWORD PTR __Pos$[ebp+16]

; 523  : 
; 524  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

  00078	8b ce		 mov	 ecx, esi
  0007a	89 56 4c	 mov	 DWORD PTR [esi+76], edx
  0007d	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 525  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  00082	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00085	8b 4d f8	 mov	 ecx, DWORD PTR __Fileposition$[ebp]
  00088	8b 55 fc	 mov	 edx, DWORD PTR __Fileposition$[ebp+4]
  0008b	5f		 pop	 edi
  0008c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0008f	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  00092	5e		 pop	 esi
  00093	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00099	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000a0	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000a3	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000a6	5b		 pop	 ebx

; 526  : 			_Fileposition));	// return new position
; 527  : 		}

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 20 00	 ret	 32			; 00000020H
$LN16@seekpos:

; 525  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000ad	33 c9		 xor	 ecx, ecx
$LN2@seekpos:

; 520  : 			return (pos_type(_BADOFF));	// report failure

  000af	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?_BADOFF@std@@3_JB
  000b8	5f		 pop	 edi
  000b9	89 10		 mov	 DWORD PTR [eax], edx
  000bb	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?_BADOFF@std@@3_JB+4
  000c1	5e		 pop	 esi
  000c2	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000c5	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000c8	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  000cb	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000ce	5b		 pop	 ebx

; 526  : 			_Fileposition));	// return new position
; 527  : 		}

  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 713  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 714  : 		if (this == &_Right)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 5d		 je	 SHORT $LN45@assign@5

; 715  : 			;
; 716  : 		else if (get_allocator() != _Right.get_allocator()
; 717  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 718  : 			*this = _Right;
; 719  : 		else
; 720  : 			{	// not same, clear this and steal from _Right
; 721  : 			_Tidy(true);

  0000e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00012	72 0b		 jb	 SHORT $LN33@assign@5
  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
$LN33@assign@5:
  0001f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00026	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002d	c6 06 00	 mov	 BYTE PTR [esi], 0

; 722  : 			if (_Right._Myres < this->_BUF_SIZE)

  00030	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00034	73 11		 jae	 SHORT $LN2@assign@5

; 723  : 				_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 724  : 					_Right._Mysize + 1);

  00036	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00039	41		 inc	 ecx
  0003a	51		 push	 ecx
  0003b	57		 push	 edi
  0003c	56		 push	 esi
  0003d	e8 00 00 00 00	 call	 _memmove
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 725  : 			else

  00045	eb 0a		 jmp	 SHORT $LN1@assign@5
$LN2@assign@5:

; 726  : 				{	// copy pointer
; 727  : 				this->_Bx._Ptr = _Right._Bx._Ptr;

  00047	8b 17		 mov	 edx, DWORD PTR [edi]
  00049	89 16		 mov	 DWORD PTR [esi], edx

; 728  : 				_Right._Bx._Ptr = 0;

  0004b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1@assign@5:

; 729  : 				}
; 730  : 			this->_Mysize = _Right._Mysize;

  00051	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00054	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 731  : 			this->_Myres = _Right._Myres;

  00057	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0005a	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 732  : 
; 733  : 			_Right._Mysize = 0;

  0005d	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 734  : 			_Right._Myres = 0;

  00064	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
$LN45@assign@5:

; 735  : 			}
; 736  : 		return (*this);

  0006b	5f		 pop	 edi
  0006c	8b c6		 mov	 eax, esi
  0006e	5e		 pop	 esi

; 737  : 		}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
EXTRN	_fclose:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 292  : 		{	// close the C stream

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 293  : 		_Myt *_Ans = this;
; 294  : 		if (_Myfile == 0)

  00004	33 db		 xor	 ebx, ebx
  00006	57		 push	 edi
  00007	8b fe		 mov	 edi, esi
  00009	39 5e 54	 cmp	 DWORD PTR [esi+84], ebx

; 295  : 			_Ans = 0;
; 296  : 		else

  0000c	74 1b		 je	 SHORT $LN18@close

; 297  : 			{	// put any homing sequence and close file
; 298  : 			if (!_Endwrite())

  0000e	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00013	84 c0		 test	 al, al
  00015	75 02		 jne	 SHORT $LN2@close

; 299  : 				_Ans = 0;

  00017	33 ff		 xor	 edi, edi
$LN2@close:

; 300  : 			if (fclose(_Myfile) != 0)

  00019	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _fclose
  00022	83 c4 04	 add	 esp, 4
  00025	85 c0		 test	 eax, eax
  00027	74 02		 je	 SHORT $LN1@close
$LN18@close:

; 301  : 				_Ans = 0;

  00029	33 ff		 xor	 edi, edi
$LN1@close:

; 302  : 			}
; 303  : 		_Init(0, _Closefl);

  0002b	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0002e	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00031	88 5e 50	 mov	 BYTE PTR [esi+80], bl
  00034	88 5e 49	 mov	 BYTE PTR [esi+73], bl
  00037	8d 56 18	 lea	 edx, DWORD PTR [esi+24]
  0003a	89 56 20	 mov	 DWORD PTR [esi+32], edx
  0003d	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00040	89 4e 24	 mov	 DWORD PTR [esi+36], ecx
  00043	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00046	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00049	8d 56 28	 lea	 edx, DWORD PTR [esi+40]
  0004c	89 56 30	 mov	 DWORD PTR [esi+48], edx
  0004f	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00052	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  00055	89 18		 mov	 DWORD PTR [eax], ebx
  00057	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  0005a	89 1a		 mov	 DWORD PTR [edx], ebx
  0005c	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0005f	89 18		 mov	 DWORD PTR [eax], ebx
  00061	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00064	89 19		 mov	 DWORD PTR [ecx], ebx
  00066	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00069	89 1a		 mov	 DWORD PTR [edx], ebx
  0006b	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0006e	89 18		 mov	 DWORD PTR [eax], ebx
  00070	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA

; 304  : 		return (_Ans);

  00079	8b c7		 mov	 eax, edi
  0007b	5f		 pop	 edi
  0007c	89 5e 44	 mov	 DWORD PTR [esi+68], ebx
  0007f	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx

; 305  : 		}

  00084	c3		 ret	 0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 213  : 		_Destroy(_Ptr);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  0000b	72 0c		 jb	 SHORT $LN22@destroy
  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$LN22@destroy:
  00019	33 c0		 xor	 eax, eax
  0001b	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00022	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00025	88 46 04	 mov	 BYTE PTR [esi+4], al
  00028	5e		 pop	 esi

; 214  : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy
_TEXT	ENDS
PUBLIC	??$?0$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@AAU01@@Z ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@AAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@AAU01@@Z PROC ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 195  : 		{	// construct from compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 0e		 mov	 DWORD PTR [esi], ecx
  0000d	6a ff		 push	 -1
  0000f	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00012	6a 00		 push	 0
  00014	83 c0 04	 add	 eax, 4
  00017	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0001e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00025	50		 push	 eax
  00026	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00029	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 196  : 		}

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??$?0$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@AAU01@@Z ENDP ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 702  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 703  : 		_Tidy();
; 704  : 		assign(_STD forward<_Myt>(_Right));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	50		 push	 eax
  00018	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 705  : 		}

  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 708  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 710  : 		}

  00003	5d		 pop	 ebp

; 709  : 		return (assign(_STD forward<_Myt>(_Right)));

  00004	e9 00 00 00 00	 jmp	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::close
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
;	COMDAT ?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 1340 : 		{	// close the C stream

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1341 : 		if (_Filebuffer.close() == 0)

  00003	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00006	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  0000b	85 c0		 test	 eax, eax
  0000d	75 1f		 jne	 SHORT $LN9@close@2

; 1342 : 			_Myios::setstate(ios_base::failbit);

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
  00018	03 ce		 add	 ecx, esi
  0001a	83 c8 02	 or	 eax, 2
  0001d	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00021	75 03		 jne	 SHORT $LN11@close@2
  00023	83 c8 04	 or	 eax, 4
$LN11@close@2:
  00026	6a 00		 push	 0
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN9@close@2:
  0002e	5e		 pop	 esi

; 1343 : 		}

  0002f	c3		 ret	 0
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::close
_TEXT	ENDS
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ$0
__ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 143  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 144  : 		if (_Myfile != 0)

  0002f	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	74 1e		 je	 SHORT $LN11@basic_file

; 145  : 			_Reset_back();	// revert from _Mychar buffer

  0003c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0003f	8d 56 48	 lea	 edx, DWORD PTR [esi+72]
  00042	39 11		 cmp	 DWORD PTR [ecx], edx
  00044	75 14		 jne	 SHORT $LN11@basic_file
  00046	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  00049	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0004c	89 11		 mov	 DWORD PTR [ecx], edx
  0004e	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00051	89 01		 mov	 DWORD PTR [ecx], eax
  00053	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00056	2b c0		 sub	 eax, eax
  00058	89 02		 mov	 DWORD PTR [edx], eax
$LN11@basic_file:

; 146  : 		if (_Closef)

  0005a	80 7e 50 00	 cmp	 BYTE PTR [esi+80], 0
  0005e	74 07		 je	 SHORT $LN1@basic_file

; 147  : 			close();

  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN1@basic_file:

; 148  : 		}

  00067	8b ce		 mov	 ecx, esi
  00069	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00070	e8 00 00 00 00	 call	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
  00075	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00078	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007f	59		 pop	 ecx
  00080	5e		 pop	 esi
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$0
__ehfuncinfo$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0002f	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	74 1e		 je	 SHORT $LN14@scalar@19
  0003c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0003f	8d 56 48	 lea	 edx, DWORD PTR [esi+72]
  00042	39 11		 cmp	 DWORD PTR [ecx], edx
  00044	75 14		 jne	 SHORT $LN14@scalar@19
  00046	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  00049	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0004c	89 11		 mov	 DWORD PTR [ecx], edx
  0004e	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00051	89 01		 mov	 DWORD PTR [ecx], eax
  00053	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00056	2b c0		 sub	 eax, eax
  00058	89 02		 mov	 DWORD PTR [edx], eax
$LN14@scalar@19:
  0005a	80 7e 50 00	 cmp	 BYTE PTR [esi+80], 0
  0005e	74 07		 je	 SHORT $LN4@scalar@19
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN4@scalar@19:
  00067	8b ce		 mov	 ecx, esi
  00069	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00070	e8 00 00 00 00	 call	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
  00075	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00079	74 09		 je	 SHORT $LN16@scalar@19
  0007b	56		 push	 esi
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00081	83 c4 04	 add	 esp, 4
$LN16@scalar@19:
  00084	8b c6		 mov	 eax, esi
  00086	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00089	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00090	59		 pop	 ecx
  00091	5e		 pop	 esi
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??0?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Val2$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 0e		 mov	 DWORD PTR [esi], ecx
  00010	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00013	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0001a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00021	52		 push	 edx
  00022	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 146  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 287  : 	_Alval.destroy(_Pdest);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Pdest$[ebp]
  00007	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  0000b	72 0c		 jb	 SHORT $LN24@Dest_val
  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$LN24@Dest_val:
  00019	33 c0		 xor	 eax, eax
  0001b	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00022	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00025	88 46 04	 mov	 BYTE PTR [esi+4], al
  00028	5e		 pop	 esi

; 288  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	3d fe ff ff 07	 cmp	 eax, 134217726		; 07fffffeH
  0000e	72 23		 jb	 SHORT $LN17@Insert

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  00010	8b 75 14	 mov	 esi, DWORD PTR __Newnode$[ebp]
  00013	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00016	50		 push	 eax
  00017	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0002e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN377@Insert:
$LN17@Insert:

; 1640 : 			}
; 1641 : 		++this->_Mysize;
; 1642 : 		_Newnode->_Parent = _Wherenode;

  00033	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00036	40		 inc	 eax
  00037	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0003a	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0003d	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00040	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00043	32 db		 xor	 bl, bl
  00045	3b c2		 cmp	 eax, edx
  00047	75 10		 jne	 SHORT $LN16@Insert

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00049	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1647 : 			_Lmost() = _Newnode;

  0004c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004f	89 3a		 mov	 DWORD PTR [edx], edi

; 1648 : 			_Rmost() = _Newnode;

  00051	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00054	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00057	eb 20		 jmp	 SHORT $LN11@Insert
$LN16@Insert:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  00059	38 5d 0c	 cmp	 BYTE PTR __Addleft$[ebp], bl
  0005c	74 0d		 je	 SHORT $LN14@Insert

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  0005e	89 38		 mov	 DWORD PTR [eax], edi

; 1653 : 			if (_Wherenode == _Lmost())

  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	3b 02		 cmp	 eax, DWORD PTR [edx]
  00065	75 12		 jne	 SHORT $LN11@Insert

; 1654 : 				_Lmost() = _Newnode;

  00067	89 3a		 mov	 DWORD PTR [edx], edi

; 1655 : 			}
; 1656 : 		else

  00069	eb 0e		 jmp	 SHORT $LN11@Insert
$LN14@Insert:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  0006b	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 1659 : 			if (_Wherenode == _Rmost())

  0006e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00071	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00074	75 03		 jne	 SHORT $LN11@Insert

; 1660 : 				_Rmost() = _Newnode;

  00076	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN11@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00079	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007c	8b c7		 mov	 eax, edi
  0007e	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  00081	0f 85 8f 01 00
	00		 jne	 $LN9@Insert
$LL10@Insert:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0008d	3b 16		 cmp	 edx, DWORD PTR [esi]
  0008f	0f 85 c1 00 00
	00		 jne	 $LN8@Insert

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00095	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00098	38 5e 2c	 cmp	 BYTE PTR [esi+44], bl
  0009b	75 1c		 jne	 SHORT $LN7@Insert

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0009d	c6 42 2c 01	 mov	 BYTE PTR [edx+44], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  000a1	c6 46 2c 01	 mov	 BYTE PTR [esi+44], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  000a5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a8	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000ab	88 5a 2c	 mov	 BYTE PTR [edx+44], bl

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000ae	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1677 : 					}
; 1678 : 				else

  000b4	e9 51 01 00 00	 jmp	 $LN316@Insert
$LN7@Insert:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000b9	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  000bc	75 3a		 jne	 SHORT $LN111@Insert

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  000be	8b c2		 mov	 eax, edx

; 1683 : 						_Lrotate(_Pnode);

  000c0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000c3	8b 32		 mov	 esi, DWORD PTR [edx]
  000c5	89 70 08	 mov	 DWORD PTR [eax+8], esi
  000c8	8b 32		 mov	 esi, DWORD PTR [edx]
  000ca	38 5e 2d	 cmp	 BYTE PTR [esi+45], bl
  000cd	75 03		 jne	 SHORT $LN110@Insert
  000cf	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN110@Insert:
  000d2	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d5	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000d8	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000db	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000de	75 05		 jne	 SHORT $LN109@Insert
  000e0	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000e3	eb 0e		 jmp	 SHORT $LN106@Insert
$LN109@Insert:
  000e5	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000e8	3b 06		 cmp	 eax, DWORD PTR [esi]
  000ea	75 04		 jne	 SHORT $LN107@Insert
  000ec	89 16		 mov	 DWORD PTR [esi], edx
  000ee	eb 03		 jmp	 SHORT $LN106@Insert
$LN107@Insert:
  000f0	89 56 08	 mov	 DWORD PTR [esi+8], edx
$LN106@Insert:
  000f3	89 02		 mov	 DWORD PTR [edx], eax
  000f5	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN111@Insert:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000f8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000fb	c6 42 2c 01	 mov	 BYTE PTR [edx+44], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000ff	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00102	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00105	88 5a 2c	 mov	 BYTE PTR [edx+44], bl

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00108	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0010b	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0010e	8b 32		 mov	 esi, DWORD PTR [edx]
  00110	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00113	89 3a		 mov	 DWORD PTR [edx], edi
  00115	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00118	38 5f 2d	 cmp	 BYTE PTR [edi+45], bl
  0011b	75 03		 jne	 SHORT $LN173@Insert
  0011d	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN173@Insert:
  00120	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00123	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00126	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00129	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  0012c	75 0b		 jne	 SHORT $LN172@Insert
  0012e	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00131	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00134	e9 cb 00 00 00	 jmp	 $LN376@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN172@Insert:
  00139	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0013c	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  0013f	75 0b		 jne	 SHORT $LN170@Insert
  00141	89 77 08	 mov	 DWORD PTR [edi+8], esi
  00144	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00147	e9 b8 00 00 00	 jmp	 $LN376@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN170@Insert:
  0014c	89 37		 mov	 DWORD PTR [edi], esi
  0014e	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00151	e9 ae 00 00 00	 jmp	 $LN376@Insert
$LN8@Insert:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  00156	8b 36		 mov	 esi, DWORD PTR [esi]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  00158	38 5e 2c	 cmp	 BYTE PTR [esi+44], bl
  0015b	75 1c		 jne	 SHORT $LN3@Insert

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0015d	c6 42 2c 01	 mov	 BYTE PTR [edx+44], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  00161	c6 46 2c 01	 mov	 BYTE PTR [esi+44], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  00165	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00168	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0016b	88 5a 2c	 mov	 BYTE PTR [edx+44], bl

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  0016e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00171	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1703 : 					}
; 1704 : 				else

  00174	e9 91 00 00 00	 jmp	 $LN316@Insert
$LN3@Insert:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00179	3b 02		 cmp	 eax, DWORD PTR [edx]
  0017b	75 3c		 jne	 SHORT $LN253@Insert

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  0017d	8b c2		 mov	 eax, edx

; 1709 : 						_Rrotate(_Pnode);

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00184	89 30		 mov	 DWORD PTR [eax], esi
  00186	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00189	38 5e 2d	 cmp	 BYTE PTR [esi+45], bl
  0018c	75 03		 jne	 SHORT $LN252@Insert
  0018e	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN252@Insert:
  00191	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00194	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00197	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0019a	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0019d	75 05		 jne	 SHORT $LN251@Insert
  0019f	89 56 04	 mov	 DWORD PTR [esi+4], edx
  001a2	eb 0f		 jmp	 SHORT $LN248@Insert
$LN251@Insert:
  001a4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001a7	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  001aa	75 05		 jne	 SHORT $LN249@Insert
  001ac	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001af	eb 02		 jmp	 SHORT $LN248@Insert
$LN249@Insert:
  001b1	89 16		 mov	 DWORD PTR [esi], edx
$LN248@Insert:
  001b3	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001b6	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN253@Insert:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  001b9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bc	c6 42 2c 01	 mov	 BYTE PTR [edx+44], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  001c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001c3	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001c6	88 5a 2c	 mov	 BYTE PTR [edx+44], bl

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001c9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001cc	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001cf	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  001d2	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d4	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  001d7	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d9	38 5f 2d	 cmp	 BYTE PTR [edi+45], bl
  001dc	75 03		 jne	 SHORT $LN315@Insert
  001de	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN315@Insert:
  001e1	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001e4	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001e7	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  001ea	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  001ed	75 05		 jne	 SHORT $LN314@Insert
  001ef	89 77 04	 mov	 DWORD PTR [edi+4], esi
  001f2	eb 0e		 jmp	 SHORT $LN311@Insert
$LN314@Insert:
  001f4	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001f7	3b 17		 cmp	 edx, DWORD PTR [edi]
  001f9	75 04		 jne	 SHORT $LN312@Insert
  001fb	89 37		 mov	 DWORD PTR [edi], esi
  001fd	eb 03		 jmp	 SHORT $LN311@Insert
$LN312@Insert:
  001ff	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN311@Insert:
  00202	89 16		 mov	 DWORD PTR [esi], edx
$LN376@Insert:
  00204	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00207	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN316@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  0020a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0020d	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  00210	0f 84 71 fe ff
	ff		 je	 $LL10@Insert
$LN9@Insert:

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00216	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00219	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1720 : 		return (iterator(_Newnode, this));

  0021c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0021f	89 38		 mov	 DWORD PTR [eax], edi
  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	c6 41 2c 01	 mov	 BYTE PTR [ecx+44], 1
  00227	5b		 pop	 ebx

; 1721 : 		}

  00228	5d		 pop	 ebp
  00229	c2 10 00	 ret	 16			; 00000010H
$LN375@Insert:
?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z$0
__ehfuncinfo$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z
_TEXT	SEGMENT
$T174990 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z PROC ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR $T174990[ebp], eax
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c0		 test	 eax, eax
  00032	74 28		 je	 SHORT $LN3@construct
  00034	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00037	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	6a ff		 push	 -1
  0003d	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00040	6a 00		 push	 0
  00042	83 c2 04	 add	 edx, 4
  00045	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0004c	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00053	52		 push	 edx
  00054	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00057	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@construct:

; 209  : 		}

  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00066	59		 pop	 ecx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T174990[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z ENDP ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
PUBLIC	??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Val2$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 0e		 mov	 DWORD PTR [esi], ecx
  00010	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00013	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0001a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00021	52		 push	 edx
  00022	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 164  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	070H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	060H
CONST	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	070H
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$4
	DD	03H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1
	DD	05H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T175297 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$ = 16						; size = 4
_$initVBases$ = 20					; size = 4
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1171 : 		{	// construct with named file and specified mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002d	33 c0		 xor	 eax, eax
  0002f	89 45 f0	 mov	 DWORD PTR $T175297[ebp], eax
  00032	39 45 14	 cmp	 DWORD PTR _$initVBases$[ebp], eax
  00035	74 1e		 je	 SHORT $LN2@basic_fstr
  00037	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0003d	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00044	c7 47 70 00 00
	00 00		 mov	 DWORD PTR [edi+112], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  0004b	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  0004e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T175297[ebp], 1
$LN2@basic_fstr:
  00055	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00057	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005a	c7 04 17 00 00
	00 00		 mov	 DWORD PTR [edi+edx], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00061	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00064	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00067	8b 07		 mov	 eax, DWORD PTR [edi]
  00069	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0006c	03 df		 add	 ebx, edi
  0006e	8b cb		 mov	 ecx, ebx
  00070	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init
  00075	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00078	6a 20		 push	 32			; 00000020H
  0007a	8b cb		 mov	 ecx, ebx
  0007c	89 73 38	 mov	 DWORD PTR [ebx+56], esi
  0007f	c7 43 3c 00 00
	00 00		 mov	 DWORD PTR [ebx+60], 0
  00086	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
  0008b	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  0008f	88 43 40	 mov	 BYTE PTR [ebx+64], al
  00092	75 13		 jne	 SHORT $LN42@basic_fstr
  00094	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00097	83 c8 04	 or	 eax, 4
  0009a	83 c8 04	 or	 eax, 4
  0009d	6a 00		 push	 0
  0009f	50		 push	 eax
  000a0	8b cb		 mov	 ecx, ebx
  000a2	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN42@basic_fstr:
  000a7	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  000aa	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ad	c7 44 17 10 00
	00 00 00	 mov	 DWORD PTR [edi+edx+16], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ba	c7 04 0f 00 00
	00 00		 mov	 DWORD PTR [edi+ecx], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  000c1	8b 17		 mov	 edx, DWORD PTR [edi]
  000c3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c6	8b ce		 mov	 ecx, esi
  000c8	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  000cf	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  000d6	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
  000db	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  000de	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  000e1	33 db		 xor	 ebx, ebx
  000e3	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  000e9	c6 46 50 00	 mov	 BYTE PTR [esi+80], 0
  000ed	c6 46 49 00	 mov	 BYTE PTR [esi+73], 0
  000f1	8d 56 18	 lea	 edx, DWORD PTR [esi+24]
  000f4	89 56 20	 mov	 DWORD PTR [esi+32], edx
  000f7	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  000fa	89 4e 24	 mov	 DWORD PTR [esi+36], ecx
  000fd	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00100	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00103	8d 56 28	 lea	 edx, DWORD PTR [esi+40]
  00106	89 56 30	 mov	 DWORD PTR [esi+48], edx
  00109	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  0010c	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  0010f	89 18		 mov	 DWORD PTR [eax], ebx
  00111	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00114	89 1a		 mov	 DWORD PTR [edx], ebx
  00116	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00119	89 18		 mov	 DWORD PTR [eax], ebx
  0011b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0011e	89 19		 mov	 DWORD PTR [ecx], ebx
  00120	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00123	89 1a		 mov	 DWORD PTR [edx], ebx
  00125	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00128	89 18		 mov	 DWORD PTR [eax], ebx
  0012a	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  0012d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA
  00133	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  00136	89 5e 44	 mov	 DWORD PTR [esi+68], ebx

; 1172 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00139	8b 55 10	 mov	 edx, DWORD PTR __Prot$[ebp]
  0013c	8b 45 0c	 mov	 eax, DWORD PTR __Mode$[ebp]
  0013f	8b 4d 08	 mov	 ecx, DWORD PTR __Filename$[ebp]
  00142	52		 push	 edx
  00143	50		 push	 eax
  00144	51		 push	 ecx
  00145	8b ce		 mov	 ecx, esi
  00147	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0014b	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00150	85 c0		 test	 eax, eax
  00152	75 1d		 jne	 SHORT $LN81@basic_fstr

; 1173 : 			_Myios::setstate(ios_base::failbit);

  00154	8b 17		 mov	 edx, DWORD PTR [edi]
  00156	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00159	8b 44 39 0c	 mov	 eax, DWORD PTR [ecx+edi+12]
  0015d	03 cf		 add	 ecx, edi
  0015f	83 c8 02	 or	 eax, 2
  00162	39 59 38	 cmp	 DWORD PTR [ecx+56], ebx
  00165	75 03		 jne	 SHORT $LN79@basic_fstr
  00167	83 c8 04	 or	 eax, 4
$LN79@basic_fstr:
  0016a	53		 push	 ebx
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN81@basic_fstr:

; 1174 : 		}

  00171	8b c7		 mov	 eax, edi
  00173	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00176	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017d	59		 pop	 ecx
  0017e	5f		 pop	 edi
  0017f	5e		 pop	 esi
  00180	5b		 pop	 ebx
  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T175297[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN6@basic_fstr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T175297[ebp], -2 ; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 70	 add	 ecx, 112		; 00000070H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN6@basic_fstr:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$4:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 10	 add	 ecx, 16			; 00000010H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1:
  00027	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	83 c1 18	 add	 ecx, 24			; 00000018H
  0002d	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2:
  00032	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	83 c1 18	 add	 ecx, 24			; 00000018H
  00038	e9 00 00 00 00	 jmp	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z:
  0003d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00041	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00044	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00047	33 c8		 xor	 ecx, eax
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
  00053	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	SEGMENT
__unwindtable$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ$2
__ehfuncinfo$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
$T175575 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1302 : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00029	8b 41 90	 mov	 eax, DWORD PTR [ecx-112]
  0002c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002f	c7 44 0a 90 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-112], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@

; 1303 : 		}

  00037	8d 71 a8	 lea	 esi, DWORD PTR [ecx-88]
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	89 75 ec	 mov	 DWORD PTR $T175575[ebp], esi
  00044	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0004a	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  0004e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00052	74 1e		 je	 SHORT $LN15@basic_fstr@2
  00054	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00057	8d 56 48	 lea	 edx, DWORD PTR [esi+72]
  0005a	39 11		 cmp	 DWORD PTR [ecx], edx
  0005c	75 14		 jne	 SHORT $LN15@basic_fstr@2
  0005e	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  00061	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00064	89 11		 mov	 DWORD PTR [ecx], edx
  00066	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00069	89 01		 mov	 DWORD PTR [ecx], eax
  0006b	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0006e	2b c0		 sub	 eax, eax
  00070	89 02		 mov	 DWORD PTR [edx], eax
$LN15@basic_fstr@2:
  00072	80 7e 50 00	 cmp	 BYTE PTR [esi+80], 0
  00076	74 07		 je	 SHORT $LN5@basic_fstr@2
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN5@basic_fstr@2:
  0007f	8b ce		 mov	 ecx, esi
  00081	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00085	e8 00 00 00 00	 call	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
  0008a	8b 46 e8	 mov	 eax, DWORD PTR [esi-24]
  0008d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00090	c7 44 31 e8 00
	00 00 00	 mov	 DWORD PTR [ecx+esi-24], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  00098	8b 56 f8	 mov	 edx, DWORD PTR [esi-8]
  0009b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0009e	c7 44 30 f8 00
	00 00 00	 mov	 DWORD PTR [eax+esi-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  000a6	8b 4e e8	 mov	 ecx, DWORD PTR [esi-24]
  000a9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ac	c7 44 32 e8 00
	00 00 00	 mov	 DWORD PTR [edx+esi-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  000b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000be	59		 pop	 ecx
  000bf	5e		 pop	 esi
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 e9 58	 sub	 ecx, 88			; 00000058H
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__unwindfunclet$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ$2:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR $T175575[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
PUBLIC	??0?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Val2$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 0e		 mov	 DWORD PTR [esi], ecx
  00010	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00013	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0001a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00021	52		 push	 edx
  00022	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 228  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv797 = -12						; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	80 7b 2d 00	 cmp	 BYTE PTR [ebx+45], 0
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00013	74 0a		 je	 SHORT $LN40@erase@2

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN297@erase@2:
$LN40@erase@2:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1207 : 		++_Where;	// save successor iterator for return

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00022	89 5d f8	 mov	 DWORD PTR __Erasednode$[ebp], ebx
  00025	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  0002a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002c	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00030	74 05		 je	 SHORT $LN39@erase@2

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00032	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00035	eb 17		 jmp	 SHORT $LN291@erase@2
$LN39@erase@2:
  00037	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0003a	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0003e	74 04		 je	 SHORT $LN37@erase@2

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00040	8b f9		 mov	 edi, ecx

; 1218 : 		else

  00042	eb 0a		 jmp	 SHORT $LN291@erase@2
$LN37@erase@2:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00047	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  0004a	3b c3		 cmp	 eax, ebx
  0004c	75 72		 jne	 SHORT $LN35@erase@2
$LN291@erase@2:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004e	80 7f 2d 00	 cmp	 BYTE PTR [edi+45], 0
  00052	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00055	75 03		 jne	 SHORT $LN34@erase@2

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00057	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase@2:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00060	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00063	75 05		 jne	 SHORT $LN33@erase@2

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00065	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00068	eb 0b		 jmp	 SHORT $LN30@erase@2
$LN33@erase@2:
  0006a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0006c	75 04		 jne	 SHORT $LN31@erase@2

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006e	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  00070	eb 03		 jmp	 SHORT $LN30@erase@2
$LN31@erase@2:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  00072	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase@2:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	39 18		 cmp	 DWORD PTR [eax], ebx
  0007a	75 1b		 jne	 SHORT $LN29@erase@2

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007c	80 7f 2d 00	 cmp	 BYTE PTR [edi+45], 0
  00080	74 04		 je	 SHORT $LN43@erase@2
  00082	8b c6		 mov	 eax, esi
  00084	eb 0c		 jmp	 SHORT $LN44@erase@2
$LN43@erase@2:
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c4 04	 add	 esp, 4
$LN44@erase@2:
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	89 02		 mov	 DWORD PTR [edx], eax
$LN29@erase@2:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  00097	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009a	89 4d f4	 mov	 DWORD PTR tv797[ebp], ecx
  0009d	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000a0	75 78		 jne	 SHORT $LN165@erase@2

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000a2	80 7f 2d 00	 cmp	 BYTE PTR [edi+45], 0
  000a6	74 07		 je	 SHORT $LN45@erase@2
  000a8	8b c6		 mov	 eax, esi
  000aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000ad	eb 6b		 jmp	 SHORT $LN165@erase@2
$LN45@erase@2:

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR tv797[ebp]
  000b8	83 c4 04	 add	 esp, 4
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000be	eb 5a		 jmp	 SHORT $LN165@erase@2
$LN35@erase@2:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c0	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase@2

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f0		 mov	 esi, eax

; 1257 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase@2
$LN26@erase@2:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 2d 00	 cmp	 BYTE PTR [edi+45], 0
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	75 03		 jne	 SHORT $LN24@erase@2

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase@2:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e1	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000e4	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000e7	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN25@erase@2:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f0	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000f3	75 05		 jne	 SHORT $LN23@erase@2

; 1271 : 				_Root() = _Pnode;	// link down from root

  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f8	eb 0e		 jmp	 SHORT $LN20@erase@2
$LN23@erase@2:
  000fa	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000fd	39 19		 cmp	 DWORD PTR [ecx], ebx
  000ff	75 04		 jne	 SHORT $LN21@erase@2

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00101	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  00103	eb 03		 jmp	 SHORT $LN20@erase@2
$LN21@erase@2:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  00105	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase@2:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00108	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0010b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  0010e	8a 53 2c	 mov	 dl, BYTE PTR [ebx+44]
  00111	8a 48 2c	 mov	 cl, BYTE PTR [eax+44]
  00114	88 50 2c	 mov	 BYTE PTR [eax+44], dl
  00117	88 4b 2c	 mov	 BYTE PTR [ebx+44], cl
$LN165@erase@2:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	b3 01		 mov	 bl, 1
  00122	38 58 2c	 cmp	 BYTE PTR [eax+44], bl
  00125	0f 85 fa 00 00
	00		 jne	 $LN19@erase@2
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	3b 7a 04	 cmp	 edi, DWORD PTR [edx+4]
  00131	0f 84 eb 00 00
	00		 je	 $LN16@erase@2
$LL18@erase@2:
  00137	38 5f 2c	 cmp	 BYTE PTR [edi+44], bl
  0013a	0f 85 e2 00 00
	00		 jne	 $LN16@erase@2

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00140	8b 06		 mov	 eax, DWORD PTR [esi]
  00142	3b f8		 cmp	 edi, eax
  00144	75 65		 jne	 SHORT $LN15@erase@2

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  00146	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  00149	80 78 2c 00	 cmp	 BYTE PTR [eax+44], 0
  0014d	75 13		 jne	 SHORT $LN14@erase@2

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0014f	88 58 2c	 mov	 BYTE PTR [eax+44], bl

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  00152	56		 push	 esi
  00153	c6 46 2c 00	 mov	 BYTE PTR [esi+44], 0
  00157	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN14@erase@2:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00162	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00166	75 74		 jne	 SHORT $LN294@erase@2

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00168	8b 10		 mov	 edx, DWORD PTR [eax]
  0016a	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  0016d	75 08		 jne	 SHORT $LN11@erase@2
  0016f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00172	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  00175	74 61		 je	 SHORT $LN295@erase@2
$LN11@erase@2:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  00177	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017a	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  0017d	75 15		 jne	 SHORT $LN9@erase@2

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	88 5a 2c	 mov	 BYTE PTR [edx+44], bl

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  00184	50		 push	 eax
  00185	c6 40 2c 00	 mov	 BYTE PTR [eax+44], 0
  00189	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  0018e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN9@erase@2:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00194	8a 56 2c	 mov	 dl, BYTE PTR [esi+44]
  00197	88 50 2c	 mov	 BYTE PTR [eax+44], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0019a	88 5e 2c	 mov	 BYTE PTR [esi+44], bl

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0019d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1323 : 						_Lrotate(_Fixnodeparent);

  001a0	56		 push	 esi
  001a1	88 58 2c	 mov	 BYTE PTR [eax+44], bl
  001a4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001a9	eb 74		 jmp	 SHORT $LN296@erase@2
$LN15@erase@2:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001ab	80 78 2c 00	 cmp	 BYTE PTR [eax+44], 0
  001af	75 12		 jne	 SHORT $LN7@erase@2

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001b1	88 58 2c	 mov	 BYTE PTR [eax+44], bl

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001b4	56		 push	 esi
  001b5	c6 46 2c 00	 mov	 BYTE PTR [esi+44], 0
  001b9	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001be	8b 06		 mov	 eax, DWORD PTR [esi]
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN7@erase@2:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001c3	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001c7	75 13		 jne	 SHORT $LN294@erase@2

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001cc	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  001cf	75 1e		 jne	 SHORT $LN4@erase@2
  001d1	8b 10		 mov	 edx, DWORD PTR [eax]
  001d3	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  001d6	75 17		 jne	 SHORT $LN4@erase@2
$LN295@erase@2:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001d8	c6 40 2c 00	 mov	 BYTE PTR [eax+44], 0
$LN294@erase@2:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001dc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1344 : 						_Fixnode = _Fixnodeparent;

  001df	8b fe		 mov	 edi, esi
  001e1	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001e4	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001e7	0f 85 4a ff ff
	ff		 jne	 $LL18@erase@2

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001ed	eb 33		 jmp	 SHORT $LN16@erase@2
$LN4@erase@2:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001ef	8b 10		 mov	 edx, DWORD PTR [eax]
  001f1	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  001f4	75 15		 jne	 SHORT $LN2@erase@2

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001f9	88 5a 2c	 mov	 BYTE PTR [edx+44], bl

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  001fc	50		 push	 eax
  001fd	c6 40 2c 00	 mov	 BYTE PTR [eax+44], 0
  00201	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00206	8b 06		 mov	 eax, DWORD PTR [esi]
  00208	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN2@erase@2:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0020b	8a 56 2c	 mov	 dl, BYTE PTR [esi+44]
  0020e	88 50 2c	 mov	 BYTE PTR [eax+44], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00211	88 5e 2c	 mov	 BYTE PTR [esi+44], bl

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00214	8b 00		 mov	 eax, DWORD PTR [eax]

; 1359 : 						_Rrotate(_Fixnodeparent);

  00216	56		 push	 esi
  00217	88 58 2c	 mov	 BYTE PTR [eax+44], bl
  0021a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate
$LN296@erase@2:
  0021f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN16@erase@2:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00222	88 5f 2c	 mov	 BYTE PTR [edi+44], bl
$LN19@erase@2:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00225	8b 55 f8	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00228	83 c2 0c	 add	 edx, 12			; 0000000cH
  0022b	52		 push	 edx
  0022c	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00235	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00241	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00244	83 c4 0c	 add	 esp, 12			; 0000000cH
  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
  00249	5b		 pop	 ebx
  0024a	85 c0		 test	 eax, eax
  0024c	74 04		 je	 SHORT $LN1@erase@2

; 1373 : 			--this->_Mysize;

  0024e	48		 dec	 eax
  0024f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase@2:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  00252	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00255	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00258	89 08		 mov	 DWORD PTR [eax], ecx

; 1376 : 		}

  0025a	8b e5		 mov	 esp, ebp
  0025c	5d		 pop	 ebp
  0025d	c2 08 00	 ret	 8
$LN293@erase@2:
?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase
; Function compile flags: /Ogtp
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 2d 00	 cmp	 BYTE PTR [edi+45], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 2b		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	50		 push	 eax
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  00020	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00023	51		 push	 ecx
  00024	8d 43 0d	 lea	 eax, DWORD PTR [ebx+13]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	80 7e 2d 00	 cmp	 BYTE PTR [esi+45], 0
  0003a	8b fe		 mov	 edi, esi
  0003c	74 d5		 je	 SHORT $LL3@Erase
$LN1@Erase:
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Linsert
; Function compile flags: /Ogtp
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
$T176212 = 16						; size = 4
$T176210 = 16						; size = 4
__Where$152031 = 16					; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx

; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00012	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00016	8b f1		 mov	 esi, ecx
  00018	b1 01		 mov	 cl, 1
  0001a	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 2d		 jne	 SHORT $LN11@Linsert
  0001f	8b 5a 0c	 mov	 ebx, DWORD PTR [edx+12]
$LL12@Linsert:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Leftish$[ebp], 0
  00026	8b f0		 mov	 esi, eax
  00028	74 08		 je	 SHORT $LN10@Linsert

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0002a	39 58 0c	 cmp	 DWORD PTR [eax+12], ebx
  0002d	0f 93 c1	 setae	 cl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00030	eb 06		 jmp	 SHORT $LN145@Linsert
$LN10@Linsert:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00032	3b 58 0c	 cmp	 ebx, DWORD PTR [eax+12]
  00035	0f 92 c1	 setb	 cl
$LN145@Linsert:
  00038	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0003b	84 c9		 test	 cl, cl
  0003d	74 04		 je	 SHORT $LN15@Linsert
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 03		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert:

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00046	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0004a	74 d6		 je	 SHORT $LL12@Linsert
$LN11@Linsert:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  0004c	8b de		 mov	 ebx, esi
  0004e	89 5d 10	 mov	 DWORD PTR __Where$152031[ebp], ebx

; 970  : 			if (!_Addleft)

  00051	84 c9		 test	 cl, cl
  00053	74 35		 je	 SHORT $LN99@Linsert

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00055	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00058	8d 4d 10	 lea	 ecx, DWORD PTR $T176210[ebp]
  0005b	3b 30		 cmp	 esi, DWORD PTR [eax]
  0005d	75 20		 jne	 SHORT $LN4@Linsert
  0005f	52		 push	 edx
  00060	56		 push	 esi
  00061	6a 01		 push	 1
  00063	51		 push	 ecx
  00064	8b cf		 mov	 ecx, edi
  00066	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  0006b	8b 10		 mov	 edx, DWORD PTR [eax]
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	89 10		 mov	 DWORD PTR [eax], edx
  00074	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  00078	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@Linsert:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  0007f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--
  00084	8b 5d 10	 mov	 ebx, DWORD PTR __Where$152031[ebp]
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  0008a	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0008d	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  00090	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00093	73 25		 jae	 SHORT $LN2@Linsert

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  00095	52		 push	 edx
  00096	8b 55 fc	 mov	 edx, DWORD PTR __Addleft$[ebp]
  00099	56		 push	 esi
  0009a	52		 push	 edx
  0009b	8d 45 10	 lea	 eax, DWORD PTR $T176212[ebp]
  0009e	50		 push	 eax
  0009f	8b cf		 mov	 ecx, edi
  000a1	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000b3	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Linsert:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  000ba	50		 push	 eax
  000bb	83 c7 0d	 add	 edi, 13			; 0000000dH
  000be	57		 push	 edi
  000bf	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000c4	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000cd	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	89 18		 mov	 DWORD PTR [eax], ebx
  000d7	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000db	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z
_TEXT	SEGMENT
$T176717 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR $T176717[ebp], eax
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c0		 test	 eax, eax
  00032	74 28		 je	 SHORT $LN7@Cons_val
  00034	8b 55 10	 mov	 edx, DWORD PTR __Src$[ebp]
  00037	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	6a ff		 push	 -1
  0003d	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00040	6a 00		 push	 0
  00042	83 c2 04	 add	 edx, 4
  00045	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0004c	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00053	52		 push	 edx
  00054	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00057	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN7@Cons_val:

; 281  : 	}

  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00066	59		 pop	 ecx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T176717[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
PUBLIC	??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 0e		 mov	 DWORD PTR [esi], ecx
  0000d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00010	83 c0 04	 add	 eax, 4
  00013	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0001a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00021	50		 push	 eax
  00022	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 256  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8d 71 70	 lea	 esi, DWORD PTR [ecx+112]
  00004	8b ce		 mov	 ecx, esi
  00006	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  0000b	56		 push	 esi
  0000c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00012	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00017	83 c4 04	 add	 esp, 4
  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8d 79 90	 lea	 edi, DWORD PTR [ecx-112]
  00008	8d 77 70	 lea	 esi, DWORD PTR [edi+112]
  0000b	8b ce		 mov	 ecx, esi
  0000d	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  00012	56		 push	 esi
  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00019	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0001e	83 c4 04	 add	 esp, 4
  00021	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00025	74 09		 je	 SHORT $LN11@scalar@20
  00027	57		 push	 edi
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	83 c4 04	 add	 esp, 4
$LN11@scalar@20:
  00030	8b c7		 mov	 eax, edi
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	51		 push	 ecx
  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001a	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1419 : 		this->_Mysize = 0;

  00022	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00029	5e		 pop	 esi

; 1420 : 		}

  0002a	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
_TEXT	ENDS
PUBLIC	??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0
__unwindtable$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$2
__ehfuncinfo$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
$T177063 = -32						; size = 12
__Ptr$177057 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T177010 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002d	6a 30		 push	 48			; 00000030H
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	8b f0		 mov	 esi, eax
  00036	33 c0		 xor	 eax, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	89 75 ec	 mov	 DWORD PTR __Ptr$177057[ebp], esi
  0003e	3b f0		 cmp	 esi, eax
  00040	74 57		 je	 SHORT $LN12@Buynode@4
  00042	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00045	89 0e		 mov	 DWORD PTR [esi], ecx
  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0004d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00050	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	66 89 46 2c	 mov	 WORD PTR [esi+44], ax
  00057	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  0005a	52		 push	 edx
  0005b	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005e	50		 push	 eax
  0005f	83 c7 0d	 add	 edi, 13			; 0000000dH
  00062	57		 push	 edi
  00063	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00066	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  0006e	8b c6		 mov	 eax, esi

; 599  : 		}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
__catch$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$177057[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4

; 595  : 		_RERAISE;

  00090	33 c0		 xor	 eax, eax
  00092	50		 push	 eax
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Buynode@4:

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@4:
  00099	8d 55 08	 lea	 edx, DWORD PTR $T177010[ebp]
  0009c	52		 push	 edx
  0009d	8d 4d e0	 lea	 ecx, DWORD PTR $T177063[ebp]
  000a0	89 45 08	 mov	 DWORD PTR $T177010[ebp], eax
  000a3	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ad	8d 45 e0	 lea	 eax, DWORD PTR $T177063[ebp]
  000b0	50		 push	 eax
  000b1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T177063[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Buynode@4:
$LN44@Buynode@4:
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
; Function compile flags: /Ogtp
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
$T177111 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Node$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1089 : 		{	// try to insert node at _Node using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1090 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1091 : 		if (_Where._Getcont() != this)
; 1092 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1093 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1094 : 
; 1095 : 		const value_type& _Val = this->_Myval(_Node);
; 1096 : 
; 1097 : 		const_iterator _Next;
; 1098 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1099 : 
; 1100 : 		if (size() == 0)

  00009	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0

; 1101 : 			return (_Insert(true, this->_Myhead, _Node));	// empty tree

  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	57		 push	 edi
  00011	8b 7d 10	 mov	 edi, DWORD PTR __Node$[ebp]
  00014	75 17		 jne	 SHORT $LN33@Insert@2
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	50		 push	 eax
  0001b	6a 01		 push	 1
  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  00023	8b c7		 mov	 eax, edi
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 1181 : 		}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
$LN33@Insert@2:
  0002d	53		 push	 ebx

; 1102 : 		else if (this->_Multi)
; 1103 : 			{	// insert even if duplicate
; 1104 : 			if (_Where == begin())
; 1105 : 				{	// insert at beginning if before first element
; 1106 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1107 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1108 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1109 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1110 : 				}
; 1111 : 			else if (_Where == end())
; 1112 : 				{	// insert at end if after last element
; 1113 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1114 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1115 : 					return (_Insert(false, _Rmost(), _Node));
; 1116 : 				}
; 1117 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1118 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1119 : 				&& !_DEBUG_LT_PRED(this->comp,
; 1120 : 					this->_Kfn(_Val),
; 1121 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1122 : 				{	// insert before _Where
; 1123 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1124 : 					return (_Insert(false, _Next._Mynode(), _Node));
; 1125 : 				else
; 1126 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1127 : 				}
; 1128 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1129 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1130 : 				&& (++(_Next = _Where) == end()
; 1131 : 					|| !_DEBUG_LT_PRED(this->comp,
; 1132 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1133 : 				{	// insert after _Where
; 1134 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1135 : 					return (_Insert(false, _Where._Mynode(), _Node));
; 1136 : 				else
; 1137 : 					return (_Insert(true, _Next._Mynode(), _Node));
; 1138 : 				}
; 1139 : 			else
; 1140 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1141 : 			}
; 1142 : 		else
; 1143 : 			{	// insert only if unique
; 1144 : 			if (_Where == begin())

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  00031	3b 18		 cmp	 ebx, DWORD PTR [eax]
  00033	75 26		 jne	 SHORT $LN14@Insert@2

; 1145 : 				{	// insert at beginning if before first element
; 1146 : 				if (_DEBUG_LT_PRED(this->comp,

  00035	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00038	3b 4b 0c	 cmp	 ecx, DWORD PTR [ebx+12]
  0003b	0f 83 f4 00 00
	00		 jae	 $LN333@Insert@2

; 1147 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1148 : 					return (_Insert(true, _Where._Mynode(), _Node));

  00041	57		 push	 edi
  00042	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00045	53		 push	 ebx
  00046	6a 01		 push	 1
  00048	57		 push	 edi
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  00050	5b		 pop	 ebx
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 1181 : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
$LN14@Insert@2:

; 1149 : 				}
; 1150 : 			else if (_Where == end())

  0005b	3b d8		 cmp	 ebx, eax
  0005d	75 27		 jne	 SHORT $LN11@Insert@2

; 1151 : 				{	// insert at end if after last element
; 1152 : 				if (_DEBUG_LT_PRED(this->comp,

  0005f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00062	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00065	3b 57 0c	 cmp	 edx, DWORD PTR [edi+12]
  00068	0f 83 c7 00 00
	00		 jae	 $LN333@Insert@2

; 1153 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1154 : 					return (_Insert(false, _Rmost(), _Node));

  0006e	57		 push	 edi
  0006f	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00072	50		 push	 eax
  00073	6a 00		 push	 0
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  0007b	5b		 pop	 ebx
  0007c	8b c7		 mov	 eax, edi
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 1181 : 		}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 0c 00	 ret	 12			; 0000000cH
$LN11@Insert@2:

; 1155 : 				}
; 1156 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1157 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1158 : 				&& _DEBUG_LT_PRED(this->comp,

  00086	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00089	3b 43 0c	 cmp	 eax, DWORD PTR [ebx+12]
  0008c	73 4d		 jae	 SHORT $LN332@Insert@2
  0008e	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  00091	89 5d 10	 mov	 DWORD PTR __Next$[ebp], ebx
  00094	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--
  00099	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  0009c	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0009f	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  000a2	73 37		 jae	 SHORT $LN332@Insert@2

; 1159 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1160 : 					this->_Kfn(_Val)))
; 1161 : 				{	// insert before _Where
; 1162 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  000a4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a7	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0

; 1163 : 					return (_Insert(false, _Next._Mynode(), _Node));

  000ab	57		 push	 edi
  000ac	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  000af	8b ce		 mov	 ecx, esi
  000b1	74 14		 je	 SHORT $LN7@Insert@2
  000b3	50		 push	 eax
  000b4	6a 00		 push	 0
  000b6	57		 push	 edi
  000b7	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  000bc	5b		 pop	 ebx
  000bd	8b c7		 mov	 eax, edi
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi

; 1181 : 		}

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH
$LN7@Insert@2:

; 1164 : 				else
; 1165 : 					return (_Insert(true, _Where._Mynode(), _Node));

  000c7	53		 push	 ebx
  000c8	6a 01		 push	 1
  000ca	57		 push	 edi
  000cb	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  000d0	5b		 pop	 ebx
  000d1	8b c7		 mov	 eax, edi
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi

; 1181 : 		}

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 0c 00	 ret	 12			; 0000000cH
$LN332@Insert@2:

; 1166 : 				}
; 1167 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1168 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1169 : 				&& (++(_Next = _Where) == end()
; 1170 : 					|| _DEBUG_LT_PRED(this->comp,

  000db	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000de	39 43 0c	 cmp	 DWORD PTR [ebx+12], eax
  000e1	73 52		 jae	 SHORT $LN333@Insert@2
  000e3	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  000e6	89 5d 10	 mov	 DWORD PTR __Next$[ebp], ebx
  000e9	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++
  000ee	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  000f1	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000f4	74 08		 je	 SHORT $LN3@Insert@2
  000f6	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000f9	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000fc	73 37		 jae	 SHORT $LN333@Insert@2
$LN3@Insert@2:

; 1171 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1172 : 				{	// insert after _Where
; 1173 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  000fe	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00101	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0

; 1174 : 					return (_Insert(false, _Where._Mynode(), _Node));

  00105	57		 push	 edi
  00106	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00109	8b ce		 mov	 ecx, esi
  0010b	74 14		 je	 SHORT $LN2@Insert@2
  0010d	53		 push	 ebx
  0010e	6a 00		 push	 0
  00110	57		 push	 edi
  00111	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  00116	5b		 pop	 ebx
  00117	8b c7		 mov	 eax, edi
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi

; 1181 : 		}

  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Insert@2:

; 1175 : 				else
; 1176 : 					return (_Insert(true, _Next._Mynode(), _Node));

  00121	50		 push	 eax
  00122	6a 01		 push	 1
  00124	57		 push	 edi
  00125	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  0012a	5b		 pop	 ebx
  0012b	8b c7		 mov	 eax, edi
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi

; 1181 : 		}

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c2 0c 00	 ret	 12			; 0000000cH
$LN333@Insert@2:

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00135	6a 00		 push	 0
  00137	57		 push	 edi
  00138	8d 45 f8	 lea	 eax, DWORD PTR $T177111[ebp]
  0013b	50		 push	 eax
  0013c	8b ce		 mov	 ecx, esi
  0013e	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Linsert
  00143	8b 08		 mov	 ecx, DWORD PTR [eax]
  00145	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00148	5b		 pop	 ebx
  00149	5f		 pop	 edi
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
  0014c	5e		 pop	 esi

; 1181 : 		}

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0
__ehfuncinfo$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
$T177761 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR $T177761[ebp], eax
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c0		 test	 eax, eax
  00032	74 24		 je	 SHORT $LN3@construct@2
  00034	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00037	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0003e	83 c2 04	 add	 edx, 4
  00041	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00048	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0004f	52		 push	 edx
  00050	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00053	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@construct@2:

; 209  : 		}

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T177761[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T177986 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00012	75 38		 jne	 SHORT $LN115@erase@3
  00014	3b d0		 cmp	 edx, eax
  00016	75 34		 jne	 SHORT $LN115@erase@3

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	50		 push	 eax
  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 00		 mov	 DWORD PTR [eax], eax
  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1383 : 			return (begin());

  00034	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00037	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	89 10		 mov	 DWORD PTR [eax], edx
  00045	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 0c 00	 ret	 12			; 0000000cH
$LN115@erase@3:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0004c	3b ca		 cmp	 ecx, edx
  0004e	74 62		 je	 SHORT $LN1@erase@3
$LL2@erase@3:

; 1388 : 				erase(_First++);

  00050	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00054	8b d1		 mov	 edx, ecx
  00056	75 46		 jne	 SHORT $LN77@erase@3
  00058	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0005b	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0005f	75 1e		 jne	 SHORT $LN117@erase@3
  00061	8b c8		 mov	 ecx, eax
  00063	8b 01		 mov	 eax, DWORD PTR [ecx]
  00065	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00069	75 0f		 jne	 SHORT $LN91@erase@3
  0006b	eb 03 8d 49 00	 npad	 5
$LL92@erase@3:
  00070	8b c8		 mov	 ecx, eax
  00072	8b 01		 mov	 eax, DWORD PTR [ecx]
  00074	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00078	74 f6		 je	 SHORT $LL92@erase@3
$LN91@erase@3:
  0007a	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  0007d	eb 1f		 jmp	 SHORT $LN77@erase@3
$LN117@erase@3:
  0007f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00082	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00086	75 13		 jne	 SHORT $LN75@erase@3
$LL76@erase@3:
  00088	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0008b	75 0e		 jne	 SHORT $LN75@erase@3
  0008d	8b c8		 mov	 ecx, eax
  0008f	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  00092	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00095	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00099	74 ed		 je	 SHORT $LL76@erase@3
$LN75@erase@3:
  0009b	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
$LN77@erase@3:
  0009e	52		 push	 edx
  0009f	8d 45 fc	 lea	 eax, DWORD PTR $T177986[ebp]
  000a2	50		 push	 eax
  000a3	8b ce		 mov	 ecx, esi
  000a5	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  000ad	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  000b0	75 9e		 jne	 SHORT $LL2@erase@3
$LN1@erase@3:

; 1389 : 			return (iterator(_First._Ptr, this));

  000b2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b5	89 08		 mov	 DWORD PTR [eax], ecx
  000b7	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1516 : 		{	// copy entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d e8	 mov	 DWORD PTR _this$[ebp], ebx

; 1517 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1518 : 
; 1519 : 		if (!this->_Isnil(_Rootnode))

  00030	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00033	80 7f 2d 00	 cmp	 BYTE PTR [edi+45], 0
  00037	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0003a	89 45 ec	 mov	 DWORD PTR __Newroot$[ebp], eax
  0003d	75 48		 jne	 SHORT $LN8@Copy@2

; 1520 : 			{	// copy a node, then any subtrees
; 1521 : 			_Nodeptr _Pnode = this->_Buynode(this->_Myval(_Rootnode));

  0003f	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00042	51		 push	 ecx
  00043	8b cb		 mov	 ecx, ebx
  00045	e8 00 00 00 00	 call	 ??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>

; 1522 : 			_Pnode->_Parent = _Wherenode;

  0004a	8b 55 0c	 mov	 edx, DWORD PTR __Wherenode$[ebp]

; 1523 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1524 : 			if (this->_Isnil(_Newroot))

  0004d	8b 4d ec	 mov	 ecx, DWORD PTR __Newroot$[ebp]
  00050	8b f0		 mov	 esi, eax
  00052	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00055	8a 47 2c	 mov	 al, BYTE PTR [edi+44]
  00058	88 46 2c	 mov	 BYTE PTR [esi+44], al
  0005b	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0005f	74 03		 je	 SHORT $LN2@Copy@2

; 1525 : 				_Newroot = _Pnode;	// memorize new root

  00061	89 75 ec	 mov	 DWORD PTR __Newroot$[ebp], esi
$LN2@Copy@2:

; 1526 : 
; 1527 : 			_TRY_BEGIN
; 1528 : 			this->_Left(_Pnode) = _Copy(this->_Left(_Rootnode), _Pnode);

  00064	8b 17		 mov	 edx, DWORD PTR [edi]
  00066	56		 push	 esi
  00067	52		 push	 edx
  00068	8b cb		 mov	 ecx, ebx
  0006a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00071	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
  00076	89 06		 mov	 DWORD PTR [esi], eax

; 1529 : 			this->_Right(_Pnode) = _Copy(this->_Right(_Rootnode), _Pnode);

  00078	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0007b	56		 push	 esi
  0007c	50		 push	 eax
  0007d	8b cb		 mov	 ecx, ebx
  0007f	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
  00084	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN8@Copy@2:

; 1533 : 			_CATCH_END
; 1534 : 			}
; 1535 : 
; 1536 : 		return (_Newroot);	// return newly constructed tree

  00087	8b 45 ec	 mov	 eax, DWORD PTR __Newroot$[ebp]

; 1537 : 		}

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00094	59		 pop	 ecx
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$0:

; 1530 : 			_CATCH_ALL
; 1531 : 			_Erase(_Newroot);	// subtree copy failed, bail out

  0009e	8b 4d ec	 mov	 ecx, DWORD PTR __Newroot$[ebp]
  000a1	51		 push	 ecx
  000a2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase

; 1532 : 			_RERAISE;

  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@Copy@2:
$LN28@Copy@2:
  000b3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
$T178633 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR $T178633[ebp], eax
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c0		 test	 eax, eax
  00032	74 24		 je	 SHORT $LN7@Cons_val@2
  00034	8b 55 10	 mov	 edx, DWORD PTR __Src$[ebp]
  00037	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0003e	83 c2 04	 add	 edx, 4
  00041	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00048	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0004f	52		 push	 edx
  00050	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00053	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN7@Cons_val@2:

; 281  : 	}

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T178633[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T178698 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T178698[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase

; 1867 : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
; Function compile flags: /Ogtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1500 : 		{	// copy entire tree from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1501 : 		_Root() = _Copy(_Right._Root(), this->_Myhead);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b f1		 mov	 esi, ecx
  00011	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
  0001b	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1502 : 		this->_Mysize = _Right.size();

  0001e	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 1503 : 		if (!this->_Isnil(_Root()))

  00021	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00024	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00027	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002a	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0002e	75 38		 jne	 SHORT $LN2@Copy@3

; 1504 : 			{	// nonempty tree, look for new smallest and largest
; 1505 : 			_Lmost() = this->_Min(_Root());

  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00036	75 0a		 jne	 SHORT $LN25@Copy@3
$LL26@Copy@3:
  00038	8b c1		 mov	 eax, ecx
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00040	74 f6		 je	 SHORT $LL26@Copy@3
$LN25@Copy@3:
  00042	89 02		 mov	 DWORD PTR [edx], eax

; 1506 : 			_Rmost() = this->_Max(_Root());

  00044	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00047	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0004d	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00051	75 0b		 jne	 SHORT $LN43@Copy@3
$LL44@Copy@3:
  00053	8b c8		 mov	 ecx, eax
  00055	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00058	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0005c	74 f5		 je	 SHORT $LL44@Copy@3
$LN43@Copy@3:
  0005e	5f		 pop	 edi
  0005f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx

; 1512 : 			}
; 1513 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN2@Copy@3:

; 1507 : 			}
; 1508 : 		else
; 1509 : 			{	// empty tree, just tidy head pointers
; 1510 : 			_Lmost() = this->_Myhead;

  00068	89 12		 mov	 DWORD PTR [edx], edx

; 1511 : 			_Rmost() = this->_Myhead;

  0006a	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0006d	5f		 pop	 edi
  0006e	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx

; 1512 : 			}
; 1513 : 		}

  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T179027 = -36						; size = 12
$T178962 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T179140 = 8						; size = 4
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 715  : 		{	// construct tree by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00030	33 ff		 xor	 edi, edi
  00032	6a 30		 push	 48			; 00000030H
  00034	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00037	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b c7		 cmp	 eax, edi
  00041	74 62		 je	 SHORT $LN27@Tree@4
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00046	89 00		 mov	 DWORD PTR [eax], eax
  00048	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004b	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0004e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00051	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00054	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00057	b0 01		 mov	 al, 1
  00059	88 41 2c	 mov	 BYTE PTR [ecx+44], al
  0005c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0005f	88 42 2d	 mov	 BYTE PTR [edx+45], al
  00062	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi

; 716  : 		_TRY_BEGIN

  00065	88 45 fc	 mov	 BYTE PTR __$EHRec$[ebp+12], al

; 717  : 		_Copy(_Right);

  00068	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0006b	50		 push	 eax
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy

; 721  : 		_CATCH_END
; 722  : 		}

  00073	8b c6		 mov	 eax, esi
  00075	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00078	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007f	59		 pop	 ecx
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
__catch$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 718  : 		_CATCH_ALL
; 719  : 		_Tidy();

  00089	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0008f	8b 10		 mov	 edx, DWORD PTR [eax]
  00091	50		 push	 eax
  00092	52		 push	 edx
  00093	8d 55 08	 lea	 edx, DWORD PTR $T179140[ebp]
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase

; 720  : 		_RERAISE;

  0009c	33 ff		 xor	 edi, edi
  0009e	57		 push	 edi
  0009f	57		 push	 edi
  000a0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN78@Tree@4:

; 715  : 		{	// construct tree by copying _Right

$LN27@Tree@4:
  000a5	8d 45 e8	 lea	 eax, DWORD PTR $T178962[ebp]
  000a8	50		 push	 eax
  000a9	8d 4d dc	 lea	 ecx, DWORD PTR $T179027[ebp]
  000ac	89 7d e8	 mov	 DWORD PTR $T178962[ebp], edi
  000af	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000b4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000b9	8d 4d dc	 lea	 ecx, DWORD PTR $T179027[ebp]
  000bc	51		 push	 ecx
  000bd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T179027[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000c4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN79@Tree@4:
$LN77@Tree@4:
  000c9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
$T179246 = -32						; size = 12
__Ptr$179240 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T179191 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002d	6a 30		 push	 48			; 00000030H
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	8b f0		 mov	 esi, eax
  00036	33 c0		 xor	 eax, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	89 75 ec	 mov	 DWORD PTR __Ptr$179240[ebp], esi
  0003e	3b f0		 cmp	 esi, eax
  00040	74 57		 je	 SHORT $LN12@Buynode@5
  00042	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00045	89 0e		 mov	 DWORD PTR [esi], ecx
  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0004d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00050	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	66 89 46 2c	 mov	 WORD PTR [esi+44], ax
  00057	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  0005a	52		 push	 edx
  0005b	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005e	50		 push	 eax
  0005f	83 c7 0d	 add	 edi, 13			; 0000000dH
  00062	57		 push	 edi
  00063	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00066	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  0006e	8b c6		 mov	 eax, esi

; 599  : 		}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
__catch$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$179240[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4

; 595  : 		_RERAISE;

  00090	33 c0		 xor	 eax, eax
  00092	50		 push	 eax
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Buynode@5:

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@5:
  00099	8d 55 08	 lea	 edx, DWORD PTR $T179191[ebp]
  0009c	52		 push	 edx
  0009d	8d 4d e0	 lea	 ecx, DWORD PTR $T179246[ebp]
  000a0	89 45 08	 mov	 DWORD PTR $T179191[ebp], eax
  000a3	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ad	8d 45 e0	 lea	 eax, DWORD PTR $T179246[ebp]
  000b0	50		 push	 eax
  000b1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T179246[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Buynode@5:
$LN44@Buynode@5:
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T179384 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 791  : 		_Tidy();

  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T179384[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase

; 792  : 		}

  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	??4?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T179430 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::operator=, COMDAT
; _this$ = ecx

; 795  : 		{	// replace contents from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 796  : 		if (this != &_Right)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 1a		 je	 SHORT $LN28@operator@11

; 797  : 			{	// worth doing
; 798  : 			erase(begin(), end());

  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 45 08	 lea	 eax, DWORD PTR $T179430[ebp]
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase

; 799  : 			this->comp = _Right.comp;
; 800  : 			_Copy(_Right);

  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
$LN28@operator@11:

; 801  : 			}
; 802  : 		return (*this);

  00028	5f		 pop	 edi
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi

; 803  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??4?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::operator=
_TEXT	ENDS
PUBLIC	??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@ABV01@@Z ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 111  : 		{	// construct map by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >

; 112  : 		}

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
??$insert@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 760  : 		typename _STD tr1::enable_if<!_STD tr1::is_same<const_iterator,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 761  : 			typename _STD tr1::remove_reference<_Valty>::type>::value,
; 762  : 				iterator>::type
; 763  : 		insert(const_iterator _Where,
; 764  : 			_Valty&& _Val)
; 765  : 		{	// try to insert node with value _Val using _Where as a hint
; 766  : 		return (_Insert(_Where,
; 767  : 			this->_Buynode(_STD forward<_Valty>(_Val))));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00016	50		 push	 eax
  00017	51		 push	 ecx
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  00020	8b c7		 mov	 eax, edi
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 768  : 		}

  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??$insert@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T179668 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T179668[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T179850 = -16						; size = 12
$T179750 = -4						; size = 4
??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 30		 push	 48			; 00000030H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN25@map
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 2c	 mov	 BYTE PTR [ecx+44], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 2d	 mov	 BYTE PTR [edx+45], al

; 107  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0

; 106  : 		{	// construct empty map from defaults

$LN25@map:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T179750[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T179850[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T179750[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T179850[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T179850[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@map:
$LN48@map:
  0006c	cc		 int	 3
??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??4?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T179975 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator=, COMDAT
; _this$ = ecx

; 148  : 		{	// assign by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 149  : 		_Mybase::operator=(_Right);

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 1a		 je	 SHORT $LN30@operator@12
  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 45 08	 lea	 eax, DWORD PTR $T179975[ebp]
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
$LN30@operator@12:

; 150  : 		return (*this);

  00028	5f		 pop	 edi
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi

; 151  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??4?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator=
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z$1
__ehfuncinfo$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	ENDS
;	COMDAT ??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z
_TEXT	SEGMENT
$T180007 = -80						; size = 4
$T147850 = -76						; size = 28
$T147996 = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Keyval$ = 8						; size = 4
??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z PROC ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[], COMDAT
; _this$ = ecx

; 165  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0002e	8b f1		 mov	 esi, ecx

; 166  : 		iterator _Where = this->lower_bound(_Keyval);

  00030	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00033	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00036	33 db		 xor	 ebx, ebx
  00038	8b f9		 mov	 edi, ecx
  0003a	38 58 2d	 cmp	 BYTE PTR [eax+45], bl
  0003d	75 15		 jne	 SHORT $LN11@operator@13
  0003f	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LL12@operator@13:
  00041	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00044	73 05		 jae	 SHORT $LN10@operator@13
  00046	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00049	eb 04		 jmp	 SHORT $LN9@operator@13
$LN10@operator@13:
  0004b	8b f8		 mov	 edi, eax
  0004d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@operator@13:
  0004f	38 58 2d	 cmp	 BYTE PTR [eax+45], bl
  00052	74 ed		 je	 SHORT $LL12@operator@13
$LN11@operator@13:

; 167  : 		if (_Where == this->end()
; 168  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00054	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00057	74 0b		 je	 SHORT $LN1@operator@13
  00059	8b 02		 mov	 eax, DWORD PTR [edx]
  0005b	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  0005e	0f 83 83 00 00
	00		 jae	 $LN195@operator@13
$LN1@operator@13:

; 169  : 			_Where = this->insert(_Where,
; 170  : 				_STD pair<key_type, mapped_type>(
; 171  : 					_STD move(_Keyval),
; 172  : 					mapped_type()));

  00064	8b 02		 mov	 eax, DWORD PTR [edx]
  00066	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0006b	89 4d c8	 mov	 DWORD PTR $T147850[ebp+20], ecx
  0006e	89 5d c4	 mov	 DWORD PTR $T147850[ebp+16], ebx
  00071	88 5d b4	 mov	 BYTE PTR $T147850[ebp], bl
  00074	89 4d e8	 mov	 DWORD PTR $T147996[ebp+24], ecx
  00077	8d 4d b4	 lea	 ecx, DWORD PTR $T147850[ebp]
  0007a	51		 push	 ecx
  0007b	8d 4d d4	 lea	 ecx, DWORD PTR $T147996[ebp+4]
  0007e	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00081	89 45 d0	 mov	 DWORD PTR $T147996[ebp], eax
  00084	89 5d e4	 mov	 DWORD PTR $T147996[ebp+20], ebx
  00087	88 5d d4	 mov	 BYTE PTR $T147996[ebp+4], bl
  0008a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0008f	8d 55 d0	 lea	 edx, DWORD PTR $T147996[ebp]
  00092	52		 push	 edx
  00093	8b ce		 mov	 ecx, esi
  00095	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00099	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0009e	50		 push	 eax
  0009f	57		 push	 edi
  000a0	8d 45 b0	 lea	 eax, DWORD PTR $T180007[ebp]
  000a3	50		 push	 eax
  000a4	8b ce		 mov	 ecx, esi
  000a6	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  000ab	8b 75 b0	 mov	 esi, DWORD PTR $T180007[ebp]
  000ae	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  000b3	39 7d e8	 cmp	 DWORD PTR $T147996[ebp+24], edi
  000b6	72 0c		 jb	 SHORT $LN153@operator@13
  000b8	8b 4d d4	 mov	 ecx, DWORD PTR $T147996[ebp+4]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c1	83 c4 04	 add	 esp, 4
$LN153@operator@13:
  000c4	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T147996[ebp+24], 15 ; 0000000fH
  000cb	89 5d e4	 mov	 DWORD PTR $T147996[ebp+20], ebx
  000ce	88 5d d4	 mov	 BYTE PTR $T147996[ebp+4], bl
  000d1	39 7d c8	 cmp	 DWORD PTR $T147850[ebp+20], edi
  000d4	72 0c		 jb	 SHORT $LN194@operator@13
  000d6	8b 55 b4	 mov	 edx, DWORD PTR $T147850[ebp]
  000d9	52		 push	 edx
  000da	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000df	83 c4 04	 add	 esp, 4
$LN194@operator@13:

; 173  : 		return ((*_Where).second);

  000e2	8d 46 10	 lea	 eax, DWORD PTR [esi+16]

; 169  : 			_Where = this->insert(_Where,
; 170  : 				_STD pair<key_type, mapped_type>(
; 171  : 					_STD move(_Keyval),
; 172  : 					mapped_type()));

  000e5	eb 03		 jmp	 SHORT $LN175@operator@13
$LN195@operator@13:

; 173  : 		return ((*_Where).second);

  000e7	8d 47 10	 lea	 eax, DWORD PTR [edi+16]

; 169  : 			_Where = this->insert(_Where,
; 170  : 				_STD pair<key_type, mapped_type>(
; 171  : 					_STD move(_Keyval),
; 172  : 					mapped_type()));

$LN175@operator@13:

; 174  : 		}

  000ea	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ed	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f4	59		 pop	 ecx
  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fb	33 cd		 xor	 ecx, ebp
  000fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z$0:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR $T147850[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z$1:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR $T147996[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
__ehhandler$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z ENDP ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
PUBLIC	??0TokenizerRow@@QAE@ABV0@@Z			; TokenizerRow::TokenizerRow
; Function compile flags: /Ogtp
;	COMDAT ??0TokenizerRow@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0TokenizerRow@@QAE@ABV0@@Z PROC			; TokenizerRow::TokenizerRow, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  00010	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00013	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00016	5f		 pop	 edi
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??0TokenizerRow@@QAE@ABV0@@Z ENDP			; TokenizerRow::TokenizerRow
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	_pRow$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z ; Tokenizer::ParseLine
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z$1
__ehfuncinfo$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\tokenizer.h
xdata$x	ENDS
;	COMDAT ?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z
_TEXT	SEGMENT
_pRow$GSCopy$ = -60					; size = 4
$T180748 = -56						; size = 4
$T180747 = -56						; size = 4
_dump$ = -52						; size = 4
_clearingspace$ = -46					; size = 1
_openstring$ = -45					; size = 1
_data$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_line$ = 8						; size = 28
_pRow$ = 36						; size = 4
?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z PROC ; Tokenizer::ParseLine, COMDAT
; _this$ = ecx

; 101  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 45 24	 mov	 eax, DWORD PTR _pRow$[ebp]

; 169  : 
; 170  : 		return true;

  0002e	89 45 c4	 mov	 DWORD PTR _pRow$GSCopy$[ebp], eax
  00031	33 db		 xor	 ebx, ebx
  00033	53		 push	 ebx
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00039	8d 4d d4	 lea	 ecx, DWORD PTR _data$[ebp]
  0003c	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0003f	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _data$[ebp+20], 15 ; 0000000fH
  00046	89 5d e4	 mov	 DWORD PTR _data$[ebp+16], ebx
  00049	88 5d d4	 mov	 BYTE PTR _data$[ebp], bl
  0004c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00051	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00056	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0005a	39 55 1c	 cmp	 DWORD PTR _line$[ebp+20], edx
  0005d	72 08		 jb	 SHORT $LN55@ParseLine

; 102  : 
; 103  : 		std::string data = "";
; 104  : 
; 105  : 		char* dump = (char*)line.c_str();

  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00062	89 4d cc	 mov	 DWORD PTR _dump$[ebp], ecx
  00065	eb 06		 jmp	 SHORT $LN56@ParseLine
$LN55@ParseLine:
  00067	8d 45 08	 lea	 eax, DWORD PTR _line$[ebp]
  0006a	89 45 cc	 mov	 DWORD PTR _dump$[ebp], eax
$LN56@ParseLine:

; 106  : 		
; 107  : 		bool openstring = false;
; 108  : 		bool clearingspace = true;
; 109  : 		
; 110  : 		int column = 0;

  0006d	33 f6		 xor	 esi, esi

; 111  : 
; 112  : 		for(unsigned int i = 0; i < line.length(); i++)

  0006f	33 ff		 xor	 edi, edi
  00071	88 5d d3	 mov	 BYTE PTR _openstring$[ebp], bl
  00074	c6 45 d2 01	 mov	 BYTE PTR _clearingspace$[ebp], 1
  00078	39 5d 18	 cmp	 DWORD PTR _line$[ebp+16], ebx
  0007b	0f 86 e8 00 00
	00		 jbe	 $LN14@ParseLine
$LL16@ParseLine:

; 113  : 		{
; 114  : 
; 115  : 			if(clearingspace)
; 116  : 			{
; 117  : 				if(dump[i] == ' ' || dump[i] == '\t')

  00081	8b 4d cc	 mov	 ecx, DWORD PTR _dump$[ebp]
  00084	38 5d d2	 cmp	 BYTE PTR _clearingspace$[ebp], bl
  00087	74 16		 je	 SHORT $LN13@ParseLine
  00089	8a 04 0f	 mov	 al, BYTE PTR [edi+ecx]
  0008c	3c 20		 cmp	 al, 32			; 00000020H
  0008e	0f 84 c6 00 00
	00		 je	 $LN15@ParseLine
  00094	3c 09		 cmp	 al, 9
  00096	0f 84 be 00 00
	00		 je	 $LN15@ParseLine

; 118  : 				{
; 119  : 					continue;
; 120  : 				}
; 121  : 				clearingspace = false;

  0009c	88 5d d2	 mov	 BYTE PTR _clearingspace$[ebp], bl
$LN13@ParseLine:

; 122  : 			}
; 123  : 
; 124  : 			if(openstring)
; 125  : 			{
; 126  : 				if(dump[i] == '"')

  0009f	8a 04 0f	 mov	 al, BYTE PTR [edi+ecx]
  000a2	38 5d d3	 cmp	 BYTE PTR _openstring$[ebp], bl
  000a5	74 0c		 je	 SHORT $LN10@ParseLine
  000a7	3c 22		 cmp	 al, 34			; 00000022H
  000a9	75 4c		 jne	 SHORT $LN9@ParseLine

; 127  : 				{
; 128  : 					openstring = false;

  000ab	88 5d d3	 mov	 BYTE PTR _openstring$[ebp], bl

; 129  : 					continue;

  000ae	e9 a7 00 00 00	 jmp	 $LN15@ParseLine
$LN10@ParseLine:

; 130  : 				}
; 131  : 				data += dump[i];
; 132  : 			}
; 133  : 			else
; 134  : 			{
; 135  : 				if(dump[i] == '"')

  000b3	3c 22		 cmp	 al, 34			; 00000022H
  000b5	75 38		 jne	 SHORT $LN7@ParseLine

; 136  : 				{
; 137  : 					if(data != "")

  000b7	8b 45 d4	 mov	 eax, DWORD PTR _data$[ebp]
  000ba	39 55 e8	 cmp	 DWORD PTR _data$[ebp+20], edx
  000bd	73 03		 jae	 SHORT $LN85@ParseLine
  000bf	8d 45 d4	 lea	 eax, DWORD PTR _data$[ebp]
$LN85@ParseLine:
  000c2	53		 push	 ebx
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d1	3b c3		 cmp	 eax, ebx
  000d3	0f 85 40 01 00
	00		 jne	 $LN258@ParseLine
  000d9	33 c0		 xor	 eax, eax
  000db	39 5d e4	 cmp	 DWORD PTR _data$[ebp+16], ebx
  000de	0f 95 c0	 setne	 al
  000e1	3b c3		 cmp	 eax, ebx
  000e3	0f 85 30 01 00
	00		 jne	 $LN258@ParseLine

; 140  : 					}
; 141  : 					openstring = true;

  000e9	c6 45 d3 01	 mov	 BYTE PTR _openstring$[ebp], 1

; 142  : 					continue;

  000ed	eb 6b		 jmp	 SHORT $LN15@ParseLine
$LN7@ParseLine:

; 143  : 				}
; 144  : 				else
; 145  : 				{
; 146  : 					if(dump[i] == '\t' || dump[i] == ' ')

  000ef	3c 09		 cmp	 al, 9
  000f1	74 11		 je	 SHORT $LN3@ParseLine
  000f3	3c 20		 cmp	 al, 32			; 00000020H
  000f5	74 0d		 je	 SHORT $LN3@ParseLine
$LN9@ParseLine:

; 152  : 						}
; 153  : 						continue;
; 154  : 					}   
; 155  : 					data += dump[i];

  000f7	50		 push	 eax
  000f8	6a 01		 push	 1
  000fa	8d 4d d4	 lea	 ecx, DWORD PTR _data$[ebp]
  000fd	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 156  : 				}
; 157  : 			}
; 158  : 
; 159  : 		}

  00102	eb 56		 jmp	 SHORT $LN15@ParseLine
$LN3@ParseLine:

; 147  : 					{
; 148  : 						if(data != "")

  00104	8b 45 d4	 mov	 eax, DWORD PTR _data$[ebp]
  00107	39 55 e8	 cmp	 DWORD PTR _data$[ebp+20], edx
  0010a	73 03		 jae	 SHORT $LN158@ParseLine
  0010c	8d 45 d4	 lea	 eax, DWORD PTR _data$[ebp]
$LN158@ParseLine:
  0010f	53		 push	 ebx
  00110	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0011b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011e	3b c3		 cmp	 eax, ebx
  00120	75 0c		 jne	 SHORT $LN269@ParseLine
  00122	33 c0		 xor	 eax, eax
  00124	39 5d e4	 cmp	 DWORD PTR _data$[ebp+16], ebx
  00127	0f 95 c0	 setne	 al
  0012a	3b c3		 cmp	 eax, ebx
  0012c	74 2c		 je	 SHORT $LN15@ParseLine
$LN269@ParseLine:

; 149  : 						{
; 150  : 							pRow.Columns[column++] = data;

  0012e	8d 4d c8	 lea	 ecx, DWORD PTR $T180747[ebp]
  00131	51		 push	 ecx
  00132	8b 4d c4	 mov	 ecx, DWORD PTR _pRow$GSCopy$[ebp]
  00135	89 75 c8	 mov	 DWORD PTR $T180747[ebp], esi
  00138	46		 inc	 esi
  00139	e8 00 00 00 00	 call	 ??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
  0013e	6a ff		 push	 -1
  00140	53		 push	 ebx
  00141	8d 55 d4	 lea	 edx, DWORD PTR _data$[ebp]
  00144	52		 push	 edx
  00145	8b c8		 mov	 ecx, eax
  00147	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 151  : 							data = "";

  0014c	53		 push	 ebx
  0014d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00152	8d 4d d4	 lea	 ecx, DWORD PTR _data$[ebp]
  00155	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN15@ParseLine:

; 147  : 					{
; 148  : 						if(data != "")

  0015a	47		 inc	 edi
  0015b	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00160	3b 7d 18	 cmp	 edi, DWORD PTR _line$[ebp+16]
  00163	0f 82 18 ff ff
	ff		 jb	 $LL16@ParseLine
$LN14@ParseLine:

; 160  : 
; 161  : 		if(data != "")

  00169	8b 45 d4	 mov	 eax, DWORD PTR _data$[ebp]
  0016c	39 55 e8	 cmp	 DWORD PTR _data$[ebp+20], edx
  0016f	73 03		 jae	 SHORT $LN198@ParseLine
  00171	8d 45 d4	 lea	 eax, DWORD PTR _data$[ebp]
$LN198@ParseLine:
  00174	53		 push	 ebx
  00175	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00180	83 c4 0c	 add	 esp, 12			; 0000000cH
  00183	3b c3		 cmp	 eax, ebx
  00185	75 0c		 jne	 SHORT $LN271@ParseLine
  00187	33 c0		 xor	 eax, eax
  00189	39 5d e4	 cmp	 DWORD PTR _data$[ebp+16], ebx
  0018c	0f 95 c0	 setne	 al
  0018f	3b c3		 cmp	 eax, ebx
  00191	74 1e		 je	 SHORT $LN202@ParseLine
$LN271@ParseLine:

; 162  : 		{
; 163  : 			pRow.Columns[column++] = data;

  00193	8b 4d c4	 mov	 ecx, DWORD PTR _pRow$GSCopy$[ebp]
  00196	8d 55 c8	 lea	 edx, DWORD PTR $T180748[ebp]
  00199	89 75 c8	 mov	 DWORD PTR $T180748[ebp], esi
  0019c	52		 push	 edx
  0019d	46		 inc	 esi
  0019e	e8 00 00 00 00	 call	 ??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
  001a3	6a ff		 push	 -1
  001a5	53		 push	 ebx
  001a6	8d 4d d4	 lea	 ecx, DWORD PTR _data$[ebp]
  001a9	51		 push	 ecx
  001aa	8b c8		 mov	 ecx, eax
  001ac	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN202@ParseLine:

; 164  : 		}
; 165  : 
; 166  : 		data = "";

  001b1	53		 push	 ebx
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001b7	8d 4d d4	 lea	 ecx, DWORD PTR _data$[ebp]
  001ba	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 167  : 
; 168  : 		pRow.ColumnCount = column;

  001bf	8b 55 c4	 mov	 edx, DWORD PTR _pRow$GSCopy$[ebp]
  001c2	89 72 10	 mov	 DWORD PTR [edx+16], esi

; 169  : 
; 170  : 		return true;

  001c5	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  001ca	39 75 e8	 cmp	 DWORD PTR _data$[ebp+20], esi
  001cd	72 0c		 jb	 SHORT $LN222@ParseLine
  001cf	8b 45 d4	 mov	 eax, DWORD PTR _data$[ebp]
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001d8	83 c4 04	 add	 esp, 4
$LN222@ParseLine:
  001db	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _data$[ebp+20], 15 ; 0000000fH
  001e2	89 5d e4	 mov	 DWORD PTR _data$[ebp+16], ebx
  001e5	88 5d d4	 mov	 BYTE PTR _data$[ebp], bl
  001e8	39 75 1c	 cmp	 DWORD PTR _line$[ebp+20], esi
  001eb	72 0c		 jb	 SHORT $LN244@ParseLine
  001ed	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  001f0	51		 push	 ecx
  001f1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001f6	83 c4 04	 add	 esp, 4
$LN244@ParseLine:
  001f9	b0 01		 mov	 al, 1
$LN17@ParseLine:

; 171  : 
; 172  : 	}

  001fb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001fe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00205	59		 pop	 ecx
  00206	5f		 pop	 edi
  00207	5e		 pop	 esi
  00208	5b		 pop	 ebx
  00209	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020c	33 cd		 xor	 ecx, ebp
  0020e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00213	8b e5		 mov	 esp, ebp
  00215	5d		 pop	 ebp
  00216	c2 20 00	 ret	 32			; 00000020H
$LN258@ParseLine:

; 138  : 					{
; 139  : 						return false;

  00219	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  0021e	39 75 e8	 cmp	 DWORD PTR _data$[ebp+20], esi
  00221	72 0c		 jb	 SHORT $LN100@ParseLine
  00223	8b 45 d4	 mov	 eax, DWORD PTR _data$[ebp]
  00226	50		 push	 eax
  00227	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0022c	83 c4 04	 add	 esp, 4
$LN100@ParseLine:
  0022f	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _data$[ebp+20], 15 ; 0000000fH
  00236	89 5d e4	 mov	 DWORD PTR _data$[ebp+16], ebx
  00239	88 5d d4	 mov	 BYTE PTR _data$[ebp], bl
  0023c	39 75 1c	 cmp	 DWORD PTR _line$[ebp+20], esi
  0023f	72 0c		 jb	 SHORT $LN122@ParseLine
  00241	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00244	51		 push	 ecx
  00245	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0024a	83 c4 04	 add	 esp, 4
$LN122@ParseLine:
  0024d	32 c0		 xor	 al, al
  0024f	eb aa		 jmp	 SHORT $LN17@ParseLine
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _line$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z$1:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR _data$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z ENDP ; Tokenizer::ParseLine
PUBLIC	??0TokenizerRow@@QAE@XZ				; TokenizerRow::TokenizerRow
; Function compile flags: /Ogtp
;	COMDAT ??0TokenizerRow@@QAE@XZ
_TEXT	SEGMENT
$T181814 = -16						; size = 12
$T181667 = -4						; size = 4
??0TokenizerRow@@QAE@XZ PROC				; TokenizerRow::TokenizerRow, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 30		 push	 48			; 00000030H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN28@TokenizerR
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 2c	 mov	 BYTE PTR [ecx+44], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 2d	 mov	 BYTE PTR [edx+45], al
  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN28@TokenizerR:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T181667[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T181814[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T181667[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T181814[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T181814[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN53@TokenizerR:
$LN52@TokenizerR:
  0006c	cc		 int	 3
??0TokenizerRow@@QAE@XZ ENDP				; TokenizerRow::TokenizerRow
_TEXT	ENDS
PUBLIC	??1TokenizerRow@@QAE@XZ				; TokenizerRow::~TokenizerRow
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TokenizerRow@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TokenizerRow@@QAE@XZ$2
__ehfuncinfo$??1TokenizerRow@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1TokenizerRow@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1TokenizerRow@@QAE@XZ
_TEXT	SEGMENT
$T182023 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TokenizerRow@@QAE@XZ PROC				; TokenizerRow::~TokenizerRow, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1TokenizerRow@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T182023[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TokenizerRow@@QAE@XZ$2:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1TokenizerRow@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1TokenizerRow@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1TokenizerRow@@QAE@XZ ENDP				; TokenizerRow::~TokenizerRow
PUBLIC	??4TokenizerRow@@QAEAAV0@ABV0@@Z		; TokenizerRow::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4TokenizerRow@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
$T182194 = 8						; size = 4
___that$ = 8						; size = 4
??4TokenizerRow@@QAEAAV0@ABV0@@Z PROC			; TokenizerRow::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 1a		 je	 SHORT $LN5@operator@14
  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 45 08	 lea	 eax, DWORD PTR $T182194[ebp]
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
$LN5@operator@14:
  00028	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0002b	5f		 pop	 edi
  0002c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??4TokenizerRow@@QAEAAV0@ABV0@@Z ENDP			; TokenizerRow::operator=
_TEXT	ENDS
PUBLIC	??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ	; std::_Pair_base<unsigned long,TokenizerRow>::~_Pair_base<unsigned long,TokenizerRow>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ$3
__ehfuncinfo$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ
_TEXT	SEGMENT
$T182455 = -20						; size = 4
$T182476 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ PROC	; std::_Pair_base<unsigned long,TokenizerRow>::~_Pair_base<unsigned long,TokenizerRow>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00029	89 75 f0	 mov	 DWORD PTR $T182476[ebp], esi
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	8d 45 ec	 lea	 eax, DWORD PTR $T182455[ebp]
  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ$3:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T182476[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ ENDP	; std::_Pair_base<unsigned long,TokenizerRow>::~_Pair_base<unsigned long,TokenizerRow>
PUBLIC	??0?$_Pair_base@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z ; std::_Pair_base<unsigned long,TokenizerRow>::_Pair_base<unsigned long,TokenizerRow>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z PROC ; std::_Pair_base<unsigned long,TokenizerRow>::_Pair_base<unsigned long,TokenizerRow>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 146  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$_Pair_base@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z ENDP ; std::_Pair_base<unsigned long,TokenizerRow>::_Pair_base<unsigned long,TokenizerRow>
_TEXT	ENDS
PUBLIC	??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ ; std::_Pair_base<unsigned long const ,TokenizerRow>::~_Pair_base<unsigned long const ,TokenizerRow>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ$3
__ehfuncinfo$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ
_TEXT	SEGMENT
$T182728 = -20						; size = 4
$T182760 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ PROC	; std::_Pair_base<unsigned long const ,TokenizerRow>::~_Pair_base<unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00029	89 75 f0	 mov	 DWORD PTR $T182760[ebp], esi
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	8d 45 ec	 lea	 eax, DWORD PTR $T182728[ebp]
  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ$3:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T182760[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ ENDP	; std::_Pair_base<unsigned long const ,TokenizerRow>::~_Pair_base<unsigned long const ,TokenizerRow>
PUBLIC	??$?0ABKAAVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABKAAVTokenizerRow@@@Z ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow><unsigned long const &,TokenizerRow &>
; Function compile flags: /Ogtp
;	COMDAT ??$?0ABKAAVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABKAAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0ABKAAVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABKAAVTokenizerRow@@@Z PROC ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow><unsigned long const &,TokenizerRow &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 164  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$?0ABKAAVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABKAAVTokenizerRow@@@Z ENDP ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow><unsigned long const &,TokenizerRow &>
_TEXT	ENDS
PUBLIC	??$?0KVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow><unsigned long,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??$?0KVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0KVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z PROC ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow><unsigned long,TokenizerRow>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 164  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$?0KVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z ENDP ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow><unsigned long,TokenizerRow>
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z PROC ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx

; 150  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 151  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z ENDP ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow>
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QBK$$QAVTokenizerRow@@@Z ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QBK$$QAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QBK$$QAVTokenizerRow@@@Z PROC ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 146  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QBK$$QAVTokenizerRow@@@Z ENDP ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow>
_TEXT	ENDS
PUBLIC	??1?$pair@KVTokenizerRow@@@std@@QAE@XZ		; std::pair<unsigned long,TokenizerRow>::~pair<unsigned long,TokenizerRow>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ$4
__ehfuncinfo$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$pair@KVTokenizerRow@@@std@@QAE@XZ
_TEXT	SEGMENT
$T183116 = -20						; size = 4
$T183103 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@KVTokenizerRow@@@std@@QAE@XZ PROC		; std::pair<unsigned long,TokenizerRow>::~pair<unsigned long,TokenizerRow>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00029	89 75 f0	 mov	 DWORD PTR $T183103[ebp], esi
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	8d 45 ec	 lea	 eax, DWORD PTR $T183116[ebp]
  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ$4:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T183103[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$pair@KVTokenizerRow@@@std@@QAE@XZ ENDP		; std::pair<unsigned long,TokenizerRow>::~pair<unsigned long,TokenizerRow>
PUBLIC	??0?$pair@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z ; std::pair<unsigned long,TokenizerRow>::pair<unsigned long,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??0?$pair@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z PROC ; std::pair<unsigned long,TokenizerRow>::pair<unsigned long,TokenizerRow>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 228  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$pair@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z ENDP ; std::pair<unsigned long,TokenizerRow>::pair<unsigned long,TokenizerRow>
_TEXT	ENDS
PUBLIC	??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ	; std::pair<unsigned long const ,TokenizerRow>::~pair<unsigned long const ,TokenizerRow>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ$4
__ehfuncinfo$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ
_TEXT	SEGMENT
$T183454 = -20						; size = 4
$T183450 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ PROC		; std::pair<unsigned long const ,TokenizerRow>::~pair<unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00029	89 75 f0	 mov	 DWORD PTR $T183450[ebp], esi
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	8d 45 ec	 lea	 eax, DWORD PTR $T183454[ebp]
  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ$4:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T183450[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ ENDP		; std::pair<unsigned long const ,TokenizerRow>::~pair<unsigned long const ,TokenizerRow>
PUBLIC	??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@AAU01@@Z ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long const ,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@AAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@AAU01@@Z PROC ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx

; 195  : 		{	// construct from compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	57		 push	 edi
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	89 06		 mov	 DWORD PTR [esi], eax
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0001e	5f		 pop	 edi
  0001f	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 196  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@AAU01@@Z ENDP ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long const ,TokenizerRow>
_TEXT	ENDS
PUBLIC	??$?0KVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU?$pair@KVTokenizerRow@@@1@@Z ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??$?0KVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU?$pair@KVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0KVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU?$pair@KVTokenizerRow@@@1@@Z PROC ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long,TokenizerRow>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	57		 push	 edi
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	89 06		 mov	 DWORD PTR [esi], eax
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0001e	5f		 pop	 edi
  0001f	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 256  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??$?0KVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU?$pair@KVTokenizerRow@@@1@@Z ENDP ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long,TokenizerRow>
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??0?$pair@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z PROC ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx

; 233  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 234  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$pair@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z ENDP ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow>
_TEXT	ENDS
PUBLIC	??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU01@@Z ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long const ,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU01@@Z PROC ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	57		 push	 edi
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	89 06		 mov	 DWORD PTR [esi], eax
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0001e	5f		 pop	 edi
  0001f	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 256  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU01@@Z ENDP ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long const ,TokenizerRow>
_TEXT	ENDS
PUBLIC	??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z	; std::pair<unsigned long const ,TokenizerRow>::`scalar deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z$4
__ehfuncinfo$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
$T183958 = -20						; size = 4
$T183901 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z PROC	; std::pair<unsigned long const ,TokenizerRow>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  0002c	89 75 f0	 mov	 DWORD PTR $T183901[ebp], esi
  0002f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	8d 45 ec	 lea	 eax, DWORD PTR $T183958[ebp]
  00039	50		 push	 eax
  0003a	8b ce		 mov	 ecx, esi
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00048	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00051	83 c4 04	 add	 esp, 4
  00054	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00058	74 09		 je	 SHORT $LN49@scalar@21
  0005a	57		 push	 edi
  0005b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00060	83 c4 04	 add	 esp, 4
$LN49@scalar@21:
  00063	8b c7		 mov	 eax, edi
  00065	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006f	59		 pop	 ecx
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z$4:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T183901[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z ENDP	; std::pair<unsigned long const ,TokenizerRow>::`scalar deleting destructor'
PUBLIC	??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct<std::pair<unsigned long const ,TokenizerRow> &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z$0
__ehfuncinfo$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z
_TEXT	SEGMENT
$T184000 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct<std::pair<unsigned long const ,TokenizerRow> &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00025	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T184000[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN3@construct@3
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN3@construct@3:

; 209  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T184000[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct<std::pair<unsigned long const ,TokenizerRow> &>
PUBLIC	??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct<std::pair<unsigned long,TokenizerRow> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z$0
__ehfuncinfo$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
$T184063 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct<std::pair<unsigned long,TokenizerRow> >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00025	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T184063[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN3@construct@4
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN3@construct@4:

; 209  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T184063[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct<std::pair<unsigned long,TokenizerRow> >
PUBLIC	?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z$0
__ehfuncinfo$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z
_TEXT	SEGMENT
$T184136 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00025	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T184136[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN3@construct@5
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN3@construct@5:

; 203  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T184136[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z
_TEXT	SEGMENT
$T184270 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T184270[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN7@Cons_val@3
  00036	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN7@Cons_val@3:

; 281  : 	}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T184270[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> &>
PUBLIC	??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z ; std::_Destroy<std::pair<unsigned long const ,TokenizerRow> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z$4
__ehfuncinfo$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z
_TEXT	SEGMENT
$T184679 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T184556 = 8						; size = 4
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z PROC ; std::_Destroy<std::pair<unsigned long const ,TokenizerRow> >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 63   : 	_Ptr->~_Ty();

  00024	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00027	83 c6 04	 add	 esi, 4
  0002a	89 75 08	 mov	 DWORD PTR $T184556[ebp], esi
  0002d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	8d 45 f0	 lea	 eax, DWORD PTR $T184679[ebp]
  00037	50		 push	 eax
  00038	8b ce		 mov	 ecx, esi
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00046	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004f	83 c4 04	 add	 esp, 4

; 64   : 	}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z$4:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR $T184556[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z ENDP ; std::_Destroy<std::pair<unsigned long const ,TokenizerRow> >
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long,TokenizerRow> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z
_TEXT	SEGMENT
$T184773 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long,TokenizerRow> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T184773[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN7@Cons_val@4
  00036	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN7@Cons_val@4:

; 281  : 	}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T184773[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long,TokenizerRow> >
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z
_TEXT	SEGMENT
$T184875 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T184875[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN7@Cons_val@5
  00036	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN7@Cons_val@5:

; 281  : 	}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T184875[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> >
PUBLIC	??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> &>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z$0
__unwindtable$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z$2
__ehfuncinfo$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
$T184966 = -32						; size = 12
__Ptr$184970 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T184918 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> &>, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002d	6a 28		 push	 40			; 00000028H
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	8b f0		 mov	 esi, eax
  00036	33 c0		 xor	 eax, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	89 75 ec	 mov	 DWORD PTR __Ptr$184970[ebp], esi
  0003e	3b f0		 cmp	 esi, eax
  00040	74 57		 je	 SHORT $LN12@Buynode@6
  00042	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00045	89 0e		 mov	 DWORD PTR [esi], ecx
  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0004d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00050	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	66 89 46 24	 mov	 WORD PTR [esi+36], ax
  00057	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  0005a	52		 push	 edx
  0005b	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005e	50		 push	 eax
  0005f	83 c7 0d	 add	 edi, 13			; 0000000dH
  00062	57		 push	 edi
  00063	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00066	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> &>
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  0006e	8b c6		 mov	 eax, esi

; 599  : 		}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
__catch$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$184970[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4

; 595  : 		_RERAISE;

  00090	33 c0		 xor	 eax, eax
  00092	50		 push	 eax
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Buynode@6:

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@6:
  00099	8d 55 08	 lea	 edx, DWORD PTR $T184918[ebp]
  0009c	52		 push	 edx
  0009d	8d 4d e0	 lea	 ecx, DWORD PTR $T184966[ebp]
  000a0	89 45 08	 mov	 DWORD PTR $T184918[ebp], eax
  000a3	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ad	8d 45 e0	 lea	 eax, DWORD PTR $T184966[ebp]
  000b0	50		 push	 eax
  000b1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T184966[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Buynode@6:
$LN44@Buynode@6:
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> &>
PUBLIC	?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::destroy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z$4
__ehfuncinfo$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z
_TEXT	SEGMENT
$T185446 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T185273 = 8						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 213  : 		_Destroy(_Ptr);

  00024	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00027	83 c6 04	 add	 esi, 4
  0002a	89 75 08	 mov	 DWORD PTR $T185273[ebp], esi
  0002d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	8d 45 f0	 lea	 eax, DWORD PTR $T185446[ebp]
  00037	50		 push	 eax
  00038	8b ce		 mov	 ecx, esi
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00046	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004f	83 c4 04	 add	 esp, 4

; 214  : 		}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z$4:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR $T185273[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::destroy
PUBLIC	??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long,TokenizerRow> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
$T185525 = -32						; size = 12
__Ptr$185529 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T185479 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long,TokenizerRow> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002d	6a 28		 push	 40			; 00000028H
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	8b f0		 mov	 esi, eax
  00036	33 c0		 xor	 eax, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	89 75 ec	 mov	 DWORD PTR __Ptr$185529[ebp], esi
  0003e	3b f0		 cmp	 esi, eax
  00040	74 57		 je	 SHORT $LN12@Buynode@7
  00042	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00045	89 0e		 mov	 DWORD PTR [esi], ecx
  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0004d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00050	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	66 89 46 24	 mov	 WORD PTR [esi+36], ax
  00057	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  0005a	52		 push	 edx
  0005b	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005e	50		 push	 eax
  0005f	83 c7 0d	 add	 edi, 13			; 0000000dH
  00062	57		 push	 edi
  00063	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00066	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long,TokenizerRow> >
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  0006e	8b c6		 mov	 eax, esi

; 599  : 		}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
__catch$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$185529[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4

; 595  : 		_RERAISE;

  00090	33 c0		 xor	 eax, eax
  00092	50		 push	 eax
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Buynode@7:

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@7:
  00099	8d 55 08	 lea	 edx, DWORD PTR $T185479[ebp]
  0009c	52		 push	 edx
  0009d	8d 4d e0	 lea	 ecx, DWORD PTR $T185525[ebp]
  000a0	89 45 08	 mov	 DWORD PTR $T185479[ebp], eax
  000a3	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ad	8d 45 e0	 lea	 eax, DWORD PTR $T185525[ebp]
  000b0	50		 push	 eax
  000b1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T185525[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Buynode@7:
$LN44@Buynode@7:
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long,TokenizerRow> >
PUBLIC	??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
$T185633 = -32						; size = 12
__Ptr$185637 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T185585 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002d	6a 28		 push	 40			; 00000028H
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	8b f0		 mov	 esi, eax
  00036	33 c0		 xor	 eax, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	89 75 ec	 mov	 DWORD PTR __Ptr$185637[ebp], esi
  0003e	3b f0		 cmp	 esi, eax
  00040	74 57		 je	 SHORT $LN12@Buynode@8
  00042	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00045	89 0e		 mov	 DWORD PTR [esi], ecx
  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0004d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00050	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	66 89 46 24	 mov	 WORD PTR [esi+36], ax
  00057	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  0005a	52		 push	 edx
  0005b	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005e	50		 push	 eax
  0005f	83 c7 0d	 add	 edi, 13			; 0000000dH
  00062	57		 push	 edi
  00063	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00066	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> >
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  0006e	8b c6		 mov	 eax, esi

; 599  : 		}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
__catch$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$185637[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4

; 595  : 		_RERAISE;

  00090	33 c0		 xor	 eax, eax
  00092	50		 push	 eax
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Buynode@8:

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@8:
  00099	8d 55 08	 lea	 edx, DWORD PTR $T185585[ebp]
  0009c	52		 push	 edx
  0009d	8d 4d e0	 lea	 ecx, DWORD PTR $T185633[ebp]
  000a0	89 45 08	 mov	 DWORD PTR $T185585[ebp], eax
  000a3	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ad	8d 45 e0	 lea	 eax, DWORD PTR $T185633[ebp]
  000b0	50		 push	 eax
  000b1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T185633[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Buynode@8:
$LN44@Buynode@8:
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> >
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z$4
__ehfuncinfo$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z
_TEXT	SEGMENT
$T186148 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
$T185941 = 12						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 287  : 	_Alval.destroy(_Pdest);

  00024	8b 75 0c	 mov	 esi, DWORD PTR __Pdest$[ebp]
  00027	83 c6 04	 add	 esi, 4
  0002a	89 75 0c	 mov	 DWORD PTR $T185941[ebp], esi
  0002d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	8d 45 f0	 lea	 eax, DWORD PTR $T186148[ebp]
  00037	50		 push	 eax
  00038	8b ce		 mov	 ecx, esi
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00046	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004f	83 c4 04	 add	 esp, 4

; 288  : 	}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z$4:
  00000	8b 4d 0c	 mov	 ecx, DWORD PTR $T185941[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	3d a9 aa aa 0a	 cmp	 eax, 178956969		; 0aaaaaa9H
  0000e	72 23		 jb	 SHORT $LN17@Insert@3

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  00010	8b 75 14	 mov	 esi, DWORD PTR __Newnode$[ebp]
  00013	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00016	50		 push	 eax
  00017	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0002e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN377@Insert@3:
$LN17@Insert@3:

; 1640 : 			}
; 1641 : 		++this->_Mysize;
; 1642 : 		_Newnode->_Parent = _Wherenode;

  00033	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00036	40		 inc	 eax
  00037	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0003a	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0003d	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00040	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00043	32 db		 xor	 bl, bl
  00045	3b c2		 cmp	 eax, edx
  00047	75 10		 jne	 SHORT $LN16@Insert@3

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00049	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1647 : 			_Lmost() = _Newnode;

  0004c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004f	89 3a		 mov	 DWORD PTR [edx], edi

; 1648 : 			_Rmost() = _Newnode;

  00051	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00054	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00057	eb 20		 jmp	 SHORT $LN11@Insert@3
$LN16@Insert@3:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  00059	38 5d 0c	 cmp	 BYTE PTR __Addleft$[ebp], bl
  0005c	74 0d		 je	 SHORT $LN14@Insert@3

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  0005e	89 38		 mov	 DWORD PTR [eax], edi

; 1653 : 			if (_Wherenode == _Lmost())

  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	3b 02		 cmp	 eax, DWORD PTR [edx]
  00065	75 12		 jne	 SHORT $LN11@Insert@3

; 1654 : 				_Lmost() = _Newnode;

  00067	89 3a		 mov	 DWORD PTR [edx], edi

; 1655 : 			}
; 1656 : 		else

  00069	eb 0e		 jmp	 SHORT $LN11@Insert@3
$LN14@Insert@3:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  0006b	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 1659 : 			if (_Wherenode == _Rmost())

  0006e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00071	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00074	75 03		 jne	 SHORT $LN11@Insert@3

; 1660 : 				_Rmost() = _Newnode;

  00076	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN11@Insert@3:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00079	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007c	8b c7		 mov	 eax, edi
  0007e	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00081	0f 85 8f 01 00
	00		 jne	 $LN9@Insert@3
$LL10@Insert@3:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0008d	3b 16		 cmp	 edx, DWORD PTR [esi]
  0008f	0f 85 c1 00 00
	00		 jne	 $LN8@Insert@3

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00095	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00098	38 5e 24	 cmp	 BYTE PTR [esi+36], bl
  0009b	75 1c		 jne	 SHORT $LN7@Insert@3

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0009d	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  000a1	c6 46 24 01	 mov	 BYTE PTR [esi+36], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  000a5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a8	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000ab	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000ae	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1677 : 					}
; 1678 : 				else

  000b4	e9 51 01 00 00	 jmp	 $LN316@Insert@3
$LN7@Insert@3:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000b9	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  000bc	75 3a		 jne	 SHORT $LN111@Insert@3

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  000be	8b c2		 mov	 eax, edx

; 1683 : 						_Lrotate(_Pnode);

  000c0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000c3	8b 32		 mov	 esi, DWORD PTR [edx]
  000c5	89 70 08	 mov	 DWORD PTR [eax+8], esi
  000c8	8b 32		 mov	 esi, DWORD PTR [edx]
  000ca	38 5e 25	 cmp	 BYTE PTR [esi+37], bl
  000cd	75 03		 jne	 SHORT $LN110@Insert@3
  000cf	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN110@Insert@3:
  000d2	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d5	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000d8	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000db	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000de	75 05		 jne	 SHORT $LN109@Insert@3
  000e0	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000e3	eb 0e		 jmp	 SHORT $LN106@Insert@3
$LN109@Insert@3:
  000e5	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000e8	3b 06		 cmp	 eax, DWORD PTR [esi]
  000ea	75 04		 jne	 SHORT $LN107@Insert@3
  000ec	89 16		 mov	 DWORD PTR [esi], edx
  000ee	eb 03		 jmp	 SHORT $LN106@Insert@3
$LN107@Insert@3:
  000f0	89 56 08	 mov	 DWORD PTR [esi+8], edx
$LN106@Insert@3:
  000f3	89 02		 mov	 DWORD PTR [edx], eax
  000f5	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN111@Insert@3:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000f8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000fb	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000ff	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00102	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00105	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00108	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0010b	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0010e	8b 32		 mov	 esi, DWORD PTR [edx]
  00110	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00113	89 3a		 mov	 DWORD PTR [edx], edi
  00115	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00118	38 5f 25	 cmp	 BYTE PTR [edi+37], bl
  0011b	75 03		 jne	 SHORT $LN173@Insert@3
  0011d	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN173@Insert@3:
  00120	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00123	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00126	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00129	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  0012c	75 0b		 jne	 SHORT $LN172@Insert@3
  0012e	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00131	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00134	e9 cb 00 00 00	 jmp	 $LN376@Insert@3

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN172@Insert@3:
  00139	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0013c	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  0013f	75 0b		 jne	 SHORT $LN170@Insert@3
  00141	89 77 08	 mov	 DWORD PTR [edi+8], esi
  00144	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00147	e9 b8 00 00 00	 jmp	 $LN376@Insert@3

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN170@Insert@3:
  0014c	89 37		 mov	 DWORD PTR [edi], esi
  0014e	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00151	e9 ae 00 00 00	 jmp	 $LN376@Insert@3
$LN8@Insert@3:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  00156	8b 36		 mov	 esi, DWORD PTR [esi]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  00158	38 5e 24	 cmp	 BYTE PTR [esi+36], bl
  0015b	75 1c		 jne	 SHORT $LN3@Insert@3

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0015d	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  00161	c6 46 24 01	 mov	 BYTE PTR [esi+36], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  00165	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00168	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0016b	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  0016e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00171	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1703 : 					}
; 1704 : 				else

  00174	e9 91 00 00 00	 jmp	 $LN316@Insert@3
$LN3@Insert@3:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00179	3b 02		 cmp	 eax, DWORD PTR [edx]
  0017b	75 3c		 jne	 SHORT $LN253@Insert@3

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  0017d	8b c2		 mov	 eax, edx

; 1709 : 						_Rrotate(_Pnode);

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00184	89 30		 mov	 DWORD PTR [eax], esi
  00186	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00189	38 5e 25	 cmp	 BYTE PTR [esi+37], bl
  0018c	75 03		 jne	 SHORT $LN252@Insert@3
  0018e	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN252@Insert@3:
  00191	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00194	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00197	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0019a	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0019d	75 05		 jne	 SHORT $LN251@Insert@3
  0019f	89 56 04	 mov	 DWORD PTR [esi+4], edx
  001a2	eb 0f		 jmp	 SHORT $LN248@Insert@3
$LN251@Insert@3:
  001a4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001a7	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  001aa	75 05		 jne	 SHORT $LN249@Insert@3
  001ac	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001af	eb 02		 jmp	 SHORT $LN248@Insert@3
$LN249@Insert@3:
  001b1	89 16		 mov	 DWORD PTR [esi], edx
$LN248@Insert@3:
  001b3	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001b6	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN253@Insert@3:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  001b9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bc	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  001c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001c3	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001c6	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001c9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001cc	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001cf	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  001d2	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d4	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  001d7	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d9	38 5f 25	 cmp	 BYTE PTR [edi+37], bl
  001dc	75 03		 jne	 SHORT $LN315@Insert@3
  001de	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN315@Insert@3:
  001e1	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001e4	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001e7	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  001ea	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  001ed	75 05		 jne	 SHORT $LN314@Insert@3
  001ef	89 77 04	 mov	 DWORD PTR [edi+4], esi
  001f2	eb 0e		 jmp	 SHORT $LN311@Insert@3
$LN314@Insert@3:
  001f4	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001f7	3b 17		 cmp	 edx, DWORD PTR [edi]
  001f9	75 04		 jne	 SHORT $LN312@Insert@3
  001fb	89 37		 mov	 DWORD PTR [edi], esi
  001fd	eb 03		 jmp	 SHORT $LN311@Insert@3
$LN312@Insert@3:
  001ff	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN311@Insert@3:
  00202	89 16		 mov	 DWORD PTR [esi], edx
$LN376@Insert@3:
  00204	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00207	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN316@Insert@3:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  0020a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0020d	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00210	0f 84 71 fe ff
	ff		 je	 $LL10@Insert@3
$LN9@Insert@3:

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00216	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00219	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1720 : 		return (iterator(_Newnode, this));

  0021c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0021f	89 38		 mov	 DWORD PTR [eax], edi
  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	c6 41 24 01	 mov	 BYTE PTR [ecx+36], 1
  00227	5b		 pop	 ebx

; 1721 : 		}

  00228	5d		 pop	 ebp
  00229	c2 10 00	 ret	 16			; 00000010H
$LN375@Insert@3:
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv797 = -12						; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	80 7b 25 00	 cmp	 BYTE PTR [ebx+37], 0
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00013	74 0a		 je	 SHORT $LN40@erase@4

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN297@erase@4:
$LN40@erase@4:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1207 : 		++_Where;	// save successor iterator for return

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00022	89 5d f8	 mov	 DWORD PTR __Erasednode$[ebp], ebx
  00025	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  0002a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002c	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00030	74 05		 je	 SHORT $LN39@erase@4

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00032	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00035	eb 17		 jmp	 SHORT $LN291@erase@4
$LN39@erase@4:
  00037	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0003a	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0003e	74 04		 je	 SHORT $LN37@erase@4

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00040	8b f9		 mov	 edi, ecx

; 1218 : 		else

  00042	eb 0a		 jmp	 SHORT $LN291@erase@4
$LN37@erase@4:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00047	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  0004a	3b c3		 cmp	 eax, ebx
  0004c	75 72		 jne	 SHORT $LN35@erase@4
$LN291@erase@4:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004e	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  00052	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00055	75 03		 jne	 SHORT $LN34@erase@4

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00057	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase@4:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00060	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00063	75 05		 jne	 SHORT $LN33@erase@4

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00065	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00068	eb 0b		 jmp	 SHORT $LN30@erase@4
$LN33@erase@4:
  0006a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0006c	75 04		 jne	 SHORT $LN31@erase@4

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006e	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  00070	eb 03		 jmp	 SHORT $LN30@erase@4
$LN31@erase@4:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  00072	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase@4:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	39 18		 cmp	 DWORD PTR [eax], ebx
  0007a	75 1b		 jne	 SHORT $LN29@erase@4

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007c	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  00080	74 04		 je	 SHORT $LN43@erase@4
  00082	8b c6		 mov	 eax, esi
  00084	eb 0c		 jmp	 SHORT $LN44@erase@4
$LN43@erase@4:
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Min
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c4 04	 add	 esp, 4
$LN44@erase@4:
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	89 02		 mov	 DWORD PTR [edx], eax
$LN29@erase@4:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  00097	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009a	89 4d f4	 mov	 DWORD PTR tv797[ebp], ecx
  0009d	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000a0	75 78		 jne	 SHORT $LN165@erase@4

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000a2	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  000a6	74 07		 je	 SHORT $LN45@erase@4
  000a8	8b c6		 mov	 eax, esi
  000aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000ad	eb 6b		 jmp	 SHORT $LN165@erase@4
$LN45@erase@4:

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Max
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR tv797[ebp]
  000b8	83 c4 04	 add	 esp, 4
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000be	eb 5a		 jmp	 SHORT $LN165@erase@4
$LN35@erase@4:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c0	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase@4

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f0		 mov	 esi, eax

; 1257 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase@4
$LN26@erase@4:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	75 03		 jne	 SHORT $LN24@erase@4

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase@4:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e1	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000e4	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000e7	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN25@erase@4:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f0	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000f3	75 05		 jne	 SHORT $LN23@erase@4

; 1271 : 				_Root() = _Pnode;	// link down from root

  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f8	eb 0e		 jmp	 SHORT $LN20@erase@4
$LN23@erase@4:
  000fa	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000fd	39 19		 cmp	 DWORD PTR [ecx], ebx
  000ff	75 04		 jne	 SHORT $LN21@erase@4

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00101	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  00103	eb 03		 jmp	 SHORT $LN20@erase@4
$LN21@erase@4:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  00105	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase@4:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00108	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0010b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  0010e	8a 53 24	 mov	 dl, BYTE PTR [ebx+36]
  00111	8a 48 24	 mov	 cl, BYTE PTR [eax+36]
  00114	88 50 24	 mov	 BYTE PTR [eax+36], dl
  00117	88 4b 24	 mov	 BYTE PTR [ebx+36], cl
$LN165@erase@4:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	b3 01		 mov	 bl, 1
  00122	38 58 24	 cmp	 BYTE PTR [eax+36], bl
  00125	0f 85 fa 00 00
	00		 jne	 $LN19@erase@4
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	3b 7a 04	 cmp	 edi, DWORD PTR [edx+4]
  00131	0f 84 eb 00 00
	00		 je	 $LN16@erase@4
$LL18@erase@4:
  00137	38 5f 24	 cmp	 BYTE PTR [edi+36], bl
  0013a	0f 85 e2 00 00
	00		 jne	 $LN16@erase@4

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00140	8b 06		 mov	 eax, DWORD PTR [esi]
  00142	3b f8		 cmp	 edi, eax
  00144	75 65		 jne	 SHORT $LN15@erase@4

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  00146	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  00149	80 78 24 00	 cmp	 BYTE PTR [eax+36], 0
  0014d	75 13		 jne	 SHORT $LN14@erase@4

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0014f	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  00152	56		 push	 esi
  00153	c6 46 24 00	 mov	 BYTE PTR [esi+36], 0
  00157	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN14@erase@4:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00162	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00166	75 74		 jne	 SHORT $LN294@erase@4

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00168	8b 10		 mov	 edx, DWORD PTR [eax]
  0016a	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  0016d	75 08		 jne	 SHORT $LN11@erase@4
  0016f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00172	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00175	74 61		 je	 SHORT $LN295@erase@4
$LN11@erase@4:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  00177	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017a	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  0017d	75 15		 jne	 SHORT $LN9@erase@4

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  00184	50		 push	 eax
  00185	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
  00189	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  0018e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN9@erase@4:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00194	8a 56 24	 mov	 dl, BYTE PTR [esi+36]
  00197	88 50 24	 mov	 BYTE PTR [eax+36], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0019a	88 5e 24	 mov	 BYTE PTR [esi+36], bl

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0019d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1323 : 						_Lrotate(_Fixnodeparent);

  001a0	56		 push	 esi
  001a1	88 58 24	 mov	 BYTE PTR [eax+36], bl
  001a4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001a9	eb 74		 jmp	 SHORT $LN296@erase@4
$LN15@erase@4:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001ab	80 78 24 00	 cmp	 BYTE PTR [eax+36], 0
  001af	75 12		 jne	 SHORT $LN7@erase@4

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001b1	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001b4	56		 push	 esi
  001b5	c6 46 24 00	 mov	 BYTE PTR [esi+36], 0
  001b9	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001be	8b 06		 mov	 eax, DWORD PTR [esi]
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN7@erase@4:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001c3	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001c7	75 13		 jne	 SHORT $LN294@erase@4

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001cc	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001cf	75 1e		 jne	 SHORT $LN4@erase@4
  001d1	8b 10		 mov	 edx, DWORD PTR [eax]
  001d3	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001d6	75 17		 jne	 SHORT $LN4@erase@4
$LN295@erase@4:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001d8	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
$LN294@erase@4:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001dc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1344 : 						_Fixnode = _Fixnodeparent;

  001df	8b fe		 mov	 edi, esi
  001e1	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001e4	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001e7	0f 85 4a ff ff
	ff		 jne	 $LL18@erase@4

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001ed	eb 33		 jmp	 SHORT $LN16@erase@4
$LN4@erase@4:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001ef	8b 10		 mov	 edx, DWORD PTR [eax]
  001f1	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001f4	75 15		 jne	 SHORT $LN2@erase@4

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001f9	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  001fc	50		 push	 eax
  001fd	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
  00201	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00206	8b 06		 mov	 eax, DWORD PTR [esi]
  00208	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN2@erase@4:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0020b	8a 56 24	 mov	 dl, BYTE PTR [esi+36]
  0020e	88 50 24	 mov	 BYTE PTR [eax+36], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00211	88 5e 24	 mov	 BYTE PTR [esi+36], bl

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00214	8b 00		 mov	 eax, DWORD PTR [eax]

; 1359 : 						_Rrotate(_Fixnodeparent);

  00216	56		 push	 esi
  00217	88 58 24	 mov	 BYTE PTR [eax+36], bl
  0021a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rrotate
$LN296@erase@4:
  0021f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN16@erase@4:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00222	88 5f 24	 mov	 BYTE PTR [edi+36], bl
$LN19@erase@4:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00225	8b 55 f8	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00228	83 c2 0c	 add	 edx, 12			; 0000000cH
  0022b	52		 push	 edx
  0022c	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00235	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00241	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00244	83 c4 0c	 add	 esp, 12			; 0000000cH
  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
  00249	5b		 pop	 ebx
  0024a	85 c0		 test	 eax, eax
  0024c	74 04		 je	 SHORT $LN1@erase@4

; 1373 : 			--this->_Mysize;

  0024e	48		 dec	 eax
  0024f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase@4:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  00252	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00255	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00258	89 08		 mov	 DWORD PTR [eax], ecx

; 1376 : 		}

  0025a	8b e5		 mov	 esp, ebp
  0025c	5d		 pop	 ebp
  0025d	c2 08 00	 ret	 8
$LN293@erase@4:
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase
; Function compile flags: /Ogtp
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 2b		 jne	 SHORT $LN1@Erase@2
$LL3@Erase@2:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	50		 push	 eax
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  00020	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00023	51		 push	 ecx
  00024	8d 43 0d	 lea	 eax, DWORD PTR [ebx+13]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  0003a	8b fe		 mov	 edi, esi
  0003c	74 d5		 je	 SHORT $LL3@Erase@2
$LN1@Erase@2:
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Linsert
; Function compile flags: /Ogtp
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
$T187404 = 16						; size = 4
$T187402 = 16						; size = 4
__Where$152128 = 16					; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx

; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00012	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00016	8b f1		 mov	 esi, ecx
  00018	b1 01		 mov	 cl, 1
  0001a	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 2d		 jne	 SHORT $LN11@Linsert@2
  0001f	8b 5a 0c	 mov	 ebx, DWORD PTR [edx+12]
$LL12@Linsert@2:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Leftish$[ebp], 0
  00026	8b f0		 mov	 esi, eax
  00028	74 08		 je	 SHORT $LN10@Linsert@2

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0002a	39 58 0c	 cmp	 DWORD PTR [eax+12], ebx
  0002d	0f 93 c1	 setae	 cl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00030	eb 06		 jmp	 SHORT $LN145@Linsert@2
$LN10@Linsert@2:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00032	3b 58 0c	 cmp	 ebx, DWORD PTR [eax+12]
  00035	0f 92 c1	 setb	 cl
$LN145@Linsert@2:
  00038	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0003b	84 c9		 test	 cl, cl
  0003d	74 04		 je	 SHORT $LN15@Linsert@2
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 03		 jmp	 SHORT $LN16@Linsert@2
$LN15@Linsert@2:
  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert@2:

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00046	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0004a	74 d6		 je	 SHORT $LL12@Linsert@2
$LN11@Linsert@2:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  0004c	8b de		 mov	 ebx, esi
  0004e	89 5d 10	 mov	 DWORD PTR __Where$152128[ebp], ebx

; 970  : 			if (!_Addleft)

  00051	84 c9		 test	 cl, cl
  00053	74 35		 je	 SHORT $LN99@Linsert@2

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00055	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00058	8d 4d 10	 lea	 ecx, DWORD PTR $T187402[ebp]
  0005b	3b 30		 cmp	 esi, DWORD PTR [eax]
  0005d	75 20		 jne	 SHORT $LN4@Linsert@2
  0005f	52		 push	 edx
  00060	56		 push	 esi
  00061	6a 01		 push	 1
  00063	51		 push	 ecx
  00064	8b cf		 mov	 ecx, edi
  00066	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  0006b	8b 10		 mov	 edx, DWORD PTR [eax]
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	89 10		 mov	 DWORD PTR [eax], edx
  00074	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  00078	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@Linsert@2:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  0007f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--
  00084	8b 5d 10	 mov	 ebx, DWORD PTR __Where$152128[ebp]
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert@2:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  0008a	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0008d	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  00090	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00093	73 25		 jae	 SHORT $LN2@Linsert@2

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  00095	52		 push	 edx
  00096	8b 55 fc	 mov	 edx, DWORD PTR __Addleft$[ebp]
  00099	56		 push	 esi
  0009a	52		 push	 edx
  0009b	8d 45 10	 lea	 eax, DWORD PTR $T187404[ebp]
  0009e	50		 push	 eax
  0009f	8b cf		 mov	 ecx, edi
  000a1	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000b3	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Linsert@2:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  000ba	50		 push	 eax
  000bb	83 c7 0d	 add	 edi, 13			; 0000000dH
  000be	57		 push	 edi
  000bf	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000c4	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000cd	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	89 18		 mov	 DWORD PTR [eax], ebx
  000d7	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000db	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	51		 push	 ecx
  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001a	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1419 : 		this->_Mysize = 0;

  00022	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00029	5e		 pop	 esi

; 1420 : 		}

  0002a	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1516 : 		{	// copy entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d e8	 mov	 DWORD PTR _this$[ebp], ebx

; 1517 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1518 : 
; 1519 : 		if (!this->_Isnil(_Rootnode))

  00030	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00033	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  00037	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0003a	89 45 ec	 mov	 DWORD PTR __Newroot$[ebp], eax
  0003d	75 48		 jne	 SHORT $LN8@Copy@4

; 1520 : 			{	// copy a node, then any subtrees
; 1521 : 			_Nodeptr _Pnode = this->_Buynode(this->_Myval(_Rootnode));

  0003f	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00042	51		 push	 ecx
  00043	8b cb		 mov	 ecx, ebx
  00045	e8 00 00 00 00	 call	 ??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> &>

; 1522 : 			_Pnode->_Parent = _Wherenode;

  0004a	8b 55 0c	 mov	 edx, DWORD PTR __Wherenode$[ebp]

; 1523 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1524 : 			if (this->_Isnil(_Newroot))

  0004d	8b 4d ec	 mov	 ecx, DWORD PTR __Newroot$[ebp]
  00050	8b f0		 mov	 esi, eax
  00052	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00055	8a 47 24	 mov	 al, BYTE PTR [edi+36]
  00058	88 46 24	 mov	 BYTE PTR [esi+36], al
  0005b	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0005f	74 03		 je	 SHORT $LN2@Copy@4

; 1525 : 				_Newroot = _Pnode;	// memorize new root

  00061	89 75 ec	 mov	 DWORD PTR __Newroot$[ebp], esi
$LN2@Copy@4:

; 1526 : 
; 1527 : 			_TRY_BEGIN
; 1528 : 			this->_Left(_Pnode) = _Copy(this->_Left(_Rootnode), _Pnode);

  00064	8b 17		 mov	 edx, DWORD PTR [edi]
  00066	56		 push	 esi
  00067	52		 push	 edx
  00068	8b cb		 mov	 ecx, ebx
  0006a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00071	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
  00076	89 06		 mov	 DWORD PTR [esi], eax

; 1529 : 			this->_Right(_Pnode) = _Copy(this->_Right(_Rootnode), _Pnode);

  00078	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0007b	56		 push	 esi
  0007c	50		 push	 eax
  0007d	8b cb		 mov	 ecx, ebx
  0007f	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
  00084	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN8@Copy@4:

; 1533 : 			_CATCH_END
; 1534 : 			}
; 1535 : 
; 1536 : 		return (_Newroot);	// return newly constructed tree

  00087	8b 45 ec	 mov	 eax, DWORD PTR __Newroot$[ebp]

; 1537 : 		}

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00094	59		 pop	 ecx
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z$0:

; 1530 : 			_CATCH_ALL
; 1531 : 			_Erase(_Newroot);	// subtree copy failed, bail out

  0009e	8b 4d ec	 mov	 ecx, DWORD PTR __Newroot$[ebp]
  000a1	51		 push	 ecx
  000a2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase

; 1532 : 			_RERAISE;

  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@Copy@4:
$LN28@Copy@4:
  000b3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
; Function compile flags: /Ogtp
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
$T187798 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Node$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1089 : 		{	// try to insert node at _Node using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1090 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1091 : 		if (_Where._Getcont() != this)
; 1092 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1093 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1094 : 
; 1095 : 		const value_type& _Val = this->_Myval(_Node);
; 1096 : 
; 1097 : 		const_iterator _Next;
; 1098 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1099 : 
; 1100 : 		if (size() == 0)

  00009	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0

; 1101 : 			return (_Insert(true, this->_Myhead, _Node));	// empty tree

  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	57		 push	 edi
  00011	8b 7d 10	 mov	 edi, DWORD PTR __Node$[ebp]
  00014	75 17		 jne	 SHORT $LN33@Insert@4
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	50		 push	 eax
  0001b	6a 01		 push	 1
  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  00023	8b c7		 mov	 eax, edi
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 1181 : 		}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
$LN33@Insert@4:
  0002d	53		 push	 ebx

; 1102 : 		else if (this->_Multi)
; 1103 : 			{	// insert even if duplicate
; 1104 : 			if (_Where == begin())
; 1105 : 				{	// insert at beginning if before first element
; 1106 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1107 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1108 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1109 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1110 : 				}
; 1111 : 			else if (_Where == end())
; 1112 : 				{	// insert at end if after last element
; 1113 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1114 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1115 : 					return (_Insert(false, _Rmost(), _Node));
; 1116 : 				}
; 1117 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1118 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1119 : 				&& !_DEBUG_LT_PRED(this->comp,
; 1120 : 					this->_Kfn(_Val),
; 1121 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1122 : 				{	// insert before _Where
; 1123 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1124 : 					return (_Insert(false, _Next._Mynode(), _Node));
; 1125 : 				else
; 1126 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1127 : 				}
; 1128 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1129 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1130 : 				&& (++(_Next = _Where) == end()
; 1131 : 					|| !_DEBUG_LT_PRED(this->comp,
; 1132 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1133 : 				{	// insert after _Where
; 1134 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1135 : 					return (_Insert(false, _Where._Mynode(), _Node));
; 1136 : 				else
; 1137 : 					return (_Insert(true, _Next._Mynode(), _Node));
; 1138 : 				}
; 1139 : 			else
; 1140 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1141 : 			}
; 1142 : 		else
; 1143 : 			{	// insert only if unique
; 1144 : 			if (_Where == begin())

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  00031	3b 18		 cmp	 ebx, DWORD PTR [eax]
  00033	75 26		 jne	 SHORT $LN14@Insert@4

; 1145 : 				{	// insert at beginning if before first element
; 1146 : 				if (_DEBUG_LT_PRED(this->comp,

  00035	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00038	3b 4b 0c	 cmp	 ecx, DWORD PTR [ebx+12]
  0003b	0f 83 f4 00 00
	00		 jae	 $LN333@Insert@4

; 1147 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1148 : 					return (_Insert(true, _Where._Mynode(), _Node));

  00041	57		 push	 edi
  00042	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00045	53		 push	 ebx
  00046	6a 01		 push	 1
  00048	57		 push	 edi
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  00050	5b		 pop	 ebx
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 1181 : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
$LN14@Insert@4:

; 1149 : 				}
; 1150 : 			else if (_Where == end())

  0005b	3b d8		 cmp	 ebx, eax
  0005d	75 27		 jne	 SHORT $LN11@Insert@4

; 1151 : 				{	// insert at end if after last element
; 1152 : 				if (_DEBUG_LT_PRED(this->comp,

  0005f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00062	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00065	3b 57 0c	 cmp	 edx, DWORD PTR [edi+12]
  00068	0f 83 c7 00 00
	00		 jae	 $LN333@Insert@4

; 1153 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1154 : 					return (_Insert(false, _Rmost(), _Node));

  0006e	57		 push	 edi
  0006f	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00072	50		 push	 eax
  00073	6a 00		 push	 0
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  0007b	5b		 pop	 ebx
  0007c	8b c7		 mov	 eax, edi
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 1181 : 		}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 0c 00	 ret	 12			; 0000000cH
$LN11@Insert@4:

; 1155 : 				}
; 1156 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1157 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1158 : 				&& _DEBUG_LT_PRED(this->comp,

  00086	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00089	3b 43 0c	 cmp	 eax, DWORD PTR [ebx+12]
  0008c	73 4d		 jae	 SHORT $LN332@Insert@4
  0008e	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  00091	89 5d 10	 mov	 DWORD PTR __Next$[ebp], ebx
  00094	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--
  00099	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  0009c	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0009f	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  000a2	73 37		 jae	 SHORT $LN332@Insert@4

; 1159 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1160 : 					this->_Kfn(_Val)))
; 1161 : 				{	// insert before _Where
; 1162 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  000a4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a7	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0

; 1163 : 					return (_Insert(false, _Next._Mynode(), _Node));

  000ab	57		 push	 edi
  000ac	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  000af	8b ce		 mov	 ecx, esi
  000b1	74 14		 je	 SHORT $LN7@Insert@4
  000b3	50		 push	 eax
  000b4	6a 00		 push	 0
  000b6	57		 push	 edi
  000b7	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  000bc	5b		 pop	 ebx
  000bd	8b c7		 mov	 eax, edi
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi

; 1181 : 		}

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH
$LN7@Insert@4:

; 1164 : 				else
; 1165 : 					return (_Insert(true, _Where._Mynode(), _Node));

  000c7	53		 push	 ebx
  000c8	6a 01		 push	 1
  000ca	57		 push	 edi
  000cb	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  000d0	5b		 pop	 ebx
  000d1	8b c7		 mov	 eax, edi
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi

; 1181 : 		}

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 0c 00	 ret	 12			; 0000000cH
$LN332@Insert@4:

; 1166 : 				}
; 1167 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1168 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1169 : 				&& (++(_Next = _Where) == end()
; 1170 : 					|| _DEBUG_LT_PRED(this->comp,

  000db	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000de	39 43 0c	 cmp	 DWORD PTR [ebx+12], eax
  000e1	73 52		 jae	 SHORT $LN333@Insert@4
  000e3	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  000e6	89 5d 10	 mov	 DWORD PTR __Next$[ebp], ebx
  000e9	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++
  000ee	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  000f1	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000f4	74 08		 je	 SHORT $LN3@Insert@4
  000f6	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000f9	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000fc	73 37		 jae	 SHORT $LN333@Insert@4
$LN3@Insert@4:

; 1171 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1172 : 				{	// insert after _Where
; 1173 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  000fe	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00101	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0

; 1174 : 					return (_Insert(false, _Where._Mynode(), _Node));

  00105	57		 push	 edi
  00106	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00109	8b ce		 mov	 ecx, esi
  0010b	74 14		 je	 SHORT $LN2@Insert@4
  0010d	53		 push	 ebx
  0010e	6a 00		 push	 0
  00110	57		 push	 edi
  00111	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  00116	5b		 pop	 ebx
  00117	8b c7		 mov	 eax, edi
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi

; 1181 : 		}

  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Insert@4:

; 1175 : 				else
; 1176 : 					return (_Insert(true, _Next._Mynode(), _Node));

  00121	50		 push	 eax
  00122	6a 01		 push	 1
  00124	57		 push	 edi
  00125	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  0012a	5b		 pop	 ebx
  0012b	8b c7		 mov	 eax, edi
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi

; 1181 : 		}

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c2 0c 00	 ret	 12			; 0000000cH
$LN333@Insert@4:

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00135	6a 00		 push	 0
  00137	57		 push	 edi
  00138	8d 45 f8	 lea	 eax, DWORD PTR $T187798[ebp]
  0013b	50		 push	 eax
  0013c	8b ce		 mov	 ecx, esi
  0013e	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Linsert
  00143	8b 08		 mov	 ecx, DWORD PTR [eax]
  00145	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00148	5b		 pop	 ebx
  00149	5f		 pop	 edi
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
  0014c	5e		 pop	 esi

; 1181 : 		}

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::insert<std::pair<unsigned long const ,TokenizerRow> >
; Function compile flags: /Ogtp
;	COMDAT ??$insert@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
??$insert@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::insert<std::pair<unsigned long const ,TokenizerRow> >, COMDAT
; _this$ = ecx

; 760  : 		typename _STD tr1::enable_if<!_STD tr1::is_same<const_iterator,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 761  : 			typename _STD tr1::remove_reference<_Valty>::type>::value,
; 762  : 				iterator>::type
; 763  : 		insert(const_iterator _Where,
; 764  : 			_Valty&& _Val)
; 765  : 		{	// try to insert node with value _Val using _Where as a hint
; 766  : 		return (_Insert(_Where,
; 767  : 			this->_Buynode(_STD forward<_Valty>(_Val))));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> >
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00016	50		 push	 eax
  00017	51		 push	 ecx
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  00020	8b c7		 mov	 eax, edi
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 768  : 		}

  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??$insert@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::insert<std::pair<unsigned long const ,TokenizerRow> >
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T188455 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00012	75 38		 jne	 SHORT $LN115@erase@5
  00014	3b d0		 cmp	 edx, eax
  00016	75 34		 jne	 SHORT $LN115@erase@5

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	50		 push	 eax
  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 00		 mov	 DWORD PTR [eax], eax
  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1383 : 			return (begin());

  00034	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00037	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	89 10		 mov	 DWORD PTR [eax], edx
  00045	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 0c 00	 ret	 12			; 0000000cH
$LN115@erase@5:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0004c	3b ca		 cmp	 ecx, edx
  0004e	74 62		 je	 SHORT $LN1@erase@5
$LL2@erase@5:

; 1388 : 				erase(_First++);

  00050	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00054	8b d1		 mov	 edx, ecx
  00056	75 46		 jne	 SHORT $LN77@erase@5
  00058	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0005b	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0005f	75 1e		 jne	 SHORT $LN117@erase@5
  00061	8b c8		 mov	 ecx, eax
  00063	8b 01		 mov	 eax, DWORD PTR [ecx]
  00065	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00069	75 0f		 jne	 SHORT $LN91@erase@5
  0006b	eb 03 8d 49 00	 npad	 5
$LL92@erase@5:
  00070	8b c8		 mov	 ecx, eax
  00072	8b 01		 mov	 eax, DWORD PTR [ecx]
  00074	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00078	74 f6		 je	 SHORT $LL92@erase@5
$LN91@erase@5:
  0007a	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  0007d	eb 1f		 jmp	 SHORT $LN77@erase@5
$LN117@erase@5:
  0007f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00082	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00086	75 13		 jne	 SHORT $LN75@erase@5
$LL76@erase@5:
  00088	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0008b	75 0e		 jne	 SHORT $LN75@erase@5
  0008d	8b c8		 mov	 ecx, eax
  0008f	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  00092	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00095	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00099	74 ed		 je	 SHORT $LL76@erase@5
$LN75@erase@5:
  0009b	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
$LN77@erase@5:
  0009e	52		 push	 edx
  0009f	8d 45 fc	 lea	 eax, DWORD PTR $T188455[ebp]
  000a2	50		 push	 eax
  000a3	8b ce		 mov	 ecx, esi
  000a5	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  000ad	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  000b0	75 9e		 jne	 SHORT $LL2@erase@5
$LN1@erase@5:

; 1389 : 			return (iterator(_First._Ptr, this));

  000b2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b5	89 08		 mov	 DWORD PTR [eax], ecx
  000b7	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
; Function compile flags: /Ogtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1500 : 		{	// copy entire tree from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1501 : 		_Root() = _Copy(_Right._Root(), this->_Myhead);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b f1		 mov	 esi, ecx
  00011	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
  0001b	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1502 : 		this->_Mysize = _Right.size();

  0001e	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 1503 : 		if (!this->_Isnil(_Root()))

  00021	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00024	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00027	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002a	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0002e	75 38		 jne	 SHORT $LN2@Copy@5

; 1504 : 			{	// nonempty tree, look for new smallest and largest
; 1505 : 			_Lmost() = this->_Min(_Root());

  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00036	75 0a		 jne	 SHORT $LN25@Copy@5
$LL26@Copy@5:
  00038	8b c1		 mov	 eax, ecx
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00040	74 f6		 je	 SHORT $LL26@Copy@5
$LN25@Copy@5:
  00042	89 02		 mov	 DWORD PTR [edx], eax

; 1506 : 			_Rmost() = this->_Max(_Root());

  00044	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00047	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0004d	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00051	75 0b		 jne	 SHORT $LN43@Copy@5
$LL44@Copy@5:
  00053	8b c8		 mov	 ecx, eax
  00055	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00058	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0005c	74 f5		 je	 SHORT $LL44@Copy@5
$LN43@Copy@5:
  0005e	5f		 pop	 edi
  0005f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx

; 1512 : 			}
; 1513 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN2@Copy@5:

; 1507 : 			}
; 1508 : 		else
; 1509 : 			{	// empty tree, just tidy head pointers
; 1510 : 			_Lmost() = this->_Myhead;

  00068	89 12		 mov	 DWORD PTR [edx], edx

; 1511 : 			_Rmost() = this->_Myhead;

  0006a	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0006d	5f		 pop	 edi
  0006e	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx

; 1512 : 			}
; 1513 : 		}

  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@KVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::insert<std::pair<unsigned long,TokenizerRow> >
; Function compile flags: /Ogtp
;	COMDAT ??$insert@U?$pair@KVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
??$insert@U?$pair@KVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::insert<std::pair<unsigned long,TokenizerRow> >, COMDAT
; _this$ = ecx

; 760  : 		typename _STD tr1::enable_if<!_STD tr1::is_same<const_iterator,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 761  : 			typename _STD tr1::remove_reference<_Valty>::type>::value,
; 762  : 				iterator>::type
; 763  : 		insert(const_iterator _Where,
; 764  : 			_Valty&& _Val)
; 765  : 		{	// try to insert node with value _Val using _Where as a hint
; 766  : 		return (_Insert(_Where,
; 767  : 			this->_Buynode(_STD forward<_Valty>(_Val))));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long,TokenizerRow> >
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00016	50		 push	 eax
  00017	51		 push	 ecx
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  00020	8b c7		 mov	 eax, edi
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 768  : 		}

  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??$insert@U?$pair@KVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::insert<std::pair<unsigned long,TokenizerRow> >
_TEXT	ENDS
PUBLIC	??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$16
__ehfuncinfo$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	ENDS
;	COMDAT ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z
_TEXT	SEGMENT
$T188977 = -72						; size = 24
$T188978 = -48						; size = 20
$T189411 = -28						; size = 12
$T189792 = -16						; size = 4
$T189209 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T190047 = 8						; size = 4
$T189736 = 8						; size = 4
$T188980 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z PROC ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[], COMDAT
; _this$ = ecx

; 210  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx

; 211  : 		iterator _Where = this->lower_bound(_Keyval);

  0002a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0002d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00030	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00034	75 1e		 jne	 SHORT $LN11@operator@15

; 212  : 		if (_Where == this->end()
; 213  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00036	8b 4d 08	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003b	eb 03 8d 49 00	 npad	 5
$LL12@operator@15:

; 211  : 		iterator _Where = this->lower_bound(_Keyval);

  00040	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00043	73 05		 jae	 SHORT $LN10@operator@15
  00045	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00048	eb 04		 jmp	 SHORT $LN9@operator@15
$LN10@operator@15:
  0004a	8b f8		 mov	 edi, eax
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@operator@15:
  0004e	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00052	74 ec		 je	 SHORT $LL12@operator@15
$LN11@operator@15:

; 212  : 		if (_Where == this->end()
; 213  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00054	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00057	74 0e		 je	 SHORT $LN1@operator@15
  00059	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0005c	8b 02		 mov	 eax, DWORD PTR [edx]
  0005e	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  00061	0f 83 c4 00 00
	00		 jae	 $LN216@operator@15
$LN1@operator@15:

; 214  : 			_Where = this->insert(_Where,
; 215  : 				value_type(_Keyval, mapped_type()));

  00067	33 db		 xor	 ebx, ebx
  00069	6a 30		 push	 48			; 00000030H
  0006b	89 5d d8	 mov	 DWORD PTR $T188978[ebp+8], ebx
  0006e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00073	83 c4 04	 add	 esp, 4
  00076	3b c3		 cmp	 eax, ebx
  00078	0f 84 c4 00 00
	00		 je	 $LN90@operator@15
  0007e	89 45 d4	 mov	 DWORD PTR $T188978[ebp+4], eax
  00081	89 00		 mov	 DWORD PTR [eax], eax
  00083	8b 45 d4	 mov	 eax, DWORD PTR $T188978[ebp+4]
  00086	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00089	8b 45 d4	 mov	 eax, DWORD PTR $T188978[ebp+4]
  0008c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0008f	8b 4d d4	 mov	 ecx, DWORD PTR $T188978[ebp+4]
  00092	b3 01		 mov	 bl, 1
  00094	88 59 2c	 mov	 BYTE PTR [ecx+44], bl
  00097	8b 55 d4	 mov	 edx, DWORD PTR $T188978[ebp+4]
  0009a	88 5a 2d	 mov	 BYTE PTR [edx+45], bl
  0009d	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8d 55 d0	 lea	 edx, DWORD PTR $T188978[ebp]
  000a5	89 4d b8	 mov	 DWORD PTR $T188977[ebp], ecx
  000a8	52		 push	 edx
  000a9	8d 4d bc	 lea	 ecx, DWORD PTR $T188977[ebp+4]
  000ac	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000b3	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  000b8	8b 45 e0	 mov	 eax, DWORD PTR $T188978[ebp+16]
  000bb	89 45 cc	 mov	 DWORD PTR $T188977[ebp+20], eax
  000be	8d 4d b8	 lea	 ecx, DWORD PTR $T188977[ebp]
  000c1	51		 push	 ecx
  000c2	8b ce		 mov	 ecx, esi
  000c4	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  000c7	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> >
  000cc	50		 push	 eax
  000cd	57		 push	 edi
  000ce	8d 55 08	 lea	 edx, DWORD PTR $T188980[ebp]
  000d1	52		 push	 edx
  000d2	8b ce		 mov	 ecx, esi
  000d4	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  000d9	8b 7d 08	 mov	 edi, DWORD PTR $T188980[ebp]
  000dc	8d 45 bc	 lea	 eax, DWORD PTR $T188977[ebp+4]
  000df	89 45 08	 mov	 DWORD PTR $T189736[ebp], eax
  000e2	8b 45 c0	 mov	 eax, DWORD PTR $T188977[ebp+8]
  000e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e7	50		 push	 eax
  000e8	51		 push	 ecx
  000e9	8d 4d f0	 lea	 ecx, DWORD PTR $T189792[ebp]
  000ec	51		 push	 ecx
  000ed	8d 4d bc	 lea	 ecx, DWORD PTR $T188977[ebp+4]
  000f0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f4	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  000f9	8b 55 c0	 mov	 edx, DWORD PTR $T188977[ebp+8]
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00102	83 c4 04	 add	 esp, 4
  00105	8b 45 d4	 mov	 eax, DWORD PTR $T188978[ebp+4]
  00108	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010a	50		 push	 eax
  0010b	51		 push	 ecx
  0010c	8d 45 08	 lea	 eax, DWORD PTR $T190047[ebp]
  0010f	50		 push	 eax
  00110	8d 4d d0	 lea	 ecx, DWORD PTR $T188978[ebp]
  00113	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  0011a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  0011f	8b 4d d4	 mov	 ecx, DWORD PTR $T188978[ebp+4]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00128	83 c4 04	 add	 esp, 4
$LN216@operator@15:

; 216  : 		return ((*_Where).second);

  0012b	8d 47 10	 lea	 eax, DWORD PTR [edi+16]

; 217  : 		}

  0012e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00131	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00138	59		 pop	 ecx
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 04 00	 ret	 4

; 214  : 			_Where = this->insert(_Where,
; 215  : 				value_type(_Keyval, mapped_type()));

$LN90@operator@15:
  00142	8d 55 f0	 lea	 edx, DWORD PTR $T189209[ebp]
  00145	52		 push	 edx
  00146	8d 4d e4	 lea	 ecx, DWORD PTR $T189411[ebp]
  00149	89 5d f0	 mov	 DWORD PTR $T189209[ebp], ebx
  0014c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00151	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00156	8d 45 e4	 lea	 eax, DWORD PTR $T189411[ebp]
  00159	50		 push	 eax
  0015a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T189411[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00161	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN229@operator@15:
$LN228@operator@15:
  00166	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR $T188978[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TokenizerRow@@QAE@XZ
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$1:
  00008	8d 4d b8	 lea	 ecx, DWORD PTR $T188977[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$13:
  00010	8b 4d 08	 mov	 ecx, DWORD PTR $T189736[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$16:
  00018	8d 4d d0	 lea	 ecx, DWORD PTR $T188978[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z:
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ENDP ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
PUBLIC	??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$16
__ehfuncinfo$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	ENDS
;	COMDAT ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z
_TEXT	SEGMENT
$T190108 = -72						; size = 24
$T190109 = -48						; size = 20
$T190546 = -28						; size = 12
$T190938 = -16						; size = 4
$T190344 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T191194 = 8						; size = 4
$T190883 = 8						; size = 4
$T190112 = 8						; size = 4
$T190110 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z PROC ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[], COMDAT
; _this$ = ecx

; 165  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx

; 166  : 		iterator _Where = this->lower_bound(_Keyval);

  0002a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0002d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00030	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00034	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00037	75 1b		 jne	 SHORT $LN11@operator@16
  00039	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0003b	eb 03 8d 49 00	 npad	 5
$LL12@operator@16:
  00040	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00043	73 05		 jae	 SHORT $LN10@operator@16
  00045	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00048	eb 04		 jmp	 SHORT $LN9@operator@16
$LN10@operator@16:
  0004a	8b f8		 mov	 edi, eax
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@operator@16:
  0004e	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00052	74 ec		 je	 SHORT $LL12@operator@16
$LN11@operator@16:

; 167  : 		if (_Where == this->end()
; 168  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00054	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00057	74 0b		 je	 SHORT $LN1@operator@16
  00059	8b 02		 mov	 eax, DWORD PTR [edx]
  0005b	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  0005e	0f 83 c7 00 00
	00		 jae	 $LN222@operator@16
$LN1@operator@16:

; 169  : 			_Where = this->insert(_Where,
; 170  : 				_STD pair<key_type, mapped_type>(
; 171  : 					_STD move(_Keyval),
; 172  : 					mapped_type()));

  00064	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00066	33 db		 xor	 ebx, ebx
  00068	6a 30		 push	 48			; 00000030H
  0006a	89 4d 08	 mov	 DWORD PTR $T190110[ebp], ecx
  0006d	89 5d d8	 mov	 DWORD PTR $T190109[ebp+8], ebx
  00070	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00075	83 c4 04	 add	 esp, 4
  00078	3b c3		 cmp	 eax, ebx
  0007a	0f 84 c2 00 00
	00		 je	 $LN92@operator@16
  00080	89 45 d4	 mov	 DWORD PTR $T190109[ebp+4], eax
  00083	89 00		 mov	 DWORD PTR [eax], eax
  00085	8b 45 d4	 mov	 eax, DWORD PTR $T190109[ebp+4]
  00088	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0008b	8b 45 d4	 mov	 eax, DWORD PTR $T190109[ebp+4]
  0008e	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00091	8b 55 d4	 mov	 edx, DWORD PTR $T190109[ebp+4]
  00094	b3 01		 mov	 bl, 1
  00096	88 5a 2c	 mov	 BYTE PTR [edx+44], bl
  00099	8b 45 d4	 mov	 eax, DWORD PTR $T190109[ebp+4]
  0009c	88 58 2d	 mov	 BYTE PTR [eax+45], bl
  0009f	8b 4d 08	 mov	 ecx, DWORD PTR $T190110[ebp]
  000a2	8d 55 d0	 lea	 edx, DWORD PTR $T190109[ebp]
  000a5	89 4d b8	 mov	 DWORD PTR $T190108[ebp], ecx
  000a8	52		 push	 edx
  000a9	8d 4d bc	 lea	 ecx, DWORD PTR $T190108[ebp+4]
  000ac	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000b3	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  000b8	8b 45 e0	 mov	 eax, DWORD PTR $T190109[ebp+16]
  000bb	89 45 cc	 mov	 DWORD PTR $T190108[ebp+20], eax
  000be	8d 4d b8	 lea	 ecx, DWORD PTR $T190108[ebp]
  000c1	51		 push	 ecx
  000c2	8b ce		 mov	 ecx, esi
  000c4	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  000c7	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long,TokenizerRow> >
  000cc	50		 push	 eax
  000cd	57		 push	 edi
  000ce	8d 55 08	 lea	 edx, DWORD PTR $T190112[ebp]
  000d1	52		 push	 edx
  000d2	8b ce		 mov	 ecx, esi
  000d4	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  000d9	8b 7d 08	 mov	 edi, DWORD PTR $T190112[ebp]
  000dc	8d 45 bc	 lea	 eax, DWORD PTR $T190108[ebp+4]
  000df	89 45 08	 mov	 DWORD PTR $T190883[ebp], eax
  000e2	8b 45 c0	 mov	 eax, DWORD PTR $T190108[ebp+8]
  000e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e7	50		 push	 eax
  000e8	51		 push	 ecx
  000e9	8d 4d f0	 lea	 ecx, DWORD PTR $T190938[ebp]
  000ec	51		 push	 ecx
  000ed	8d 4d bc	 lea	 ecx, DWORD PTR $T190108[ebp+4]
  000f0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f4	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  000f9	8b 55 c0	 mov	 edx, DWORD PTR $T190108[ebp+8]
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00102	83 c4 04	 add	 esp, 4
  00105	8b 45 d4	 mov	 eax, DWORD PTR $T190109[ebp+4]
  00108	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010a	50		 push	 eax
  0010b	51		 push	 ecx
  0010c	8d 45 08	 lea	 eax, DWORD PTR $T191194[ebp]
  0010f	50		 push	 eax
  00110	8d 4d d0	 lea	 ecx, DWORD PTR $T190109[ebp]
  00113	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  0011a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  0011f	8b 4d d4	 mov	 ecx, DWORD PTR $T190109[ebp+4]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00128	83 c4 04	 add	 esp, 4
$LN222@operator@16:

; 173  : 		return ((*_Where).second);

  0012b	8d 47 10	 lea	 eax, DWORD PTR [edi+16]

; 174  : 		}

  0012e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00131	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00138	59		 pop	 ecx
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 04 00	 ret	 4

; 169  : 			_Where = this->insert(_Where,
; 170  : 				_STD pair<key_type, mapped_type>(
; 171  : 					_STD move(_Keyval),
; 172  : 					mapped_type()));

$LN92@operator@16:
  00142	8d 55 f0	 lea	 edx, DWORD PTR $T190344[ebp]
  00145	52		 push	 edx
  00146	8d 4d e4	 lea	 ecx, DWORD PTR $T190546[ebp]
  00149	89 5d f0	 mov	 DWORD PTR $T190344[ebp], ebx
  0014c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00151	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00156	8d 45 e4	 lea	 eax, DWORD PTR $T190546[ebp]
  00159	50		 push	 eax
  0015a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T190546[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00161	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN234@operator@16:
$LN233@operator@16:
  00166	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR $T190109[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TokenizerRow@@QAE@XZ
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$1:
  00008	8d 4d b8	 lea	 ecx, DWORD PTR $T190108[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$pair@KVTokenizerRow@@@std@@QAE@XZ
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$13:
  00010	8b 4d 08	 mov	 ecx, DWORD PTR $T190883[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$16:
  00018	8d 4d d0	 lea	 ecx, DWORD PTR $T190109[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z:
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z ENDP ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
PUBLIC	??4?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T191257 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::operator=, COMDAT
; _this$ = ecx

; 795  : 		{	// replace contents from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 796  : 		if (this != &_Right)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 1a		 je	 SHORT $LN28@operator@17

; 797  : 			{	// worth doing
; 798  : 			erase(begin(), end());

  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 45 08	 lea	 eax, DWORD PTR $T191257[ebp]
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase

; 799  : 			this->comp = _Right.comp;
; 800  : 			_Copy(_Right);

  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
$LN28@operator@17:

; 801  : 			}
; 802  : 		return (*this);

  00028	5f		 pop	 edi
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi

; 803  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??4?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::operator=
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T191350 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T191350[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase

; 1867 : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T191530 = -36						; size = 12
$T191483 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T191660 = 8						; size = 4
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >, COMDAT
; _this$ = ecx

; 715  : 		{	// construct tree by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00030	33 ff		 xor	 edi, edi
  00032	6a 28		 push	 40			; 00000028H
  00034	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00037	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b c7		 cmp	 eax, edi
  00041	74 62		 je	 SHORT $LN27@Tree@5
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00046	89 00		 mov	 DWORD PTR [eax], eax
  00048	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004b	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0004e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00051	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00054	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00057	b0 01		 mov	 al, 1
  00059	88 41 24	 mov	 BYTE PTR [ecx+36], al
  0005c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0005f	88 42 25	 mov	 BYTE PTR [edx+37], al
  00062	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi

; 716  : 		_TRY_BEGIN

  00065	88 45 fc	 mov	 BYTE PTR __$EHRec$[ebp+12], al

; 717  : 		_Copy(_Right);

  00068	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0006b	50		 push	 eax
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy

; 721  : 		_CATCH_END
; 722  : 		}

  00073	8b c6		 mov	 eax, esi
  00075	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00078	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007f	59		 pop	 ecx
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
__catch$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 718  : 		_CATCH_ALL
; 719  : 		_Tidy();

  00089	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0008f	8b 10		 mov	 edx, DWORD PTR [eax]
  00091	50		 push	 eax
  00092	52		 push	 edx
  00093	8d 55 08	 lea	 edx, DWORD PTR $T191660[ebp]
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase

; 720  : 		_RERAISE;

  0009c	33 ff		 xor	 edi, edi
  0009e	57		 push	 edi
  0009f	57		 push	 edi
  000a0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN78@Tree@5:

; 715  : 		{	// construct tree by copying _Right

$LN27@Tree@5:
  000a5	8d 45 e8	 lea	 eax, DWORD PTR $T191483[ebp]
  000a8	50		 push	 eax
  000a9	8d 4d dc	 lea	 ecx, DWORD PTR $T191530[ebp]
  000ac	89 7d e8	 mov	 DWORD PTR $T191483[ebp], edi
  000af	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000b4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000b9	8d 4d dc	 lea	 ecx, DWORD PTR $T191530[ebp]
  000bc	51		 push	 ecx
  000bd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T191530[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000c4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN79@Tree@5:
$LN77@Tree@5:
  000c9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z$2:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
PUBLIC	??4?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAV01@ABV01@@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??4?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T191799 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator=, COMDAT
; _this$ = ecx

; 148  : 		{	// assign by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 149  : 		_Mybase::operator=(_Right);

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 1a		 je	 SHORT $LN30@operator@18
  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 45 08	 lea	 eax, DWORD PTR $T191799[ebp]
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
$LN30@operator@18:

; 150  : 		return (*this);

  00028	5f		 pop	 edi
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi

; 151  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??4?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T191925 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 791  : 		_Tidy();

  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T191925[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase

; 792  : 		}

  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
PUBLIC	??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@ABV01@@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@ABV01@@Z PROC ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >, COMDAT
; _this$ = ecx

; 111  : 		{	// construct map by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >

; 112  : 		}

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@ABV01@@Z ENDP ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >
_TEXT	ENDS
PUBLIC	??4TokenizerSection@@QAEAAV0@ABV0@@Z		; TokenizerSection::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4TokenizerSection@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
$T192102 = 8						; size = 4
___that$ = 8						; size = 4
??4TokenizerSection@@QAEAAV0@ABV0@@Z PROC		; TokenizerSection::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 1a		 je	 SHORT $LN5@operator@19
  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 45 08	 lea	 eax, DWORD PTR $T192102[ebp]
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
$LN5@operator@19:
  00028	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0002b	5f		 pop	 edi
  0002c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??4TokenizerSection@@QAEAAV0@ABV0@@Z ENDP		; TokenizerSection::operator=
_TEXT	ENDS
PUBLIC	??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::~map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T192272 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::~map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T192272[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::~map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >
PUBLIC	??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T192461 = -16						; size = 12
$T192353 = -4						; size = 4
??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN25@map@2
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 107  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0

; 106  : 		{	// construct empty map from defaults

$LN25@map@2:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T192353[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T192461[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T192353[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T192461[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T192461[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@map@2:
$LN48@map@2:
  0006c	cc		 int	 3
??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >
_TEXT	ENDS
PUBLIC	??0TokenizerSection@@QAE@ABV0@@Z		; TokenizerSection::TokenizerSection
; Function compile flags: /Ogtp
;	COMDAT ??0TokenizerSection@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0TokenizerSection@@QAE@ABV0@@Z PROC			; TokenizerSection::TokenizerSection, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  00010	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00013	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00016	5f		 pop	 edi
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??0TokenizerSection@@QAE@ABV0@@Z ENDP			; TokenizerSection::TokenizerSection
_TEXT	ENDS
PUBLIC	?GetSection@TokenizerGroup@@QAE_NKAAVTokenizerSection@@@Z ; TokenizerGroup::GetSection
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\tokenizer.h
;	COMDAT ?GetSection@TokenizerGroup@@QAE_NKAAVTokenizerSection@@@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
$T192717 = 8						; size = 4
_Index$ = 8						; size = 4
_section$ = 12						; size = 4
?GetSection@TokenizerGroup@@QAE_NKAAVTokenizerSection@@@Z PROC ; TokenizerGroup::GetSection, COMDAT
; _this$ = ecx

; 76   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 77   : 		std::map<DWORD, TokenizerSection>::iterator it = this->Sections.find(Index);

  00007	8d 45 08	 lea	 eax, DWORD PTR _Index$[ebp]
  0000a	50		 push	 eax
  0000b	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  0000e	51		 push	 ecx
  0000f	8b ce		 mov	 ecx, esi
  00011	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::find

; 78   : 		if(it == this->Sections.end())

  00016	8b 45 fc	 mov	 eax, DWORD PTR _it$[ebp]
  00019	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0001c	75 09		 jne	 SHORT $LN2@GetSection

; 79   : 		{
; 80   : 			return false;

  0001e	32 c0		 xor	 al, al
  00020	5e		 pop	 esi

; 86   : 		}
; 87   : 	}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN2@GetSection:

; 81   : 		}
; 82   : 		else
; 83   : 		{
; 84   : 			section = it->second;

  00027	8b 75 0c	 mov	 esi, DWORD PTR _section$[ebp]
  0002a	57		 push	 edi
  0002b	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0002e	3b f7		 cmp	 esi, edi
  00030	74 1a		 je	 SHORT $LN29@GetSection
  00032	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	50		 push	 eax
  00038	51		 push	 ecx
  00039	8d 55 08	 lea	 edx, DWORD PTR $T192717[ebp]
  0003c	52		 push	 edx
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00044	57		 push	 edi
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
$LN29@GetSection:
  0004c	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0004f	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00052	5f		 pop	 edi

; 85   : 			return true;

  00053	b0 01		 mov	 al, 1
  00055	5e		 pop	 esi

; 86   : 		}
; 87   : 	}

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
?GetSection@TokenizerGroup@@QAE_NKAAVTokenizerSection@@@Z ENDP ; TokenizerGroup::GetSection
_TEXT	ENDS
PUBLIC	??0TokenizerSection@@QAE@XZ			; TokenizerSection::TokenizerSection
; Function compile flags: /Ogtp
;	COMDAT ??0TokenizerSection@@QAE@XZ
_TEXT	SEGMENT
$T192942 = -16						; size = 12
$T192795 = -4						; size = 4
??0TokenizerSection@@QAE@XZ PROC			; TokenizerSection::TokenizerSection, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN28@TokenizerS
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al
  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN28@TokenizerS:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T192795[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T192942[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T192795[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T192942[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T192942[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN53@TokenizerS:
$LN52@TokenizerS:
  0006c	cc		 int	 3
??0TokenizerSection@@QAE@XZ ENDP			; TokenizerSection::TokenizerSection
_TEXT	ENDS
PUBLIC	??1TokenizerSection@@QAE@XZ			; TokenizerSection::~TokenizerSection
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TokenizerSection@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TokenizerSection@@QAE@XZ$2
__ehfuncinfo$??1TokenizerSection@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1TokenizerSection@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1TokenizerSection@@QAE@XZ
_TEXT	SEGMENT
$T193151 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TokenizerSection@@QAE@XZ PROC			; TokenizerSection::~TokenizerSection, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1TokenizerSection@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T193151[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TokenizerSection@@QAE@XZ$2:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??1TokenizerSection@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1TokenizerSection@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1TokenizerSection@@QAE@XZ ENDP			; TokenizerSection::~TokenizerSection
PUBLIC	??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ ; std::_Pair_base<unsigned long const ,TokenizerSection>::~_Pair_base<unsigned long const ,TokenizerSection>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ$3
__ehfuncinfo$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ
_TEXT	SEGMENT
$T193413 = -20						; size = 4
$T193444 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ PROC ; std::_Pair_base<unsigned long const ,TokenizerSection>::~_Pair_base<unsigned long const ,TokenizerSection>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00029	89 75 f0	 mov	 DWORD PTR $T193444[ebp], esi
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	8d 45 ec	 lea	 eax, DWORD PTR $T193413[ebp]
  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ$3:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T193444[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ ENDP ; std::_Pair_base<unsigned long const ,TokenizerSection>::~_Pair_base<unsigned long const ,TokenizerSection>
PUBLIC	??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z ; std::_Pair_base<unsigned long const ,TokenizerSection>::_Pair_base<unsigned long const ,TokenizerSection>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z PROC ; std::_Pair_base<unsigned long const ,TokenizerSection>::_Pair_base<unsigned long const ,TokenizerSection>, COMDAT
; _this$ = ecx

; 150  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 151  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z ENDP ; std::_Pair_base<unsigned long const ,TokenizerSection>::_Pair_base<unsigned long const ,TokenizerSection>
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@$$QBK$$QAVTokenizerSection@@@Z ; std::_Pair_base<unsigned long const ,TokenizerSection>::_Pair_base<unsigned long const ,TokenizerSection>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@$$QBK$$QAVTokenizerSection@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@$$QBK$$QAVTokenizerSection@@@Z PROC ; std::_Pair_base<unsigned long const ,TokenizerSection>::_Pair_base<unsigned long const ,TokenizerSection>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 146  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@$$QBK$$QAVTokenizerSection@@@Z ENDP ; std::_Pair_base<unsigned long const ,TokenizerSection>::_Pair_base<unsigned long const ,TokenizerSection>
_TEXT	ENDS
PUBLIC	??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ	; std::pair<unsigned long const ,TokenizerSection>::~pair<unsigned long const ,TokenizerSection>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ$4
__ehfuncinfo$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ
_TEXT	SEGMENT
$T193773 = -20						; size = 4
$T193747 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ PROC	; std::pair<unsigned long const ,TokenizerSection>::~pair<unsigned long const ,TokenizerSection>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00029	89 75 f0	 mov	 DWORD PTR $T193747[ebp], esi
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	8d 45 ec	 lea	 eax, DWORD PTR $T193773[ebp]
  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ$4:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T193747[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ ENDP	; std::pair<unsigned long const ,TokenizerSection>::~pair<unsigned long const ,TokenizerSection>
PUBLIC	??0?$pair@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z ; std::pair<unsigned long const ,TokenizerSection>::pair<unsigned long const ,TokenizerSection>
; Function compile flags: /Ogtp
;	COMDAT ??0?$pair@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z PROC ; std::pair<unsigned long const ,TokenizerSection>::pair<unsigned long const ,TokenizerSection>, COMDAT
; _this$ = ecx

; 233  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 234  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$pair@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z ENDP ; std::pair<unsigned long const ,TokenizerSection>::pair<unsigned long const ,TokenizerSection>
_TEXT	ENDS
PUBLIC	??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z ; std::pair<unsigned long const ,TokenizerSection>::`scalar deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z$4
__ehfuncinfo$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
$T194144 = -20						; size = 4
$T194087 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z PROC	; std::pair<unsigned long const ,TokenizerSection>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  0002c	89 75 f0	 mov	 DWORD PTR $T194087[ebp], esi
  0002f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	8d 45 ec	 lea	 eax, DWORD PTR $T194144[ebp]
  00039	50		 push	 eax
  0003a	8b ce		 mov	 ecx, esi
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00048	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00051	83 c4 04	 add	 esp, 4
  00054	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00058	74 09		 je	 SHORT $LN49@scalar@22
  0005a	57		 push	 edi
  0005b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00060	83 c4 04	 add	 esp, 4
$LN49@scalar@22:
  00063	8b c7		 mov	 eax, edi
  00065	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006f	59		 pop	 ecx
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z$4:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T194087[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z ENDP	; std::pair<unsigned long const ,TokenizerSection>::`scalar deleting destructor'
PUBLIC	??$?0$$CBKVTokenizerSection@@@?$pair@$$CBKVTokenizerSection@@@std@@QAE@$$QAU01@@Z ; std::pair<unsigned long const ,TokenizerSection>::pair<unsigned long const ,TokenizerSection><unsigned long const ,TokenizerSection>
; Function compile flags: /Ogtp
;	COMDAT ??$?0$$CBKVTokenizerSection@@@?$pair@$$CBKVTokenizerSection@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0$$CBKVTokenizerSection@@@?$pair@$$CBKVTokenizerSection@@@std@@QAE@$$QAU01@@Z PROC ; std::pair<unsigned long const ,TokenizerSection>::pair<unsigned long const ,TokenizerSection><unsigned long const ,TokenizerSection>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	57		 push	 edi
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	89 06		 mov	 DWORD PTR [esi], eax
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  0001b	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0001e	5f		 pop	 edi
  0001f	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 256  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??$?0$$CBKVTokenizerSection@@@?$pair@$$CBKVTokenizerSection@@@std@@QAE@$$QAU01@@Z ENDP ; std::pair<unsigned long const ,TokenizerSection>::pair<unsigned long const ,TokenizerSection><unsigned long const ,TokenizerSection>
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z ; std::_Destroy<std::pair<unsigned long const ,TokenizerSection> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z$4
__ehfuncinfo$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z
_TEXT	SEGMENT
$T194601 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T194483 = 8						; size = 4
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z PROC ; std::_Destroy<std::pair<unsigned long const ,TokenizerSection> >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 63   : 	_Ptr->~_Ty();

  00024	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00027	83 c6 04	 add	 esi, 4
  0002a	89 75 08	 mov	 DWORD PTR $T194483[ebp], esi
  0002d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	8d 45 f0	 lea	 eax, DWORD PTR $T194601[ebp]
  00037	50		 push	 eax
  00038	8b ce		 mov	 ecx, esi
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00046	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004f	83 c4 04	 add	 esp, 4

; 64   : 	}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z$4:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR $T194483[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z ENDP ; std::_Destroy<std::pair<unsigned long const ,TokenizerSection> >
PUBLIC	?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z$0
__ehfuncinfo$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z
_TEXT	SEGMENT
$T194629 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00025	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T194629[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN3@construct@6
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN3@construct@6:

; 203  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T194629[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::construct
PUBLIC	?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::destroy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z$4
__ehfuncinfo$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z
_TEXT	SEGMENT
$T195115 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T194961 = 8						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 213  : 		_Destroy(_Ptr);

  00024	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00027	83 c6 04	 add	 esi, 4
  0002a	89 75 08	 mov	 DWORD PTR $T194961[ebp], esi
  0002d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	8d 45 f0	 lea	 eax, DWORD PTR $T195115[ebp]
  00037	50		 push	 eax
  00038	8b ce		 mov	 ecx, esi
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00046	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004f	83 c4 04	 add	 esp, 4

; 214  : 		}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z$4:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR $T194961[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::destroy
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection>,std::pair<unsigned long const ,TokenizerSection> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z
_TEXT	SEGMENT
$T195228 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection>,std::pair<unsigned long const ,TokenizerSection> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T195228[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN7@Cons_val@6
  00036	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN7@Cons_val@6:

; 281  : 	}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T195228[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection>,std::pair<unsigned long const ,TokenizerSection> >
PUBLIC	??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerSection> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z
_TEXT	SEGMENT
$T195324 = -32						; size = 12
__Ptr$195318 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T195270 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerSection> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002d	6a 28		 push	 40			; 00000028H
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	8b f0		 mov	 esi, eax
  00036	33 c0		 xor	 eax, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	89 75 ec	 mov	 DWORD PTR __Ptr$195318[ebp], esi
  0003e	3b f0		 cmp	 esi, eax
  00040	74 57		 je	 SHORT $LN12@Buynode@9
  00042	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00045	89 0e		 mov	 DWORD PTR [esi], ecx
  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0004d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00050	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	66 89 46 24	 mov	 WORD PTR [esi+36], ax
  00057	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  0005a	52		 push	 edx
  0005b	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005e	50		 push	 eax
  0005f	83 c7 0d	 add	 edi, 13			; 0000000dH
  00062	57		 push	 edi
  00063	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00066	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection>,std::pair<unsigned long const ,TokenizerSection> >
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  0006e	8b c6		 mov	 eax, esi

; 599  : 		}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
__catch$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$195318[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4

; 595  : 		_RERAISE;

  00090	33 c0		 xor	 eax, eax
  00092	50		 push	 eax
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Buynode@9:

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@9:
  00099	8d 55 08	 lea	 edx, DWORD PTR $T195270[ebp]
  0009c	52		 push	 edx
  0009d	8d 4d e0	 lea	 ecx, DWORD PTR $T195324[ebp]
  000a0	89 45 08	 mov	 DWORD PTR $T195270[ebp], eax
  000a3	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ad	8d 45 e0	 lea	 eax, DWORD PTR $T195324[ebp]
  000b0	50		 push	 eax
  000b1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T195324[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Buynode@9:
$LN44@Buynode@9:
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerSection> >
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z$4
__ehfuncinfo$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z
_TEXT	SEGMENT
$T195826 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
$T195626 = 12						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 287  : 	_Alval.destroy(_Pdest);

  00024	8b 75 0c	 mov	 esi, DWORD PTR __Pdest$[ebp]
  00027	83 c6 04	 add	 esi, 4
  0002a	89 75 0c	 mov	 DWORD PTR $T195626[ebp], esi
  0002d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	8d 45 f0	 lea	 eax, DWORD PTR $T195826[ebp]
  00037	50		 push	 eax
  00038	8b ce		 mov	 ecx, esi
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00046	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004f	83 c4 04	 add	 esp, 4

; 288  : 	}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z$4:
  00000	8b 4d 0c	 mov	 ecx, DWORD PTR $T195626[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv797 = -12						; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	80 7b 25 00	 cmp	 BYTE PTR [ebx+37], 0
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00013	74 0a		 je	 SHORT $LN40@erase@6

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN297@erase@6:
$LN40@erase@6:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1207 : 		++_Where;	// save successor iterator for return

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00022	89 5d f8	 mov	 DWORD PTR __Erasednode$[ebp], ebx
  00025	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  0002a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002c	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00030	74 05		 je	 SHORT $LN39@erase@6

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00032	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00035	eb 17		 jmp	 SHORT $LN291@erase@6
$LN39@erase@6:
  00037	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0003a	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0003e	74 04		 je	 SHORT $LN37@erase@6

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00040	8b f9		 mov	 edi, ecx

; 1218 : 		else

  00042	eb 0a		 jmp	 SHORT $LN291@erase@6
$LN37@erase@6:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00047	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  0004a	3b c3		 cmp	 eax, ebx
  0004c	75 72		 jne	 SHORT $LN35@erase@6
$LN291@erase@6:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004e	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  00052	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00055	75 03		 jne	 SHORT $LN34@erase@6

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00057	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase@6:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00060	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00063	75 05		 jne	 SHORT $LN33@erase@6

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00065	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00068	eb 0b		 jmp	 SHORT $LN30@erase@6
$LN33@erase@6:
  0006a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0006c	75 04		 jne	 SHORT $LN31@erase@6

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006e	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  00070	eb 03		 jmp	 SHORT $LN30@erase@6
$LN31@erase@6:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  00072	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase@6:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	39 18		 cmp	 DWORD PTR [eax], ebx
  0007a	75 1b		 jne	 SHORT $LN29@erase@6

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007c	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  00080	74 04		 je	 SHORT $LN43@erase@6
  00082	8b c6		 mov	 eax, esi
  00084	eb 0c		 jmp	 SHORT $LN44@erase@6
$LN43@erase@6:
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Min
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c4 04	 add	 esp, 4
$LN44@erase@6:
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	89 02		 mov	 DWORD PTR [edx], eax
$LN29@erase@6:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  00097	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009a	89 4d f4	 mov	 DWORD PTR tv797[ebp], ecx
  0009d	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000a0	75 78		 jne	 SHORT $LN165@erase@6

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000a2	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  000a6	74 07		 je	 SHORT $LN45@erase@6
  000a8	8b c6		 mov	 eax, esi
  000aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000ad	eb 6b		 jmp	 SHORT $LN165@erase@6
$LN45@erase@6:

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Max
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR tv797[ebp]
  000b8	83 c4 04	 add	 esp, 4
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000be	eb 5a		 jmp	 SHORT $LN165@erase@6
$LN35@erase@6:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c0	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase@6

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f0		 mov	 esi, eax

; 1257 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase@6
$LN26@erase@6:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	75 03		 jne	 SHORT $LN24@erase@6

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase@6:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e1	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000e4	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000e7	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN25@erase@6:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f0	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000f3	75 05		 jne	 SHORT $LN23@erase@6

; 1271 : 				_Root() = _Pnode;	// link down from root

  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f8	eb 0e		 jmp	 SHORT $LN20@erase@6
$LN23@erase@6:
  000fa	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000fd	39 19		 cmp	 DWORD PTR [ecx], ebx
  000ff	75 04		 jne	 SHORT $LN21@erase@6

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00101	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  00103	eb 03		 jmp	 SHORT $LN20@erase@6
$LN21@erase@6:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  00105	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase@6:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00108	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0010b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  0010e	8a 53 24	 mov	 dl, BYTE PTR [ebx+36]
  00111	8a 48 24	 mov	 cl, BYTE PTR [eax+36]
  00114	88 50 24	 mov	 BYTE PTR [eax+36], dl
  00117	88 4b 24	 mov	 BYTE PTR [ebx+36], cl
$LN165@erase@6:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	b3 01		 mov	 bl, 1
  00122	38 58 24	 cmp	 BYTE PTR [eax+36], bl
  00125	0f 85 fa 00 00
	00		 jne	 $LN19@erase@6
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	3b 7a 04	 cmp	 edi, DWORD PTR [edx+4]
  00131	0f 84 eb 00 00
	00		 je	 $LN16@erase@6
$LL18@erase@6:
  00137	38 5f 24	 cmp	 BYTE PTR [edi+36], bl
  0013a	0f 85 e2 00 00
	00		 jne	 $LN16@erase@6

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00140	8b 06		 mov	 eax, DWORD PTR [esi]
  00142	3b f8		 cmp	 edi, eax
  00144	75 65		 jne	 SHORT $LN15@erase@6

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  00146	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  00149	80 78 24 00	 cmp	 BYTE PTR [eax+36], 0
  0014d	75 13		 jne	 SHORT $LN14@erase@6

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0014f	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  00152	56		 push	 esi
  00153	c6 46 24 00	 mov	 BYTE PTR [esi+36], 0
  00157	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN14@erase@6:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00162	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00166	75 74		 jne	 SHORT $LN294@erase@6

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00168	8b 10		 mov	 edx, DWORD PTR [eax]
  0016a	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  0016d	75 08		 jne	 SHORT $LN11@erase@6
  0016f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00172	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00175	74 61		 je	 SHORT $LN295@erase@6
$LN11@erase@6:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  00177	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017a	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  0017d	75 15		 jne	 SHORT $LN9@erase@6

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  00184	50		 push	 eax
  00185	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
  00189	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  0018e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN9@erase@6:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00194	8a 56 24	 mov	 dl, BYTE PTR [esi+36]
  00197	88 50 24	 mov	 BYTE PTR [eax+36], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0019a	88 5e 24	 mov	 BYTE PTR [esi+36], bl

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0019d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1323 : 						_Lrotate(_Fixnodeparent);

  001a0	56		 push	 esi
  001a1	88 58 24	 mov	 BYTE PTR [eax+36], bl
  001a4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001a9	eb 74		 jmp	 SHORT $LN296@erase@6
$LN15@erase@6:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001ab	80 78 24 00	 cmp	 BYTE PTR [eax+36], 0
  001af	75 12		 jne	 SHORT $LN7@erase@6

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001b1	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001b4	56		 push	 esi
  001b5	c6 46 24 00	 mov	 BYTE PTR [esi+36], 0
  001b9	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001be	8b 06		 mov	 eax, DWORD PTR [esi]
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN7@erase@6:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001c3	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001c7	75 13		 jne	 SHORT $LN294@erase@6

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001cc	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001cf	75 1e		 jne	 SHORT $LN4@erase@6
  001d1	8b 10		 mov	 edx, DWORD PTR [eax]
  001d3	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001d6	75 17		 jne	 SHORT $LN4@erase@6
$LN295@erase@6:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001d8	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
$LN294@erase@6:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001dc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1344 : 						_Fixnode = _Fixnodeparent;

  001df	8b fe		 mov	 edi, esi
  001e1	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001e4	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001e7	0f 85 4a ff ff
	ff		 jne	 $LL18@erase@6

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001ed	eb 33		 jmp	 SHORT $LN16@erase@6
$LN4@erase@6:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001ef	8b 10		 mov	 edx, DWORD PTR [eax]
  001f1	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001f4	75 15		 jne	 SHORT $LN2@erase@6

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001f9	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  001fc	50		 push	 eax
  001fd	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
  00201	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00206	8b 06		 mov	 eax, DWORD PTR [esi]
  00208	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN2@erase@6:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0020b	8a 56 24	 mov	 dl, BYTE PTR [esi+36]
  0020e	88 50 24	 mov	 BYTE PTR [eax+36], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00211	88 5e 24	 mov	 BYTE PTR [esi+36], bl

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00214	8b 00		 mov	 eax, DWORD PTR [eax]

; 1359 : 						_Rrotate(_Fixnodeparent);

  00216	56		 push	 esi
  00217	88 58 24	 mov	 BYTE PTR [eax+36], bl
  0021a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rrotate
$LN296@erase@6:
  0021f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN16@erase@6:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00222	88 5f 24	 mov	 BYTE PTR [edi+36], bl
$LN19@erase@6:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00225	8b 55 f8	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00228	83 c2 0c	 add	 edx, 12			; 0000000cH
  0022b	52		 push	 edx
  0022c	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00235	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00241	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00244	83 c4 0c	 add	 esp, 12			; 0000000cH
  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
  00249	5b		 pop	 ebx
  0024a	85 c0		 test	 eax, eax
  0024c	74 04		 je	 SHORT $LN1@erase@6

; 1373 : 			--this->_Mysize;

  0024e	48		 dec	 eax
  0024f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase@6:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  00252	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00255	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00258	89 08		 mov	 DWORD PTR [eax], ecx

; 1376 : 		}

  0025a	8b e5		 mov	 esp, ebp
  0025c	5d		 pop	 ebp
  0025d	c2 08 00	 ret	 8
$LN293@erase@6:
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Erase
; Function compile flags: /Ogtp
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 2b		 jne	 SHORT $LN1@Erase@3
$LL3@Erase@3:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	50		 push	 eax
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  00020	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00023	51		 push	 ecx
  00024	8d 43 0d	 lea	 eax, DWORD PTR [ebx+13]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  0003a	8b fe		 mov	 edi, esi
  0003c	74 d5		 je	 SHORT $LL3@Erase@3
$LN1@Erase@3:
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
; Function compile flags: /Ogtp
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	3d a9 aa aa 0a	 cmp	 eax, 178956969		; 0aaaaaa9H
  0000e	72 23		 jb	 SHORT $LN17@Insert@5

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  00010	8b 75 14	 mov	 esi, DWORD PTR __Newnode$[ebp]
  00013	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00016	50		 push	 eax
  00017	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0002e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN377@Insert@5:
$LN17@Insert@5:

; 1640 : 			}
; 1641 : 		++this->_Mysize;
; 1642 : 		_Newnode->_Parent = _Wherenode;

  00033	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00036	40		 inc	 eax
  00037	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0003a	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0003d	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00040	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00043	32 db		 xor	 bl, bl
  00045	3b c2		 cmp	 eax, edx
  00047	75 10		 jne	 SHORT $LN16@Insert@5

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00049	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1647 : 			_Lmost() = _Newnode;

  0004c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004f	89 3a		 mov	 DWORD PTR [edx], edi

; 1648 : 			_Rmost() = _Newnode;

  00051	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00054	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00057	eb 20		 jmp	 SHORT $LN11@Insert@5
$LN16@Insert@5:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  00059	38 5d 0c	 cmp	 BYTE PTR __Addleft$[ebp], bl
  0005c	74 0d		 je	 SHORT $LN14@Insert@5

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  0005e	89 38		 mov	 DWORD PTR [eax], edi

; 1653 : 			if (_Wherenode == _Lmost())

  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	3b 02		 cmp	 eax, DWORD PTR [edx]
  00065	75 12		 jne	 SHORT $LN11@Insert@5

; 1654 : 				_Lmost() = _Newnode;

  00067	89 3a		 mov	 DWORD PTR [edx], edi

; 1655 : 			}
; 1656 : 		else

  00069	eb 0e		 jmp	 SHORT $LN11@Insert@5
$LN14@Insert@5:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  0006b	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 1659 : 			if (_Wherenode == _Rmost())

  0006e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00071	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00074	75 03		 jne	 SHORT $LN11@Insert@5

; 1660 : 				_Rmost() = _Newnode;

  00076	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN11@Insert@5:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00079	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007c	8b c7		 mov	 eax, edi
  0007e	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00081	0f 85 8f 01 00
	00		 jne	 $LN9@Insert@5
$LL10@Insert@5:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0008d	3b 16		 cmp	 edx, DWORD PTR [esi]
  0008f	0f 85 c1 00 00
	00		 jne	 $LN8@Insert@5

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00095	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00098	38 5e 24	 cmp	 BYTE PTR [esi+36], bl
  0009b	75 1c		 jne	 SHORT $LN7@Insert@5

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0009d	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  000a1	c6 46 24 01	 mov	 BYTE PTR [esi+36], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  000a5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a8	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000ab	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000ae	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1677 : 					}
; 1678 : 				else

  000b4	e9 51 01 00 00	 jmp	 $LN316@Insert@5
$LN7@Insert@5:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000b9	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  000bc	75 3a		 jne	 SHORT $LN111@Insert@5

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  000be	8b c2		 mov	 eax, edx

; 1683 : 						_Lrotate(_Pnode);

  000c0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000c3	8b 32		 mov	 esi, DWORD PTR [edx]
  000c5	89 70 08	 mov	 DWORD PTR [eax+8], esi
  000c8	8b 32		 mov	 esi, DWORD PTR [edx]
  000ca	38 5e 25	 cmp	 BYTE PTR [esi+37], bl
  000cd	75 03		 jne	 SHORT $LN110@Insert@5
  000cf	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN110@Insert@5:
  000d2	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d5	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000d8	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000db	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000de	75 05		 jne	 SHORT $LN109@Insert@5
  000e0	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000e3	eb 0e		 jmp	 SHORT $LN106@Insert@5
$LN109@Insert@5:
  000e5	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000e8	3b 06		 cmp	 eax, DWORD PTR [esi]
  000ea	75 04		 jne	 SHORT $LN107@Insert@5
  000ec	89 16		 mov	 DWORD PTR [esi], edx
  000ee	eb 03		 jmp	 SHORT $LN106@Insert@5
$LN107@Insert@5:
  000f0	89 56 08	 mov	 DWORD PTR [esi+8], edx
$LN106@Insert@5:
  000f3	89 02		 mov	 DWORD PTR [edx], eax
  000f5	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN111@Insert@5:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000f8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000fb	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000ff	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00102	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00105	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00108	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0010b	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0010e	8b 32		 mov	 esi, DWORD PTR [edx]
  00110	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00113	89 3a		 mov	 DWORD PTR [edx], edi
  00115	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00118	38 5f 25	 cmp	 BYTE PTR [edi+37], bl
  0011b	75 03		 jne	 SHORT $LN173@Insert@5
  0011d	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN173@Insert@5:
  00120	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00123	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00126	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00129	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  0012c	75 0b		 jne	 SHORT $LN172@Insert@5
  0012e	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00131	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00134	e9 cb 00 00 00	 jmp	 $LN376@Insert@5

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN172@Insert@5:
  00139	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0013c	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  0013f	75 0b		 jne	 SHORT $LN170@Insert@5
  00141	89 77 08	 mov	 DWORD PTR [edi+8], esi
  00144	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00147	e9 b8 00 00 00	 jmp	 $LN376@Insert@5

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN170@Insert@5:
  0014c	89 37		 mov	 DWORD PTR [edi], esi
  0014e	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00151	e9 ae 00 00 00	 jmp	 $LN376@Insert@5
$LN8@Insert@5:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  00156	8b 36		 mov	 esi, DWORD PTR [esi]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  00158	38 5e 24	 cmp	 BYTE PTR [esi+36], bl
  0015b	75 1c		 jne	 SHORT $LN3@Insert@5

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0015d	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  00161	c6 46 24 01	 mov	 BYTE PTR [esi+36], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  00165	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00168	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0016b	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  0016e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00171	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1703 : 					}
; 1704 : 				else

  00174	e9 91 00 00 00	 jmp	 $LN316@Insert@5
$LN3@Insert@5:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00179	3b 02		 cmp	 eax, DWORD PTR [edx]
  0017b	75 3c		 jne	 SHORT $LN253@Insert@5

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  0017d	8b c2		 mov	 eax, edx

; 1709 : 						_Rrotate(_Pnode);

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00184	89 30		 mov	 DWORD PTR [eax], esi
  00186	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00189	38 5e 25	 cmp	 BYTE PTR [esi+37], bl
  0018c	75 03		 jne	 SHORT $LN252@Insert@5
  0018e	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN252@Insert@5:
  00191	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00194	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00197	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0019a	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0019d	75 05		 jne	 SHORT $LN251@Insert@5
  0019f	89 56 04	 mov	 DWORD PTR [esi+4], edx
  001a2	eb 0f		 jmp	 SHORT $LN248@Insert@5
$LN251@Insert@5:
  001a4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001a7	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  001aa	75 05		 jne	 SHORT $LN249@Insert@5
  001ac	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001af	eb 02		 jmp	 SHORT $LN248@Insert@5
$LN249@Insert@5:
  001b1	89 16		 mov	 DWORD PTR [esi], edx
$LN248@Insert@5:
  001b3	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001b6	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN253@Insert@5:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  001b9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bc	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  001c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001c3	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001c6	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001c9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001cc	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001cf	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  001d2	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d4	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  001d7	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d9	38 5f 25	 cmp	 BYTE PTR [edi+37], bl
  001dc	75 03		 jne	 SHORT $LN315@Insert@5
  001de	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN315@Insert@5:
  001e1	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001e4	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001e7	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  001ea	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  001ed	75 05		 jne	 SHORT $LN314@Insert@5
  001ef	89 77 04	 mov	 DWORD PTR [edi+4], esi
  001f2	eb 0e		 jmp	 SHORT $LN311@Insert@5
$LN314@Insert@5:
  001f4	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001f7	3b 17		 cmp	 edx, DWORD PTR [edi]
  001f9	75 04		 jne	 SHORT $LN312@Insert@5
  001fb	89 37		 mov	 DWORD PTR [edi], esi
  001fd	eb 03		 jmp	 SHORT $LN311@Insert@5
$LN312@Insert@5:
  001ff	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN311@Insert@5:
  00202	89 16		 mov	 DWORD PTR [esi], edx
$LN376@Insert@5:
  00204	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00207	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN316@Insert@5:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  0020a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0020d	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00210	0f 84 71 fe ff
	ff		 je	 $LL10@Insert@5
$LN9@Insert@5:

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00216	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00219	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1720 : 		return (iterator(_Newnode, this));

  0021c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0021f	89 38		 mov	 DWORD PTR [eax], edi
  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	c6 41 24 01	 mov	 BYTE PTR [ecx+36], 1
  00227	5b		 pop	 ebx

; 1721 : 		}

  00228	5d		 pop	 ebp
  00229	c2 10 00	 ret	 16			; 00000010H
$LN375@Insert@5:
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	51		 push	 ecx
  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001a	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1419 : 		this->_Mysize = 0;

  00022	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00029	5e		 pop	 esi

; 1420 : 		}

  0002a	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Linsert
; Function compile flags: /Ogtp
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
$T197125 = 16						; size = 4
$T197123 = 16						; size = 4
__Where$152225 = 16					; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx

; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00012	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00016	8b f1		 mov	 esi, ecx
  00018	b1 01		 mov	 cl, 1
  0001a	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 2d		 jne	 SHORT $LN11@Linsert@3
  0001f	8b 5a 0c	 mov	 ebx, DWORD PTR [edx+12]
$LL12@Linsert@3:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Leftish$[ebp], 0
  00026	8b f0		 mov	 esi, eax
  00028	74 08		 je	 SHORT $LN10@Linsert@3

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0002a	39 58 0c	 cmp	 DWORD PTR [eax+12], ebx
  0002d	0f 93 c1	 setae	 cl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00030	eb 06		 jmp	 SHORT $LN145@Linsert@3
$LN10@Linsert@3:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00032	3b 58 0c	 cmp	 ebx, DWORD PTR [eax+12]
  00035	0f 92 c1	 setb	 cl
$LN145@Linsert@3:
  00038	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0003b	84 c9		 test	 cl, cl
  0003d	74 04		 je	 SHORT $LN15@Linsert@3
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 03		 jmp	 SHORT $LN16@Linsert@3
$LN15@Linsert@3:
  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert@3:

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00046	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0004a	74 d6		 je	 SHORT $LL12@Linsert@3
$LN11@Linsert@3:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  0004c	8b de		 mov	 ebx, esi
  0004e	89 5d 10	 mov	 DWORD PTR __Where$152225[ebp], ebx

; 970  : 			if (!_Addleft)

  00051	84 c9		 test	 cl, cl
  00053	74 35		 je	 SHORT $LN99@Linsert@3

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00055	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00058	8d 4d 10	 lea	 ecx, DWORD PTR $T197123[ebp]
  0005b	3b 30		 cmp	 esi, DWORD PTR [eax]
  0005d	75 20		 jne	 SHORT $LN4@Linsert@3
  0005f	52		 push	 edx
  00060	56		 push	 esi
  00061	6a 01		 push	 1
  00063	51		 push	 ecx
  00064	8b cf		 mov	 ecx, edi
  00066	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  0006b	8b 10		 mov	 edx, DWORD PTR [eax]
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	89 10		 mov	 DWORD PTR [eax], edx
  00074	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  00078	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@Linsert@3:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  0007f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--
  00084	8b 5d 10	 mov	 ebx, DWORD PTR __Where$152225[ebp]
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert@3:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  0008a	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0008d	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  00090	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00093	73 25		 jae	 SHORT $LN2@Linsert@3

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  00095	52		 push	 edx
  00096	8b 55 fc	 mov	 edx, DWORD PTR __Addleft$[ebp]
  00099	56		 push	 esi
  0009a	52		 push	 edx
  0009b	8d 45 10	 lea	 eax, DWORD PTR $T197125[ebp]
  0009e	50		 push	 eax
  0009f	8b cf		 mov	 ecx, edi
  000a1	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000b3	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Linsert@3:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  000ba	50		 push	 eax
  000bb	83 c7 0d	 add	 edi, 13			; 0000000dH
  000be	57		 push	 edi
  000bf	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000c4	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000cd	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	89 18		 mov	 DWORD PTR [eax], ebx
  000d7	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000db	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T197439 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00012	75 38		 jne	 SHORT $LN115@erase@7
  00014	3b d0		 cmp	 edx, eax
  00016	75 34		 jne	 SHORT $LN115@erase@7

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	50		 push	 eax
  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Erase
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 00		 mov	 DWORD PTR [eax], eax
  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1383 : 			return (begin());

  00034	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00037	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	89 10		 mov	 DWORD PTR [eax], edx
  00045	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 0c 00	 ret	 12			; 0000000cH
$LN115@erase@7:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0004c	3b ca		 cmp	 ecx, edx
  0004e	74 62		 je	 SHORT $LN1@erase@7
$LL2@erase@7:

; 1388 : 				erase(_First++);

  00050	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00054	8b d1		 mov	 edx, ecx
  00056	75 46		 jne	 SHORT $LN77@erase@7
  00058	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0005b	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0005f	75 1e		 jne	 SHORT $LN117@erase@7
  00061	8b c8		 mov	 ecx, eax
  00063	8b 01		 mov	 eax, DWORD PTR [ecx]
  00065	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00069	75 0f		 jne	 SHORT $LN91@erase@7
  0006b	eb 03 8d 49 00	 npad	 5
$LL92@erase@7:
  00070	8b c8		 mov	 ecx, eax
  00072	8b 01		 mov	 eax, DWORD PTR [ecx]
  00074	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00078	74 f6		 je	 SHORT $LL92@erase@7
$LN91@erase@7:
  0007a	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  0007d	eb 1f		 jmp	 SHORT $LN77@erase@7
$LN117@erase@7:
  0007f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00082	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00086	75 13		 jne	 SHORT $LN75@erase@7
$LL76@erase@7:
  00088	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0008b	75 0e		 jne	 SHORT $LN75@erase@7
  0008d	8b c8		 mov	 ecx, eax
  0008f	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  00092	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00095	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00099	74 ed		 je	 SHORT $LL76@erase@7
$LN75@erase@7:
  0009b	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
$LN77@erase@7:
  0009e	52		 push	 edx
  0009f	8d 45 fc	 lea	 eax, DWORD PTR $T197439[ebp]
  000a2	50		 push	 eax
  000a3	8b ce		 mov	 ecx, esi
  000a5	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  000ad	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  000b0	75 9e		 jne	 SHORT $LL2@erase@7
$LN1@erase@7:

; 1389 : 			return (iterator(_First._Ptr, this));

  000b2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b5	89 08		 mov	 DWORD PTR [eax], ecx
  000b7	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
; Function compile flags: /Ogtp
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
$T197830 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Node$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1089 : 		{	// try to insert node at _Node using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1090 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1091 : 		if (_Where._Getcont() != this)
; 1092 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1093 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1094 : 
; 1095 : 		const value_type& _Val = this->_Myval(_Node);
; 1096 : 
; 1097 : 		const_iterator _Next;
; 1098 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1099 : 
; 1100 : 		if (size() == 0)

  00009	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0

; 1101 : 			return (_Insert(true, this->_Myhead, _Node));	// empty tree

  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	57		 push	 edi
  00011	8b 7d 10	 mov	 edi, DWORD PTR __Node$[ebp]
  00014	75 17		 jne	 SHORT $LN33@Insert@6
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	50		 push	 eax
  0001b	6a 01		 push	 1
  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  00023	8b c7		 mov	 eax, edi
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 1181 : 		}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
$LN33@Insert@6:
  0002d	53		 push	 ebx

; 1102 : 		else if (this->_Multi)
; 1103 : 			{	// insert even if duplicate
; 1104 : 			if (_Where == begin())
; 1105 : 				{	// insert at beginning if before first element
; 1106 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1107 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1108 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1109 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1110 : 				}
; 1111 : 			else if (_Where == end())
; 1112 : 				{	// insert at end if after last element
; 1113 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1114 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1115 : 					return (_Insert(false, _Rmost(), _Node));
; 1116 : 				}
; 1117 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1118 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1119 : 				&& !_DEBUG_LT_PRED(this->comp,
; 1120 : 					this->_Kfn(_Val),
; 1121 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1122 : 				{	// insert before _Where
; 1123 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1124 : 					return (_Insert(false, _Next._Mynode(), _Node));
; 1125 : 				else
; 1126 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1127 : 				}
; 1128 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1129 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1130 : 				&& (++(_Next = _Where) == end()
; 1131 : 					|| !_DEBUG_LT_PRED(this->comp,
; 1132 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1133 : 				{	// insert after _Where
; 1134 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1135 : 					return (_Insert(false, _Where._Mynode(), _Node));
; 1136 : 				else
; 1137 : 					return (_Insert(true, _Next._Mynode(), _Node));
; 1138 : 				}
; 1139 : 			else
; 1140 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1141 : 			}
; 1142 : 		else
; 1143 : 			{	// insert only if unique
; 1144 : 			if (_Where == begin())

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  00031	3b 18		 cmp	 ebx, DWORD PTR [eax]
  00033	75 26		 jne	 SHORT $LN14@Insert@6

; 1145 : 				{	// insert at beginning if before first element
; 1146 : 				if (_DEBUG_LT_PRED(this->comp,

  00035	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00038	3b 4b 0c	 cmp	 ecx, DWORD PTR [ebx+12]
  0003b	0f 83 f4 00 00
	00		 jae	 $LN333@Insert@6

; 1147 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1148 : 					return (_Insert(true, _Where._Mynode(), _Node));

  00041	57		 push	 edi
  00042	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00045	53		 push	 ebx
  00046	6a 01		 push	 1
  00048	57		 push	 edi
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  00050	5b		 pop	 ebx
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 1181 : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
$LN14@Insert@6:

; 1149 : 				}
; 1150 : 			else if (_Where == end())

  0005b	3b d8		 cmp	 ebx, eax
  0005d	75 27		 jne	 SHORT $LN11@Insert@6

; 1151 : 				{	// insert at end if after last element
; 1152 : 				if (_DEBUG_LT_PRED(this->comp,

  0005f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00062	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00065	3b 57 0c	 cmp	 edx, DWORD PTR [edi+12]
  00068	0f 83 c7 00 00
	00		 jae	 $LN333@Insert@6

; 1153 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1154 : 					return (_Insert(false, _Rmost(), _Node));

  0006e	57		 push	 edi
  0006f	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00072	50		 push	 eax
  00073	6a 00		 push	 0
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  0007b	5b		 pop	 ebx
  0007c	8b c7		 mov	 eax, edi
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 1181 : 		}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 0c 00	 ret	 12			; 0000000cH
$LN11@Insert@6:

; 1155 : 				}
; 1156 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1157 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1158 : 				&& _DEBUG_LT_PRED(this->comp,

  00086	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00089	3b 43 0c	 cmp	 eax, DWORD PTR [ebx+12]
  0008c	73 4d		 jae	 SHORT $LN332@Insert@6
  0008e	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  00091	89 5d 10	 mov	 DWORD PTR __Next$[ebp], ebx
  00094	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--
  00099	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  0009c	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0009f	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  000a2	73 37		 jae	 SHORT $LN332@Insert@6

; 1159 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1160 : 					this->_Kfn(_Val)))
; 1161 : 				{	// insert before _Where
; 1162 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  000a4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a7	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0

; 1163 : 					return (_Insert(false, _Next._Mynode(), _Node));

  000ab	57		 push	 edi
  000ac	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  000af	8b ce		 mov	 ecx, esi
  000b1	74 14		 je	 SHORT $LN7@Insert@6
  000b3	50		 push	 eax
  000b4	6a 00		 push	 0
  000b6	57		 push	 edi
  000b7	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  000bc	5b		 pop	 ebx
  000bd	8b c7		 mov	 eax, edi
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi

; 1181 : 		}

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH
$LN7@Insert@6:

; 1164 : 				else
; 1165 : 					return (_Insert(true, _Where._Mynode(), _Node));

  000c7	53		 push	 ebx
  000c8	6a 01		 push	 1
  000ca	57		 push	 edi
  000cb	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  000d0	5b		 pop	 ebx
  000d1	8b c7		 mov	 eax, edi
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi

; 1181 : 		}

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 0c 00	 ret	 12			; 0000000cH
$LN332@Insert@6:

; 1166 : 				}
; 1167 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1168 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1169 : 				&& (++(_Next = _Where) == end()
; 1170 : 					|| _DEBUG_LT_PRED(this->comp,

  000db	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000de	39 43 0c	 cmp	 DWORD PTR [ebx+12], eax
  000e1	73 52		 jae	 SHORT $LN333@Insert@6
  000e3	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  000e6	89 5d 10	 mov	 DWORD PTR __Next$[ebp], ebx
  000e9	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++
  000ee	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  000f1	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000f4	74 08		 je	 SHORT $LN3@Insert@6
  000f6	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000f9	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000fc	73 37		 jae	 SHORT $LN333@Insert@6
$LN3@Insert@6:

; 1171 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1172 : 				{	// insert after _Where
; 1173 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  000fe	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00101	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0

; 1174 : 					return (_Insert(false, _Where._Mynode(), _Node));

  00105	57		 push	 edi
  00106	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00109	8b ce		 mov	 ecx, esi
  0010b	74 14		 je	 SHORT $LN2@Insert@6
  0010d	53		 push	 ebx
  0010e	6a 00		 push	 0
  00110	57		 push	 edi
  00111	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  00116	5b		 pop	 ebx
  00117	8b c7		 mov	 eax, edi
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi

; 1181 : 		}

  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Insert@6:

; 1175 : 				else
; 1176 : 					return (_Insert(true, _Next._Mynode(), _Node));

  00121	50		 push	 eax
  00122	6a 01		 push	 1
  00124	57		 push	 edi
  00125	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  0012a	5b		 pop	 ebx
  0012b	8b c7		 mov	 eax, edi
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi

; 1181 : 		}

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c2 0c 00	 ret	 12			; 0000000cH
$LN333@Insert@6:

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00135	6a 00		 push	 0
  00137	57		 push	 edi
  00138	8d 45 f8	 lea	 eax, DWORD PTR $T197830[ebp]
  0013b	50		 push	 eax
  0013c	8b ce		 mov	 ecx, esi
  0013e	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Linsert
  00143	8b 08		 mov	 ecx, DWORD PTR [eax]
  00145	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00148	5b		 pop	 ebx
  00149	5f		 pop	 edi
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
  0014c	5e		 pop	 esi

; 1181 : 		}

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T198483 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T198483[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase

; 1867 : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::insert<std::pair<unsigned long const ,TokenizerSection> >
; Function compile flags: /Ogtp
;	COMDAT ??$insert@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
??$insert@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::insert<std::pair<unsigned long const ,TokenizerSection> >, COMDAT
; _this$ = ecx

; 760  : 		typename _STD tr1::enable_if<!_STD tr1::is_same<const_iterator,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 761  : 			typename _STD tr1::remove_reference<_Valty>::type>::value,
; 762  : 				iterator>::type
; 763  : 		insert(const_iterator _Where,
; 764  : 			_Valty&& _Val)
; 765  : 		{	// try to insert node with value _Val using _Where as a hint
; 766  : 		return (_Insert(_Where,
; 767  : 			this->_Buynode(_STD forward<_Valty>(_Val))));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerSection> >
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00016	50		 push	 eax
  00017	51		 push	 ecx
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  00020	8b c7		 mov	 eax, edi
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 768  : 		}

  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??$insert@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::insert<std::pair<unsigned long const ,TokenizerSection> >
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T198686 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 791  : 		_Tidy();

  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T198686[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase

; 792  : 		}

  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
PUBLIC	??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::operator[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$16
__ehfuncinfo$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	ENDS
;	COMDAT ??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z
_TEXT	SEGMENT
$T198717 = -72						; size = 24
$T198718 = -48						; size = 20
$T199144 = -28						; size = 12
$T199534 = -16						; size = 4
$T198949 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T199803 = 8						; size = 4
$T199476 = 8						; size = 4
$T198720 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z PROC ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::operator[], COMDAT
; _this$ = ecx

; 210  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx

; 211  : 		iterator _Where = this->lower_bound(_Keyval);

  0002a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0002d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00030	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00034	75 1e		 jne	 SHORT $LN11@operator@20

; 212  : 		if (_Where == this->end()
; 213  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00036	8b 4d 08	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003b	eb 03 8d 49 00	 npad	 5
$LL12@operator@20:

; 211  : 		iterator _Where = this->lower_bound(_Keyval);

  00040	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00043	73 05		 jae	 SHORT $LN10@operator@20
  00045	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00048	eb 04		 jmp	 SHORT $LN9@operator@20
$LN10@operator@20:
  0004a	8b f8		 mov	 edi, eax
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@operator@20:
  0004e	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00052	74 ec		 je	 SHORT $LL12@operator@20
$LN11@operator@20:

; 212  : 		if (_Where == this->end()
; 213  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00054	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00057	74 0e		 je	 SHORT $LN1@operator@20
  00059	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0005c	8b 02		 mov	 eax, DWORD PTR [edx]
  0005e	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  00061	0f 83 c4 00 00
	00		 jae	 $LN216@operator@20
$LN1@operator@20:

; 214  : 			_Where = this->insert(_Where,
; 215  : 				value_type(_Keyval, mapped_type()));

  00067	33 db		 xor	 ebx, ebx
  00069	6a 28		 push	 40			; 00000028H
  0006b	89 5d d8	 mov	 DWORD PTR $T198718[ebp+8], ebx
  0006e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00073	83 c4 04	 add	 esp, 4
  00076	3b c3		 cmp	 eax, ebx
  00078	0f 84 c4 00 00
	00		 je	 $LN90@operator@20
  0007e	89 45 d4	 mov	 DWORD PTR $T198718[ebp+4], eax
  00081	89 00		 mov	 DWORD PTR [eax], eax
  00083	8b 45 d4	 mov	 eax, DWORD PTR $T198718[ebp+4]
  00086	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00089	8b 45 d4	 mov	 eax, DWORD PTR $T198718[ebp+4]
  0008c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0008f	8b 4d d4	 mov	 ecx, DWORD PTR $T198718[ebp+4]
  00092	b3 01		 mov	 bl, 1
  00094	88 59 24	 mov	 BYTE PTR [ecx+36], bl
  00097	8b 55 d4	 mov	 edx, DWORD PTR $T198718[ebp+4]
  0009a	88 5a 25	 mov	 BYTE PTR [edx+37], bl
  0009d	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8d 55 d0	 lea	 edx, DWORD PTR $T198718[ebp]
  000a5	89 4d b8	 mov	 DWORD PTR $T198717[ebp], ecx
  000a8	52		 push	 edx
  000a9	8d 4d bc	 lea	 ecx, DWORD PTR $T198717[ebp+4]
  000ac	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000b3	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  000b8	8b 45 e0	 mov	 eax, DWORD PTR $T198718[ebp+16]
  000bb	89 45 cc	 mov	 DWORD PTR $T198717[ebp+20], eax
  000be	8d 4d b8	 lea	 ecx, DWORD PTR $T198717[ebp]
  000c1	51		 push	 ecx
  000c2	8b ce		 mov	 ecx, esi
  000c4	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  000c7	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerSection> >
  000cc	50		 push	 eax
  000cd	57		 push	 edi
  000ce	8d 55 08	 lea	 edx, DWORD PTR $T198720[ebp]
  000d1	52		 push	 edx
  000d2	8b ce		 mov	 ecx, esi
  000d4	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  000d9	8b 7d 08	 mov	 edi, DWORD PTR $T198720[ebp]
  000dc	8d 45 bc	 lea	 eax, DWORD PTR $T198717[ebp+4]
  000df	89 45 08	 mov	 DWORD PTR $T199476[ebp], eax
  000e2	8b 45 c0	 mov	 eax, DWORD PTR $T198717[ebp+8]
  000e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e7	50		 push	 eax
  000e8	51		 push	 ecx
  000e9	8d 4d f0	 lea	 ecx, DWORD PTR $T199534[ebp]
  000ec	51		 push	 ecx
  000ed	8d 4d bc	 lea	 ecx, DWORD PTR $T198717[ebp+4]
  000f0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f4	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  000f9	8b 55 c0	 mov	 edx, DWORD PTR $T198717[ebp+8]
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00102	83 c4 04	 add	 esp, 4
  00105	8b 45 d4	 mov	 eax, DWORD PTR $T198718[ebp+4]
  00108	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010a	50		 push	 eax
  0010b	51		 push	 ecx
  0010c	8d 45 08	 lea	 eax, DWORD PTR $T199803[ebp]
  0010f	50		 push	 eax
  00110	8d 4d d0	 lea	 ecx, DWORD PTR $T198718[ebp]
  00113	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  0011a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  0011f	8b 4d d4	 mov	 ecx, DWORD PTR $T198718[ebp+4]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00128	83 c4 04	 add	 esp, 4
$LN216@operator@20:

; 216  : 		return ((*_Where).second);

  0012b	8d 47 10	 lea	 eax, DWORD PTR [edi+16]

; 217  : 		}

  0012e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00131	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00138	59		 pop	 ecx
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 04 00	 ret	 4

; 214  : 			_Where = this->insert(_Where,
; 215  : 				value_type(_Keyval, mapped_type()));

$LN90@operator@20:
  00142	8d 55 f0	 lea	 edx, DWORD PTR $T198949[ebp]
  00145	52		 push	 edx
  00146	8d 4d e4	 lea	 ecx, DWORD PTR $T199144[ebp]
  00149	89 5d f0	 mov	 DWORD PTR $T198949[ebp], ebx
  0014c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00151	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00156	8d 45 e4	 lea	 eax, DWORD PTR $T199144[ebp]
  00159	50		 push	 eax
  0015a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T199144[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00161	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN229@operator@20:
$LN228@operator@20:
  00166	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR $T198718[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TokenizerSection@@QAE@XZ
__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$1:
  00008	8d 4d b8	 lea	 ecx, DWORD PTR $T198717[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ
__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$13:
  00010	8b 4d 08	 mov	 ecx, DWORD PTR $T199476[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$16:
  00018	8d 4d d0	 lea	 ecx, DWORD PTR $T198718[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z:
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z ENDP ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::operator[]
PUBLIC	??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::~map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T199989 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::~map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T199989[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
__ehhandler$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::~map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >
PUBLIC	??0?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T200178 = -16						; size = 12
$T200070 = -4						; size = 4
??0?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN25@map@3
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 107  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0

; 106  : 		{	// construct empty map from defaults

$LN25@map@3:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T200070[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T200178[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T200070[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T200178[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T200178[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@map@3:
$LN48@map@3:
  0006c	cc		 int	 3
??0?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >
_TEXT	ENDS
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_02CBLDBPFN@?1?1?$AA@			; `string'
PUBLIC	_tok$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z ; Tokenizer::ParseFile
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CBLDBPFN@?1?1?$AA@
CONST	SEGMENT
??_C@_02CBLDBPFN@?1?1?$AA@ DB '//', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$14
	DD	03H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$21
	DD	01H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$24
	DD	07H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$31
	DD	03H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$34
	DD	03H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$37
	DD	01H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$40
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\tokenizer.h
xdata$x	ENDS
;	COMDAT ?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z
_TEXT	SEGMENT
_f$ = -4496						; size = 184
$T204568 = -4312					; size = 4
$T204127 = -4308					; size = 12
$T202930 = -4296					; size = 12
$T202302 = -4284					; size = 4
$T200491 = -4280					; size = 12
$T205098 = -4268					; size = 4
$T204835 = -4264					; size = 4
$T204318 = -4260					; size = 4
_this$ = -4256						; size = 4
_tok$GSCopy$ = -4252					; size = 4
$T200295 = -4248					; size = 4
_it$203866 = -4244					; size = 4
$T202727 = -4240					; size = 4
$T203932 = -4236					; size = 4
_current_sec$144173 = -4232				; size = 4
_row$144309 = -4228					; size = 20
_sec_index$144174 = -4208				; size = 4
_sec$144171 = -4204					; size = 20
$T205680 = -4184					; size = 4
$T205348 = -4184					; size = 4
$T203592 = -4184					; size = 4
$T203260 = -4184					; size = 4
$T201692 = -4184					; size = 4
$T203884 = -4180					; size = 4
$T200204 = -4180					; size = 4
$T200201 = -4180					; size = 4
$T200200 = -4180					; size = 4
$T200937 = -4176					; size = 1
_sec_open$144175 = -4169				; size = 1
$T144289 = -4168					; size = 28
$T144195 = -4168					; size = 28
$T200203 = -4160					; size = 20
_line$144181 = -4140					; size = 28
_temp$144179 = -4112					; size = 4096
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_file$ = 8						; size = 28
_tok$ = 36						; size = 4
?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z PROC ; Tokenizer::ParseFile, COMDAT
; _this$ = ecx

; 175  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 84 11 00 00	 mov	 eax, 4484		; 00001184H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	89 8d 60 ef ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00038	8b 45 24	 mov	 eax, DWORD PTR _tok$[ebp]

; 231  : 					}
; 232  : 
; 233  : 					if(line.substr(0, 2) == "//") continue;

  0003b	89 85 64 ef ff
	ff		 mov	 DWORD PTR _tok$GSCopy$[ebp], eax
  00041	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00044	33 f6		 xor	 esi, esi
  00046	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  0004b	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  0004e	39 7d 1c	 cmp	 DWORD PTR _file$[ebp+20], edi
  00051	73 03		 jae	 SHORT $LN40@ParseFile

; 176  : 
; 177  : 		std::fstream f(file.c_str(), std::ios::in);

  00053	8d 45 08	 lea	 eax, DWORD PTR _file$[ebp]
$LN40@ParseFile:
  00056	6a 01		 push	 1
  00058	6a 40		 push	 64			; 00000040H
  0005a	6a 01		 push	 1
  0005c	50		 push	 eax
  0005d	8d 8d 70 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp]
  00063	e8 00 00 00 00	 call	 ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
  00068	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 178  : 
; 179  : 		if(f.is_open())

  0006c	39 b5 dc ee ff
	ff		 cmp	 DWORD PTR _f$[ebp+108], esi
  00072	0f 84 9f 0b 00
	00		 je	 $LN23@ParseFile

; 180  : 		{
; 181  : 
; 182  : 			if(f.good())

  00078	8b 8d 70 ee ff
	ff		 mov	 ecx, DWORD PTR _f$[ebp]
  0007e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00081	39 b4 15 7c ee
	ff ff		 cmp	 DWORD PTR _f$[ebp+edx+12], esi
  00088	0f 85 1e 0b 00
	00		 jne	 $LN22@ParseFile

; 183  : 			{
; 184  : 
; 185  : 				TokenizerSection sec = TokenizerSection();

  0008e	6a 28		 push	 40			; 00000028H
  00090	89 b5 9c ef ff
	ff		 mov	 DWORD PTR _sec$144171[ebp+8], esi
  00096	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009b	83 c4 04	 add	 esp, 4
  0009e	3b c6		 cmp	 eax, esi
  000a0	0f 84 d3 0a 00
	00		 je	 $LN76@ParseFile
  000a6	89 85 98 ef ff
	ff		 mov	 DWORD PTR _sec$144171[ebp+4], eax
  000ac	89 00		 mov	 DWORD PTR [eax], eax
  000ae	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  000b4	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000b7	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  000bd	89 40 08	 mov	 DWORD PTR [eax+8], eax
  000c0	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  000c6	c6 40 24 01	 mov	 BYTE PTR [eax+36], 1
  000ca	8b 8d 98 ef ff
	ff		 mov	 ecx, DWORD PTR _sec$144171[ebp+4]
  000d0	c6 41 25 01	 mov	 BYTE PTR [ecx+37], 1

; 186  : 				int current_sec = 0;
; 187  : 				int sec_index = 0;
; 188  : 				bool sec_open = false;
; 189  : 
; 190  : 				while(!f.eof())

  000d4	8b 95 70 ee ff
	ff		 mov	 edx, DWORD PTR _f$[ebp]
  000da	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000dd	8b 84 05 7c ee
	ff ff		 mov	 eax, DWORD PTR _f$[ebp+eax+12]
  000e4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000e8	89 b5 78 ef ff
	ff		 mov	 DWORD PTR _current_sec$144173[ebp], esi
  000ee	89 b5 90 ef ff
	ff		 mov	 DWORD PTR _sec_index$144174[ebp], esi
  000f4	c6 85 b7 ef ff
	ff 00		 mov	 BYTE PTR _sec_open$144175[ebp], 0
  000fb	a8 01		 test	 al, 1
  000fd	0f 85 f8 07 00
	00		 jne	 $LN20@ParseFile

; 226  : 
; 227  : 					std::string::size_type k = 0;
; 228  : 					while((k=line.find(13,k))!=line.npos) 

  00103	c6 85 b0 ef ff
	ff 0d		 mov	 BYTE PTR $T200937[ebp], 13 ; 0000000dH
  0010a	8d 9b 00 00 00
	00		 npad	 6
$LL21@ParseFile:

; 191  : 				{
; 192  : 
; 193  : 					char temp[4096];
; 194  : 					char* dump = NULL;
; 195  : 					std::string line = "";

  00110	6a 00		 push	 0
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00117	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  0011d	c7 85 e8 ef ff
	ff 0f 00 00 00	 mov	 DWORD PTR _line$144181[ebp+20], 15 ; 0000000fH
  00127	c7 85 e4 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _line$144181[ebp+16], 0
  00131	c6 85 d4 ef ff
	ff 00		 mov	 BYTE PTR _line$144181[ebp], 0
  00138	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 196  : 
; 197  : 					ZeroMemory(&temp[0], 4096);

  0013d	68 00 10 00 00	 push	 4096			; 00001000H
  00142	8d 8d f0 ef ff
	ff		 lea	 ecx, DWORD PTR _temp$144179[ebp]
  00148	6a 00		 push	 0
  0014a	51		 push	 ecx
  0014b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0014f	e8 00 00 00 00	 call	 _memset

; 198  : 
; 199  : 					f.getline(&temp[0], 4095);

  00154	8b 95 70 ee ff
	ff		 mov	 edx, DWORD PTR _f$[ebp]
  0015a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	6a 0a		 push	 10			; 0000000aH
  00162	8d 8c 0d 70 ee
	ff ff		 lea	 ecx, DWORD PTR _f$[ebp+ecx]
  00169	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
  0016e	0f b6 c0	 movzx	 eax, al
  00171	50		 push	 eax
  00172	6a 00		 push	 0
  00174	68 ff 0f 00 00	 push	 4095			; 00000fffH
  00179	8d 8d f0 ef ff
	ff		 lea	 ecx, DWORD PTR _temp$144179[ebp]
  0017f	51		 push	 ecx
  00180	8d 8d 70 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp]
  00186	e8 00 00 00 00	 call	 ?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z ; std::basic_istream<char,std::char_traits<char> >::getline

; 200  : 					line.assign(&temp[0]);

  0018b	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _temp$144179[ebp]
  00191	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL1332@ParseFile:
  00194	8a 08		 mov	 cl, BYTE PTR [eax]
  00196	40		 inc	 eax
  00197	84 c9		 test	 cl, cl
  00199	75 f9		 jne	 SHORT $LL1332@ParseFile
  0019b	2b c2		 sub	 eax, edx
  0019d	50		 push	 eax
  0019e	8d 95 f0 ef ff
	ff		 lea	 edx, DWORD PTR _temp$144179[ebp]
  001a4	52		 push	 edx
  001a5	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  001ab	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 201  : 
; 202  : 					dump = (char*)line.c_str();

  001b0	83 bd e8 ef ff
	ff 10		 cmp	 DWORD PTR _line$144181[ebp+20], 16 ; 00000010H
  001b7	8b bd d4 ef ff
	ff		 mov	 edi, DWORD PTR _line$144181[ebp]
  001bd	73 06		 jae	 SHORT $LN145@ParseFile
  001bf	8d bd d4 ef ff
	ff		 lea	 edi, DWORD PTR _line$144181[ebp]
$LN145@ParseFile:

; 203  : 
; 204  : 					int start = 0;
; 205  : 					int end = 0;
; 206  : 
; 207  : 					for(DWORD i = 0; i < line.length(); i++)

  001c5	8b 95 e4 ef ff
	ff		 mov	 edx, DWORD PTR _line$144181[ebp+16]
  001cb	33 f6		 xor	 esi, esi
  001cd	33 db		 xor	 ebx, ebx
  001cf	33 c0		 xor	 eax, eax
  001d1	85 d2		 test	 edx, edx
  001d3	74 13		 je	 SHORT $LN1307@ParseFile
$LL19@ParseFile:

; 208  : 					{
; 209  : 						if(dump[i] != ' ' && dump[i] != '\t')

  001d5	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  001d8	80 f9 20	 cmp	 cl, 32			; 00000020H
  001db	74 05		 je	 SHORT $LN16@ParseFile
  001dd	80 f9 09	 cmp	 cl, 9
  001e0	75 06		 jne	 SHORT $LN1307@ParseFile
$LN16@ParseFile:

; 203  : 
; 204  : 					int start = 0;
; 205  : 					int end = 0;
; 206  : 
; 207  : 					for(DWORD i = 0; i < line.length(); i++)

  001e2	40		 inc	 eax

; 210  : 						{
; 211  : 							break;
; 212  : 						}
; 213  : 						start++;

  001e3	46		 inc	 esi
  001e4	3b c2		 cmp	 eax, edx
  001e6	72 ed		 jb	 SHORT $LL19@ParseFile
$LN1307@ParseFile:

; 214  : 					}
; 215  : 
; 216  : 					for(DWORD i = line.length()-1; i > 0; i--) // warning C6295: Ill-defined for-loop Arrumado

  001e8	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]
  001eb	85 c9		 test	 ecx, ecx
  001ed	74 10		 je	 SHORT $LN1308@ParseFile
  001ef	90		 npad	 1
$LL15@ParseFile:

; 217  : 					{
; 218  : 						if(dump[i] != ' ' && dump[i] != '\t')

  001f0	8a 04 39	 mov	 al, BYTE PTR [ecx+edi]
  001f3	3c 20		 cmp	 al, 32			; 00000020H
  001f5	74 04		 je	 SHORT $LN12@ParseFile
  001f7	3c 09		 cmp	 al, 9
  001f9	75 04		 jne	 SHORT $LN1308@ParseFile
$LN12@ParseFile:

; 219  : 						{
; 220  : 							break;
; 221  : 						}
; 222  : 						end++;

  001fb	43		 inc	 ebx
  001fc	49		 dec	 ecx
  001fd	75 f1		 jne	 SHORT $LL15@ParseFile
$LN1308@ParseFile:

; 223  : 					}
; 224  : 
; 225  : 					line = line.substr(start, line.length() - end - start);

  001ff	2b d3		 sub	 edx, ebx
  00201	2b d6		 sub	 edx, esi
  00203	52		 push	 edx
  00204	56		 push	 esi
  00205	8d 85 b8 ef ff
	ff		 lea	 eax, DWORD PTR $T144195[ebp]
  0020b	50		 push	 eax
  0020c	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  00212	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  00217	8b f0		 mov	 esi, eax
  00219	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  0021f	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
  00224	3b ce		 cmp	 ecx, esi
  00226	74 70		 je	 SHORT $LN1336@ParseFile
  00228	39 9d e8 ef ff
	ff		 cmp	 DWORD PTR _line$144181[ebp+20], ebx
  0022e	72 0f		 jb	 SHORT $LN188@ParseFile
  00230	8b 95 d4 ef ff
	ff		 mov	 edx, DWORD PTR _line$144181[ebp]
  00236	52		 push	 edx
  00237	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0023c	83 c4 04	 add	 esp, 4
$LN188@ParseFile:
  0023f	33 ff		 xor	 edi, edi
  00241	c7 85 e8 ef ff
	ff 0f 00 00 00	 mov	 DWORD PTR _line$144181[ebp+20], 15 ; 0000000fH
  0024b	89 bd e4 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+16], edi
  00251	c6 85 d4 ef ff
	ff 00		 mov	 BYTE PTR _line$144181[ebp], 0
  00258	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  0025b	73 17		 jae	 SHORT $LN157@ParseFile
  0025d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00260	40		 inc	 eax
  00261	50		 push	 eax
  00262	8d 85 d4 ef ff
	ff		 lea	 eax, DWORD PTR _line$144181[ebp]
  00268	56		 push	 esi
  00269	50		 push	 eax
  0026a	e8 00 00 00 00	 call	 _memmove
  0026f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00272	eb 0a		 jmp	 SHORT $LN156@ParseFile
$LN157@ParseFile:
  00274	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00276	89 8d d4 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp], ecx
  0027c	89 3e		 mov	 DWORD PTR [esi], edi
$LN156@ParseFile:
  0027e	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00281	89 95 e4 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+16], edx
  00287	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0028a	89 85 e8 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+20], eax
  00290	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00293	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00296	eb 02		 jmp	 SHORT $LN158@ParseFile
$LN1336@ParseFile:
  00298	33 ff		 xor	 edi, edi
$LN158@ParseFile:
  0029a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0029e	39 9d cc ef ff
	ff		 cmp	 DWORD PTR $T144195[ebp+20], ebx
  002a4	72 0f		 jb	 SHORT $LN210@ParseFile
  002a6	8b 8d b8 ef ff
	ff		 mov	 ecx, DWORD PTR $T144195[ebp]
  002ac	51		 push	 ecx
  002ad	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002b2	83 c4 04	 add	 esp, 4
$LN210@ParseFile:

; 226  : 
; 227  : 					std::string::size_type k = 0;
; 228  : 					while((k=line.find(13,k))!=line.npos) 

  002b5	6a 01		 push	 1
  002b7	57		 push	 edi
  002b8	8d 95 b0 ef ff
	ff		 lea	 edx, DWORD PTR $T200937[ebp]
  002be	52		 push	 edx
  002bf	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  002c5	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  002ca	8b f0		 mov	 esi, eax
  002cc	83 fe ff	 cmp	 esi, -1
  002cf	0f 84 a7 00 00
	00		 je	 $LN10@ParseFile
  002d5	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL11@ParseFile:

; 229  : 					{
; 230  : 						line.erase(k, 1);

  002e0	8b 85 e4 ef ff
	ff		 mov	 eax, DWORD PTR _line$144181[ebp+16]
  002e6	bf 01 00 00 00	 mov	 edi, 1
  002eb	3b c6		 cmp	 eax, esi
  002ed	0f 82 b3 06 00
	00		 jb	 $LN1309@ParseFile
  002f3	8b c8		 mov	 ecx, eax
  002f5	2b ce		 sub	 ecx, esi
  002f7	3b cf		 cmp	 ecx, edi
  002f9	73 06		 jae	 SHORT $LN1329@ParseFile
  002fb	8b f9		 mov	 edi, ecx
  002fd	85 ff		 test	 edi, edi
  002ff	74 5b		 je	 SHORT $LN248@ParseFile
$LN1329@ParseFile:
  00301	8b 8d e8 ef ff
	ff		 mov	 ecx, DWORD PTR _line$144181[ebp+20]
  00307	8b 9d d4 ef ff
	ff		 mov	 ebx, DWORD PTR _line$144181[ebp]
  0030d	8b d3		 mov	 edx, ebx
  0030f	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00312	0f 83 99 00 00
	00		 jae	 $LN1349@ParseFile
  00318	8d 95 d4 ef ff
	ff		 lea	 edx, DWORD PTR _line$144181[ebp]
  0031e	8b ca		 mov	 ecx, edx
$LN239@ParseFile:
  00320	2b c7		 sub	 eax, edi
  00322	2b c6		 sub	 eax, esi
  00324	03 d7		 add	 edx, edi
  00326	50		 push	 eax
  00327	03 d6		 add	 edx, esi
  00329	52		 push	 edx
  0032a	03 ce		 add	 ecx, esi
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 _memmove
  00332	8b 85 e4 ef ff
	ff		 mov	 eax, DWORD PTR _line$144181[ebp+16]
  00338	8b 8d d4 ef ff
	ff		 mov	 ecx, DWORD PTR _line$144181[ebp]
  0033e	2b c7		 sub	 eax, edi
  00340	83 c4 0c	 add	 esp, 12			; 0000000cH
  00343	83 bd e8 ef ff
	ff 10		 cmp	 DWORD PTR _line$144181[ebp+20], 16 ; 00000010H
  0034a	89 85 e4 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+16], eax
  00350	73 06		 jae	 SHORT $LN247@ParseFile
  00352	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
$LN247@ParseFile:
  00358	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
$LN248@ParseFile:

; 226  : 
; 227  : 					std::string::size_type k = 0;
; 228  : 					while((k=line.find(13,k))!=line.npos) 

  0035c	6a 01		 push	 1
  0035e	56		 push	 esi
  0035f	8d 85 b0 ef ff
	ff		 lea	 eax, DWORD PTR $T200937[ebp]
  00365	50		 push	 eax
  00366	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  0036c	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00371	8b f0		 mov	 esi, eax
  00373	83 fe ff	 cmp	 esi, -1
  00376	0f 85 64 ff ff
	ff		 jne	 $LL11@ParseFile
$LN10@ParseFile:

; 231  : 					}
; 232  : 
; 233  : 					if(line.substr(0, 2) == "//") continue;

  0037c	6a 02		 push	 2
  0037e	6a 00		 push	 0
  00380	8d 8d b8 ef ff
	ff		 lea	 ecx, DWORD PTR $T144289[ebp]
  00386	51		 push	 ecx
  00387	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  0038d	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  00392	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  00395	8b cf		 mov	 ecx, edi
  00397	3b cf		 cmp	 ecx, edi
  00399	73 00		 jae	 SHORT $LN256@ParseFile
$LN256@ParseFile:
  0039b	8b d7		 mov	 edx, edi
  0039d	83 ff 02	 cmp	 edi, 2
  003a0	72 05		 jb	 SHORT $LN261@ParseFile
  003a2	ba 02 00 00 00	 mov	 edx, 2
$LN261@ParseFile:
  003a7	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  003ab	72 0b		 jb	 SHORT $LN271@ParseFile
  003ad	8b 30		 mov	 esi, DWORD PTR [eax]
  003af	eb 09		 jmp	 SHORT $LN272@ParseFile
$LN1349@ParseFile:

; 229  : 					{
; 230  : 						line.erase(k, 1);

  003b1	8b cb		 mov	 ecx, ebx
  003b3	e9 68 ff ff ff	 jmp	 $LN239@ParseFile

; 231  : 					}
; 232  : 
; 233  : 					if(line.substr(0, 2) == "//") continue;

$LN271@ParseFile:
  003b8	8b f0		 mov	 esi, eax
$LN272@ParseFile:
  003ba	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02CBLDBPFN@?1?1?$AA@
  003bf	83 fa 04	 cmp	 edx, 4
  003c2	72 14		 jb	 SHORT $LN1310@ParseFile
$LL276@ParseFile:
  003c4	8b 06		 mov	 eax, DWORD PTR [esi]
  003c6	3b 01		 cmp	 eax, DWORD PTR [ecx]
  003c8	75 12		 jne	 SHORT $LN277@ParseFile
  003ca	83 ea 04	 sub	 edx, 4
  003cd	83 c1 04	 add	 ecx, 4
  003d0	83 c6 04	 add	 esi, 4
  003d3	83 fa 04	 cmp	 edx, 4
  003d6	73 ec		 jae	 SHORT $LL276@ParseFile
$LN1310@ParseFile:
  003d8	85 d2		 test	 edx, edx
  003da	74 43		 je	 SHORT $LN278@ParseFile
$LN277@ParseFile:
  003dc	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  003df	0f b6 19	 movzx	 ebx, BYTE PTR [ecx]
  003e2	2b c3		 sub	 eax, ebx
  003e4	75 31		 jne	 SHORT $LN279@ParseFile
  003e6	83 fa 01	 cmp	 edx, 1
  003e9	76 34		 jbe	 SHORT $LN278@ParseFile
  003eb	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  003ef	0f b6 59 01	 movzx	 ebx, BYTE PTR [ecx+1]
  003f3	2b c3		 sub	 eax, ebx
  003f5	75 20		 jne	 SHORT $LN279@ParseFile
  003f7	83 fa 02	 cmp	 edx, 2
  003fa	76 23		 jbe	 SHORT $LN278@ParseFile
  003fc	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00400	0f b6 59 02	 movzx	 ebx, BYTE PTR [ecx+2]
  00404	2b c3		 sub	 eax, ebx
  00406	75 0f		 jne	 SHORT $LN279@ParseFile
  00408	83 fa 03	 cmp	 edx, 3
  0040b	76 12		 jbe	 SHORT $LN278@ParseFile
  0040d	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00411	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00415	2b c1		 sub	 eax, ecx
$LN279@ParseFile:
  00417	c1 f8 1f	 sar	 eax, 31			; 0000001fH
  0041a	83 c8 01	 or	 eax, 1
  0041d	eb 02		 jmp	 SHORT $LN280@ParseFile
$LN278@ParseFile:
  0041f	33 c0		 xor	 eax, eax
$LN280@ParseFile:
  00421	85 c0		 test	 eax, eax
  00423	75 12		 jne	 SHORT $LN263@ParseFile
  00425	83 ff 02	 cmp	 edi, 2
  00428	73 05		 jae	 SHORT $LN262@ParseFile
  0042a	83 c8 ff	 or	 eax, -1
  0042d	eb 08		 jmp	 SHORT $LN263@ParseFile
$LN262@ParseFile:
  0042f	33 c0		 xor	 eax, eax
  00431	83 ff 02	 cmp	 edi, 2
  00434	0f 95 c0	 setne	 al
$LN263@ParseFile:
  00437	33 ff		 xor	 edi, edi
  00439	3b c7		 cmp	 eax, edi
  0043b	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  00440	0f 94 c3	 sete	 bl
  00443	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00447	39 b5 cc ef ff
	ff		 cmp	 DWORD PTR $T144289[ebp+20], esi
  0044d	72 0f		 jb	 SHORT $LN293@ParseFile
  0044f	8b 95 b8 ef ff
	ff		 mov	 edx, DWORD PTR $T144289[ebp]
  00455	52		 push	 edx
  00456	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0045b	83 c4 04	 add	 esp, 4
$LN293@ParseFile:
  0045e	84 db		 test	 bl, bl
  00460	74 1c		 je	 SHORT $LN9@ParseFile
  00462	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00466	39 b5 e8 ef ff
	ff		 cmp	 DWORD PTR _line$144181[ebp+20], esi
  0046c	0f 82 6b 04 00
	00		 jb	 $LN1129@ParseFile
  00472	8b 85 d4 ef ff
	ff		 mov	 eax, DWORD PTR _line$144181[ebp]
  00478	50		 push	 eax
  00479	e9 57 04 00 00	 jmp	 $LN1350@ParseFile
$LN9@ParseFile:

; 234  : 
; 235  : 					if(line.compare("end") == false)

  0047e	8b 9d e4 ef ff
	ff		 mov	 ebx, DWORD PTR _line$144181[ebp+16]
  00484	8b d3		 mov	 edx, ebx
  00486	83 fb 03	 cmp	 ebx, 3
  00489	72 05		 jb	 SHORT $LN336@ParseFile
  0048b	ba 03 00 00 00	 mov	 edx, 3
$LN336@ParseFile:
  00490	39 b5 e8 ef ff
	ff		 cmp	 DWORD PTR _line$144181[ebp+20], esi
  00496	8b b5 d4 ef ff
	ff		 mov	 esi, DWORD PTR _line$144181[ebp]
  0049c	73 06		 jae	 SHORT $LN347@ParseFile
  0049e	8d b5 d4 ef ff
	ff		 lea	 esi, DWORD PTR _line$144181[ebp]
$LN347@ParseFile:
  004a4	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  004a9	83 fa 04	 cmp	 edx, 4
  004ac	72 16		 jb	 SHORT $LN1311@ParseFile
  004ae	8b ff		 npad	 2
$LL351@ParseFile:
  004b0	8b 06		 mov	 eax, DWORD PTR [esi]
  004b2	3b 01		 cmp	 eax, DWORD PTR [ecx]
  004b4	75 12		 jne	 SHORT $LN352@ParseFile
  004b6	83 ea 04	 sub	 edx, 4
  004b9	83 c1 04	 add	 ecx, 4
  004bc	83 c6 04	 add	 esi, 4
  004bf	83 fa 04	 cmp	 edx, 4
  004c2	73 ec		 jae	 SHORT $LL351@ParseFile
$LN1311@ParseFile:
  004c4	3b d7		 cmp	 edx, edi
  004c6	74 47		 je	 SHORT $LN353@ParseFile
$LN352@ParseFile:
  004c8	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  004cb	0f b6 39	 movzx	 edi, BYTE PTR [ecx]
  004ce	2b c7		 sub	 eax, edi
  004d0	75 31		 jne	 SHORT $LN354@ParseFile
  004d2	83 fa 01	 cmp	 edx, 1
  004d5	76 36		 jbe	 SHORT $LN1345@ParseFile
  004d7	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  004db	0f b6 79 01	 movzx	 edi, BYTE PTR [ecx+1]
  004df	2b c7		 sub	 eax, edi
  004e1	75 20		 jne	 SHORT $LN354@ParseFile
  004e3	83 fa 02	 cmp	 edx, 2
  004e6	76 25		 jbe	 SHORT $LN1345@ParseFile
  004e8	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  004ec	0f b6 79 02	 movzx	 edi, BYTE PTR [ecx+2]
  004f0	2b c7		 sub	 eax, edi
  004f2	75 0f		 jne	 SHORT $LN354@ParseFile
  004f4	83 fa 03	 cmp	 edx, 3
  004f7	76 14		 jbe	 SHORT $LN1345@ParseFile
  004f9	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  004fd	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00501	2b c1		 sub	 eax, ecx
$LN354@ParseFile:
  00503	c1 f8 1f	 sar	 eax, 31			; 0000001fH
  00506	83 c8 01	 or	 eax, 1
  00509	33 ff		 xor	 edi, edi
  0050b	eb 04		 jmp	 SHORT $LN355@ParseFile
$LN1345@ParseFile:
  0050d	33 ff		 xor	 edi, edi
$LN353@ParseFile:
  0050f	33 c0		 xor	 eax, eax
$LN355@ParseFile:
  00511	3b c7		 cmp	 eax, edi
  00513	0f 85 06 01 00
	00		 jne	 $LN8@ParseFile
  00519	83 fb 03	 cmp	 ebx, 3
  0051c	0f 82 fd 00 00
	00		 jb	 $LN8@ParseFile
  00522	33 c0		 xor	 eax, eax
  00524	83 fb 03	 cmp	 ebx, 3
  00527	0f 95 c0	 setne	 al
  0052a	3b c7		 cmp	 eax, edi
  0052c	0f 85 ed 00 00
	00		 jne	 $LN8@ParseFile

; 236  : 					{
; 237  : 						if(sec_open == false) 

  00532	80 bd b7 ef ff
	ff 00		 cmp	 BYTE PTR _sec_open$144175[ebp], 0
  00539	0f 84 71 04 00
	00		 je	 $LN1315@ParseFile

; 240  : 						}
; 241  : 						sec_open = false;
; 242  : 						sec.RowCount = sec_index;

  0053f	8b 95 90 ef ff
	ff		 mov	 edx, DWORD PTR _sec_index$144174[ebp]

; 243  : 						tok.Sections[current_sec] = sec;

  00545	8b 85 78 ef ff
	ff		 mov	 eax, DWORD PTR _current_sec$144173[ebp]
  0054b	8d 8d ac ef ff
	ff		 lea	 ecx, DWORD PTR $T200200[ebp]
  00551	51		 push	 ecx
  00552	8b 8d 64 ef ff
	ff		 mov	 ecx, DWORD PTR _tok$GSCopy$[ebp]
  00558	c6 85 b7 ef ff
	ff 00		 mov	 BYTE PTR _sec_open$144175[ebp], 0
  0055f	89 95 a4 ef ff
	ff		 mov	 DWORD PTR _sec$144171[ebp+16], edx
  00565	89 85 ac ef ff
	ff		 mov	 DWORD PTR $T200200[ebp], eax
  0056b	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::operator[]
  00570	8b f0		 mov	 esi, eax
  00572	8d 95 94 ef ff
	ff		 lea	 edx, DWORD PTR _sec$144171[ebp]
  00578	3b f2		 cmp	 esi, edx
  0057a	74 7d		 je	 SHORT $LN478@ParseFile
  0057c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0057f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00581	50		 push	 eax
  00582	51		 push	 ecx
  00583	8d 85 44 ef ff
	ff		 lea	 eax, DWORD PTR $T202302[ebp]
  00589	50		 push	 eax
  0058a	8b ce		 mov	 ecx, esi
  0058c	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00591	8b 8d 98 ef ff
	ff		 mov	 ecx, DWORD PTR _sec$144171[ebp+4]
  00597	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0059a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0059d	57		 push	 edi
  0059e	52		 push	 edx
  0059f	8b ce		 mov	 ecx, esi
  005a1	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
  005a6	89 47 04	 mov	 DWORD PTR [edi+4], eax
  005a9	8b 85 9c ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+8]
  005af	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  005b2	89 46 08	 mov	 DWORD PTR [esi+8], eax
  005b5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  005b8	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  005bc	75 33		 jne	 SHORT $LN479@ParseFile
  005be	8b 08		 mov	 ecx, DWORD PTR [eax]
  005c0	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  005c4	75 0a		 jne	 SHORT $LN502@ParseFile
$LL503@ParseFile:
  005c6	8b c1		 mov	 eax, ecx
  005c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  005ca	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  005ce	74 f6		 je	 SHORT $LL503@ParseFile
$LN502@ParseFile:
  005d0	89 02		 mov	 DWORD PTR [edx], eax
  005d2	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  005d5	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  005d8	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  005db	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  005df	75 0b		 jne	 SHORT $LN520@ParseFile
$LL521@ParseFile:
  005e1	8b c8		 mov	 ecx, eax
  005e3	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  005e6	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  005ea	74 f5		 je	 SHORT $LL521@ParseFile
$LN520@ParseFile:
  005ec	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  005ef	eb 08		 jmp	 SHORT $LN478@ParseFile
$LN479@ParseFile:
  005f1	89 12		 mov	 DWORD PTR [edx], edx
  005f3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  005f6	89 40 08	 mov	 DWORD PTR [eax+8], eax
$LN478@ParseFile:
  005f9	8b 8d a4 ef ff
	ff		 mov	 ecx, DWORD PTR _sec$144171[ebp+16]
  005ff	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
$LN1352@ParseFile:

; 244  : 						continue;

  00602	83 bd e8 ef ff
	ff 10		 cmp	 DWORD PTR _line$144181[ebp+20], 16 ; 00000010H
  00609	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0060d	0f 82 ca 02 00
	00		 jb	 $LN1129@ParseFile
  00613	8b 95 d4 ef ff
	ff		 mov	 edx, DWORD PTR _line$144181[ebp]
  00619	52		 push	 edx
  0061a	e9 b6 02 00 00	 jmp	 $LN1350@ParseFile
$LN8@ParseFile:

; 245  : 					}
; 246  : 					
; 247  : 					if(line == "") continue;

  0061f	33 c0		 xor	 eax, eax
  00621	3b df		 cmp	 ebx, edi
  00623	0f 95 c0	 setne	 al
  00626	3b c7		 cmp	 eax, edi
  00628	0f 94 c0	 sete	 al
  0062b	84 c0		 test	 al, al
  0062d	74 1d		 je	 SHORT $LN6@ParseFile
  0062f	83 bd e8 ef ff
	ff 10		 cmp	 DWORD PTR _line$144181[ebp+20], 16 ; 00000010H
  00636	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0063a	0f 82 9d 02 00
	00		 jb	 $LN1129@ParseFile
  00640	8b 85 d4 ef ff
	ff		 mov	 eax, DWORD PTR _line$144181[ebp]
  00646	50		 push	 eax
  00647	e9 89 02 00 00	 jmp	 $LN1350@ParseFile
$LN6@ParseFile:

; 248  : 
; 249  : 					TokenizerRow row;

  0064c	6a 30		 push	 48			; 00000030H
  0064e	89 bd 84 ef ff
	ff		 mov	 DWORD PTR _row$144309[ebp+8], edi
  00654	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00659	83 c4 04	 add	 esp, 4
  0065c	3b c7		 cmp	 eax, edi
  0065e	0f 84 e2 04 00
	00		 je	 $LN646@ParseFile
  00664	89 85 80 ef ff
	ff		 mov	 DWORD PTR _row$144309[ebp+4], eax
  0066a	89 00		 mov	 DWORD PTR [eax], eax
  0066c	8b 85 80 ef ff
	ff		 mov	 eax, DWORD PTR _row$144309[ebp+4]
  00672	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00675	8b 85 80 ef ff
	ff		 mov	 eax, DWORD PTR _row$144309[ebp+4]
  0067b	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0067e	8b 8d 80 ef ff
	ff		 mov	 ecx, DWORD PTR _row$144309[ebp+4]
  00684	c6 41 2c 01	 mov	 BYTE PTR [ecx+44], 1
  00688	8b 95 80 ef ff
	ff		 mov	 edx, DWORD PTR _row$144309[ebp+4]
  0068e	c6 42 2d 01	 mov	 BYTE PTR [edx+45], 1

; 250  : 					if(!this->ParseLine(line, row))

  00692	8d 85 7c ef ff
	ff		 lea	 eax, DWORD PTR _row$144309[ebp]
  00698	50		 push	 eax
  00699	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0069c	8b cc		 mov	 ecx, esp
  0069e	89 a5 ac ef ff
	ff		 mov	 DWORD PTR $T200201[ebp], esp
  006a4	6a ff		 push	 -1
  006a6	57		 push	 edi
  006a7	8d 95 d4 ef ff
	ff		 lea	 edx, DWORD PTR _line$144181[ebp]
  006ad	be 0f 00 00 00	 mov	 esi, 15			; 0000000fH
  006b2	89 71 14	 mov	 DWORD PTR [ecx+20], esi
  006b5	89 79 10	 mov	 DWORD PTR [ecx+16], edi
  006b8	52		 push	 edx
  006b9	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  006bd	c6 01 00	 mov	 BYTE PTR [ecx], 0
  006c0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  006c5	8b 8d 60 ef ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006cb	e8 00 00 00 00	 call	 ?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z ; Tokenizer::ParseLine
  006d0	84 c0		 test	 al, al
  006d2	0f 84 74 03 00
	00		 je	 $LN1318@ParseFile

; 252  : 
; 253  : 					if(row.ColumnCount == 1)

  006d8	83 bd 8c ef ff
	ff 01		 cmp	 DWORD PTR _row$144309[ebp+16], 1
  006df	0f 85 50 01 00
	00		 jne	 $LN3@ParseFile

; 254  : 					{
; 255  : 						if(sec_open == false)

  006e5	80 bd b7 ef ff
	ff 00		 cmp	 BYTE PTR _sec_open$144175[ebp], 0
  006ec	0f 85 43 01 00
	00		 jne	 $LN3@ParseFile

; 256  : 						{
; 257  : 							sec_index = 0;
; 258  : 							current_sec = row.GetInt(0, 0);

  006f2	8d 85 ac ef ff
	ff		 lea	 eax, DWORD PTR $T203884[ebp]
  006f8	50		 push	 eax
  006f9	8d 8d 6c ef ff
	ff		 lea	 ecx, DWORD PTR _it$203866[ebp]
  006ff	51		 push	 ecx
  00700	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00706	89 bd 90 ef ff
	ff		 mov	 DWORD PTR _sec_index$144174[ebp], edi
  0070c	89 bd ac ef ff
	ff		 mov	 DWORD PTR $T203884[ebp], edi
  00712	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
  00717	8b 85 6c ef ff
	ff		 mov	 eax, DWORD PTR _it$203866[ebp]
  0071d	3b 85 80 ef ff
	ff		 cmp	 eax, DWORD PTR _row$144309[ebp+4]
  00723	75 08		 jne	 SHORT $LN825@ParseFile
  00725	89 bd 78 ef ff
	ff		 mov	 DWORD PTR _current_sec$144173[ebp], edi
  0072b	eb 1a		 jmp	 SHORT $LN826@ParseFile
$LN825@ParseFile:
  0072d	83 c0 10	 add	 eax, 16			; 00000010H
  00730	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00734	72 02		 jb	 SHORT $LN866@ParseFile
  00736	8b 00		 mov	 eax, DWORD PTR [eax]
$LN866@ParseFile:
  00738	50		 push	 eax
  00739	e8 00 00 00 00	 call	 _atoi
  0073e	83 c4 04	 add	 esp, 4
  00741	89 85 78 ef ff
	ff		 mov	 DWORD PTR _current_sec$144173[ebp], eax
$LN826@ParseFile:

; 259  : 							sec = TokenizerSection();

  00747	6a 28		 push	 40			; 00000028H
  00749	89 bd c8 ef ff
	ff		 mov	 DWORD PTR $T200203[ebp+8], edi
  0074f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00754	83 c4 04	 add	 esp, 4
  00757	3b c7		 cmp	 eax, edi
  00759	0f 84 b4 03 00
	00		 je	 $LN1319@ParseFile
  0075f	89 85 c4 ef ff
	ff		 mov	 DWORD PTR $T200203[ebp+4], eax
  00765	89 00		 mov	 DWORD PTR [eax], eax
  00767	8b 85 c4 ef ff
	ff		 mov	 eax, DWORD PTR $T200203[ebp+4]
  0076d	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00770	8b 85 c4 ef ff
	ff		 mov	 eax, DWORD PTR $T200203[ebp+4]
  00776	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00779	8b 95 c4 ef ff
	ff		 mov	 edx, DWORD PTR $T200203[ebp+4]
  0077f	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1
  00783	8b 85 c4 ef ff
	ff		 mov	 eax, DWORD PTR $T200203[ebp+4]
  00789	c6 40 25 01	 mov	 BYTE PTR [eax+37], 1
  0078d	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  00793	8b 08		 mov	 ecx, DWORD PTR [eax]
  00795	50		 push	 eax
  00796	51		 push	 ecx
  00797	8d 8d 5c ef ff
	ff		 lea	 ecx, DWORD PTR $T204318[ebp]
  0079d	51		 push	 ecx
  0079e	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  007a4	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  007a8	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  007ad	8d 95 c0 ef ff
	ff		 lea	 edx, DWORD PTR $T200203[ebp]
  007b3	52		 push	 edx
  007b4	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  007ba	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
  007bf	8b 85 d0 ef ff
	ff		 mov	 eax, DWORD PTR $T200203[ebp+16]
  007c5	89 85 a4 ef ff
	ff		 mov	 DWORD PTR _sec$144171[ebp+16], eax
  007cb	8b 85 c4 ef ff
	ff		 mov	 eax, DWORD PTR $T200203[ebp+4]
  007d1	8b 08		 mov	 ecx, DWORD PTR [eax]
  007d3	50		 push	 eax
  007d4	51		 push	 ecx
  007d5	8d 8d 28 ef ff
	ff		 lea	 ecx, DWORD PTR $T204568[ebp]
  007db	51		 push	 ecx
  007dc	8d 8d c0 ef ff
	ff		 lea	 ecx, DWORD PTR $T200203[ebp]
  007e2	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  007e6	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  007eb	8b 95 c4 ef ff
	ff		 mov	 edx, DWORD PTR $T200203[ebp+4]
  007f1	52		 push	 edx
  007f2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  007f7	83 c4 04	 add	 esp, 4

; 260  : 							sec_open = true;

  007fa	c6 85 b7 ef ff
	ff 01		 mov	 BYTE PTR _sec_open$144175[ebp], 1

; 261  : 							continue;

  00801	8b 85 80 ef ff
	ff		 mov	 eax, DWORD PTR _row$144309[ebp+4]
  00807	8b 08		 mov	 ecx, DWORD PTR [eax]
  00809	50		 push	 eax
  0080a	51		 push	 ecx
  0080b	8d 85 58 ef ff
	ff		 lea	 eax, DWORD PTR $T204835[ebp]
  00811	50		 push	 eax
  00812	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00818	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  0081c	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00821	8b 8d 80 ef ff
	ff		 mov	 ecx, DWORD PTR _row$144309[ebp+4]
  00827	51		 push	 ecx
  00828	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0082d	83 c4 04	 add	 esp, 4
  00830	e9 cd fd ff ff	 jmp	 $LN1352@ParseFile
$LN3@ParseFile:

; 262  : 						}
; 263  : 					}
; 264  : 
; 265  : 					sec.Rows[sec_index++] = row;

  00835	8b 85 90 ef ff
	ff		 mov	 eax, DWORD PTR _sec_index$144174[ebp]
  0083b	89 85 ac ef ff
	ff		 mov	 DWORD PTR $T200204[ebp], eax
  00841	40		 inc	 eax
  00842	89 85 90 ef ff
	ff		 mov	 DWORD PTR _sec_index$144174[ebp], eax
  00848	8d 85 ac ef ff
	ff		 lea	 eax, DWORD PTR $T200204[ebp]
  0084e	50		 push	 eax
  0084f	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  00855	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  0085a	8b f0		 mov	 esi, eax
  0085c	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00862	3b f1		 cmp	 esi, ecx
  00864	74 23		 je	 SHORT $LN1053@ParseFile
  00866	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00869	8b 08		 mov	 ecx, DWORD PTR [eax]
  0086b	50		 push	 eax
  0086c	51		 push	 ecx
  0086d	8d 95 54 ef ff
	ff		 lea	 edx, DWORD PTR $T205098[ebp]
  00873	52		 push	 edx
  00874	8b ce		 mov	 ecx, esi
  00876	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  0087b	8d 85 7c ef ff
	ff		 lea	 eax, DWORD PTR _row$144309[ebp]
  00881	50		 push	 eax
  00882	8b ce		 mov	 ecx, esi
  00884	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
$LN1053@ParseFile:
  00889	8b 8d 8c ef ff
	ff		 mov	 ecx, DWORD PTR _row$144309[ebp+16]
  0088f	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 266  : 
; 267  : 				}

  00892	8b 85 80 ef ff
	ff		 mov	 eax, DWORD PTR _row$144309[ebp+4]
  00898	8b 08		 mov	 ecx, DWORD PTR [eax]
  0089a	50		 push	 eax
  0089b	51		 push	 ecx
  0089c	8d 95 a8 ef ff
	ff		 lea	 edx, DWORD PTR $T205348[ebp]
  008a2	52		 push	 edx
  008a3	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  008a9	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  008ad	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  008b2	8b 85 80 ef ff
	ff		 mov	 eax, DWORD PTR _row$144309[ebp+4]
  008b8	50		 push	 eax
  008b9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  008be	83 c4 04	 add	 esp, 4
  008c1	83 bd e8 ef ff
	ff 10		 cmp	 DWORD PTR _line$144181[ebp+20], 16 ; 00000010H
  008c8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  008cc	72 0f		 jb	 SHORT $LN1129@ParseFile
  008ce	8b 8d d4 ef ff
	ff		 mov	 ecx, DWORD PTR _line$144181[ebp]
  008d4	51		 push	 ecx
$LN1350@ParseFile:
  008d5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  008da	83 c4 04	 add	 esp, 4
$LN1129@ParseFile:

; 186  : 				int current_sec = 0;
; 187  : 				int sec_index = 0;
; 188  : 				bool sec_open = false;
; 189  : 
; 190  : 				while(!f.eof())

  008dd	8b 95 70 ee ff
	ff		 mov	 edx, DWORD PTR _f$[ebp]
  008e3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  008e6	f6 84 05 7c ee
	ff ff 01	 test	 BYTE PTR _f$[ebp+eax+12], 1
  008ee	0f 84 1c f8 ff
	ff		 je	 $LL21@ParseFile

; 259  : 							sec = TokenizerSection();

  008f4	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  008f9	33 f6		 xor	 esi, esi
$LN20@ParseFile:

; 268  : 
; 269  : 			}

  008fb	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  00901	8b 08		 mov	 ecx, DWORD PTR [eax]
  00903	50		 push	 eax
  00904	51		 push	 ecx
  00905	8d 95 a8 ef ff
	ff		 lea	 edx, DWORD PTR $T205680[ebp]
  0090b	52		 push	 edx
  0090c	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  00912	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00916	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  0091b	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  00921	50		 push	 eax
  00922	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00926	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0092b	83 c4 04	 add	 esp, 4

; 274  : 			}
; 275  : 			
; 276  : 			f.close();

  0092e	8d 8d 88 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+24]
  00934	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00939	85 c0		 test	 eax, eax
  0093b	75 29		 jne	 SHORT $LN1229@ParseFile
  0093d	8b 8d 70 ee ff
	ff		 mov	 ecx, DWORD PTR _f$[ebp]
  00943	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00946	8b 84 0d 7c ee
	ff ff		 mov	 eax, DWORD PTR _f$[ebp+ecx+12]
  0094d	8d 8c 0d 70 ee
	ff ff		 lea	 ecx, DWORD PTR _f$[ebp+ecx]
  00954	83 c8 02	 or	 eax, 2
  00957	39 71 38	 cmp	 DWORD PTR [ecx+56], esi
  0095a	75 03		 jne	 SHORT $LN1231@ParseFile
  0095c	83 c8 04	 or	 eax, 4
$LN1231@ParseFile:
  0095f	56		 push	 esi
  00960	50		 push	 eax
  00961	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN1229@ParseFile:

; 277  : 
; 278  : 			return true;

  00966	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  0096c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00970	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  00975	8d 95 e0 ee ff
	ff		 lea	 edx, DWORD PTR _f$[ebp+112]
  0097b	52		 push	 edx
  0097c	c7 85 e0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _f$[ebp+112], OFFSET ??_7ios_base@std@@6B@
  00986	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0098b	83 c4 04	 add	 esp, 4
  0098e	39 7d 1c	 cmp	 DWORD PTR _file$[ebp+20], edi
  00991	72 0c		 jb	 SHORT $LN1250@ParseFile
  00993	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00996	50		 push	 eax
  00997	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0099c	83 c4 04	 add	 esp, 4
$LN1250@ParseFile:
  0099f	b0 01		 mov	 al, 1
  009a1	e9 ac 02 00 00	 jmp	 $LN24@ParseFile
$LN1309@ParseFile:

; 229  : 					{
; 230  : 						line.erase(k, 1);

  009a6	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  009ab	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN1354@ParseFile:
$LN1315@ParseFile:

; 238  : 						{
; 239  : 							return false; // falha de sintaxe

  009b0	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  009b5	39 b5 e8 ef ff
	ff		 cmp	 DWORD PTR _line$144181[ebp+20], esi
  009bb	72 0f		 jb	 SHORT $LN367@ParseFile
  009bd	8b 8d d4 ef ff
	ff		 mov	 ecx, DWORD PTR _line$144181[ebp]
  009c3	51		 push	 ecx
  009c4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  009c9	83 c4 04	 add	 esp, 4
$LN367@ParseFile:
  009cc	c7 85 e8 ef ff
	ff 0f 00 00 00	 mov	 DWORD PTR _line$144181[ebp+20], 15 ; 0000000fH
  009d6	89 bd e4 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+16], edi
  009dc	c6 85 d4 ef ff
	ff 00		 mov	 BYTE PTR _line$144181[ebp], 0
  009e3	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  009e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  009eb	50		 push	 eax
  009ec	51		 push	 ecx
  009ed	8d 95 a8 ef ff
	ff		 lea	 edx, DWORD PTR $T201692[ebp]
  009f3	52		 push	 edx
  009f4	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  009fa	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  009fe	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00a03	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  00a09	50		 push	 eax
  00a0a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a0f	83 c4 04	 add	 esp, 4
  00a12	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  00a18	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00a1c	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  00a21	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  00a27	51		 push	 ecx
  00a28	c7 85 e0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _f$[ebp+112], OFFSET ??_7ios_base@std@@6B@
  00a32	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00a37	83 c4 04	 add	 esp, 4
  00a3a	39 75 1c	 cmp	 DWORD PTR _file$[ebp+20], esi
  00a3d	0f 82 0d 02 00
	00		 jb	 $LN1279@ParseFile
  00a43	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00a46	52		 push	 edx
  00a47	e9 fc 01 00 00	 jmp	 $LN1353@ParseFile
$LN1318@ParseFile:

; 251  : 						return false;

  00a4c	8b 85 80 ef ff
	ff		 mov	 eax, DWORD PTR _row$144309[ebp+4]
  00a52	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a54	50		 push	 eax
  00a55	51		 push	 ecx
  00a56	8d 85 a8 ef ff
	ff		 lea	 eax, DWORD PTR $T203260[ebp]
  00a5c	50		 push	 eax
  00a5d	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00a63	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00a67	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00a6c	8b 8d 80 ef ff
	ff		 mov	 ecx, DWORD PTR _row$144309[ebp+4]
  00a72	51		 push	 ecx
  00a73	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a78	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
  00a7d	83 c4 04	 add	 esp, 4
  00a80	39 9d e8 ef ff
	ff		 cmp	 DWORD PTR _line$144181[ebp+20], ebx
  00a86	72 0f		 jb	 SHORT $LN744@ParseFile
  00a88	8b 95 d4 ef ff
	ff		 mov	 edx, DWORD PTR _line$144181[ebp]
  00a8e	52		 push	 edx
  00a8f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a94	83 c4 04	 add	 esp, 4
$LN744@ParseFile:
  00a97	89 b5 e8 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+20], esi
  00a9d	89 bd e4 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+16], edi
  00aa3	c6 85 d4 ef ff
	ff 00		 mov	 BYTE PTR _line$144181[ebp], 0
  00aaa	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  00ab0	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ab2	50		 push	 eax
  00ab3	51		 push	 ecx
  00ab4	8d 85 a8 ef ff
	ff		 lea	 eax, DWORD PTR $T203592[ebp]
  00aba	50		 push	 eax
  00abb	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  00ac1	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00ac5	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00aca	8b 8d 98 ef ff
	ff		 mov	 ecx, DWORD PTR _sec$144171[ebp+4]
  00ad0	51		 push	 ecx
  00ad1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ad6	83 c4 04	 add	 esp, 4
  00ad9	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  00adf	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00ae3	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  00ae8	8d 95 e0 ee ff
	ff		 lea	 edx, DWORD PTR _f$[ebp+112]
  00aee	52		 push	 edx
  00aef	c7 85 e0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _f$[ebp+112], OFFSET ??_7ios_base@std@@6B@
  00af9	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00afe	83 c4 04	 add	 esp, 4
  00b01	39 5d 1c	 cmp	 DWORD PTR _file$[ebp+20], ebx
  00b04	0f 82 46 01 00
	00		 jb	 $LN1279@ParseFile
  00b0a	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00b0d	50		 push	 eax
  00b0e	e9 35 01 00 00	 jmp	 $LN1353@ParseFile
$LN1319@ParseFile:

; 259  : 							sec = TokenizerSection();

  00b13	8d 8d 74 ef ff
	ff		 lea	 ecx, DWORD PTR $T203932[ebp]
  00b19	51		 push	 ecx
  00b1a	8d 8d 2c ef ff
	ff		 lea	 ecx, DWORD PTR $T204127[ebp]
  00b20	89 bd 74 ef ff
	ff		 mov	 DWORD PTR $T203932[ebp], edi
  00b26	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00b2b	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00b30	8d 95 2c ef ff
	ff		 lea	 edx, DWORD PTR $T204127[ebp]
  00b36	52		 push	 edx
  00b37	c7 85 2c ef ff
	ff 00 00 00 00	 mov	 DWORD PTR $T204127[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00b41	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1355@ParseFile:

; 248  : 
; 249  : 					TokenizerRow row;

$LN646@ParseFile:
  00b46	8d 85 70 ef ff
	ff		 lea	 eax, DWORD PTR $T202727[ebp]
  00b4c	50		 push	 eax
  00b4d	8d 8d 38 ef ff
	ff		 lea	 ecx, DWORD PTR $T202930[ebp]
  00b53	89 bd 70 ef ff
	ff		 mov	 DWORD PTR $T202727[ebp], edi
  00b59	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00b5e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00b63	8d 8d 38 ef ff
	ff		 lea	 ecx, DWORD PTR $T202930[ebp]
  00b69	51		 push	 ecx
  00b6a	c7 85 38 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR $T202930[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00b74	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1356@ParseFile:

; 183  : 			{
; 184  : 
; 185  : 				TokenizerSection sec = TokenizerSection();

$LN76@ParseFile:
  00b79	8d 8d 68 ef ff
	ff		 lea	 ecx, DWORD PTR $T200295[ebp]
  00b7f	51		 push	 ecx
  00b80	8d 8d 48 ef ff
	ff		 lea	 ecx, DWORD PTR $T200491[ebp]
  00b86	89 b5 68 ef ff
	ff		 mov	 DWORD PTR $T200295[ebp], esi
  00b8c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00b91	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00b96	8d 95 48 ef ff
	ff		 lea	 edx, DWORD PTR $T200491[ebp]
  00b9c	52		 push	 edx
  00b9d	c7 85 48 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR $T200491[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00ba7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1357@ParseFile:
$LN22@ParseFile:

; 270  : 			else
; 271  : 			{
; 272  : 				f.close();

  00bac	8d 8d 88 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+24]
  00bb2	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00bb7	85 c0		 test	 eax, eax
  00bb9	75 29		 jne	 SHORT $LN1188@ParseFile
  00bbb	8b 85 70 ee ff
	ff		 mov	 eax, DWORD PTR _f$[ebp]
  00bc1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00bc4	8b 84 0d 7c ee
	ff ff		 mov	 eax, DWORD PTR _f$[ebp+ecx+12]
  00bcb	8d 8c 0d 70 ee
	ff ff		 lea	 ecx, DWORD PTR _f$[ebp+ecx]
  00bd2	83 c8 02	 or	 eax, 2
  00bd5	39 71 38	 cmp	 DWORD PTR [ecx+56], esi
  00bd8	75 03		 jne	 SHORT $LN1190@ParseFile
  00bda	83 c8 04	 or	 eax, 4
$LN1190@ParseFile:
  00bdd	56		 push	 esi
  00bde	50		 push	 eax
  00bdf	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN1188@ParseFile:

; 273  : 				return false;

  00be4	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  00bea	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00bee	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  00bf3	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  00bf9	51		 push	 ecx
  00bfa	c7 85 e0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _f$[ebp+112], OFFSET ??_7ios_base@std@@6B@
  00c04	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00c09	83 c4 04	 add	 esp, 4
  00c0c	39 7d 1c	 cmp	 DWORD PTR _file$[ebp+20], edi
  00c0f	72 3f		 jb	 SHORT $LN1279@ParseFile
  00c11	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00c14	52		 push	 edx
  00c15	eb 31		 jmp	 SHORT $LN1353@ParseFile
$LN23@ParseFile:

; 279  : 
; 280  : 		}
; 281  : 		else
; 282  : 		{
; 283  : 			return false;

  00c17	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  00c1d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00c21	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  00c26	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _f$[ebp+112]
  00c2c	50		 push	 eax
  00c2d	c7 85 e0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _f$[ebp+112], OFFSET ??_7ios_base@std@@6B@
  00c37	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00c3c	83 c4 04	 add	 esp, 4
  00c3f	39 7d 1c	 cmp	 DWORD PTR _file$[ebp+20], edi
  00c42	72 0c		 jb	 SHORT $LN1279@ParseFile
  00c44	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00c47	51		 push	 ecx
$LN1353@ParseFile:
  00c48	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c4d	83 c4 04	 add	 esp, 4
$LN1279@ParseFile:
  00c50	32 c0		 xor	 al, al
$LN24@ParseFile:

; 284  : 		}
; 285  : 
; 286  : 	}

  00c52	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00c55	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00c5c	59		 pop	 ecx
  00c5d	5f		 pop	 edi
  00c5e	5e		 pop	 esi
  00c5f	5b		 pop	 ebx
  00c60	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c63	33 cd		 xor	 ecx, ebp
  00c65	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c6a	8b e5		 mov	 esp, ebp
  00c6c	5d		 pop	 ebp
  00c6d	c2 20 00	 ret	 32			; 00000020H
$LN1347@ParseFile:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _file$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$1:
  00008	8d 8d 70 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$2:
  00013	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1TokenizerSection@@QAE@XZ
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$3:
  0001e	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$4:
  00029	8d 8d b8 ef ff
	ff		 lea	 ecx, DWORD PTR $T144195[ebp]
  0002f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$5:
  00034	8d 8d b8 ef ff
	ff		 lea	 ecx, DWORD PTR $T144289[ebp]
  0003a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$6:
  0003f	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00045	e9 00 00 00 00	 jmp	 ??1TokenizerRow@@QAE@XZ
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$8:
  0004a	8d 8d c0 ef ff
	ff		 lea	 ecx, DWORD PTR $T200203[ebp]
  00050	e9 00 00 00 00	 jmp	 ??1TokenizerSection@@QAE@XZ
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$31:
  00055	8d 8d c0 ef ff
	ff		 lea	 ecx, DWORD PTR $T200203[ebp]
  0005b	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$34:
  00060	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00066	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$37:
  0006b	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00071	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$40:
  00076	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  0007c	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$14:
  00081	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  00087	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$21:
  0008c	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00092	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$24:
  00097	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  0009d	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z:
  000a2	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000a6	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000a9	8b 8a 6c ee ff
	ff		 mov	 ecx, DWORD PTR [edx-4500]
  000af	33 c8		 xor	 ecx, eax
  000b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b6	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000b9	33 c8		 xor	 ecx, eax
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z
  000c5	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z ENDP ; Tokenizer::ParseFile
PUBLIC	??0TokenizerGroup@@QAE@XZ			; TokenizerGroup::TokenizerGroup
; Function compile flags: /Ogtp
;	COMDAT ??0TokenizerGroup@@QAE@XZ
_TEXT	SEGMENT
$T206342 = -16						; size = 12
$T206187 = -4						; size = 4
??0TokenizerGroup@@QAE@XZ PROC				; TokenizerGroup::TokenizerGroup, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN28@TokenizerG
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al
  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN28@TokenizerG:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T206187[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T206342[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T206187[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T206342[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T206342[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN53@TokenizerG:
$LN52@TokenizerG:
  0006c	cc		 int	 3
??0TokenizerGroup@@QAE@XZ ENDP				; TokenizerGroup::TokenizerGroup
_TEXT	ENDS
PUBLIC	??1TokenizerGroup@@QAE@XZ			; TokenizerGroup::~TokenizerGroup
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TokenizerGroup@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TokenizerGroup@@QAE@XZ$2
__ehfuncinfo$??1TokenizerGroup@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1TokenizerGroup@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1TokenizerGroup@@QAE@XZ
_TEXT	SEGMENT
$T206544 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TokenizerGroup@@QAE@XZ PROC				; TokenizerGroup::~TokenizerGroup, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1TokenizerGroup@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T206544[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TokenizerGroup@@QAE@XZ$2:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
__ehhandler$??1TokenizerGroup@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1TokenizerGroup@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1TokenizerGroup@@QAE@XZ ENDP				; TokenizerGroup::~TokenizerGroup
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	?Load@CBloodCastle@@QAEHPAD@Z			; CBloodCastle::Load
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Load@CBloodCastle@@QAEHPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CBloodCastle@@QAEHPAD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@CBloodCastle@@QAEHPAD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@CBloodCastle@@QAEHPAD@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CBloodCastle@@QAEHPAD@Z$14
__ehfuncinfo$?Load@CBloodCastle@@QAEHPAD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?Load@CBloodCastle@@QAEHPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\bloodcastle.cpp
xdata$x	ENDS
;	COMDAT ?Load@CBloodCastle@@QAEHPAD@Z
_TEXT	SEGMENT
_section$ = -108					; size = 20
_group$ = -88						; size = 16
$T206850 = -72						; size = 12
_token$ = -72						; size = 12
$T207105 = -60						; size = 12
$T206911 = -48						; size = 4
$T214806 = -44						; size = 4
$T212082 = -44						; size = 4
$T209859 = -44						; size = 4
$T207531 = -44						; size = 4
$T206646 = -44						; size = 4
$T206581 = -44						; size = 4
$T214282 = -40						; size = 4
$T213721 = -36						; size = 4
__Where$214877 = -32					; size = 4
__Where$214277 = -32					; size = 4
__Where$213792 = -32					; size = 4
__Where$213282 = -32					; size = 4
__Where$212707 = -32					; size = 4
__Where$212116 = -32					; size = 4
__Where$211466 = -32					; size = 4
__Where$210877 = -32					; size = 4
__Where$210372 = -32					; size = 4
__Where$209753 = -32					; size = 4
$T209163 = -32						; size = 4
$T206594 = -32						; size = 4
$T206593 = -32						; size = 4
$T206592 = -32						; size = 4
$T206591 = -32						; size = 4
$T206588 = -32						; size = 4
$T206587 = -32						; size = 4
$T206586 = -32						; size = 4
$T206585 = -32						; size = 4
$T212636 = -28						; size = 4
$T212121 = -28						; size = 4
$T210377 = -28						; size = 4
$T209758 = -28						; size = 4
$T208525 = -28						; size = 4
$T213287 = -24						; size = 4
$T210852 = -24						; size = 4
__Where$209158 = -24					; size = 4
__Where$208596 = -24					; size = 4
__Where$208019 = -24					; size = 4
_it$207496 = -24					; size = 4
$T206584 = -24						; size = 4
$T206583 = -24						; size = 4
$T206582 = -24						; size = 4
$T213840 = -20						; size = 4
$T213297 = -20						; size = 4
$T211395 = -20						; size = 4
$T208024 = -20						; size = 4
$T207557 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T215401 = 8						; size = 4
$T215163 = 8						; size = 4
_filename$ = 8						; size = 4
?Load@CBloodCastle@@QAEHPAD@Z PROC			; CBloodCastle::Load, COMDAT
; _this$ = ecx

; 194  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Load@CBloodCastle@@QAEHPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 195  : 	Tokenizer          token;
; 196  : 	TokenizerGroup     group;

  0002b	33 db		 xor	 ebx, ebx
  0002d	6a 28		 push	 40			; 00000028H
  0002f	89 5d b0	 mov	 DWORD PTR _group$[ebp+8], ebx
  00032	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00037	83 c4 04	 add	 esp, 4
  0003a	3b c3		 cmp	 eax, ebx
  0003c	0f 84 7e 07 00
	00		 je	 $LN49@Load
  00042	89 45 ac	 mov	 DWORD PTR _group$[ebp+4], eax
  00045	89 00		 mov	 DWORD PTR [eax], eax
  00047	8b 45 ac	 mov	 eax, DWORD PTR _group$[ebp+4]
  0004a	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0004d	8b 45 ac	 mov	 eax, DWORD PTR _group$[ebp+4]
  00050	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00053	8b 45 ac	 mov	 eax, DWORD PTR _group$[ebp+4]
  00056	c6 40 24 01	 mov	 BYTE PTR [eax+36], 1
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR _group$[ebp+4]
  0005d	c6 41 25 01	 mov	 BYTE PTR [ecx+37], 1

; 197  : 	TokenizerSection   section;

  00061	6a 28		 push	 40			; 00000028H
  00063	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00066	89 5d 9c	 mov	 DWORD PTR _section$[ebp+8], ebx
  00069	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0006e	83 c4 04	 add	 esp, 4
  00071	3b c3		 cmp	 eax, ebx
  00073	0f 84 23 07 00
	00		 je	 $LN100@Load
  00079	89 45 98	 mov	 DWORD PTR _section$[ebp+4], eax
  0007c	89 00		 mov	 DWORD PTR [eax], eax
  0007e	8b 45 98	 mov	 eax, DWORD PTR _section$[ebp+4]
  00081	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00084	8b 45 98	 mov	 eax, DWORD PTR _section$[ebp+4]
  00087	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0008a	8b 55 98	 mov	 edx, DWORD PTR _section$[ebp+4]
  0008d	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1
  00091	8b 45 98	 mov	 eax, DWORD PTR _section$[ebp+4]
  00094	c6 40 25 01	 mov	 BYTE PTR [eax+37], 1

; 198  : 	int BridgeCount;
; 199  : 	signed int iBridgeNum;
; 200  : 	int null;
; 201  : 
; 202  : 	int i = 0;
; 203  : 
; 204  : 	token.ParseFile(std::string(filename), group);

  00098	8b 7d 08	 mov	 edi, DWORD PTR _filename$[ebp]
  0009b	8d 4d a8	 lea	 ecx, DWORD PTR _group$[ebp]
  0009e	51		 push	 ecx
  0009f	83 ec 1c	 sub	 esp, 28			; 0000001cH
  000a2	8b cc		 mov	 ecx, esp
  000a4	8b c7		 mov	 eax, edi
  000a6	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  000ad	89 59 10	 mov	 DWORD PTR [ecx+16], ebx
  000b0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000b4	89 65 d4	 mov	 DWORD PTR $T206581[ebp], esp
  000b7	88 19		 mov	 BYTE PTR [ecx], bl
  000b9	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  000bc	8d 64 24 00	 npad	 4
$LL1815@Load:
  000c0	8a 10		 mov	 dl, BYTE PTR [eax]
  000c2	40		 inc	 eax
  000c3	3a d3		 cmp	 dl, bl
  000c5	75 f9		 jne	 SHORT $LL1815@Load
  000c7	2b c6		 sub	 eax, esi
  000c9	50		 push	 eax
  000ca	57		 push	 edi
  000cb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000d0	8d 4d b8	 lea	 ecx, DWORD PTR _token$[ebp]
  000d3	e8 00 00 00 00	 call	 ?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z ; Tokenizer::ParseFile

; 205  : 
; 206  : 	BridgeCount=-1;
; 207  : 
; 208  : 	if(group.GetSection(0, section))

  000d8	8d 55 ec	 lea	 edx, DWORD PTR $T207557[ebp]
  000db	52		 push	 edx
  000dc	8d 45 e8	 lea	 eax, DWORD PTR _it$207496[ebp]
  000df	50		 push	 eax
  000e0	8d 4d a8	 lea	 ecx, DWORD PTR _group$[ebp]
  000e3	89 5d ec	 mov	 DWORD PTR $T207557[ebp], ebx
  000e6	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::find
  000eb	8b 45 e8	 mov	 eax, DWORD PTR _it$207496[ebp]
  000ee	8b 4d ac	 mov	 ecx, DWORD PTR _group$[ebp+4]
  000f1	3b c1		 cmp	 eax, ecx
  000f3	0f 84 88 01 00
	00		 je	 $LN11@Load
  000f9	8d 70 10	 lea	 esi, DWORD PTR [eax+16]
  000fc	8d 55 94	 lea	 edx, DWORD PTR _section$[ebp]
  000ff	3b d6		 cmp	 edx, esi
  00101	74 1e		 je	 SHORT $LN181@Load
  00103	8b 45 98	 mov	 eax, DWORD PTR _section$[ebp+4]
  00106	8b 08		 mov	 ecx, DWORD PTR [eax]
  00108	50		 push	 eax
  00109	51		 push	 ecx
  0010a	8d 45 d4	 lea	 eax, DWORD PTR $T207531[ebp]
  0010d	50		 push	 eax
  0010e	8b ca		 mov	 ecx, edx
  00110	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00115	56		 push	 esi
  00116	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  00119	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
  0011e	8b 4d ac	 mov	 ecx, DWORD PTR _group$[ebp+4]
$LN181@Load:
  00121	8b 76 10	 mov	 esi, DWORD PTR [esi+16]

; 209  : 	{
; 210  : 		for(i = 0; i < section.RowCount; i++)

  00124	33 ff		 xor	 edi, edi
  00126	89 75 a4	 mov	 DWORD PTR _section$[ebp+16], esi
  00129	3b f3		 cmp	 esi, ebx
  0012b	0f 8e 50 01 00
	00		 jle	 $LN11@Load
  00131	8b 75 f0	 mov	 esi, DWORD PTR _this$[ebp]
$LL13@Load:

; 211  : 		{
; 212  : 			this->m_iBC_TIME_MIN_OPEN = section.Rows[i].GetInt(0);

  00134	8d 4d e8	 lea	 ecx, DWORD PTR $T206582[ebp]
  00137	51		 push	 ecx
  00138	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  0013b	89 7d e8	 mov	 DWORD PTR $T206582[ebp], edi
  0013e	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  00143	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00146	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00149	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  0014c	75 0b		 jne	 SHORT $LN220@Load
  0014e	8b ff		 npad	 2
$LL221@Load:
  00150	8b d1		 mov	 edx, ecx
  00152	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00154	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  00157	74 f7		 je	 SHORT $LL221@Load
$LN220@Load:
  00159	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0015c	89 55 e8	 mov	 DWORD PTR __Where$208019[ebp], edx
  0015f	3b d0		 cmp	 edx, eax
  00161	74 0a		 je	 SHORT $LN214@Load
  00163	39 5a 0c	 cmp	 DWORD PTR [edx+12], ebx
  00166	77 05		 ja	 SHORT $LN214@Load
  00168	8d 4d e8	 lea	 ecx, DWORD PTR __Where$208019[ebp]
  0016b	eb 06		 jmp	 SHORT $LN215@Load
$LN214@Load:
  0016d	89 45 ec	 mov	 DWORD PTR $T208024[ebp], eax
  00170	8d 4d ec	 lea	 ecx, DWORD PTR $T208024[ebp]
$LN215@Load:
  00173	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00175	3b c8		 cmp	 ecx, eax
  00177	75 05		 jne	 SHORT $LN209@Load
  00179	83 c8 ff	 or	 eax, -1
  0017c	eb 14		 jmp	 SHORT $LN210@Load
$LN209@Load:
  0017e	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  00182	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00185	72 02		 jb	 SHORT $LN320@Load
  00187	8b 00		 mov	 eax, DWORD PTR [eax]
$LN320@Load:
  00189	50		 push	 eax
  0018a	e8 00 00 00 00	 call	 _atoi
  0018f	83 c4 04	 add	 esp, 4
$LN210@Load:

; 213  : 			this->m_iBC_TIME_MIN_PLAY = section.Rows[i].GetInt(1);

  00192	8d 55 e8	 lea	 edx, DWORD PTR $T206583[ebp]
  00195	52		 push	 edx
  00196	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  00199	89 86 08 0e 00
	00		 mov	 DWORD PTR [esi+3592], eax
  0019f	89 7d e8	 mov	 DWORD PTR $T206583[ebp], edi
  001a2	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  001a7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001aa	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001ad	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  001b0	75 14		 jne	 SHORT $LN334@Load
$LL335@Load:
  001b2	83 79 0c 01	 cmp	 DWORD PTR [ecx+12], 1
  001b6	73 05		 jae	 SHORT $LN333@Load
  001b8	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  001bb	eb 04		 jmp	 SHORT $LN332@Load
$LN333@Load:
  001bd	8b d1		 mov	 edx, ecx
  001bf	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN332@Load:
  001c1	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  001c4	74 ec		 je	 SHORT $LL335@Load
$LN334@Load:
  001c6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c9	89 55 e8	 mov	 DWORD PTR __Where$208596[ebp], edx
  001cc	3b d0		 cmp	 edx, eax
  001ce	74 0b		 je	 SHORT $LN328@Load
  001d0	83 7a 0c 01	 cmp	 DWORD PTR [edx+12], 1
  001d4	77 05		 ja	 SHORT $LN328@Load
  001d6	8d 4d e8	 lea	 ecx, DWORD PTR __Where$208596[ebp]
  001d9	eb 06		 jmp	 SHORT $LN329@Load
$LN328@Load:
  001db	89 45 e4	 mov	 DWORD PTR $T208525[ebp], eax
  001de	8d 4d e4	 lea	 ecx, DWORD PTR $T208525[ebp]
$LN329@Load:
  001e1	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001e3	3b c8		 cmp	 ecx, eax
  001e5	75 05		 jne	 SHORT $LN323@Load
  001e7	83 c8 ff	 or	 eax, -1
  001ea	eb 14		 jmp	 SHORT $LN324@Load
$LN323@Load:
  001ec	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  001f0	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  001f3	72 02		 jb	 SHORT $LN434@Load
  001f5	8b 00		 mov	 eax, DWORD PTR [eax]
$LN434@Load:
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 _atoi
  001fd	83 c4 04	 add	 esp, 4
$LN324@Load:
  00200	89 86 0c 0e 00
	00		 mov	 DWORD PTR [esi+3596], eax

; 214  : 			this->m_iBC_TIME_MIN_REST = section.Rows[i].GetInt(2);

  00206	8d 45 e8	 lea	 eax, DWORD PTR $T206584[ebp]
  00209	50		 push	 eax
  0020a	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  0020d	89 7d e8	 mov	 DWORD PTR $T206584[ebp], edi
  00210	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  00215	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00218	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0021b	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  0021e	75 14		 jne	 SHORT $LN448@Load
$LL449@Load:
  00220	83 79 0c 02	 cmp	 DWORD PTR [ecx+12], 2
  00224	73 05		 jae	 SHORT $LN447@Load
  00226	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00229	eb 04		 jmp	 SHORT $LN446@Load
$LN447@Load:
  0022b	8b d1		 mov	 edx, ecx
  0022d	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN446@Load:
  0022f	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  00232	74 ec		 je	 SHORT $LL449@Load
$LN448@Load:
  00234	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00237	89 55 e8	 mov	 DWORD PTR __Where$209158[ebp], edx
  0023a	3b d0		 cmp	 edx, eax
  0023c	74 0b		 je	 SHORT $LN442@Load
  0023e	83 7a 0c 02	 cmp	 DWORD PTR [edx+12], 2
  00242	77 05		 ja	 SHORT $LN442@Load
  00244	8d 4d e8	 lea	 ecx, DWORD PTR __Where$209158[ebp]
  00247	eb 06		 jmp	 SHORT $LN443@Load
$LN442@Load:
  00249	89 45 e0	 mov	 DWORD PTR $T209163[ebp], eax
  0024c	8d 4d e0	 lea	 ecx, DWORD PTR $T209163[ebp]
$LN443@Load:
  0024f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00251	3b c8		 cmp	 ecx, eax
  00253	75 05		 jne	 SHORT $LN437@Load
  00255	83 c8 ff	 or	 eax, -1
  00258	eb 14		 jmp	 SHORT $LN438@Load
$LN437@Load:
  0025a	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  0025e	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00261	72 02		 jb	 SHORT $LN548@Load
  00263	8b 00		 mov	 eax, DWORD PTR [eax]
$LN548@Load:
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 _atoi
  0026b	83 c4 04	 add	 esp, 4
$LN438@Load:
  0026e	47		 inc	 edi
  0026f	89 86 10 0e 00
	00		 mov	 DWORD PTR [esi+3600], eax
  00275	3b 7d a4	 cmp	 edi, DWORD PTR _section$[ebp+16]
  00278	0f 8c b6 fe ff
	ff		 jl	 $LL13@Load

; 209  : 	{
; 210  : 		for(i = 0; i < section.RowCount; i++)

  0027e	8b 4d ac	 mov	 ecx, DWORD PTR _group$[ebp+4]
$LN11@Load:

; 215  : 		}
; 216  : 	}
; 217  : 	if(group.GetSection(1, section))

  00281	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00284	8b d1		 mov	 edx, ecx
  00286	be 01 00 00 00	 mov	 esi, 1
  0028b	38 58 25	 cmp	 BYTE PTR [eax+37], bl
  0028e	75 13		 jne	 SHORT $LN562@Load
$LL563@Load:
  00290	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  00293	73 05		 jae	 SHORT $LN561@Load
  00295	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00298	eb 04		 jmp	 SHORT $LN560@Load
$LN561@Load:
  0029a	8b d0		 mov	 edx, eax
  0029c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN560@Load:
  0029e	38 58 25	 cmp	 BYTE PTR [eax+37], bl
  002a1	74 ed		 je	 SHORT $LL563@Load
$LN562@Load:
  002a3	89 55 e0	 mov	 DWORD PTR __Where$209753[ebp], edx
  002a6	3b d1		 cmp	 edx, ecx
  002a8	74 0a		 je	 SHORT $LN556@Load
  002aa	39 72 0c	 cmp	 DWORD PTR [edx+12], esi
  002ad	77 05		 ja	 SHORT $LN556@Load
  002af	8d 45 e0	 lea	 eax, DWORD PTR __Where$209753[ebp]
  002b2	eb 06		 jmp	 SHORT $LN557@Load
$LN556@Load:
  002b4	89 4d e4	 mov	 DWORD PTR $T209758[ebp], ecx
  002b7	8d 45 e4	 lea	 eax, DWORD PTR $T209758[ebp]
$LN557@Load:
  002ba	8b 00		 mov	 eax, DWORD PTR [eax]
  002bc	3b c1		 cmp	 eax, ecx
  002be	0f 84 8d 01 00
	00		 je	 $LN7@Load
  002c4	8d 70 10	 lea	 esi, DWORD PTR [eax+16]
  002c7	8d 55 94	 lea	 edx, DWORD PTR _section$[ebp]
  002ca	3b d6		 cmp	 edx, esi
  002cc	74 1e		 je	 SHORT $LN648@Load
  002ce	8b 45 98	 mov	 eax, DWORD PTR _section$[ebp+4]
  002d1	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d3	50		 push	 eax
  002d4	51		 push	 ecx
  002d5	8d 45 d4	 lea	 eax, DWORD PTR $T209859[ebp]
  002d8	50		 push	 eax
  002d9	8b ca		 mov	 ecx, edx
  002db	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  002e0	56		 push	 esi
  002e1	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  002e4	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
  002e9	8b 4d ac	 mov	 ecx, DWORD PTR _group$[ebp+4]
$LN648@Load:
  002ec	8b 76 10	 mov	 esi, DWORD PTR [esi+16]

; 218  : 	{
; 219  : 		for(i = 0; i < section.RowCount; i++)

  002ef	33 ff		 xor	 edi, edi
  002f1	89 75 a4	 mov	 DWORD PTR _section$[ebp+16], esi
  002f4	3b f3		 cmp	 esi, ebx
  002f6	0f 8e 55 01 00
	00		 jle	 $LN7@Load
  002fc	8b 75 f0	 mov	 esi, DWORD PTR _this$[ebp]
  002ff	90		 npad	 1
$LL9@Load:

; 220  : 		{
; 221  : 			this->m_iBC_NORMAL_ITEM_DROP = section.Rows[i].GetInt(0);

  00300	8d 4d e0	 lea	 ecx, DWORD PTR $T206585[ebp]
  00303	51		 push	 ecx
  00304	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  00307	89 7d e0	 mov	 DWORD PTR $T206585[ebp], edi
  0030a	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  0030f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00312	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00315	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  00318	75 0f		 jne	 SHORT $LN687@Load
  0031a	8d 9b 00 00 00
	00		 npad	 6
$LL688@Load:
  00320	8b d1		 mov	 edx, ecx
  00322	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00324	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  00327	74 f7		 je	 SHORT $LL688@Load
$LN687@Load:
  00329	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0032c	89 55 e0	 mov	 DWORD PTR __Where$210372[ebp], edx
  0032f	3b d0		 cmp	 edx, eax
  00331	74 0a		 je	 SHORT $LN681@Load
  00333	39 5a 0c	 cmp	 DWORD PTR [edx+12], ebx
  00336	77 05		 ja	 SHORT $LN681@Load
  00338	8d 4d e0	 lea	 ecx, DWORD PTR __Where$210372[ebp]
  0033b	eb 06		 jmp	 SHORT $LN682@Load
$LN681@Load:
  0033d	89 45 e4	 mov	 DWORD PTR $T210377[ebp], eax
  00340	8d 4d e4	 lea	 ecx, DWORD PTR $T210377[ebp]
$LN682@Load:
  00343	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00345	3b c8		 cmp	 ecx, eax
  00347	75 05		 jne	 SHORT $LN676@Load
  00349	83 c8 ff	 or	 eax, -1
  0034c	eb 14		 jmp	 SHORT $LN677@Load
$LN676@Load:
  0034e	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  00352	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00355	72 02		 jb	 SHORT $LN787@Load
  00357	8b 00		 mov	 eax, DWORD PTR [eax]
$LN787@Load:
  00359	50		 push	 eax
  0035a	e8 00 00 00 00	 call	 _atoi
  0035f	83 c4 04	 add	 esp, 4
$LN677@Load:

; 222  : 			this->m_iBC_EXCEL_ITEM_DROP  = section.Rows[i].GetInt(1);

  00362	8d 55 e0	 lea	 edx, DWORD PTR $T206586[ebp]
  00365	52		 push	 edx
  00366	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  00369	89 86 14 0e 00
	00		 mov	 DWORD PTR [esi+3604], eax
  0036f	89 7d e0	 mov	 DWORD PTR $T206586[ebp], edi
  00372	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  00377	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0037a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0037d	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  00380	75 14		 jne	 SHORT $LN801@Load
$LL802@Load:
  00382	83 79 0c 01	 cmp	 DWORD PTR [ecx+12], 1
  00386	73 05		 jae	 SHORT $LN800@Load
  00388	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0038b	eb 04		 jmp	 SHORT $LN799@Load
$LN800@Load:
  0038d	8b d1		 mov	 edx, ecx
  0038f	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN799@Load:
  00391	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  00394	74 ec		 je	 SHORT $LL802@Load
$LN801@Load:
  00396	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00399	89 55 e0	 mov	 DWORD PTR __Where$210877[ebp], edx
  0039c	3b d0		 cmp	 edx, eax
  0039e	74 0b		 je	 SHORT $LN795@Load
  003a0	83 7a 0c 01	 cmp	 DWORD PTR [edx+12], 1
  003a4	77 05		 ja	 SHORT $LN795@Load
  003a6	8d 4d e0	 lea	 ecx, DWORD PTR __Where$210877[ebp]
  003a9	eb 06		 jmp	 SHORT $LN796@Load
$LN795@Load:
  003ab	89 45 e8	 mov	 DWORD PTR $T210852[ebp], eax
  003ae	8d 4d e8	 lea	 ecx, DWORD PTR $T210852[ebp]
$LN796@Load:
  003b1	8b 09		 mov	 ecx, DWORD PTR [ecx]
  003b3	3b c8		 cmp	 ecx, eax
  003b5	75 05		 jne	 SHORT $LN790@Load
  003b7	83 c8 ff	 or	 eax, -1
  003ba	eb 14		 jmp	 SHORT $LN791@Load
$LN790@Load:
  003bc	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  003c0	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  003c3	72 02		 jb	 SHORT $LN901@Load
  003c5	8b 00		 mov	 eax, DWORD PTR [eax]
$LN901@Load:
  003c7	50		 push	 eax
  003c8	e8 00 00 00 00	 call	 _atoi
  003cd	83 c4 04	 add	 esp, 4
$LN791@Load:
  003d0	89 86 18 0e 00
	00		 mov	 DWORD PTR [esi+3608], eax

; 223  : 			this->m_iBC_MONSTER_REGEN    = section.Rows[i].GetInt(2);

  003d6	8d 45 e0	 lea	 eax, DWORD PTR $T206587[ebp]
  003d9	50		 push	 eax
  003da	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  003dd	89 7d e0	 mov	 DWORD PTR $T206587[ebp], edi
  003e0	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  003e5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003e8	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  003eb	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  003ee	75 14		 jne	 SHORT $LN915@Load
$LL916@Load:
  003f0	83 79 0c 02	 cmp	 DWORD PTR [ecx+12], 2
  003f4	73 05		 jae	 SHORT $LN914@Load
  003f6	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  003f9	eb 04		 jmp	 SHORT $LN913@Load
$LN914@Load:
  003fb	8b d1		 mov	 edx, ecx
  003fd	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN913@Load:
  003ff	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  00402	74 ec		 je	 SHORT $LL916@Load
$LN915@Load:
  00404	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00407	89 55 e0	 mov	 DWORD PTR __Where$211466[ebp], edx
  0040a	3b d0		 cmp	 edx, eax
  0040c	74 0b		 je	 SHORT $LN909@Load
  0040e	83 7a 0c 02	 cmp	 DWORD PTR [edx+12], 2
  00412	77 05		 ja	 SHORT $LN909@Load
  00414	8d 4d e0	 lea	 ecx, DWORD PTR __Where$211466[ebp]
  00417	eb 06		 jmp	 SHORT $LN910@Load
$LN909@Load:
  00419	89 45 ec	 mov	 DWORD PTR $T211395[ebp], eax
  0041c	8d 4d ec	 lea	 ecx, DWORD PTR $T211395[ebp]
$LN910@Load:
  0041f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00421	3b c8		 cmp	 ecx, eax
  00423	75 05		 jne	 SHORT $LN904@Load
  00425	83 c8 ff	 or	 eax, -1
  00428	eb 14		 jmp	 SHORT $LN905@Load
$LN904@Load:
  0042a	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  0042e	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00431	72 02		 jb	 SHORT $LN1015@Load
  00433	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1015@Load:
  00435	50		 push	 eax
  00436	e8 00 00 00 00	 call	 _atoi
  0043b	83 c4 04	 add	 esp, 4
$LN905@Load:
  0043e	47		 inc	 edi
  0043f	89 86 1c 0e 00
	00		 mov	 DWORD PTR [esi+3612], eax
  00445	3b 7d a4	 cmp	 edi, DWORD PTR _section$[ebp+16]
  00448	0f 8c b2 fe ff
	ff		 jl	 $LL9@Load

; 218  : 	{
; 219  : 		for(i = 0; i < section.RowCount; i++)

  0044e	8b 4d ac	 mov	 ecx, DWORD PTR _group$[ebp+4]
$LN7@Load:

; 224  : 		}
; 225  : 	}
; 226  : 	if(group.GetSection(2, section))

  00451	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00454	8b d1		 mov	 edx, ecx
  00456	be 02 00 00 00	 mov	 esi, 2
  0045b	38 58 25	 cmp	 BYTE PTR [eax+37], bl
  0045e	75 13		 jne	 SHORT $LN1029@Load
$LL1030@Load:
  00460	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  00463	73 05		 jae	 SHORT $LN1028@Load
  00465	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00468	eb 04		 jmp	 SHORT $LN1027@Load
$LN1028@Load:
  0046a	8b d0		 mov	 edx, eax
  0046c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1027@Load:
  0046e	38 58 25	 cmp	 BYTE PTR [eax+37], bl
  00471	74 ed		 je	 SHORT $LL1030@Load
$LN1029@Load:
  00473	89 55 e0	 mov	 DWORD PTR __Where$212116[ebp], edx
  00476	3b d1		 cmp	 edx, ecx
  00478	74 0a		 je	 SHORT $LN1023@Load
  0047a	39 72 0c	 cmp	 DWORD PTR [edx+12], esi
  0047d	77 05		 ja	 SHORT $LN1023@Load
  0047f	8d 45 e0	 lea	 eax, DWORD PTR __Where$212116[ebp]
  00482	eb 06		 jmp	 SHORT $LN1024@Load
$LN1023@Load:
  00484	89 4d e4	 mov	 DWORD PTR $T212121[ebp], ecx
  00487	8d 45 e4	 lea	 eax, DWORD PTR $T212121[ebp]
$LN1024@Load:
  0048a	8b 00		 mov	 eax, DWORD PTR [eax]
  0048c	3b c1		 cmp	 eax, ecx
  0048e	0f 84 94 02 00
	00		 je	 $LN3@Load
  00494	8d 70 10	 lea	 esi, DWORD PTR [eax+16]
  00497	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  0049a	3b ce		 cmp	 ecx, esi
  0049c	74 1c		 je	 SHORT $LN1115@Load
  0049e	8b 45 98	 mov	 eax, DWORD PTR _section$[ebp+4]
  004a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  004a3	50		 push	 eax
  004a4	51		 push	 ecx
  004a5	8d 55 d4	 lea	 edx, DWORD PTR $T212082[ebp]
  004a8	52		 push	 edx
  004a9	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  004ac	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  004b1	56		 push	 esi
  004b2	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  004b5	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
$LN1115@Load:
  004ba	8b 76 10	 mov	 esi, DWORD PTR [esi+16]

; 227  : 	{
; 228  : 		for(i = 0; i < section.RowCount; i++)

  004bd	33 ff		 xor	 edi, edi
  004bf	89 75 a4	 mov	 DWORD PTR _section$[ebp+16], esi
  004c2	3b f3		 cmp	 esi, ebx
  004c4	0f 8e 5e 02 00
	00		 jle	 $LN3@Load
  004ca	8d 9b 00 00 00
	00		 npad	 6
$LL5@Load:

; 229  : 		{
; 230  : 			iBridgeNum = section.Rows[i].GetInt(0);

  004d0	8d 45 e0	 lea	 eax, DWORD PTR $T206588[ebp]
  004d3	50		 push	 eax
  004d4	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  004d7	89 7d e0	 mov	 DWORD PTR $T206588[ebp], edi
  004da	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  004df	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  004e2	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  004e5	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  004e8	75 0f		 jne	 SHORT $LN1154@Load
  004ea	8d 9b 00 00 00
	00		 npad	 6
$LL1155@Load:
  004f0	8b d1		 mov	 edx, ecx
  004f2	8b 09		 mov	 ecx, DWORD PTR [ecx]
  004f4	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  004f7	74 f7		 je	 SHORT $LL1155@Load
$LN1154@Load:
  004f9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004fc	89 55 e0	 mov	 DWORD PTR __Where$212707[ebp], edx
  004ff	3b d0		 cmp	 edx, eax
  00501	74 0a		 je	 SHORT $LN1148@Load
  00503	39 5a 0c	 cmp	 DWORD PTR [edx+12], ebx
  00506	77 05		 ja	 SHORT $LN1148@Load
  00508	8d 4d e0	 lea	 ecx, DWORD PTR __Where$212707[ebp]
  0050b	eb 06		 jmp	 SHORT $LN1149@Load
$LN1148@Load:
  0050d	89 45 e4	 mov	 DWORD PTR $T212636[ebp], eax
  00510	8d 4d e4	 lea	 ecx, DWORD PTR $T212636[ebp]
$LN1149@Load:
  00513	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00515	3b c8		 cmp	 ecx, eax
  00517	0f 84 35 01 00
	00		 je	 $LN2@Load
  0051d	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  00521	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00524	72 02		 jb	 SHORT $LN1254@Load
  00526	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1254@Load:
  00528	50		 push	 eax
  00529	e8 00 00 00 00	 call	 _atoi
  0052e	8b f0		 mov	 esi, eax
  00530	83 c4 04	 add	 esp, 4

; 231  : 
; 232  : 			if ( BC_BRIDGE_RANGE(iBridgeNum) != FALSE )

  00533	3b f3		 cmp	 esi, ebx
  00535	0f 8c 17 01 00
	00		 jl	 $LN2@Load
  0053b	33 c0		 xor	 eax, eax
  0053d	83 fe 06	 cmp	 esi, 6
  00540	0f 9e c0	 setle	 al
  00543	3b c3		 cmp	 eax, ebx
  00545	0f 84 07 01 00
	00		 je	 $LN2@Load

; 233  : 			{
; 234  : 				this->m_BridgeData[iBridgeNum].m_iCastleStatueHealth = section.Rows[i].GetInt(1);

  0054b	8d 4d e0	 lea	 ecx, DWORD PTR $T206591[ebp]
  0054e	51		 push	 ecx
  0054f	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  00552	89 7d e0	 mov	 DWORD PTR $T206591[ebp], edi
  00555	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  0055a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0055d	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00560	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  00563	75 14		 jne	 SHORT $LN1268@Load
$LL1269@Load:
  00565	83 79 0c 01	 cmp	 DWORD PTR [ecx+12], 1
  00569	73 05		 jae	 SHORT $LN1267@Load
  0056b	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0056e	eb 04		 jmp	 SHORT $LN1266@Load
$LN1267@Load:
  00570	8b d1		 mov	 edx, ecx
  00572	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1266@Load:
  00574	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  00577	74 ec		 je	 SHORT $LL1269@Load
$LN1268@Load:
  00579	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0057c	89 55 e0	 mov	 DWORD PTR __Where$213282[ebp], edx
  0057f	3b d0		 cmp	 edx, eax
  00581	74 0b		 je	 SHORT $LN1262@Load
  00583	83 7a 0c 01	 cmp	 DWORD PTR [edx+12], 1
  00587	77 05		 ja	 SHORT $LN1262@Load
  00589	8d 4d e0	 lea	 ecx, DWORD PTR __Where$213282[ebp]
  0058c	eb 06		 jmp	 SHORT $LN1263@Load
$LN1262@Load:
  0058e	89 45 e8	 mov	 DWORD PTR $T213287[ebp], eax
  00591	8d 4d e8	 lea	 ecx, DWORD PTR $T213287[ebp]
$LN1263@Load:
  00594	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00596	3b c8		 cmp	 ecx, eax
  00598	75 09		 jne	 SHORT $LN1257@Load
  0059a	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR $T213297[ebp], -1
  005a1	eb 17		 jmp	 SHORT $LN1258@Load
$LN1257@Load:
  005a3	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  005a7	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  005aa	72 02		 jb	 SHORT $LN1368@Load
  005ac	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1368@Load:
  005ae	50		 push	 eax
  005af	e8 00 00 00 00	 call	 _atoi
  005b4	83 c4 04	 add	 esp, 4
  005b7	89 45 ec	 mov	 DWORD PTR $T213297[ebp], eax
$LN1258@Load:
  005ba	db 45 ec	 fild	 DWORD PTR $T213297[ebp]
  005bd	c1 e6 09	 shl	 esi, 9
  005c0	03 75 f0	 add	 esi, DWORD PTR _this$[ebp]

; 235  : 				this->m_BridgeData[iBridgeNum].m_iCastleDoorHealth   = section.Rows[i].GetInt(2);

  005c3	8d 45 e0	 lea	 eax, DWORD PTR $T206592[ebp]
  005c6	50		 push	 eax
  005c7	d9 9e 6c 01 00
	00		 fstp	 DWORD PTR [esi+364]
  005cd	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  005d0	89 7d e0	 mov	 DWORD PTR $T206592[ebp], edi
  005d3	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  005d8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  005db	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  005de	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  005e1	75 14		 jne	 SHORT $LN1382@Load
$LL1383@Load:
  005e3	83 79 0c 02	 cmp	 DWORD PTR [ecx+12], 2
  005e7	73 05		 jae	 SHORT $LN1381@Load
  005e9	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  005ec	eb 04		 jmp	 SHORT $LN1380@Load
$LN1381@Load:
  005ee	8b d1		 mov	 edx, ecx
  005f0	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1380@Load:
  005f2	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  005f5	74 ec		 je	 SHORT $LL1383@Load
$LN1382@Load:
  005f7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  005fa	89 55 e0	 mov	 DWORD PTR __Where$213792[ebp], edx
  005fd	3b d0		 cmp	 edx, eax
  005ff	74 0b		 je	 SHORT $LN1376@Load
  00601	83 7a 0c 02	 cmp	 DWORD PTR [edx+12], 2
  00605	77 05		 ja	 SHORT $LN1376@Load
  00607	8d 4d e0	 lea	 ecx, DWORD PTR __Where$213792[ebp]
  0060a	eb 06		 jmp	 SHORT $LN1377@Load
$LN1376@Load:
  0060c	89 45 dc	 mov	 DWORD PTR $T213721[ebp], eax
  0060f	8d 4d dc	 lea	 ecx, DWORD PTR $T213721[ebp]
$LN1377@Load:
  00612	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00614	3b c8		 cmp	 ecx, eax
  00616	75 15		 jne	 SHORT $LN1371@Load
  00618	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR $T213840[ebp], -1
  0061f	db 45 ec	 fild	 DWORD PTR $T213840[ebp]
  00622	d9 9e 70 01 00
	00		 fstp	 DWORD PTR [esi+368]

; 236  : 				iBridgeNum++;
; 237  : 			}
; 238  : 			else

  00628	e9 f1 00 00 00	 jmp	 $LN4@Load

; 235  : 				this->m_BridgeData[iBridgeNum].m_iCastleDoorHealth   = section.Rows[i].GetInt(2);

$LN1371@Load:
  0062d	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  00631	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00634	72 02		 jb	 SHORT $LN1482@Load
  00636	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1482@Load:
  00638	50		 push	 eax
  00639	e8 00 00 00 00	 call	 _atoi
  0063e	89 45 ec	 mov	 DWORD PTR $T213840[ebp], eax
  00641	db 45 ec	 fild	 DWORD PTR $T213840[ebp]
  00644	83 c4 04	 add	 esp, 4
  00647	d9 9e 70 01 00
	00		 fstp	 DWORD PTR [esi+368]

; 236  : 				iBridgeNum++;
; 237  : 			}
; 238  : 			else

  0064d	e9 cc 00 00 00	 jmp	 $LN4@Load
$LN2@Load:

; 239  : 			{
; 240  : 				null = section.Rows[i].GetInt(1);

  00652	8d 4d e0	 lea	 ecx, DWORD PTR $T206593[ebp]
  00655	51		 push	 ecx
  00656	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  00659	89 7d e0	 mov	 DWORD PTR $T206593[ebp], edi
  0065c	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  00661	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00664	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00667	be 01 00 00 00	 mov	 esi, 1
  0066c	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  0066f	75 13		 jne	 SHORT $LN1496@Load
$LL1497@Load:
  00671	39 71 0c	 cmp	 DWORD PTR [ecx+12], esi
  00674	73 05		 jae	 SHORT $LN1495@Load
  00676	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00679	eb 04		 jmp	 SHORT $LN1494@Load
$LN1495@Load:
  0067b	8b d1		 mov	 edx, ecx
  0067d	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1494@Load:
  0067f	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  00682	74 ed		 je	 SHORT $LL1497@Load
$LN1496@Load:
  00684	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00687	89 55 e0	 mov	 DWORD PTR __Where$214277[ebp], edx
  0068a	3b d0		 cmp	 edx, eax
  0068c	74 0a		 je	 SHORT $LN1490@Load
  0068e	39 72 0c	 cmp	 DWORD PTR [edx+12], esi
  00691	77 05		 ja	 SHORT $LN1490@Load
  00693	8d 4d e0	 lea	 ecx, DWORD PTR __Where$214277[ebp]
  00696	eb 06		 jmp	 SHORT $LN1491@Load
$LN1490@Load:
  00698	89 45 d8	 mov	 DWORD PTR $T214282[ebp], eax
  0069b	8d 4d d8	 lea	 ecx, DWORD PTR $T214282[ebp]
$LN1491@Load:
  0069e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  006a0	3b c8		 cmp	 ecx, eax
  006a2	74 14		 je	 SHORT $LN1486@Load
  006a4	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  006a8	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  006ab	72 02		 jb	 SHORT $LN1596@Load
  006ad	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1596@Load:
  006af	50		 push	 eax
  006b0	e8 00 00 00 00	 call	 _atoi
  006b5	83 c4 04	 add	 esp, 4
$LN1486@Load:

; 241  : 				null = section.Rows[i].GetInt(2);

  006b8	8d 55 e0	 lea	 edx, DWORD PTR $T206594[ebp]
  006bb	52		 push	 edx
  006bc	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  006bf	89 7d e0	 mov	 DWORD PTR $T206594[ebp], edi
  006c2	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  006c7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  006ca	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  006cd	be 02 00 00 00	 mov	 esi, 2
  006d2	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  006d5	75 13		 jne	 SHORT $LN1610@Load
$LL1611@Load:
  006d7	39 71 0c	 cmp	 DWORD PTR [ecx+12], esi
  006da	73 05		 jae	 SHORT $LN1609@Load
  006dc	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  006df	eb 04		 jmp	 SHORT $LN1608@Load
$LN1609@Load:
  006e1	8b d1		 mov	 edx, ecx
  006e3	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1608@Load:
  006e5	38 59 2d	 cmp	 BYTE PTR [ecx+45], bl
  006e8	74 ed		 je	 SHORT $LL1611@Load
$LN1610@Load:
  006ea	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  006ed	89 55 e0	 mov	 DWORD PTR __Where$214877[ebp], edx
  006f0	3b d0		 cmp	 edx, eax
  006f2	74 0a		 je	 SHORT $LN1604@Load
  006f4	39 72 0c	 cmp	 DWORD PTR [edx+12], esi
  006f7	77 05		 ja	 SHORT $LN1604@Load
  006f9	8d 4d e0	 lea	 ecx, DWORD PTR __Where$214877[ebp]
  006fc	eb 06		 jmp	 SHORT $LN1605@Load
$LN1604@Load:
  006fe	89 45 d4	 mov	 DWORD PTR $T214806[ebp], eax
  00701	8d 4d d4	 lea	 ecx, DWORD PTR $T214806[ebp]
$LN1605@Load:
  00704	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00706	3b c8		 cmp	 ecx, eax
  00708	74 14		 je	 SHORT $LN4@Load
  0070a	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  0070e	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00711	72 02		 jb	 SHORT $LN1710@Load
  00713	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1710@Load:
  00715	50		 push	 eax
  00716	e8 00 00 00 00	 call	 _atoi
  0071b	83 c4 04	 add	 esp, 4
$LN4@Load:

; 227  : 	{
; 228  : 		for(i = 0; i < section.RowCount; i++)

  0071e	47		 inc	 edi
  0071f	3b 7d a4	 cmp	 edi, DWORD PTR _section$[ebp+16]
  00722	0f 8c a8 fd ff
	ff		 jl	 $LL5@Load
$LN3@Load:

; 242  : 			}
; 243  : 		}
; 244  : 	}
; 245  : 
; 246  : 	LogAdd(LOG_BLACK, "%s file load!", filename);

  00728	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0072b	50		 push	 eax
  0072c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  00731	53		 push	 ebx
  00732	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00737	83 c4 0c	 add	 esp, 12			; 0000000cH

; 247  : 
; 248  : 	return TRUE;

  0073a	8b 45 98	 mov	 eax, DWORD PTR _section$[ebp+4]
  0073d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0073f	50		 push	 eax
  00740	51		 push	 ecx
  00741	8d 4d 08	 lea	 ecx, DWORD PTR $T215163[ebp]
  00744	51		 push	 ecx
  00745	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  00748	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0074c	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00751	8b 55 98	 mov	 edx, DWORD PTR _section$[ebp+4]
  00754	52		 push	 edx
  00755	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0075a	83 c4 04	 add	 esp, 4
  0075d	8b 45 ac	 mov	 eax, DWORD PTR _group$[ebp+4]
  00760	8b 08		 mov	 ecx, DWORD PTR [eax]
  00762	50		 push	 eax
  00763	51		 push	 ecx
  00764	8d 45 08	 lea	 eax, DWORD PTR $T215401[ebp]
  00767	50		 push	 eax
  00768	8d 4d a8	 lea	 ecx, DWORD PTR _group$[ebp]
  0076b	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00772	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
  00777	8b 4d ac	 mov	 ecx, DWORD PTR _group$[ebp+4]
  0077a	51		 push	 ecx
  0077b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00780	83 c4 04	 add	 esp, 4
  00783	b8 01 00 00 00	 mov	 eax, 1

; 249  : }

  00788	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0078b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00792	59		 pop	 ecx
  00793	5f		 pop	 edi
  00794	5e		 pop	 esi
  00795	5b		 pop	 ebx
  00796	8b e5		 mov	 esp, ebp
  00798	5d		 pop	 ebp
  00799	c2 04 00	 ret	 4

; 197  : 	TokenizerSection   section;

$LN100@Load:
  0079c	8d 55 d0	 lea	 edx, DWORD PTR $T206911[ebp]
  0079f	52		 push	 edx
  007a0	8d 4d c4	 lea	 ecx, DWORD PTR $T207105[ebp]
  007a3	89 5d d0	 mov	 DWORD PTR $T206911[ebp], ebx
  007a6	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  007ab	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  007b0	8d 45 c4	 lea	 eax, DWORD PTR $T207105[ebp]
  007b3	50		 push	 eax
  007b4	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T207105[ebp], OFFSET ??_7bad_alloc@std@@6B@
  007bb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1822@Load:

; 195  : 	Tokenizer          token;
; 196  : 	TokenizerGroup     group;

$LN49@Load:
  007c0	8d 4d d4	 lea	 ecx, DWORD PTR $T206646[ebp]
  007c3	51		 push	 ecx
  007c4	8d 4d b8	 lea	 ecx, DWORD PTR $T206850[ebp]
  007c7	89 5d d4	 mov	 DWORD PTR $T206646[ebp], ebx
  007ca	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  007cf	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  007d4	8d 55 b8	 lea	 edx, DWORD PTR $T206850[ebp]
  007d7	52		 push	 edx
  007d8	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T206850[ebp], OFFSET ??_7bad_alloc@std@@6B@
  007df	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1823@Load:
$LN1821@Load:
  007e4	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Load@CBloodCastle@@QAEHPAD@Z$0:
  00000	8d 4d a8	 lea	 ecx, DWORD PTR _group$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TokenizerGroup@@QAE@XZ
__unwindfunclet$?Load@CBloodCastle@@QAEHPAD@Z$1:
  00008	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1TokenizerSection@@QAE@XZ
__unwindfunclet$?Load@CBloodCastle@@QAEHPAD@Z$11:
  00010	8d 4d 94	 lea	 ecx, DWORD PTR _section$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__unwindfunclet$?Load@CBloodCastle@@QAEHPAD@Z$14:
  00018	8d 4d a8	 lea	 ecx, DWORD PTR _group$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
__ehhandler$?Load@CBloodCastle@@QAEHPAD@Z:
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CBloodCastle@@QAEHPAD@Z
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CBloodCastle@@QAEHPAD@Z ENDP			; CBloodCastle::Load
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_BloodCastle@@YAXXZ
text$yc	SEGMENT
??__Eg_BloodCastle@@YAXXZ PROC				; `dynamic initializer for 'g_BloodCastle'', COMDAT

; 16   : CBloodCastle g_BloodCastle;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00005	e8 00 00 00 00	 call	 ??0CBloodCastle@@QAE@XZ	; CBloodCastle::CBloodCastle
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_BloodCastle@@YAXXZ ; `dynamic atexit destructor for 'g_BloodCastle''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_BloodCastle@@YAXXZ ENDP				; `dynamic initializer for 'g_BloodCastle''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_BloodCastle@@YAXXZ
text$yd	SEGMENT
??__Fg_BloodCastle@@YAXXZ PROC				; `dynamic atexit destructor for 'g_BloodCastle'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00005	e9 00 00 00 00	 jmp	 ??1CBloodCastle@@UAE@XZ	; CBloodCastle::~CBloodCastle
??__Fg_BloodCastle@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_BloodCastle''
text$yd	ENDS
PUBLIC	?id@?$codecvt@DDH@std@@2V0locale@2@A		; std::codecvt<char,char,int>::id
PUBLIC	?g_BloodCastle@@3VCBloodCastle@@A		; g_BloodCastle
;	COMDAT ?id@?$codecvt@DDH@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDH@std@@2V0locale@2@A DD 01H DUP (?)	; std::codecvt<char,char,int>::id
_BSS	ENDS
_BSS	SEGMENT
?g_BloodCastle@@3VCBloodCastle@@A DB 0e20H DUP (?)	; g_BloodCastle
_BSS	ENDS
CRT$XCU	SEGMENT
_g_BloodCastle$initializer$ DD FLAT:??__Eg_BloodCastle@@YAXXZ
CRT$XCU	ENDS
END
