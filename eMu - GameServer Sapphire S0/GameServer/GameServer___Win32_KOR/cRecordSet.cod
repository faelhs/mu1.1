; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\cRecordSet.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ReplaceSingleQuotes@CRecordSet@@QAEXPADH@Z	; CRecordSet::ReplaceSingleQuotes
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\crecordset.cpp
;	COMDAT ?ReplaceSingleQuotes@CRecordSet@@QAEXPADH@Z
_TEXT	SEGMENT
_sData$ = 8						; size = 4
_iDataSz$ = 12						; size = 4
?ReplaceSingleQuotes@CRecordSet@@QAEXPADH@Z PROC	; CRecordSet::ReplaceSingleQuotes, COMDAT
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 22   :     int iRPos = 0;
; 23   : 
; 24   :     while(iRPos < iDataSz)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _iDataSz$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 d2		 test	 edx, edx
  0000a	7e 13		 jle	 SHORT $LN2@ReplaceSin
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _sData$[ebp]
  0000f	90		 npad	 1
$LL3@ReplaceSin:

; 25   :     {
; 26   :         if(sData[iRPos] == '\'')

  00010	80 3c 08 27	 cmp	 BYTE PTR [eax+ecx], 39	; 00000027H
  00014	75 04		 jne	 SHORT $LN1@ReplaceSin

; 27   : 		{
; 28   :             sData[iRPos] = '`';

  00016	c6 04 08 60	 mov	 BYTE PTR [eax+ecx], 96	; 00000060H
$LN1@ReplaceSin:

; 29   : 		}
; 30   :         iRPos++;

  0001a	40		 inc	 eax
  0001b	3b c2		 cmp	 eax, edx
  0001d	7c f1		 jl	 SHORT $LL3@ReplaceSin
$LN2@ReplaceSin:

; 31   :     }
; 32   : }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?ReplaceSingleQuotes@CRecordSet@@QAEXPADH@Z ENDP	; CRecordSet::ReplaceSingleQuotes
_TEXT	ENDS
PUBLIC	?RTrim@CRecordSet@@QAEHPADH@Z			; CRecordSet::RTrim
; Function compile flags: /Ogtp
;	COMDAT ?RTrim@CRecordSet@@QAEHPADH@Z
_TEXT	SEGMENT
_sData$ = 8						; size = 4
_iDataSz$ = 12						; size = 4
?RTrim@CRecordSet@@QAEHPADH@Z PROC			; CRecordSet::RTrim, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   :     int iPos = iDataSz;
; 39   : 
; 40   :     if(iDataSz == 0)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iDataSz$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN5@RTrim

; 55   : 
; 56   :     return iPos; //Return the new data length.
; 57   : }

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
$LN5@RTrim:

; 41   :         return iDataSz;//Return the new data length.
; 42   : 
; 43   :     if(sData[iDataSz-1] != ' ')

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _sData$[ebp]
  00011	80 7c 01 ff 20	 cmp	 BYTE PTR [ecx+eax-1], 32 ; 00000020H

; 44   :         return iDataSz;//Return the new data length.

  00016	75 1c		 jne	 SHORT $LN6@RTrim

; 45   : 
; 46   :     iPos--;

  00018	48		 dec	 eax

; 47   : 
; 48   :     while(iPos != 0 && sData[iPos] == ' ')

  00019	74 0e		 je	 SHORT $LN2@RTrim
  0001b	eb 03 8d 49 00	 npad	 5
$LL3@RTrim:
  00020	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  00024	75 09		 jne	 SHORT $LN11@RTrim

; 49   :         iPos--;

  00026	48		 dec	 eax

; 47   : 
; 48   :     while(iPos != 0 && sData[iPos] == ' ')

  00027	75 f7		 jne	 SHORT $LL3@RTrim
$LN2@RTrim:

; 50   : 
; 51   :     if(sData[iPos] != ' ')

  00029	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  0002d	74 01		 je	 SHORT $LN1@RTrim
$LN11@RTrim:

; 52   :         iPos++;

  0002f	40		 inc	 eax
$LN1@RTrim:

; 53   : 
; 54   :     sData[iPos] = '\0';

  00030	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
$LN6@RTrim:

; 55   : 
; 56   :     return iPos; //Return the new data length.
; 57   : }

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
?RTrim@CRecordSet@@QAEHPADH@Z ENDP			; CRecordSet::RTrim
_TEXT	ENDS
PUBLIC	?Reset@CRecordSet@@QAE_NXZ			; CRecordSet::Reset
EXTRN	_SQLFreeStmt@8:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Reset@CRecordSet@@QAE_NXZ
_TEXT	SEGMENT
?Reset@CRecordSet@@QAE_NXZ PROC				; CRecordSet::Reset, COMDAT
; _this$ = ecx

; 62   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 63   : 	bool bResult = false;
; 64   : 
; 65   : 	bResult = (SQLFreeStmt(this->hSTMT, SQL_UNBIND) == SQL_SUCCESS);

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	6a 02		 push	 2
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _SQLFreeStmt@8

; 66   : 	bResult = (SQLFreeStmt(this->hSTMT, SQL_RESET_PARAMS) == SQL_SUCCESS);

  0000e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00011	6a 03		 push	 3
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 _SQLFreeStmt@8
  00019	66 85 c0	 test	 ax, ax
  0001c	0f 94 c0	 sete	 al
  0001f	5e		 pop	 esi

; 67   : 
; 68   : 	return bResult;
; 69   : }

  00020	c3		 ret	 0
?Reset@CRecordSet@@QAE_NXZ ENDP				; CRecordSet::Reset
_TEXT	ENDS
PUBLIC	?Close@CRecordSet@@QAE_NXZ			; CRecordSet::Close
EXTRN	_SQLFreeHandle@8:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Close@CRecordSet@@QAE_NXZ
_TEXT	SEGMENT
?Close@CRecordSet@@QAE_NXZ PROC				; CRecordSet::Close, COMDAT
; _this$ = ecx

; 74   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 75   : 	bool bResult = (SQLFreeHandle(SQL_HANDLE_STMT, this->hSTMT) == SQL_SUCCESS);

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	50		 push	 eax
  00007	6a 03		 push	 3
  00009	e8 00 00 00 00	 call	 _SQLFreeHandle@8
  0000e	66 85 c0	 test	 ax, ax
  00011	0f 94 c0	 sete	 al

; 76   : 
; 77   : 	this->RowCount = 0;

  00014	33 c9		 xor	 ecx, ecx
  00016	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 78   : 	this->ColumnCount = 0;

  00019	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx

; 79   : 	this->hSTMT = NULL;

  0001c	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0001f	5e		 pop	 esi

; 80   : 
; 81   : 	return bResult;
; 82   : }

  00020	c3		 ret	 0
?Close@CRecordSet@@QAE_NXZ ENDP				; CRecordSet::Close
_TEXT	ENDS
PUBLIC	?GetColumnInfo@CRecordSet@@QAE_NHPADHPAH1111@Z	; CRecordSet::GetColumnInfo
EXTRN	_SQLDescribeColA@36:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GetColumnInfo@CRecordSet@@QAE_NHPADHPAH1111@Z
_TEXT	SEGMENT
_iCol$ = 8						; size = 4
_sOutName$ = 12						; size = 4
_iSzOfOutName$ = 16					; size = 4
_iOutColNameLen$ = 20					; size = 4
_ioutDataType$ = 24					; size = 4
_iOutColSize$ = 28					; size = 4
_iNumOfDeciPlaces$ = 32					; size = 4
_iColNullable$ = 36					; size = 4
?GetColumnInfo@CRecordSet@@QAE_NHPADHPAH1111@Z PROC	; CRecordSet::GetColumnInfo, COMDAT
; _this$ = ecx

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 150  : 	if(SQL_SUCCEEDED(SQLDescribeColA(this->hSTMT, iCol, (SQLCHAR *)sOutName, (SQLSMALLINT)iSzOfOutName,
; 151  : 		(SQLSMALLINT *)iOutColNameLen, (SQLSMALLINT *)ioutDataType, (SQLUINTEGER *)iOutColSize,
; 152  : 		(SQLSMALLINT *)iNumOfDeciPlaces, (SQLSMALLINT *)iColNullable)))

  00003	8b 45 24	 mov	 eax, DWORD PTR _iColNullable$[ebp]
  00006	8b 55 20	 mov	 edx, DWORD PTR _iNumOfDeciPlaces$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 1c	 mov	 eax, DWORD PTR _iOutColSize$[ebp]
  0000d	52		 push	 edx
  0000e	8b 55 18	 mov	 edx, DWORD PTR _ioutDataType$[ebp]
  00011	50		 push	 eax
  00012	8b 45 14	 mov	 eax, DWORD PTR _iOutColNameLen$[ebp]
  00015	52		 push	 edx
  00016	8b 55 10	 mov	 edx, DWORD PTR _iSzOfOutName$[ebp]
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR _sOutName$[ebp]
  0001d	52		 push	 edx
  0001e	8b 55 08	 mov	 edx, DWORD PTR _iCol$[ebp]
  00021	50		 push	 eax
  00022	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00025	52		 push	 edx
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _SQLDescribeColA@36
  0002c	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  00030	0f 94 c0	 sete	 al

; 153  : 	{
; 154  : 		return true;
; 155  : 	}
; 156  : 	else return false;
; 157  : }

  00033	5d		 pop	 ebp
  00034	c2 20 00	 ret	 32			; 00000020H
?GetColumnInfo@CRecordSet@@QAE_NHPADHPAH1111@Z ENDP	; CRecordSet::GetColumnInfo
_TEXT	ENDS
PUBLIC	??0CRecordSet@@QAE@XZ				; CRecordSet::CRecordSet
; Function compile flags: /Ogtp
;	COMDAT ??0CRecordSet@@QAE@XZ
_TEXT	SEGMENT
??0CRecordSet@@QAE@XZ PROC				; CRecordSet::CRecordSet, COMDAT
; _this$ = ecx

; 322  : {

  00000	8b c1		 mov	 eax, ecx

; 323  : 	this->hSTMT = NULL;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 324  : 	this->RowCount = 0;

  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 325  : 	this->ColumnCount = 0;

  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 326  : 
; 327  : 	this->bTrimCharData = true;

  0000d	b1 01		 mov	 cl, 1
  0000f	66 c7 40 10 01
	01		 mov	 WORD PTR [eax+16], 257	; 00000101H

; 328  : 	this->bReplaceSingleQuotes = true;
; 329  : 	this->bThrowErrors = true;

  00015	88 48 12	 mov	 BYTE PTR [eax+18], cl

; 330  : }

  00018	c3		 ret	 0
??0CRecordSet@@QAE@XZ ENDP				; CRecordSet::CRecordSet
_TEXT	ENDS
PUBLIC	??1CRecordSet@@QAE@XZ				; CRecordSet::~CRecordSet
; Function compile flags: /Ogtp
;	COMDAT ??1CRecordSet@@QAE@XZ
_TEXT	SEGMENT
??1CRecordSet@@QAE@XZ PROC				; CRecordSet::~CRecordSet, COMDAT
; _this$ = ecx

; 336  : 	this->hSTMT = NULL;

  00000	33 c0		 xor	 eax, eax
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 337  : 	this->RowCount = 0;

  00005	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 338  : 	this->ColumnCount = 0;

  00008	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 339  : }

  0000b	c3		 ret	 0
??1CRecordSet@@QAE@XZ ENDP				; CRecordSet::~CRecordSet
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetErrorMessage@CRecordSet@@QAE_NPAHPADH@Z	; CRecordSet::GetErrorMessage
EXTRN	_SQLErrorA@32:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GetErrorMessage@CRecordSet@@QAE_NPAHPADH@Z
_TEXT	SEGMENT
_iOutErrorMsgSz$ = -28					; size = 2
_sSQLState$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_iOutErr$ = 8						; size = 4
_sOutError$ = 12					; size = 4
_iErrBufSz$ = 16					; size = 4
?GetErrorMessage@CRecordSet@@QAE_NPAHPADH@Z PROC	; CRecordSet::GetErrorMessage, COMDAT
; _this$ = ecx

; 344  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 0c	 mov	 edx, DWORD PTR _sOutError$[ebp]
  00013	8b 45 08	 mov	 eax, DWORD PTR _iOutErr$[ebp]

; 345  : 	SQLCHAR     sSQLState[20];
; 346  : 	SQLSMALLINT iOutErrorMsgSz;
; 347  : 
; 348  : 	return SQL_SUCCEEDED(SQLErrorA(NULL, NULL, this->hSTMT, sSQLState,
; 349  : 		(SQLINTEGER *)iOutErr, (SQLCHAR *)sOutError, iErrBufSz, &iOutErrorMsgSz));

  00016	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00019	56		 push	 esi
  0001a	8d 75 e4	 lea	 esi, DWORD PTR _iOutErrorMsgSz$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 10	 mov	 esi, DWORD PTR _iErrBufSz$[ebp]
  00021	56		 push	 esi
  00022	52		 push	 edx
  00023	50		 push	 eax
  00024	8d 45 e8	 lea	 eax, DWORD PTR _sSQLState$[ebp]
  00027	50		 push	 eax
  00028	51		 push	 ecx
  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	e8 00 00 00 00	 call	 _SQLErrorA@32

; 350  : }

  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  00039	b8 00 00 00 00	 mov	 eax, 0
  0003e	0f 94 c0	 sete	 al
  00041	33 cd		 xor	 ecx, ebp
  00043	5e		 pop	 esi
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 0c 00	 ret	 12			; 0000000cH
?GetErrorMessage@CRecordSet@@QAE_NPAHPADH@Z ENDP	; CRecordSet::GetErrorMessage
_TEXT	ENDS
PUBLIC	??_C@_0L@KFPCFAAF@CRecordSet?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ThrowError@CRecordSet@@QAE_NXZ			; CRecordSet::ThrowError
;	COMDAT ??_C@_0L@KFPCFAAF@CRecordSet?$AA@
CONST	SEGMENT
??_C@_0L@KFPCFAAF@CRecordSet?$AA@ DB 'CRecordSet', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ThrowError@CRecordSet@@QAE_NXZ
_TEXT	SEGMENT
_iNativeError$ = -2056					; size = 4
_sErrorMsg$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
?ThrowError@CRecordSet@@QAE_NXZ PROC			; CRecordSet::ThrowError, COMDAT
; _this$ = ecx

; 367  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 08 00
	00		 sub	 esp, 2056		; 00000808H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 368  : 	char sErrorMsg[2048];
; 369  : 	int iNativeError = 0;
; 370  : 
; 371  : 	if(this->GetErrorMessage(&iNativeError, sErrorMsg, sizeof(sErrorMsg)))

  00014	68 00 08 00 00	 push	 2048			; 00000800H
  00019	8b f1		 mov	 esi, ecx
  0001b	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _sErrorMsg$[ebp]
  00021	50		 push	 eax
  00022	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _iNativeError$[ebp]
  00028	51		 push	 ecx
  00029	8b ce		 mov	 ecx, esi
  0002b	c7 85 f8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _iNativeError$[ebp], 0
  00035	e8 00 00 00 00	 call	 ?GetErrorMessage@CRecordSet@@QAE_NPAHPADH@Z ; CRecordSet::GetErrorMessage
  0003a	84 c0		 test	 al, al
  0003c	74 2f		 je	 SHORT $LN2@ThrowError

; 372  : 	{
; 373  : 		if(this->pErrorHandler)

  0003e	8b 36		 mov	 esi, DWORD PTR [esi]
  00040	85 f6		 test	 esi, esi
  00042	74 18		 je	 SHORT $LN1@ThrowError

; 374  : 		{
; 375  : 			this->pErrorHandler("CRecordSet", sErrorMsg, iNativeError);

  00044	8b 95 f8 f7 ff
	ff		 mov	 edx, DWORD PTR _iNativeError$[ebp]
  0004a	52		 push	 edx
  0004b	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _sErrorMsg$[ebp]
  00051	50		 push	 eax
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KFPCFAAF@CRecordSet?$AA@
  00057	ff d6		 call	 esi
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ThrowError:

; 376  : 		}
; 377  : 		return true;

  0005c	b0 01		 mov	 al, 1
  0005e	5e		 pop	 esi

; 378  : 	}
; 379  : 
; 380  : 	return false;
; 381  : }

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00062	33 cd		 xor	 ecx, ebp
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
$LN2@ThrowError:
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	33 cd		 xor	 ecx, ebp
  00072	32 c0		 xor	 al, al
  00074	5e		 pop	 esi
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?ThrowError@CRecordSet@@QAE_NXZ ENDP			; CRecordSet::ThrowError
_TEXT	ENDS
PUBLIC	?SetErrorHandler@CRecordSet@@QAEXP6AHPBD0H@Z@Z	; CRecordSet::SetErrorHandler
; Function compile flags: /Ogtp
;	COMDAT ?SetErrorHandler@CRecordSet@@QAEXP6AHPBD0H@Z@Z
_TEXT	SEGMENT
_pHandler$ = 8						; size = 4
?SetErrorHandler@CRecordSet@@QAEXP6AHPBD0H@Z@Z PROC	; CRecordSet::SetErrorHandler, COMDAT
; _this$ = ecx

; 386  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 387  : 	this->pErrorHandler = pHandler;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pHandler$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 388  : }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?SetErrorHandler@CRecordSet@@QAEXP6AHPBD0H@Z@Z ENDP	; CRecordSet::SetErrorHandler
_TEXT	ENDS
PUBLIC	?ThrowErrorIfSet@CRecordSet@@QAE_NXZ		; CRecordSet::ThrowErrorIfSet
; Function compile flags: /Ogtp
;	COMDAT ?ThrowErrorIfSet@CRecordSet@@QAE_NXZ
_TEXT	SEGMENT
?ThrowErrorIfSet@CRecordSet@@QAE_NXZ PROC		; CRecordSet::ThrowErrorIfSet, COMDAT
; _this$ = ecx

; 356  : 	if(this->bThrowErrors)

  00000	80 79 12 00	 cmp	 BYTE PTR [ecx+18], 0
  00004	74 05		 je	 SHORT $LN1@ThrowError@2

; 357  : 	{
; 358  : 		return this->ThrowError();

  00006	e9 00 00 00 00	 jmp	 ?ThrowError@CRecordSet@@QAE_NXZ ; CRecordSet::ThrowError
$LN1@ThrowError@2:

; 359  : 	}
; 360  : 
; 361  : 	return false;

  0000b	32 c0		 xor	 al, al

; 362  : }

  0000d	c3		 ret	 0
?ThrowErrorIfSet@CRecordSet@@QAE_NXZ ENDP		; CRecordSet::ThrowErrorIfSet
_TEXT	ENDS
PUBLIC	?Fetch@CRecordSet@@QAE_NPAH@Z			; CRecordSet::Fetch
EXTRN	_SQLFetch@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Fetch@CRecordSet@@QAE_NPAH@Z
_TEXT	SEGMENT
_iErrorCode$ = 8					; size = 4
?Fetch@CRecordSet@@QAE_NPAH@Z PROC			; CRecordSet::Fetch, COMDAT
; _this$ = ecx

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 88   : 	if(SQL_SUCCEEDED((*iErrorCode = SQLFetch(this->hSTMT))))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _SQLFetch@4
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _iErrorCode$[ebp]
  00012	98		 cwde
  00013	89 01		 mov	 DWORD PTR [ecx], eax
  00015	a9 fe ff ff ff	 test	 eax, -2			; fffffffeH
  0001a	75 07		 jne	 SHORT $LN14@Fetch

; 89   : 	{
; 90   :         return true;

  0001c	b0 01		 mov	 al, 1
  0001e	5e		 pop	 esi

; 120  : 	}
; 121  : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN14@Fetch:

; 91   : 	}
; 92   : 	else {
; 93   : 		char *sErrorType = NULL;
; 94   : 
; 95   : 		if(*iErrorCode == SQL_SUCCESS){

  00023	85 c0		 test	 eax, eax
  00025	74 0a		 je	 SHORT $LN8@Fetch

; 96   : 			sErrorType = "SQL_SUCCESS";
; 97   : 		}
; 98   : 		else if(*iErrorCode == SQL_SUCCESS_WITH_INFO){

  00027	83 f8 01	 cmp	 eax, 1
  0002a	74 05		 je	 SHORT $LN8@Fetch

; 99   : 			sErrorType = "SQL_SUCCESS_WITH_INFO";
; 100  : 		}
; 101  : 		else if(*iErrorCode == SQL_NO_DATA){

  0002c	83 f8 64	 cmp	 eax, 100		; 00000064H

; 102  : 			sErrorType = "SQL_NO_DATA";
; 103  : 			return false;

  0002f	74 07		 je	 SHORT $LN17@Fetch
$LN8@Fetch:

; 104  : 		}
; 105  : 		else if(*iErrorCode == SQL_STILL_EXECUTING){
; 106  : 			sErrorType = "SQL_STILL_EXECUTING";
; 107  : 		}
; 108  : 		else if(*iErrorCode == SQL_ERROR){
; 109  : 			sErrorType = "SQL_ERROR";
; 110  : 		}
; 111  : 		else if(*iErrorCode == SQL_INVALID_HANDLE){
; 112  : 			sErrorType = "SQL_INVALID_HANDLE";
; 113  : 		}
; 114  : 		else{
; 115  : 			sErrorType = "OTHER";
; 116  : 		}
; 117  : 
; 118  : 		this->ThrowErrorIfSet();

  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CRecordSet@@QAE_NXZ ; CRecordSet::ThrowErrorIfSet
$LN17@Fetch:

; 119  : 		return false;

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 120  : 	}
; 121  : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?Fetch@CRecordSet@@QAE_NPAH@Z ENDP			; CRecordSet::Fetch
_TEXT	ENDS
PUBLIC	?Fetch@CRecordSet@@QAE_NXZ			; CRecordSet::Fetch
; Function compile flags: /Ogtp
;	COMDAT ?Fetch@CRecordSet@@QAE_NXZ
_TEXT	SEGMENT
_iErrorCode$ = -4					; size = 4
?Fetch@CRecordSet@@QAE_NXZ PROC				; CRecordSet::Fetch, COMDAT
; _this$ = ecx

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	int iErrorCode = 0;
; 128  : 	return this->Fetch(&iErrorCode);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iErrorCode$[ebp]
  00007	50		 push	 eax
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iErrorCode$[ebp], 0
  0000f	e8 00 00 00 00	 call	 ?Fetch@CRecordSet@@QAE_NPAH@Z ; CRecordSet::Fetch

; 129  : }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?Fetch@CRecordSet@@QAE_NXZ ENDP				; CRecordSet::Fetch
_TEXT	ENDS
PUBLIC	?GetData@CRecordSet@@QAE_NGFPAXJPAJ@Z		; CRecordSet::GetData
EXTRN	_SQLGetData@24:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GetData@CRecordSet@@QAE_NGFPAXJPAJ@Z
_TEXT	SEGMENT
_iCol$ = 8						; size = 2
_iType$ = 12						; size = 2
_pvBuf$ = 16						; size = 4
_iBufSz$ = 20						; size = 4
_piOutBufSz$ = 24					; size = 4
?GetData@CRecordSet@@QAE_NGFPAXJPAJ@Z PROC		; CRecordSet::GetData, COMDAT
; _this$ = ecx

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 135  :     if(SQL_SUCCEEDED(SQLGetData(this->hSTMT, iCol, iType, pvBuf, iBufSz, piOutBufSz)))

  00003	8b 45 18	 mov	 eax, DWORD PTR _piOutBufSz$[ebp]
  00006	8b 55 10	 mov	 edx, DWORD PTR _pvBuf$[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _iType$[ebp]
  0000e	8b f1		 mov	 esi, ecx
  00010	8b 4d 14	 mov	 ecx, DWORD PTR _iBufSz$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _iCol$[ebp]
  00017	52		 push	 edx
  00018	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001b	50		 push	 eax
  0001c	51		 push	 ecx
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _SQLGetData@24
  00023	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  00027	75 07		 jne	 SHORT $LN2@GetData

; 136  : 	{
; 137  : 		return true;

  00029	b0 01		 mov	 al, 1
  0002b	5e		 pop	 esi

; 142  : 	}
; 143  : }

  0002c	5d		 pop	 ebp
  0002d	c2 14 00	 ret	 20			; 00000014H
$LN2@GetData:

; 138  : 	}
; 139  : 	else {
; 140  : 		ThrowErrorIfSet();

  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CRecordSet@@QAE_NXZ ; CRecordSet::ThrowErrorIfSet

; 141  : 		return false;

  00037	32 c0		 xor	 al, al
  00039	5e		 pop	 esi

; 142  : 	}
; 143  : }

  0003a	5d		 pop	 ebp
  0003b	c2 14 00	 ret	 20			; 00000014H
?GetData@CRecordSet@@QAE_NGFPAXJPAJ@Z ENDP		; CRecordSet::GetData
_TEXT	ENDS
PUBLIC	?sColumnEx@CRecordSet@@QAE_NHPADHPAH@Z		; CRecordSet::sColumnEx
; Function compile flags: /Ogtp
;	COMDAT ?sColumnEx@CRecordSet@@QAE_NHPADHPAH@Z
_TEXT	SEGMENT
_iLen$ = -4						; size = 4
_iCol$ = 8						; size = 4
_sBuf$ = 12						; size = 4
_iBufSz$ = 16						; size = 4
_iOutLen$ = 20						; size = 4
?sColumnEx@CRecordSet@@QAE_NHPADHPAH@Z PROC		; CRecordSet::sColumnEx, COMDAT
; _this$ = ecx

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 164  : 	int iLen = 0;
; 165  : 
; 166  : 	if(SQL_SUCCEEDED(SQLGetData(this->hSTMT, iCol, SQL_C_CHAR, sBuf, iBufSz, (SQLINTEGER *)&iLen)))

  00004	8b 55 08	 mov	 edx, DWORD PTR _iCol$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 10	 mov	 ebx, DWORD PTR _iBufSz$[ebp]
  0000b	56		 push	 esi
  0000c	8d 45 fc	 lea	 eax, DWORD PTR _iLen$[ebp]
  0000f	50		 push	 eax
  00010	53		 push	 ebx
  00011	8b f1		 mov	 esi, ecx
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _sBuf$[ebp]
  00016	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00019	51		 push	 ecx
  0001a	6a 01		 push	 1
  0001c	52		 push	 edx
  0001d	50		 push	 eax
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iLen$[ebp], 0
  00025	e8 00 00 00 00	 call	 _SQLGetData@24
  0002a	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  0002e	75 44		 jne	 SHORT $LN6@sColumnEx

; 167  : 	{
; 168  : 		if(iLen > iBufSz)

  00030	57		 push	 edi
  00031	8b 7d fc	 mov	 edi, DWORD PTR _iLen$[ebp]
  00034	3b fb		 cmp	 edi, ebx
  00036	7e 02		 jle	 SHORT $LN5@sColumnEx

; 169  : 		{
; 170  : 			iLen = iBufSz;

  00038	8b fb		 mov	 edi, ebx
$LN5@sColumnEx:

; 171  : 		}
; 172  : 
; 173  : 		if(bReplaceSingleQuotes)

  0003a	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  0003e	74 0c		 je	 SHORT $LN9@sColumnEx

; 174  : 		{
; 175  : 			this->ReplaceSingleQuotes(sBuf, iLen);

  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _sBuf$[ebp]
  00043	57		 push	 edi
  00044	51		 push	 ecx
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?ReplaceSingleQuotes@CRecordSet@@QAEXPADH@Z ; CRecordSet::ReplaceSingleQuotes
$LN9@sColumnEx:

; 176  : 		}
; 177  : 
; 178  : 		if(bTrimCharData)

  0004c	80 7e 10 00	 cmp	 BYTE PTR [esi+16], 0
  00050	74 0e		 je	 SHORT $LN3@sColumnEx

; 179  : 		{
; 180  : 			iLen = RTrim(sBuf, iLen);

  00052	8b 55 0c	 mov	 edx, DWORD PTR _sBuf$[ebp]
  00055	57		 push	 edi
  00056	52		 push	 edx
  00057	8b ce		 mov	 ecx, esi
  00059	e8 00 00 00 00	 call	 ?RTrim@CRecordSet@@QAEHPADH@Z ; CRecordSet::RTrim
  0005e	8b f8		 mov	 edi, eax
$LN3@sColumnEx:

; 181  : 		}
; 182  : 
; 183  : 		if(iOutLen)

  00060	8b 45 14	 mov	 eax, DWORD PTR _iOutLen$[ebp]
  00063	85 c0		 test	 eax, eax
  00065	74 02		 je	 SHORT $LN2@sColumnEx

; 184  : 		{
; 185  : 			*iOutLen = iLen;

  00067	89 38		 mov	 DWORD PTR [eax], edi
$LN2@sColumnEx:
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi

; 186  : 		}
; 187  : 		
; 188  : 		return true;

  0006b	b0 01		 mov	 al, 1
  0006d	5b		 pop	 ebx

; 193  : 	}
; 194  : }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 10 00	 ret	 16			; 00000010H
$LN6@sColumnEx:

; 189  : 	}
; 190  : 	else {
; 191  : 		this->ThrowErrorIfSet();

  00074	8b ce		 mov	 ecx, esi
  00076	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CRecordSet@@QAE_NXZ ; CRecordSet::ThrowErrorIfSet
  0007b	5e		 pop	 esi

; 192  : 		return false;

  0007c	32 c0		 xor	 al, al
  0007e	5b		 pop	 ebx

; 193  : 	}
; 194  : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 10 00	 ret	 16			; 00000010H
?sColumnEx@CRecordSet@@QAE_NHPADHPAH@Z ENDP		; CRecordSet::sColumnEx
_TEXT	ENDS
PUBLIC	?lColumnEx@CRecordSet@@QAE_NHPAJ@Z		; CRecordSet::lColumnEx
; Function compile flags: /Ogtp
;	COMDAT ?lColumnEx@CRecordSet@@QAE_NHPAJ@Z
_TEXT	SEGMENT
_piOutBufSz$ = -4					; size = 4
_iCol$ = 8						; size = 4
_plOutVal$ = 12						; size = 4
?lColumnEx@CRecordSet@@QAE_NHPAJ@Z PROC			; CRecordSet::lColumnEx, COMDAT
; _this$ = ecx

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 200  : 	long piOutBufSz = 0;
; 201  : 
; 202  : 	if(SQL_SUCCEEDED(SQLGetData(this->hSTMT, iCol, SQL_C_LONG, plOutVal, sizeof(long), &piOutBufSz)))

  00004	8b 55 08	 mov	 edx, DWORD PTR _iCol$[ebp]
  00007	56		 push	 esi
  00008	8d 45 fc	 lea	 eax, DWORD PTR _piOutBufSz$[ebp]
  0000b	50		 push	 eax
  0000c	6a 04		 push	 4
  0000e	8b f1		 mov	 esi, ecx
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _plOutVal$[ebp]
  00013	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00016	51		 push	 ecx
  00017	6a 04		 push	 4
  00019	52		 push	 edx
  0001a	50		 push	 eax
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _piOutBufSz$[ebp], 0
  00022	e8 00 00 00 00	 call	 _SQLGetData@24
  00027	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  0002b	75 09		 jne	 SHORT $LN2@lColumnEx

; 203  : 	{
; 204  : 		return true;

  0002d	b0 01		 mov	 al, 1
  0002f	5e		 pop	 esi

; 209  : 	}
; 210  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
$LN2@lColumnEx:

; 205  : 	}
; 206  : 	else {
; 207  : 		this->ThrowErrorIfSet();

  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CRecordSet@@QAE_NXZ ; CRecordSet::ThrowErrorIfSet

; 208  : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	5e		 pop	 esi

; 209  : 	}
; 210  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?lColumnEx@CRecordSet@@QAE_NHPAJ@Z ENDP			; CRecordSet::lColumnEx
_TEXT	ENDS
PUBLIC	?lColumn@CRecordSet@@QAEJH@Z			; CRecordSet::lColumn
; Function compile flags: /Ogtp
;	COMDAT ?lColumn@CRecordSet@@QAEJH@Z
_TEXT	SEGMENT
_lTemp$ = -4						; size = 4
_iCol$ = 8						; size = 4
?lColumn@CRecordSet@@QAEJH@Z PROC			; CRecordSet::lColumn, COMDAT
; _this$ = ecx

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 216  : 	long lTemp = 0;
; 217  : 
; 218  : 	if(this->lColumnEx(iCol, &lTemp))

  00004	8b 55 08	 mov	 edx, DWORD PTR _iCol$[ebp]
  00007	8d 45 fc	 lea	 eax, DWORD PTR _lTemp$[ebp]
  0000a	50		 push	 eax
  0000b	52		 push	 edx
  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lTemp$[ebp], 0
  00013	e8 00 00 00 00	 call	 ?lColumnEx@CRecordSet@@QAE_NHPAJ@Z ; CRecordSet::lColumnEx
  00018	84 c0		 test	 al, al
  0001a	74 09		 je	 SHORT $LN2@lColumn

; 219  : 	{
; 220  : 	    return lTemp;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _lTemp$[ebp]

; 223  : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN2@lColumn:

; 221  : 	}
; 222  : 	else return -1;

  00025	83 c8 ff	 or	 eax, -1

; 223  : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?lColumn@CRecordSet@@QAEJH@Z ENDP			; CRecordSet::lColumn
_TEXT	ENDS
PUBLIC	?dColumnEx@CRecordSet@@QAE_NHPAN@Z		; CRecordSet::dColumnEx
; Function compile flags: /Ogtp
;	COMDAT ?dColumnEx@CRecordSet@@QAE_NHPAN@Z
_TEXT	SEGMENT
_piOutBufSz$ = -4					; size = 4
_iCol$ = 8						; size = 4
_pdOutVal$ = 12						; size = 4
?dColumnEx@CRecordSet@@QAE_NHPAN@Z PROC			; CRecordSet::dColumnEx, COMDAT
; _this$ = ecx

; 228  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 229  : 	long piOutBufSz = 0;
; 230  : 
; 231  : 	if(SQL_SUCCEEDED(SQLGetData(this->hSTMT, iCol, SQL_FLOAT, pdOutVal, sizeof(double), &piOutBufSz)))

  00004	8b 55 08	 mov	 edx, DWORD PTR _iCol$[ebp]
  00007	56		 push	 esi
  00008	8d 45 fc	 lea	 eax, DWORD PTR _piOutBufSz$[ebp]
  0000b	50		 push	 eax
  0000c	6a 08		 push	 8
  0000e	8b f1		 mov	 esi, ecx
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _pdOutVal$[ebp]
  00013	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00016	51		 push	 ecx
  00017	6a 06		 push	 6
  00019	52		 push	 edx
  0001a	50		 push	 eax
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _piOutBufSz$[ebp], 0
  00022	e8 00 00 00 00	 call	 _SQLGetData@24
  00027	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  0002b	75 09		 jne	 SHORT $LN2@dColumnEx

; 232  : 	{
; 233  : 		return true;

  0002d	b0 01		 mov	 al, 1
  0002f	5e		 pop	 esi

; 238  : 	}
; 239  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
$LN2@dColumnEx:

; 234  : 	}
; 235  : 	else {
; 236  : 		this->ThrowErrorIfSet();

  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CRecordSet@@QAE_NXZ ; CRecordSet::ThrowErrorIfSet

; 237  : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	5e		 pop	 esi

; 238  : 	}
; 239  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?dColumnEx@CRecordSet@@QAE_NHPAN@Z ENDP			; CRecordSet::dColumnEx
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	?dColumn@CRecordSet@@QAENH@Z			; CRecordSet::dColumn
EXTRN	__fltused:DWORD
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?dColumn@CRecordSet@@QAENH@Z
_TEXT	SEGMENT
_dTemp$ = -8						; size = 8
_iCol$ = 8						; size = 4
?dColumn@CRecordSet@@QAENH@Z PROC			; CRecordSet::dColumn, COMDAT
; _this$ = ecx

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 245  : 	double dTemp = 0;
; 246  : 
; 247  : 	if(this->dColumnEx(iCol, &dTemp))

  00006	8b 55 08	 mov	 edx, DWORD PTR _iCol$[ebp]
  00009	d9 ee		 fldz
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _dTemp$[ebp]
  0000e	dd 5d f8	 fstp	 QWORD PTR _dTemp$[ebp]
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?dColumnEx@CRecordSet@@QAE_NHPAN@Z ; CRecordSet::dColumnEx
  00018	84 c0		 test	 al, al
  0001a	74 09		 je	 SHORT $LN2@dColumn

; 248  : 	{
; 249  : 	    return dTemp;

  0001c	dd 45 f8	 fld	 QWORD PTR _dTemp$[ebp]

; 252  : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN2@dColumn:

; 250  : 	}
; 251  : 	else return -1;

  00025	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@bff0000000000000

; 252  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?dColumn@CRecordSet@@QAENH@Z ENDP			; CRecordSet::dColumn
_TEXT	ENDS
PUBLIC	?fColumnEx@CRecordSet@@QAE_NHPAM@Z		; CRecordSet::fColumnEx
; Function compile flags: /Ogtp
;	COMDAT ?fColumnEx@CRecordSet@@QAE_NHPAM@Z
_TEXT	SEGMENT
_piOutBufSz$ = -4					; size = 4
_iCol$ = 8						; size = 4
_pfOutVal$ = 12						; size = 4
?fColumnEx@CRecordSet@@QAE_NHPAM@Z PROC			; CRecordSet::fColumnEx, COMDAT
; _this$ = ecx

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 258  : 	long piOutBufSz = 0;
; 259  : 
; 260  : 	if(SQL_SUCCEEDED(SQLGetData(this->hSTMT, iCol, SQL_FLOAT, pfOutVal, sizeof(float), &piOutBufSz)))

  00004	8b 55 08	 mov	 edx, DWORD PTR _iCol$[ebp]
  00007	56		 push	 esi
  00008	8d 45 fc	 lea	 eax, DWORD PTR _piOutBufSz$[ebp]
  0000b	50		 push	 eax
  0000c	6a 04		 push	 4
  0000e	8b f1		 mov	 esi, ecx
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _pfOutVal$[ebp]
  00013	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00016	51		 push	 ecx
  00017	6a 06		 push	 6
  00019	52		 push	 edx
  0001a	50		 push	 eax
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _piOutBufSz$[ebp], 0
  00022	e8 00 00 00 00	 call	 _SQLGetData@24
  00027	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  0002b	75 09		 jne	 SHORT $LN2@fColumnEx

; 261  : 	{
; 262  : 		return true;

  0002d	b0 01		 mov	 al, 1
  0002f	5e		 pop	 esi

; 267  : 	}
; 268  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
$LN2@fColumnEx:

; 263  : 	}
; 264  : 	else {
; 265  : 		this->ThrowErrorIfSet();

  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CRecordSet@@QAE_NXZ ; CRecordSet::ThrowErrorIfSet

; 266  : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	5e		 pop	 esi

; 267  : 	}
; 268  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?fColumnEx@CRecordSet@@QAE_NHPAM@Z ENDP			; CRecordSet::fColumnEx
_TEXT	ENDS
PUBLIC	__real@bf800000
PUBLIC	__real@00000000
PUBLIC	?fColumn@CRecordSet@@QAEMH@Z			; CRecordSet::fColumn
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?fColumn@CRecordSet@@QAEMH@Z
_TEXT	SEGMENT
_fTemp$ = -4						; size = 4
_iCol$ = 8						; size = 4
?fColumn@CRecordSet@@QAEMH@Z PROC			; CRecordSet::fColumn, COMDAT
; _this$ = ecx

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 274  : 	float fTemp = 0;
; 275  : 
; 276  : 	if(this->fColumnEx(iCol, &fTemp))

  00004	8b 55 08	 mov	 edx, DWORD PTR _iCol$[ebp]
  00007	d9 ee		 fldz
  00009	8d 45 fc	 lea	 eax, DWORD PTR _fTemp$[ebp]
  0000c	d9 5d fc	 fstp	 DWORD PTR _fTemp$[ebp]
  0000f	50		 push	 eax
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 ?fColumnEx@CRecordSet@@QAE_NHPAM@Z ; CRecordSet::fColumnEx
  00016	84 c0		 test	 al, al
  00018	74 09		 je	 SHORT $LN2@fColumn

; 277  : 	{
; 278  : 	    return fTemp;

  0001a	d9 45 fc	 fld	 DWORD PTR _fTemp$[ebp]

; 281  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN2@fColumn:

; 279  : 	}
; 280  : 	else return -1;

  00023	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@bf800000

; 281  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?fColumn@CRecordSet@@QAEMH@Z ENDP			; CRecordSet::fColumn
_TEXT	ENDS
PUBLIC	?BinColumnEx@CRecordSet@@QAE_NHPADHPAH@Z	; CRecordSet::BinColumnEx
; Function compile flags: /Ogtp
;	COMDAT ?BinColumnEx@CRecordSet@@QAE_NHPADHPAH@Z
_TEXT	SEGMENT
_iLen$ = -4						; size = 4
_iCol$ = 8						; size = 4
_sBuf$ = 12						; size = 4
_iBufSz$ = 16						; size = 4
_iOutLen$ = 20						; size = 4
?BinColumnEx@CRecordSet@@QAE_NHPADHPAH@Z PROC		; CRecordSet::BinColumnEx, COMDAT
; _this$ = ecx

; 286  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 287  : 	SQLLEN iLen = 0;
; 288  : 
; 289  : 	if(SQL_SUCCEEDED(SQLGetData(this->hSTMT, iCol, SQL_C_BINARY, sBuf, iBufSz, (SQLLEN *)&iLen)))

  00004	8b 55 08	 mov	 edx, DWORD PTR _iCol$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 10	 mov	 ebx, DWORD PTR _iBufSz$[ebp]
  0000b	56		 push	 esi
  0000c	8d 45 fc	 lea	 eax, DWORD PTR _iLen$[ebp]
  0000f	50		 push	 eax
  00010	53		 push	 ebx
  00011	8b f1		 mov	 esi, ecx
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _sBuf$[ebp]
  00016	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00019	51		 push	 ecx
  0001a	6a fe		 push	 -2			; fffffffeH
  0001c	52		 push	 edx
  0001d	50		 push	 eax
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iLen$[ebp], 0
  00025	e8 00 00 00 00	 call	 _SQLGetData@24
  0002a	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  0002e	75 44		 jne	 SHORT $LN6@BinColumnE

; 290  : 	{
; 291  : 		if(iLen > iBufSz)

  00030	57		 push	 edi
  00031	8b 7d fc	 mov	 edi, DWORD PTR _iLen$[ebp]
  00034	3b fb		 cmp	 edi, ebx
  00036	7e 02		 jle	 SHORT $LN5@BinColumnE

; 292  : 		{
; 293  : 			iLen = iBufSz;

  00038	8b fb		 mov	 edi, ebx
$LN5@BinColumnE:

; 294  : 		}
; 295  : 
; 296  : 		if(this->bReplaceSingleQuotes)

  0003a	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  0003e	74 0c		 je	 SHORT $LN9@BinColumnE

; 297  : 		{
; 298  : 			this->ReplaceSingleQuotes(sBuf, iLen);

  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _sBuf$[ebp]
  00043	57		 push	 edi
  00044	51		 push	 ecx
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?ReplaceSingleQuotes@CRecordSet@@QAEXPADH@Z ; CRecordSet::ReplaceSingleQuotes
$LN9@BinColumnE:

; 299  : 		}
; 300  : 
; 301  : 		if(this->bTrimCharData)

  0004c	80 7e 10 00	 cmp	 BYTE PTR [esi+16], 0
  00050	74 0e		 je	 SHORT $LN3@BinColumnE

; 302  : 		{
; 303  : 			iLen = RTrim(sBuf, iLen);

  00052	8b 55 0c	 mov	 edx, DWORD PTR _sBuf$[ebp]
  00055	57		 push	 edi
  00056	52		 push	 edx
  00057	8b ce		 mov	 ecx, esi
  00059	e8 00 00 00 00	 call	 ?RTrim@CRecordSet@@QAEHPADH@Z ; CRecordSet::RTrim
  0005e	8b f8		 mov	 edi, eax
$LN3@BinColumnE:

; 304  : 		}
; 305  : 
; 306  : 		if(iOutLen)

  00060	8b 45 14	 mov	 eax, DWORD PTR _iOutLen$[ebp]
  00063	85 c0		 test	 eax, eax
  00065	74 02		 je	 SHORT $LN2@BinColumnE

; 307  : 		{
; 308  : 			*iOutLen = iLen;

  00067	89 38		 mov	 DWORD PTR [eax], edi
$LN2@BinColumnE:
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi

; 309  : 		}
; 310  : 		
; 311  : 		return true;

  0006b	b0 01		 mov	 al, 1
  0006d	5b		 pop	 ebx

; 316  : 	}
; 317  : }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 10 00	 ret	 16			; 00000010H
$LN6@BinColumnE:

; 312  : 	}
; 313  : 	else {
; 314  : 		this->ThrowErrorIfSet();

  00074	8b ce		 mov	 ecx, esi
  00076	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CRecordSet@@QAE_NXZ ; CRecordSet::ThrowErrorIfSet
  0007b	5e		 pop	 esi

; 315  : 		return false;

  0007c	32 c0		 xor	 al, al
  0007e	5b		 pop	 ebx

; 316  : 	}
; 317  : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 10 00	 ret	 16			; 00000010H
?BinColumnEx@CRecordSet@@QAE_NHPADHPAH@Z ENDP		; CRecordSet::BinColumnEx
_TEXT	ENDS
END
