; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\cBoundRecordSet.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?GetDefaultConversion@CBoundRecordSet@@QAE?AW4CType@CTypes@@W4SQLType@SQLTypes@@@Z ; CBoundRecordSet::GetDefaultConversion
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\cboundrecordset.cpp
;	COMDAT ?GetDefaultConversion@CBoundRecordSet@@QAE?AW4CType@CTypes@@W4SQLType@SQLTypes@@@Z
_TEXT	SEGMENT
_DataType$ = 8						; size = 4
?GetDefaultConversion@CBoundRecordSet@@QAE?AW4CType@CTypes@@W4SQLType@SQLTypes@@@Z PROC ; CBoundRecordSet::GetDefaultConversion, COMDAT
; _this$ = ecx

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 26   : 	CTypes::CType Value = CTypes::Char;
; 27   : 
; 28   : 	if(DataType == SQLTypes::BigInt){

  00003	8b 45 08	 mov	 eax, DWORD PTR _DataType$[ebp]
  00006	3d fb ff 00 00	 cmp	 eax, 65531		; 0000fffbH
  0000b	75 09		 jne	 SHORT $LN49@GetDefault

; 29   : 		return CTypes::SBigInt;

  0000d	b8 e7 ff ff ff	 mov	 eax, -25		; ffffffe7H

; 101  : 		return CTypes::Char;
; 102  : 	}
; 103  : 
; 104  : 	return Value;
; 105  : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN49@GetDefault:

; 30   : 	}
; 31   : 	else if(DataType == SQLTypes::Binary){

  00016	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH

; 32   : 		return CTypes::Char;

  0001b	0f 84 8b 00 00
	00		 je	 $LN3@GetDefault

; 33   : 	}
; 34   : 	else if(DataType == SQLTypes::Bit){

  00021	3d f9 ff 00 00	 cmp	 eax, 65529		; 0000fff9H
  00026	75 09		 jne	 SHORT $LN45@GetDefault

; 35   : 		return CTypes::Bit;

  00028	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H

; 101  : 		return CTypes::Char;
; 102  : 	}
; 103  : 
; 104  : 	return Value;
; 105  : }

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
$LN45@GetDefault:

; 36   : 	}
; 37   : 	else if(DataType == SQLTypes::Char){

  00031	83 f8 01	 cmp	 eax, 1

; 38   : 		return CTypes::Char;

  00034	74 76		 je	 SHORT $LN3@GetDefault

; 39   : 	}
; 40   : 	else if(DataType == SQLTypes::DateTime){

  00036	83 f8 5d	 cmp	 eax, 93			; 0000005dH

; 41   : 		return CTypes::Char;

  00039	74 71		 je	 SHORT $LN3@GetDefault

; 42   : 	}
; 43   : 	else if(DataType == SQLTypes::Decimal){

  0003b	83 f8 03	 cmp	 eax, 3
  0003e	75 09		 jne	 SHORT $LN39@GetDefault
$LN52@GetDefault:

; 44   : 		return CTypes::Double;

  00040	b8 08 00 00 00	 mov	 eax, 8

; 101  : 		return CTypes::Char;
; 102  : 	}
; 103  : 
; 104  : 	return Value;
; 105  : }

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN39@GetDefault:

; 45   : 	}
; 46   : 	else if(DataType == SQLTypes::Float){

  00049	83 f8 06	 cmp	 eax, 6
  0004c	75 09		 jne	 SHORT $LN37@GetDefault

; 47   : 		return CTypes::Float;

  0004e	b8 07 00 00 00	 mov	 eax, 7

; 101  : 		return CTypes::Char;
; 102  : 	}
; 103  : 
; 104  : 	return Value;
; 105  : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN37@GetDefault:

; 48   : 	}
; 49   : 	else if(DataType == SQLTypes::Image){

  00057	3d fc ff 00 00	 cmp	 eax, 65532		; 0000fffcH

; 50   : 		return CTypes::Char;

  0005c	74 4e		 je	 SHORT $LN3@GetDefault

; 51   : 	}
; 52   : 	else if(DataType == SQLTypes::Int){

  0005e	83 f8 04	 cmp	 eax, 4
  00061	75 09		 jne	 SHORT $LN33@GetDefault
$LN53@GetDefault:

; 53   : 		return CTypes::SLong;

  00063	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H

; 101  : 		return CTypes::Char;
; 102  : 	}
; 103  : 
; 104  : 	return Value;
; 105  : }

  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
$LN33@GetDefault:

; 54   : 	}
; 55   : 	else if(DataType == SQLTypes::Money){
; 56   : 		return CTypes::Double;
; 57   : 	}
; 58   : 	else if(DataType == SQLTypes::NChar){

  0006c	3d f8 ff 00 00	 cmp	 eax, 65528		; 0000fff8H

; 59   : 		return CTypes::Char;

  00071	74 39		 je	 SHORT $LN3@GetDefault

; 60   : 	}
; 61   : 	else if(DataType == SQLTypes::NText){

  00073	3d f6 ff 00 00	 cmp	 eax, 65526		; 0000fff6H

; 62   : 		return CTypes::Char;

  00078	74 32		 je	 SHORT $LN3@GetDefault

; 63   : 	}
; 64   : 	else if(DataType == SQLTypes::Numeric){

  0007a	83 f8 02	 cmp	 eax, 2

; 65   : 		return CTypes::SLong;

  0007d	74 e4		 je	 SHORT $LN53@GetDefault

; 66   : 	}
; 67   : 	else if(DataType == SQLTypes::NVarChar){

  0007f	3d f7 ff 00 00	 cmp	 eax, 65527		; 0000fff7H

; 68   : 		return CTypes::Char;

  00084	74 26		 je	 SHORT $LN3@GetDefault

; 69   : 	}
; 70   : 	else if(DataType == SQLTypes::Real){

  00086	83 f8 07	 cmp	 eax, 7

; 71   : 		return CTypes::Double;

  00089	74 b5		 je	 SHORT $LN52@GetDefault

; 72   : 	}
; 73   : 	else if(DataType == SQLTypes::SmallDateTime){
; 74   : 		return CTypes::Char;
; 75   : 	}
; 76   : 	else if(DataType == SQLTypes::SmallInt){

  0008b	83 f8 05	 cmp	 eax, 5
  0008e	75 09		 jne	 SHORT $LN17@GetDefault

; 77   : 		return CTypes::SShort;

  00090	b8 f1 ff ff ff	 mov	 eax, -15		; fffffff1H

; 101  : 		return CTypes::Char;
; 102  : 	}
; 103  : 
; 104  : 	return Value;
; 105  : }

  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
$LN17@GetDefault:

; 78   : 	}
; 79   : 	else if(DataType == SQLTypes::SmallMoney){
; 80   : 		return CTypes::Double;
; 81   : 	}
; 82   : 	else if(DataType == SQLTypes::Text){

  00099	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH

; 83   : 		return CTypes::Char;

  0009e	74 0c		 je	 SHORT $LN3@GetDefault

; 84   : 	}
; 85   : 	else if(DataType == SQLTypes::TimeStamp){
; 86   : 		return CTypes::Char;
; 87   : 	}
; 88   : 	else if(DataType == SQLTypes::TinyInt){

  000a0	3d fa ff 00 00	 cmp	 eax, 65530		; 0000fffaH

; 89   : 		return CTypes::SShort;

  000a5	b8 f1 ff ff ff	 mov	 eax, -15		; fffffff1H
  000aa	74 05		 je	 SHORT $LN1@GetDefault
$LN3@GetDefault:

; 90   : 	}
; 91   : 	else if(DataType == SQLTypes::UniqueIdentifier){
; 92   : 		return CTypes::Char;
; 93   : 	}
; 94   : 	else if(DataType == SQLTypes::VarBinary){
; 95   : 		return CTypes::Char;
; 96   : 	}
; 97   : 	else if(DataType == SQLTypes::VarChar){
; 98   : 		return CTypes::Char;
; 99   : 	}
; 100  : 	else if(DataType == SQLTypes::Variant){

  000ac	b8 01 00 00 00	 mov	 eax, 1
$LN1@GetDefault:

; 101  : 		return CTypes::Char;
; 102  : 	}
; 103  : 
; 104  : 	return Value;
; 105  : }

  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
?GetDefaultConversion@CBoundRecordSet@@QAE?AW4CType@CTypes@@W4SQLType@SQLTypes@@@Z ENDP ; CBoundRecordSet::GetDefaultConversion
_TEXT	ENDS
PUBLIC	?Reset@CBoundRecordSet@@QAE_NXZ			; CBoundRecordSet::Reset
EXTRN	_SQLFreeStmt@8:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Reset@CBoundRecordSet@@QAE_NXZ
_TEXT	SEGMENT
?Reset@CBoundRecordSet@@QAE_NXZ PROC			; CBoundRecordSet::Reset, COMDAT
; _this$ = ecx

; 110  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 111  : 	bool bResult = true;
; 112  : 
; 113  : 	bResult = bResult && (SQLFreeStmt(this->hSTMT, SQL_UNBIND) == SQL_SUCCESS);

  00003	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00006	6a 02		 push	 2
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _SQLFreeStmt@8
  0000e	66 85 c0	 test	 ax, ax

; 114  : 	bResult = bResult && (SQLFreeStmt(this->hSTMT, SQL_RESET_PARAMS) == SQL_SUCCESS);

  00011	75 14		 jne	 SHORT $LN5@Reset
  00013	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00016	6a 03		 push	 3
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _SQLFreeStmt@8
  0001e	66 85 c0	 test	 ax, ax
  00021	75 04		 jne	 SHORT $LN5@Reset
  00023	b0 01		 mov	 al, 1
  00025	5e		 pop	 esi

; 115  : 
; 116  : 	return bResult;
; 117  : }

  00026	c3		 ret	 0
$LN5@Reset:

; 114  : 	bResult = bResult && (SQLFreeStmt(this->hSTMT, SQL_RESET_PARAMS) == SQL_SUCCESS);

  00027	32 c0		 xor	 al, al
  00029	5e		 pop	 esi

; 115  : 
; 116  : 	return bResult;
; 117  : }

  0002a	c3		 ret	 0
?Reset@CBoundRecordSet@@QAE_NXZ ENDP			; CBoundRecordSet::Reset
_TEXT	ENDS
PUBLIC	?Close@CBoundRecordSet@@QAE_NXZ			; CBoundRecordSet::Close
EXTRN	_SQLFreeHandle@8:PROC
EXTRN	_free:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Close@CBoundRecordSet@@QAE_NXZ
_TEXT	SEGMENT
?Close@CBoundRecordSet@@QAE_NXZ PROC			; CBoundRecordSet::Close, COMDAT
; _this$ = ecx

; 122  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 123  : 	bool bResult = true;
; 124  : 
; 125  : 	if(this->Columns.Count > 0)

  00003	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00006	57		 push	 edi
  00007	33 ff		 xor	 edi, edi
  00009	3b c7		 cmp	 eax, edi
  0000b	7e 51		 jle	 SHORT $LN5@Close

; 126  : 	{
; 127  : 		for(int iPos = 0; iPos < this->Columns.Count; iPos++)

  0000d	53		 push	 ebx
  0000e	33 db		 xor	 ebx, ebx
  00010	3b c7		 cmp	 eax, edi
  00012	7e 3d		 jle	 SHORT $LN2@Close
  00014	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL4@Close:

; 128  : 		{
; 129  : 			if(this->Columns.Column[iPos].IsBound)

  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	80 bc 38 1c 04
	00 00 00	 cmp	 BYTE PTR [eax+edi+1052], 0
  0002b	74 16		 je	 SHORT $LN3@Close

; 130  : 			{
; 131  : 				#ifdef _USE_GLOBAL_MEMPOOL
; 132  : 					pMem->Free(this->Columns.Column[iPos].Data.Buffer);
; 133  : 				#else
; 134  : 					free(this->Columns.Column[iPos].Data.Buffer);

  0002d	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _free

; 135  : 				#endif
; 136  : 				this->Columns.Column[iPos].Data.Buffer = NULL;

  00036	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00039	83 c4 04	 add	 esp, 4
  0003c	c7 04 17 00 00
	00 00		 mov	 DWORD PTR [edi+edx], 0
$LN3@Close:

; 126  : 	{
; 127  : 		for(int iPos = 0; iPos < this->Columns.Count; iPos++)

  00043	43		 inc	 ebx
  00044	81 c7 20 04 00
	00		 add	 edi, 1056		; 00000420H
  0004a	3b 5e 08	 cmp	 ebx, DWORD PTR [esi+8]
  0004d	7c d1		 jl	 SHORT $LL4@Close
  0004f	33 ff		 xor	 edi, edi
$LN2@Close:

; 137  : 			}
; 138  : 		}
; 139  : 
; 140  : 		#ifdef _USE_GLOBAL_MEMPOOL
; 141  : 			pMem->Free(this->Columns.Column);
; 142  : 		#else
; 143  : 			free(this->Columns.Column);

  00051	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _free
  0005a	83 c4 04	 add	 esp, 4
  0005d	5b		 pop	 ebx
$LN5@Close:

; 144  : 		#endif
; 145  : 	}
; 146  : 
; 147  : 	memset(&this->Columns, 0, sizeof(RECORDSET_COLUMN));

  0005e	33 c0		 xor	 eax, eax
  00060	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00063	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 148  : 
; 149  : 	RowCount = 0;
; 150  : 
; 151  : 	bResult = bResult && (SQLFreeStmt(this->hSTMT, SQL_UNBIND) == SQL_SUCCESS);

  00066	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00069	6a 02		 push	 2
  0006b	51		 push	 ecx
  0006c	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0006f	e8 00 00 00 00	 call	 _SQLFreeStmt@8
  00074	66 85 c0	 test	 ax, ax

; 152  : 	bResult = bResult && (SQLFreeStmt(this->hSTMT, SQL_CLOSE) == SQL_SUCCESS);

  00077	75 27		 jne	 SHORT $LN12@Close
  00079	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0007c	57		 push	 edi
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 _SQLFreeStmt@8
  00083	66 85 c0	 test	 ax, ax

; 153  : 	bResult = bResult && (SQLFreeHandle(SQL_HANDLE_STMT, this->hSTMT) == SQL_SUCCESS);

  00086	75 18		 jne	 SHORT $LN12@Close
  00088	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0008b	50		 push	 eax
  0008c	6a 03		 push	 3
  0008e	e8 00 00 00 00	 call	 _SQLFreeHandle@8
  00093	66 85 c0	 test	 ax, ax
  00096	75 08		 jne	 SHORT $LN12@Close

; 154  : 
; 155  : 	this->hSTMT = NULL;

  00098	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0009b	5f		 pop	 edi
  0009c	b0 01		 mov	 al, 1
  0009e	5e		 pop	 esi

; 156  : 
; 157  : 	return bResult;
; 158  : }

  0009f	c3		 ret	 0
$LN12@Close:

; 154  : 
; 155  : 	this->hSTMT = NULL;

  000a0	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  000a3	5f		 pop	 edi
  000a4	32 c0		 xor	 al, al
  000a6	5e		 pop	 esi

; 156  : 
; 157  : 	return bResult;
; 158  : }

  000a7	c3		 ret	 0
?Close@CBoundRecordSet@@QAE_NXZ ENDP			; CBoundRecordSet::Close
_TEXT	ENDS
PUBLIC	?GetColumnInfo@CBoundRecordSet@@QAE_NHPADHPAH1111@Z ; CBoundRecordSet::GetColumnInfo
EXTRN	_SQLDescribeColA@36:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GetColumnInfo@CBoundRecordSet@@QAE_NHPADHPAH1111@Z
_TEXT	SEGMENT
_iCol$ = 8						; size = 4
_sOutName$ = 12						; size = 4
_iSzOfOutName$ = 16					; size = 4
_iOutColNameLen$ = 20					; size = 4
_ioutDataType$ = 24					; size = 4
_iOutColSize$ = 28					; size = 4
_iNumOfDeciPlaces$ = 32					; size = 4
_iColNullable$ = 36					; size = 4
?GetColumnInfo@CBoundRecordSet@@QAE_NHPADHPAH1111@Z PROC ; CBoundRecordSet::GetColumnInfo, COMDAT
; _this$ = ecx

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : 	if(SQL_SUCCEEDED(SQLDescribeColA(this->hSTMT, iCol, (SQLCHAR *)sOutName, (SQLSMALLINT)iSzOfOutName,
; 238  : 		(SQLSMALLINT *)iOutColNameLen, (SQLSMALLINT *)ioutDataType, (SQLUINTEGER *)iOutColSize,
; 239  : 		(SQLSMALLINT *)iNumOfDeciPlaces, (SQLSMALLINT *)iColNullable)))

  00003	8b 45 24	 mov	 eax, DWORD PTR _iColNullable$[ebp]
  00006	8b 55 20	 mov	 edx, DWORD PTR _iNumOfDeciPlaces$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 1c	 mov	 eax, DWORD PTR _iOutColSize$[ebp]
  0000d	52		 push	 edx
  0000e	8b 55 18	 mov	 edx, DWORD PTR _ioutDataType$[ebp]
  00011	50		 push	 eax
  00012	8b 45 14	 mov	 eax, DWORD PTR _iOutColNameLen$[ebp]
  00015	52		 push	 edx
  00016	8b 55 10	 mov	 edx, DWORD PTR _iSzOfOutName$[ebp]
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR _sOutName$[ebp]
  0001d	52		 push	 edx
  0001e	8b 55 08	 mov	 edx, DWORD PTR _iCol$[ebp]
  00021	50		 push	 eax
  00022	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00025	52		 push	 edx
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _SQLDescribeColA@36
  0002c	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  00030	0f 94 c0	 sete	 al

; 240  : 	{
; 241  : 		return true;
; 242  : 	}
; 243  : 	else return false;
; 244  : }

  00033	5d		 pop	 ebp
  00034	c2 20 00	 ret	 32			; 00000020H
?GetColumnInfo@CBoundRecordSet@@QAE_NHPADHPAH1111@Z ENDP ; CBoundRecordSet::GetColumnInfo
_TEXT	ENDS
PUBLIC	?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z	; CBoundRecordSet::GetColumnIndex
EXTRN	__stricmp:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z
_TEXT	SEGMENT
_sColumnName$ = 8					; size = 4
?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z PROC		; CBoundRecordSet::GetColumnIndex, COMDAT
; _this$ = ecx

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 250  :     for(int iPos = 0; iPos < this->Columns.Count; iPos++)

  00008	33 ff		 xor	 edi, edi
  0000a	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  0000d	7e 26		 jle	 SHORT $LN2@GetColumnI
  0000f	33 db		 xor	 ebx, ebx
$LL4@GetColumnI:

; 251  : 	{
; 252  : 		if(_stricmp(this->Columns.Column[iPos].Name, sColumnName) == 0)

  00011	8b 45 08	 mov	 eax, DWORD PTR _sColumnName$[ebp]
  00014	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00017	50		 push	 eax
  00018	8d 54 19 0c	 lea	 edx, DWORD PTR [ecx+ebx+12]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __stricmp
  00022	83 c4 08	 add	 esp, 8
  00025	85 c0		 test	 eax, eax
  00027	74 16		 je	 SHORT $LN8@GetColumnI

; 250  :     for(int iPos = 0; iPos < this->Columns.Count; iPos++)

  00029	47		 inc	 edi
  0002a	81 c3 20 04 00
	00		 add	 ebx, 1056		; 00000420H
  00030	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  00033	7c dc		 jl	 SHORT $LL4@GetColumnI
$LN2@GetColumnI:
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi

; 255  : 		}
; 256  : 	}
; 257  : 
; 258  :     return -1;

  00037	83 c8 ff	 or	 eax, -1
  0003a	5b		 pop	 ebx

; 259  : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
$LN8@GetColumnI:

; 253  : 		{
; 254  : 			return iPos;

  0003f	8b c7		 mov	 eax, edi
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx

; 259  : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z ENDP		; CBoundRecordSet::GetColumnIndex
_TEXT	ENDS
PUBLIC	?GetColumnOrdinal@CBoundRecordSet@@QAEHPBD@Z	; CBoundRecordSet::GetColumnOrdinal
; Function compile flags: /Ogtp
;	COMDAT ?GetColumnOrdinal@CBoundRecordSet@@QAEHPBD@Z
_TEXT	SEGMENT
_sColumnName$ = 8					; size = 4
?GetColumnOrdinal@CBoundRecordSet@@QAEHPBD@Z PROC	; CBoundRecordSet::GetColumnOrdinal, COMDAT
; _this$ = ecx

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 265  :     for(int iPos = 0; iPos < this->Columns.Count; iPos++)

  00008	33 f6		 xor	 esi, esi
  0000a	39 77 08	 cmp	 DWORD PTR [edi+8], esi
  0000d	7e 26		 jle	 SHORT $LN2@GetColumnO
  0000f	33 db		 xor	 ebx, ebx
$LL4@GetColumnO:

; 266  : 	{
; 267  : 		if(_stricmp(this->Columns.Column[iPos].Name, sColumnName) == 0)

  00011	8b 45 08	 mov	 eax, DWORD PTR _sColumnName$[ebp]
  00014	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00017	50		 push	 eax
  00018	8d 54 19 0c	 lea	 edx, DWORD PTR [ecx+ebx+12]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __stricmp
  00022	83 c4 08	 add	 esp, 8
  00025	85 c0		 test	 eax, eax
  00027	74 16		 je	 SHORT $LN8@GetColumnO

; 265  :     for(int iPos = 0; iPos < this->Columns.Count; iPos++)

  00029	46		 inc	 esi
  0002a	81 c3 20 04 00
	00		 add	 ebx, 1056		; 00000420H
  00030	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00033	7c dc		 jl	 SHORT $LL4@GetColumnO
$LN2@GetColumnO:
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi

; 270  : 		}
; 271  : 	}
; 272  : 
; 273  :     return -1;

  00037	83 c8 ff	 or	 eax, -1
  0003a	5b		 pop	 ebx

; 274  : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
$LN8@GetColumnO:

; 268  : 		{
; 269  : 			return this->Columns.Column[iPos].Ordinal;

  0003f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00042	69 f6 20 04 00
	00		 imul	 esi, 1056		; 00000420H
  00048	8b 84 06 18 04
	00 00		 mov	 eax, DWORD PTR [esi+eax+1048]
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 274  : }

  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
?GetColumnOrdinal@CBoundRecordSet@@QAEHPBD@Z ENDP	; CBoundRecordSet::GetColumnOrdinal
_TEXT	ENDS
PUBLIC	?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z ; CBoundRecordSet::Bind
EXTRN	_SQLBindCol@24:PROC
EXTRN	_calloc:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_TheConversion$ = 12					; size = 4
?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z PROC	; CBoundRecordSet::Bind, COMDAT
; _this$ = ecx

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 280  : 	if(iIndex < 0 || iIndex >= Columns.Count)

  00005	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 5f		 js	 SHORT $LN2@Bind
  0000e	3b 73 08	 cmp	 esi, DWORD PTR [ebx+8]
  00011	7d 5a		 jge	 SHORT $LN2@Bind

; 283  : 	}
; 284  : 
; 285  : 	LPRECORDSET_COLUMNINFO Pointer = &this->Columns.Column[iIndex];

  00013	69 f6 20 04 00
	00		 imul	 esi, 1056		; 00000420H
  00019	03 73 04	 add	 esi, DWORD PTR [ebx+4]

; 286  : 
; 287  : 	if(Pointer->IsBound)

  0001c	80 be 1c 04 00
	00 00		 cmp	 BYTE PTR [esi+1052], 0
  00023	74 08		 je	 SHORT $LN1@Bind

; 288  : 	{
; 289  : 		return Pointer->Data.Buffer;

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx

; 305  : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
$LN1@Bind:
  0002d	57		 push	 edi

; 290  : 	}
; 291  : 
; 292  : 	#ifdef _USE_GLOBAL_MEMPOOL
; 293  : 		Pointer->Data.Buffer = pMem->Allocate(Pointer->MaxSize + 1, 1);
; 294  : 	#else
; 295  : 		Pointer->Data.Buffer = calloc(Pointer->MaxSize + 1, 1);

  0002e	8b be 10 04 00
	00		 mov	 edi, DWORD PTR [esi+1040]
  00034	47		 inc	 edi
  00035	6a 01		 push	 1
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 _calloc

; 296  : 	#endif
; 297  : 
; 298  : 	SQLBindCol(this->hSTMT, Pointer->Ordinal,
; 299  : 		(SQLSMALLINT)TheConversion, Pointer->Data.Buffer,
; 300  : 		Pointer->MaxSize + 1, (SQLINTEGER *)&Pointer->Data.Size);

  0003d	8b 55 0c	 mov	 edx, DWORD PTR _TheConversion$[ebp]
  00040	83 c4 08	 add	 esp, 8
  00043	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00046	51		 push	 ecx
  00047	57		 push	 edi
  00048	50		 push	 eax
  00049	89 06		 mov	 DWORD PTR [esi], eax
  0004b	0f b7 86 18 04
	00 00		 movzx	 eax, WORD PTR [esi+1048]
  00052	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00055	52		 push	 edx
  00056	50		 push	 eax
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 _SQLBindCol@24

; 301  : 
; 302  : 	Pointer->IsBound = true;
; 303  : 
; 304  :     return Pointer->Data.Buffer;

  0005d	8b 06		 mov	 eax, DWORD PTR [esi]
  0005f	5f		 pop	 edi
  00060	c6 86 1c 04 00
	00 01		 mov	 BYTE PTR [esi+1052], 1
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx

; 305  : }

  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
$LN2@Bind:
  0006d	5e		 pop	 esi

; 281  : 	{
; 282  : 		return NULL;

  0006e	33 c0		 xor	 eax, eax
  00070	5b		 pop	 ebx

; 305  : }

  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8
?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z ENDP	; CBoundRecordSet::Bind
_TEXT	ENDS
PUBLIC	?Bind@CBoundRecordSet@@QAEPAXPBDW4CType@CTypes@@@Z ; CBoundRecordSet::Bind
; Function compile flags: /Ogtp
;	COMDAT ?Bind@CBoundRecordSet@@QAEPAXPBDW4CType@CTypes@@@Z
_TEXT	SEGMENT
_sColumnName$ = 8					; size = 4
_TheConversion$ = 12					; size = 4
?Bind@CBoundRecordSet@@QAEPAXPBDW4CType@CTypes@@@Z PROC	; CBoundRecordSet::Bind, COMDAT
; _this$ = ecx

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  : 	return this->Bind(this->GetColumnIndex(sColumnName), TheConversion);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _TheConversion$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _sColumnName$[ebp]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	8b ce		 mov	 ecx, esi
  00010	e8 00 00 00 00	 call	 ?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z ; CBoundRecordSet::GetColumnIndex
  00015	50		 push	 eax
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z ; CBoundRecordSet::Bind
  0001d	5e		 pop	 esi

; 312  : }

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?Bind@CBoundRecordSet@@QAEPAXPBDW4CType@CTypes@@@Z ENDP	; CBoundRecordSet::Bind
_TEXT	ENDS
PUBLIC	?BindBinary@CBoundRecordSet@@QAEPADPBD@Z	; CBoundRecordSet::BindBinary
; Function compile flags: /Ogtp
;	COMDAT ?BindBinary@CBoundRecordSet@@QAEPADPBD@Z
_TEXT	SEGMENT
_sColumnName$ = 8					; size = 4
?BindBinary@CBoundRecordSet@@QAEPADPBD@Z PROC		; CBoundRecordSet::BindBinary, COMDAT
; _this$ = ecx

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 318  : 	return (char *) this->Bind(this->GetColumnIndex(sColumnName), CTypes::Binary);

  00003	8b 45 08	 mov	 eax, DWORD PTR _sColumnName$[ebp]
  00006	56		 push	 esi
  00007	6a fe		 push	 -2			; fffffffeH
  00009	50		 push	 eax
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z ; CBoundRecordSet::GetColumnIndex
  00011	50		 push	 eax
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z ; CBoundRecordSet::Bind
  00019	5e		 pop	 esi

; 319  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?BindBinary@CBoundRecordSet@@QAEPADPBD@Z ENDP		; CBoundRecordSet::BindBinary
_TEXT	ENDS
PUBLIC	?BindString@CBoundRecordSet@@QAEPADPBD@Z	; CBoundRecordSet::BindString
; Function compile flags: /Ogtp
;	COMDAT ?BindString@CBoundRecordSet@@QAEPADPBD@Z
_TEXT	SEGMENT
_sColumnName$ = 8					; size = 4
?BindString@CBoundRecordSet@@QAEPADPBD@Z PROC		; CBoundRecordSet::BindString, COMDAT
; _this$ = ecx

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 325  : 	return (char *) this->Bind(this->GetColumnIndex(sColumnName), CTypes::Char);

  00003	8b 45 08	 mov	 eax, DWORD PTR _sColumnName$[ebp]
  00006	56		 push	 esi
  00007	6a 01		 push	 1
  00009	50		 push	 eax
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z ; CBoundRecordSet::GetColumnIndex
  00011	50		 push	 eax
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z ; CBoundRecordSet::Bind
  00019	5e		 pop	 esi

; 326  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?BindString@CBoundRecordSet@@QAEPADPBD@Z ENDP		; CBoundRecordSet::BindString
_TEXT	ENDS
PUBLIC	?BindSignedInteger@CBoundRecordSet@@QAEAAHPBD@Z	; CBoundRecordSet::BindSignedInteger
; Function compile flags: /Ogtp
;	COMDAT ?BindSignedInteger@CBoundRecordSet@@QAEAAHPBD@Z
_TEXT	SEGMENT
_sColumnName$ = 8					; size = 4
?BindSignedInteger@CBoundRecordSet@@QAEAAHPBD@Z PROC	; CBoundRecordSet::BindSignedInteger, COMDAT
; _this$ = ecx

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 332  : 	return *(signed int *)this->Bind(this->GetColumnIndex(sColumnName), CTypes::SLong);

  00003	8b 45 08	 mov	 eax, DWORD PTR _sColumnName$[ebp]
  00006	56		 push	 esi
  00007	6a f0		 push	 -16			; fffffff0H
  00009	50		 push	 eax
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z ; CBoundRecordSet::GetColumnIndex
  00011	50		 push	 eax
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z ; CBoundRecordSet::Bind
  00019	5e		 pop	 esi

; 333  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?BindSignedInteger@CBoundRecordSet@@QAEAAHPBD@Z ENDP	; CBoundRecordSet::BindSignedInteger
_TEXT	ENDS
PUBLIC	?BindUnsignedInteger@CBoundRecordSet@@QAEAAIPBD@Z ; CBoundRecordSet::BindUnsignedInteger
; Function compile flags: /Ogtp
;	COMDAT ?BindUnsignedInteger@CBoundRecordSet@@QAEAAIPBD@Z
_TEXT	SEGMENT
_sColumnName$ = 8					; size = 4
?BindUnsignedInteger@CBoundRecordSet@@QAEAAIPBD@Z PROC	; CBoundRecordSet::BindUnsignedInteger, COMDAT
; _this$ = ecx

; 338  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 339  : 	return *(unsigned int *)this->Bind(this->GetColumnIndex(sColumnName), CTypes::ULong);

  00003	8b 45 08	 mov	 eax, DWORD PTR _sColumnName$[ebp]
  00006	56		 push	 esi
  00007	6a ee		 push	 -18			; ffffffeeH
  00009	50		 push	 eax
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z ; CBoundRecordSet::GetColumnIndex
  00011	50		 push	 eax
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z ; CBoundRecordSet::Bind
  00019	5e		 pop	 esi

; 340  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?BindUnsignedInteger@CBoundRecordSet@@QAEAAIPBD@Z ENDP	; CBoundRecordSet::BindUnsignedInteger
_TEXT	ENDS
PUBLIC	?BindDouble@CBoundRecordSet@@QAEAANPBD@Z	; CBoundRecordSet::BindDouble
; Function compile flags: /Ogtp
;	COMDAT ?BindDouble@CBoundRecordSet@@QAEAANPBD@Z
_TEXT	SEGMENT
_sColumnName$ = 8					; size = 4
?BindDouble@CBoundRecordSet@@QAEAANPBD@Z PROC		; CBoundRecordSet::BindDouble, COMDAT
; _this$ = ecx

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 346  : 	return *(double *)this->Bind(this->GetColumnIndex(sColumnName), CTypes::Double);

  00003	8b 45 08	 mov	 eax, DWORD PTR _sColumnName$[ebp]
  00006	56		 push	 esi
  00007	6a 08		 push	 8
  00009	50		 push	 eax
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z ; CBoundRecordSet::GetColumnIndex
  00011	50		 push	 eax
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z ; CBoundRecordSet::Bind
  00019	5e		 pop	 esi

; 347  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?BindDouble@CBoundRecordSet@@QAEAANPBD@Z ENDP		; CBoundRecordSet::BindDouble
_TEXT	ENDS
PUBLIC	?BindFloat@CBoundRecordSet@@QAEAAMPBD@Z		; CBoundRecordSet::BindFloat
; Function compile flags: /Ogtp
;	COMDAT ?BindFloat@CBoundRecordSet@@QAEAAMPBD@Z
_TEXT	SEGMENT
_sColumnName$ = 8					; size = 4
?BindFloat@CBoundRecordSet@@QAEAAMPBD@Z PROC		; CBoundRecordSet::BindFloat, COMDAT
; _this$ = ecx

; 352  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 353  : 	return *(float *)this->Bind(this->GetColumnIndex(sColumnName), CTypes::Float);

  00003	8b 45 08	 mov	 eax, DWORD PTR _sColumnName$[ebp]
  00006	56		 push	 esi
  00007	6a 07		 push	 7
  00009	50		 push	 eax
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z ; CBoundRecordSet::GetColumnIndex
  00011	50		 push	 eax
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z ; CBoundRecordSet::Bind
  00019	5e		 pop	 esi

; 354  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?BindFloat@CBoundRecordSet@@QAEAAMPBD@Z ENDP		; CBoundRecordSet::BindFloat
_TEXT	ENDS
PUBLIC	?BindUnsignedI64@CBoundRecordSet@@QAEAA_KPBD@Z	; CBoundRecordSet::BindUnsignedI64
; Function compile flags: /Ogtp
;	COMDAT ?BindUnsignedI64@CBoundRecordSet@@QAEAA_KPBD@Z
_TEXT	SEGMENT
_sColumnName$ = 8					; size = 4
?BindUnsignedI64@CBoundRecordSet@@QAEAA_KPBD@Z PROC	; CBoundRecordSet::BindUnsignedI64, COMDAT
; _this$ = ecx

; 359  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 360  : 	return *(unsigned __int64 *)this->Bind(this->GetColumnIndex(sColumnName), CTypes::UBigInt);

  00003	8b 45 08	 mov	 eax, DWORD PTR _sColumnName$[ebp]
  00006	56		 push	 esi
  00007	6a e5		 push	 -27			; ffffffe5H
  00009	50		 push	 eax
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z ; CBoundRecordSet::GetColumnIndex
  00011	50		 push	 eax
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z ; CBoundRecordSet::Bind
  00019	5e		 pop	 esi

; 361  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?BindUnsignedI64@CBoundRecordSet@@QAEAA_KPBD@Z ENDP	; CBoundRecordSet::BindUnsignedI64
_TEXT	ENDS
PUBLIC	?BindSignedI64@CBoundRecordSet@@QAEAA_JPBD@Z	; CBoundRecordSet::BindSignedI64
; Function compile flags: /Ogtp
;	COMDAT ?BindSignedI64@CBoundRecordSet@@QAEAA_JPBD@Z
_TEXT	SEGMENT
_sColumnName$ = 8					; size = 4
?BindSignedI64@CBoundRecordSet@@QAEAA_JPBD@Z PROC	; CBoundRecordSet::BindSignedI64, COMDAT
; _this$ = ecx

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 367  : 	return *(signed __int64 *)this->Bind(this->GetColumnIndex(sColumnName), CTypes::SBigInt);

  00003	8b 45 08	 mov	 eax, DWORD PTR _sColumnName$[ebp]
  00006	56		 push	 esi
  00007	6a e7		 push	 -25			; ffffffe7H
  00009	50		 push	 eax
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z ; CBoundRecordSet::GetColumnIndex
  00011	50		 push	 eax
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z ; CBoundRecordSet::Bind
  00019	5e		 pop	 esi

; 368  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?BindSignedI64@CBoundRecordSet@@QAEAA_JPBD@Z ENDP	; CBoundRecordSet::BindSignedI64
_TEXT	ENDS
PUBLIC	??0CBoundRecordSet@@QAE@XZ			; CBoundRecordSet::CBoundRecordSet
; Function compile flags: /Ogtp
;	COMDAT ??0CBoundRecordSet@@QAE@XZ
_TEXT	SEGMENT
??0CBoundRecordSet@@QAE@XZ PROC				; CBoundRecordSet::CBoundRecordSet, COMDAT
; _this$ = ecx

; 373  : {

  00000	8b c1		 mov	 eax, ecx

; 374  : 	this->hSTMT = NULL;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 375  : 	this->RowCount = 0;

  00007	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 376  : 	this->Columns.Count = 0;

  0000a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 377  : 
; 378  : 	this->bTrimCharData = true;

  0000d	b1 01		 mov	 cl, 1
  0000f	66 c7 40 14 01
	01		 mov	 WORD PTR [eax+20], 257	; 00000101H

; 379  : 	this->bReplaceSingleQuotes = true;
; 380  : 	this->bThrowErrors = true;

  00015	88 48 16	 mov	 BYTE PTR [eax+22], cl

; 381  : }

  00018	c3		 ret	 0
??0CBoundRecordSet@@QAE@XZ ENDP				; CBoundRecordSet::CBoundRecordSet
_TEXT	ENDS
PUBLIC	??1CBoundRecordSet@@QAE@XZ			; CBoundRecordSet::~CBoundRecordSet
; Function compile flags: /Ogtp
;	COMDAT ??1CBoundRecordSet@@QAE@XZ
_TEXT	SEGMENT
??1CBoundRecordSet@@QAE@XZ PROC				; CBoundRecordSet::~CBoundRecordSet, COMDAT
; _this$ = ecx

; 387  : 	this->hSTMT = NULL;

  00000	33 c0		 xor	 eax, eax
  00002	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 388  : 	this->RowCount = 0;

  00005	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 389  : 	this->Columns.Count = 0;

  00008	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 390  : }

  0000b	c3		 ret	 0
??1CBoundRecordSet@@QAE@XZ ENDP				; CBoundRecordSet::~CBoundRecordSet
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetErrorMessage@CBoundRecordSet@@QAE_NPAHPADH@Z ; CBoundRecordSet::GetErrorMessage
EXTRN	_SQLErrorA@32:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GetErrorMessage@CBoundRecordSet@@QAE_NPAHPADH@Z
_TEXT	SEGMENT
_iOutErrorMsgSz$ = -28					; size = 2
_sSQLState$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_iOutErr$ = 8						; size = 4
_sOutError$ = 12					; size = 4
_iErrBufSz$ = 16					; size = 4
?GetErrorMessage@CBoundRecordSet@@QAE_NPAHPADH@Z PROC	; CBoundRecordSet::GetErrorMessage, COMDAT
; _this$ = ecx

; 395  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 0c	 mov	 edx, DWORD PTR _sOutError$[ebp]
  00013	8b 45 08	 mov	 eax, DWORD PTR _iOutErr$[ebp]

; 396  : 	SQLCHAR     sSQLState[20];
; 397  : 	SQLSMALLINT iOutErrorMsgSz;
; 398  : 
; 399  : 	return SQL_SUCCEEDED(SQLErrorA(NULL, NULL, this->hSTMT, sSQLState,
; 400  : 		(SQLINTEGER *)iOutErr, (SQLCHAR *)sOutError, iErrBufSz, &iOutErrorMsgSz));

  00016	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00019	56		 push	 esi
  0001a	8d 75 e4	 lea	 esi, DWORD PTR _iOutErrorMsgSz$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 10	 mov	 esi, DWORD PTR _iErrBufSz$[ebp]
  00021	56		 push	 esi
  00022	52		 push	 edx
  00023	50		 push	 eax
  00024	8d 45 e8	 lea	 eax, DWORD PTR _sSQLState$[ebp]
  00027	50		 push	 eax
  00028	51		 push	 ecx
  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	e8 00 00 00 00	 call	 _SQLErrorA@32

; 401  : }

  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  00039	b8 00 00 00 00	 mov	 eax, 0
  0003e	0f 94 c0	 sete	 al
  00041	33 cd		 xor	 ecx, ebp
  00043	5e		 pop	 esi
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 0c 00	 ret	 12			; 0000000cH
?GetErrorMessage@CBoundRecordSet@@QAE_NPAHPADH@Z ENDP	; CBoundRecordSet::GetErrorMessage
_TEXT	ENDS
PUBLIC	??_C@_0BA@FEFDPDFC@CBoundRecordSet?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ThrowError@CBoundRecordSet@@QAE_NXZ		; CBoundRecordSet::ThrowError
;	COMDAT ??_C@_0BA@FEFDPDFC@CBoundRecordSet?$AA@
CONST	SEGMENT
??_C@_0BA@FEFDPDFC@CBoundRecordSet?$AA@ DB 'CBoundRecordSet', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ThrowError@CBoundRecordSet@@QAE_NXZ
_TEXT	SEGMENT
_iNativeError$ = -2056					; size = 4
_sErrorMsg$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
?ThrowError@CBoundRecordSet@@QAE_NXZ PROC		; CBoundRecordSet::ThrowError, COMDAT
; _this$ = ecx

; 418  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 08 00
	00		 sub	 esp, 2056		; 00000808H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 419  : 	char sErrorMsg[2048];
; 420  : 	int iNativeError = 0;
; 421  : 
; 422  : 	if(this->GetErrorMessage(&iNativeError, sErrorMsg, sizeof(sErrorMsg)))

  00014	68 00 08 00 00	 push	 2048			; 00000800H
  00019	8b f1		 mov	 esi, ecx
  0001b	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _sErrorMsg$[ebp]
  00021	50		 push	 eax
  00022	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _iNativeError$[ebp]
  00028	51		 push	 ecx
  00029	8b ce		 mov	 ecx, esi
  0002b	c7 85 f8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _iNativeError$[ebp], 0
  00035	e8 00 00 00 00	 call	 ?GetErrorMessage@CBoundRecordSet@@QAE_NPAHPADH@Z ; CBoundRecordSet::GetErrorMessage
  0003a	84 c0		 test	 al, al
  0003c	74 30		 je	 SHORT $LN2@ThrowError

; 423  : 	{
; 424  : 		if(this->pErrorHandler)

  0003e	8b 36		 mov	 esi, DWORD PTR [esi]
  00040	85 f6		 test	 esi, esi
  00042	74 19		 je	 SHORT $LN1@ThrowError

; 425  : 		{
; 426  : 			this->pErrorHandler("CBoundRecordSet", sErrorMsg, iNativeError);

  00044	8b 95 f8 f7 ff
	ff		 mov	 edx, DWORD PTR _iNativeError$[ebp]
  0004a	52		 push	 edx
  0004b	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _sErrorMsg$[ebp]
  00051	50		 push	 eax
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FEFDPDFC@CBoundRecordSet?$AA@
  00057	ff d6		 call	 esi
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 427  : 			#ifdef CSQL_THROW_HARD_ERRORS
; 428  : 				__debugbreak();

  0005c	cc		 int	 3
$LN1@ThrowError:

; 429  : 			#endif
; 430  : 		}
; 431  : 		return true;

  0005d	b0 01		 mov	 al, 1
  0005f	5e		 pop	 esi

; 432  : 	}
; 433  : 
; 434  : 	return false;
; 435  : }

  00060	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00063	33 cd		 xor	 ecx, ebp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN2@ThrowError:
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	33 cd		 xor	 ecx, ebp
  00073	32 c0		 xor	 al, al
  00075	5e		 pop	 esi
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?ThrowError@CBoundRecordSet@@QAE_NXZ ENDP		; CBoundRecordSet::ThrowError
_TEXT	ENDS
PUBLIC	?SetErrorHandler@CBoundRecordSet@@QAEXP6AHPBD0H@Z@Z ; CBoundRecordSet::SetErrorHandler
; Function compile flags: /Ogtp
;	COMDAT ?SetErrorHandler@CBoundRecordSet@@QAEXP6AHPBD0H@Z@Z
_TEXT	SEGMENT
_pHandler$ = 8						; size = 4
?SetErrorHandler@CBoundRecordSet@@QAEXP6AHPBD0H@Z@Z PROC ; CBoundRecordSet::SetErrorHandler, COMDAT
; _this$ = ecx

; 440  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 441  : 	this->pErrorHandler = pHandler;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pHandler$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 442  : }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?SetErrorHandler@CBoundRecordSet@@QAEXP6AHPBD0H@Z@Z ENDP ; CBoundRecordSet::SetErrorHandler
_TEXT	ENDS
PUBLIC	?Values@CBoundRecordSet@@QAE?AVCSQLValue@@PBD@Z	; CBoundRecordSet::Values
EXTRN	?Initialize@CSQLValue@@QAEXPAU_TAG_COLUMNINFO@@_N11@Z:PROC ; CSQLValue::Initialize
; Function compile flags: /Ogtp
;	COMDAT ?Values@CBoundRecordSet@@QAE?AVCSQLValue@@PBD@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_sColumnName$ = 12					; size = 4
?Values@CBoundRecordSet@@QAE?AVCSQLValue@@PBD@Z PROC	; CBoundRecordSet::Values, COMDAT
; _this$ = ecx

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 218  : 	int iIndex = this->GetColumnIndex(sColumnName);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _sColumnName$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?GetColumnIndex@CBoundRecordSet@@QAEHPBD@Z ; CBoundRecordSet::GetColumnIndex

; 219  : 
; 220  : 	CSQLValue SQLValue;
; 221  : 	memset(&SQLValue, 0, sizeof(SQLValue));

  00010	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00013	33 c9		 xor	 ecx, ecx
  00015	89 0f		 mov	 DWORD PTR [edi], ecx
  00017	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 222  : 
; 223  : 	if(iIndex >= 0 && iIndex < this->Columns.Count)

  0001a	85 c0		 test	 eax, eax
  0001c	78 25		 js	 SHORT $LN5@Values
  0001e	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00021	7d 20		 jge	 SHORT $LN5@Values

; 224  : 	{
; 225  : 		SQLValue.Initialize(&this->Columns.Column[iIndex],
; 226  : 			this->bTrimCharData, this->bReplaceSingleQuotes, this->bThrowErrors);

  00023	0f b6 4e 16	 movzx	 ecx, BYTE PTR [esi+22]
  00027	69 c0 20 04 00
	00		 imul	 eax, 1056		; 00000420H
  0002d	0f b6 56 15	 movzx	 edx, BYTE PTR [esi+21]
  00031	03 46 04	 add	 eax, DWORD PTR [esi+4]
  00034	51		 push	 ecx
  00035	0f b6 4e 14	 movzx	 ecx, BYTE PTR [esi+20]
  00039	52		 push	 edx
  0003a	51		 push	 ecx
  0003b	50		 push	 eax
  0003c	8b cf		 mov	 ecx, edi
  0003e	e8 00 00 00 00	 call	 ?Initialize@CSQLValue@@QAEXPAU_TAG_COLUMNINFO@@_N11@Z ; CSQLValue::Initialize
$LN5@Values:

; 227  : 	}
; 228  : 
; 229  : 	return SQLValue;

  00043	8b c7		 mov	 eax, edi
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi

; 230  : }

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
?Values@CBoundRecordSet@@QAE?AVCSQLValue@@PBD@Z ENDP	; CBoundRecordSet::Values
_TEXT	ENDS
PUBLIC	?ThrowErrorIfSet@CBoundRecordSet@@QAE_NXZ	; CBoundRecordSet::ThrowErrorIfSet
; Function compile flags: /Ogtp
;	COMDAT ?ThrowErrorIfSet@CBoundRecordSet@@QAE_NXZ
_TEXT	SEGMENT
?ThrowErrorIfSet@CBoundRecordSet@@QAE_NXZ PROC		; CBoundRecordSet::ThrowErrorIfSet, COMDAT
; _this$ = ecx

; 407  : 	if(this->bThrowErrors == true)

  00000	80 79 16 01	 cmp	 BYTE PTR [ecx+22], 1
  00004	75 05		 jne	 SHORT $LN1@ThrowError@2

; 408  : 	{
; 409  : 		return this->ThrowError();

  00006	e9 00 00 00 00	 jmp	 ?ThrowError@CBoundRecordSet@@QAE_NXZ ; CBoundRecordSet::ThrowError
$LN1@ThrowError@2:

; 410  : 	}
; 411  : 
; 412  : 	return false;

  0000b	32 c0		 xor	 al, al

; 413  : }

  0000d	c3		 ret	 0
?ThrowErrorIfSet@CBoundRecordSet@@QAE_NXZ ENDP		; CBoundRecordSet::ThrowErrorIfSet
_TEXT	ENDS
PUBLIC	?Fetch@CBoundRecordSet@@QAE_NPAH@Z		; CBoundRecordSet::Fetch
EXTRN	_SQLFetch@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Fetch@CBoundRecordSet@@QAE_NPAH@Z
_TEXT	SEGMENT
_iErrorCode$ = 8					; size = 4
?Fetch@CBoundRecordSet@@QAE_NPAH@Z PROC			; CBoundRecordSet::Fetch, COMDAT
; _this$ = ecx

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 164  : 	if(SQL_SUCCEEDED((*iErrorCode = SQLFetch(this->hSTMT))))

  00006	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _SQLFetch@4
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _iErrorCode$[ebp]
  00012	98		 cwde
  00013	89 01		 mov	 DWORD PTR [ecx], eax
  00015	a9 fe ff ff ff	 test	 eax, -2			; fffffffeH
  0001a	75 41		 jne	 SHORT $LN18@Fetch

; 165  : 	{
; 166  : 		for(int iCol = 0; iCol < this->Columns.Count; iCol++)

  0001c	57		 push	 edi
  0001d	33 ff		 xor	 edi, edi
  0001f	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  00022	7e 31		 jle	 SHORT $LN15@Fetch
  00024	33 c9		 xor	 ecx, ecx
  00026	83 ca ff	 or	 edx, -1
  00029	53		 push	 ebx
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL23@Fetch:

; 167  : 		{
; 168  : 			if(this->Columns.Column[iCol].IsBound)

  00030	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00033	80 bc 08 1c 04
	00 00 00	 cmp	 BYTE PTR [eax+ecx+1052], 0
  0003b	74 0b		 je	 SHORT $LN16@Fetch

; 169  : 			{
; 170  : 				this->Columns.Column[iCol].Data.IsNull = (this->Columns.Column[iCol].Data.Size == -1);

  0003d	39 54 08 04	 cmp	 DWORD PTR [eax+ecx+4], edx
  00041	0f 94 c3	 sete	 bl
  00044	88 5c 08 08	 mov	 BYTE PTR [eax+ecx+8], bl
$LN16@Fetch:

; 165  : 	{
; 166  : 		for(int iCol = 0; iCol < this->Columns.Count; iCol++)

  00048	47		 inc	 edi
  00049	81 c1 20 04 00
	00		 add	 ecx, 1056		; 00000420H
  0004f	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  00052	7c dc		 jl	 SHORT $LL23@Fetch
  00054	5b		 pop	 ebx
$LN15@Fetch:
  00055	5f		 pop	 edi

; 171  : 			}
; 172  : 		}
; 173  :         return true;

  00056	b0 01		 mov	 al, 1
  00058	5e		 pop	 esi

; 203  : 	}
; 204  : }

  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
$LN18@Fetch:

; 174  : 	}
; 175  : 	else {
; 176  : 		char *sErrorType = NULL;
; 177  : 
; 178  : 		if(*iErrorCode == SQL_SUCCESS){

  0005d	85 c0		 test	 eax, eax
  0005f	74 0a		 je	 SHORT $LN8@Fetch

; 179  : 			sErrorType = "SQL_SUCCESS";
; 180  : 		}
; 181  : 		else if(*iErrorCode == SQL_SUCCESS_WITH_INFO){

  00061	83 f8 01	 cmp	 eax, 1
  00064	74 05		 je	 SHORT $LN8@Fetch

; 182  : 			sErrorType = "SQL_SUCCESS_WITH_INFO";
; 183  : 		}
; 184  : 		else if(*iErrorCode == SQL_NO_DATA){

  00066	83 f8 64	 cmp	 eax, 100		; 00000064H

; 185  : 			sErrorType = "SQL_NO_DATA";
; 186  : 			return false;

  00069	74 07		 je	 SHORT $LN24@Fetch
$LN8@Fetch:

; 187  : 		}
; 188  : 		else if(*iErrorCode == SQL_STILL_EXECUTING){
; 189  : 			sErrorType = "SQL_STILL_EXECUTING";
; 190  : 		}
; 191  : 		else if(*iErrorCode == SQL_ERROR){
; 192  : 			sErrorType = "SQL_ERROR";
; 193  : 		}
; 194  : 		else if(*iErrorCode == SQL_INVALID_HANDLE){
; 195  : 			sErrorType = "SQL_INVALID_HANDLE";
; 196  : 		}
; 197  : 		else{
; 198  : 			sErrorType = "OTHER";
; 199  : 		}
; 200  : 
; 201  : 		this->ThrowErrorIfSet();

  0006b	8b ce		 mov	 ecx, esi
  0006d	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CBoundRecordSet@@QAE_NXZ ; CBoundRecordSet::ThrowErrorIfSet
$LN24@Fetch:

; 202  : 		return false;

  00072	32 c0		 xor	 al, al
  00074	5e		 pop	 esi

; 203  : 	}
; 204  : }

  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
?Fetch@CBoundRecordSet@@QAE_NPAH@Z ENDP			; CBoundRecordSet::Fetch
_TEXT	ENDS
PUBLIC	?Fetch@CBoundRecordSet@@QAE_NXZ			; CBoundRecordSet::Fetch
; Function compile flags: /Ogtp
;	COMDAT ?Fetch@CBoundRecordSet@@QAE_NXZ
_TEXT	SEGMENT
_iErrorCode$ = -4					; size = 4
?Fetch@CBoundRecordSet@@QAE_NXZ PROC			; CBoundRecordSet::Fetch, COMDAT
; _this$ = ecx

; 209  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 210  : 	int iErrorCode = 0;
; 211  : 	return this->Fetch(&iErrorCode);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iErrorCode$[ebp]
  00007	50		 push	 eax
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iErrorCode$[ebp], 0
  0000f	e8 00 00 00 00	 call	 ?Fetch@CBoundRecordSet@@QAE_NPAH@Z ; CBoundRecordSet::Fetch

; 212  : }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?Fetch@CBoundRecordSet@@QAE_NXZ ENDP			; CBoundRecordSet::Fetch
_TEXT	ENDS
END
