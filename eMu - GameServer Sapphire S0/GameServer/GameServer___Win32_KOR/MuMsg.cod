; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\MuMsg.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CN@EJHEHGKB@Error?5Message?5?$DMCan?8t?5Find?5Specif@ ; `string'
PUBLIC	??_7CMsg@@6B@					; CMsg::`vftable'
PUBLIC	??0CMsg@@QAE@XZ					; CMsg::CMsg
PUBLIC	??_R4CMsg@@6B@					; CMsg::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMsg@@@8				; CMsg `RTTI Type Descriptor'
PUBLIC	??_R3CMsg@@8					; CMsg::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMsg@@8					; CMsg::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMsg@@8				; CMsg::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECMsg@@UAEPAXI@Z:PROC			; CMsg::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CMsg@@8
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\mumsg.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CMsg@@8 DD FLAT:??_R0?AVCMsg@@@8		; CMsg::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMsg@@8
rdata$r	ENDS
;	COMDAT ??_R2CMsg@@8
rdata$r	SEGMENT
??_R2CMsg@@8 DD	FLAT:??_R1A@?0A@EA@CMsg@@8		; CMsg::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMsg@@8
rdata$r	SEGMENT
??_R3CMsg@@8 DD	00H					; CMsg::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMsg@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMsg@@@8
_DATA	SEGMENT
??_R0?AVCMsg@@@8 DD FLAT:??_7type_info@@6B@		; CMsg `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMsg@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CMsg@@6B@
rdata$r	SEGMENT
??_R4CMsg@@6B@ DD 00H					; CMsg::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMsg@@@8
	DD	FLAT:??_R3CMsg@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CN@EJHEHGKB@Error?5Message?5?$DMCan?8t?5Find?5Specif@
CONST	SEGMENT
??_C@_0CN@EJHEHGKB@Error?5Message?5?$DMCan?8t?5Find?5Specif@ DB 'Error Me'
	DB	'ssage <Can''t Find Specific Message>.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7CMsg@@6B@
CONST	SEGMENT
??_7CMsg@@6B@ DD FLAT:??_R4CMsg@@6B@			; CMsg::`vftable'
	DD	FLAT:??_ECMsg@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0CMsg@@QAE@XZ
_TEXT	SEGMENT
??0CMsg@@QAE@XZ PROC					; CMsg::CMsg, COMDAT
; _this$ = ecx

; 7    : {

  00000	56		 push	 esi
  00001	8b c1		 mov	 eax, ecx
  00003	57		 push	 edi
  00004	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMsg@@6B@

; 8    : 	this->Msghead = NULL;

  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 9    : 	
; 10   : 	strcpy(this->szDefaultMsg, "Error Message <Can't Find Specific Message>.");

  00011	8d b8 28 00 02
	00		 lea	 edi, DWORD PTR [eax+131112]
  00017	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0001c	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0CN@EJHEHGKB@Error?5Message?5?$DMCan?8t?5Find?5Specif@
  00021	f3 a5		 rep movsd
  00023	a4		 movsb
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi

; 11   : }

  00026	c3		 ret	 0
??0CMsg@@QAE@XZ ENDP					; CMsg::CMsg
_TEXT	ENDS
PUBLIC	?XorBuffer@CMsg@@AAEXPADH@Z			; CMsg::XorBuffer
; Function compile flags: /Ogtp
;	COMDAT ?XorBuffer@CMsg@@AAEXPADH@Z
_TEXT	SEGMENT
_buff$ = 8						; size = 4
_len$ = 12						; size = 4
?XorBuffer@CMsg@@AAEXPADH@Z PROC			; CMsg::XorBuffer, COMDAT
; _this$ = ecx

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 20   : 	if (len <= 0) return;

  00003	8b 55 0c	 mov	 edx, DWORD PTR _len$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	7e 12		 jle	 SHORT $LN1@XorBuffer

; 21   : 	
; 22   : 	for( int iCounter = 0; iCounter < len; ++iCounter)

  0000a	33 c0		 xor	 eax, eax
  0000c	85 d2		 test	 edx, edx
  0000e	7e 0c		 jle	 SHORT $LN1@XorBuffer
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _buff$[ebp]
$LL3@XorBuffer:

; 23   : 	{
; 24   : 		buff[iCounter] = buff[iCounter]^0xCA;

  00013	80 34 08 ca	 xor	 BYTE PTR [eax+ecx], -54	; ffffffcaH
  00017	40		 inc	 eax
  00018	3b c2		 cmp	 eax, edx
  0001a	7c f7		 jl	 SHORT $LL3@XorBuffer
$LN1@XorBuffer:

; 25   : 	}
; 26   : }

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?XorBuffer@CMsg@@AAEXPADH@Z ENDP			; CMsg::XorBuffer
_TEXT	ENDS
PUBLIC	??_C@_0CA@OBAGPFFE@Memory?5Allocation?5Error?5?$CIMuMsg?$CJ?$AA@ ; `string'
PUBLIC	??_C@_05NAOIJFC@Error?$AA@			; `string'
PUBLIC	?lMsgListInit@CMsg@@AAE_NXZ			; CMsg::lMsgListInit
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	_memset:PROC
;	COMDAT ??_C@_0CA@OBAGPFFE@Memory?5Allocation?5Error?5?$CIMuMsg?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@OBAGPFFE@Memory?5Allocation?5Error?5?$CIMuMsg?$CJ?$AA@ DB 'Memo'
	DB	'ry Allocation Error (MuMsg)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error?$AA@
CONST	SEGMENT
??_C@_05NAOIJFC@Error?$AA@ DB 'Error', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?lMsgListInit@CMsg@@AAE_NXZ
_TEXT	SEGMENT
?lMsgListInit@CMsg@@AAE_NXZ PROC			; CMsg::lMsgListInit, COMDAT
; _this$ = ecx

; 85   : {

  00000	56		 push	 esi

; 86   : 	LPMSG_STRUCT Msg = new MSG_STRUCT;

  00001	6a 0c		 push	 12			; 0000000cH
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 87   : 	
; 88   : 	if ( Msg == NULL )

  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 c4 04	 add	 esp, 4
  0000f	3b c1		 cmp	 eax, ecx
  00011	75 16		 jne	 SHORT $LN1@lMsgListIn

; 89   : 	{
; 90   : 		MessageBox(NULL, "Memory Allocation Error (MuMsg)", "Error", MB_OK);

  00013	51		 push	 ecx
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@OBAGPFFE@Memory?5Allocation?5Error?5?$CIMuMsg?$CJ?$AA@
  0001e	51		 push	 ecx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 91   : 		
; 92   : 		return false;

  00025	32 c0		 xor	 al, al
  00027	5e		 pop	 esi

; 102  : }

  00028	c3		 ret	 0
$LN1@lMsgListIn:

; 93   : 	}
; 94   : 	
; 95   : 	Msg->next	= NULL;
; 96   : 	Msg->number = 0;
; 97   : 	Msg->msg	= NULL;
; 98   : 	
; 99   : 	memset(this->MsgIndex, 0, sizeof(this->MsgIndex));

  00029	68 00 00 02 00	 push	 131072			; 00020000H
  0002e	51		 push	 ecx
  0002f	83 c6 0c	 add	 esi, 12			; 0000000cH
  00032	56		 push	 esi
  00033	89 08		 mov	 DWORD PTR [eax], ecx
  00035	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00038	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0003b	e8 00 00 00 00	 call	 _memset
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 100  : 	// -----
; 101  : 	return true;

  00043	b0 01		 mov	 al, 1
  00045	5e		 pop	 esi

; 102  : }

  00046	c3		 ret	 0
?lMsgListInit@CMsg@@AAE_NXZ ENDP			; CMsg::lMsgListInit
_TEXT	ENDS
PUBLIC	?lMsgFree@CMsg@@AAEXXZ				; CMsg::lMsgFree
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtp
;	COMDAT ?lMsgFree@CMsg@@AAEXXZ
_TEXT	SEGMENT
?lMsgFree@CMsg@@AAEXXZ PROC				; CMsg::lMsgFree, COMDAT
; _this$ = ecx

; 105  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 106  : 	for (int n = 0; n < 32768; n++)

  00002	8d 71 0c	 lea	 esi, DWORD PTR [ecx+12]
  00005	bf 00 80 00 00	 mov	 edi, 32768		; 00008000H
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL4@lMsgFree:

; 107  : 	{
; 108  : 		if (this->MsgIndex[n] != 0)

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	85 c0		 test	 eax, eax
  00014	74 14		 je	 SHORT $LN3@lMsgFree

; 109  : 		{
; 110  : 			delete[] this->MsgIndex[n]->msg;

  00016	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 111  : 			// -----
; 112  : 			delete this->MsgIndex[n];

  0001f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN3@lMsgFree:

; 106  : 	for (int n = 0; n < 32768; n++)

  0002a	83 c6 04	 add	 esi, 4
  0002d	4f		 dec	 edi
  0002e	75 e0		 jne	 SHORT $LL4@lMsgFree

; 113  : 		}
; 114  : 	}
; 115  : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	c3		 ret	 0
?lMsgFree@CMsg@@AAEXXZ ENDP				; CMsg::lMsgFree
_TEXT	ENDS
PUBLIC	?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ		; CMsg::lMsgListNew
; Function compile flags: /Ogtp
;	COMDAT ?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ
_TEXT	SEGMENT
?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ PROC		; CMsg::lMsgListNew, COMDAT
; _this$ = ecx

; 119  : 	return new MSG_STRUCT;

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 120  : }

  0000a	c3		 ret	 0
?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ ENDP		; CMsg::lMsgListNew
_TEXT	ENDS
PUBLIC	??_C@_0BP@CIHPAEKD@Message?5Index?5Table?5Make?5Error?$AA@ ; `string'
PUBLIC	??_C@_0CC@PKJPBHBB@Memory?5Allocation?5Error?5?$CD2?$CIMuMsg@ ; `string'
PUBLIC	?lMsgListAdd@CMsg@@AAE_NHPAE@Z			; CMsg::lMsgListAdd
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
;	COMDAT ??_C@_0BP@CIHPAEKD@Message?5Index?5Table?5Make?5Error?$AA@
CONST	SEGMENT
??_C@_0BP@CIHPAEKD@Message?5Index?5Table?5Make?5Error?$AA@ DB 'Message In'
	DB	'dex Table Make Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PKJPBHBB@Memory?5Allocation?5Error?5?$CD2?$CIMuMsg@
CONST	SEGMENT
??_C@_0CC@PKJPBHBB@Memory?5Allocation?5Error?5?$CD2?$CIMuMsg@ DB 'Memory '
	DB	'Allocation Error #2(MuMsg)', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?lMsgListAdd@CMsg@@AAE_NHPAE@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
_cMsg$ = 12						; size = 4
?lMsgListAdd@CMsg@@AAE_NHPAE@Z PROC			; CMsg::lMsgListAdd, COMDAT
; _this$ = ecx

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 124  : 	int		MsgLen		= strlen((CHAR*)cMsg);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _cMsg$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000e	8b ff		 npad	 2
$LL11@lMsgListAd:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL11@lMsgListAd
  00017	2b c2		 sub	 eax, edx
  00019	8b d8		 mov	 ebx, eax

; 125  : 	CHAR*	pPointer;
; 126  : 	
; 127  : 	if (MsgLen > 0)

  0001b	85 db		 test	 ebx, ebx
  0001d	0f 8e 87 00 00
	00		 jle	 $LN1@lMsgListAd

; 128  : 	{
; 129  : 		this->MsgIndex[index] = this->lMsgListNew();

  00023	8b cf		 mov	 ecx, edi
  00025	e8 00 00 00 00	 call	 ?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ ; CMsg::lMsgListNew
  0002a	8b 75 08	 mov	 esi, DWORD PTR _index$[ebp]
  0002d	89 44 b7 0c	 mov	 DWORD PTR [edi+esi*4+12], eax

; 130  : 		
; 131  : 		if (this->MsgIndex[index] == 0)

  00031	85 c0		 test	 eax, eax
  00033	75 1b		 jne	 SHORT $LN5@lMsgListAd

; 132  : 		{
; 133  : 			MessageBox(NULL, "Memory Allocation Error #2(MuMsg)", "Error", MB_OK); // Me

  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PKJPBHBB@Memory?5Allocation?5Error?5?$CD2?$CIMuMsg@
  00040	50		 push	 eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 134  : 			return false;

  00049	32 c0		 xor	 al, al
  0004b	5b		 pop	 ebx

; 159  : }

  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
$LN5@lMsgListAd:

; 135  : 		}
; 136  : 		
; 137  : 		pPointer = new char[MsgLen+1];

  00050	43		 inc	 ebx
  00051	53		 push	 ebx
  00052	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00057	83 c4 04	 add	 esp, 4

; 138  : 		
; 139  : 		if (pPointer  != 0)

  0005a	85 c0		 test	 eax, eax
  0005c	74 4c		 je	 SHORT $LN1@lMsgListAd

; 140  : 		{
; 141  : 			this->MsgIndex[index]->number = index;

  0005e	8b 4c b7 0c	 mov	 ecx, DWORD PTR [edi+esi*4+12]
  00062	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 142  : 			
; 143  : 			if (index >= 0 || index < 32767)

  00065	85 f6		 test	 esi, esi
  00067	79 25		 jns	 SHORT $LN2@lMsgListAd
  00069	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  0006f	7c 1d		 jl	 SHORT $LN2@lMsgListAd

; 148  : 				return true;
; 149  : 			}
; 150  : 			else
; 151  : 			{
; 152  : 				MessageBox(NULL, "Message Index Table Make Error", "Error", MB_OK);

  00071	6a 00		 push	 0
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@CIHPAEKD@Message?5Index?5Table?5Make?5Error?$AA@
  0007d	6a 00		 push	 0
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi

; 153  : 				return false;

  00087	32 c0		 xor	 al, al
  00089	5b		 pop	 ebx

; 159  : }

  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
$LN2@lMsgListAd:

; 144  : 			{
; 145  : 				this->MsgIndex[index]->msg = (UCHAR*)pPointer;

  0008e	8b 54 b7 0c	 mov	 edx, DWORD PTR [edi+esi*4+12]

; 146  : 				
; 147  : 				strcpy((CHAR*)this->MsgIndex[index]->msg, (CHAR*)cMsg);

  00092	8b 4d 0c	 mov	 ecx, DWORD PTR _cMsg$[ebp]
  00095	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00098	8b 44 b7 0c	 mov	 eax, DWORD PTR [edi+esi*4+12]
  0009c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0009f	90		 npad	 1
$LL9@lMsgListAd:
  000a0	8a 01		 mov	 al, BYTE PTR [ecx]
  000a2	88 02		 mov	 BYTE PTR [edx], al
  000a4	41		 inc	 ecx
  000a5	42		 inc	 edx
  000a6	84 c0		 test	 al, al
  000a8	75 f6		 jne	 SHORT $LL9@lMsgListAd
$LN1@lMsgListAd:
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi

; 154  : 			}
; 155  : 		}
; 156  : 	}
; 157  : 	
; 158  : 	return true;

  000ac	b0 01		 mov	 al, 1
  000ae	5b		 pop	 ebx

; 159  : }

  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8
?lMsgListAdd@CMsg@@AAE_NHPAE@Z ENDP			; CMsg::lMsgListAdd
_TEXT	ENDS
PUBLIC	??_C@_07BEIHKDLJ@Message?$AA@			; `string'
PUBLIC	?lMsgListPrint@CMsg@@AAEXXZ			; CMsg::lMsgListPrint
;	COMDAT ??_C@_07BEIHKDLJ@Message?$AA@
CONST	SEGMENT
??_C@_07BEIHKDLJ@Message?$AA@ DB 'Message', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?lMsgListPrint@CMsg@@AAEXXZ
_TEXT	SEGMENT
?lMsgListPrint@CMsg@@AAEXXZ PROC			; CMsg::lMsgListPrint, COMDAT
; _this$ = ecx

; 162  : {

  00000	53		 push	 ebx

; 163  : 	for (int n = 0; n < 32768; ++n)

  00001	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__MessageBoxA@16
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8d 71 0c	 lea	 esi, DWORD PTR [ecx+12]
  0000c	bf 00 80 00 00	 mov	 edi, 32768		; 00008000H
$LL4@lMsgListPr:

; 164  : 	{
; 165  : 		if (this->MsgIndex[n] != 0)

  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	85 c0		 test	 eax, eax
  00015	74 0f		 je	 SHORT $LN3@lMsgListPr

; 166  : 		{
; 167  : 			MessageBox(NULL, (char*)this->MsgIndex[n]->msg, "Message", MB_OK);

  00017	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_07BEIHKDLJ@Message?$AA@
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	ff d3		 call	 ebx
$LN3@lMsgListPr:

; 163  : 	for (int n = 0; n < 32768; ++n)

  00026	83 c6 04	 add	 esi, 4
  00029	4f		 dec	 edi
  0002a	75 e5		 jne	 SHORT $LL4@lMsgListPr

; 168  : 		}
; 169  : 	}
; 170  : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	c3		 ret	 0
?lMsgListPrint@CMsg@@AAEXXZ ENDP			; CMsg::lMsgListPrint
_TEXT	ENDS
PUBLIC	?Get@CMsg@@QAEPADH@Z				; CMsg::Get
; Function compile flags: /Ogtp
;	COMDAT ?Get@CMsg@@QAEPADH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?Get@CMsg@@QAEPADH@Z PROC				; CMsg::Get, COMDAT
; _this$ = ecx

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 174  : 	if (index >= 0 && index < 32768)

  00003	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00006	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0000b	77 14		 ja	 SHORT $LN4@Get

; 175  : 	{
; 176  : 		if (this->MsgIndex[index] == 0)

  0000d	8b 44 81 0c	 mov	 eax, DWORD PTR [ecx+eax*4+12]
  00011	85 c0		 test	 eax, eax

; 177  : 		{
; 178  : 			return this->szDefaultMsg;

  00013	74 0c		 je	 SHORT $LN4@Get

; 179  : 		}
; 180  : 		
; 181  : 		if (this->MsgIndex[index]->msg == 0)

  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	85 c0		 test	 eax, eax

; 182  : 		{
; 183  : 			return this->szDefaultMsg;

  0001a	74 05		 je	 SHORT $LN4@Get

; 184  : 		}
; 185  : 		
; 186  : 		if (*this->MsgIndex[index]->msg == 0)

  0001c	80 38 00	 cmp	 BYTE PTR [eax], 0

; 187  : 		{
; 188  : 			return this->szDefaultMsg;
; 189  : 		}
; 190  : 		
; 191  : 		return (char*)this->MsgIndex[index]->msg;

  0001f	75 06		 jne	 SHORT $LN5@Get
$LN4@Get:

; 192  : 	}
; 193  : 	
; 194  : 	return (char*)this->szDefaultMsg;	

  00021	8d 81 28 00 02
	00		 lea	 eax, DWORD PTR [ecx+131112]
$LN5@Get:

; 195  : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?Get@CMsg@@QAEPADH@Z ENDP				; CMsg::Get
_TEXT	ENDS
PUBLIC	??1CMsg@@UAE@XZ					; CMsg::~CMsg
; Function compile flags: /Ogtp
;	COMDAT ??1CMsg@@UAE@XZ
_TEXT	SEGMENT
??1CMsg@@UAE@XZ PROC					; CMsg::~CMsg, COMDAT
; _this$ = ecx

; 14   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMsg@@6B@

; 15   : 	this->lMsgFree();

  00006	e9 00 00 00 00	 jmp	 ?lMsgFree@CMsg@@AAEXXZ	; CMsg::lMsgFree
??1CMsg@@UAE@XZ ENDP					; CMsg::~CMsg
_TEXT	ENDS
PUBLIC	??_C@_0BO@BPGIDDGH@Number?5of?5data?5reading?5error?4?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DataFileLoad@CMsg@@AAEXPAU_iobuf@@@Z		; CMsg::DataFileLoad
EXTRN	_fread:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0BO@BPGIDDGH@Number?5of?5data?5reading?5error?4?$AA@
CONST	SEGMENT
??_C@_0BO@BPGIDDGH@Number?5of?5data?5reading?5error?4?$AA@ DB 'Number of '
	DB	'data reading error.', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DataFileLoad@CMsg@@AAEXPAU_iobuf@@@Z
_TEXT	SEGMENT
_Index$ = -268						; size = 2
_Len$ = -264						; size = 2
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?DataFileLoad@CMsg@@AAEXPAU_iobuf@@@Z PROC		; CMsg::DataFileLoad, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]
  00018	8b d9		 mov	 ebx, ecx
  0001a	57		 push	 edi

; 30   : 	UCHAR	szTemp[256];
; 31   : 	SHORT	Index;
; 32   : 	USHORT	Len;
; 33   : 	
; 34   : 	int Max = this->LoadHeader.count;

  0001b	8b bb 24 00 02
	00		 mov	 edi, DWORD PTR [ebx+131108]

; 35   : 	
; 36   : 	if (Max <= 0)

  00021	85 ff		 test	 edi, edi
  00023	7f 2b		 jg	 SHORT $LL2@DataFileLo

; 37   : 	{
; 38   : 		MessageBox(NULL, "Number of data reading error."	, "Error", MB_OK|MB_APPLMODAL); // Modification error data while reading

  00025	6a 00		 push	 0
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BPGIDDGH@Number?5of?5data?5reading?5error?4?$AA@
  00031	6a 00		 push	 0
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 54   : 	} 
; 55   : }

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003f	33 cd		 xor	 ecx, ebp
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
  0004c	8d 64 24 00	 npad	 4
$LL2@DataFileLo:

; 39   : 		return;
; 40   : 	}
; 41   : 	
; 42   : 	while (Max--)
; 43   : 	{
; 44   : 		memset(&szTemp, 0, sizeof(szTemp));

  00050	68 00 01 00 00	 push	 256			; 00000100H
  00055	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0005b	6a 00		 push	 0
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _memset

; 45   : 		
; 46   : 		fread(&Index, 2, 1, filename);

  00063	56		 push	 esi
  00064	6a 01		 push	 1
  00066	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _Index$[ebp]
  0006c	6a 02		 push	 2
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _fread

; 47   : 		fread(&Len, 2, 1, filename);

  00074	56		 push	 esi
  00075	6a 01		 push	 1
  00077	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _Len$[ebp]
  0007d	6a 02		 push	 2
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 _fread

; 48   : 		fread(szTemp, Len, 1, filename);

  00085	0f b7 85 f8 fe
	ff ff		 movzx	 eax, WORD PTR _Len$[ebp]
  0008c	56		 push	 esi
  0008d	6a 01		 push	 1
  0008f	50		 push	 eax
  00090	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _fread

; 49   : 		
; 50   : 		szTemp[Len] = 0;

  0009c	0f b7 85 f8 fe
	ff ff		 movzx	 eax, WORD PTR _Len$[ebp]
  000a3	83 c4 3c	 add	 esp, 60			; 0000003cH

; 51   : 		
; 52   : 		this->XorBuffer((CHAR*)szTemp, Len);

  000a6	50		 push	 eax
  000a7	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  000ad	52		 push	 edx
  000ae	8b cb		 mov	 ecx, ebx
  000b0	c6 84 05 fc fe
	ff ff 00	 mov	 BYTE PTR _szTemp$[ebp+eax], 0
  000b8	e8 00 00 00 00	 call	 ?XorBuffer@CMsg@@AAEXPADH@Z ; CMsg::XorBuffer

; 53   : 		this->lMsgListAdd(Index, (UCHAR*) szTemp);

  000bd	0f bf 8d f4 fe
	ff ff		 movsx	 ecx, WORD PTR _Index$[ebp]
  000c4	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  000ca	50		 push	 eax
  000cb	51		 push	 ecx
  000cc	8b cb		 mov	 ecx, ebx
  000ce	e8 00 00 00 00	 call	 ?lMsgListAdd@CMsg@@AAE_NHPAE@Z ; CMsg::lMsgListAdd
  000d3	4f		 dec	 edi
  000d4	0f 85 76 ff ff
	ff		 jne	 $LL2@DataFileLo

; 54   : 	} 
; 55   : }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	33 cd		 xor	 ecx, ebp
  000e1	5b		 pop	 ebx
  000e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 04 00	 ret	 4
?DataFileLoad@CMsg@@AAEXPAU_iobuf@@@Z ENDP		; CMsg::DataFileLoad
_TEXT	ENDS
PUBLIC	??_C@_0CC@NDIMOEJH@Version?5of?5data?5is?5not?5supported@ ; `string'
PUBLIC	??_C@_0BF@OLFGABCH@TextCode?5Type?5Wrong?4?$AA@	; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	?LoadWTF@CMsg@@QAEXPAD@Z			; CMsg::LoadWTF
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
;	COMDAT ??_C@_0CC@NDIMOEJH@Version?5of?5data?5is?5not?5supported@
CONST	SEGMENT
??_C@_0CC@NDIMOEJH@Version?5of?5data?5is?5not?5supported@ DB 'Version of '
	DB	'data is not supported.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OLFGABCH@TextCode?5Type?5Wrong?4?$AA@
CONST	SEGMENT
??_C@_0BF@OLFGABCH@TextCode?5Type?5Wrong?4?$AA@ DB 'TextCode Type Wrong.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LoadWTF@CMsg@@QAEXPAD@Z
_TEXT	SEGMENT
_filename$ = 8						; size = 4
?LoadWTF@CMsg@@QAEXPAD@Z PROC				; CMsg::LoadWTF, COMDAT
; _this$ = ecx

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 59   : 	FILE * WTFFile = 0;
; 60   : 	
; 61   : 	if (( WTFFile = fopen(filename, "rb")) == NULL) return;

  00003	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0000d	50		 push	 eax
  0000e	8b f9		 mov	 edi, ecx
  00010	e8 00 00 00 00	 call	 _fopen
  00015	8b d8		 mov	 ebx, eax
  00017	83 c4 08	 add	 esp, 8
  0001a	85 db		 test	 ebx, ebx
  0001c	0f 84 87 00 00
	00		 je	 $LN5@LoadWTF

; 62   : 	
; 63   : 	if (this->lMsgListInit() != 0)

  00022	8b cf		 mov	 ecx, edi
  00024	e8 00 00 00 00	 call	 ?lMsgListInit@CMsg@@AAE_NXZ ; CMsg::lMsgListInit
  00029	84 c0		 test	 al, al
  0002b	74 7c		 je	 SHORT $LN5@LoadWTF

; 64   : 	{
; 65   : 		fread(&this->LoadHeader, 28, 1, WTFFile);

  0002d	56		 push	 esi
  0002e	53		 push	 ebx
  0002f	6a 01		 push	 1
  00031	8d b7 0c 00 02
	00		 lea	 esi, DWORD PTR [edi+131084]
  00037	6a 1c		 push	 28			; 0000001cH
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 _fread
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 66   : 		
; 67   : 		if (this->LoadHeader.headcode != 0xCC)

  00042	80 3e cc	 cmp	 BYTE PTR [esi], 204	; 000000ccH
  00045	5e		 pop	 esi
  00046	74 23		 je	 SHORT $LN4@LoadWTF

; 68   : 		{
; 69   : 			MessageBox(NULL, "TextCode Type Wrong.", "Error", MB_OK|MB_APPLMODAL);

  00048	6a 00		 push	 0
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OLFGABCH@TextCode?5Type?5Wrong?4?$AA@
  00054	6a 00		 push	 0
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 78   : 		}
; 79   : 		
; 80   : 		fclose(WTFFile);

  0005c	53		 push	 ebx
  0005d	e8 00 00 00 00	 call	 _fclose
  00062	83 c4 04	 add	 esp, 4
  00065	5f		 pop	 edi
  00066	5b		 pop	 ebx

; 81   : 	}
; 82   : }

  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
$LN4@LoadWTF:

; 70   : 		}
; 71   : 		else if ((this->LoadHeader.version -1) != 0)

  0006b	0f b6 8f 0d 00
	02 00		 movzx	 ecx, BYTE PTR [edi+131085]
  00072	49		 dec	 ecx
  00073	74 23		 je	 SHORT $LN2@LoadWTF

; 72   : 		{
; 73   : 			MessageBox(NULL, "Version of data is not supported.", "Error", MB_OK|MB_APPLMODAL);

  00075	6a 00		 push	 0
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@NDIMOEJH@Version?5of?5data?5is?5not?5supported@
  00081	6a 00		 push	 0
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 78   : 		}
; 79   : 		
; 80   : 		fclose(WTFFile);

  00089	53		 push	 ebx
  0008a	e8 00 00 00 00	 call	 _fclose
  0008f	83 c4 04	 add	 esp, 4
  00092	5f		 pop	 edi
  00093	5b		 pop	 ebx

; 81   : 	}
; 82   : }

  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
$LN2@LoadWTF:

; 74   : 		}
; 75   : 		else
; 76   : 		{
; 77   : 			DataFileLoad(WTFFile);

  00098	53		 push	 ebx
  00099	8b cf		 mov	 ecx, edi
  0009b	e8 00 00 00 00	 call	 ?DataFileLoad@CMsg@@AAEXPAU_iobuf@@@Z ; CMsg::DataFileLoad

; 78   : 		}
; 79   : 		
; 80   : 		fclose(WTFFile);

  000a0	53		 push	 ebx
  000a1	e8 00 00 00 00	 call	 _fclose
  000a6	83 c4 04	 add	 esp, 4
$LN5@LoadWTF:
  000a9	5f		 pop	 edi
  000aa	5b		 pop	 ebx

; 81   : 	}
; 82   : }

  000ab	5d		 pop	 ebp
  000ac	c2 04 00	 ret	 4
?LoadWTF@CMsg@@QAEXPAD@Z ENDP				; CMsg::LoadWTF
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCMsg@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMsg@@UAEPAXI@Z PROC				; CMsg::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMsg@@UAE@XZ		; CMsg::~CMsg
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCMsg@@UAEPAXI@Z ENDP				; CMsg::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__ElMsg@@YAXXZ
text$yc	SEGMENT
??__ElMsg@@YAXXZ PROC					; `dynamic initializer for 'lMsg'', COMDAT

; 4    : CMsg lMsg;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00005	e8 00 00 00 00	 call	 ??0CMsg@@QAE@XZ		; CMsg::CMsg
  0000a	68 00 00 00 00	 push	 OFFSET ??__FlMsg@@YAXXZ	; `dynamic atexit destructor for 'lMsg''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__ElMsg@@YAXXZ ENDP					; `dynamic initializer for 'lMsg''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__FlMsg@@YAXXZ
text$yd	SEGMENT
??__FlMsg@@YAXXZ PROC					; `dynamic atexit destructor for 'lMsg'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00005	e9 00 00 00 00	 jmp	 ??1CMsg@@UAE@XZ		; CMsg::~CMsg
??__FlMsg@@YAXXZ ENDP					; `dynamic atexit destructor for 'lMsg''
text$yd	ENDS
PUBLIC	?lMsg@@3VCMsg@@A				; lMsg
_BSS	SEGMENT
?lMsg@@3VCMsg@@A DB 02005cH DUP (?)			; lMsg
_BSS	ENDS
CRT$XCU	SEGMENT
_lMsg$initializer$ DD FLAT:??__ElMsg@@YAXXZ
CRT$XCU	ENDS
END
