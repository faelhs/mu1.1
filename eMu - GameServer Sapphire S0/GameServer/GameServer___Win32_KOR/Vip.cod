; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\Vip.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?gVip@@3VCVip@@A				; gVip
_BSS	SEGMENT
?gVip@@3VCVip@@A DB 0f0H DUP (?)			; gVip
_BSS	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_ungetc:PROC
EXTRN	_getc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_TokenNumber DD	01H DUP (?)
_CurrentToken DD 01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	TokenString[0] = '\0';

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL30@GetToken:

; 27   : 
; 28   : 	do
; 29   : 	{
; 30   : 		// ÇöÀç ÆÄÀÏÀÇ ³¡ÀÌ¸é END ¸®ÅÏ
; 31   : 		if( (ch = (char)fgetc(SMDFile)) == EOF )

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 5f		 je	 SHORT $LN39@GetToken

; 33   : 
; 34   : 		// ¸¸ÀÏ // °ªÀÌ¸é '\n'ÀÌ ³ª¿Ã¶§ ±îÁö µ¹¾Æ¶ó.
; 35   : 		if( ch == '/' && ( ch = (char)fgetc(SMDFile) ) == '/' )	

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 2c		 jne	 SHORT $LN29@GetToken
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 16		 jne	 SHORT $LN29@GetToken
$LL25@GetToken:

; 36   : 		{
; 37   : 			while( (ch = (char)fgetc(SMDFile)) != '\n' );

  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 _fgetc
  0005c	8a d8		 mov	 bl, al
  0005e	83 c4 04	 add	 esp, 4
  00061	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00064	75 ea		 jne	 SHORT $LL25@GetToken
$LN29@GetToken:

; 38   : 		}
; 39   : 	} while( isspace(ch) );

  00066	0f be c3	 movsx	 eax, bl
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _isspace
  0006f	83 c4 04	 add	 esp, 4
  00072	85 c0		 test	 eax, eax
  00074	75 aa		 jne	 SHORT $LL30@GetToken

; 40   : 	
; 41   : 	char *p, TempString[100];
; 42   : 
; 43   : 	switch(ch)

  00076	0f be c3	 movsx	 eax, bl
  00079	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  0007c	56		 push	 esi
  0007d	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00080	0f 87 8d 01 00
	00		 ja	 $LN5@GetToken
  00086	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN45@GetToken[ecx]
  0008d	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN49@GetToken[ecx*4]
$LN39@GetToken:

; 32   : 			return END;

  00094	b8 02 00 00 00	 mov	 eax, 2
  00099	5b		 pop	 ebx

; 92   : 	}
; 93   : }

  0009a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009d	33 cd		 xor	 ecx, ebp
  0009f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
$LN21@GetToken:

; 44   : 	{	
; 45   : 	case '#':
; 46   : 		p = TokenString;
; 47   : 		while ( ( (ch = getc(SMDFile) ) != EOF) && (ch!='#'))// || isalnum(ch)) )

  000a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000ae	52		 push	 edx
  000af	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  000b4	e8 00 00 00 00	 call	 _getc
  000b9	83 c4 04	 add	 esp, 4
  000bc	3c ff		 cmp	 al, -1
  000be	74 19		 je	 SHORT $LN19@GetToken
$LL20@GetToken:
  000c0	3c 23		 cmp	 al, 35			; 00000023H
  000c2	74 2c		 je	 SHORT $LN18@GetToken

; 48   : 			*p++ = ch;

  000c4	88 06		 mov	 BYTE PTR [esi], al
  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000cb	50		 push	 eax
  000cc	46		 inc	 esi
  000cd	e8 00 00 00 00	 call	 _getc
  000d2	83 c4 04	 add	 esp, 4
  000d5	3c ff		 cmp	 al, -1
  000d7	75 e7		 jne	 SHORT $LL20@GetToken
$LN19@GetToken:

; 49   : 		if (ch!='#')

  000d9	3c 23		 cmp	 al, 35			; 00000023H
  000db	74 13		 je	 SHORT $LN18@GetToken

; 50   : 			ungetc(ch,SMDFile);

  000dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  000e3	0f be d0	 movsx	 edx, al
  000e6	51		 push	 ecx
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 _ungetc
  000ed	83 c4 08	 add	 esp, 8
$LN18@GetToken:

; 51   : 		*p = 0;

  000f0	c6 06 00	 mov	 BYTE PTR [esi], 0
  000f3	5e		 pop	 esi

; 52   : 		return CurrentToken = COMMAND;

  000f4	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  000fe	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  00103	5b		 pop	 ebx

; 92   : 	}
; 93   : }

  00104	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00107	33 cd		 xor	 ecx, ebp
  00109	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
$LN17@GetToken:

; 53   : 	case ';':
; 54   : 		return CurrentToken = SEMICOLON;

  00112	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  00117	e9 92 01 00 00	 jmp	 $LN47@GetToken
$LN16@GetToken:

; 55   : 	case ',':
; 56   : 		return CurrentToken = COMMA;

  0011c	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  00121	e9 88 01 00 00	 jmp	 $LN47@GetToken
$LN15@GetToken:

; 57   : 	case '{':
; 58   : 		return CurrentToken = LP;

  00126	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  0012b	e9 7e 01 00 00	 jmp	 $LN47@GetToken
$LN14@GetToken:

; 59   : 	case '}':
; 60   : 		return CurrentToken = RP;

  00130	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  00135	e9 74 01 00 00	 jmp	 $LN47@GetToken
$LN13@GetToken:

; 61   : 	case '0':	case '1':	case '2':	case '3':	case '4':
; 62   : 	case '5':	case '6':	case '7':	case '8':	case '9':
; 63   : 	case '.':	case '-':
; 64   : 		ungetc(ch,SMDFile);

  0013a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00140	51		 push	 ecx
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 _ungetc

; 65   : 		p = TempString;
; 66   : 		while ( (  (ch = getc(SMDFile) ) !=EOF) && (ch=='.' || isdigit(ch) || ch=='-') )

  00147	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0014d	52		 push	 edx
  0014e	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  00151	e8 00 00 00 00	 call	 _getc
  00156	8a d8		 mov	 bl, al
  00158	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015b	80 fb ff	 cmp	 bl, -1
  0015e	74 33		 je	 SHORT $LN11@GetToken
$LL12@GetToken:
  00160	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00163	74 15		 je	 SHORT $LN10@GetToken
  00165	0f be c3	 movsx	 eax, bl
  00168	50		 push	 eax
  00169	e8 00 00 00 00	 call	 _isdigit
  0016e	83 c4 04	 add	 esp, 4
  00171	85 c0		 test	 eax, eax
  00173	75 05		 jne	 SHORT $LN10@GetToken
  00175	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  00178	75 19		 jne	 SHORT $LN11@GetToken
$LN10@GetToken:
  0017a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile

; 67   : 			*p++ = ch;

  00180	88 1e		 mov	 BYTE PTR [esi], bl
  00182	51		 push	 ecx
  00183	46		 inc	 esi
  00184	e8 00 00 00 00	 call	 _getc
  00189	8a d8		 mov	 bl, al
  0018b	83 c4 04	 add	 esp, 4
  0018e	80 fb ff	 cmp	 bl, -1
  00191	75 cd		 jne	 SHORT $LL12@GetToken
$LN11@GetToken:

; 68   : 		*p = 0;
; 69   : 		TokenNumber = (float)atof(TempString);

  00193	8d 55 98	 lea	 edx, DWORD PTR _TempString$[ebp]
  00196	52		 push	 edx
  00197	c6 06 00	 mov	 BYTE PTR [esi], 0
  0019a	e8 00 00 00 00	 call	 _atof
  0019f	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  001a5	83 c4 04	 add	 esp, 4
  001a8	5e		 pop	 esi

; 70   : 		//			sscanf(TempString," %f ",&TokenNumber);
; 71   : 		return CurrentToken = NUMBER;

  001a9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  001b3	b8 01 00 00 00	 mov	 eax, 1
  001b8	5b		 pop	 ebx

; 92   : 	}
; 93   : }

  001b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bc	33 cd		 xor	 ecx, ebp
  001be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c3	8b e5		 mov	 esp, ebp
  001c5	5d		 pop	 ebp
  001c6	c3		 ret	 0
$LN9@GetToken:

; 72   : 	case '"':
; 73   : 		p = TokenString;
; 74   : 		while ( (  (ch = getc(SMDFile) ) !=EOF) && (ch!='"'))// || isalnum(ch)) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  001d2	e8 00 00 00 00	 call	 _getc
  001d7	83 c4 04	 add	 esp, 4
  001da	3c ff		 cmp	 al, -1
  001dc	74 20		 je	 SHORT $LN7@GetToken
  001de	8b ff		 npad	 2
$LL8@GetToken:
  001e0	3c 22		 cmp	 al, 34			; 00000022H
  001e2	0f 84 a2 00 00
	00		 je	 $LN6@GetToken
  001e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile

; 75   : 			*p++ = ch;

  001ee	88 06		 mov	 BYTE PTR [esi], al
  001f0	51		 push	 ecx
  001f1	46		 inc	 esi
  001f2	e8 00 00 00 00	 call	 _getc
  001f7	83 c4 04	 add	 esp, 4
  001fa	3c ff		 cmp	 al, -1
  001fc	75 e2		 jne	 SHORT $LL8@GetToken
$LN7@GetToken:

; 76   : 		if (ch!='"')

  001fe	3c 22		 cmp	 al, 34			; 00000022H
  00200	0f 84 84 00 00
	00		 je	 $LN6@GetToken

; 77   : 			ungetc(ch,SMDFile);

  00206	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0020c	0f be c0	 movsx	 eax, al
  0020f	52		 push	 edx
  00210	50		 push	 eax

; 78   : 		*p = 0;
; 79   : 		return CurrentToken = NAME;

  00211	eb 6f		 jmp	 SHORT $LN48@GetToken
$LN5@GetToken:

; 80   : 	default:
; 81   : 		if (isalpha(ch))	

  00213	50		 push	 eax
  00214	e8 00 00 00 00	 call	 _isalpha
  00219	83 c4 04	 add	 esp, 4
  0021c	85 c0		 test	 eax, eax
  0021e	0f 84 85 00 00
	00		 je	 $LN4@GetToken

; 82   : 		{
; 83   : 			p = TokenString;
; 84   : 			*p++ = ch;
; 85   : 			while ( (  (ch = getc(SMDFile) ) !=EOF) && (ch=='.' || ch=='_' || isalnum(ch)) )

  00224	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  0022a	51		 push	 ecx
  0022b	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  00231	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  00236	e8 00 00 00 00	 call	 _getc
  0023b	8a d8		 mov	 bl, al
  0023d	83 c4 04	 add	 esp, 4
  00240	80 fb ff	 cmp	 bl, -1
  00243	74 32		 je	 SHORT $LN2@GetToken
$LL3@GetToken:
  00245	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00248	74 15		 je	 SHORT $LN1@GetToken
  0024a	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  0024d	74 10		 je	 SHORT $LN1@GetToken
  0024f	0f be d3	 movsx	 edx, bl
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 _isalnum
  00258	83 c4 04	 add	 esp, 4
  0025b	85 c0		 test	 eax, eax
  0025d	74 18		 je	 SHORT $LN2@GetToken
$LN1@GetToken:
  0025f	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile

; 86   : 				*p++ = ch;

  00264	88 1e		 mov	 BYTE PTR [esi], bl
  00266	50		 push	 eax
  00267	46		 inc	 esi
  00268	e8 00 00 00 00	 call	 _getc
  0026d	8a d8		 mov	 bl, al
  0026f	83 c4 04	 add	 esp, 4
  00272	80 fb ff	 cmp	 bl, -1
  00275	75 ce		 jne	 SHORT $LL3@GetToken
$LN2@GetToken:

; 87   : 			ungetc(ch,SMDFile);

  00277	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  0027d	0f be d3	 movsx	 edx, bl
  00280	51		 push	 ecx
  00281	52		 push	 edx
$LN48@GetToken:
  00282	e8 00 00 00 00	 call	 _ungetc
  00287	83 c4 08	 add	 esp, 8
$LN6@GetToken:

; 88   : 			*p = 0;

  0028a	c6 06 00	 mov	 BYTE PTR [esi], 0
  0028d	5e		 pop	 esi

; 89   : 			return CurrentToken = NAME;

  0028e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  00298	33 c0		 xor	 eax, eax
  0029a	5b		 pop	 ebx

; 92   : 	}
; 93   : }

  0029b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029e	33 cd		 xor	 ecx, ebp
  002a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a5	8b e5		 mov	 esp, ebp
  002a7	5d		 pop	 ebp
  002a8	c3		 ret	 0
$LN4@GetToken:

; 90   : 		}
; 91   : 		return CurrentToken = SMD_ERROR;

  002a9	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN47@GetToken:

; 92   : 	}
; 93   : }

  002ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b1	5e		 pop	 esi
  002b2	33 cd		 xor	 ecx, ebp
  002b4	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  002b9	5b		 pop	 ebx
  002ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bf	8b e5		 mov	 esp, ebp
  002c1	5d		 pop	 ebp
  002c2	c3		 ret	 0
  002c3	90		 npad	 1
$LN49@GetToken:
  002c4	00 00 00 00	 DD	 $LN9@GetToken
  002c8	00 00 00 00	 DD	 $LN21@GetToken
  002cc	00 00 00 00	 DD	 $LN16@GetToken
  002d0	00 00 00 00	 DD	 $LN13@GetToken
  002d4	00 00 00 00	 DD	 $LN17@GetToken
  002d8	00 00 00 00	 DD	 $LN15@GetToken
  002dc	00 00 00 00	 DD	 $LN14@GetToken
  002e0	00 00 00 00	 DD	 $LN5@GetToken
$LN45@GetToken:
  002e4	00		 DB	 0
  002e5	01		 DB	 1
  002e6	07		 DB	 7
  002e7	07		 DB	 7
  002e8	07		 DB	 7
  002e9	07		 DB	 7
  002ea	07		 DB	 7
  002eb	07		 DB	 7
  002ec	07		 DB	 7
  002ed	07		 DB	 7
  002ee	02		 DB	 2
  002ef	03		 DB	 3
  002f0	03		 DB	 3
  002f1	07		 DB	 7
  002f2	03		 DB	 3
  002f3	03		 DB	 3
  002f4	03		 DB	 3
  002f5	03		 DB	 3
  002f6	03		 DB	 3
  002f7	03		 DB	 3
  002f8	03		 DB	 3
  002f9	03		 DB	 3
  002fa	03		 DB	 3
  002fb	03		 DB	 3
  002fc	07		 DB	 7
  002fd	04		 DB	 4
  002fe	07		 DB	 7
  002ff	07		 DB	 7
  00300	07		 DB	 7
  00301	07		 DB	 7
  00302	07		 DB	 7
  00303	07		 DB	 7
  00304	07		 DB	 7
  00305	07		 DB	 7
  00306	07		 DB	 7
  00307	07		 DB	 7
  00308	07		 DB	 7
  00309	07		 DB	 7
  0030a	07		 DB	 7
  0030b	07		 DB	 7
  0030c	07		 DB	 7
  0030d	07		 DB	 7
  0030e	07		 DB	 7
  0030f	07		 DB	 7
  00310	07		 DB	 7
  00311	07		 DB	 7
  00312	07		 DB	 7
  00313	07		 DB	 7
  00314	07		 DB	 7
  00315	07		 DB	 7
  00316	07		 DB	 7
  00317	07		 DB	 7
  00318	07		 DB	 7
  00319	07		 DB	 7
  0031a	07		 DB	 7
  0031b	07		 DB	 7
  0031c	07		 DB	 7
  0031d	07		 DB	 7
  0031e	07		 DB	 7
  0031f	07		 DB	 7
  00320	07		 DB	 7
  00321	07		 DB	 7
  00322	07		 DB	 7
  00323	07		 DB	 7
  00324	07		 DB	 7
  00325	07		 DB	 7
  00326	07		 DB	 7
  00327	07		 DB	 7
  00328	07		 DB	 7
  00329	07		 DB	 7
  0032a	07		 DB	 7
  0032b	07		 DB	 7
  0032c	07		 DB	 7
  0032d	07		 DB	 7
  0032e	07		 DB	 7
  0032f	07		 DB	 7
  00330	07		 DB	 7
  00331	07		 DB	 7
  00332	07		 DB	 7
  00333	07		 DB	 7
  00334	07		 DB	 7
  00335	07		 DB	 7
  00336	07		 DB	 7
  00337	07		 DB	 7
  00338	07		 DB	 7
  00339	07		 DB	 7
  0033a	07		 DB	 7
  0033b	07		 DB	 7
  0033c	07		 DB	 7
  0033d	05		 DB	 5
  0033e	07		 DB	 7
  0033f	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??_C@_0BH@NMPHHNEB@?$FLVIP?5FILE?$FN?5Carregado?5?$CB?$AA@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0BO@IFKAPNGP@?4?2Customs?2Systems?2Hgt_Vip?4ini?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?Load@CVip@@QAEXXZ				; CVip::Load
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
EXTRN	__imp__ExitProcess@4:PROC
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0BH@NMPHHNEB@?$FLVIP?5FILE?$FN?5Carregado?5?$CB?$AA@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\vip.cpp
CONST	SEGMENT
??_C@_0BH@NMPHHNEB@?$FLVIP?5FILE?$FN?5Carregado?5?$CB?$AA@ DB '[VIP FILE]'
	DB	' Carregado !', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IFKAPNGP@?4?2Customs?2Systems?2Hgt_Vip?4ini?$AA@
CONST	SEGMENT
??_C@_0BO@IFKAPNGP@?4?2Customs?2Systems?2Hgt_Vip?4ini?$AA@ DB '.\Customs\'
	DB	'Systems\Hgt_Vip.ini', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Load@CVip@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Load@CVip@@QAEXXZ PROC					; CVip::Load, COMDAT
; _this$ = ecx

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 9    : 	SMDToken Token;
; 10   : 	SMDFile = fopen(VIP_FILE, "r");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IFKAPNGP@?4?2Customs?2Systems?2Hgt_Vip?4ini?$AA@
  0000e	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00011	e8 00 00 00 00	 call	 _fopen
  00016	83 c4 08	 add	 esp, 8
  00019	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 11   : 	// --- 
; 12   : 	if(!SMDFile)

  0001e	85 c0		 test	 eax, eax
  00020	75 07		 jne	 SHORT $LN10@Load

; 13   : 	{
; 14   : 		//MsgBox("Arquivo '%s' Não Encontrado !", VIP_FILE);
; 15   : 		ExitProcess(0);

  00022	50		 push	 eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExitProcess@4
$LN25@Load:
$LN10@Load:

; 16   : 	}
; 17   : 	// ---
; 18   : 	int VipIndex;
; 19   : 	// ---
; 20   : 	char szTemp[100];
; 21   : 	// ---
; 22   : 	memset(szTemp, 0, sizeof(szTemp));
; 23   : 	// ---
; 24   : 	while (true)
; 25   : 	{
; 26   : 		Token = GetToken();

  00029	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 27   : 		// ---
; 28   : 		if (Token == END)

  0002e	83 f8 02	 cmp	 eax, 2
  00031	0f 84 c6 00 00
	00		 je	 $LN17@Load
  00037	53		 push	 ebx
  00038	56		 push	 esi
  00039	57		 push	 edi
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL9@Load:

; 29   : 		{
; 30   : 			break;
; 31   : 		}
; 32   : 		// ---
; 33   : 		if (Token == NUMBER)

  00040	83 f8 01	 cmp	 eax, 1
  00043	0f 85 a3 00 00
	00		 jne	 $LN23@Load

; 34   : 		{
; 35   : 			int Section = TokenNumber;
; 36   : 			// ---
; 37   : 			if (Section == 0)

  00049	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0004f	e8 00 00 00 00	 call	 __ftol2_sse
  00054	85 c0		 test	 eax, eax
  00056	0f 85 90 00 00
	00		 jne	 $LN23@Load
  0005c	8d 64 24 00	 npad	 4
$LL4@Load:

; 38   : 			{
; 39   : 				while (true)
; 40   : 				{
; 41   : 					Token = GetToken();

  00060	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 42   : 					// ---
; 43   : 					if (Token == NAME)

  00065	85 c0		 test	 eax, eax
  00067	75 33		 jne	 SHORT $LN1@Load

; 44   : 					{
; 45   : 						if (strcmp("end", TokenString) == 0)

  00069	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  0006e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL18@Load:
  00073	8a 10		 mov	 dl, BYTE PTR [eax]
  00075	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00077	75 1a		 jne	 SHORT $LN19@Load
  00079	84 d2		 test	 dl, dl
  0007b	74 12		 je	 SHORT $LN22@Load
  0007d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00080	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00083	75 0e		 jne	 SHORT $LN19@Load
  00085	83 c0 02	 add	 eax, 2
  00088	83 c1 02	 add	 ecx, 2
  0008b	84 d2		 test	 dl, dl
  0008d	75 e4		 jne	 SHORT $LL18@Load
$LN22@Load:
  0008f	33 c0		 xor	 eax, eax
  00091	eb 05		 jmp	 SHORT $LN21@Load
$LN19@Load:
  00093	1b c0		 sbb	 eax, eax
  00095	83 d8 ff	 sbb	 eax, -1
$LN21@Load:
  00098	85 c0		 test	 eax, eax
  0009a	74 50		 je	 SHORT $LN23@Load
$LN1@Load:

; 46   : 						{
; 47   : 							break;
; 48   : 						}
; 49   : 					}
; 50   : 					// ---
; 51   : 					VipIndex = TokenNumber;

  0009c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000a2	e8 00 00 00 00	 call	 __ftol2_sse
  000a7	8b f0		 mov	 esi, eax

; 52   : 					// ---
; 53   : 					Token = GetToken();

  000a9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 54   : 					memcpy(this->m_Data[VipIndex].iVipName, TokenString, sizeof(this->m_Data[VipIndex].iVipName));

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	8b c6		 mov	 eax, esi
  000b3	c1 e0 04	 shl	 eax, 4
  000b6	2b c6		 sub	 eax, esi
  000b8	8d 1c 81	 lea	 ebx, DWORD PTR [ecx+eax*4]
  000bb	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000c0	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  000c5	8b fb		 mov	 edi, ebx
  000c7	f3 a5		 rep movsd
  000c9	66 a5		 movsw

; 55   : 					// ---
; 56   : 					Token = GetToken();

  000cb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 57   : 					this->m_Data[VipIndex].iExperience = TokenNumber;

  000d0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000d6	d9 5b 34	 fstp	 DWORD PTR [ebx+52]

; 58   : 					// ---
; 59   : 					Token = GetToken();

  000d9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 60   : 					this->m_Data[VipIndex].iItemDrop = TokenNumber;

  000de	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000e4	d9 5b 38	 fstp	 DWORD PTR [ebx+56]

; 61   : 				}

  000e7	e9 74 ff ff ff	 jmp	 $LL4@Load
$LN23@Load:

; 16   : 	}
; 17   : 	// ---
; 18   : 	int VipIndex;
; 19   : 	// ---
; 20   : 	char szTemp[100];
; 21   : 	// ---
; 22   : 	memset(szTemp, 0, sizeof(szTemp));
; 23   : 	// ---
; 24   : 	while (true)
; 25   : 	{
; 26   : 		Token = GetToken();

  000ec	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 27   : 		// ---
; 28   : 		if (Token == END)

  000f1	83 f8 02	 cmp	 eax, 2
  000f4	0f 85 46 ff ff
	ff		 jne	 $LL9@Load
  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
$LN17@Load:

; 62   : 			}
; 63   : 		}
; 64   : 	}
; 65   : 	// ---
; 66   : 	LogAdd(LOG_GOLD, "[VIP FILE] Carregado !");

  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NMPHHNEB@?$FLVIP?5FILE?$FN?5Carregado?5?$CB?$AA@
  00102	6a 05		 push	 5
  00104	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00109	83 c4 08	 add	 esp, 8

; 67   : }

  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c3		 ret	 0
$LN24@Load:
?Load@CVip@@QAEXXZ ENDP					; CVip::Load
_TEXT	ENDS
PUBLIC	??_C@_04KHKKIIL@Null?$AA@			; `string'
PUBLIC	?GetName@CVip@@QAEPADH@Z			; CVip::GetName
;	COMDAT ??_C@_04KHKKIIL@Null?$AA@
CONST	SEGMENT
??_C@_04KHKKIIL@Null?$AA@ DB 'Null', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GetName@CVip@@QAEPADH@Z
_TEXT	SEGMENT
_VipNumber$ = 8						; size = 4
?GetName@CVip@@QAEPADH@Z PROC				; CVip::GetName, COMDAT
; _this$ = ecx

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 71   : 	if(this->m_Data[VipNumber].iVipName != NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _VipNumber$[ebp]
  00006	8b d0		 mov	 edx, eax
  00008	c1 e2 04	 shl	 edx, 4
  0000b	2b d0		 sub	 edx, eax
  0000d	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00010	85 c0		 test	 eax, eax

; 72   : 	{
; 73   : 		return m_Data[VipNumber].iVipName;

  00012	75 05		 jne	 SHORT $LN2@GetName

; 74   : 	}
; 75   : 	// ---
; 76   : 	return "Null";

  00014	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04KHKKIIL@Null?$AA@
$LN2@GetName:

; 77   : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?GetName@CVip@@QAEPADH@Z ENDP				; CVip::GetName
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	__real@bf800000
PUBLIC	?GetDropRate@CVip@@QAEMH@Z			; CVip::GetDropRate
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GetDropRate@CVip@@QAEMH@Z
_TEXT	SEGMENT
_VipNumber$ = 8						; size = 4
?GetDropRate@CVip@@QAEMH@Z PROC				; CVip::GetDropRate, COMDAT
; _this$ = ecx

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 81   : 	if(this->m_Data[VipNumber].iItemDrop != -1)

  00003	8b 45 08	 mov	 eax, DWORD PTR _VipNumber$[ebp]
  00006	8b d0		 mov	 edx, eax
  00008	c1 e2 04	 shl	 edx, 4
  0000b	2b d0		 sub	 edx, eax
  0000d	d9 44 91 38	 fld	 DWORD PTR [ecx+edx*4+56]
  00011	8d 4c 91 38	 lea	 ecx, DWORD PTR [ecx+edx*4+56]
  00015	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@bf800000
  0001b	da e9		 fucompp
  0001d	df e0		 fnstsw	 ax
  0001f	f6 c4 44	 test	 ah, 68			; 00000044H
  00022	7b 06		 jnp	 SHORT $LN1@GetDropRat

; 82   : 	{
; 83   : 		return m_Data[VipNumber].iItemDrop;

  00024	d9 01		 fld	 DWORD PTR [ecx]

; 87   : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN1@GetDropRat:

; 84   : 	}
; 85   : 	// ---
; 86   : 	return 0.0f;

  0002a	d9 ee		 fldz

; 87   : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?GetDropRate@CVip@@QAEMH@Z ENDP				; CVip::GetDropRate
_TEXT	ENDS
PUBLIC	?GetExperience@CVip@@QAEMH@Z			; CVip::GetExperience
; Function compile flags: /Ogtp
;	COMDAT ?GetExperience@CVip@@QAEMH@Z
_TEXT	SEGMENT
_VipNumber$ = 8						; size = 4
?GetExperience@CVip@@QAEMH@Z PROC			; CVip::GetExperience, COMDAT
; _this$ = ecx

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   : 	if(this->m_Data[VipNumber].iExperience != -1)

  00003	8b 45 08	 mov	 eax, DWORD PTR _VipNumber$[ebp]
  00006	8b d0		 mov	 edx, eax
  00008	c1 e2 04	 shl	 edx, 4
  0000b	2b d0		 sub	 edx, eax
  0000d	d9 44 91 34	 fld	 DWORD PTR [ecx+edx*4+52]
  00011	8d 4c 91 34	 lea	 ecx, DWORD PTR [ecx+edx*4+52]
  00015	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@bf800000
  0001b	da e9		 fucompp
  0001d	df e0		 fnstsw	 ax
  0001f	f6 c4 44	 test	 ah, 68			; 00000044H
  00022	7b 06		 jnp	 SHORT $LN1@GetExperie

; 92   : 	{
; 93   : 		return m_Data[VipNumber].iExperience;

  00024	d9 01		 fld	 DWORD PTR [ecx]

; 97   : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN1@GetExperie:

; 94   : 	}
; 95   : 	// ---
; 96   : 	return 0.0f;

  0002a	d9 ee		 fldz

; 97   : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?GetExperience@CVip@@QAEMH@Z ENDP			; CVip::GetExperience
_TEXT	ENDS
END
