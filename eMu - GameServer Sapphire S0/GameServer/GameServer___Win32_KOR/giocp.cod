; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\giocp.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?SOCKET_FLAG@@3W4<unnamed-type-SOCKET_FLAG>@@A	; SOCKET_FLAG
PUBLIC	?g_CompletionPort@@3PAXA			; g_CompletionPort
PUBLIC	?g_dwThreadCount@@3KA				; g_dwThreadCount
PUBLIC	?criti@@3U_RTL_CRITICAL_SECTION@@A		; criti
PUBLIC	?g_ThreadHandles@@3PAPAXA			; g_ThreadHandles
PUBLIC	?g_ServerPort@@3HA				; g_ServerPort
PUBLIC	?g_IocpThreadHandle@@3PAXA			; g_IocpThreadHandle
PUBLIC	?ExSendBuf@@3PAEA				; ExSendBuf
PUBLIC	?g_Listen@@3IA					; g_Listen
_BSS	SEGMENT
?SOCKET_FLAG@@3W4<unnamed-type-SOCKET_FLAG>@@A DD 01H DUP (?) ; SOCKET_FLAG
?g_CompletionPort@@3PAXA DD 01H DUP (?)			; g_CompletionPort
?g_dwThreadCount@@3KA DD 01H DUP (?)			; g_dwThreadCount
?criti@@3U_RTL_CRITICAL_SECTION@@A DB 018H DUP (?)	; criti
?g_ThreadHandles@@3PAPAXA DD 010H DUP (?)		; g_ThreadHandles
?g_ServerPort@@3HA DD 01H DUP (?)			; g_ServerPort
?g_IocpThreadHandle@@3PAXA DD 01H DUP (?)		; g_IocpThreadHandle
?ExSendBuf@@3PAEA DD 01H DUP (?)			; ExSendBuf
_BSS	ENDS
_DATA	SEGMENT
?g_Listen@@3IA DD 0ffffffffH				; g_Listen
_DATA	ENDS
PUBLIC	??_7CStreamPacketEngine_Server@@6B@		; CStreamPacketEngine_Server::`vftable'
PUBLIC	??1CStreamPacketEngine_Server@@UAE@XZ		; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
PUBLIC	??_R4CStreamPacketEngine_Server@@6B@		; CStreamPacketEngine_Server::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCStreamPacketEngine_Server@@@8		; CStreamPacketEngine_Server `RTTI Type Descriptor'
PUBLIC	??_R3CStreamPacketEngine_Server@@8		; CStreamPacketEngine_Server::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CStreamPacketEngine_Server@@8		; CStreamPacketEngine_Server::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CStreamPacketEngine_Server@@8	; CStreamPacketEngine_Server::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECStreamPacketEngine_Server@@UAEPAXI@Z:PROC	; CStreamPacketEngine_Server::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CStreamPacketEngine_Server@@8
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\spe.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CStreamPacketEngine_Server@@8 DD FLAT:??_R0?AVCStreamPacketEngine_Server@@@8 ; CStreamPacketEngine_Server::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CStreamPacketEngine_Server@@8
rdata$r	ENDS
;	COMDAT ??_R2CStreamPacketEngine_Server@@8
rdata$r	SEGMENT
??_R2CStreamPacketEngine_Server@@8 DD FLAT:??_R1A@?0A@EA@CStreamPacketEngine_Server@@8 ; CStreamPacketEngine_Server::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CStreamPacketEngine_Server@@8
rdata$r	SEGMENT
??_R3CStreamPacketEngine_Server@@8 DD 00H		; CStreamPacketEngine_Server::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CStreamPacketEngine_Server@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCStreamPacketEngine_Server@@@8
_DATA	SEGMENT
??_R0?AVCStreamPacketEngine_Server@@@8 DD FLAT:??_7type_info@@6B@ ; CStreamPacketEngine_Server `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCStreamPacketEngine_Server@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CStreamPacketEngine_Server@@6B@
rdata$r	SEGMENT
??_R4CStreamPacketEngine_Server@@6B@ DD 00H		; CStreamPacketEngine_Server::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCStreamPacketEngine_Server@@@8
	DD	FLAT:??_R3CStreamPacketEngine_Server@@8
rdata$r	ENDS
;	COMDAT ??_7CStreamPacketEngine_Server@@6B@
CONST	SEGMENT
??_7CStreamPacketEngine_Server@@6B@ DD FLAT:??_R4CStreamPacketEngine_Server@@6B@ ; CStreamPacketEngine_Server::`vftable'
	DD	FLAT:??_ECStreamPacketEngine_Server@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1CStreamPacketEngine_Server@@UAE@XZ
_TEXT	SEGMENT
??1CStreamPacketEngine_Server@@UAE@XZ PROC		; CStreamPacketEngine_Server::~CStreamPacketEngine_Server, COMDAT
; _this$ = ecx

; 25   : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 26   : 		return;
; 27   : 	};

  00006	c3		 ret	 0
??1CStreamPacketEngine_Server@@UAE@XZ ENDP		; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
_TEXT	ENDS
PUBLIC	?Clear@CStreamPacketEngine_Server@@QAEXXZ	; CStreamPacketEngine_Server::Clear
; Function compile flags: /Ogtp
;	COMDAT ?Clear@CStreamPacketEngine_Server@@QAEXXZ
_TEXT	SEGMENT
?Clear@CStreamPacketEngine_Server@@QAEXXZ PROC		; CStreamPacketEngine_Server::Clear, COMDAT
; _this$ = ecx

; 31   : 		this->m_wSize = 0;

  00000	33 c0		 xor	 eax, eax
  00002	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 32   : 	};

  00006	c3		 ret	 0
?Clear@CStreamPacketEngine_Server@@QAEXXZ ENDP		; CStreamPacketEngine_Server::Clear
_TEXT	ENDS
PUBLIC	??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Erro@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z	; CStreamPacketEngine_Server::XorData
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Erro@
CONST	SEGMENT
??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Erro@ DB 'CStreamPacketE'
	DB	'ngine XorData Error %d,%d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z
_TEXT	SEGMENT
_byXorFilter$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_iStart$ = 8						; size = 4
_iEnd$ = 12						; size = 4
_iDir$ = 16						; size = 4
?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z PROC	; CStreamPacketEngine_Server::XorData, COMDAT
; _this$ = ecx

; 37   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 38   : 		if ( iStart < iEnd  )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iStart$[ebp]
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _iEnd$[ebp]
  00017	8b d1		 mov	 edx, ecx
  00019	3b c6		 cmp	 eax, esi
  0001b	7d 22		 jge	 SHORT $LN4@XorData

; 39   : 		{
; 40   : 			LogAdd(LOG_RED,  "CStreamPacketEngine XorData Error %d,%d", iStart, iEnd);

  0001d	56		 push	 esi
  0001e	50		 push	 eax
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Erro@
  00024	6a 01		 push	 1
  00026	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0002b	83 c4 10	 add	 esp, 16			; 00000010H
  0002e	5e		 pop	 esi

; 82   : 		}
; 83   : 	}

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00032	33 cd		 xor	 ecx, ebp
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@XorData:

; 41   : 			return;
; 42   : 		}
; 43   : 
; 44   : 		unsigned char byXorFilter[32];
; 45   : 				
; 46   : 		byXorFilter[0] = 0xE7;

  0003f	c7 45 dc e7 6d
	3a 89		 mov	 DWORD PTR _byXorFilter$[ebp], -1992659481 ; 893a6de7H

; 47   : 		byXorFilter[1] = 0x6D;
; 48   : 		byXorFilter[2] = 0x3A;
; 49   : 		byXorFilter[3] = 0x89;
; 50   : 		byXorFilter[4] = 0xBC;

  00046	c7 45 e0 bc b2
	9f 73		 mov	 DWORD PTR _byXorFilter$[ebp+4], 1939845820 ; 739fb2bcH

; 51   : 		byXorFilter[5] = 0xB2;
; 52   : 		byXorFilter[6] = 0x9F;
; 53   : 		byXorFilter[7] = 0x73;
; 54   : 		byXorFilter[8] = 0x23;

  0004d	c7 45 e4 23 a8
	fe b6		 mov	 DWORD PTR _byXorFilter$[ebp+8], -1224824797 ; b6fea823H

; 55   : 		byXorFilter[9] = 0xA8;
; 56   : 		byXorFilter[10] = 0xFE;
; 57   : 		byXorFilter[11] = 0xB6;
; 58   : 		byXorFilter[12] = 0x49;

  00054	c7 45 e8 49 5d
	39 5d		 mov	 DWORD PTR _byXorFilter$[ebp+12], 1564040521 ; 5d395d49H

; 59   : 		byXorFilter[13] = 0x5D;
; 60   : 		byXorFilter[14] = 0x39;
; 61   : 		byXorFilter[15] = 0x5D;
; 62   : 		byXorFilter[16] = 0x8A;

  0005b	c7 45 ec 8a cb
	63 8d		 mov	 DWORD PTR _byXorFilter$[ebp+16], -1922839670 ; 8d63cb8aH

; 63   : 		byXorFilter[17] = 0xCB;
; 64   : 		byXorFilter[18] = 0x63;
; 65   : 		byXorFilter[19] = 0x8D;
; 66   : 		byXorFilter[20] = 0xEA;

  00062	c7 45 f0 ea 7d
	2b 5f		 mov	 DWORD PTR _byXorFilter$[ebp+20], 1596685802 ; 5f2b7deaH

; 67   : 		byXorFilter[21] = 0x7D;
; 68   : 		byXorFilter[22] = 0x2B;
; 69   : 		byXorFilter[23] = 0x5F;
; 70   : 		byXorFilter[24] = 0xC3;

  00069	c7 45 f4 c3 b1
	e9 83		 mov	 DWORD PTR _byXorFilter$[ebp+24], -2081836605 ; 83e9b1c3H

; 71   : 		byXorFilter[25] = 0xB1;
; 72   : 		byXorFilter[26] = 0xE9;
; 73   : 		byXorFilter[27] = 0x83;
; 74   : 		byXorFilter[28] = 0x29;

  00070	c7 45 f8 29 51
	e8 56		 mov	 DWORD PTR _byXorFilter$[ebp+28], 1458065705 ; 56e85129H

; 75   : 		byXorFilter[29] = 0x51;
; 76   : 		byXorFilter[30] = 0xE8;
; 77   : 		byXorFilter[31] = 0x56;
; 78   : 
; 79   : 		for ( int i = iStart ; i != iEnd ; i+=iDir )

  00077	3b c6		 cmp	 eax, esi
  00079	74 38		 je	 SHORT $LN1@XorData
  0007b	b9 fa ff ff ff	 mov	 ecx, -6			; fffffffaH
  00080	57		 push	 edi
  00081	8b 7d 10	 mov	 edi, DWORD PTR _iDir$[ebp]
  00084	8d 44 02 06	 lea	 eax, DWORD PTR [edx+eax+6]
  00088	2b ca		 sub	 ecx, edx
  0008a	8d 9b 00 00 00
	00		 npad	 6
$LL3@XorData:

; 80   : 		{
; 81   : 			this->m_byBuffer[i] ^= this->m_byBuffer[i-1] ^ byXorFilter[ i%32 ];

  00090	8d 14 01	 lea	 edx, DWORD PTR [ecx+eax]
  00093	81 e2 1f 00 00
	80		 and	 edx, -2147483617	; 8000001fH
  00099	79 05		 jns	 SHORT $LN9@XorData
  0009b	4a		 dec	 edx
  0009c	83 ca e0	 or	 edx, -32		; ffffffe0H
  0009f	42		 inc	 edx
$LN9@XorData:
  000a0	8a 54 15 dc	 mov	 dl, BYTE PTR _byXorFilter$[ebp+edx]
  000a4	32 50 ff	 xor	 dl, BYTE PTR [eax-1]
  000a7	30 10		 xor	 BYTE PTR [eax], dl
  000a9	03 c7		 add	 eax, edi
  000ab	8d 14 01	 lea	 edx, DWORD PTR [ecx+eax]
  000ae	3b d6		 cmp	 edx, esi
  000b0	75 de		 jne	 SHORT $LL3@XorData
  000b2	5f		 pop	 edi
$LN1@XorData:

; 82   : 		}
; 83   : 	}

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b6	33 cd		 xor	 ecx, ebp
  000b8	5e		 pop	 esi
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 0c 00	 ret	 12			; 0000000cH
?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z ENDP	; CStreamPacketEngine_Server::XorData
_TEXT	ENDS
PUBLIC	??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@ ; `string'
PUBLIC	?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z	; CStreamPacketEngine_Server::AddData
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
CONST	SEGMENT
??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@ DB 'CStreamPacketEn'
	DB	'gine Adding Buffer Size Error %d', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_wSize$ = 12						; size = 2
?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z PROC	; CStreamPacketEngine_Server::AddData, COMDAT
; _this$ = ecx

; 88   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 89   : 		if ( ((this->m_wSize + wSize) >=  2048) ||  (wSize == 0) )

  00005	66 8b 7d 0c	 mov	 di, WORD PTR _wSize$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	0f b7 46 04	 movzx	 eax, WORD PTR [esi+4]
  0000f	0f b7 cf	 movzx	 ecx, di
  00012	8d 14 01	 lea	 edx, DWORD PTR [ecx+eax]
  00015	81 fa 00 08 00
	00		 cmp	 edx, 2048		; 00000800H
  0001b	7d 26		 jge	 SHORT $LN1@AddData
  0001d	66 85 ff	 test	 di, di
  00020	74 21		 je	 SHORT $LN1@AddData

; 94   : 		}
; 95   : 
; 96   : 		memcpy((void*)&this->m_byBuffer[this->m_wSize], pSrc, wSize);

  00022	51		 push	 ecx
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  00026	51		 push	 ecx
  00027	8d 54 30 06	 lea	 edx, DWORD PTR [eax+esi+6]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 _memcpy
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 97   : 		this->m_wSize += wSize;

  00034	66 01 7e 04	 add	 WORD PTR [esi+4], di
  00038	5f		 pop	 edi

; 98   : 		return TRUE;

  00039	b8 01 00 00 00	 mov	 eax, 1
  0003e	5e		 pop	 esi

; 99   : 	}

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
$LN1@AddData:

; 90   : 		{
; 91   : 			LogAdd(LOG_RED, "CStreamPacketEngine Adding Buffer Size Error %d", this->m_wSize + wSize);

  00043	52		 push	 edx
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
  00049	6a 01		 push	 1
  0004b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	5f		 pop	 edi

; 92   : 			int iSize = 2048;
; 93   : 			return FALSE;

  00054	33 c0		 xor	 eax, eax
  00056	5e		 pop	 esi

; 99   : 	}

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z ENDP	; CStreamPacketEngine_Server::AddData
_TEXT	ENDS
PUBLIC	_pTar$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
; Function compile flags: /Ogtp
;	COMDAT ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z
_TEXT	SEGMENT
_wSize$ = -2060						; size = 2
tv293 = -2056						; size = 4
_pTar$GSCopy$ = -2056					; size = 4
_byTemp$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_pTar$ = 8						; size = 4
?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z PROC ; CStreamPacketEngine_Server::ExtractPacket, COMDAT
; _this$ = ecx

; 102  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 08 00
	00		 sub	 esp, 2060		; 0000080cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _pTar$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx

; 103  : 		WORD wSize;
; 104  : 		BYTE byXorFilter[32];
; 105  : 
; 106  : 		BYTE byTemp[2048];
; 107  : 
; 108  : 		
; 109  : 
; 110  : 		switch ( this->m_byBuffer[0] )

  0001a	8d 5e 06	 lea	 ebx, DWORD PTR [esi+6]

; 128  : 		}
; 129  : 
; 130  : 		byXorFilter[0] = 0xE7;
; 131  : 		byXorFilter[1] = 0x6D;
; 132  : 		byXorFilter[2] = 0x3A;
; 133  : 		byXorFilter[3] = 0x89;
; 134  : 		byXorFilter[4] = 0xBC;
; 135  : 		byXorFilter[5] = 0xB2;
; 136  : 		byXorFilter[6] = 0x9F;
; 137  : 		byXorFilter[7] = 0x73;
; 138  : 		byXorFilter[8] = 0x23;
; 139  : 		byXorFilter[9] = 0xA8;
; 140  : 		byXorFilter[10] = 0xFE;
; 141  : 		byXorFilter[11] = 0xB6;
; 142  : 		byXorFilter[12] = 0x49;
; 143  : 		byXorFilter[13] = 0x5D;
; 144  : 		byXorFilter[14] = 0x39;
; 145  : 		byXorFilter[15] = 0x5D;
; 146  : 		byXorFilter[16] = 0x8A;
; 147  : 		byXorFilter[17] = 0xCB;
; 148  : 		byXorFilter[18] = 0x63;
; 149  : 		byXorFilter[19] = 0x8D;
; 150  : 		byXorFilter[20] = 0xEA;
; 151  : 		byXorFilter[21] = 0x7D;
; 152  : 		byXorFilter[22] = 0x2B;
; 153  : 		byXorFilter[23] = 0x5F;
; 154  : 		byXorFilter[24] = 0xC3;
; 155  : 		byXorFilter[25] = 0xB1;
; 156  : 		byXorFilter[26] = 0xE9;
; 157  : 		byXorFilter[27] = 0x83;
; 158  : 		byXorFilter[28] = 0x29;
; 159  : 		byXorFilter[29] = 0x51;
; 160  : 		byXorFilter[30] = 0xE8;
; 161  : 		byXorFilter[31] = 0x56;
; 162  : 
; 163  : 		this->XorData(wSize-1, (this->m_byBuffer[0] == 0xC1 ? 2 : 3), -1);

  0001d	89 85 f8 f7 ff
	ff		 mov	 DWORD PTR _pTar$GSCopy$[ebp], eax
  00023	8a 03		 mov	 al, BYTE PTR [ebx]
  00025	0f b6 c8	 movzx	 ecx, al
  00028	81 e9 c1 00 00
	00		 sub	 ecx, 193		; 000000c1H
  0002e	74 39		 je	 SHORT $LN4@ExtractPac

; 103  : 		WORD wSize;
; 104  : 		BYTE byXorFilter[32];
; 105  : 
; 106  : 		BYTE byTemp[2048];
; 107  : 
; 108  : 		
; 109  : 
; 110  : 		switch ( this->m_byBuffer[0] )

  00030	49		 dec	 ecx
  00031	74 17		 je	 SHORT $LN3@ExtractPac

; 119  : 
; 120  : 			default:
; 121  : 				return true;

  00033	5e		 pop	 esi
  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	5b		 pop	 ebx

; 168  : 		return false;
; 169  : 	}

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003d	33 cd		 xor	 ecx, ebp
  0003f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN3@ExtractPac:

; 114  : 				break;
; 115  : 
; 116  : 			case 0xC2:
; 117  : 				wSize = this->m_byBuffer[1] * 256 + this->m_byBuffer[2];

  0004a	0f b6 4e 07	 movzx	 ecx, BYTE PTR [esi+7]
  0004e	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00053	66 0f af ca	 imul	 cx, dx
  00057	0f b6 56 08	 movzx	 edx, BYTE PTR [esi+8]
  0005b	66 03 ca	 add	 cx, dx
  0005e	0f b7 c9	 movzx	 ecx, cx
  00061	89 8d f4 f7 ff
	ff		 mov	 DWORD PTR _wSize$[ebp], ecx

; 118  : 				break;

  00067	eb 0c		 jmp	 SHORT $LN5@ExtractPac
$LN4@ExtractPac:

; 111  : 		{
; 112  : 			case 0xC1:
; 113  : 				wSize = this->m_byBuffer[1];

  00069	0f b6 56 07	 movzx	 edx, BYTE PTR [esi+7]
  0006d	89 95 f4 f7 ff
	ff		 mov	 DWORD PTR _wSize$[ebp], edx
  00073	8b ca		 mov	 ecx, edx
$LN5@ExtractPac:

; 122  : 				break;
; 123  : 		}
; 124  : 
; 125  : 		if ( this->m_wSize < wSize )

  00075	66 39 4e 04	 cmp	 WORD PTR [esi+4], cx
  00079	73 17		 jae	 SHORT $LN1@ExtractPac

; 126  : 		{
; 127  : 			return 2;

  0007b	5e		 pop	 esi
  0007c	b8 02 00 00 00	 mov	 eax, 2
  00081	5b		 pop	 ebx

; 168  : 		return false;
; 169  : 	}

  00082	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00085	33 cd		 xor	 ecx, ebp
  00087	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
$LN1@ExtractPac:
  00092	57		 push	 edi

; 128  : 		}
; 129  : 
; 130  : 		byXorFilter[0] = 0xE7;
; 131  : 		byXorFilter[1] = 0x6D;
; 132  : 		byXorFilter[2] = 0x3A;
; 133  : 		byXorFilter[3] = 0x89;
; 134  : 		byXorFilter[4] = 0xBC;
; 135  : 		byXorFilter[5] = 0xB2;
; 136  : 		byXorFilter[6] = 0x9F;
; 137  : 		byXorFilter[7] = 0x73;
; 138  : 		byXorFilter[8] = 0x23;
; 139  : 		byXorFilter[9] = 0xA8;
; 140  : 		byXorFilter[10] = 0xFE;
; 141  : 		byXorFilter[11] = 0xB6;
; 142  : 		byXorFilter[12] = 0x49;
; 143  : 		byXorFilter[13] = 0x5D;
; 144  : 		byXorFilter[14] = 0x39;
; 145  : 		byXorFilter[15] = 0x5D;
; 146  : 		byXorFilter[16] = 0x8A;
; 147  : 		byXorFilter[17] = 0xCB;
; 148  : 		byXorFilter[18] = 0x63;
; 149  : 		byXorFilter[19] = 0x8D;
; 150  : 		byXorFilter[20] = 0xEA;
; 151  : 		byXorFilter[21] = 0x7D;
; 152  : 		byXorFilter[22] = 0x2B;
; 153  : 		byXorFilter[23] = 0x5F;
; 154  : 		byXorFilter[24] = 0xC3;
; 155  : 		byXorFilter[25] = 0xB1;
; 156  : 		byXorFilter[26] = 0xE9;
; 157  : 		byXorFilter[27] = 0x83;
; 158  : 		byXorFilter[28] = 0x29;
; 159  : 		byXorFilter[29] = 0x51;
; 160  : 		byXorFilter[30] = 0xE8;
; 161  : 		byXorFilter[31] = 0x56;
; 162  : 
; 163  : 		this->XorData(wSize-1, (this->m_byBuffer[0] == 0xC1 ? 2 : 3), -1);

  00093	0f b7 f9	 movzx	 edi, cx
  00096	33 c9		 xor	 ecx, ecx
  00098	3c c1		 cmp	 al, 193			; 000000c1H
  0009a	0f 95 c1	 setne	 cl
  0009d	6a ff		 push	 -1
  0009f	8d 57 ff	 lea	 edx, DWORD PTR [edi-1]
  000a2	83 c1 02	 add	 ecx, 2
  000a5	51		 push	 ecx
  000a6	52		 push	 edx
  000a7	8b ce		 mov	 ecx, esi
  000a9	e8 00 00 00 00	 call	 ?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z ; CStreamPacketEngine_Server::XorData

; 164  : 		memcpy(pTar, this->m_byBuffer, wSize);

  000ae	8b 85 f8 f7 ff
	ff		 mov	 eax, DWORD PTR _pTar$GSCopy$[ebp]
  000b4	57		 push	 edi
  000b5	53		 push	 ebx
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 _memcpy

; 165  : 		this->m_wSize-=wSize;

  000bc	66 8b 8d f4 f7
	ff ff		 mov	 cx, WORD PTR _wSize$[ebp]
  000c3	66 29 4e 04	 sub	 WORD PTR [esi+4], cx

; 166  : 		memcpy(byTemp, &this->m_byBuffer[wSize], this->m_wSize);

  000c7	0f b7 46 04	 movzx	 eax, WORD PTR [esi+4]
  000cb	50		 push	 eax
  000cc	8d 54 37 06	 lea	 edx, DWORD PTR [edi+esi+6]
  000d0	89 85 f8 f7 ff
	ff		 mov	 DWORD PTR tv293[ebp], eax
  000d6	52		 push	 edx
  000d7	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _byTemp$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _memcpy

; 167  : 		memcpy(this->m_byBuffer, byTemp, this->m_wSize);

  000e3	8b 8d f8 f7 ff
	ff		 mov	 ecx, DWORD PTR tv293[ebp]
  000e9	51		 push	 ecx
  000ea	8d 95 fc f7 ff
	ff		 lea	 edx, DWORD PTR _byTemp$[ebp]
  000f0	52		 push	 edx
  000f1	53		 push	 ebx
  000f2	e8 00 00 00 00	 call	 _memcpy

; 168  : 		return false;
; 169  : 	}

  000f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fa	83 c4 24	 add	 esp, 36			; 00000024H
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	33 cd		 xor	 ecx, ebp
  00101	33 c0		 xor	 eax, eax
  00103	5b		 pop	 ebx
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c2 04 00	 ret	 4
?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ENDP ; CStreamPacketEngine_Server::ExtractPacket
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCStreamPacketEngine_Server@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCStreamPacketEngine_Server@@UAEPAXI@Z PROC		; CStreamPacketEngine_Server::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CStreamPacketEngine_Server@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_GCStreamPacketEngine_Server@@UAEPAXI@Z ENDP		; CStreamPacketEngine_Server::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GiocpInit@@YAXXZ				; GiocpInit
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\giocp.cpp
;	COMDAT ?GiocpInit@@YAXXZ
_TEXT	SEGMENT
?GiocpInit@@YAXXZ PROC					; GiocpInit, COMDAT

; 28   : 	ExSendBuf=new BYTE[MAX_EXSENDBUF_SIZE];

  00000	68 70 1b 00 00	 push	 7024			; 00001b70H
  00005	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0000a	83 c4 04	 add	 esp, 4
  0000d	a3 00 00 00 00	 mov	 DWORD PTR ?ExSendBuf@@3PAEA, eax ; ExSendBuf

; 29   : }

  00012	c3		 ret	 0
?GiocpInit@@YAXXZ ENDP					; GiocpInit
_TEXT	ENDS
PUBLIC	?GiocpDelete@@YAXXZ				; GiocpDelete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtp
;	COMDAT ?GiocpDelete@@YAXXZ
_TEXT	SEGMENT
?GiocpDelete@@YAXXZ PROC				; GiocpDelete, COMDAT

; 33   : 	delete[] ExSendBuf;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000b	59		 pop	 ecx

; 34   : }

  0000c	c3		 ret	 0
?GiocpDelete@@YAXXZ ENDP				; GiocpDelete
_TEXT	ENDS
PUBLIC	??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CFd@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CreateListenSocket@@YAHXZ			; CreateListenSocket
EXTRN	__imp__listen@8:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	__imp__bind@12:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	__imp__htonl@4:PROC
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp__WSASocketA@24:PROC
;	COMDAT ??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@ DB 'li'
	DB	'sten() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CFd@
CONST	SEGMENT
??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CFd@ DB 'WSA'
	DB	'Socket() failed with error %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CreateListenSocket@@YAHXZ
_TEXT	SEGMENT
_InternetAddr$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
?CreateListenSocket@@YAHXZ PROC				; CreateListenSocket, COMDAT

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 52   : 	sockaddr_in InternetAddr;
; 53   : 	int nRet;
; 54   : 
; 55   : 	g_Listen=WSASocket(AF_INET, SOCK_STREAM, IPPROTO_IP, NULL, 0, WSA_FLAG_OVERLAPPED);

  00010	6a 01		 push	 1
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	6a 01		 push	 1
  0001a	6a 02		 push	 2
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASocketA@24
  00022	a3 00 00 00 00	 mov	 DWORD PTR ?g_Listen@@3IA, eax ; g_Listen

; 56   : 
; 57   : 	if ( g_Listen == -1 )

  00027	83 f8 ff	 cmp	 eax, -1
  0002a	75 26		 jne	 SHORT $LN6@CreateList

; 58   : 	{
; 59   : 		LogAdd(LOG_BLACK, "WSASocket() failed with error %d", WSAGetLastError() );

  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CFd@
  00038	6a 00		 push	 0
  0003a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 60   : 		return 0;

  00042	33 c0		 xor	 eax, eax

; 82   : 			}
; 83   : 			else
; 84   : 			{
; 85   : 				return 1;
; 86   : 			}
; 87   : 		}
; 88   : 	} 
; 89   : }

  00044	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00047	33 cd		 xor	 ecx, ebp
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN6@CreateList:

; 61   : 	}
; 62   : 	else
; 63   : 	{
; 64   : 		InternetAddr.sin_family=AF_INET;

  00052	b8 02 00 00 00	 mov	 eax, 2

; 65   : 		InternetAddr.sin_addr.S_un.S_addr=htonl(0);

  00057	6a 00		 push	 0
  00059	66 89 45 ec	 mov	 WORD PTR _InternetAddr$[ebp], ax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htonl@4

; 66   : 		InternetAddr.sin_port=htons(g_ServerPort);

  00063	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?g_ServerPort@@3HA
  0006a	51		 push	 ecx
  0006b	89 45 f0	 mov	 DWORD PTR _InternetAddr$[ebp+4], eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4

; 67   : 		nRet=bind(g_Listen, (sockaddr*)&InternetAddr, 16);

  00074	6a 10		 push	 16			; 00000010H
  00076	8d 55 ec	 lea	 edx, DWORD PTR _InternetAddr$[ebp]
  00079	66 89 45 ee	 mov	 WORD PTR _InternetAddr$[ebp+2], ax
  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_Listen@@3IA ; g_Listen
  00082	52		 push	 edx
  00083	50		 push	 eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__bind@12

; 68   : 		
; 69   : 		if ( nRet == -1 )

  0008a	83 f8 ff	 cmp	 eax, -1
  0008d	75 3b		 jne	 SHORT $LN4@CreateList

; 70   : 		{
; 71   : 			MsgBox(lMsg.Get(MSGGET(2, 55)));

  0008f	68 37 02 00 00	 push	 567			; 00000237H
  00094	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00099	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 72   : 			SendMessage(ghWnd, WM_CLOSE, 0,0);	// Kill aplication

  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000aa	83 c4 04	 add	 esp, 4
  000ad	6a 00		 push	 0
  000af	6a 00		 push	 0
  000b1	6a 10		 push	 16			; 00000010H
  000b3	51		 push	 ecx
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 73   : 			return 0 ;

  000ba	33 c0		 xor	 eax, eax

; 82   : 			}
; 83   : 			else
; 84   : 			{
; 85   : 				return 1;
; 86   : 			}
; 87   : 		}
; 88   : 	} 
; 89   : }

  000bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bf	33 cd		 xor	 ecx, ebp
  000c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
$LN4@CreateList:

; 74   : 		}
; 75   : 		else
; 76   : 		{
; 77   : 			nRet=listen(g_Listen, 5);

  000ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_Listen@@3IA ; g_Listen
  000d0	6a 05		 push	 5
  000d2	52		 push	 edx
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__listen@8

; 78   : 			if (nRet == -1)

  000d9	83 f8 ff	 cmp	 eax, -1
  000dc	75 26		 jne	 SHORT $LN2@CreateList

; 79   : 			{
; 80   : 				LogAdd(LOG_BLACK, "listen() failed with error %d", WSAGetLastError());

  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000e4	50		 push	 eax
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@
  000ea	6a 00		 push	 0
  000ec	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 81   : 				return 0;

  000f4	33 c0		 xor	 eax, eax

; 82   : 			}
; 83   : 			else
; 84   : 			{
; 85   : 				return 1;
; 86   : 			}
; 87   : 		}
; 88   : 	} 
; 89   : }

  000f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f9	33 cd		 xor	 ecx, ebp
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
$LN2@CreateList:
  00104	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00107	33 cd		 xor	 ecx, ebp
  00109	b8 01 00 00 00	 mov	 eax, 1
  0010e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c3		 ret	 0
?CreateListenSocket@@YAHXZ ENDP				; CreateListenSocket
_TEXT	ENDS
PUBLIC	??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd?$AA@ ; `string'
PUBLIC	?UpdateCompletionPort@@YAHIHH@Z			; UpdateCompletionPort
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:BYTE			; gObj
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__CreateIoCompletionPort@16:PROC
;	COMDAT ??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd?$AA@ DB 'CreateIoCompl'
	DB	'etionPort: %d', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?UpdateCompletionPort@@YAHIHH@Z
_TEXT	SEGMENT
_sd$ = 8						; size = 4
_ClientIndex$ = 12					; size = 4
_bAddToList$ = 16					; size = 4
?UpdateCompletionPort@@YAHIHH@Z PROC			; UpdateCompletionPort, COMDAT

; 838  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 839  : 	LPPER_SOCKET_CONTEXT lpPerSocketContext = NULL;
; 840  : 
; 841  : 	HANDLE cp = CreateIoCompletionPort((HANDLE)sd, g_CompletionPort, (DWORD)ClientIndex, 0); 

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _sd$[ebp]
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _ClientIndex$[ebp]
  0000f	6a 00		 push	 0
  00011	56		 push	 esi
  00012	50		 push	 eax
  00013	51		 push	 ecx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateIoCompletionPort@16

; 842  :     
; 843  : 	if (cp == NULL)

  0001a	85 c0		 test	 eax, eax
  0001c	75 1b		 jne	 SHORT $LN1@UpdateComp

; 844  : 	{
; 845  : 		LogAdd(LOG_BLACK, "CreateIoCompletionPort: %d", GetLastError() );

  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00024	50		 push	 eax
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd?$AA@
  0002a	6a 00		 push	 0
  0002c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 846  : 		return FALSE;

  00034	33 c0		 xor	 eax, eax
  00036	5e		 pop	 esi

; 851  : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN1@UpdateComp:

; 847  : 	}
; 848  : 
; 849  : 	gObj[ClientIndex].PerSocketContext->dwIOCount = 0;

  00039	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  0003f	8b 96 0c 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+12]
  00045	c7 82 28 5e 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+24104], 0

; 850  : 	return TRUE;

  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	5e		 pop	 esi

; 851  : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?UpdateCompletionPort@@YAHIHH@Z ENDP			; UpdateCompletionPort
_TEXT	ENDS
PUBLIC	?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z	; CloseClient
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	__imp__closesocket@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z
_TEXT	SEGMENT
_lpPerSocketContext$ = 8				; size = 4
_bGraceful$ = 12					; size = 4
?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z PROC	; CloseClient, COMDAT

; 855  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 856  : 	int index = -1;
; 857  : 	index = lpPerSocketContext->nIndex ;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00006	57		 push	 edi
  00007	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 858  : 
; 859  : 	if ( index >= OBJ_STARTUSERINDEX && index < OBJMAX )

  0000a	8d 8f 00 e7 ff
	ff		 lea	 ecx, DWORD PTR [edi-6400]
  00010	81 f9 e7 03 00
	00		 cmp	 ecx, 999		; 000003e7H
  00016	77 43		 ja	 SHORT $LN4@CloseClien

; 860  : 	{
; 861  : 		if ( gObj[index].m_socket != INVALID_SOCKET )

  00018	8b d7		 mov	 edx, edi
  0001a	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00020	8b 82 10 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+16]
  00026	56		 push	 esi
  00027	8d b2 10 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+16]
  0002d	83 f8 ff	 cmp	 eax, -1
  00030	74 1f		 je	 SHORT $LN3@CloseClien

; 862  : 		{
; 863  : 			if (closesocket(gObj[index].m_socket) == -1 )

  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00039	83 f8 ff	 cmp	 eax, -1
  0003c	75 0d		 jne	 SHORT $LN1@CloseClien

; 864  : 			{
; 865  : 				if ( WSAGetLastError() != 10038 )

  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00044	3d 36 27 00 00	 cmp	 eax, 10038		; 00002736H
  00049	75 0f		 jne	 SHORT $LN7@CloseClien
$LN1@CloseClien:

; 866  : 				{
; 867  : 					return;
; 868  : 				}
; 869  : 			}
; 870  : 
; 871  : 			gObj[index].m_socket = INVALID_SOCKET;

  0004b	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN3@CloseClien:

; 872  : 		}
; 873  : 
; 874  : 		gObjDel(index);

  00051	57		 push	 edi
  00052	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00057	83 c4 04	 add	 esp, 4
$LN7@CloseClien:
  0005a	5e		 pop	 esi
$LN4@CloseClien:
  0005b	5f		 pop	 edi

; 875  : 	}
; 876  : }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ENDP	; CloseClient
_TEXT	ENDS
PUBLIC	??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5err@ ; `string'
PUBLIC	??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_S@ ; `string'
PUBLIC	??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5e@ ; `string'
PUBLIC	?CloseClient@@YAXH@Z				; CloseClient
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
;	COMDAT ??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5err@
CONST	SEGMENT
??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5err@ DB 'error-L1 :'
	DB	' CloseClient index error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_S@
CONST	SEGMENT
??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_S@ DB 'error-L1 : '
	DB	'CloseClient INVALID_SOCKET', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5e@
CONST	SEGMENT
??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5e@ DB 'error-L1 :'
	DB	' CloseClient connect error', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CloseClient@@YAXH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?CloseClient@@YAXH@Z PROC				; CloseClient, COMDAT

; 881  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 882  : 	if ( index < 0 || index > OBJMAX-1 )

  00004	8b 75 08	 mov	 esi, DWORD PTR _index$[ebp]
  00007	81 fe e7 1c 00
	00		 cmp	 esi, 7399		; 00001ce7H
  0000d	77 73		 ja	 SHORT $LN4@CloseClien@2

; 885  : 		return;
; 886  : 	}
; 887  : 
; 888  : 	if ( gObj[index].Connected == PLAYER_EMPTY )

  0000f	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00015	80 be 04 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+4], 0
  0001c	75 12		 jne	 SHORT $LN3@CloseClien@2

; 889  : 	{
; 890  : 		LogAdd(LOG_BLACK, "error-L1 : CloseClient connect error");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5e@
  00023	6a 00		 push	 0
  00025	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0002a	83 c4 08	 add	 esp, 8
  0002d	5e		 pop	 esi

; 907  : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN3@CloseClien@2:

; 891  : 		return;
; 892  : 	}
; 893  : 
; 894  : 	EnterCriticalSection(&criti);

  00030	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 895  : 
; 896  : 	if ( gObj[index].m_socket != INVALID_SOCKET )

  0003b	8b 86 10 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+16]
  00041	83 f8 ff	 cmp	 eax, -1
  00044	74 1f		 je	 SHORT $LN2@CloseClien@2

; 897  : 	{
; 898  : 		closesocket(gObj[index].m_socket );

  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 904  : 	}
; 905  : 
; 906  : 	LeaveCriticalSection(&criti);

  0004d	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00052	c7 86 10 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+16], -1
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00062	5e		 pop	 esi

; 907  : }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN2@CloseClien@2:

; 899  : 		gObj[index].m_socket = INVALID_SOCKET;
; 900  : 	}
; 901  : 	else
; 902  : 	{
; 903  : 		LogAdd(LOG_BLACK, "error-L1 : CloseClient INVALID_SOCKET");

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_S@
  0006a	6a 00		 push	 0
  0006c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00071	83 c4 08	 add	 esp, 8

; 904  : 	}
; 905  : 
; 906  : 	LeaveCriticalSection(&criti);

  00074	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0007f	5e		 pop	 esi

; 907  : }

  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
$LN4@CloseClien@2:

; 883  : 	{
; 884  : 		LogAdd(LOG_BLACK, "error-L1 : CloseClient index error");

  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5err@
  00087	6a 00		 push	 0
  00089	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0008e	83 c4 08	 add	 esp, 8
  00091	5e		 pop	 esi

; 907  : }

  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?CloseClient@@YAXH@Z ENDP				; CloseClient
_TEXT	ENDS
PUBLIC	?CloseClientEx@@YAXH@Z				; CloseClientEx
EXTRN	?SendClose@CReconnect@@QAEXH@Z:PROC		; CReconnect::SendClose
EXTRN	?gReconnect@@3VCReconnect@@A:BYTE		; gReconnect
; Function compile flags: /Ogtp
;	COMDAT ?CloseClientEx@@YAXH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?CloseClientEx@@YAXH@Z PROC				; CloseClientEx, COMDAT

; 910  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 911  : 	if ( index < 0 || index > OBJMAX-1 )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _index$[ebp]
  00007	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  0000d	77 50		 ja	 SHORT $LN4@CloseClien@3

; 912  : 	{
; 913  : 		/*LogAdd(LOG_BLACK, "error-L1 : CloseClient index error");*/
; 914  : 		return;
; 915  : 	}
; 916  : 
; 917  : 	if ( gObj[index].Connected == PLAYER_EMPTY )

  0000f	56		 push	 esi
  00010	8b f7		 mov	 esi, edi
  00012	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00018	80 be 04 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+4], 0
  0001f	74 3d		 je	 SHORT $LN8@CloseClien@3

; 918  : 	{
; 919  : 		/*LogAdd(LOG_BLACK, "error-L1 : CloseClient connect error");*/
; 920  : 		return;
; 921  : 	}
; 922  : 
; 923  : 	EnterCriticalSection(&criti);

  00021	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 924  : 
; 925  : 	gReconnect.SendClose(index);

  0002c	57		 push	 edi
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gReconnect@@3VCReconnect@@A ; gReconnect
  00032	e8 00 00 00 00	 call	 ?SendClose@CReconnect@@QAEXH@Z ; CReconnect::SendClose

; 926  : 
; 927  : 	if ( gObj[index].m_socket != INVALID_SOCKET )

  00037	8b 86 10 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+16]
  0003d	83 f8 ff	 cmp	 eax, -1
  00040	74 11		 je	 SHORT $LN2@CloseClien@3

; 928  : 	{
; 929  : 		closesocket(gObj[index].m_socket );

  00042	50		 push	 eax
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 930  : 		gObj[index].m_socket = INVALID_SOCKET;

  00049	c7 86 10 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+16], -1
$LN2@CloseClien@3:

; 931  : 	}
; 932  : 	else
; 933  : 	{
; 934  : 		/*LogAdd(LOG_BLACK, "error-L1 : CloseClient INVALID_SOCKET");*/
; 935  : 	}
; 936  : 
; 937  : 	LeaveCriticalSection(&criti);

  00053	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN8@CloseClien@3:
  0005e	5e		 pop	 esi
$LN4@CloseClien@3:
  0005f	5f		 pop	 edi

; 938  : }

  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?CloseClientEx@@YAXH@Z ENDP				; CloseClientEx
_TEXT	ENDS
PUBLIC	?ResponErrorCloseClient@@YAXH@Z			; ResponErrorCloseClient
; Function compile flags: /Ogtp
;	COMDAT ?ResponErrorCloseClient@@YAXH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?ResponErrorCloseClient@@YAXH@Z PROC			; ResponErrorCloseClient, COMDAT

; 941  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 942  : 	if ( index < 0 || index > OBJMAX-1 )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _index$[ebp]
  00007	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  0000d	77 6b		 ja	 SHORT $LN3@ResponErro

; 945  : 		return;
; 946  : 	}
; 947  : 
; 948  : 	if ( gObj[index].Connected == PLAYER_EMPTY )

  0000f	56		 push	 esi
  00010	8b f7		 mov	 esi, edi
  00012	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00018	80 be 04 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+4], 0
  0001f	75 13		 jne	 SHORT $LN2@ResponErro

; 949  : 	{
; 950  : 		LogAdd(LOG_BLACK, "error-L1 : CloseClient connect error");

  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5e@
  00026	6a 00		 push	 0
  00028	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0002d	83 c4 08	 add	 esp, 8
  00030	5e		 pop	 esi
  00031	5f		 pop	 edi

; 965  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN2@ResponErro:

; 951  : 		return;
; 952  : 	}
; 953  : 
; 954  : 	EnterCriticalSection(&criti);

  00034	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 955  : 	closesocket(gObj[index].m_socket);

  0003f	8b 86 10 00 00
	00		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+16]
  00045	50		 push	 eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 956  : 	gObj[index].m_socket = INVALID_SOCKET;
; 957  : 
; 958  : 	if ( gObj[index].m_socket == INVALID_SOCKET )
; 959  : 	{
; 960  : 		LogAdd(LOG_BLACK, "error-L1 : CloseClient INVALID_SOCKET");

  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_S@
  00051	6a 00		 push	 0
  00053	c7 86 10 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+16], -1
  0005d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 961  : 	}
; 962  : 
; 963  : 	gObjDel(index);

  00062	57		 push	 edi
  00063	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 	LeaveCriticalSection(&criti);

  0006b	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00076	5e		 pop	 esi
  00077	5f		 pop	 edi

; 965  : }

  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
$LN3@ResponErro:

; 943  : 	{
; 944  : 		LogAdd(LOG_BLACK, "error-L1 : CloseClient index error");

  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5err@
  0007f	6a 00		 push	 0
  00081	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00086	83 c4 08	 add	 esp, 8
  00089	5f		 pop	 edi

; 965  : }

  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?ResponErrorCloseClient@@YAXH@Z ENDP			; ResponErrorCloseClient
_TEXT	ENDS
PUBLIC	??0CStreamPacketEngine_Server@@QAE@XZ		; CStreamPacketEngine_Server::CStreamPacketEngine_Server
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\spe.h
;	COMDAT ??0CStreamPacketEngine_Server@@QAE@XZ
_TEXT	SEGMENT
??0CStreamPacketEngine_Server@@QAE@XZ PROC		; CStreamPacketEngine_Server::CStreamPacketEngine_Server, COMDAT
; _this$ = ecx

; 19   : 	CStreamPacketEngine_Server()	// Good

  00000	8b c1		 mov	 eax, ecx

; 20   : 	{
; 21   : 		this->Clear();

  00002	33 c9		 xor	 ecx, ecx
  00004	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CStreamPacketEngine_Server@@6B@
  0000a	66 89 48 04	 mov	 WORD PTR [eax+4], cx

; 22   : 	};

  0000e	c3		 ret	 0
??0CStreamPacketEngine_Server@@QAE@XZ ENDP		; CStreamPacketEngine_Server::CStreamPacketEngine_Server
_TEXT	ENDS
PUBLIC	??_C@_0BA@OIIBACED@Message?5copy?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@ ; `string'
PUBLIC	??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0DA@PEHCNCMI@error?9L1?5?3?5Header?5error?5?$CI?$CFs?5?$CFd?$CJl@ ; `string'
PUBLIC	??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5A@ ; `string'
PUBLIC	??_C@_09ELJFIOPP@giocp?4cpp?$AA@		; `string'
PUBLIC	??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN?$AA@ ; `string'
PUBLIC	_uIndex$GSCopy$
PUBLIC	_lpIOContext$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z	; RecvDataParse
EXTRN	?ProtocolCore@@YAXEPAEHHHH@Z:PROC		; ProtocolCore
EXTRN	?Decrypt@CSimpleModulus@@QAEHPAX0H@Z:PROC	; CSimpleModulus::Decrypt
EXTRN	?g_SimpleModulusCS@@3VCSimpleModulus@@A:BYTE	; g_SimpleModulusCS
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_0BA@OIIBACED@Message?5copy?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BA@OIIBACED@Message?5copy?5?$CFd?$AA@ DB 'Message copy %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd?$AA@ DB 'er'
	DB	'ror-L1 : recvbuflen 1 %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@
CONST	SEGMENT
??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@ DB 'error-L1 : '
	DB	'CStreamPacketEngine ExtractPacket Error : ip = %s account:%s '
	DB	'name:%s HEAD:%x (%s,%d) State:%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd?$AA@ DB 'error-L1 : size %d'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PEHCNCMI@error?9L1?5?3?5Header?5error?5?$CI?$CFs?5?$CFd?$CJl@
CONST	SEGMENT
??_C@_0DA@PEHCNCMI@error?9L1?5?3?5Header?5error?5?$CI?$CFs?5?$CFd?$CJl@ DB 'e'
	DB	'rror-L1 : Header error (%s %d)lOfs:%d, size:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5A@
CONST	SEGMENT
??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5A@ DB 'error-L1 : '
	DB	'CStreamPacketEngine Adding Error : ip = %s account:%s name:%s'
	DB	' HEAD:%x (%s,%d) State:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
CONST	SEGMENT
??_C@_09ELJFIOPP@giocp?4cpp?$AA@ DB 'giocp.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN?$AA@
CONST	SEGMENT
??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN?$AA@ DB 0beH
	DB	0cfH, 0c8H, 0a3H, 0c6H, 0d0H, 0c5H, 0b6H, ' : [0x%x]', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$2
__ehfuncinfo$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\giocp.cpp
xdata$x	ENDS
;	COMDAT ?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z
_TEXT	SEGMENT
_lpIOContext$GSCopy$ = -9116				; size = 4
_lOfs$ = -9112						; size = 4
_uIndex$GSCopy$ = -9108					; size = 4
_headcode$ = -9101					; size = 1
_subhead$155208 = -9097					; size = 1
_subhead$155191 = -9097					; size = 1
_ps$155223 = -9096					; size = 2056
_PacketStream$155216 = -9096				; size = 2056
_PacketStream$155193 = -9096				; size = 2056
_byDec$ = -7040						; size = 7024
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpIOContext$ = 8					; size = 4
_uIndex$ = 12						; size = 4
?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z PROC		; RecvDataParse, COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 90 23 00 00	 mov	 eax, 9104		; 00002390H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b 5d 08	 mov	 ebx, DWORD PTR _lpIOContext$[ebp]

; 356  : 	if ( lpIOContext->nSentBytes < 3 )

  00035	83 bb 04 2f 00
	00 03		 cmp	 DWORD PTR [ebx+12036], 3

; 386  : 			headcode			= lphead->headcode;

  0003c	8b 45 0c	 mov	 eax, DWORD PTR _uIndex$[ebp]

; 450  : 					{
; 451  : 						LogAdd(LOG_BLACK, " : [0x%x]" , headcode);
; 452  : 					}
; 453  : 
; 454  : 					ProtocolCore(headcode, byDec, iSize, uIndex, 1, subhead);

  0003f	89 9d 64 dc ff
	ff		 mov	 DWORD PTR _lpIOContext$GSCopy$[ebp], ebx
  00045	89 85 6c dc ff
	ff		 mov	 DWORD PTR _uIndex$GSCopy$[ebp], eax
  0004b	0f 8c 41 05 00
	00		 jl	 $LN2@RecvDataPa

; 357  : 	{
; 358  : 		return TRUE;
; 359  : 	}
; 360  : 
; 361  : 	LPBYTE recvbuf;
; 362  : 	int lOfs = 0;

  00051	33 d2		 xor	 edx, edx
  00053	89 95 68 dc ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], edx
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL32@RecvDataPa:

; 363  : 	int size = 0;
; 364  : 	BYTE headcode;
; 365  : 	BYTE xcode = 0;
; 366  : 	BYTE byDec[7024];
; 367  : 
; 368  : 	recvbuf = (LPBYTE)lpIOContext->Buffer;
; 369  : 	
; 370  : 	while ( 1 )
; 371  : 	{
; 372  : 		if( recvbuf[lOfs] == 0xC1 || 
; 373  : 			recvbuf[lOfs] == 0xC3 ) 

  00060	8d 7b 1c	 lea	 edi, DWORD PTR [ebx+28]
  00063	8a 0c 17	 mov	 cl, BYTE PTR [edi+edx]
  00066	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00069	80 f9 c1	 cmp	 cl, 193			; 000000c1H
  0006c	74 25		 je	 SHORT $LN29@RecvDataPa
  0006e	80 f9 c3	 cmp	 cl, 195			; 000000c3H
  00071	74 20		 je	 SHORT $LN29@RecvDataPa

; 378  : 			xcode				= recvbuf[lOfs];
; 379  : 		}
; 380  : 		else if( recvbuf[lOfs] == 0xC2 || 
; 381  : 				 recvbuf[lOfs] == 0xC4 ) //

  00073	80 f9 c2	 cmp	 cl, 194			; 000000c2H
  00076	74 09		 je	 SHORT $LN26@RecvDataPa
  00078	80 f9 c4	 cmp	 cl, 196			; 000000c4H
  0007b	0f 85 b7 03 00
	00		 jne	 $LN27@RecvDataPa
$LN26@RecvDataPa:

; 382  : 		{
; 383  : 			PWMSG_HEAD* lphead	= (PWMSG_HEAD*)(recvbuf+lOfs);
; 384  : 			size				= ((WORD)(lphead->sizeH)<<8);
; 385  : 			size			   |= (WORD)(lphead->sizeL);

  00081	0f b6 70 01	 movzx	 esi, BYTE PTR [eax+1]
  00085	0f b6 50 02	 movzx	 edx, BYTE PTR [eax+2]
  00089	c1 e6 08	 shl	 esi, 8
  0008c	0b f2		 or	 esi, edx

; 386  : 			headcode			= lphead->headcode;

  0008e	8a 50 03	 mov	 dl, BYTE PTR [eax+3]

; 387  : 			xcode				= recvbuf[lOfs];
; 388  : 		}
; 389  : 		else  //   ..

  00091	eb 07		 jmp	 SHORT $LN103@RecvDataPa
$LN29@RecvDataPa:

; 374  : 		{
; 375  : 			PBMSG_HEAD* lphead = (PBMSG_HEAD*)(recvbuf+lOfs);
; 376  : 			size				= lphead->size;

  00093	0f b6 70 01	 movzx	 esi, BYTE PTR [eax+1]

; 377  : 			headcode			= lphead->headcode;

  00097	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
$LN103@RecvDataPa:
  0009a	88 95 73 dc ff
	ff		 mov	 BYTE PTR _headcode$[ebp], dl

; 396  : 		}
; 397  : 		if ( size <= 0 )

  000a0	85 f6		 test	 esi, esi
  000a2	0f 8e c2 03 00
	00		 jle	 $LN88@RecvDataPa

; 401  : 		}
; 402  : 
; 403  : 		if ( size <= lpIOContext->nSentBytes )

  000a8	3b b3 04 2f 00
	00		 cmp	 esi, DWORD PTR [ebx+12036]
  000ae	0f 8f 87 04 00
	00		 jg	 $LN23@RecvDataPa

; 404  : 		{
; 405  : 			if ( xcode == 0xC3 )

  000b4	80 f9 c3	 cmp	 cl, 195			; 000000c3H
  000b7	0f 85 36 01 00
	00		 jne	 $LN22@RecvDataPa

; 406  : 			{
; 407  : 				int iSize = g_SimpleModulusCS.Decrypt( byDec+2,(recvbuf+lOfs+2), size-2);

  000bd	8b 8d 68 dc ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  000c3	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  000c6	50		 push	 eax
  000c7	8d 54 0f 02	 lea	 edx, DWORD PTR [edi+ecx+2]
  000cb	52		 push	 edx
  000cc	8d 85 82 e4 ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp+2]
  000d2	50		 push	 eax
  000d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulusCS@@3VCSimpleModulus@@A ; g_SimpleModulusCS
  000d8	e8 00 00 00 00	 call	 ?Decrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Decrypt
  000dd	8b d8		 mov	 ebx, eax

; 408  : 
; 409  : 				if ( iSize < 0 )

  000df	85 db		 test	 ebx, ebx
  000e1	0f 88 e2 00 00
	00		 js	 $LN100@RecvDataPa

; 410  : 				{
; 411  : 
; 412  : 				}
; 413  : 				else
; 414  : 				{
; 415  : 					PBMSG_HEAD* lphead = (PBMSG_HEAD*)(byDec+1);
; 416  : 					headcode		= lphead->headcode;
; 417  : 					BYTE subhead	= byDec[2];

  000e7	8a 95 82 e4 ff
	ff		 mov	 dl, BYTE PTR _byDec$[ebp+2]
  000ed	8a 8d 83 e4 ff
	ff		 mov	 cl, BYTE PTR _byDec$[ebp+3]

; 418  : 					byDec[1]		= 0xC1;
; 419  : 					byDec[2]		= ((BYTE)iSize)+2;

  000f3	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  000f6	88 8d 73 dc ff
	ff		 mov	 BYTE PTR _headcode$[ebp], cl
  000fc	88 95 77 dc ff
	ff		 mov	 BYTE PTR _subhead$155191[ebp], dl
  00102	c6 85 81 e4 ff
	ff c1		 mov	 BYTE PTR _byDec$[ebp+1], 193 ; 000000c1H
  00109	88 85 82 e4 ff
	ff		 mov	 BYTE PTR _byDec$[ebp+2], al

; 420  : 
; 421  : 					CStreamPacketEngine_Server PacketStream;

  0010f	c7 85 78 dc ff
	ff 00 00 00 00	 mov	 DWORD PTR _PacketStream$155193[ebp], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 422  : 
; 423  : 					PacketStream.Clear();
; 424  : 
; 425  : 					if ( PacketStream.AddData(byDec+1, iSize+2) == 0 )

  00119	8d 53 02	 lea	 edx, DWORD PTR [ebx+2]
  0011c	0f b7 fa	 movzx	 edi, dx
  0011f	33 c9		 xor	 ecx, ecx
  00121	8b c7		 mov	 eax, edi
  00123	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0012a	66 89 8d 7c dc
	ff ff		 mov	 WORD PTR _PacketStream$155193[ebp+4], cx
  00131	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00136	0f 8d 1d 02 00
	00		 jge	 $LN45@RecvDataPa
  0013c	66 85 ff	 test	 di, di
  0013f	0f 84 14 02 00
	00		 je	 $LN45@RecvDataPa
  00145	50		 push	 eax
  00146	8d 85 81 e4 ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp+1]
  0014c	50		 push	 eax
  0014d	8d 8d 7e dc ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$155193[ebp+6]
  00153	51		 push	 ecx
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	66 01 bd 7c dc
	ff ff		 add	 WORD PTR _PacketStream$155193[ebp+4], di
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH

; 435  : 					}
; 436  : 
; 437  : 					if ( PacketStream.ExtractPacket(byDec) != 0 )

  00163	8d 95 80 e4 ff
	ff		 lea	 edx, DWORD PTR _byDec$[ebp]
  00169	52		 push	 edx
  0016a	8d 8d 78 dc ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$155193[ebp]
  00170	e8 00 00 00 00	 call	 ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
  00175	85 c0		 test	 eax, eax
  00177	0f 85 04 03 00
	00		 jne	 $LN90@RecvDataPa

; 447  : 					}
; 448  : 
; 449  : 					if ( xcode == 0xC3 && headcode == 0xC5 )

  0017d	80 bd 73 dc ff
	ff c5		 cmp	 BYTE PTR _headcode$[ebp], 197 ; 000000c5H
$LN107@RecvDataPa:

; 504  : 
; 505  : 					if ( xcode == 0xC4 && headcode == 0xC5 )

  00184	75 14		 jne	 SHORT $LN10@RecvDataPa

; 506  : 					{
; 507  : 						LogAdd(LOG_BLACK, " : [0x%x]" , headcode);

  00186	68 c5 00 00 00	 push	 197			; 000000c5H
  0018b	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN?$AA@
  00190	6a 00		 push	 0
  00192	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00197	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@RecvDataPa:

; 508  : 					}
; 509  : 
; 510  : 					ProtocolCore(headcode, byDec, iSize, uIndex, 1, subhead);

  0019a	0f b6 85 77 dc
	ff ff		 movzx	 eax, BYTE PTR _subhead$155208[ebp]
  001a1	8b 8d 6c dc ff
	ff		 mov	 ecx, DWORD PTR _uIndex$GSCopy$[ebp]
  001a7	50		 push	 eax
  001a8	8b 85 73 dc ff
	ff		 mov	 eax, DWORD PTR _headcode$[ebp]
  001ae	6a 01		 push	 1
  001b0	51		 push	 ecx
  001b1	53		 push	 ebx
  001b2	8d 95 80 e4 ff
	ff		 lea	 edx, DWORD PTR _byDec$[ebp]
  001b8	52		 push	 edx
  001b9	50		 push	 eax
  001ba	e8 00 00 00 00	 call	 ?ProtocolCore@@YAXEPAEHHHH@Z ; ProtocolCore
  001bf	83 c4 18	 add	 esp, 24			; 00000018H

; 511  : 				}

  001c2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN100@RecvDataPa:

; 512  : 			}
; 513  : 			else

  001c9	8b 9d 64 dc ff
	ff		 mov	 ebx, DWORD PTR _lpIOContext$GSCopy$[ebp]

; 543  : 			}

$LN85@RecvDataPa:

; 544  : 
; 545  : 			lOfs += size;

  001cf	01 b5 68 dc ff
	ff		 add	 DWORD PTR _lOfs$[ebp], esi

; 546  : 			lpIOContext->nSentBytes  -= size;

  001d5	29 b3 04 2f 00
	00		 sub	 DWORD PTR [ebx+12036], esi

; 547  : 
; 548  : 			if ( lpIOContext->nSentBytes <= 0 )

  001db	83 bb 04 2f 00
	00 00		 cmp	 DWORD PTR [ebx+12036], 0
  001e2	0f 8e aa 03 00
	00		 jle	 $LN2@RecvDataPa

; 565  : 				//break;
; 566  : 			}
; 567  : 			break;
; 568  : 		
; 569  : 		}
; 570  : 		else
; 571  : 		{
; 572  : 			break;
; 573  : 		}
; 574  : 		
; 575  : 	}

  001e8	8b 95 68 dc ff
	ff		 mov	 edx, DWORD PTR _lOfs$[ebp]
  001ee	e9 6d fe ff ff	 jmp	 $LL32@RecvDataPa
$LN22@RecvDataPa:

; 455  : 				}
; 456  : 			}
; 457  : 
; 458  : 			else if ( xcode == 0xC4 )

  001f3	80 f9 c4	 cmp	 cl, 196			; 000000c4H
  001f6	0f 85 cc 00 00
	00		 jne	 $LN15@RecvDataPa

; 459  : 			{
; 460  : 				int iSize = g_SimpleModulusCS.Decrypt( byDec+3, (recvbuf+lOfs+3), size-3);

  001fc	8b 95 68 dc ff
	ff		 mov	 edx, DWORD PTR _lOfs$[ebp]
  00202	8d 4e fd	 lea	 ecx, DWORD PTR [esi-3]
  00205	51		 push	 ecx
  00206	8d 44 17 03	 lea	 eax, DWORD PTR [edi+edx+3]
  0020a	50		 push	 eax
  0020b	8d 8d 83 e4 ff
	ff		 lea	 ecx, DWORD PTR _byDec$[ebp+3]
  00211	51		 push	 ecx
  00212	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulusCS@@3VCSimpleModulus@@A ; g_SimpleModulusCS
  00217	e8 00 00 00 00	 call	 ?Decrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Decrypt
  0021c	8b d8		 mov	 ebx, eax

; 461  : 				if ( iSize < 0 )

  0021e	85 db		 test	 ebx, ebx
  00220	78 a7		 js	 SHORT $LN100@RecvDataPa

; 462  : 				{
; 463  : 
; 464  : 				}
; 465  : 				else
; 466  : 				{
; 467  : 					BYTE* pDecBuf = byDec+1;
; 468  : 					BYTE subhead	= byDec[3];

  00222	8a 95 83 e4 ff
	ff		 mov	 dl, BYTE PTR _byDec$[ebp+3]

; 469  : 					byDec[1]		= 0xC2;
; 470  : 					WORD wsize		= ((WORD)iSize)+3;

  00228	8d 7b 03	 lea	 edi, DWORD PTR [ebx+3]
  0022b	0f b7 c7	 movzx	 eax, di

; 471  : 					byDec[2]		= SET_NUMBERH(wsize);

  0022e	8b c8		 mov	 ecx, eax
  00230	c1 e9 08	 shr	 ecx, 8
  00233	88 95 77 dc ff
	ff		 mov	 BYTE PTR _subhead$155208[ebp], dl
  00239	c6 85 81 e4 ff
	ff c2		 mov	 BYTE PTR _byDec$[ebp+1], 194 ; 000000c2H
  00240	88 8d 82 e4 ff
	ff		 mov	 BYTE PTR _byDec$[ebp+2], cl

; 472  : 					byDec[3]		= SET_NUMBERL(wsize);

  00246	88 85 83 e4 ff
	ff		 mov	 BYTE PTR _byDec$[ebp+3], al

; 473  : 
; 474  : 					CStreamPacketEngine_Server PacketStream;

  0024c	c7 85 78 dc ff
	ff 00 00 00 00	 mov	 DWORD PTR _PacketStream$155216[ebp], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 475  : 
; 476  : 					PacketStream.Clear();
; 477  : 					if ( PacketStream.AddData(byDec+1, iSize+3) == 0 )

  00256	0f b7 c7	 movzx	 eax, di
  00259	33 d2		 xor	 edx, edx
  0025b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00262	66 89 95 7c dc
	ff ff		 mov	 WORD PTR _PacketStream$155216[ebp+4], dx
  00269	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0026e	0f 8d 46 01 00
	00		 jge	 $LN61@RecvDataPa
  00274	66 85 ff	 test	 di, di
  00277	0f 84 3d 01 00
	00		 je	 $LN61@RecvDataPa
  0027d	50		 push	 eax
  0027e	8d 85 81 e4 ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp+1]
  00284	50		 push	 eax
  00285	8d 8d 7e dc ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$155216[ebp+6]
  0028b	51		 push	 ecx
  0028c	e8 00 00 00 00	 call	 _memcpy
  00291	66 01 bd 7c dc
	ff ff		 add	 WORD PTR _PacketStream$155216[ebp+4], di
  00298	83 c4 0c	 add	 esp, 12			; 0000000cH

; 488  : 					}
; 489  : 
; 490  : 					if ( PacketStream.ExtractPacket(byDec) != 0 )

  0029b	8d 95 80 e4 ff
	ff		 lea	 edx, DWORD PTR _byDec$[ebp]
  002a1	52		 push	 edx
  002a2	8d 8d 78 dc ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$155216[ebp]
  002a8	e8 00 00 00 00	 call	 ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
  002ad	85 c0		 test	 eax, eax
  002af	0f 85 1d 02 00
	00		 jne	 $LN92@RecvDataPa

; 500  : 						return FALSE;
; 501  : 					}
; 502  : 
; 503  : 					headcode = pDecBuf[2];

  002b5	8a 85 83 e4 ff
	ff		 mov	 al, BYTE PTR _byDec$[ebp+3]
  002bb	88 85 73 dc ff
	ff		 mov	 BYTE PTR _headcode$[ebp], al

; 504  : 
; 505  : 					if ( xcode == 0xC4 && headcode == 0xC5 )

  002c1	3c c5		 cmp	 al, 197			; 000000c5H

; 512  : 			}
; 513  : 			else

  002c3	e9 bc fe ff ff	 jmp	 $LN107@RecvDataPa
$LN15@RecvDataPa:

; 514  : 			{
; 515  : 				CStreamPacketEngine_Server ps;

  002c8	c7 85 78 dc ff
	ff 00 00 00 00	 mov	 DWORD PTR _ps$155223[ebp], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 516  : 				ps.Clear();

  002d2	33 c9		 xor	 ecx, ecx
  002d4	66 89 8d 7c dc
	ff ff		 mov	 WORD PTR _ps$155223[ebp+4], cx

; 517  : 				
; 518  : 				if ( ps.AddData(recvbuf+lOfs, size) == 0 )

  002db	0f b7 ce	 movzx	 ecx, si
  002de	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  002e5	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  002eb	0f 8d 19 01 00
	00		 jge	 $LN77@RecvDataPa
  002f1	66 85 f6	 test	 si, si
  002f4	0f 84 10 01 00
	00		 je	 $LN77@RecvDataPa
  002fa	51		 push	 ecx
  002fb	50		 push	 eax
  002fc	8d 95 7e dc ff
	ff		 lea	 edx, DWORD PTR _ps$155223[ebp+6]
  00302	52		 push	 edx
  00303	e8 00 00 00 00	 call	 _memcpy
  00308	66 01 b5 7c dc
	ff ff		 add	 WORD PTR _ps$155223[ebp+4], si
  0030f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 528  : 				}
; 529  : 
; 530  : 				if ( ps.ExtractPacket(byDec) != 0 )

  00312	8d 85 80 e4 ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp]
  00318	50		 push	 eax
  00319	8d 8d 78 dc ff
	ff		 lea	 ecx, DWORD PTR _ps$155223[ebp]
  0031f	e8 00 00 00 00	 call	 ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
  00324	85 c0		 test	 eax, eax
  00326	0f 85 f4 01 00
	00		 jne	 $LN94@RecvDataPa

; 540  : 				}
; 541  : 
; 542  : 				ProtocolCore(headcode, byDec, size, uIndex, 0, -1);

  0032c	8b 8d 6c dc ff
	ff		 mov	 ecx, DWORD PTR _uIndex$GSCopy$[ebp]
  00332	6a ff		 push	 -1
  00334	50		 push	 eax
  00335	8b 85 73 dc ff
	ff		 mov	 eax, DWORD PTR _headcode$[ebp]
  0033b	51		 push	 ecx
  0033c	56		 push	 esi
  0033d	8d 95 80 e4 ff
	ff		 lea	 edx, DWORD PTR _byDec$[ebp]
  00343	52		 push	 edx
  00344	50		 push	 eax
  00345	e8 00 00 00 00	 call	 ?ProtocolCore@@YAXEPAEHHHH@Z ; ProtocolCore
  0034a	83 c4 18	 add	 esp, 24			; 00000018H

; 543  : 			}

  0034d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00354	e9 76 fe ff ff	 jmp	 $LN85@RecvDataPa

; 422  : 
; 423  : 					PacketStream.Clear();
; 424  : 
; 425  : 					if ( PacketStream.AddData(byDec+1, iSize+2) == 0 )

$LN45@RecvDataPa:
  00359	57		 push	 edi
  0035a	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
  0035f	6a 01		 push	 1
  00361	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 426  : 					{
; 427  : 						LogAdd(LOG_RED,  "error-L1 : CStreamPacketEngine Adding Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 428  : 							gObj[uIndex].Ip_addr, 
; 429  : 							gObj[uIndex].AccountID, 
; 430  : 							gObj[uIndex].Name, 
; 431  : 							headcode, 
; 432  : 							__FILE__, __LINE__, 
; 433  : 							gObj[uIndex].Connected);

  00366	8b 85 6c dc ff
	ff		 mov	 eax, DWORD PTR _uIndex$GSCopy$[ebp]
  0036c	0f b6 8d 73 dc
	ff ff		 movzx	 ecx, BYTE PTR _headcode$[ebp]
  00373	83 c4 0c	 add	 esp, 12			; 0000000cH
  00376	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0037c	0f b6 90 04 00
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4]
  00383	52		 push	 edx
  00384	68 b0 01 00 00	 push	 432			; 000001b0H
  00389	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  0038e	51		 push	 ecx
  0038f	8d 90 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  00395	52		 push	 edx
  00396	8d 88 64 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  0039c	51		 push	 ecx
  0039d	8d 90 14 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+20]
  003a3	52		 push	 edx
$LN105@RecvDataPa:
  003a4	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5A@
  003a9	6a 01		 push	 1
  003ab	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  003b0	83 c4 24	 add	 esp, 36			; 00000024H

; 434  : 						return FALSE;

  003b3	33 c0		 xor	 eax, eax
  003b5	e9 dd 01 00 00	 jmp	 $LN34@RecvDataPa

; 475  : 
; 476  : 					PacketStream.Clear();
; 477  : 					if ( PacketStream.AddData(byDec+1, iSize+3) == 0 )

$LN61@RecvDataPa:
  003ba	0f b7 d7	 movzx	 edx, di
  003bd	52		 push	 edx
  003be	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
  003c3	6a 01		 push	 1
  003c5	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 478  : 					{
; 479  : 						LogAdd(LOG_RED,  "error-L1 : CStreamPacketEngine Adding Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d",	
; 480  : 							gObj[uIndex].Ip_addr, 
; 481  : 							gObj[uIndex].AccountID, 
; 482  : 							gObj[uIndex].Name, 
; 483  : 							headcode, 
; 484  : 							__FILE__, 
; 485  : 							__LINE__, 
; 486  : 							gObj[uIndex].Connected);

  003ca	8b 85 6c dc ff
	ff		 mov	 eax, DWORD PTR _uIndex$GSCopy$[ebp]
  003d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  003d3	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  003d9	0f b6 88 04 00
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4]
  003e0	51		 push	 ecx
  003e1	68 e5 01 00 00	 push	 485			; 000001e5H
$LN108@RecvDataPa:
  003e6	0f b6 95 73 dc
	ff ff		 movzx	 edx, BYTE PTR _headcode$[ebp]
  003ed	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  003f2	52		 push	 edx
  003f3	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  003f9	51		 push	 ecx
  003fa	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00400	52		 push	 edx
  00401	8d 80 14 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+20]
  00407	50		 push	 eax

; 487  : 						return FALSE;

  00408	eb 9a		 jmp	 SHORT $LN105@RecvDataPa

; 517  : 				
; 518  : 				if ( ps.AddData(recvbuf+lOfs, size) == 0 )

$LN77@RecvDataPa:
  0040a	0f b7 c6	 movzx	 eax, si
  0040d	50		 push	 eax
  0040e	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
  00413	6a 01		 push	 1
  00415	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 519  : 				{
; 520  : 					LogAdd(LOG_RED,  "error-L1 : CStreamPacketEngine Adding Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 521  : 						gObj[uIndex].Ip_addr, 
; 522  : 						gObj[uIndex].AccountID, 
; 523  : 						gObj[uIndex].Name, 
; 524  : 						headcode, 
; 525  : 						__FILE__, __LINE__, 
; 526  : 						gObj[uIndex].Connected);

  0041a	8b 85 6c dc ff
	ff		 mov	 eax, DWORD PTR _uIndex$GSCopy$[ebp]
  00420	83 c4 0c	 add	 esp, 12			; 0000000cH
  00423	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00429	0f b6 88 04 00
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4]
  00430	51		 push	 ecx
  00431	68 0d 02 00 00	 push	 525			; 0000020dH

; 527  : 					return FALSE;

  00436	eb ae		 jmp	 SHORT $LN108@RecvDataPa
$LN27@RecvDataPa:

; 390  : 		{
; 391  : 			LogAdd(LOG_BLACK, "error-L1 : Header error (%s %d)lOfs:%d, size:%d",
; 392  : 				__FILE__, __LINE__, lOfs, 
; 393  : 				lpIOContext->nSentBytes);

  00438	8b 8b 04 2f 00
	00		 mov	 ecx, DWORD PTR [ebx+12036]
  0043e	51		 push	 ecx
  0043f	52		 push	 edx
  00440	68 88 01 00 00	 push	 392			; 00000188H
  00445	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  0044a	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@PEHCNCMI@error?9L1?5?3?5Header?5error?5?$CI?$CFs?5?$CFd?$CJl@
  0044f	6a 00		 push	 0
  00451	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00456	83 c4 18	 add	 esp, 24			; 00000018H

; 394  : 			lpIOContext->nSentBytes = 0;

  00459	c7 83 04 2f 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+12036], 0

; 395  : 			return FALSE;

  00463	33 c0		 xor	 eax, eax
  00465	e9 2d 01 00 00	 jmp	 $LN34@RecvDataPa
$LN88@RecvDataPa:

; 398  : 		{
; 399  : 			LogAdd(LOG_BLACK, "error-L1 : size %d",size);

  0046a	56		 push	 esi
  0046b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd?$AA@
  00470	6a 00		 push	 0
  00472	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00477	83 c4 0c	 add	 esp, 12			; 0000000cH

; 400  : 			return FALSE;

  0047a	33 c0		 xor	 eax, eax
  0047c	e9 16 01 00 00	 jmp	 $LN34@RecvDataPa
$LN90@RecvDataPa:

; 438  : 					{
; 439  : 						LogAdd(LOG_RED,  "error-L1 : CStreamPacketEngine ExtractPacket Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 440  : 							gObj[uIndex].Ip_addr, 
; 441  : 							gObj[uIndex].AccountID, 
; 442  : 							gObj[uIndex].Name, 
; 443  : 							headcode, 
; 444  : 							__FILE__, __LINE__, 
; 445  : 							gObj[uIndex].Connected);

  00481	8b 85 6c dc ff
	ff		 mov	 eax, DWORD PTR _uIndex$GSCopy$[ebp]
  00487	0f b6 95 73 dc
	ff ff		 movzx	 edx, BYTE PTR _headcode$[ebp]
  0048e	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00494	0f b6 88 04 00
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4]
  0049b	51		 push	 ecx
  0049c	68 bc 01 00 00	 push	 444			; 000001bcH
  004a1	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  004a6	52		 push	 edx
  004a7	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  004ad	51		 push	 ecx
  004ae	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  004b4	52		 push	 edx
  004b5	8d 80 14 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+20]
  004bb	50		 push	 eax
  004bc	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@
  004c1	6a 01		 push	 1
  004c3	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  004c8	83 c4 24	 add	 esp, 36			; 00000024H

; 446  : 						return FALSE;

  004cb	33 c0		 xor	 eax, eax
  004cd	e9 c5 00 00 00	 jmp	 $LN34@RecvDataPa
$LN92@RecvDataPa:

; 491  : 					{
; 492  : 						LogAdd(LOG_RED,  "error-L1 : CStreamPacketEngine ExtractPacket Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 493  : 							gObj[uIndex].Ip_addr, 
; 494  : 							gObj[uIndex].AccountID, 
; 495  : 							gObj[uIndex].Name, 
; 496  : 							headcode, 
; 497  : 							__FILE__, 
; 498  : 							__LINE__, 
; 499  : 							gObj[uIndex].Connected);

  004d2	8b 85 6c dc ff
	ff		 mov	 eax, DWORD PTR _uIndex$GSCopy$[ebp]
  004d8	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  004de	0f b6 88 04 00
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4]
  004e5	51		 push	 ecx
  004e6	68 f2 01 00 00	 push	 498			; 000001f2H
$LN109@RecvDataPa:
  004eb	0f b6 95 73 dc
	ff ff		 movzx	 edx, BYTE PTR _headcode$[ebp]
  004f2	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  004f7	52		 push	 edx
  004f8	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  004fe	51		 push	 ecx
  004ff	8d 90 64 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  00505	52		 push	 edx
  00506	8d 80 14 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+20]
  0050c	50		 push	 eax
  0050d	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@
  00512	6a 01		 push	 1
  00514	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00519	83 c4 24	 add	 esp, 36			; 00000024H
  0051c	33 c0		 xor	 eax, eax
  0051e	eb 77		 jmp	 SHORT $LN34@RecvDataPa
$LN94@RecvDataPa:

; 531  : 				{
; 532  : 					LogAdd(LOG_RED,  "error-L1 : CStreamPacketEngine ExtractPacket Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 533  : 						gObj[uIndex].Ip_addr, 
; 534  : 						gObj[uIndex].AccountID, 
; 535  : 						gObj[uIndex].Name, 
; 536  : 						headcode, 
; 537  : 						__FILE__, __LINE__, 
; 538  : 						gObj[uIndex].Connected);

  00520	8b 85 6c dc ff
	ff		 mov	 eax, DWORD PTR _uIndex$GSCopy$[ebp]
  00526	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0052c	0f b6 88 04 00
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4]
  00533	51		 push	 ecx
  00534	68 19 02 00 00	 push	 537			; 00000219H

; 539  : 					return FALSE;

  00539	eb b0		 jmp	 SHORT $LN109@RecvDataPa
$LN23@RecvDataPa:

; 549  : 			{
; 550  : 				break;
; 551  : 			}
; 552  : 		}
; 553  : 		else if ( lOfs > 0 )

  0053b	8b 8d 68 dc ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  00541	85 c9		 test	 ecx, ecx
  00543	7e 4d		 jle	 SHORT $LN2@RecvDataPa

; 554  : 		{
; 555  : 			if ( lpIOContext->nSentBytes < 1 )

  00545	8b 83 04 2f 00
	00		 mov	 eax, DWORD PTR [ebx+12036]
  0054b	83 f8 01	 cmp	 eax, 1
  0054e	7d 1b		 jge	 SHORT $LN3@RecvDataPa

; 556  : 			{
; 557  : 				LogAdd(LOG_BLACK, "error-L1 : recvbuflen 1 %s %d", __FILE__, __LINE__);

  00550	68 2d 02 00 00	 push	 557			; 0000022dH
  00555	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  0055a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd?$AA@
  0055f	6a 00		 push	 0
  00561	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00566	83 c4 10	 add	 esp, 16			; 00000010H

; 558  : 				break;

  00569	eb 27		 jmp	 SHORT $LN2@RecvDataPa
$LN3@RecvDataPa:

; 559  : 			}
; 560  : 
; 561  : 			if ( lpIOContext->nSentBytes < MAX_IO_BUFFER_SIZE ) 

  0056b	3d 70 17 00 00	 cmp	 eax, 6000		; 00001770H
  00570	7d 20		 jge	 SHORT $LN2@RecvDataPa

; 562  : 			{
; 563  : 				memcpy(recvbuf, &recvbuf[lOfs], lpIOContext->nSentBytes);

  00572	50		 push	 eax
  00573	03 cf		 add	 ecx, edi
  00575	51		 push	 ecx
  00576	57		 push	 edi
  00577	e8 00 00 00 00	 call	 _memcpy

; 564  : 				LogAdd(LOG_BLACK, "Message copy %d", lpIOContext->nSentBytes);

  0057c	8b 93 04 2f 00
	00		 mov	 edx, DWORD PTR [ebx+12036]
  00582	52		 push	 edx
  00583	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OIIBACED@Message?5copy?5?$CFd?$AA@
  00588	6a 00		 push	 0
  0058a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0058f	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@RecvDataPa:

; 576  : 
; 577  : 	return true;

  00592	b8 01 00 00 00	 mov	 eax, 1
$LN34@RecvDataPa:

; 578  : }

  00597	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0059a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005a1	59		 pop	 ecx
  005a2	5f		 pop	 edi
  005a3	5e		 pop	 esi
  005a4	5b		 pop	 ebx
  005a5	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005a8	33 cd		 xor	 ecx, ebp
  005aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005af	8b e5		 mov	 esp, ebp
  005b1	5d		 pop	 ebp
  005b2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$0:
  00000	8d 8d 78 dc ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$155193[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$1:
  0000b	8d 8d 78 dc ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$155216[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$2:
  00016	8d 8d 78 dc ff
	ff		 lea	 ecx, DWORD PTR _ps$155223[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
__ehhandler$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 8a 60 dc ff
	ff		 mov	 ecx, DWORD PTR [edx-9120]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z ENDP		; RecvDataParse
PUBLIC	??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5erro@ ; `string'
PUBLIC	??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BP@LLCNDKPF@error?9L2?5?3?5Index?$CI?$CFd?$CJ?5?$CFx?5?$CFx?5?$CFx?5?$AA@ ; `string'
PUBLIC	?DataSend@@YAHHPAEK@Z				; DataSend
EXTRN	__imp__WSASend@28:PROC
EXTRN	?Encrypt@CSimpleModulus@@QAEHPAX0H@Z:PROC	; CSimpleModulus::Encrypt
EXTRN	?g_SimpleModulusSC@@3VCSimpleModulus@@A:BYTE	; g_SimpleModulusSC
EXTRN	?GetSendSerial@NSerialCheck@@QAEEXZ:PROC	; NSerialCheck::GetSendSerial
EXTRN	?gNSerialCheck@@3PAVNSerialCheck@@A:BYTE	; gNSerialCheck
;	COMDAT ??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5erro@
CONST	SEGMENT
??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5erro@ DB '('
	DB	'%d)WSASend(%d) failed with error [%x][%x] %d %s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@
CONST	SEGMENT
??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@ DB '('
	DB	'%d)error-L2 MAX BUFFER OVER %d %d [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@
CONST	SEGMENT
??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@ DB '('
	DB	'%d)error-L2 MAX BUFFER OVER %d %d %d [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd?$AA@ DB 'E'
	DB	'rror : Max msg(%d) %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LLCNDKPF@error?9L2?5?3?5Index?$CI?$CFd?$CJ?5?$CFx?5?$CFx?5?$CFx?5?$AA@
CONST	SEGMENT
??_C@_0BP@LLCNDKPF@error?9L2?5?3?5Index?$CI?$CFd?$CJ?5?$CFx?5?$CFx?5?$CFx?5?$AA@ DB 'e'
	DB	'rror-L2 : Index(%d) %x %x %x ', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DataSend@@YAHHPAEK@Z
_TEXT	SEGMENT
_SendBytes$ = -12					; size = 4
_lpPerSocketContext$ = -8				; size = 4
_SendBuf$ = -4						; size = 4
tv449 = 8						; size = 4
_aIndex$ = 8						; size = 4
_btsize$155250 = 11					; size = 1
_lpMsg$ = 12						; size = 4
_dwSize$ = 16						; size = 4
?DataSend@@YAHHPAEK@Z PROC				; DataSend, COMDAT

; 581  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 582  : 	DWORD SendBytes;
; 583  : 	LPPER_SOCKET_CONTEXT lpPerSocketContext;
; 584  : 	LPBYTE SendBuf;
; 585  : 	
; 586  : 
; 587  : 	if ( aIndex < OBJ_STARTUSERINDEX )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	81 fb 00 19 00
	00		 cmp	 ebx, 6400		; 00001900H
  00010	7d 0a		 jge	 SHORT $LN19@DataSend

; 588  : 	{
; 589  : 		return true;

  00012	b8 01 00 00 00	 mov	 eax, 1
  00017	5b		 pop	 ebx

; 736  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
$LN19@DataSend:

; 590  : 	}
; 591  : 
; 592  : 	EnterCriticalSection(&criti);

  0001c	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 593  : 
; 594  : 	if ( ((aIndex < 0)? FALSE : (aIndex > OBJMAX-1)? FALSE : TRUE )  == FALSE )

  00027	85 db		 test	 ebx, ebx
  00029	78 0f		 js	 SHORT $LN24@DataSend
  0002b	33 c0		 xor	 eax, eax
  0002d	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  00033	0f 9e c0	 setle	 al
  00036	85 c0		 test	 eax, eax
  00038	75 36		 jne	 SHORT $LN18@DataSend
$LN24@DataSend:

; 595  : 	{
; 596  : 		LogAdd(LOG_BLACK, "error-L2 : Index(%d) %x %x %x ", dwSize, lpMsg[0], lpMsg[1], lpMsg[2]);

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0003d	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00041	0f b6 50 01	 movzx	 edx, BYTE PTR [eax+1]
  00045	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00048	51		 push	 ecx
  00049	8b 4d 10	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  0004c	52		 push	 edx
  0004d	50		 push	 eax
  0004e	51		 push	 ecx
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@LLCNDKPF@error?9L2?5?3?5Index?$CI?$CFd?$CJ?5?$CFx?5?$CFx?5?$CFx?5?$AA@
  00054	6a 00		 push	 0
  00056	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0005b	83 c4 18	 add	 esp, 24			; 00000018H

; 597  : 		LeaveCriticalSection(&criti);

  0005e	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 598  : 		return false;

  00069	33 c0		 xor	 eax, eax
  0006b	5b		 pop	 ebx

; 736  : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
$LN18@DataSend:
  00070	56		 push	 esi

; 599  : 	}
; 600  : 
; 601  : 	if ( lpMsg[0] == 0xC3 || lpMsg[0] == 0xC4 )

  00071	8b 75 0c	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00074	8a 06		 mov	 al, BYTE PTR [esi]
  00076	57		 push	 edi
  00077	3c c3		 cmp	 al, 195			; 000000c3H
  00079	74 0f		 je	 SHORT $LN25@DataSend
  0007b	3c c4		 cmp	 al, 196			; 000000c4H
  0007d	74 64		 je	 SHORT $LN15@DataSend

; 628  : 		}
; 629  : 	}
; 630  : 	else
; 631  : 	{
; 632  : 		SendBuf = lpMsg;

  0007f	8b 7d 10	 mov	 edi, DWORD PTR _dwSize$[ebp]
  00082	89 75 fc	 mov	 DWORD PTR _SendBuf$[ebp], esi
  00085	e9 be 00 00 00	 jmp	 $LN14@DataSend
$LN25@DataSend:

; 602  : 	{
; 603  : 		int ret;
; 604  : 		BYTE btsize;
; 605  : 
; 606  : 		if ( lpMsg[0] == 0xC3 )
; 607  : 		{
; 608  : 			btsize = lpMsg[1];

  0008a	0f b6 56 01	 movzx	 edx, BYTE PTR [esi+1]
  0008e	46		 inc	 esi

; 609  : 			lpMsg[1]=gNSerialCheck[aIndex].GetSendSerial();

  0008f	8d 0c dd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[ebx*8]
  00096	88 55 0b	 mov	 BYTE PTR _btsize$155250[ebp], dl
  00099	e8 00 00 00 00	 call	 ?GetSendSerial@NSerialCheck@@QAEEXZ ; NSerialCheck::GetSendSerial
  0009e	88 06		 mov	 BYTE PTR [esi], al

; 610  : 			ret = g_SimpleModulusSC.Encrypt(&ExSendBuf[2], &lpMsg[1], dwSize-1);

  000a0	8b 45 10	 mov	 eax, DWORD PTR _dwSize$[ebp]
  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  000a9	48		 dec	 eax
  000aa	50		 push	 eax
  000ab	83 c1 02	 add	 ecx, 2
  000ae	56		 push	 esi
  000af	51		 push	 ecx
  000b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulusSC@@3VCSimpleModulus@@A ; g_SimpleModulusSC
  000b5	e8 00 00 00 00	 call	 ?Encrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Encrypt

; 611  : 			ExSendBuf[0] = 0xC3;

  000ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  000c0	c6 02 c3	 mov	 BYTE PTR [edx], 195	; 000000c3H

; 612  : 			ExSendBuf[1] = ret + 2;

  000c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  000c9	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  000cc	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 613  : 			SendBuf = ExSendBuf;
; 614  : 			dwSize = ret + 2;
; 615  : 			lpMsg[1] = btsize;

  000cf	0f b6 55 0b	 movzx	 edx, BYTE PTR _btsize$155250[ebp]
  000d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  000d9	89 4d fc	 mov	 DWORD PTR _SendBuf$[ebp], ecx
  000dc	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  000df	88 16		 mov	 BYTE PTR [esi], dl

; 616  : 		}
; 617  : 		else

  000e1	eb 65		 jmp	 SHORT $LN14@DataSend
$LN15@DataSend:

; 618  : 		{
; 619  : 			btsize = lpMsg[2];

  000e3	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  000e6	83 c6 02	 add	 esi, 2

; 620  : 			lpMsg[2] = gNSerialCheck[aIndex].GetSendSerial();

  000e9	8d 0c dd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[ebx*8]
  000f0	88 45 0b	 mov	 BYTE PTR _btsize$155250[ebp], al
  000f3	e8 00 00 00 00	 call	 ?GetSendSerial@NSerialCheck@@QAEEXZ ; NSerialCheck::GetSendSerial

; 621  : 			ret = g_SimpleModulusSC.Encrypt(&ExSendBuf[3], &lpMsg[2], dwSize-2);

  000f8	8b 4d 10	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  000fb	83 c1 fe	 add	 ecx, -2			; fffffffeH
  000fe	51		 push	 ecx
  000ff	88 06		 mov	 BYTE PTR [esi], al
  00101	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00107	56		 push	 esi
  00108	83 c2 03	 add	 edx, 3
  0010b	52		 push	 edx
  0010c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulusSC@@3VCSimpleModulus@@A ; g_SimpleModulusSC
  00111	e8 00 00 00 00	 call	 ?Encrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Encrypt

; 622  : 			ExSendBuf[0] = 0xC4;

  00116	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  0011c	c6 01 c4	 mov	 BYTE PTR [ecx], 196	; 000000c4H

; 623  : 			ExSendBuf[1] = SET_NUMBERH(ret +3 );

  0011f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00125	8d 78 03	 lea	 edi, DWORD PTR [eax+3]
  00128	8b d7		 mov	 edx, edi
  0012a	c1 ea 08	 shr	 edx, 8
  0012d	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 624  : 			ExSendBuf[2] = SET_NUMBERL(ret+3);

  00130	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf

; 625  : 			SendBuf = ExSendBuf;
; 626  : 			dwSize = ret + 3;
; 627  : 			lpMsg[2] = btsize;

  00136	8a 4d 0b	 mov	 cl, BYTE PTR _btsize$155250[ebp]
  00139	04 03		 add	 al, 3
  0013b	88 42 02	 mov	 BYTE PTR [edx+2], al
  0013e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00143	89 45 fc	 mov	 DWORD PTR _SendBuf$[ebp], eax
  00146	88 0e		 mov	 BYTE PTR [esi], cl
$LN14@DataSend:

; 633  : 	}
; 634  : 
; 635  : 	if ( gObj[aIndex].Connected < PLAYER_CONNECTED )

  00148	8b c3		 mov	 eax, ebx
  0014a	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00150	80 b8 04 00 00
	00 01		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 1
  00157	89 45 08	 mov	 DWORD PTR tv449[ebp], eax

; 636  : 	{
; 637  : 		LeaveCriticalSection(&criti);
; 638  : 		return FALSE;

  0015a	0f 82 3c 02 00
	00		 jb	 $LN31@DataSend

; 639  : 	}
; 640  : 
; 641  : 	lpPerSocketContext= gObj[aIndex].PerSocketContext;

  00160	8b b0 0c 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+12]
  00166	89 75 f8	 mov	 DWORD PTR _lpPerSocketContext$[ebp], esi

; 642  : 
; 643  : 	if ( dwSize > sizeof(lpPerSocketContext->IOContext[0].Buffer))

  00169	81 ff 70 17 00
	00		 cmp	 edi, 6000		; 00001770H
  0016f	76 34		 jbe	 SHORT $LN11@DataSend

; 644  : 	{
; 645  : 		LogAdd(LOG_BLACK, "Error : Max msg(%d) %s %d", dwSize, __FILE__, __LINE__);

  00171	68 85 02 00 00	 push	 645			; 00000285H
  00176	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  0017b	57		 push	 edi
  0017c	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd?$AA@
  00181	6a 00		 push	 0
  00183	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 646  : 		CloseClient(aIndex);

  00188	53		 push	 ebx
  00189	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0018e	83 c4 18	 add	 esp, 24			; 00000018H

; 647  : 		LeaveCriticalSection(&criti);

  00191	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0019c	5f		 pop	 edi
  0019d	5e		 pop	 esi

; 648  : 		return false;

  0019e	33 c0		 xor	 eax, eax
  001a0	5b		 pop	 ebx

; 736  : }

  001a1	8b e5		 mov	 esp, ebp
  001a3	5d		 pop	 ebp
  001a4	c3		 ret	 0
$LN11@DataSend:

; 649  : 	}
; 650  : 
; 651  : 	LPPER_IO_CONTEXT	lpIoCtxt = (LPPER_IO_CONTEXT)&lpPerSocketContext->IOContext[1];
; 652  : 
; 653  : 	if ( lpIoCtxt->nWaitIO > 0 )
; 654  : 	{
; 655  : 		if ( ( lpIoCtxt->nSecondOfs + dwSize ) > MAX_IO_BUFFER_SIZE-1 )

  001a5	8b 8e 14 5e 00
	00		 mov	 ecx, DWORD PTR [esi+24084]
  001ab	81 c6 18 2f 00
	00		 add	 esi, 12056		; 00002f18H
  001b1	83 be 0c 2f 00
	00 00		 cmp	 DWORD PTR [esi+12044], 0
  001b8	7e 67		 jle	 SHORT $LN10@DataSend
  001ba	8d 14 39	 lea	 edx, DWORD PTR [ecx+edi]
  001bd	81 fa 6f 17 00
	00		 cmp	 edx, 5999		; 0000176fH
  001c3	76 3c		 jbe	 SHORT $LN9@DataSend

; 656  : 		{
; 657  : 			LogAdd(LOG_BLACK, "(%d)error-L2 MAX BUFFER OVER %d %d %d [%s][%s]", 
; 658  : 				aIndex, lpIoCtxt->nTotalBytes, lpIoCtxt->nSecondOfs, 
; 659  : 				dwSize, gObj[aIndex].AccountID, gObj[aIndex].Name);

  001c5	8d 90 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  001cb	52		 push	 edx
  001cc	8d 80 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  001d2	50		 push	 eax
  001d3	57		 push	 edi
  001d4	51		 push	 ecx
  001d5	8b 8e 00 2f 00
	00		 mov	 ecx, DWORD PTR [esi+12032]
  001db	51		 push	 ecx
  001dc	53		 push	 ebx
  001dd	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@
  001e2	6a 00		 push	 0
  001e4	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 660  : 
; 661  : 			lpIoCtxt->nWaitIO = 0;
; 662  : 			CloseClient(aIndex);

  001e9	53		 push	 ebx
  001ea	c7 86 0c 2f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+12044], 0
  001f4	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  001f9	83 c4 24	 add	 esp, 36			; 00000024H

; 663  : 			LeaveCriticalSection(&criti);
; 664  : 			return true;

  001fc	e9 c2 01 00 00	 jmp	 $LN29@DataSend
$LN9@DataSend:

; 665  : 		}
; 666  : 
; 667  : 		memcpy( &lpIoCtxt->BufferSecond[lpIoCtxt->nSecondOfs], SendBuf, dwSize);

  00201	8b 55 fc	 mov	 edx, DWORD PTR _SendBuf$[ebp]
  00204	57		 push	 edi
  00205	52		 push	 edx
  00206	8d 84 31 8c 17
	00 00		 lea	 eax, DWORD PTR [ecx+esi+6028]
  0020d	50		 push	 eax
  0020e	e8 00 00 00 00	 call	 _memcpy
  00213	83 c4 0c	 add	 esp, 12			; 0000000cH

; 668  : 		lpIoCtxt->nSecondOfs += dwSize;

  00216	01 be fc 2e 00
	00		 add	 DWORD PTR [esi+12028], edi

; 669  : 		LeaveCriticalSection(&criti);
; 670  : 		return true;

  0021c	e9 a2 01 00 00	 jmp	 $LN29@DataSend
$LN10@DataSend:

; 671  : 	}
; 672  : 
; 673  : 	lpIoCtxt->nTotalBytes = 0;

  00221	c7 86 00 2f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+12032], 0

; 674  : 	
; 675  : 	if ( lpIoCtxt->nSecondOfs > 0 )

  0022b	85 c9		 test	 ecx, ecx
  0022d	7e 2d		 jle	 SHORT $LN8@DataSend

; 676  : 	{
; 677  : 		memcpy(lpIoCtxt->Buffer, lpIoCtxt->BufferSecond, lpIoCtxt->nSecondOfs);

  0022f	51		 push	 ecx
  00230	8d 8e 8c 17 00
	00		 lea	 ecx, DWORD PTR [esi+6028]
  00236	51		 push	 ecx
  00237	8d 56 1c	 lea	 edx, DWORD PTR [esi+28]
  0023a	52		 push	 edx
  0023b	e8 00 00 00 00	 call	 _memcpy

; 678  : 		lpIoCtxt->nTotalBytes = lpIoCtxt->nSecondOfs;

  00240	8b 86 fc 2e 00
	00		 mov	 eax, DWORD PTR [esi+12028]
  00246	89 86 00 2f 00
	00		 mov	 DWORD PTR [esi+12032], eax

; 679  : 		lpIoCtxt->nSecondOfs = 0;

  0024c	8b 45 08	 mov	 eax, DWORD PTR tv449[ebp]
  0024f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00252	c7 86 fc 2e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+12028], 0
$LN8@DataSend:

; 680  : 	}
; 681  : 
; 682  : 	if ( (lpIoCtxt->nTotalBytes+dwSize) > MAX_IO_BUFFER_SIZE-1 )

  0025c	8b 8e 00 2f 00
	00		 mov	 ecx, DWORD PTR [esi+12032]
  00262	8d 14 39	 lea	 edx, DWORD PTR [ecx+edi]
  00265	81 fa 6f 17 00
	00		 cmp	 edx, 5999		; 0000176fH
  0026b	76 44		 jbe	 SHORT $LN7@DataSend

; 683  : 	{
; 684  : 		LogAdd(LOG_BLACK, "(%d)error-L2 MAX BUFFER OVER %d %d [%s][%s]", 
; 685  : 			aIndex, lpIoCtxt->nTotalBytes, dwSize, 
; 686  : 			gObj[aIndex].AccountID, gObj[aIndex].Name);

  0026d	8d 90 6f 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  00273	52		 push	 edx
  00274	8d 80 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  0027a	50		 push	 eax
  0027b	57		 push	 edi
  0027c	51		 push	 ecx
  0027d	53		 push	 ebx
  0027e	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@
  00283	6a 00		 push	 0
  00285	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 687  : 
; 688  : 		lpIoCtxt->nWaitIO = 0;
; 689  : 		CloseClient(aIndex);

  0028a	53		 push	 ebx
  0028b	c7 86 0c 2f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+12044], 0
  00295	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0029a	83 c4 20	 add	 esp, 32			; 00000020H

; 690  : 		LeaveCriticalSection(&criti);

  0029d	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  002a8	5f		 pop	 edi
  002a9	5e		 pop	 esi

; 691  : 		return FALSE;

  002aa	33 c0		 xor	 eax, eax
  002ac	5b		 pop	 ebx

; 736  : }

  002ad	8b e5		 mov	 esp, ebp
  002af	5d		 pop	 ebp
  002b0	c3		 ret	 0
$LN7@DataSend:

; 692  : 	}
; 693  : 
; 694  : 	memcpy( &lpIoCtxt->Buffer[lpIoCtxt->nTotalBytes], SendBuf, dwSize);

  002b1	8b 55 fc	 mov	 edx, DWORD PTR _SendBuf$[ebp]
  002b4	57		 push	 edi
  002b5	52		 push	 edx
  002b6	8d 44 31 1c	 lea	 eax, DWORD PTR [ecx+esi+28]
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 _memcpy

; 695  : 	lpIoCtxt->nTotalBytes += dwSize;

  002c0	01 be 00 2f 00
	00		 add	 DWORD PTR [esi+12032], edi
  002c6	8b 8e 00 2f 00
	00		 mov	 ecx, DWORD PTR [esi+12032]

; 696  : 	lpIoCtxt->wsabuf.buf = (char*)&lpIoCtxt->Buffer;
; 697  : 	lpIoCtxt->wsabuf.len = lpIoCtxt->nTotalBytes;
; 698  : 	lpIoCtxt->nSentBytes = 0;
; 699  : 	lpIoCtxt->IOOperation = SEND_IO;
; 700  : 	
; 701  : 
; 702  : 	if ( WSASend( gObj[aIndex].m_socket, &lpIoCtxt->wsabuf , 1, &SendBytes, 0, &lpIoCtxt->Overlapped, NULL) == -1 )

  002cc	8b 7d 08	 mov	 edi, DWORD PTR tv449[ebp]
  002cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d2	6a 00		 push	 0
  002d4	56		 push	 esi
  002d5	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  002d8	6a 00		 push	 0
  002da	89 08		 mov	 DWORD PTR [eax], ecx
  002dc	8d 4d f4	 lea	 ecx, DWORD PTR _SendBytes$[ebp]
  002df	51		 push	 ecx
  002e0	8d 56 1c	 lea	 edx, DWORD PTR [esi+28]
  002e3	6a 01		 push	 1
  002e5	89 56 18	 mov	 DWORD PTR [esi+24], edx
  002e8	c7 86 04 2f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+12036], 0
  002f2	c7 86 08 2f 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+12040], 1
  002fc	8b 97 10 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+16]
  00302	50		 push	 eax
  00303	52		 push	 edx
  00304	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  0030a	83 f8 ff	 cmp	 eax, -1
  0030d	0f 85 9d 00 00
	00		 jne	 $LN6@DataSend

; 703  : 	{
; 704  : 
; 705  : 		if ( WSAGetLastError() != WSA_IO_PENDING )	

  00313	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00319	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  0031e	0f 84 95 00 00
	00		 je	 $LN26@DataSend

; 706  : 		{
; 707  : 			lpIoCtxt->nWaitIO = 0;
; 708  : 			
; 709  : 
; 710  : 			if ( lpIoCtxt->wsabuf.buf[0] == 0xC1 )

  00324	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00327	c7 86 0c 2f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+12044], 0
  00331	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00334	3d c1 00 00 00	 cmp	 eax, 193		; 000000c1H
  00339	75 22		 jne	 SHORT $LN4@DataSend

; 711  : 			{
; 712  : 				LogAdd(LOG_BLACK, "(%d)WSASend(%d) failed with error [%x][%x] %d %s ", 
; 713  : 					__LINE__, aIndex, (BYTE)lpIoCtxt->wsabuf.buf[0],
; 714  : 					(BYTE)lpIoCtxt->wsabuf.buf[2], WSAGetLastError(), gObj[aIndex].Ip_addr);

  0033b	8b 76 18	 mov	 esi, DWORD PTR [esi+24]
  0033e	8d 8f 14 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+20]
  00344	51		 push	 ecx
  00345	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0034b	0f b6 56 02	 movzx	 edx, BYTE PTR [esi+2]
  0034f	50		 push	 eax
  00350	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00353	52		 push	 edx
  00354	50		 push	 eax
  00355	53		 push	 ebx
  00356	68 c9 02 00 00	 push	 713			; 000002c9H
  0035b	eb 27		 jmp	 SHORT $LN30@DataSend
$LN4@DataSend:

; 715  : 			}
; 716  : 			else if ( lpIoCtxt->wsabuf.buf[0] == 0xC2 )

  0035d	3d c2 00 00 00	 cmp	 eax, 194		; 000000c2H
  00362	75 2f		 jne	 SHORT $LN2@DataSend

; 717  : 			{
; 718  : 				LogAdd(LOG_BLACK, "(%d)WSASend(%d) failed with error [%x][%x] %d %s ", 
; 719  : 					__LINE__, aIndex, (BYTE)lpIoCtxt->wsabuf.buf[0],
; 720  : 					(BYTE)lpIoCtxt->wsabuf.buf[3], WSAGetLastError(), gObj[aIndex].Ip_addr);

  00364	8b 76 18	 mov	 esi, DWORD PTR [esi+24]
  00367	8d 8f 14 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+20]
  0036d	51		 push	 ecx
  0036e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00374	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  00378	50		 push	 eax
  00379	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0037c	52		 push	 edx
  0037d	50		 push	 eax
  0037e	53		 push	 ebx
  0037f	68 cf 02 00 00	 push	 719			; 000002cfH
$LN30@DataSend:
  00384	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5erro@
  00389	6a 00		 push	 0
  0038b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00390	83 c4 20	 add	 esp, 32			; 00000020H
$LN2@DataSend:

; 721  : 			}
; 722  : 			CloseClient(aIndex);

  00393	53		 push	 ebx
  00394	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00399	83 c4 04	 add	 esp, 4
$LN31@DataSend:

; 723  : 			LeaveCriticalSection(&criti);

  0039c	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  003a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  003a7	5f		 pop	 edi
  003a8	5e		 pop	 esi

; 724  : 			return false;

  003a9	33 c0		 xor	 eax, eax
  003ab	5b		 pop	 ebx

; 736  : }

  003ac	8b e5		 mov	 esp, ebp
  003ae	5d		 pop	 ebp
  003af	c3		 ret	 0
$LN6@DataSend:

; 725  : 		}
; 726  : 	}
; 727  : 	else
; 728  : 	{
; 729  : 		lpPerSocketContext->dwIOCount ++;

  003b0	8b 45 f8	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  003b3	ff 80 28 5e 00
	00		 inc	 DWORD PTR [eax+24104]
$LN26@DataSend:

; 730  : 	}
; 731  : 	
; 732  : 	
; 733  : 	lpIoCtxt->nWaitIO = 1;

  003b9	c7 86 0c 2f 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+12044], 1
$LN29@DataSend:

; 734  : 	LeaveCriticalSection(&criti);

  003c3	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  003c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  003ce	5f		 pop	 edi
  003cf	5e		 pop	 esi

; 735  : 	return true;

  003d0	b8 01 00 00 00	 mov	 eax, 1
  003d5	5b		 pop	 ebx

; 736  : }

  003d6	8b e5		 mov	 esp, ebp
  003d8	5d		 pop	 ebp
  003d9	c3		 ret	 0
?DataSend@@YAHHPAEK@Z ENDP				; DataSend
_TEXT	ENDS
PUBLIC	??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@ ; `string'
PUBLIC	?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z	; IoSendSecond
;	COMDAT ??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@
CONST	SEGMENT
??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@ DB 'W'
	DB	'SASend(%d) failed with error %d %s ', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z
_TEXT	SEGMENT
_SendBytes$ = -4					; size = 4
_lpPerSocketContext$ = 8				; size = 4
?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z PROC	; IoSendSecond, COMDAT

; 743  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 744  : 	DWORD SendBytes;
; 745  : 	int aIndex;
; 746  : 	EnterCriticalSection(&criti);

  00006	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 747  : 	aIndex = lpPerSocketContext->nIndex;

  00011	8b 75 08	 mov	 esi, DWORD PTR _lpPerSocketContext$[ebp]
  00014	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]

; 748  : 	LPPER_IO_CONTEXT	lpIoCtxt = (LPPER_IO_CONTEXT)&lpPerSocketContext->IOContext[1];

  00017	81 c6 18 2f 00
	00		 add	 esi, 12056		; 00002f18H

; 749  : 
; 750  : 	if ( lpIoCtxt->nWaitIO > 0 )

  0001d	83 be 0c 2f 00
	00 00		 cmp	 DWORD PTR [esi+12044], 0
  00024	7e 13		 jle	 SHORT $LN6@IoSendSeco
$LN5@IoSendSeco:

; 751  : 	{
; 752  : 		LeaveCriticalSection(&criti);

  00026	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00031	5e		 pop	 esi

; 753  : 		return false;

  00032	33 c0		 xor	 eax, eax
  00034	5b		 pop	 ebx

; 793  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN6@IoSendSeco:

; 754  : 	}
; 755  : 
; 756  : 	lpIoCtxt->nTotalBytes = 0;
; 757  : 	if ( lpIoCtxt->nSecondOfs > 0 )

  00039	8b 86 fc 2e 00
	00		 mov	 eax, DWORD PTR [esi+12028]
  0003f	c7 86 00 2f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+12032], 0
  00049	85 c0		 test	 eax, eax
  0004b	7e d9		 jle	 SHORT $LN5@IoSendSeco

; 758  : 	{
; 759  : 		memcpy(lpIoCtxt->Buffer, lpIoCtxt->BufferSecond, lpIoCtxt->nSecondOfs);

  0004d	57		 push	 edi
  0004e	50		 push	 eax
  0004f	8d 86 8c 17 00
	00		 lea	 eax, DWORD PTR [esi+6028]
  00055	50		 push	 eax
  00056	8d 7e 1c	 lea	 edi, DWORD PTR [esi+28]
  00059	57		 push	 edi
  0005a	e8 00 00 00 00	 call	 _memcpy

; 760  : 		lpIoCtxt->nTotalBytes = lpIoCtxt->nSecondOfs;

  0005f	8b 8e fc 2e 00
	00		 mov	 ecx, DWORD PTR [esi+12028]
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	89 8e 00 2f 00
	00		 mov	 DWORD PTR [esi+12032], ecx

; 761  : 		lpIoCtxt->nSecondOfs = 0;
; 762  : 	}
; 763  : 	else
; 764  : 	{
; 765  : 		LeaveCriticalSection(&criti);
; 766  : 		return false;
; 767  : 	}
; 768  : 
; 769  : 	lpIoCtxt->wsabuf.buf = (char*)&lpIoCtxt->Buffer;
; 770  : 	lpIoCtxt->wsabuf.len = lpIoCtxt->nTotalBytes;

  0006e	8b 96 00 2f 00
	00		 mov	 edx, DWORD PTR [esi+12032]
  00074	33 c9		 xor	 ecx, ecx

; 771  : 	lpIoCtxt->nSentBytes = 0;
; 772  : 	lpIoCtxt->IOOperation = SEND_IO;
; 773  : 
; 774  : 	if ( WSASend(gObj[aIndex].m_socket, &lpIoCtxt->wsabuf, 1, &SendBytes, 0, &lpIoCtxt->Overlapped, NULL) == -1 )

  00076	51		 push	 ecx
  00077	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0007a	56		 push	 esi
  0007b	8b fb		 mov	 edi, ebx
  0007d	51		 push	 ecx
  0007e	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00084	89 8e fc 2e 00
	00		 mov	 DWORD PTR [esi+12028], ecx
  0008a	89 8e 04 2f 00
	00		 mov	 DWORD PTR [esi+12036], ecx
  00090	8d 4d fc	 lea	 ecx, DWORD PTR _SendBytes$[ebp]
  00093	51		 push	 ecx
  00094	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00097	6a 01		 push	 1
  00099	89 10		 mov	 DWORD PTR [eax], edx
  0009b	c7 86 08 2f 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+12040], 1
  000a5	8b 97 10 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+16]
  000ab	50		 push	 eax
  000ac	52		 push	 edx
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  000b3	83 f8 ff	 cmp	 eax, -1
  000b6	75 49		 jne	 SHORT $LN3@IoSendSeco

; 775  : 	{
; 776  : 		if ( WSAGetLastError() != WSA_IO_PENDING )

  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000be	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  000c3	74 45		 je	 SHORT $LN9@IoSendSeco

; 777  : 		{
; 778  : 			LogAdd(LOG_BLACK, "WSASend(%d) failed with error %d %s ", __LINE__, WSAGetLastError(), gObj[aIndex].Ip_addr);

  000c5	8d 87 14 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+20]
  000cb	50		 push	 eax
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000d2	50		 push	 eax
  000d3	68 0a 03 00 00	 push	 778			; 0000030aH
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@
  000dd	6a 00		 push	 0
  000df	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 779  : 			CloseClient(aIndex);

  000e4	53		 push	 ebx
  000e5	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000ea	83 c4 18	 add	 esp, 24			; 00000018H

; 780  : 			LeaveCriticalSection(&criti);

  000ed	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi

; 781  : 			return false;

  000fa	33 c0		 xor	 eax, eax
  000fc	5b		 pop	 ebx

; 793  : }

  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c3		 ret	 0
$LN3@IoSendSeco:

; 782  : 		}
; 783  : 	}
; 784  : 	else
; 785  : 	{
; 786  : 		lpPerSocketContext->dwIOCount ++;

  00101	8b 45 08	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00104	ff 80 28 5e 00
	00		 inc	 DWORD PTR [eax+24104]
$LN9@IoSendSeco:

; 787  : 	}
; 788  : 	
; 789  : 	lpIoCtxt->nWaitIO = 1;
; 790  : 	LeaveCriticalSection(&criti);

  0010a	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0010f	c7 86 0c 2f 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+12044], 1
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi

; 791  : 	
; 792  : 	return true;

  00121	b8 01 00 00 00	 mov	 eax, 1
  00126	5b		 pop	 ebx

; 793  : }

  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ENDP	; IoSendSecond
_TEXT	ENDS
PUBLIC	?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z	; IoMoreSend
; Function compile flags: /Ogtp
;	COMDAT ?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z
_TEXT	SEGMENT
_SendBytes$ = -4					; size = 4
_lpPerSocketContext$ = 8				; size = 4
?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z PROC		; IoMoreSend, COMDAT

; 797  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 798  : 	DWORD SendBytes;
; 799  : 	int aIndex;
; 800  : 	
; 801  : 	EnterCriticalSection(&criti);

  00006	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 802  : 	aIndex = lpPerSocketContext->nIndex;

  00011	8b 75 08	 mov	 esi, DWORD PTR _lpPerSocketContext$[ebp]
  00014	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]

; 803  : 	LPPER_IO_CONTEXT	lpIoCtxt = (LPPER_IO_CONTEXT)&lpPerSocketContext->IOContext[1];
; 804  : 
; 805  : 	if ( (lpIoCtxt->nTotalBytes - lpIoCtxt->nSentBytes) < 0 )

  00017	8b 86 1c 5e 00
	00		 mov	 eax, DWORD PTR [esi+24092]
  0001d	8b 8e 18 5e 00
	00		 mov	 ecx, DWORD PTR [esi+24088]
  00023	81 c6 18 2f 00
	00		 add	 esi, 12056		; 00002f18H
  00029	2b c8		 sub	 ecx, eax
  0002b	79 13		 jns	 SHORT $LN4@IoMoreSend

; 806  : 	{
; 807  : 		LeaveCriticalSection(&criti);

  0002d	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00038	5e		 pop	 esi

; 808  : 		return false;

  00039	33 c0		 xor	 eax, eax
  0003b	5b		 pop	 ebx

; 834  : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN4@IoMoreSend:
  00040	57		 push	 edi

; 809  : 	}
; 810  : 
; 811  : 	lpIoCtxt->wsabuf.buf = (char*)&lpIoCtxt->Buffer[lpIoCtxt->nSentBytes];
; 812  : 	lpIoCtxt->wsabuf.len = lpIoCtxt->nTotalBytes - lpIoCtxt->nSentBytes;
; 813  : 	lpIoCtxt->IOOperation = SEND_IO;
; 814  : 
; 815  : 	if ( WSASend(gObj[aIndex].m_socket, &lpIoCtxt->wsabuf, 1, &SendBytes, 0, &lpIoCtxt->Overlapped, NULL) == -1 )

  00041	6a 00		 push	 0
  00043	8d 44 30 1c	 lea	 eax, DWORD PTR [eax+esi+28]
  00047	8b fb		 mov	 edi, ebx
  00049	56		 push	 esi
  0004a	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00050	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00053	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00056	6a 00		 push	 0
  00058	89 08		 mov	 DWORD PTR [eax], ecx
  0005a	8d 4d fc	 lea	 ecx, DWORD PTR _SendBytes$[ebp]
  0005d	51		 push	 ecx
  0005e	6a 01		 push	 1
  00060	c7 86 08 2f 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+12040], 1
  0006a	8b 97 10 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+16]
  00070	50		 push	 eax
  00071	52		 push	 edx
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  00078	83 f8 ff	 cmp	 eax, -1
  0007b	75 49		 jne	 SHORT $LN3@IoMoreSend

; 816  : 	{
; 817  : 		if ( WSAGetLastError() != WSA_IO_PENDING )

  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00083	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  00088	74 45		 je	 SHORT $LN7@IoMoreSend

; 818  : 		{
; 819  : 			LogAdd(LOG_BLACK, "WSASend(%d) failed with error %d %s ", __LINE__, WSAGetLastError(), gObj[aIndex].Ip_addr);

  0008a	8d 87 14 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+20]
  00090	50		 push	 eax
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00097	50		 push	 eax
  00098	68 33 03 00 00	 push	 819			; 00000333H
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@
  000a2	6a 00		 push	 0
  000a4	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 820  : 			CloseClient(aIndex);

  000a9	53		 push	 ebx
  000aa	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000af	83 c4 18	 add	 esp, 24			; 00000018H

; 821  : 			LeaveCriticalSection(&criti);

  000b2	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi

; 822  : 			return false;

  000bf	33 c0		 xor	 eax, eax
  000c1	5b		 pop	 ebx

; 834  : }

  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
$LN3@IoMoreSend:

; 823  : 		}
; 824  : 	}
; 825  : 	else
; 826  : 	{
; 827  : 		lpPerSocketContext->dwIOCount ++;

  000c6	8b 45 08	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  000c9	ff 80 28 5e 00
	00		 inc	 DWORD PTR [eax+24104]
$LN7@IoMoreSend:

; 828  : 	}
; 829  : 	
; 830  : 	
; 831  : 	lpIoCtxt->nWaitIO = 1;
; 832  : 	LeaveCriticalSection(&criti);

  000cf	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000d4	c7 86 0c 2f 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+12044], 1
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi

; 833  : 	return true;

  000e6	b8 01 00 00 00	 mov	 eax, 1
  000eb	5b		 pop	 ebx

; 834  : }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ENDP		; IoMoreSend
_TEXT	ENDS
PUBLIC	??_C@_0CO@KIOKACIH@Error?5Thread?5?3?5GetQueueCompletio@ ; `string'
PUBLIC	??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CG@MJPNHJDJ@error?9L1?5?3?5Socket?5Header?5error?5?$CF@ ; `string'
PUBLIC	??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?50@ ; `string'
PUBLIC	?ServerWorkerThread@@YGKPAX@Z			; ServerWorkerThread
EXTRN	__imp__WSARecv@28:PROC
EXTRN	__imp__GetQueuedCompletionStatus@20:PROC
;	COMDAT ??_C@_0CO@KIOKACIH@Error?5Thread?5?3?5GetQueueCompletio@
CONST	SEGMENT
??_C@_0CO@KIOKACIH@Error?5Thread?5?3?5GetQueueCompletio@ DB 'Error Thread'
	DB	' : GetQueueCompletionStatus( %d )', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@ DB 'W'
	DB	'SARecv() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MJPNHJDJ@error?9L1?5?3?5Socket?5Header?5error?5?$CF@
CONST	SEGMENT
??_C@_0CG@MJPNHJDJ@error?9L1?5?3?5Socket?5Header?5error?5?$CF@ DB 'error-'
	DB	'L1 : Socket Header error %d, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?50@ DB 'Conne'
	DB	'ction Closed, dwIoSize == 0 (Index:%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ServerWorkerThread@@YGKPAX@Z
_TEXT	SEGMENT
_RecvBytes$ = -24					; size = 4
_Flags$ = -20						; size = 4
tv303 = -16						; size = 4
_dwIoSize$ = -12					; size = 4
_ClientIndex$ = -8					; size = 4
_lpOverlapped$ = -4					; size = 4
_CompletionPortID$ = 8					; size = 4
?ServerWorkerThread@@YGKPAX@Z PROC			; ServerWorkerThread, COMDAT

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 242  : 	HANDLE	CompletionPort = (HANDLE) CompletionPortID;
; 243  : 	DWORD	dwIoSize;
; 244  : 	DWORD	RecvBytes;
; 245  : 	DWORD	Flags;
; 246  : 	DWORD	dwSendNumBytes = 0;
; 247  : 	BOOL	bSuccess = FALSE; 
; 248  : 	int		nRet;
; 249  : 	int     ClientIndex;
; 250  : 
; 251  : 	LPPER_SOCKET_CONTEXT	lpPerSocketContext = NULL;
; 252  : 	LPOVERLAPPED			lpOverlapped = NULL; 

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lpOverlapped$[ebp], 0
  0000f	57		 push	 edi
$LL15@ServerWork:

; 253  : 	LPPER_IO_CONTEXT		lpIOContext = NULL;
; 254  : 	
; 255  : 	while(TRUE)
; 256  : 	{
; 257  : 		bSuccess = GetQueuedCompletionStatus(
; 258  : 			CompletionPort,
; 259  : 			&dwIoSize,
; 260  : 			(LPDWORD)&ClientIndex,
; 261  : 			&lpOverlapped,
; 262  : 			INFINITE
; 263  : 		);

  00010	6a ff		 push	 -1
  00012	8d 45 fc	 lea	 eax, DWORD PTR _lpOverlapped$[ebp]
  00015	50		 push	 eax
  00016	8b 45 08	 mov	 eax, DWORD PTR _CompletionPortID$[ebp]
  00019	8d 4d f8	 lea	 ecx, DWORD PTR _ClientIndex$[ebp]
  0001c	51		 push	 ecx
  0001d	8d 55 f4	 lea	 edx, DWORD PTR _dwIoSize$[ebp]
  00020	52		 push	 edx
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetQueuedCompletionStatus@20

; 264  : 
; 265  : 		if( !bSuccess )

  00028	85 c0		 test	 eax, eax
  0002a	75 24		 jne	 SHORT $LN26@ServerWork

; 266  : 		{
; 267  : 			if( lpOverlapped != NULL )

  0002c	39 45 fc	 cmp	 DWORD PTR _lpOverlapped$[ebp], eax
  0002f	74 1f		 je	 SHORT $LN26@ServerWork

; 268  : 			{
; 269  : 				int aError = GetLastError();

  00031	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetLastError@0
  00037	ff d6		 call	 esi

; 270  : 				if ( (aError != ERROR_NETNAME_DELETED) && (aError != ERROR_CONNECTION_ABORTED) && (aError != ERROR_OPERATION_ABORTED) )

  00039	83 f8 40	 cmp	 eax, 64			; 00000040H
  0003c	74 12		 je	 SHORT $LN26@ServerWork
  0003e	3d d4 04 00 00	 cmp	 eax, 1236		; 000004d4H
  00043	74 0b		 je	 SHORT $LN26@ServerWork
  00045	3d e3 03 00 00	 cmp	 eax, 995		; 000003e3H
  0004a	0f 85 c7 01 00
	00		 jne	 $LN24@ServerWork
$LN26@ServerWork:

; 276  : 				}
; 277  : 			}
; 278  : 		}
; 279  : 
; 280  : 		EnterCriticalSection(&criti);

  00050	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 281  : 		lpPerSocketContext = gObj[ClientIndex].PerSocketContext;

  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _ClientIndex$[ebp]
  0005e	69 c9 64 15 00
	00		 imul	 ecx, 5476		; 00001564H
  00064	8b b9 0c 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ecx+12]

; 282  : 		
; 283  : 		lpPerSocketContext->dwIOCount--;

  0006a	ff 8f 28 5e 00
	00		 dec	 DWORD PTR [edi+24104]

; 284  : 		if( dwIoSize == 0 )

  00070	8b 4d f4	 mov	 ecx, DWORD PTR _dwIoSize$[ebp]
  00073	33 db		 xor	 ebx, ebx
  00075	3b cb		 cmp	 ecx, ebx
  00077	75 29		 jne	 SHORT $LN10@ServerWork

; 285  : 		{
; 286  : 			LogAdd(LOG_BLACK, "Connection Closed, dwIoSize == 0 (Index:%d)", lpPerSocketContext->nIndex);

  00079	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007c	52		 push	 edx
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?50@
  00082	53		 push	 ebx
  00083	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 287  : 			CloseClient(lpPerSocketContext, 0);

  00088	53		 push	 ebx
  00089	57		 push	 edi
  0008a	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  0008f	83 c4 14	 add	 esp, 20			; 00000014H

; 288  : 			LeaveCriticalSection(&criti);

  00092	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 289  : 			continue;

  0009d	e9 6e ff ff ff	 jmp	 $LL15@ServerWork
$LN10@ServerWork:

; 290  : 		}
; 291  : 
; 292  : 		lpIOContext = (LPPER_IO_CONTEXT)lpOverlapped;

  000a2	8b 75 fc	 mov	 esi, DWORD PTR _lpOverlapped$[ebp]

; 293  : 
; 294  : 		if( lpIOContext == NULL ) continue;

  000a5	3b f3		 cmp	 esi, ebx
  000a7	0f 84 63 ff ff
	ff		 je	 $LL15@ServerWork

; 295  : 		if( lpIOContext->IOOperation == SEND_IO )

  000ad	8d 86 08 2f 00
	00		 lea	 eax, DWORD PTR [esi+12040]
  000b3	89 45 f0	 mov	 DWORD PTR tv303[ebp], eax
  000b6	8b 00		 mov	 eax, DWORD PTR [eax]
  000b8	83 f8 01	 cmp	 eax, 1
  000bb	75 58		 jne	 SHORT $LN8@ServerWork

; 296  : 		{
; 297  : 			lpIOContext->nSentBytes += dwIoSize;

  000bd	01 8e 04 2f 00
	00		 add	 DWORD PTR [esi+12036], ecx

; 298  : 
; 299  : 			if( lpIOContext->nSentBytes >= lpIOContext->nTotalBytes )

  000c3	8b 86 04 2f 00
	00		 mov	 eax, DWORD PTR [esi+12036]
  000c9	3b 86 00 2f 00
	00		 cmp	 eax, DWORD PTR [esi+12032]
  000cf	7c 2b		 jl	 SHORT $LN7@ServerWork

; 300  : 			{
; 301  : 				lpIOContext->nWaitIO = 0;

  000d1	89 9e 0c 2f 00
	00		 mov	 DWORD PTR [esi+12044], ebx

; 302  : 				if( lpIOContext->nSecondOfs > 0 )

  000d7	39 9e fc 2e 00
	00		 cmp	 DWORD PTR [esi+12028], ebx
  000dd	0f 8e 24 01 00
	00		 jle	 $LN3@ServerWork

; 303  : 				{
; 304  : 					IoSendSecond(lpPerSocketContext);

  000e3	57		 push	 edi
  000e4	e8 00 00 00 00	 call	 ?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ; IoSendSecond
  000e9	83 c4 04	 add	 esp, 4

; 348  : 		}
; 349  : 		LeaveCriticalSection(&criti);

  000ec	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 350  : 	}

  000f7	e9 14 ff ff ff	 jmp	 $LL15@ServerWork
$LN7@ServerWork:

; 305  : 				}
; 306  : 			}
; 307  : 			else
; 308  : 			{
; 309  : 				IoMoreSend(lpPerSocketContext);

  000fc	57		 push	 edi
  000fd	e8 00 00 00 00	 call	 ?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ; IoMoreSend
  00102	83 c4 04	 add	 esp, 4

; 348  : 		}
; 349  : 		LeaveCriticalSection(&criti);

  00105	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 350  : 	}

  00110	e9 fb fe ff ff	 jmp	 $LL15@ServerWork
$LN8@ServerWork:

; 310  : 			}
; 311  : 		}
; 312  : 		else if( lpIOContext->IOOperation == RECV_IO )

  00115	3b c3		 cmp	 eax, ebx
  00117	0f 85 ea 00 00
	00		 jne	 $LN3@ServerWork

; 313  : 		{
; 314  : 			RecvBytes = 0;

  0011d	89 5d e8	 mov	 DWORD PTR _RecvBytes$[ebp], ebx

; 315  : 
; 316  : 			lpIOContext->nSentBytes += dwIoSize;

  00120	01 8e 04 2f 00
	00		 add	 DWORD PTR [esi+12036], ecx

; 317  : 			
; 318  : 			if( RecvDataParse(lpIOContext, lpPerSocketContext->nIndex) == FALSE )

  00126	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00129	51		 push	 ecx
  0012a	56		 push	 esi
  0012b	e8 00 00 00 00	 call	 ?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z ; RecvDataParse
  00130	83 c4 08	 add	 esp, 8
  00133	85 c0		 test	 eax, eax
  00135	75 32		 jne	 SHORT $LN2@ServerWork

; 319  : 			{
; 320  : 				LogAdd(LOG_BLACK, "error-L1 : Socket Header error %d, %d", WSAGetLastError(), lpPerSocketContext->nIndex);

  00137	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0013a	52		 push	 edx
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00141	50		 push	 eax
  00142	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@MJPNHJDJ@error?9L1?5?3?5Socket?5Header?5error?5?$CF@
  00147	6a 00		 push	 0
  00149	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 321  : 				CloseClient(lpPerSocketContext, 0);

  0014e	6a 00		 push	 0
  00150	57		 push	 edi
  00151	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  00156	83 c4 18	 add	 esp, 24			; 00000018H

; 322  : 				LeaveCriticalSection(&criti);

  00159	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0015e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 323  : 				continue;

  00164	e9 a7 fe ff ff	 jmp	 $LL15@ServerWork
$LN2@ServerWork:

; 324  : 			}
; 325  : 			
; 326  : 			lpIOContext->nWaitIO = 0;
; 327  : 			Flags = 0;
; 328  : 			ZeroMemory(&(lpIOContext->Overlapped), sizeof(OVERLAPPED));

  00169	33 c0		 xor	 eax, eax
  0016b	33 d2		 xor	 edx, edx
  0016d	89 96 0c 2f 00
	00		 mov	 DWORD PTR [esi+12044], edx
  00173	89 55 ec	 mov	 DWORD PTR _Flags$[ebp], edx
  00176	89 06		 mov	 DWORD PTR [esi], eax
  00178	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0017b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0017e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00181	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 329  : 				
; 330  : 			lpIOContext->wsabuf.len		= MAX_IO_BUFFER_SIZE-lpIOContext->nSentBytes;

  00184	8b 86 04 2f 00
	00		 mov	 eax, DWORD PTR [esi+12036]
  0018a	bb 70 17 00 00	 mov	 ebx, 6000		; 00001770H
  0018f	2b d8		 sub	 ebx, eax

; 331  : 			lpIOContext->wsabuf.buf		= lpIOContext->Buffer+lpIOContext->nSentBytes;

  00191	8d 44 30 1c	 lea	 eax, DWORD PTR [eax+esi+28]

; 332  : 			lpIOContext->IOOperation	= RECV_IO;
; 333  : 				
; 334  : 			nRet = WSARecv(lpPerSocketContext->m_socket, &(lpIOContext->wsabuf), 1, &RecvBytes, &Flags,
; 335  : 				&(lpIOContext->Overlapped), NULL);

  00195	52		 push	 edx
  00196	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00199	8b 45 f0	 mov	 eax, DWORD PTR tv303[ebp]
  0019c	56		 push	 esi
  0019d	89 10		 mov	 DWORD PTR [eax], edx
  0019f	8d 55 ec	 lea	 edx, DWORD PTR _Flags$[ebp]
  001a2	52		 push	 edx
  001a3	8d 45 e8	 lea	 eax, DWORD PTR _RecvBytes$[ebp]
  001a6	50		 push	 eax
  001a7	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  001aa	6a 01		 push	 1
  001ac	51		 push	 ecx
  001ad	89 19		 mov	 DWORD PTR [ecx], ebx
  001af	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001b1	51		 push	 ecx
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSARecv@28

; 336  : 			
; 337  : 			if( nRet == SOCKET_ERROR && (WSAGetLastError() != ERROR_IO_PENDING) )

  001b8	83 f8 ff	 cmp	 eax, -1
  001bb	75 39		 jne	 SHORT $LN25@ServerWork
  001bd	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__WSAGetLastError@0
  001c3	ff d3		 call	 ebx
  001c5	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  001ca	74 2a		 je	 SHORT $LN25@ServerWork

; 338  : 			{
; 339  : 				LogAdd(LOG_BLACK, "WSARecv() failed with error %d", WSAGetLastError());

  001cc	ff d3		 call	 ebx
  001ce	50		 push	 eax
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@
  001d4	6a 00		 push	 0
  001d6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 340  : 				//lpIOContext->nWaitIO = 2;
; 341  : 				CloseClient( lpPerSocketContext, FALSE);

  001db	6a 00		 push	 0
  001dd	57		 push	 edi
  001de	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  001e3	83 c4 14	 add	 esp, 20			; 00000014H

; 342  : 				LeaveCriticalSection(&criti);

  001e6	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  001eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 343  : 				continue;

  001f1	e9 1a fe ff ff	 jmp	 $LL15@ServerWork
$LN25@ServerWork:

; 344  : 			}
; 345  : 				
; 346  : 			lpPerSocketContext->dwIOCount++;

  001f6	b8 01 00 00 00	 mov	 eax, 1
  001fb	01 87 28 5e 00
	00		 add	 DWORD PTR [edi+24104], eax

; 347  : 			lpIOContext->nWaitIO = 1;

  00201	89 86 0c 2f 00
	00		 mov	 DWORD PTR [esi+12044], eax
$LN3@ServerWork:

; 348  : 		}
; 349  : 		LeaveCriticalSection(&criti);

  00207	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0020c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 350  : 	}

  00212	e9 f9 fd ff ff	 jmp	 $LL15@ServerWork
$LN24@ServerWork:

; 271  : 				{
; 272  : 					EnterCriticalSection(&criti);

  00217	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 273  : 					LogAdd(LOG_BLACK, "Error Thread : GetQueueCompletionStatus( %d )", GetLastError());

  00222	ff d6		 call	 esi
  00224	50		 push	 eax
  00225	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@KIOKACIH@Error?5Thread?5?3?5GetQueueCompletio@
  0022a	6a 00		 push	 0
  0022c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00231	83 c4 0c	 add	 esp, 12			; 0000000cH

; 274  : 					LeaveCriticalSection(&criti);

  00234	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00239	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0023f	5f		 pop	 edi
  00240	5e		 pop	 esi

; 275  : 					return 0;

  00241	33 c0		 xor	 eax, eax
  00243	5b		 pop	 ebx

; 351  : 	return TRUE;
; 352  : }

  00244	8b e5		 mov	 esp, ebp
  00246	5d		 pop	 ebp
  00247	c2 04 00	 ret	 4
?ServerWorkerThread@@YGKPAX@Z ENDP			; ServerWorkerThread
_TEXT	ENDS
PUBLIC	??_C@_0CK@FNPFENCA@error?9L1?5?3?5WSARecv?$CI?$CJ?5failed?5with@ ; `string'
PUBLIC	??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5faile@ ; `string'
PUBLIC	??_C@_0DN@KCGEKGOM@error?9L1?5?3?5?$CFd?5?$CFd?5CreateIoComplet@ ; `string'
PUBLIC	??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91?$AA@ ; `string'
PUBLIC	??_C@_0CB@CBCMIDPM@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CFd@ ; `string'
PUBLIC	??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@ ; `string'
PUBLIC	??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5wi@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?IocpServerWorker@@YGKPAX@Z			; IocpServerWorker
EXTRN	__imp__PostQueuedCompletionStatus@16:PROC
EXTRN	?SCPJoinResultSend@@YAXHE@Z:PROC		; SCPJoinResultSend
EXTRN	?gObjAdd@@YAFIPADH@Z:PROC			; gObjAdd
EXTRN	?gObjAddSearch@@YAFIPAD@Z:PROC			; gObjAddSearch
EXTRN	__imp__inet_ntoa@4:PROC
EXTRN	__imp__WSAAccept@20:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__except_handler4:PROC
;	COMDAT ??_C@_0CK@FNPFENCA@error?9L1?5?3?5WSARecv?$CI?$CJ?5failed?5with@
CONST	SEGMENT
??_C@_0CK@FNPFENCA@error?9L1?5?3?5WSARecv?$CI?$CJ?5failed?5with@ DB 'erro'
	DB	'r-L1 : WSARecv() failed with error %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5faile@
CONST	SEGMENT
??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5faile@ DB 'e'
	DB	'rror-L1 : %d %d gObjAdd() failed with error %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@KCGEKGOM@error?9L1?5?3?5?$CFd?5?$CFd?5CreateIoComplet@
CONST	SEGMENT
??_C@_0DN@KCGEKGOM@error?9L1?5?3?5?$CFd?5?$CFd?5CreateIoComplet@ DB 'erro'
	DB	'r-L1 : %d %d CreateIoCompletionPort failed with error %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91?$AA@
CONST	SEGMENT
??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91?$AA@ DB 'error-L2'
	DB	' : ClientIndex = -1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CBCMIDPM@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CFd@
CONST	SEGMENT
??_C@_0CB@CBCMIDPM@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CFd@ DB 'WSA'
	DB	'Accept() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@
CONST	SEGMENT
??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@ DB 'CreateT'
	DB	'hread() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5wi@
CONST	SEGMENT
??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5wi@ DB 'CreateIoComple'
	DB	'tionPort failed with error: %d', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?IocpServerWorker@@YGKPAX@Z DD 0ffffffe4H
	DD	00H
	DD	0ffffff8cH
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN24@IocpServer
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?IocpServerWorker@@YGKPAX@Z
_TEXT	SEGMENT
_SystemInfo$ = -100					; size = 36
_RecvBytes$ = -64					; size = 4
_ThreadID$ = -60					; size = 4
_dwCPU$155082 = -56					; size = 4
_Flags$ = -52						; size = 4
_cAddrlen$ = -48					; size = 4
_cAddr$ = -44						; size = 16
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_p$ = 8							; size = 4
?IocpServerWorker@@YGKPAX@Z PROC			; IocpServerWorker, COMDAT

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?IocpServerWorker@@YGKPAX@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 54	 sub	 esp, 84			; 00000054H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 93   : 	SYSTEM_INFO SystemInfo;
; 94   : 	DWORD ThreadID;
; 95   : 	SOCKET Accept;
; 96   : 	int nRet;
; 97   : 	int ClientIndex;
; 98   : 	SOCKADDR_IN cAddr;
; 99   : 	IN_ADDR		cInAddr;
; 100  : 	int			cAddrlen = sizeof( cAddr );

  00033	c7 45 d0 10 00
	00 00		 mov	 DWORD PTR _cAddrlen$[ebp], 16 ; 00000010H

; 101  : 	LPPER_SOCKET_CONTEXT lpPerSocketContext = NULL; 
; 102  : 	DWORD RecvBytes;
; 103  : 	DWORD Flags=0;

  0003a	33 db		 xor	 ebx, ebx
  0003c	89 5d cc	 mov	 DWORD PTR _Flags$[ebp], ebx

; 104  : 	
; 105  : 	InitializeCriticalSection(&criti);

  0003f	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 106  : 	GetSystemInfo(&SystemInfo);

  0004a	8d 45 9c	 lea	 eax, DWORD PTR _SystemInfo$[ebp]
  0004d	50		 push	 eax
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4

; 107  : 
; 108  : 	g_dwThreadCount = SystemInfo.dwNumberOfProcessors * 2;

  00054	8b 4d b0	 mov	 ecx, DWORD PTR _SystemInfo$[ebp+20]
  00057	8d 14 09	 lea	 edx, DWORD PTR [ecx+ecx]
  0005a	89 15 00 00 00
	00		 mov	 DWORD PTR ?g_dwThreadCount@@3KA, edx ; g_dwThreadCount

; 109  : 	__try

  00060	89 5d fc	 mov	 DWORD PTR __$SEHRec$[ebp+20], ebx

; 110  : 	{
; 111  : 
; 112  : 		g_CompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);

  00063	53		 push	 ebx
  00064	53		 push	 ebx
  00065	53		 push	 ebx
  00066	6a ff		 push	 -1
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateIoCompletionPort@16
  0006e	a3 00 00 00 00	 mov	 DWORD PTR ?g_CompletionPort@@3PAXA, eax ; g_CompletionPort

; 113  : 		if ( g_CompletionPort == NULL)

  00073	3b c3		 cmp	 eax, ebx
  00075	75 17		 jne	 SHORT $LN19@IocpServer

; 114  : 		{
; 115  : 			LogAdd(LOG_BLACK, "CreateIoCompletionPort failed with error: %d", GetLastError());

  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0007d	50		 push	 eax
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5wi@
  00083	53		 push	 ebx
  00084	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 116  : 			__leave;

  0008c	eb 5c		 jmp	 SHORT $LN12@IocpServer
$LN19@IocpServer:

; 117  : 		}
; 118  : 		
; 119  : 		for(DWORD dwCPU = 0; dwCPU < g_dwThreadCount; dwCPU++)

  0008e	33 f6		 xor	 esi, esi
  00090	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CreateThread@24
$LN36@IocpServer:
  00096	89 75 c8	 mov	 DWORD PTR _dwCPU$155082[ebp], esi
  00099	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?g_dwThreadCount@@3KA ; g_dwThreadCount
  0009f	73 40		 jae	 SHORT $LN16@IocpServer

; 120  : 		{
; 121  : 			HANDLE ThreadHandle;
; 122  : 			// Create a server worker thread and pass the completion port to the thread.
; 123  : 			
; 124  : 			ThreadHandle = CreateThread(NULL, 0, ServerWorkerThread, g_CompletionPort, 0, &ThreadID);

  000a1	8d 4d c4	 lea	 ecx, DWORD PTR _ThreadID$[ebp]
  000a4	51		 push	 ecx
  000a5	53		 push	 ebx
  000a6	50		 push	 eax
  000a7	68 00 00 00 00	 push	 OFFSET ?ServerWorkerThread@@YGKPAX@Z ; ServerWorkerThread
  000ac	53		 push	 ebx
  000ad	53		 push	 ebx
  000ae	ff d7		 call	 edi

; 125  : 			if ( ThreadHandle == NULL)

  000b0	3b c3		 cmp	 eax, ebx
  000b2	75 17		 jne	 SHORT $LN15@IocpServer

; 126  : 			{
; 127  : 				LogAdd(LOG_BLACK, "CreateThread() failed with error %d", GetLastError());

  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000ba	50		 push	 eax
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@
  000c0	53		 push	 ebx
  000c1	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 128  : 				__leave;

  000c9	eb 1f		 jmp	 SHORT $LN12@IocpServer
$LN15@IocpServer:

; 129  : 			}
; 130  : 			g_ThreadHandles[dwCPU] = ThreadHandle;

  000cb	89 04 b5 00 00
	00 00		 mov	 DWORD PTR ?g_ThreadHandles@@3PAPAXA[esi*4], eax

; 131  : 			CloseHandle(ThreadHandle);

  000d2	50		 push	 eax
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 117  : 		}
; 118  : 		
; 119  : 		for(DWORD dwCPU = 0; dwCPU < g_dwThreadCount; dwCPU++)

  000d9	46		 inc	 esi
  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  000df	eb b5		 jmp	 SHORT $LN36@IocpServer
$LN16@IocpServer:

; 132  : 
; 133  : 		}
; 134  : 
; 135  : 		if (!CreateListenSocket() )

  000e1	e8 00 00 00 00	 call	 ?CreateListenSocket@@YAHXZ ; CreateListenSocket
  000e6	85 c0		 test	 eax, eax
  000e8	75 3a		 jne	 SHORT $LL13@IocpServer
$LN12@IocpServer:

; 218  : 	}
; 219  : 	__finally  

  000ea	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000f1	e8 6d 02 00 00	 call	 $LN26@IocpServer
$LN27@IocpServer:

; 235  : 		} 
; 236  : 	}
; 237  : 	return TRUE;

  000f6	b8 01 00 00 00	 mov	 eax, 1

; 238  : }

  000fb	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  000fe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00105	59		 pop	 ecx
  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx
  00109	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010c	33 cd		 xor	 ecx, ebp
  0010e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 04 00	 ret	 4
$LN38@IocpServer:

; 159  : 				LeaveCriticalSection(&criti);

  00119	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LL13@IocpServer:

; 136  : 			__leave;
; 137  : 
; 138  : 		
; 139  : 		while(TRUE)		
; 140  : 		{
; 141  : 			Accept = WSAAccept(g_Listen, (LPSOCKADDR)&cAddr, &cAddrlen, NULL, 0);

  00124	6a 00		 push	 0
  00126	6a 00		 push	 0
  00128	8d 55 d0	 lea	 edx, DWORD PTR _cAddrlen$[ebp]
  0012b	52		 push	 edx
  0012c	8d 45 d4	 lea	 eax, DWORD PTR _cAddr$[ebp]
  0012f	50		 push	 eax
  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_Listen@@3IA ; g_Listen
  00136	51		 push	 ecx
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAAccept@20
  0013d	8b f8		 mov	 edi, eax

; 143  : 			{
; 144  : 				EnterCriticalSection(&criti);

  0013f	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 142  : 			if (Accept==SOCKET_ERROR)

  0014a	83 ff ff	 cmp	 edi, -1
  0014d	75 18		 jne	 SHORT $LN11@IocpServer

; 145  : 				LogAdd(LOG_BLACK, "WSAAccept() failed with error %d", WSAGetLastError());

  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00155	50		 push	 eax
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@CBCMIDPM@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CFd@
  0015b	6a 00		 push	 0
  0015d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 146  : 				LeaveCriticalSection(&criti);
; 147  : 				continue;

  00165	eb b2		 jmp	 SHORT $LN38@IocpServer
$LN11@IocpServer:

; 148  : 			}
; 149  : 			EnterCriticalSection(&criti);
; 150  : 
; 151  : 			memcpy( &cInAddr, &cAddr.sin_addr.s_addr, 4 );

  00167	8b 45 d8	 mov	 eax, DWORD PTR _cAddr$[ebp+4]
  0016a	8b f0		 mov	 esi, eax

; 152  : 
; 153  : 			ClientIndex = gObjAddSearch(Accept, inet_ntoa(cInAddr) );

  0016c	50		 push	 eax
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_ntoa@4
  00173	50		 push	 eax
  00174	57		 push	 edi
  00175	e8 00 00 00 00	 call	 ?gObjAddSearch@@YAFIPAD@Z ; gObjAddSearch
  0017a	83 c4 08	 add	 esp, 8
  0017d	0f bf d8	 movsx	 ebx, ax

; 154  : 			
; 155  : 			if ( ClientIndex == -1 )

  00180	83 fb ff	 cmp	 ebx, -1
  00183	75 1b		 jne	 SHORT $LN10@IocpServer

; 156  : 			{
; 157  : 				LogAdd(LOG_BLACK, "error-L2 : ClientIndex = -1");

  00185	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91?$AA@
  0018a	6a 00		 push	 0
  0018c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00191	83 c4 08	 add	 esp, 8
$LN37@IocpServer:

; 158  : 				closesocket(Accept);

  00194	57		 push	 edi
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 160  : 				continue;

  0019b	e9 79 ff ff ff	 jmp	 $LN38@IocpServer
$LN10@IocpServer:

; 161  : 			}
; 162  : 
; 163  : 			if (UpdateCompletionPort(Accept, ClientIndex, 1) == 0 )

  001a0	6a 01		 push	 1
  001a2	53		 push	 ebx
  001a3	57		 push	 edi
  001a4	e8 00 00 00 00	 call	 ?UpdateCompletionPort@@YAHIHH@Z ; UpdateCompletionPort
  001a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ac	85 c0		 test	 eax, eax
  001ae	75 1a		 jne	 SHORT $LN9@IocpServer

; 164  : 			{
; 165  : 				LogAdd(LOG_BLACK, "error-L1 : %d %d CreateIoCompletionPort failed with error %d", Accept, ClientIndex, GetLastError() );

  001b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001b6	50		 push	 eax
  001b7	53		 push	 ebx
  001b8	57		 push	 edi
  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@KCGEKGOM@error?9L1?5?3?5?$CFd?5?$CFd?5CreateIoComplet@
  001be	6a 00		 push	 0
  001c0	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001c5	83 c4 14	 add	 esp, 20			; 00000014H

; 166  : 				closesocket(Accept);
; 167  : 				LeaveCriticalSection(&criti);
; 168  : 				continue;

  001c8	eb ca		 jmp	 SHORT $LN37@IocpServer
$LN9@IocpServer:

; 169  : 			}
; 170  : 
; 171  : 			if (gObjAdd(Accept, inet_ntoa(cInAddr), ClientIndex) == -1 )

  001ca	53		 push	 ebx
  001cb	56		 push	 esi
  001cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_ntoa@4
  001d2	50		 push	 eax
  001d3	57		 push	 edi
  001d4	e8 00 00 00 00	 call	 ?gObjAdd@@YAFIPADH@Z	; gObjAdd
  001d9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001dc	66 83 f8 ff	 cmp	 ax, -1
  001e0	75 2f		 jne	 SHORT $LN8@IocpServer

; 172  : 			{
; 173  : 				LogAdd(LOG_BLACK, "error-L1 : %d %d gObjAdd() failed with error %d", Accept, ClientIndex, GetLastError() );

  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001e8	50		 push	 eax
  001e9	53		 push	 ebx
  001ea	57		 push	 edi
  001eb	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5faile@
  001f0	6a 00		 push	 0
  001f2	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001f7	83 c4 14	 add	 esp, 20			; 00000014H

; 174  : 				LeaveCriticalSection(&criti);

  001fa	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  001ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 175  : 				closesocket(Accept);

  00205	57		 push	 edi
  00206	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 176  : 				continue;

  0020c	e9 13 ff ff ff	 jmp	 $LL13@IocpServer
$LN8@IocpServer:

; 177  : 			}
; 178  : 				
; 179  : 			memset(&gObj[ClientIndex].PerSocketContext->IOContext[0].Overlapped, 0, sizeof(OVERLAPPED));

  00211	8b d3		 mov	 edx, ebx
  00213	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  00219	8d b2 0c 00 00
	00		 lea	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+12]
  0021f	33 c9		 xor	 ecx, ecx
  00221	8b 06		 mov	 eax, DWORD PTR [esi]
  00223	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00226	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00229	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0022c	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0022f	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 180  : 			memset(&gObj[ClientIndex].PerSocketContext->IOContext[1].Overlapped, 0, sizeof(OVERLAPPED));

  00232	8b 06		 mov	 eax, DWORD PTR [esi]
  00234	89 88 18 2f 00
	00		 mov	 DWORD PTR [eax+12056], ecx
  0023a	89 88 1c 2f 00
	00		 mov	 DWORD PTR [eax+12060], ecx
  00240	89 88 20 2f 00
	00		 mov	 DWORD PTR [eax+12064], ecx
  00246	89 88 24 2f 00
	00		 mov	 DWORD PTR [eax+12068], ecx
  0024c	89 88 28 2f 00
	00		 mov	 DWORD PTR [eax+12072], ecx

; 181  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].wsabuf.buf = gObj[ClientIndex].PerSocketContext->IOContext[0].Buffer;

  00252	8b 06		 mov	 eax, DWORD PTR [esi]
  00254	8d 50 24	 lea	 edx, DWORD PTR [eax+36]
  00257	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 182  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].wsabuf.len = MAX_IO_BUFFER_SIZE;

  0025a	8b 06		 mov	 eax, DWORD PTR [esi]
  0025c	c7 40 1c 70 17
	00 00		 mov	 DWORD PTR [eax+28], 6000 ; 00001770H

; 183  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nTotalBytes = 0;

  00263	8b 16		 mov	 edx, DWORD PTR [esi]
  00265	89 8a 08 2f 00
	00		 mov	 DWORD PTR [edx+12040], ecx

; 184  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nSentBytes = 0;

  0026b	8b 06		 mov	 eax, DWORD PTR [esi]
  0026d	89 88 0c 2f 00
	00		 mov	 DWORD PTR [eax+12044], ecx

; 185  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nWaitIO    = 0;

  00273	8b 16		 mov	 edx, DWORD PTR [esi]
  00275	89 8a 14 2f 00
	00		 mov	 DWORD PTR [edx+12052], ecx

; 186  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nSecondOfs = 0;

  0027b	8b 06		 mov	 eax, DWORD PTR [esi]
  0027d	89 88 04 2f 00
	00		 mov	 DWORD PTR [eax+12036], ecx

; 187  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].IOOperation = RECV_IO;

  00283	8b 16		 mov	 edx, DWORD PTR [esi]
  00285	89 8a 10 2f 00
	00		 mov	 DWORD PTR [edx+12048], ecx

; 188  : 			
; 189  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].wsabuf.buf = gObj[ClientIndex].PerSocketContext->IOContext[0].Buffer;

  0028b	8b 06		 mov	 eax, DWORD PTR [esi]
  0028d	8d 50 24	 lea	 edx, DWORD PTR [eax+36]
  00290	89 90 30 2f 00
	00		 mov	 DWORD PTR [eax+12080], edx

; 190  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].wsabuf.len = MAX_IO_BUFFER_SIZE;

  00296	8b 06		 mov	 eax, DWORD PTR [esi]
  00298	c7 80 2c 2f 00
	00 70 17 00 00	 mov	 DWORD PTR [eax+12076], 6000 ; 00001770H

; 191  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nTotalBytes= 0;

  002a2	8b 16		 mov	 edx, DWORD PTR [esi]
  002a4	89 8a 18 5e 00
	00		 mov	 DWORD PTR [edx+24088], ecx

; 192  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nSentBytes = 0;

  002aa	8b 06		 mov	 eax, DWORD PTR [esi]
  002ac	89 88 1c 5e 00
	00		 mov	 DWORD PTR [eax+24092], ecx

; 193  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nWaitIO    = 0;

  002b2	8b 16		 mov	 edx, DWORD PTR [esi]
  002b4	89 8a 24 5e 00
	00		 mov	 DWORD PTR [edx+24100], ecx

; 194  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nSecondOfs = 0;

  002ba	8b 06		 mov	 eax, DWORD PTR [esi]
  002bc	89 88 14 5e 00
	00		 mov	 DWORD PTR [eax+24084], ecx

; 195  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].IOOperation = SEND_IO;

  002c2	8b 16		 mov	 edx, DWORD PTR [esi]
  002c4	c7 82 20 5e 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+24096], 1

; 196  : 			gObj[ClientIndex].PerSocketContext->m_socket = Accept;

  002ce	8b 06		 mov	 eax, DWORD PTR [esi]
  002d0	89 38		 mov	 DWORD PTR [eax], edi

; 197  : 			gObj[ClientIndex].PerSocketContext->nIndex   = ClientIndex;

  002d2	8b 16		 mov	 edx, DWORD PTR [esi]
  002d4	89 5a 04	 mov	 DWORD PTR [edx+4], ebx

; 198  : 
; 199  : 			nRet = WSARecv(Accept, &(gObj[ClientIndex].PerSocketContext->IOContext[0].wsabuf), 1, &RecvBytes, &Flags,
; 200  : 				&(gObj[ClientIndex].PerSocketContext->IOContext[0].Overlapped), NULL);

  002d7	8b 06		 mov	 eax, DWORD PTR [esi]
  002d9	51		 push	 ecx
  002da	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  002dd	51		 push	 ecx
  002de	8d 55 cc	 lea	 edx, DWORD PTR _Flags$[ebp]
  002e1	52		 push	 edx
  002e2	8d 4d c0	 lea	 ecx, DWORD PTR _RecvBytes$[ebp]
  002e5	51		 push	 ecx
  002e6	6a 01		 push	 1
  002e8	83 c0 1c	 add	 eax, 28			; 0000001cH
  002eb	50		 push	 eax
  002ec	57		 push	 edi
  002ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSARecv@28

; 201  : 
; 202  : 			if( nRet == SOCKET_ERROR && WSAGetLastError() != ERROR_IO_PENDING )

  002f3	83 f8 ff	 cmp	 eax, -1
  002f6	75 3c		 jne	 SHORT $LN7@IocpServer
  002f8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WSAGetLastError@0
  002fe	ff d7		 call	 edi
  00300	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  00305	74 2d		 je	 SHORT $LN7@IocpServer

; 203  : 			{
; 204  : 				LogAdd(LOG_BLACK, "error-L1 : WSARecv() failed with error %d", WSAGetLastError());

  00307	ff d7		 call	 edi
  00309	50		 push	 eax
  0030a	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@FNPFENCA@error?9L1?5?3?5WSARecv?$CI?$CJ?5failed?5with@
  0030f	6a 00		 push	 0
  00311	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 205  : 				gObj[ClientIndex].PerSocketContext->IOContext[0].nWaitIO = 4;

  00316	8b 16		 mov	 edx, DWORD PTR [esi]
  00318	c7 82 14 2f 00
	00 04 00 00 00	 mov	 DWORD PTR [edx+12052], 4

; 206  : 				CloseClient(gObj[ClientIndex].PerSocketContext, FALSE);

  00322	6a 00		 push	 0
  00324	8b 06		 mov	 eax, DWORD PTR [esi]
  00326	50		 push	 eax
  00327	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  0032c	83 c4 14	 add	 esp, 20			; 00000014H

; 207  : 				LeaveCriticalSection(&criti);
; 208  : 				continue;

  0032f	e9 e5 fd ff ff	 jmp	 $LN38@IocpServer
$LN7@IocpServer:

; 209  : 			}
; 210  : 
; 211  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nWaitIO = 1;

  00334	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00336	bf 01 00 00 00	 mov	 edi, 1
  0033b	89 b9 14 2f 00
	00		 mov	 DWORD PTR [ecx+12052], edi

; 212  : 			gObj[ClientIndex].PerSocketContext->dwIOCount++;

  00341	8b 36		 mov	 esi, DWORD PTR [esi]
  00343	01 be 28 5e 00
	00		 add	 DWORD PTR [esi+24104], edi

; 213  : 
; 214  : 			LeaveCriticalSection(&criti);

  00349	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0034e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 215  : 			SCPJoinResultSend(ClientIndex, 1);

  00354	57		 push	 edi
  00355	53		 push	 ebx
  00356	e8 00 00 00 00	 call	 ?SCPJoinResultSend@@YAXHE@Z ; SCPJoinResultSend
  0035b	83 c4 08	 add	 esp, 8

; 216  : 
; 217  : 		}

  0035e	e9 c1 fd ff ff	 jmp	 $LL13@IocpServer
$LN24@IocpServer:
$LN40@IocpServer:
$LN26@IocpServer:

; 220  : 	{
; 221  : 		if( g_CompletionPort )

  00363	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  00368	85 c0		 test	 eax, eax
  0036a	74 40		 je	 SHORT $LN2@IocpServer

; 222  : 		{
; 223  : 			for (DWORD i = 0; i < g_dwThreadCount; i++) 

  0036c	33 f6		 xor	 esi, esi
  0036e	39 35 00 00 00
	00		 cmp	 DWORD PTR ?g_dwThreadCount@@3KA, esi ; g_dwThreadCount
  00374	76 21		 jbe	 SHORT $LN3@IocpServer
  00376	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PostQueuedCompletionStatus@16
  0037c	8d 64 24 00	 npad	 4
$LL34@IocpServer:

; 224  : 					PostQueuedCompletionStatus(g_CompletionPort, 0, 0, NULL); 

  00380	6a 00		 push	 0
  00382	6a 00		 push	 0
  00384	6a 00		 push	 0
  00386	50		 push	 eax
  00387	ff d7		 call	 edi

; 222  : 		{
; 223  : 			for (DWORD i = 0; i < g_dwThreadCount; i++) 

  00389	46		 inc	 esi
  0038a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  0038f	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?g_dwThreadCount@@3KA ; g_dwThreadCount
  00395	72 e9		 jb	 SHORT $LL34@IocpServer
$LN3@IocpServer:

; 225  : 		}
; 226  : 		if( g_CompletionPort )

  00397	85 c0		 test	 eax, eax
  00399	74 11		 je	 SHORT $LN2@IocpServer

; 227  : 		{
; 228  : 			CloseHandle(g_CompletionPort);

  0039b	50		 push	 eax
  0039c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 229  : 			g_CompletionPort = NULL;

  003a2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_CompletionPort@@3PAXA, 0 ; g_CompletionPort
$LN2@IocpServer:

; 230  : 		}
; 231  : 		if (g_Listen != INVALID_SOCKET)  

  003ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_Listen@@3IA ; g_Listen
  003b1	83 f8 ff	 cmp	 eax, -1
  003b4	74 11		 je	 SHORT $LN25@IocpServer

; 232  : 		{ 
; 233  :             closesocket(g_Listen);  

  003b6	50		 push	 eax
  003b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 234  :             g_Listen = INVALID_SOCKET; 

  003bd	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?g_Listen@@3IA, -1 ; g_Listen
$LN25@IocpServer:
$LN35@IocpServer:
  003c7	c3		 ret	 0
?IocpServerWorker@@YGKPAX@Z ENDP			; IocpServerWorker
_TEXT	ENDS
PUBLIC	?CreateGIocp@@YAHH@Z				; CreateGIocp
; Function compile flags: /Ogtp
;	COMDAT ?CreateGIocp@@YAHH@Z
_TEXT	SEGMENT
_ThreadID$ = 8						; size = 4
_server_port$ = 8					; size = 4
?CreateGIocp@@YAHH@Z PROC				; CreateGIocp, COMDAT

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   : 	DWORD	ThreadID;
; 39   : 	
; 40   : 	g_ServerPort = server_port;

  00003	8b 45 08	 mov	 eax, DWORD PTR _server_port$[ebp]

; 41   : 	if ((g_IocpThreadHandle = CreateThread(NULL, 0, IocpServerWorker, (LPVOID)NULL,
; 42   : 			0, &ThreadID)) == NULL)

  00006	8d 4d 08	 lea	 ecx, DWORD PTR _ThreadID$[ebp]
  00009	51		 push	 ecx
  0000a	6a 00		 push	 0
  0000c	6a 00		 push	 0
  0000e	68 00 00 00 00	 push	 OFFSET ?IocpServerWorker@@YGKPAX@Z ; IocpServerWorker
  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	a3 00 00 00 00	 mov	 DWORD PTR ?g_ServerPort@@3HA, eax ; g_ServerPort
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  00022	a3 00 00 00 00	 mov	 DWORD PTR ?g_IocpThreadHandle@@3PAXA, eax ; g_IocpThreadHandle
  00027	85 c0		 test	 eax, eax
  00029	75 1a		 jne	 SHORT $LN1@CreateGIoc

; 43   : 	{
; 44   : 		LogAdd(LOG_BLACK, "CreateThread() failed with error %d", GetLastError());

  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00031	50		 push	 eax
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@
  00037	6a 00		 push	 0
  00039	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 45   : 		return FALSE;

  00041	33 c0		 xor	 eax, eax

; 48   : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
$LN1@CreateGIoc:

; 46   : 	}
; 47   : 	return TRUE;

  00045	b8 01 00 00 00	 mov	 eax, 1

; 48   : }

  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?CreateGIocp@@YAHH@Z ENDP				; CreateGIocp
_TEXT	ENDS
END
