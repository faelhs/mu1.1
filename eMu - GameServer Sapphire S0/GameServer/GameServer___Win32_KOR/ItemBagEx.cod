; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\ItemBagEx.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_7CItemBagEx@@6B@				; CItemBagEx::`vftable'
PUBLIC	??1CItemBagEx@@UAE@XZ				; CItemBagEx::~CItemBagEx
PUBLIC	??_R4CItemBagEx@@6B@				; CItemBagEx::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCItemBagEx@@@8				; CItemBagEx `RTTI Type Descriptor'
PUBLIC	??_R3CItemBagEx@@8				; CItemBagEx::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CItemBagEx@@8				; CItemBagEx::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CItemBagEx@@8			; CItemBagEx::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECItemBagEx@@UAEPAXI@Z:PROC			; CItemBagEx::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CItemBagEx@@8
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itembagex.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CItemBagEx@@8 DD FLAT:??_R0?AVCItemBagEx@@@8 ; CItemBagEx::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CItemBagEx@@8
rdata$r	ENDS
;	COMDAT ??_R2CItemBagEx@@8
rdata$r	SEGMENT
??_R2CItemBagEx@@8 DD FLAT:??_R1A@?0A@EA@CItemBagEx@@8	; CItemBagEx::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CItemBagEx@@8
rdata$r	SEGMENT
??_R3CItemBagEx@@8 DD 00H				; CItemBagEx::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CItemBagEx@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCItemBagEx@@@8
_DATA	SEGMENT
??_R0?AVCItemBagEx@@@8 DD FLAT:??_7type_info@@6B@	; CItemBagEx `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCItemBagEx@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CItemBagEx@@6B@
rdata$r	SEGMENT
??_R4CItemBagEx@@6B@ DD 00H				; CItemBagEx::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCItemBagEx@@@8
	DD	FLAT:??_R3CItemBagEx@@8
rdata$r	ENDS
;	COMDAT ??_7CItemBagEx@@6B@
CONST	SEGMENT
??_7CItemBagEx@@6B@ DD FLAT:??_R4CItemBagEx@@6B@	; CItemBagEx::`vftable'
	DD	FLAT:??_ECItemBagEx@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1CItemBagEx@@UAE@XZ
_TEXT	SEGMENT
??1CItemBagEx@@UAE@XZ PROC				; CItemBagEx::~CItemBagEx, COMDAT
; _this$ = ecx

; 19   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CItemBagEx@@6B@

; 20   : 	return;
; 21   : }

  00006	c3		 ret	 0
??1CItemBagEx@@UAE@XZ ENDP				; CItemBagEx::~CItemBagEx
_TEXT	ENDS
PUBLIC	??_C@_0BO@PPHECIOP@ExEvent?5ItemBag?5LoadFail?5?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_0GL@LIMNLNHJ@?$FL?$CFs?$FN?5Eventitemnum?5?$DN?5?$CFd?0EventItem@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	_script_file$GSCopy$
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LoadItem@CItemBagEx@@QAEXPAD@Z			; CItemBagEx::LoadItem
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fclose:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0BO@PPHECIOP@ExEvent?5ItemBag?5LoadFail?5?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BO@PPHECIOP@ExEvent?5ItemBag?5LoadFail?5?$FL?$CFs?$FN?$AA@ DB 'ExE'
	DB	'vent ItemBag LoadFail [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@LIMNLNHJ@?$FL?$CFs?$FN?5Eventitemnum?5?$DN?5?$CFd?0EventItem@
CONST	SEGMENT
??_C@_0GL@LIMNLNHJ@?$FL?$CFs?$FN?5Eventitemnum?5?$DN?5?$CFd?0EventItem@ DB '['
	DB	'%s] Eventitemnum = %d,EventItemLevel = %d, EventItemDropRate '
	DB	'= %d, ItemDropRate = %d, ExItemDropRate = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LoadItem@CItemBagEx@@QAEXPAD@Z
_TEXT	SEGMENT
_script_file$GSCopy$ = -276				; size = 4
_n$ = -272						; size = 4
tv649 = -268						; size = 4
tv647 = -268						; size = 4
tv641 = -268						; size = 4
tv639 = -268						; size = 4
tv633 = -268						; size = 4
tv631 = -268						; size = 4
tv542 = -268						; size = 4
tv540 = -268						; size = 4
tv534 = -268						; size = 4
tv532 = -268						; size = 4
tv526 = -268						; size = 4
tv524 = -268						; size = 4
tv518 = -268						; size = 4
tv516 = -268						; size = 4
tv510 = -268						; size = 4
tv508 = -268						; size = 4
tv502 = -268						; size = 4
tv500 = -268						; size = 4
tv494 = -268						; size = 4
tv492 = -268						; size = 4
tv486 = -268						; size = 4
tv484 = -268						; size = 4
tv652 = -262						; size = 2
tv644 = -262						; size = 2
tv636 = -262						; size = 2
tv545 = -262						; size = 2
tv537 = -262						; size = 2
tv529 = -262						; size = 2
tv521 = -262						; size = 2
tv513 = -262						; size = 2
tv505 = -262						; size = 2
tv497 = -262						; size = 2
tv489 = -262						; size = 2
_szTemp$153534 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_script_file$ = 8					; size = 4
?LoadItem@CItemBagEx@@QAEXPAD@Z PROC			; CItemBagEx::LoadItem, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _script_file$[ebp]
  00018	57		 push	 edi
  00019	8b f9		 mov	 edi, ecx

; 40   : 	int Token;
; 41   : 
; 42   : 	this->m_bLoad = FALSE;
; 43   : 	SMDFile = fopen(script_file, "r");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00020	33 db		 xor	 ebx, ebx
  00022	56		 push	 esi

; 114  : 
; 115  : 					Token = GetToken();

  00023	89 b5 ec fe ff
	ff		 mov	 DWORD PTR _script_file$GSCopy$[ebp], esi
  00029	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  0002c	e8 00 00 00 00	 call	 _fopen
  00031	83 c4 08	 add	 esp, 8
  00034	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax
  00039	3b c3		 cmp	 eax, ebx
  0003b	75 2d		 jne	 SHORT $LN24@LoadItem

; 44   : 
; 45   : 	if ( SMDFile == NULL )
; 46   : 	{
; 47   : 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(1, 197)), script_file);

  0003d	56		 push	 esi
  0003e	68 c5 01 00 00	 push	 453			; 000001c5H
  00043	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00048	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0004d	50		 push	 eax
  0004e	53		 push	 ebx
  0004f	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx

; 197  : }

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005d	33 cd		 xor	 ecx, ebp
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
$LN24@LoadItem:

; 48   : 		return;
; 49   : 	}
; 50   : 
; 51   : 	int n=0;

  0006a	89 9d f0 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], ebx

; 52   : 
; 53   : 	while ( true )
; 54   : 	{
; 55   : 		Token = GetToken();

  00070	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 56   : 
; 57   : 		if ( Token == 2 )

  00075	83 f8 02	 cmp	 eax, 2
  00078	0f 84 18 05 00
	00		 je	 $LN41@LoadItem
  0007e	8b ff		 npad	 2
$LL23@LoadItem:

; 58   : 		{
; 59   : 			break;
; 60   : 		}
; 61   : 
; 62   : 		if ( Token == 1 )

  00080	83 f8 01	 cmp	 eax, 1
  00083	0f 85 f9 04 00
	00		 jne	 $LN57@LoadItem

; 63   : 		{
; 64   : 			int st = TokenNumber;	// script_type

  00089	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0008f	e8 00 00 00 00	 call	 __ftol2_sse

; 65   : 
; 66   : 			if ( st == 0 )

  00094	85 c0		 test	 eax, eax
  00096	0f 85 3c 01 00
	00		 jne	 $LN19@LoadItem
  0009c	8d 64 24 00	 npad	 4
$LL18@LoadItem:

; 67   : 			{
; 68   : 				while ( true )
; 69   : 				{
; 70   : 					Token = GetToken();

  000a0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 71   : 
; 72   : 					if ( Token == 0 )

  000a5	85 c0		 test	 eax, eax
  000a7	75 37		 jne	 SHORT $LN15@LoadItem

; 73   : 					{
; 74   : 						if ( strcmp("end", TokenString) == 0 )

  000a9	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  000ae	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL43@LoadItem:
  000b3	8a 10		 mov	 dl, BYTE PTR [eax]
  000b5	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000b7	75 1a		 jne	 SHORT $LN44@LoadItem
  000b9	84 d2		 test	 dl, dl
  000bb	74 12		 je	 SHORT $LN45@LoadItem
  000bd	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000c0	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000c3	75 0e		 jne	 SHORT $LN44@LoadItem
  000c5	83 c0 02	 add	 eax, 2
  000c8	83 c1 02	 add	 ecx, 2
  000cb	84 d2		 test	 dl, dl
  000cd	75 e4		 jne	 SHORT $LL43@LoadItem
$LN45@LoadItem:
  000cf	33 c0		 xor	 eax, eax
  000d1	eb 05		 jmp	 SHORT $LN46@LoadItem
$LN44@LoadItem:
  000d3	1b c0		 sbb	 eax, eax
  000d5	83 d8 ff	 sbb	 eax, -1
$LN46@LoadItem:
  000d8	85 c0		 test	 eax, eax
  000da	0f 84 fa 04 00
	00		 je	 $LN56@LoadItem
$LN15@LoadItem:

; 75   : 						{
; 76   : 							break;
; 77   : 						}
; 78   : 					}
; 79   : 
; 80   : 					int map = TokenNumber;

  000e0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000e6	e8 00 00 00 00	 call	 __ftol2_sse
  000eb	8b f0		 mov	 esi, eax

; 81   : 
; 82   : 					if ( MAX_MAP_RANGE(map) == FALSE )

  000ed	85 f6		 test	 esi, esi
  000ef	0f 88 ed 04 00
	00		 js	 $LN37@LoadItem
  000f5	33 c0		 xor	 eax, eax
  000f7	83 fe 27	 cmp	 esi, 39			; 00000027H
  000fa	0f 9e c0	 setle	 al
  000fd	85 c0		 test	 eax, eax
  000ff	0f 84 dd 04 00
	00		 je	 $LN37@LoadItem

; 85   : 						return;
; 86   : 					}
; 87   : 
; 88   : 					Token = GetToken();

  00105	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 89   : 					this->DropMapInfo[map].m_bIsDrop = TokenNumber;

  0010a	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00110	8d 04 77	 lea	 eax, DWORD PTR [edi+esi*2]
  00113	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv652[ebp]
  00119	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]
  0011c	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv652[ebp]
  00123	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00128	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv649[ebp], eax
  0012e	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv649[ebp]
  00134	db 9d f4 fe ff
	ff		 fistp	 DWORD PTR tv647[ebp]
  0013a	8a 8d f4 fe ff
	ff		 mov	 cl, BYTE PTR tv647[ebp]
  00140	88 8b 24 01 00
	00		 mov	 BYTE PTR [ebx+292], cl
  00146	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv652[ebp]

; 90   : 
; 91   : 					Token = GetToken();

  0014c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 92   : 					this->DropMapInfo[map].m_MinMonsterLevel = TokenNumber;

  00151	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00157	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv644[ebp]
  0015d	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv644[ebp]
  00164	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00169	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv641[ebp], eax
  0016f	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv641[ebp]
  00175	db 9d f4 fe ff
	ff		 fistp	 DWORD PTR tv639[ebp]
  0017b	8a 95 f4 fe ff
	ff		 mov	 dl, BYTE PTR tv639[ebp]
  00181	88 93 25 01 00
	00		 mov	 BYTE PTR [ebx+293], dl
  00187	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv644[ebp]

; 93   : 
; 94   : 					Token = GetToken();

  0018d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 95   : 					this->DropMapInfo[map].m_MaxMonsterLevel = TokenNumber;

  00192	8d 8c 77 c4 00
	00 00		 lea	 ecx, DWORD PTR [edi+esi*2+196]
  00199	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0019f	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv636[ebp]
  001a5	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv636[ebp]
  001ac	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  001b1	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv633[ebp], eax
  001b7	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv633[ebp]
  001bd	db 9d f4 fe ff
	ff		 fistp	 DWORD PTR tv631[ebp]
  001c3	8a 85 f4 fe ff
	ff		 mov	 al, BYTE PTR tv631[ebp]
  001c9	88 44 0e 62	 mov	 BYTE PTR [esi+ecx+98], al
  001cd	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv636[ebp]

; 96   : 				}

  001d3	e9 c8 fe ff ff	 jmp	 $LL18@LoadItem
$LN19@LoadItem:

; 97   : 			
; 98   : 			}
; 99   : 			else if ( st == 1 )

  001d8	83 f8 01	 cmp	 eax, 1
  001db	0f 85 3a 01 00
	00		 jne	 $LN12@LoadItem
$LL11@LoadItem:

; 100  : 			{
; 101  : 				while ( true )
; 102  : 				{
; 103  : 					Token = GetToken();

  001e1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 104  : 
; 105  : 					if ( Token == 0 )

  001e6	85 c0		 test	 eax, eax
  001e8	75 37		 jne	 SHORT $LN8@LoadItem

; 106  : 					{
; 107  : 						if ( strcmp("end", TokenString) == 0 )

  001ea	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  001ef	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL47@LoadItem:
  001f4	8a 10		 mov	 dl, BYTE PTR [eax]
  001f6	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001f8	75 1a		 jne	 SHORT $LN48@LoadItem
  001fa	84 d2		 test	 dl, dl
  001fc	74 12		 je	 SHORT $LN49@LoadItem
  001fe	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00201	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00204	75 0e		 jne	 SHORT $LN48@LoadItem
  00206	83 c0 02	 add	 eax, 2
  00209	83 c1 02	 add	 ecx, 2
  0020c	84 d2		 test	 dl, dl
  0020e	75 e4		 jne	 SHORT $LL47@LoadItem
$LN49@LoadItem:
  00210	33 c0		 xor	 eax, eax
  00212	eb 05		 jmp	 SHORT $LN50@LoadItem
$LN48@LoadItem:
  00214	1b c0		 sbb	 eax, eax
  00216	83 d8 ff	 sbb	 eax, -1
$LN50@LoadItem:
  00219	85 c0		 test	 eax, eax
  0021b	0f 84 b9 03 00
	00		 je	 $LN56@LoadItem
$LN8@LoadItem:

; 108  : 						{
; 109  : 							break;
; 110  : 						}
; 111  : 					}
; 112  : 
; 113  : 					strcpy(this->m_sEventName, TokenString);

  00221	8d 5f 08	 lea	 ebx, DWORD PTR [edi+8]
  00224	b8 00 00 00 00	 mov	 eax, OFFSET _TokenString
  00229	8b d3		 mov	 edx, ebx
  0022b	2b d0		 sub	 edx, eax
  0022d	8d 49 00	 npad	 3
$LL29@LoadItem:
  00230	8a 08		 mov	 cl, BYTE PTR [eax]
  00232	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00235	40		 inc	 eax
  00236	84 c9		 test	 cl, cl
  00238	75 f6		 jne	 SHORT $LL29@LoadItem

; 114  : 
; 115  : 					Token = GetToken();

  0023a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 116  : 					this->m_iDropZen = TokenNumber;

  0023f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00245	e8 00 00 00 00	 call	 __ftol2_sse
  0024a	89 87 10 01 00
	00		 mov	 DWORD PTR [edi+272], eax

; 117  : 
; 118  : 					Token = GetToken();

  00250	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 119  : 					int type = TokenNumber;

  00255	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0025b	e8 00 00 00 00	 call	 __ftol2_sse
  00260	8b f0		 mov	 esi, eax

; 120  : 
; 121  : 					Token = GetToken();

  00262	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 122  : 					int index = TokenNumber;
; 123  : 
; 124  : 					this->m_iEventItemType = ITEMGET(type, index);

  00267	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0026d	c1 e6 09	 shl	 esi, 9
  00270	e8 00 00 00 00	 call	 __ftol2_sse
  00275	03 f0		 add	 esi, eax
  00277	89 b7 08 01 00
	00		 mov	 DWORD PTR [edi+264], esi

; 125  : 
; 126  : 					Token = GetToken();

  0027d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 127  : 					this->m_iEventItemLevel = TokenNumber;

  00282	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00288	e8 00 00 00 00	 call	 __ftol2_sse
  0028d	89 87 0c 01 00
	00		 mov	 DWORD PTR [edi+268], eax

; 128  : 
; 129  : 					Token = GetToken();

  00293	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 130  : 					this->m_iEventItemDropRate = TokenNumber;

  00298	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0029e	e8 00 00 00 00	 call	 __ftol2_sse
  002a3	89 87 14 01 00
	00		 mov	 DWORD PTR [edi+276], eax

; 131  : 
; 132  : 					Token = GetToken();

  002a9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 133  : 					this->m_iItemDropRate = TokenNumber;

  002ae	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002b4	e8 00 00 00 00	 call	 __ftol2_sse
  002b9	89 87 18 01 00
	00		 mov	 DWORD PTR [edi+280], eax

; 134  : 
; 135  : 					Token = GetToken();

  002bf	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 136  : 					this->m_iExItemDropRate = TokenNumber;

  002c4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002ca	e8 00 00 00 00	 call	 __ftol2_sse

; 137  : 
; 138  : 					char szTemp[256];
; 139  : 
; 140  : 					wsprintf(szTemp, "[%s] Eventitemnum = %d,EventItemLevel = %d, EventItemDropRate = %d, ItemDropRate = %d, ExItemDropRate = %d",
; 141  : 						this->m_sEventName, this->m_iEventItemType, this->m_iEventItemLevel, this->m_iEventItemDropRate, this->m_iItemDropRate, this->m_iExItemDropRate);

  002cf	8b 97 18 01 00
	00		 mov	 edx, DWORD PTR [edi+280]
  002d5	8b 8f 0c 01 00
	00		 mov	 ecx, DWORD PTR [edi+268]
  002db	50		 push	 eax
  002dc	52		 push	 edx
  002dd	8b 97 08 01 00
	00		 mov	 edx, DWORD PTR [edi+264]
  002e3	89 87 1c 01 00
	00		 mov	 DWORD PTR [edi+284], eax
  002e9	8b 87 14 01 00
	00		 mov	 eax, DWORD PTR [edi+276]
  002ef	50		 push	 eax
  002f0	51		 push	 ecx
  002f1	52		 push	 edx
  002f2	53		 push	 ebx
  002f3	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$153534[ebp]
  002f9	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@LIMNLNHJ@?$FL?$CFs?$FN?5Eventitemnum?5?$DN?5?$CFd?0EventItem@
  002fe	50		 push	 eax
  002ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 142  : 					LogAdd(LOG_BLACK, szTemp);

  00305	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$153534[ebp]
  0030b	51		 push	 ecx
  0030c	6a 00		 push	 0
  0030e	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00313	83 c4 28	 add	 esp, 40			; 00000028H

; 143  : 				}

  00316	e9 c6 fe ff ff	 jmp	 $LL11@LoadItem
$LN12@LoadItem:

; 144  : 			}
; 145  : 			else if ( st == 2 )

  0031b	83 f8 02	 cmp	 eax, 2
  0031e	0f 85 5e 02 00
	00		 jne	 $LN57@LoadItem
  00324	8d b4 df 9d 01
	00 00		 lea	 esi, DWORD PTR [edi+ebx*8+413]
  0032b	eb 03 8d 49 00	 npad	 5
$LL5@LoadItem:

; 146  : 			{
; 147  : 				while ( true )
; 148  : 				{
; 149  : 					Token = GetToken();

  00330	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 150  : 
; 151  : 					if ( Token == 0 )

  00335	85 c0		 test	 eax, eax
  00337	75 37		 jne	 SHORT $LN2@LoadItem

; 152  : 					{
; 153  : 						if ( strcmp("end", TokenString) == 0 )

  00339	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  0033e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL51@LoadItem:
  00343	8a 10		 mov	 dl, BYTE PTR [eax]
  00345	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00347	75 1a		 jne	 SHORT $LN52@LoadItem
  00349	84 d2		 test	 dl, dl
  0034b	74 12		 je	 SHORT $LN53@LoadItem
  0034d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00350	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00353	75 0e		 jne	 SHORT $LN52@LoadItem
  00355	83 c0 02	 add	 eax, 2
  00358	83 c1 02	 add	 ecx, 2
  0035b	84 d2		 test	 dl, dl
  0035d	75 e4		 jne	 SHORT $LL51@LoadItem
$LN53@LoadItem:
  0035f	33 c0		 xor	 eax, eax
  00361	eb 05		 jmp	 SHORT $LN54@LoadItem
$LN52@LoadItem:
  00363	1b c0		 sbb	 eax, eax
  00365	83 d8 ff	 sbb	 eax, -1
$LN54@LoadItem:
  00368	85 c0		 test	 eax, eax
  0036a	0f 84 0c 02 00
	00		 je	 $LN60@LoadItem
$LN2@LoadItem:

; 154  : 						{
; 155  : 							break;
; 156  : 						}
; 157  : 					}
; 158  : 
; 159  : 					this->BagObject[n].m_type = TokenNumber;

  00370	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00376	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv545[ebp]
  0037c	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv545[ebp]
  00383	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00388	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv542[ebp], eax
  0038e	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv542[ebp]
  00394	db 9d f4 fe ff
	ff		 fistp	 DWORD PTR tv540[ebp]
  0039a	0f b6 95 f4 fe
	ff ff		 movzx	 edx, BYTE PTR tv540[ebp]
  003a1	88 56 ff	 mov	 BYTE PTR [esi-1], dl
  003a4	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv545[ebp]

; 160  : 
; 161  : 					Token = GetToken();

  003aa	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 162  : 					this->BagObject[n].m_index = TokenNumber;

  003af	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003b5	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv537[ebp]
  003bb	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv537[ebp]
  003c2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  003c7	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv534[ebp], eax
  003cd	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv534[ebp]
  003d3	db 9d f4 fe ff
	ff		 fistp	 DWORD PTR tv532[ebp]
  003d9	0f b6 85 f4 fe
	ff ff		 movzx	 eax, BYTE PTR tv532[ebp]
  003e0	88 06		 mov	 BYTE PTR [esi], al
  003e2	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv537[ebp]

; 163  : 
; 164  : 					Token = GetToken();

  003e8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 165  : 					this->BagObject[n].m_minLevel = TokenNumber;

  003ed	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003f3	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv529[ebp]
  003f9	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv529[ebp]
  00400	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00405	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv526[ebp], eax
  0040b	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv526[ebp]
  00411	db 9d f4 fe ff
	ff		 fistp	 DWORD PTR tv524[ebp]
  00417	0f b6 8d f4 fe
	ff ff		 movzx	 ecx, BYTE PTR tv524[ebp]
  0041e	88 4e 01	 mov	 BYTE PTR [esi+1], cl
  00421	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv529[ebp]

; 166  : 
; 167  : 					Token = GetToken();

  00427	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 168  : 					this->BagObject[n].m_maxLevel = TokenNumber;

  0042c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00432	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv521[ebp]
  00438	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv521[ebp]
  0043f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00444	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv518[ebp], eax
  0044a	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv518[ebp]
  00450	db 9d f4 fe ff
	ff		 fistp	 DWORD PTR tv516[ebp]
  00456	0f b6 95 f4 fe
	ff ff		 movzx	 edx, BYTE PTR tv516[ebp]
  0045d	88 56 02	 mov	 BYTE PTR [esi+2], dl
  00460	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv521[ebp]

; 169  : 
; 170  : 					Token = GetToken();

  00466	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 171  : 					this->BagObject[n].m_isskill = TokenNumber;

  0046b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00471	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv513[ebp]
  00477	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv513[ebp]
  0047e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00483	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv510[ebp], eax
  00489	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv510[ebp]
  0048f	db 9d f4 fe ff
	ff		 fistp	 DWORD PTR tv508[ebp]
  00495	0f b6 85 f4 fe
	ff ff		 movzx	 eax, BYTE PTR tv508[ebp]
  0049c	88 46 03	 mov	 BYTE PTR [esi+3], al
  0049f	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv513[ebp]

; 172  : 
; 173  : 					Token = GetToken();

  004a5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 174  : 					this->BagObject[n].m_isluck = TokenNumber;

  004aa	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004b0	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv505[ebp]
  004b6	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv505[ebp]
  004bd	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  004c2	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv502[ebp], eax
  004c8	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv502[ebp]
  004ce	db 9d f4 fe ff
	ff		 fistp	 DWORD PTR tv500[ebp]
  004d4	0f b6 8d f4 fe
	ff ff		 movzx	 ecx, BYTE PTR tv500[ebp]
  004db	88 4e 04	 mov	 BYTE PTR [esi+4], cl
  004de	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv505[ebp]

; 175  : 
; 176  : 					Token = GetToken();

  004e4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 177  : 					this->BagObject[n].m_isoption = TokenNumber;

  004e9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004ef	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv497[ebp]
  004f5	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv497[ebp]
  004fc	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00501	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv494[ebp], eax
  00507	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv494[ebp]
  0050d	db 9d f4 fe ff
	ff		 fistp	 DWORD PTR tv492[ebp]
  00513	0f b6 95 f4 fe
	ff ff		 movzx	 edx, BYTE PTR tv492[ebp]
  0051a	88 56 05	 mov	 BYTE PTR [esi+5], dl
  0051d	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv497[ebp]

; 178  : 
; 179  : 					Token = GetToken();

  00523	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 180  : 					this->BagObject[n].m_isexitem = TokenNumber;

  00528	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0052e	d9 bd fa fe ff
	ff		 fnstcw	 WORD PTR tv489[ebp]
  00534	0f b7 85 fa fe
	ff ff		 movzx	 eax, WORD PTR tv489[ebp]
  0053b	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00540	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv486[ebp], eax
  00546	d9 ad f4 fe ff
	ff		 fldcw	 WORD PTR tv486[ebp]

; 181  : 
; 182  : 					n++;

  0054c	43		 inc	 ebx
  0054d	83 c6 08	 add	 esi, 8
  00550	db 9d f4 fe ff
	ff		 fistp	 DWORD PTR tv484[ebp]
  00556	0f b6 85 f4 fe
	ff ff		 movzx	 eax, BYTE PTR tv484[ebp]
  0055d	88 46 fe	 mov	 BYTE PTR [esi-2], al

; 183  : 					this->m_iBagObjectCount++;

  00560	ff 87 20 01 00
	00		 inc	 DWORD PTR [edi+288]

; 184  : 
; 185  : 					if ( this->m_iBagObjectCount > MAX_ITEMBAG_ATTR-1 )

  00566	81 bf 20 01 00
	00 95 00 00 00	 cmp	 DWORD PTR [edi+288], 149 ; 00000095H
  00570	d9 ad fa fe ff
	ff		 fldcw	 WORD PTR tv489[ebp]
  00576	0f 8e b4 fd ff
	ff		 jle	 $LL5@LoadItem
$LN60@LoadItem:

; 181  : 
; 182  : 					n++;

  0057c	89 9d f0 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], ebx
$LN57@LoadItem:

; 52   : 
; 53   : 	while ( true )
; 54   : 	{
; 55   : 		Token = GetToken();

  00582	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 56   : 
; 57   : 		if ( Token == 2 )

  00587	83 f8 02	 cmp	 eax, 2
  0058a	0f 85 f0 fa ff
	ff		 jne	 $LL23@LoadItem
  00590	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _script_file$GSCopy$[ebp]
$LN41@LoadItem:

; 186  : 					{
; 187  : 						break;
; 188  : 					}
; 189  : 				}
; 190  : 			}
; 191  : 		}
; 192  : 	}
; 193  : 
; 194  : 	fclose(SMDFile);

  00596	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  0059c	51		 push	 ecx
  0059d	e8 00 00 00 00	 call	 _fclose
  005a2	83 c4 04	 add	 esp, 4

; 195  : 	LogAdd(LOG_BLACK, lMsg.Get(MSGGET(1, 198)), script_file);

  005a5	56		 push	 esi
  005a6	68 c6 01 00 00	 push	 454			; 000001c6H
  005ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  005b0	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  005b5	50		 push	 eax
  005b6	6a 00		 push	 0
  005b8	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  005bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 196  : 	this->m_bLoad = TRUE;

  005c0	c7 47 04 01 00
	00 00		 mov	 DWORD PTR [edi+4], 1
  005c7	5f		 pop	 edi
  005c8	5e		 pop	 esi
  005c9	5b		 pop	 ebx

; 197  : }

  005ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005cd	33 cd		 xor	 ecx, ebp
  005cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005d4	8b e5		 mov	 esp, ebp
  005d6	5d		 pop	 ebp
  005d7	c2 04 00	 ret	 4
$LN56@LoadItem:

; 184  : 
; 185  : 					if ( this->m_iBagObjectCount > MAX_ITEMBAG_ATTR-1 )

  005da	8b 9d f0 fe ff
	ff		 mov	 ebx, DWORD PTR _n$[ebp]
  005e0	eb a0		 jmp	 SHORT $LN57@LoadItem
$LN37@LoadItem:

; 83   : 					{
; 84   : 						MsgBox("ExEvent ItemBag LoadFail [%s]", script_file);

  005e2	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _script_file$GSCopy$[ebp]
  005e8	52		 push	 edx
  005e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@PPHECIOP@ExEvent?5ItemBag?5LoadFail?5?$FL?$CFs?$FN?$AA@
  005ee	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 197  : }

  005f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005f6	83 c4 08	 add	 esp, 8
  005f9	5f		 pop	 edi
  005fa	5e		 pop	 esi
  005fb	33 cd		 xor	 ecx, ebp
  005fd	5b		 pop	 ebx
  005fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00603	8b e5		 mov	 esp, ebp
  00605	5d		 pop	 ebp
  00606	c2 04 00	 ret	 4
?LoadItem@CItemBagEx@@QAEXPAD@Z ENDP			; CItemBagEx::LoadItem
_TEXT	ENDS
PUBLIC	?GetLevel@CItemBagEx@@AAEEH@Z			; CItemBagEx::GetLevel
EXTRN	_rand:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GetLevel@CItemBagEx@@AAEEH@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
?GetLevel@CItemBagEx@@AAEEH@Z PROC			; CItemBagEx::GetLevel, COMDAT
; _this$ = ecx

; 201  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 	if ( n <0 || n > MAX_ITEMBAG_ATTR-1 )

  00003	8b 55 08	 mov	 edx, DWORD PTR _n$[ebp]
  00006	81 fa 95 00 00
	00		 cmp	 edx, 149		; 00000095H
  0000c	77 36		 ja	 SHORT $LN2@GetLevel

; 205  : 	}
; 206  : 
; 207  : 	if ( this->BagObject[n].m_minLevel == this->BagObject[n].m_maxLevel )

  0000e	8a 84 d1 9e 01
	00 00		 mov	 al, BYTE PTR [ecx+edx*8+414]
  00015	56		 push	 esi
  00016	8d b4 d1 9e 01
	00 00		 lea	 esi, DWORD PTR [ecx+edx*8+414]
  0001d	8a 8c d1 9f 01
	00 00		 mov	 cl, BYTE PTR [ecx+edx*8+415]
  00024	3a c1		 cmp	 al, cl

; 208  : 	{
; 209  : 		return this->BagObject[n].m_minLevel;

  00026	74 17		 je	 SHORT $LN6@GetLevel

; 210  : 	}
; 211  : 
; 212  : 	int sub = (this->BagObject[n].m_maxLevel - this->BagObject[n].m_minLevel) + 1;

  00028	57		 push	 edi
  00029	0f b6 c0	 movzx	 eax, al
  0002c	0f b6 f9	 movzx	 edi, cl
  0002f	2b f8		 sub	 edi, eax
  00031	47		 inc	 edi

; 213  : 	int level = this->BagObject[n].m_minLevel + (rand()%sub);

  00032	e8 00 00 00 00	 call	 _rand
  00037	99		 cdq
  00038	f7 ff		 idiv	 edi
  0003a	5f		 pop	 edi
  0003b	8b c2		 mov	 eax, edx
  0003d	02 06		 add	 al, BYTE PTR [esi]
$LN6@GetLevel:
  0003f	5e		 pop	 esi

; 214  : 
; 215  : 	return level;
; 216  : }

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
$LN2@GetLevel:

; 203  : 	{
; 204  : 		return 0;

  00044	32 c0		 xor	 al, al

; 214  : 
; 215  : 	return level;
; 216  : }

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?GetLevel@CItemBagEx@@AAEEH@Z ENDP			; CItemBagEx::GetLevel
_TEXT	ENDS
PUBLIC	?IsEnableEventItemDrop@CItemBagEx@@AAEHH@Z	; CItemBagEx::IsEnableEventItemDrop
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:BYTE			; gObj
; Function compile flags: /Ogtp
;	COMDAT ?IsEnableEventItemDrop@CItemBagEx@@AAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?IsEnableEventItemDrop@CItemBagEx@@AAEHH@Z PROC		; CItemBagEx::IsEnableEventItemDrop, COMDAT
; _this$ = ecx

; 219  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 220  : 	int iMapNumber = gObj[aIndex].MapNumber;

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0000c	0f b6 90 09 01
	00 00		 movzx	 edx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00013	56		 push	 esi

; 221  : 
; 222  : 	if ( this->DropMapInfo[iMapNumber].m_bIsDrop == FALSE )

  00014	8d 34 51	 lea	 esi, DWORD PTR [ecx+edx*2]
  00017	80 bc 16 24 01
	00 00 00	 cmp	 BYTE PTR [esi+edx+292], 0

; 223  : 	{
; 224  : 		return FALSE;

  0001f	74 2d		 je	 SHORT $LN1@IsEnableEv

; 225  : 	}
; 226  : 
; 227  : 	int iLevel = gObj[aIndex].Level;

  00021	0f bf 80 9c 00
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+156]

; 228  : 
; 229  : 	if  ( iLevel < this->DropMapInfo[iMapNumber].m_MinMonsterLevel || iLevel > this->DropMapInfo[iMapNumber].m_MaxMonsterLevel)

  00028	0f b6 b4 16 25
	01 00 00	 movzx	 esi, BYTE PTR [esi+edx+293]
  00030	3b c6		 cmp	 eax, esi
  00032	7c 1a		 jl	 SHORT $LN1@IsEnableEv
  00034	8d 8c 51 c4 00
	00 00		 lea	 ecx, DWORD PTR [ecx+edx*2+196]
  0003b	0f b6 54 0a 62	 movzx	 edx, BYTE PTR [edx+ecx+98]
  00040	3b c2		 cmp	 eax, edx
  00042	7f 0a		 jg	 SHORT $LN1@IsEnableEv

; 232  : 	}
; 233  : 
; 234  : 	return TRUE;

  00044	b8 01 00 00 00	 mov	 eax, 1
  00049	5e		 pop	 esi

; 235  : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
$LN1@IsEnableEv:

; 230  : 	{
; 231  : 		return FALSE;

  0004e	33 c0		 xor	 eax, eax
  00050	5e		 pop	 esi

; 235  : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?IsEnableEventItemDrop@CItemBagEx@@AAEHH@Z ENDP		; CItemBagEx::IsEnableEventItemDrop
_TEXT	ENDS
PUBLIC	??_C@_0CP@CFLKNDIJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5MonsterEventItemDr@ ; `string'
PUBLIC	?DropEventItem@CItemBagEx@@QAEHH@Z		; CItemBagEx::DropEventItem
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterTopHitDamageUser
;	COMDAT ??_C@_0CP@CFLKNDIJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5MonsterEventItemDr@
CONST	SEGMENT
??_C@_0CP@CFLKNDIJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5MonsterEventItemDr@ DB '['
	DB	'%s][%s] [%s] MonsterEventItemDrop (%d)(%d/%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DropEventItem@CItemBagEx@@QAEHH@Z
_TEXT	SEGMENT
_ei$153570 = -8						; size = 4
_eil$153571 = -4					; size = 4
_y$153573 = 8						; size = 4
_aIndex$ = 8						; size = 4
?DropEventItem@CItemBagEx@@QAEHH@Z PROC			; CItemBagEx::DropEventItem, COMDAT
; _this$ = ecx

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 240  : 	if ( this->m_bLoad == FALSE )

  00009	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0000d	75 09		 jne	 SHORT $LN3@DropEventI

; 241  : 	{
; 242  : 		return FALSE;

  0000f	33 c0		 xor	 eax, eax
  00011	5f		 pop	 edi

; 274  : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@DropEventI:
  00018	56		 push	 esi

; 243  : 	}
; 244  : 
; 245  : 	if ( this->IsEnableEventItemDrop(aIndex) == FALSE )

  00019	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ?IsEnableEventItemDrop@CItemBagEx@@AAEHH@Z ; CItemBagEx::IsEnableEventItemDrop
  00022	85 c0		 test	 eax, eax

; 246  : 	{
; 247  : 		return FALSE;

  00024	0f 84 b2 00 00
	00		 je	 $LN1@DropEventI

; 248  : 	}
; 249  : 
; 250  : 	LPOBJ lpObj = &gObj[aIndex];

  0002a	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00030	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 251  : 
; 252  : 	if ( (rand()%1000) < this->m_iEventItemDropRate )

  00036	e8 00 00 00 00	 call	 _rand
  0003b	99		 cdq
  0003c	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00041	f7 f9		 idiv	 ecx
  00043	3b 97 14 01 00
	00		 cmp	 edx, DWORD PTR [edi+276]
  00049	0f 8d 8d 00 00
	00		 jge	 $LN1@DropEventI

; 253  : 	{
; 254  : 		int ei;
; 255  : 		int eil;
; 256  : 		int x;
; 257  : 		int y;
; 258  : 		float dur = 0;
; 259  : 		dur = 255.0;
; 260  : 
; 261  : 		x = lpObj->X;
; 262  : 		y = lpObj->Y;

  0004f	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]

; 263  : 		eil = this->m_iEventItemLevel;

  00056	8b 87 0c 01 00
	00		 mov	 eax, DWORD PTR [edi+268]

; 264  : 		ei = this->m_iEventItemType;

  0005c	8b 8f 08 01 00
	00		 mov	 ecx, DWORD PTR [edi+264]
  00062	53		 push	 ebx
  00063	0f bf 9e 04 01
	00 00		 movsx	 ebx, WORD PTR [esi+260]

; 265  : 
; 266  : 		int thdu = gObjMonsterTopHitDamageUser(lpObj);

  0006a	56		 push	 esi
  0006b	89 55 08	 mov	 DWORD PTR _y$153573[ebp], edx
  0006e	89 45 fc	 mov	 DWORD PTR _eil$153571[ebp], eax
  00071	89 4d f8	 mov	 DWORD PTR _ei$153570[ebp], ecx
  00074	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 267  : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x ,y, ei, eil, dur, 0, 0, 0, thdu, 0, 0);

  00079	8b 55 fc	 mov	 edx, DWORD PTR _eil$153571[ebp]
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _y$153573[ebp]
  0007f	6a 00		 push	 0
  00081	6a 00		 push	 0
  00083	50		 push	 eax
  00084	8b 45 f8	 mov	 eax, DWORD PTR _ei$153570[ebp]
  00087	6a 00		 push	 0
  00089	6a 00		 push	 0
  0008b	6a 00		 push	 0
  0008d	68 ff 00 00 00	 push	 255			; 000000ffH
  00092	52		 push	 edx
  00093	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR [esi+265]
  0009a	50		 push	 eax
  0009b	8b 06		 mov	 eax, DWORD PTR [esi]
  0009d	51		 push	 ecx
  0009e	53		 push	 ebx
  0009f	52		 push	 edx
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 268  : 		LogAdd(LOG_BLACK, "[%s][%s] [%s] MonsterEventItemDrop (%d)(%d/%d)", lpObj->AccountID, lpObj->Name, 
; 269  : 			this->m_sEventName, lpObj->MapNumber, x, y);

  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _y$153573[ebp]
  000a9	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR [esi+265]
  000b0	51		 push	 ecx
  000b1	53		 push	 ebx
  000b2	52		 push	 edx
  000b3	83 c7 08	 add	 edi, 8
  000b6	57		 push	 edi
  000b7	8d 46 6f	 lea	 eax, DWORD PTR [esi+111]
  000ba	50		 push	 eax
  000bb	83 c6 64	 add	 esi, 100		; 00000064H
  000be	56		 push	 esi
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@CFLKNDIJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5MonsterEventItemDr@
  000c4	6a 00		 push	 0
  000c6	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000cb	83 c4 58	 add	 esp, 88			; 00000058H
  000ce	5b		 pop	 ebx
  000cf	5e		 pop	 esi

; 270  : 		return TRUE;

  000d0	b8 01 00 00 00	 mov	 eax, 1
  000d5	5f		 pop	 edi

; 274  : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 04 00	 ret	 4
$LN1@DropEventI:
  000dc	5e		 pop	 esi

; 271  : 	}
; 272  : 
; 273  : 	return FALSE;

  000dd	33 c0		 xor	 eax, eax
  000df	5f		 pop	 edi

; 274  : }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 04 00	 ret	 4
?DropEventItem@CItemBagEx@@QAEHH@Z ENDP			; CItemBagEx::DropEventItem
_TEXT	ENDS
PUBLIC	?GetMinLevel@CItemBagEx@@QAEEH@Z		; CItemBagEx::GetMinLevel
; Function compile flags: /Ogtp
;	COMDAT ?GetMinLevel@CItemBagEx@@QAEEH@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
?GetMinLevel@CItemBagEx@@QAEEH@Z PROC			; CItemBagEx::GetMinLevel, COMDAT
; _this$ = ecx

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 371  : 	if ( n<0 || n > MAX_ITEMBAG_ATTR-1 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00006	3d 95 00 00 00	 cmp	 eax, 149		; 00000095H
  0000b	77 0b		 ja	 SHORT $LN1@GetMinLeve

; 373  : 
; 374  : 	return this->BagObject[n].m_minLevel;

  0000d	8a 84 c1 9e 01
	00 00		 mov	 al, BYTE PTR [ecx+eax*8+414]

; 375  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN1@GetMinLeve:

; 372  : 		return 0;

  00018	32 c0		 xor	 al, al

; 375  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?GetMinLevel@CItemBagEx@@QAEEH@Z ENDP			; CItemBagEx::GetMinLevel
_TEXT	ENDS
PUBLIC	?GetMaxLevel@CItemBagEx@@QAEEH@Z		; CItemBagEx::GetMaxLevel
; Function compile flags: /Ogtp
;	COMDAT ?GetMaxLevel@CItemBagEx@@QAEEH@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
?GetMaxLevel@CItemBagEx@@QAEEH@Z PROC			; CItemBagEx::GetMaxLevel, COMDAT
; _this$ = ecx

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 379  : 	if ( n<0 || n > MAX_ITEMBAG_ATTR-1 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00006	3d 95 00 00 00	 cmp	 eax, 149		; 00000095H
  0000b	77 0b		 ja	 SHORT $LN1@GetMaxLeve

; 381  : 
; 382  : 	return this->BagObject[n].m_maxLevel;

  0000d	8a 84 c1 9f 01
	00 00		 mov	 al, BYTE PTR [ecx+eax*8+415]

; 383  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN1@GetMaxLeve:

; 380  : 		return 0;

  00018	32 c0		 xor	 al, al

; 383  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?GetMaxLevel@CItemBagEx@@QAEEH@Z ENDP			; CItemBagEx::GetMaxLevel
_TEXT	ENDS
PUBLIC	??0CItemBagAttrEx@@QAE@XZ			; CItemBagAttrEx::CItemBagAttrEx
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itembagex.h
;	COMDAT ??0CItemBagAttrEx@@QAE@XZ
_TEXT	SEGMENT
??0CItemBagAttrEx@@QAE@XZ PROC				; CItemBagAttrEx::CItemBagAttrEx, COMDAT
; _this$ = ecx

; 18   : 	CItemBagAttrEx()	// line : 26

  00000	8b c1		 mov	 eax, ecx

; 19   : 	{
; 20   : 		this->m_type = 0;

  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 21   : 		this->m_index = 0;
; 22   : 		this->m_minLevel = 0;
; 23   : 		this->m_maxLevel = 0;
; 24   : 		this->m_isskill = 0;

  00008	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 25   : 		this->m_isluck = 0;
; 26   : 		this->m_isoption = 0;
; 27   : 		this->m_isexitem = 0;
; 28   : 	}	// line : 36

  0000f	c3		 ret	 0
??0CItemBagAttrEx@@QAE@XZ ENDP				; CItemBagAttrEx::CItemBagAttrEx
_TEXT	ENDS
PUBLIC	?Init@CItemBagDropMapInfo@@QAEXXZ		; CItemBagDropMapInfo::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@CItemBagDropMapInfo@@QAEXXZ
_TEXT	SEGMENT
?Init@CItemBagDropMapInfo@@QAEXXZ PROC			; CItemBagDropMapInfo::Init, COMDAT
; _this$ = ecx

; 53   : 		this->m_bIsDrop = false;

  00000	32 c0		 xor	 al, al
  00002	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0

; 54   : 		this->m_MinMonsterLevel = 0;
; 55   : 		this->m_MaxMonsterLevel = 0;

  00007	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 56   : 	};	// line : 56

  0000a	c3		 ret	 0
?Init@CItemBagDropMapInfo@@QAEXXZ ENDP			; CItemBagDropMapInfo::Init
_TEXT	ENDS
PUBLIC	?GetBagCount@CItemBagEx@@AAEHXZ			; CItemBagEx::GetBagCount
; Function compile flags: /Ogtp
;	COMDAT ?GetBagCount@CItemBagEx@@AAEHXZ
_TEXT	SEGMENT
?GetBagCount@CItemBagEx@@AAEHXZ PROC			; CItemBagEx::GetBagCount, COMDAT
; _this$ = ecx

; 87   : 	int GetBagCount(){return this->m_iBagObjectCount;}

  00000	8b 81 20 01 00
	00		 mov	 eax, DWORD PTR [ecx+288]
  00006	c3		 ret	 0
?GetBagCount@CItemBagEx@@AAEHXZ ENDP			; CItemBagEx::GetBagCount
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCItemBagEx@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCItemBagEx@@UAEPAXI@Z PROC				; CItemBagEx::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CItemBagEx@@UAE@XZ	; CItemBagEx::~CItemBagEx
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCItemBagEx@@UAEPAXI@Z ENDP				; CItemBagEx::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Init@CItemBagEx@@QAEXPAD@Z			; CItemBagEx::Init
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itembagex.cpp
;	COMDAT ?Init@CItemBagEx@@QAEXPAD@Z
_TEXT	SEGMENT
_name$ = 8						; size = 4
?Init@CItemBagEx@@QAEXPAD@Z PROC			; CItemBagEx::Init, COMDAT
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	this->m_bLoad = FALSE;

  00003	33 c0		 xor	 eax, eax
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 26   : 	this->m_sEventName[0] = 0;

  0000b	88 46 08	 mov	 BYTE PTR [esi+8], al

; 27   : 	this->m_iEventItemType = -1;
; 28   : 	this->m_iEventItemLevel = 0;

  0000e	89 86 0c 01 00
	00		 mov	 DWORD PTR [esi+268], eax

; 29   : 	this->m_iDropZen = 0;

  00014	89 86 10 01 00
	00		 mov	 DWORD PTR [esi+272], eax

; 30   : 	this->m_iEventItemDropRate = 0;

  0001a	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax

; 31   : 	this->m_iItemDropRate = 0;

  00020	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax

; 32   : 	this->m_iExItemDropRate = 0;

  00026	89 86 1c 01 00
	00		 mov	 DWORD PTR [esi+284], eax

; 33   : 	this->m_iBagObjectCount = 0;

  0002c	89 86 20 01 00
	00		 mov	 DWORD PTR [esi+288], eax

; 34   : 
; 35   : 	this->LoadItem(gDirPath.GetNewPath(name));

  00032	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00035	50		 push	 eax
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0003b	c7 86 08 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+264], -1
  00045	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0004a	50		 push	 eax
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?LoadItem@CItemBagEx@@QAEXPAD@Z ; CItemBagEx::LoadItem
  00052	5e		 pop	 esi

; 36   : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?Init@CItemBagEx@@QAEXPAD@Z ENDP			; CItemBagEx::Init
_TEXT	ENDS
PUBLIC	??_C@_0FF@LDONOBLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5Event?5ItemDrop?5?3?5?$CI@ ; `string'
PUBLIC	?DropItem@CItemBagEx@@QAEHH@Z			; CItemBagEx::DropItem
EXTRN	?MoneyItemDrop@MapClass@@QAEHHHH@Z:PROC		; MapClass::MoneyItemDrop
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?NewOptionRand@@YAEH@Z:PROC			; NewOptionRand
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
;	COMDAT ??_C@_0FF@LDONOBLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5Event?5ItemDrop?5?3?5?$CI@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itembagex.h
CONST	SEGMENT
??_C@_0FF@LDONOBLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5Event?5ItemDrop?5?3?5?$CI@ DB '['
	DB	'%s][%s] [%s] Event ItemDrop : (%d)(%d/%d) Item:(%s)%d Level:%'
	DB	'd op1:%d op2:%d op3:%d', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itembagex.cpp
CONST	ENDS
;	COMDAT ?DropItem@CItemBagEx@@QAEHH@Z
_TEXT	SEGMENT
_ExOption$ = -28					; size = 4
_x$ = -24						; size = 4
_y$ = -20						; size = 4
_level$ = -16						; size = 4
_Option2$ = -12						; size = 4
_Option1$ = -8						; size = 4
_Option3$ = -4						; size = 4
_DropItemNum$ = 8					; size = 4
_aIndex$ = 8						; size = 4
?DropItem@CItemBagEx@@QAEHH@Z PROC			; CItemBagEx::DropItem, COMDAT
; _this$ = ecx

; 278  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 279  : 	if ( this->m_bLoad == FALSE )

  00009	33 c0		 xor	 eax, eax
  0000b	39 43 04	 cmp	 DWORD PTR [ebx+4], eax
  0000e	75 07		 jne	 SHORT $LN14@DropItem
  00010	5b		 pop	 ebx

; 366  : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
$LN14@DropItem:
  00017	56		 push	 esi

; 280  : 	{
; 281  : 		return FALSE;
; 282  : 	}
; 283  : 
; 284  : 	float dur;
; 285  : 	int type;
; 286  : 	int level;
; 287  : 	int x;
; 288  : 	int y;
; 289  : 	int Option1 = 0;
; 290  : 	int Option2 = 0;
; 291  : 	int Option3 = 0;
; 292  : 	int DropItemNum;
; 293  : 	int ExOption = 0;
; 294  : 	LPOBJ lpObj = &gObj[aIndex];

  00018	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001b	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00021	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00027	89 45 f8	 mov	 DWORD PTR _Option1$[ebp], eax
  0002a	89 45 f4	 mov	 DWORD PTR _Option2$[ebp], eax
  0002d	89 45 fc	 mov	 DWORD PTR _Option3$[ebp], eax
  00030	89 45 e4	 mov	 DWORD PTR _ExOption$[ebp], eax

; 295  : 
; 296  : 	if ( this->GetBagCount() > 0 )

  00033	39 83 20 01 00
	00		 cmp	 DWORD PTR [ebx+288], eax
  00039	0f 8e 01 02 00
	00		 jle	 $LN12@DropItem

; 297  : 	{
; 298  : 		if ( (rand()%100) < this->m_iItemDropRate )

  0003f	e8 00 00 00 00	 call	 _rand
  00044	99		 cdq
  00045	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0004a	f7 f9		 idiv	 ecx
  0004c	3b 93 18 01 00
	00		 cmp	 edx, DWORD PTR [ebx+280]
  00052	0f 8d e8 01 00
	00		 jge	 $LN12@DropItem

; 299  : 		{
; 300  : 			DropItemNum =  rand() % this->GetBagCount();

  00058	57		 push	 edi
  00059	8b bb 20 01 00
	00		 mov	 edi, DWORD PTR [ebx+288]
  0005f	e8 00 00 00 00	 call	 _rand
  00064	99		 cdq
  00065	f7 ff		 idiv	 edi

; 301  : 			dur = 0;
; 302  : 			x = lpObj->X;
; 303  : 			y = lpObj->Y;

  00067	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]

; 304  : 			level = this->GetLevel(DropItemNum);

  0006e	8b cb		 mov	 ecx, ebx
  00070	89 45 ec	 mov	 DWORD PTR _y$[ebp], eax
  00073	8b fa		 mov	 edi, edx
  00075	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  0007c	57		 push	 edi
  0007d	89 7d 08	 mov	 DWORD PTR _DropItemNum$[ebp], edi
  00080	89 55 e8	 mov	 DWORD PTR _x$[ebp], edx
  00083	e8 00 00 00 00	 call	 ?GetLevel@CItemBagEx@@AAEEH@Z ; CItemBagEx::GetLevel

; 305  : 			type = ItemGetNumberMake(this->BagObject[DropItemNum].m_type, this->BagObject[DropItemNum].m_index);

  00088	0f b6 94 fb 9d
	01 00 00	 movzx	 edx, BYTE PTR [ebx+edi*8+413]
  00090	0f b6 c8	 movzx	 ecx, al
  00093	0f b6 84 fb 9c
	01 00 00	 movzx	 eax, BYTE PTR [ebx+edi*8+412]
  0009b	52		 push	 edx
  0009c	50		 push	 eax
  0009d	89 4d f0	 mov	 DWORD PTR _level$[ebp], ecx
  000a0	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  000a5	8b f8		 mov	 edi, eax
  000a7	83 c4 08	 add	 esp, 8

; 306  : 
; 307  : 			if ( type == -1 )

  000aa	83 ff ff	 cmp	 edi, -1
  000ad	75 0b		 jne	 SHORT $LN11@DropItem

; 308  : 			{
; 309  : 				return FALSE;

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	33 c0		 xor	 eax, eax
  000b3	5b		 pop	 ebx

; 366  : }

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 04 00	 ret	 4
$LN11@DropItem:

; 310  : 			}
; 311  : 
; 312  : 			if ( this->BagObject[DropItemNum].m_isskill != 0 )

  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _DropItemNum$[ebp]
  000bd	80 bc cb a0 01
	00 00 00	 cmp	 BYTE PTR [ebx+ecx*8+416], 0
  000c5	74 14		 je	 SHORT $LN21@DropItem

; 313  : 			{
; 314  : 				Option1 = rand()%2;

  000c7	e8 00 00 00 00	 call	 _rand
  000cc	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000d1	79 05		 jns	 SHORT $LN28@DropItem
  000d3	48		 dec	 eax
  000d4	83 c8 fe	 or	 eax, -2			; fffffffeH
  000d7	40		 inc	 eax
$LN28@DropItem:
  000d8	89 45 f8	 mov	 DWORD PTR _Option1$[ebp], eax
$LN21@DropItem:

; 315  : 			}
; 316  : 
; 317  : 			if ( this->BagObject[DropItemNum].m_isluck != 0 )

  000db	8b 55 08	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  000de	80 bc d3 a1 01
	00 00 00	 cmp	 BYTE PTR [ebx+edx*8+417], 0
  000e6	74 14		 je	 SHORT $LN22@DropItem

; 318  : 			{
; 319  : 				Option2 = rand()%2;

  000e8	e8 00 00 00 00	 call	 _rand
  000ed	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000f2	79 05		 jns	 SHORT $LN29@DropItem
  000f4	48		 dec	 eax
  000f5	83 c8 fe	 or	 eax, -2			; fffffffeH
  000f8	40		 inc	 eax
$LN29@DropItem:
  000f9	89 45 f4	 mov	 DWORD PTR _Option2$[ebp], eax
$LN22@DropItem:

; 320  : 			}
; 321  : 
; 322  : 			if ( this->BagObject[DropItemNum].m_isoption != 0 )

  000fc	8b 45 08	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  000ff	80 bc c3 a2 01
	00 00 00	 cmp	 BYTE PTR [ebx+eax*8+418], 0
  00107	74 2b		 je	 SHORT $LN23@DropItem

; 323  : 			{
; 324  : 				if ( rand()%5 < 1 )

  00109	e8 00 00 00 00	 call	 _rand
  0010e	99		 cdq
  0010f	b9 05 00 00 00	 mov	 ecx, 5
  00114	f7 f9		 idiv	 ecx
  00116	83 fa 01	 cmp	 edx, 1
  00119	7d 09		 jge	 SHORT $LN7@DropItem

; 325  : 				{
; 326  : 					Option3 = 3;

  0011b	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3

; 327  : 				}
; 328  : 				else

  00122	eb 10		 jmp	 SHORT $LN23@DropItem
$LN7@DropItem:

; 329  : 				{
; 330  : 					Option3 = rand()%3;

  00124	e8 00 00 00 00	 call	 _rand
  00129	99		 cdq
  0012a	b9 03 00 00 00	 mov	 ecx, 3
  0012f	f7 f9		 idiv	 ecx
  00131	89 55 fc	 mov	 DWORD PTR _Option3$[ebp], edx
$LN23@DropItem:

; 331  : 				}
; 332  : 			}
; 333  : 
; 334  : 			if ( this->BagObject[DropItemNum].m_isexitem != 0 )

  00134	8b 55 08	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  00137	80 bc d3 a3 01
	00 00 00	 cmp	 BYTE PTR [ebx+edx*8+419], 0
  0013f	74 16		 je	 SHORT $LN24@DropItem

; 335  : 			{
; 336  : 				ExOption = NewOptionRand(0);

  00141	6a 00		 push	 0
  00143	e8 00 00 00 00	 call	 ?NewOptionRand@@YAEH@Z	; NewOptionRand
  00148	83 c4 04	 add	 esp, 4
  0014b	0f b6 d0	 movzx	 edx, al

; 337  : 				Option1 = 1;

  0014e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 1
  00155	eb 03		 jmp	 SHORT $LN5@DropItem
$LN24@DropItem:
  00157	8b 55 e4	 mov	 edx, DWORD PTR _ExOption$[ebp]
$LN5@DropItem:

; 338  : 			}
; 339  : 
; 340  : 			if ( type == ITEMGET(12,15) || type == ITEMGET(14,13) || type == ITEMGET(14,14))	// Chaos, Bless, Soul

  0015a	81 ff 0f 18 00
	00		 cmp	 edi, 6159		; 0000180fH
  00160	74 10		 je	 SHORT $LN3@DropItem
  00162	81 ff 0d 1c 00
	00		 cmp	 edi, 7181		; 00001c0dH
  00168	74 08		 je	 SHORT $LN3@DropItem
  0016a	81 ff 0e 1c 00
	00		 cmp	 edi, 7182		; 00001c0eH
  00170	75 10		 jne	 SHORT $LN25@DropItem
$LN3@DropItem:

; 341  : 			{
; 342  : 				Option1 = 0;

  00172	33 c9		 xor	 ecx, ecx
  00174	89 4d f8	 mov	 DWORD PTR _Option1$[ebp], ecx

; 343  : 				Option2 = 0;

  00177	89 4d f4	 mov	 DWORD PTR _Option2$[ebp], ecx

; 344  : 				Option3 = 0;

  0017a	89 4d fc	 mov	 DWORD PTR _Option3$[ebp], ecx

; 345  : 				level = 0;

  0017d	89 4d f0	 mov	 DWORD PTR _level$[ebp], ecx
  00180	eb 02		 jmp	 SHORT $LN4@DropItem
$LN25@DropItem:
  00182	33 c9		 xor	 ecx, ecx
$LN4@DropItem:

; 346  : 			}
; 347  : 
; 348  : 			if ( type == ITEMGET(13,0) || type == ITEMGET(13,1) || type ==ITEMGET(13,2) ||
; 349  : 				 type == ITEMGET(13,8) || type == ITEMGET(13,9) || type == ITEMGET(13,12) ||
; 350  : 				 type ==ITEMGET(13,13) )	// Angel, imp, unirioa, dino, r and pendant of ice, poisonm

  00184	81 ff 00 1a 00
	00		 cmp	 edi, 6656		; 00001a00H
  0018a	74 30		 je	 SHORT $LN1@DropItem
  0018c	81 ff 01 1a 00
	00		 cmp	 edi, 6657		; 00001a01H
  00192	74 28		 je	 SHORT $LN1@DropItem
  00194	81 ff 02 1a 00
	00		 cmp	 edi, 6658		; 00001a02H
  0019a	74 20		 je	 SHORT $LN1@DropItem
  0019c	81 ff 08 1a 00
	00		 cmp	 edi, 6664		; 00001a08H
  001a2	74 18		 je	 SHORT $LN1@DropItem
  001a4	81 ff 09 1a 00
	00		 cmp	 edi, 6665		; 00001a09H
  001aa	74 10		 je	 SHORT $LN1@DropItem
  001ac	81 ff 0c 1a 00
	00		 cmp	 edi, 6668		; 00001a0cH
  001b2	74 08		 je	 SHORT $LN1@DropItem
  001b4	81 ff 0d 1a 00
	00		 cmp	 edi, 6669		; 00001a0dH
  001ba	75 03		 jne	 SHORT $LN2@DropItem
$LN1@DropItem:

; 351  : 			{
; 352  : 				level = 0;

  001bc	89 4d f0	 mov	 DWORD PTR _level$[ebp], ecx
$LN2@DropItem:

; 353  : 			}
; 354  : 
; 355  : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur, Option1, Option2, Option3, lpObj->m_Index, ExOption, 0);

  001bf	8b 06		 mov	 eax, DWORD PTR [esi]
  001c1	51		 push	 ecx
  001c2	52		 push	 edx
  001c3	8b 55 fc	 mov	 edx, DWORD PTR _Option3$[ebp]
  001c6	50		 push	 eax
  001c7	52		 push	 edx
  001c8	8b 55 f4	 mov	 edx, DWORD PTR _Option2$[ebp]
  001cb	52		 push	 edx
  001cc	8b 55 f8	 mov	 edx, DWORD PTR _Option1$[ebp]
  001cf	52		 push	 edx
  001d0	8b 55 ec	 mov	 edx, DWORD PTR _y$[ebp]
  001d3	51		 push	 ecx
  001d4	8b 4d f0	 mov	 ecx, DWORD PTR _level$[ebp]
  001d7	51		 push	 ecx
  001d8	8b 4d e8	 mov	 ecx, DWORD PTR _x$[ebp]
  001db	57		 push	 edi
  001dc	52		 push	 edx
  001dd	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR [esi+265]
  001e4	51		 push	 ecx
  001e5	52		 push	 edx
  001e6	50		 push	 eax
  001e7	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 356  : 			LogAdd(LOG_BLACK, "[%s][%s] [%s] Event ItemDrop : (%d)(%d/%d) Item:(%s)%d Level:%d op1:%d op2:%d op3:%d",
; 357  : 				lpObj->AccountID, lpObj->Name, this->m_sEventName, lpObj->MapNumber, x, y, ItemAttribute[type].Name, type, level, Option1, Option2, Option3);

  001ec	8b 45 fc	 mov	 eax, DWORD PTR _Option3$[ebp]
  001ef	8b 4d f4	 mov	 ecx, DWORD PTR _Option2$[ebp]
  001f2	8b 55 f8	 mov	 edx, DWORD PTR _Option1$[ebp]
  001f5	50		 push	 eax
  001f6	8b 45 f0	 mov	 eax, DWORD PTR _level$[ebp]
  001f9	51		 push	 ecx
  001fa	8b 4d ec	 mov	 ecx, DWORD PTR _y$[ebp]
  001fd	52		 push	 edx
  001fe	8b 55 e8	 mov	 edx, DWORD PTR _x$[ebp]
  00201	50		 push	 eax
  00202	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00209	57		 push	 edi
  0020a	6b ff 6c	 imul	 edi, 108		; 0000006cH
  0020d	81 c7 00 00 00
	00		 add	 edi, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00213	57		 push	 edi
  00214	51		 push	 ecx
  00215	52		 push	 edx
  00216	50		 push	 eax
  00217	83 c3 08	 add	 ebx, 8
  0021a	53		 push	 ebx
  0021b	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  0021e	51		 push	 ecx
  0021f	83 c6 64	 add	 esi, 100		; 00000064H
  00222	56		 push	 esi
  00223	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@LDONOBLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5Event?5ItemDrop?5?3?5?$CI@
  00228	6a 00		 push	 0
  0022a	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0022f	83 c4 6c	 add	 esp, 108		; 0000006cH
  00232	5f		 pop	 edi
  00233	5e		 pop	 esi

; 358  : 			return TRUE;

  00234	b8 01 00 00 00	 mov	 eax, 1
  00239	5b		 pop	 ebx

; 366  : }

  0023a	8b e5		 mov	 esp, ebp
  0023c	5d		 pop	 ebp
  0023d	c2 04 00	 ret	 4
$LN12@DropItem:

; 359  : 		}
; 360  : 	}
; 361  : 
; 362  : 	x = lpObj->X;
; 363  : 	y = lpObj->Y;
; 364  : 	MapC[lpObj->MapNumber].MoneyItemDrop(this->m_iDropZen, x, y);

  00240	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  00247	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR [esi+260]
  0024e	8b 8b 10 01 00
	00		 mov	 ecx, DWORD PTR [ebx+272]
  00254	52		 push	 edx
  00255	50		 push	 eax
  00256	51		 push	 ecx
  00257	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  0025e	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00264	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0026a	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
  0026f	5e		 pop	 esi

; 365  : 	return TRUE;

  00270	b8 01 00 00 00	 mov	 eax, 1
  00275	5b		 pop	 ebx

; 366  : }

  00276	8b e5		 mov	 esp, ebp
  00278	5d		 pop	 ebp
  00279	c2 04 00	 ret	 4
?DropItem@CItemBagEx@@QAEHH@Z ENDP			; CItemBagEx::DropItem
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?PickItem@CItemBagEx@@QAEHAAVCItem@@AAH@Z	; CItemBagEx::PickItem
;	COMDAT __real@00000000
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itembagex.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itembagex.cpp
CONST	ENDS
;	COMDAT ?PickItem@CItemBagEx@@QAEHAAVCItem@@AAH@Z
_TEXT	SEGMENT
_objItem$ = 8						; size = 4
_nItemIndex$ = 12					; size = 4
?PickItem@CItemBagEx@@QAEHAAVCItem@@AAH@Z PROC		; CItemBagEx::PickItem, COMDAT
; _this$ = ecx

; 387  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 388  : 	if ( this->m_bLoad == FALSE )

  00006	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0000a	75 07		 jne	 SHORT $LN11@PickItem

; 389  : 		return FALSE;

  0000c	33 c0		 xor	 eax, eax
  0000e	5f		 pop	 edi

; 446  : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
$LN11@PickItem:
  00013	56		 push	 esi

; 390  : 
; 391  : 	int DropItemNum;
; 392  : 
; 393  : 	if ( this->GetBagCount() > 0 )

  00014	8b b7 20 01 00
	00		 mov	 esi, DWORD PTR [edi+288]
  0001a	85 f6		 test	 esi, esi
  0001c	0f 8e 18 01 00
	00		 jle	 $LN10@PickItem

; 394  : 	{
; 395  : 		DropItemNum = rand() % this->GetBagCount();

  00022	53		 push	 ebx
  00023	e8 00 00 00 00	 call	 _rand
  00028	99		 cdq
  00029	f7 fe		 idiv	 esi

; 396  : 		nItemIndex = DropItemNum;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _nItemIndex$[ebp]

; 397  : 		objItem.m_Type = ItemGetNumberMake(this->BagObject[DropItemNum].m_type, this->BagObject[DropItemNum].m_index);

  0002e	8b 5d 08	 mov	 ebx, DWORD PTR _objItem$[ebp]
  00031	8b f2		 mov	 esi, edx
  00033	89 30		 mov	 DWORD PTR [eax], esi
  00035	0f b6 8c f7 9d
	01 00 00	 movzx	 ecx, BYTE PTR [edi+esi*8+413]
  0003d	0f b6 94 f7 9c
	01 00 00	 movzx	 edx, BYTE PTR [edi+esi*8+412]
  00045	51		 push	 ecx
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0004c	83 c4 08	 add	 esp, 8

; 398  : 		objItem.m_Level = this->GetLevel(DropItemNum);

  0004f	56		 push	 esi
  00050	8b cf		 mov	 ecx, edi
  00052	66 89 43 06	 mov	 WORD PTR [ebx+6], ax
  00056	e8 00 00 00 00	 call	 ?GetLevel@CItemBagEx@@AAEEH@Z ; CItemBagEx::GetLevel

; 399  : 
; 400  : 		if ( objItem.m_Type == -1 )

  0005b	0f b7 4b 06	 movzx	 ecx, WORD PTR [ebx+6]
  0005f	0f b6 c0	 movzx	 eax, al
  00062	66 89 43 08	 mov	 WORD PTR [ebx+8], ax
  00066	66 83 f9 ff	 cmp	 cx, -1
  0006a	75 09		 jne	 SHORT $LN9@PickItem

; 401  : 			return FALSE;

  0006c	5b		 pop	 ebx
  0006d	5e		 pop	 esi
  0006e	33 c0		 xor	 eax, eax
  00070	5f		 pop	 edi

; 446  : }

  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8
$LN9@PickItem:

; 402  : 
; 403  : 		if ( this->BagObject[DropItemNum].m_isskill != 0 )

  00075	80 bc f7 a0 01
	00 00 00	 cmp	 BYTE PTR [edi+esi*8+416], 0
  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	74 03		 je	 SHORT $LN8@PickItem

; 404  : 			objItem.m_Option1 = 1;

  00084	88 43 78	 mov	 BYTE PTR [ebx+120], al
$LN8@PickItem:

; 405  : 
; 406  : 		if ( this->BagObject[DropItemNum].m_isluck != 0 )

  00087	80 bc f7 a1 01
	00 00 00	 cmp	 BYTE PTR [edi+esi*8+417], 0
  0008f	74 03		 je	 SHORT $LN7@PickItem

; 407  : 			objItem.m_Option2 = 1;

  00091	88 43 79	 mov	 BYTE PTR [ebx+121], al
$LN7@PickItem:

; 408  : 
; 409  : 		if ( this->BagObject[DropItemNum].m_isoption != 0 )

  00094	80 bc f7 a2 01
	00 00 00	 cmp	 BYTE PTR [edi+esi*8+418], 0
  0009c	74 03		 je	 SHORT $LN6@PickItem

; 410  : 			objItem.m_Option3 = 1;

  0009e	88 43 7a	 mov	 BYTE PTR [ebx+122], al
$LN6@PickItem:

; 411  : 
; 412  : 		if ( this->BagObject[DropItemNum].m_isexitem != 0 )

  000a1	80 bc f7 a3 01
	00 00 00	 cmp	 BYTE PTR [edi+esi*8+419], 0
  000a9	74 09		 je	 SHORT $LN5@PickItem

; 413  : 		{
; 414  : 			objItem.m_NewOption = 1;

  000ab	88 43 7b	 mov	 BYTE PTR [ebx+123], al

; 415  : 			objItem.m_Option1 = 0;

  000ae	66 c7 43 78 00
	00		 mov	 WORD PTR [ebx+120], 0
$LN5@PickItem:

; 416  : 			objItem.m_Option2 = 0;
; 417  : 		}
; 418  : 
; 419  : 		if ( objItem.m_Type == ITEMGET(12,15) ||
; 420  : 			 objItem.m_Type == ITEMGET(14,13) ||
; 421  : 			 objItem.m_Type == ITEMGET(14,14) )

  000b4	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  000b9	66 3b ca	 cmp	 cx, dx
  000bc	74 14		 je	 SHORT $LN3@PickItem
  000be	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  000c3	66 3b ca	 cmp	 cx, dx
  000c6	74 0a		 je	 SHORT $LN3@PickItem
  000c8	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  000cd	66 3b ca	 cmp	 cx, dx
  000d0	75 10		 jne	 SHORT $LN4@PickItem
$LN3@PickItem:

; 422  : 		{
; 423  : 			objItem.m_Option1 = 0;
; 424  : 			objItem.m_Option2 = 0;
; 425  : 			objItem.m_Option3 = 0;
; 426  : 			objItem.m_Level = 0;

  000d2	33 d2		 xor	 edx, edx
  000d4	66 c7 43 78 00
	00		 mov	 WORD PTR [ebx+120], 0
  000da	c6 43 7a 00	 mov	 BYTE PTR [ebx+122], 0
  000de	66 89 53 08	 mov	 WORD PTR [ebx+8], dx
$LN4@PickItem:

; 427  : 		}
; 428  : 
; 429  : 		if ( objItem.m_Type == ITEMGET(13,0) ||
; 430  : 			 objItem.m_Type == ITEMGET(13,1) ||
; 431  : 			 objItem.m_Type == ITEMGET(13,2) ||
; 432  : 			 objItem.m_Type == ITEMGET(13,8) ||
; 433  : 			 objItem.m_Type == ITEMGET(13,9) ||
; 434  : 			 objItem.m_Type == ITEMGET(13,12) ||
; 435  : 			 objItem.m_Type == ITEMGET(13,13) )

  000e2	ba 00 1a 00 00	 mov	 edx, 6656		; 00001a00H
  000e7	66 3b ca	 cmp	 cx, dx
  000ea	74 3c		 je	 SHORT $LN1@PickItem
  000ec	ba 01 1a 00 00	 mov	 edx, 6657		; 00001a01H
  000f1	66 3b ca	 cmp	 cx, dx
  000f4	74 32		 je	 SHORT $LN1@PickItem
  000f6	ba 02 1a 00 00	 mov	 edx, 6658		; 00001a02H
  000fb	66 3b ca	 cmp	 cx, dx
  000fe	74 28		 je	 SHORT $LN1@PickItem
  00100	ba 08 1a 00 00	 mov	 edx, 6664		; 00001a08H
  00105	66 3b ca	 cmp	 cx, dx
  00108	74 1e		 je	 SHORT $LN1@PickItem
  0010a	ba 09 1a 00 00	 mov	 edx, 6665		; 00001a09H
  0010f	66 3b ca	 cmp	 cx, dx
  00112	74 14		 je	 SHORT $LN1@PickItem
  00114	ba 0c 1a 00 00	 mov	 edx, 6668		; 00001a0cH
  00119	66 3b ca	 cmp	 cx, dx
  0011c	74 0a		 je	 SHORT $LN1@PickItem
  0011e	ba 0d 1a 00 00	 mov	 edx, 6669		; 00001a0dH
  00123	66 3b ca	 cmp	 cx, dx
  00126	75 06		 jne	 SHORT $LN2@PickItem
$LN1@PickItem:

; 436  : 		{
; 437  : 			objItem.m_Level = 0;

  00128	33 c9		 xor	 ecx, ecx
  0012a	66 89 4b 08	 mov	 WORD PTR [ebx+8], cx
$LN2@PickItem:

; 438  : 		}
; 439  : 
; 440  : 		objItem.m_Durability = 0;

  0012e	d9 ee		 fldz
  00130	d9 5b 24	 fstp	 DWORD PTR [ebx+36]
  00133	5b		 pop	 ebx
  00134	5e		 pop	 esi
  00135	5f		 pop	 edi

; 446  : }

  00136	5d		 pop	 ebp
  00137	c2 08 00	 ret	 8
$LN10@PickItem:
  0013a	5e		 pop	 esi

; 441  : 
; 442  : 		return TRUE;
; 443  : 	}
; 444  : 
; 445  : 	return FALSE;

  0013b	33 c0		 xor	 eax, eax
  0013d	5f		 pop	 edi

; 446  : }

  0013e	5d		 pop	 ebp
  0013f	c2 08 00	 ret	 8
?PickItem@CItemBagEx@@QAEHAAVCItem@@AAH@Z ENDP		; CItemBagEx::PickItem
_TEXT	ENDS
PUBLIC	??_C@_0GP@IHPHEILG@?$FL?$KB?$NLKundun?5EVENT?$FN?5?$KB?ZKUNDUN?5Event?5@ ; `string'
PUBLIC	??_C@_0FM@IBDEHDFI@?$FL?$KB?$NLKUNDUN?5EVENT?$FN?$FLKUNDUN?5ITEM?5BAG@ ; `string'
PUBLIC	?DropKundunEventItem@CItemBagEx@@QAEHHEEE@Z	; CItemBagEx::DropKundunEventItem
;	COMDAT ??_C@_0GP@IHPHEILG@?$FL?$KB?$NLKundun?5EVENT?$FN?5?$KB?ZKUNDUN?5Event?5@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itembagex.h
CONST	SEGMENT
??_C@_0GP@IHPHEILG@?$FL?$KB?$NLKundun?5EVENT?$FN?5?$KB?ZKUNDUN?5Event?5@ DB '['
	DB	0a1H, 0dbH, 'Kundun EVENT] ', 0a1H, 0daH, 'KUNDUN Event ItemDr'
	DB	'op [%s][%s] [%s] : (%d)(%d/%d) Item:(%s)%d Level:%d op1:%d op'
	DB	'2:%d op3:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@IBDEHDFI@?$FL?$KB?$NLKUNDUN?5EVENT?$FN?$FLKUNDUN?5ITEM?5BAG@
CONST	SEGMENT
??_C@_0FM@IBDEHDFI@?$FL?$KB?$NLKUNDUN?5EVENT?$FN?$FLKUNDUN?5ITEM?5BAG@ DB '['
	DB	0a1H, 0dbH, 'KUNDUN EVENT][KUNDUN ITEM BAG LIST] Item:(%s)%d L'
	DB	'evel:%d-%d op1:%d op2:%d op3:%d expo:%d', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itembagex.cpp
CONST	ENDS
;	COMDAT ?DropKundunEventItem@CItemBagEx@@QAEHHEEE@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_ExOption$ = -20					; size = 4
_x$ = -16						; size = 4
_Option1$ = -12						; size = 4
_Option3$ = -8						; size = 4
_Option2$ = -4						; size = 4
tv732 = 8						; size = 4
_DropItemNum$ = 8					; size = 4
_aIndex$ = 8						; size = 4
_btMapNumber$ = 12					; size = 1
_level$ = 16						; size = 4
_cX$ = 16						; size = 1
_y$ = 20						; size = 4
_cY$ = 20						; size = 1
?DropKundunEventItem@CItemBagEx@@QAEHHEEE@Z PROC	; CItemBagEx::DropKundunEventItem, COMDAT
; _this$ = ecx

; 449  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 450  : 	if ( this->m_bLoad == FALSE )

  00009	33 c9		 xor	 ecx, ecx
  0000b	89 5d e8	 mov	 DWORD PTR _this$[ebp], ebx
  0000e	39 4b 04	 cmp	 DWORD PTR [ebx+4], ecx
  00011	75 09		 jne	 SHORT $LN20@DropKundun

; 451  : 	{
; 452  : 		return FALSE;

  00013	33 c0		 xor	 eax, eax
  00015	5b		 pop	 ebx

; 565  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 10 00	 ret	 16			; 00000010H
$LN20@DropKundun:

; 461  : 	int Option2 = 0;
; 462  : 	int Option3 = 0;
; 463  : 	int DropItemNum;
; 464  : 	int ExOption = 0;
; 465  : 	LPOBJ lpObj = &gObj[aIndex];
; 466  : 	int iItemBagCount = this->GetBagCount();

  0001c	8b 83 20 01 00
	00		 mov	 eax, DWORD PTR [ebx+288]
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00027	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0002d	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00033	89 4d f4	 mov	 DWORD PTR _Option1$[ebp], ecx
  00036	89 4d fc	 mov	 DWORD PTR _Option2$[ebp], ecx
  00039	89 4d f8	 mov	 DWORD PTR _Option3$[ebp], ecx
  0003c	89 4d ec	 mov	 DWORD PTR _ExOption$[ebp], ecx

; 467  : 
; 468  : 	for(int i=0;i<iItemBagCount;i++)

  0003f	3b c1		 cmp	 eax, ecx
  00041	7e 5c		 jle	 SHORT $LN17@DropKundun

; 453  : 	}
; 454  : 
; 455  : 	float dur;
; 456  : 	int type;
; 457  : 	int level;
; 458  : 	int x;
; 459  : 	int y;
; 460  : 	int Option1 = 0;

  00043	8d b3 9c 01 00
	00		 lea	 esi, DWORD PTR [ebx+412]
  00049	89 45 08	 mov	 DWORD PTR tv732[ebp], eax
  0004c	8d 64 24 00	 npad	 4
$LL19@DropKundun:

; 469  : 	{
; 470  : 		type = ItemGetNumberMake(this->BagObject[i].m_type, this->BagObject[i].m_index);

  00050	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  00054	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  00057	50		 push	 eax
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 471  : 
; 472  : 		LogAdd(LOG_BLACK, "[KUNDUN EVENT][KUNDUN ITEM BAG LIST] Item:(%s)%d Level:%d-%d op1:%d op2:%d op3:%d expo:%d",
; 473  : 			ItemAttribute[type].Name, type, this->BagObject[i].m_minLevel, BagObject[i].m_maxLevel,
; 474  : 			BagObject[i].m_isskill, BagObject[i].m_isluck, BagObject[i].m_isoption, BagObject[i].m_isexitem);

  0005e	0f b6 56 07	 movzx	 edx, BYTE PTR [esi+7]
  00062	0f b6 4e 06	 movzx	 ecx, BYTE PTR [esi+6]
  00066	52		 push	 edx
  00067	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  0006b	51		 push	 ecx
  0006c	0f b6 4e 04	 movzx	 ecx, BYTE PTR [esi+4]
  00070	52		 push	 edx
  00071	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  00075	51		 push	 ecx
  00076	0f b6 4e 02	 movzx	 ecx, BYTE PTR [esi+2]
  0007a	52		 push	 edx
  0007b	51		 push	 ecx
  0007c	50		 push	 eax
  0007d	6b c0 6c	 imul	 eax, 108		; 0000006cH
  00080	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00085	50		 push	 eax
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@IBDEHDFI@?$FL?$KB?$NLKUNDUN?5EVENT?$FN?$FLKUNDUN?5ITEM?5BAG@
  0008b	6a 00		 push	 0
  0008d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00092	83 c4 30	 add	 esp, 48			; 00000030H
  00095	83 c6 08	 add	 esi, 8
  00098	ff 4d 08	 dec	 DWORD PTR tv732[ebp]
  0009b	75 b3		 jne	 SHORT $LL19@DropKundun

; 467  : 
; 468  : 	for(int i=0;i<iItemBagCount;i++)

  0009d	33 c9		 xor	 ecx, ecx
$LN17@DropKundun:

; 475  : 	}
; 476  : 
; 477  : 	if ( this->GetBagCount() > 0 )

  0009f	8b b3 20 01 00
	00		 mov	 esi, DWORD PTR [ebx+288]
  000a5	3b f1		 cmp	 esi, ecx
  000a7	0f 8e e1 01 00
	00		 jle	 $LN15@DropKundun

; 478  : 	{
; 479  : 		if ( true )
; 480  : 		{
; 481  : 			DropItemNum =  rand() % this->GetBagCount();

  000ad	e8 00 00 00 00	 call	 _rand
  000b2	99		 cdq
  000b3	f7 fe		 idiv	 esi

; 482  : 			dur = 0;
; 483  : 			
; 484  : 			if ( cX == 0 && cY == 0 )

  000b5	8a 45 10	 mov	 al, BYTE PTR _cX$[ebp]
  000b8	8a 4d 14	 mov	 cl, BYTE PTR _cY$[ebp]
  000bb	8b f2		 mov	 esi, edx
  000bd	89 75 08	 mov	 DWORD PTR _DropItemNum$[ebp], esi
  000c0	84 c0		 test	 al, al
  000c2	75 14		 jne	 SHORT $LN14@DropKundun
  000c4	84 c9		 test	 cl, cl
  000c6	75 10		 jne	 SHORT $LN14@DropKundun

; 485  : 			{
; 486  : 				x = lpObj->X;

  000c8	0f bf 97 04 01
	00 00		 movsx	 edx, WORD PTR [edi+260]

; 487  : 				y = lpObj->Y;

  000cf	0f bf 87 06 01
	00 00		 movsx	 eax, WORD PTR [edi+262]

; 488  : 			}
; 489  : 			else

  000d6	eb 06		 jmp	 SHORT $LN37@DropKundun
$LN14@DropKundun:

; 490  : 			{
; 491  : 				x = cX;

  000d8	0f b6 d0	 movzx	 edx, al

; 492  : 				y = cY;

  000db	0f b6 c1	 movzx	 eax, cl
$LN37@DropKundun:

; 493  : 			}
; 494  : 
; 495  : 			level = this->GetLevel(DropItemNum);

  000de	56		 push	 esi
  000df	8b cb		 mov	 ecx, ebx
  000e1	89 45 14	 mov	 DWORD PTR _y$[ebp], eax
  000e4	89 55 f0	 mov	 DWORD PTR _x$[ebp], edx
  000e7	e8 00 00 00 00	 call	 ?GetLevel@CItemBagEx@@AAEEH@Z ; CItemBagEx::GetLevel

; 496  : 			type = ItemGetNumberMake(this->BagObject[DropItemNum].m_type, this->BagObject[DropItemNum].m_index);

  000ec	0f b6 94 f3 9d
	01 00 00	 movzx	 edx, BYTE PTR [ebx+esi*8+413]
  000f4	0f b6 c8	 movzx	 ecx, al
  000f7	0f b6 84 f3 9c
	01 00 00	 movzx	 eax, BYTE PTR [ebx+esi*8+412]
  000ff	52		 push	 edx
  00100	50		 push	 eax
  00101	89 4d 10	 mov	 DWORD PTR _level$[ebp], ecx
  00104	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00109	8b f0		 mov	 esi, eax
  0010b	83 c4 08	 add	 esp, 8

; 497  : 
; 498  : 			if ( type == -1 )

  0010e	83 fe ff	 cmp	 esi, -1
  00111	75 0b		 jne	 SHORT $LN12@DropKundun

; 499  : 			{
; 500  : 				return FALSE;

  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	33 c0		 xor	 eax, eax
  00117	5b		 pop	 ebx

; 565  : }

  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 10 00	 ret	 16			; 00000010H
$LN12@DropKundun:

; 501  : 			}
; 502  : 
; 503  : 			if ( this->BagObject[DropItemNum].m_isskill != 0 )

  0011e	8b 45 08	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  00121	80 bc c3 a0 01
	00 00 00	 cmp	 BYTE PTR [ebx+eax*8+416], 0
  00129	74 07		 je	 SHORT $LN31@DropKundun

; 504  : 			{
; 505  : 				Option1 =1;

  0012b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 1
$LN31@DropKundun:

; 506  : 			}
; 507  : 
; 508  : 			if ( this->BagObject[DropItemNum].m_isluck != 0 )

  00132	80 bc c3 a1 01
	00 00 00	 cmp	 BYTE PTR [ebx+eax*8+417], 0
  0013a	74 21		 je	 SHORT $LN32@DropKundun

; 509  : 			{
; 510  : 				Option2 = 0;

  0013c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 511  : 
; 512  : 				if ( (rand()%2) == 0 )

  00143	e8 00 00 00 00	 call	 _rand
  00148	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0014d	79 05		 jns	 SHORT $LN36@DropKundun
  0014f	48		 dec	 eax
  00150	83 c8 fe	 or	 eax, -2			; fffffffeH
  00153	40		 inc	 eax
$LN36@DropKundun:
  00154	75 07		 jne	 SHORT $LN32@DropKundun

; 513  : 				{
; 514  : 					Option2 = 1;

  00156	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 1
$LN32@DropKundun:

; 515  : 				}
; 516  : 			}
; 517  : 
; 518  : 			if ( this->BagObject[DropItemNum].m_isoption != 0 )

  0015d	8b 4d 08	 mov	 ecx, DWORD PTR _DropItemNum$[ebp]
  00160	80 bc cb a2 01
	00 00 00	 cmp	 BYTE PTR [ebx+ecx*8+418], 0
  00168	74 2b		 je	 SHORT $LN6@DropKundun

; 519  : 			{
; 520  : 				if ( rand()%5 < 1 )

  0016a	e8 00 00 00 00	 call	 _rand
  0016f	99		 cdq
  00170	b9 05 00 00 00	 mov	 ecx, 5
  00175	f7 f9		 idiv	 ecx
  00177	83 fa 01	 cmp	 edx, 1
  0017a	7d 09		 jge	 SHORT $LN7@DropKundun

; 521  : 				{
; 522  : 					Option3 = 3;

  0017c	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3

; 523  : 				}
; 524  : 				else

  00183	eb 10		 jmp	 SHORT $LN6@DropKundun
$LN7@DropKundun:

; 525  : 				{
; 526  : 					Option3 = rand()%3;

  00185	e8 00 00 00 00	 call	 _rand
  0018a	99		 cdq
  0018b	b9 03 00 00 00	 mov	 ecx, 3
  00190	f7 f9		 idiv	 ecx
  00192	89 55 f8	 mov	 DWORD PTR _Option3$[ebp], edx
$LN6@DropKundun:

; 527  : 				}
; 528  : 			}
; 529  : 
; 530  : 			if ( this->BagObject[DropItemNum].m_isexitem != 0 )

  00195	8b 55 08	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  00198	80 bc d3 a3 01
	00 00 00	 cmp	 BYTE PTR [ebx+edx*8+419], 0
  001a0	74 1a		 je	 SHORT $LN33@DropKundun

; 531  : 			{
; 532  : 				ExOption = NewOptionRand(0);

  001a2	33 db		 xor	 ebx, ebx
  001a4	53		 push	 ebx
  001a5	e8 00 00 00 00	 call	 ?NewOptionRand@@YAEH@Z	; NewOptionRand
  001aa	83 c4 04	 add	 esp, 4
  001ad	0f b6 c8	 movzx	 ecx, al

; 533  : 				Option2 = 0;

  001b0	89 5d fc	 mov	 DWORD PTR _Option2$[ebp], ebx

; 534  : 				Option1 = 1;

  001b3	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 1
  001ba	eb 05		 jmp	 SHORT $LN5@DropKundun
$LN33@DropKundun:
  001bc	8b 4d ec	 mov	 ecx, DWORD PTR _ExOption$[ebp]
  001bf	33 db		 xor	 ebx, ebx
$LN5@DropKundun:

; 535  : 			}
; 536  : 
; 537  : 			if ( type == ITEMGET(12,15) || type == ITEMGET(14,13) || type == ITEMGET(14,14))	// Chaos, Bless, Soul

  001c1	81 fe 0f 18 00
	00		 cmp	 esi, 6159		; 0000180fH
  001c7	74 10		 je	 SHORT $LN3@DropKundun
  001c9	81 fe 0d 1c 00
	00		 cmp	 esi, 7181		; 00001c0dH
  001cf	74 08		 je	 SHORT $LN3@DropKundun
  001d1	81 fe 0e 1c 00
	00		 cmp	 esi, 7182		; 00001c0eH
  001d7	75 0c		 jne	 SHORT $LN4@DropKundun
$LN3@DropKundun:

; 538  : 			{
; 539  : 				Option1 = 0;

  001d9	89 5d f4	 mov	 DWORD PTR _Option1$[ebp], ebx

; 540  : 				Option2 = 0;

  001dc	89 5d fc	 mov	 DWORD PTR _Option2$[ebp], ebx

; 541  : 				Option3 = 0;

  001df	89 5d f8	 mov	 DWORD PTR _Option3$[ebp], ebx

; 542  : 				level = 0;

  001e2	89 5d 10	 mov	 DWORD PTR _level$[ebp], ebx
$LN4@DropKundun:

; 543  : 			}
; 544  : 
; 545  : 			if ( type == ITEMGET(13,0) ||
; 546  : 				 type == ITEMGET(13,1) ||
; 547  : 				 type == ITEMGET(13,2) ||
; 548  : 				 type == ITEMGET(13,8) ||
; 549  : 				 type == ITEMGET(13,9) ||
; 550  : 				 type == ITEMGET(13,12) ||
; 551  : 				 type ==ITEMGET(13,13) )	// Angel, imp, unirioa, dino, r and pendant of ice, poisonm

  001e5	81 fe 00 1a 00
	00		 cmp	 esi, 6656		; 00001a00H
  001eb	74 30		 je	 SHORT $LN1@DropKundun
  001ed	81 fe 01 1a 00
	00		 cmp	 esi, 6657		; 00001a01H
  001f3	74 28		 je	 SHORT $LN1@DropKundun
  001f5	81 fe 02 1a 00
	00		 cmp	 esi, 6658		; 00001a02H
  001fb	74 20		 je	 SHORT $LN1@DropKundun
  001fd	81 fe 08 1a 00
	00		 cmp	 esi, 6664		; 00001a08H
  00203	74 18		 je	 SHORT $LN1@DropKundun
  00205	81 fe 09 1a 00
	00		 cmp	 esi, 6665		; 00001a09H
  0020b	74 10		 je	 SHORT $LN1@DropKundun
  0020d	81 fe 0c 1a 00
	00		 cmp	 esi, 6668		; 00001a0cH
  00213	74 08		 je	 SHORT $LN1@DropKundun
  00215	81 fe 0d 1a 00
	00		 cmp	 esi, 6669		; 00001a0dH
  0021b	75 03		 jne	 SHORT $LN2@DropKundun
$LN1@DropKundun:

; 552  : 			{
; 553  : 				level = 0;

  0021d	89 5d 10	 mov	 DWORD PTR _level$[ebp], ebx
$LN2@DropKundun:

; 554  : 			}
; 555  : 
; 556  : 			ItemSerialCreateSend(lpObj->m_Index, btMapNumber, x, y, type, level, dur, Option1, Option2, Option3, lpObj->m_Index, ExOption, 0);

  00220	8b 07		 mov	 eax, DWORD PTR [edi]
  00222	8b 55 fc	 mov	 edx, DWORD PTR _Option2$[ebp]
  00225	53		 push	 ebx
  00226	51		 push	 ecx
  00227	8b 4d f8	 mov	 ecx, DWORD PTR _Option3$[ebp]
  0022a	50		 push	 eax
  0022b	51		 push	 ecx
  0022c	8b 4d f4	 mov	 ecx, DWORD PTR _Option1$[ebp]
  0022f	52		 push	 edx
  00230	8b 55 10	 mov	 edx, DWORD PTR _level$[ebp]
  00233	51		 push	 ecx
  00234	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  00237	53		 push	 ebx
  00238	8b 5d 0c	 mov	 ebx, DWORD PTR _btMapNumber$[ebp]
  0023b	52		 push	 edx
  0023c	8b 55 f0	 mov	 edx, DWORD PTR _x$[ebp]
  0023f	56		 push	 esi
  00240	51		 push	 ecx
  00241	52		 push	 edx
  00242	53		 push	 ebx
  00243	50		 push	 eax
  00244	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 557  : 
; 558  : 			LogAdd(LOG_BLACK, "[Kundun EVENT] KUNDUN Event ItemDrop [%s][%s] [%s] : (%d)(%d/%d) Item:(%s)%d Level:%d op1:%d op2:%d op3:%d",
; 559  : 				lpObj->AccountID, lpObj->Name, this->m_sEventName, btMapNumber, x, y, ItemAttribute[type].Name, type, level, Option1, Option2, Option3);

  00249	8b 45 f8	 mov	 eax, DWORD PTR _Option3$[ebp]
  0024c	8b 4d fc	 mov	 ecx, DWORD PTR _Option2$[ebp]
  0024f	8b 55 f4	 mov	 edx, DWORD PTR _Option1$[ebp]
  00252	50		 push	 eax
  00253	8b 45 10	 mov	 eax, DWORD PTR _level$[ebp]
  00256	51		 push	 ecx
  00257	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  0025a	52		 push	 edx
  0025b	8b 55 f0	 mov	 edx, DWORD PTR _x$[ebp]
  0025e	50		 push	 eax
  0025f	56		 push	 esi
  00260	6b f6 6c	 imul	 esi, 108		; 0000006cH
  00263	81 c6 00 00 00
	00		 add	 esi, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00269	56		 push	 esi
  0026a	51		 push	 ecx
  0026b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0026e	52		 push	 edx
  0026f	0f b6 c3	 movzx	 eax, bl
  00272	50		 push	 eax
  00273	83 c1 08	 add	 ecx, 8
  00276	51		 push	 ecx
  00277	8d 57 6f	 lea	 edx, DWORD PTR [edi+111]
  0027a	52		 push	 edx
  0027b	83 c7 64	 add	 edi, 100		; 00000064H
  0027e	57		 push	 edi
  0027f	68 00 00 00 00	 push	 OFFSET ??_C@_0GP@IHPHEILG@?$FL?$KB?$NLKundun?5EVENT?$FN?5?$KB?ZKUNDUN?5Event?5@
  00284	6a 00		 push	 0
  00286	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0028b	83 c4 6c	 add	 esp, 108		; 0000006cH
$LN15@DropKundun:

; 560  : 			return TRUE;
; 561  : 		}
; 562  : 	}
; 563  : 
; 564  : 	return TRUE;

  0028e	5f		 pop	 edi
  0028f	5e		 pop	 esi
  00290	b8 01 00 00 00	 mov	 eax, 1
  00295	5b		 pop	 ebx

; 565  : }

  00296	8b e5		 mov	 esp, ebp
  00298	5d		 pop	 ebp
  00299	c2 10 00	 ret	 16			; 00000010H
?DropKundunEventItem@CItemBagEx@@QAEHHEEE@Z ENDP	; CItemBagEx::DropKundunEventItem
_TEXT	ENDS
PUBLIC	??0CItemBagDropMapInfo@@QAE@XZ			; CItemBagDropMapInfo::CItemBagDropMapInfo
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itembagex.h
;	COMDAT ??0CItemBagDropMapInfo@@QAE@XZ
_TEXT	SEGMENT
??0CItemBagDropMapInfo@@QAE@XZ PROC			; CItemBagDropMapInfo::CItemBagDropMapInfo, COMDAT
; _this$ = ecx

; 46   : 	CItemBagDropMapInfo()	// line : 46

  00000	8b c1		 mov	 eax, ecx

; 47   : 	{
; 48   : 		this->Init();

  00002	32 c9		 xor	 cl, cl
  00004	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
  00009	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 49   : 	};	// line : 49

  0000c	c3		 ret	 0
??0CItemBagDropMapInfo@@QAE@XZ ENDP			; CItemBagDropMapInfo::CItemBagDropMapInfo
_TEXT	ENDS
PUBLIC	??0CItemBagEx@@QAE@XZ				; CItemBagEx::CItemBagEx
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itembagex.cpp
;	COMDAT ??0CItemBagEx@@QAE@XZ
_TEXT	SEGMENT
??0CItemBagEx@@QAE@XZ PROC				; CItemBagEx::CItemBagEx, COMDAT
; _this$ = ecx

; 14   : {

  00000	53		 push	 ebx
  00001	8b c1		 mov	 eax, ecx
  00003	56		 push	 esi
  00004	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CItemBagEx@@6B@
  0000a	8d 90 24 01 00
	00		 lea	 edx, DWORD PTR [eax+292]
  00010	be 27 00 00 00	 mov	 esi, 39			; 00000027H
  00015	32 db		 xor	 bl, bl
$LL4@CItemBagEx:
  00017	88 1a		 mov	 BYTE PTR [edx], bl
  00019	88 5a 01	 mov	 BYTE PTR [edx+1], bl
  0001c	88 5a 02	 mov	 BYTE PTR [edx+2], bl
  0001f	83 c2 03	 add	 edx, 3
  00022	4e		 dec	 esi
  00023	79 f2		 jns	 SHORT $LL4@CItemBagEx
  00025	8d 90 9c 01 00
	00		 lea	 edx, DWORD PTR [eax+412]
  0002b	be 95 00 00 00	 mov	 esi, 149		; 00000095H
$LL12@CItemBagEx:
  00030	88 1a		 mov	 BYTE PTR [edx], bl
  00032	88 5a 01	 mov	 BYTE PTR [edx+1], bl
  00035	88 5a 02	 mov	 BYTE PTR [edx+2], bl
  00038	88 5a 03	 mov	 BYTE PTR [edx+3], bl
  0003b	88 5a 04	 mov	 BYTE PTR [edx+4], bl
  0003e	88 5a 05	 mov	 BYTE PTR [edx+5], bl
  00041	88 5a 06	 mov	 BYTE PTR [edx+6], bl
  00044	88 5a 07	 mov	 BYTE PTR [edx+7], bl
  00047	83 c2 08	 add	 edx, 8
  0004a	4e		 dec	 esi
  0004b	79 e3		 jns	 SHORT $LL12@CItemBagEx

; 15   : 	return;
; 16   : }

  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	c3		 ret	 0
??0CItemBagEx@@QAE@XZ ENDP				; CItemBagEx::CItemBagEx
_TEXT	ENDS
END
