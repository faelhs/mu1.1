; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\cSQL.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?DefaultSQLErrorHandler@@YAHPBD0H@Z		; DefaultSQLErrorHandler
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__GetActiveWindow@0:PROC
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\csql.cpp
;	COMDAT ?DefaultSQLErrorHandler@@YAHPBD0H@Z
_TEXT	SEGMENT
_sSource$ = 8						; size = 4
_sErrorMsg$ = 12					; size = 4
_iErrorNumber$ = 16					; size = 4
?DefaultSQLErrorHandler@@YAHPBD0H@Z PROC		; DefaultSQLErrorHandler, COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 20   : 	MessageBoxA(GetActiveWindow(), sErrorMsg, sSource, MB_ICONERROR);

  00003	8b 45 08	 mov	 eax, DWORD PTR _sSource$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _sErrorMsg$[ebp]
  00009	6a 10		 push	 16			; 00000010H
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetActiveWindow@0
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 21   : 	return 0;

  0001a	33 c0		 xor	 eax, eax

; 22   : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?DefaultSQLErrorHandler@@YAHPBD0H@Z ENDP		; DefaultSQLErrorHandler
_TEXT	ENDS
PUBLIC	?SetTimeOut@CSQL@@QAEXK@Z			; CSQL::SetTimeOut
; Function compile flags: /Ogtp
;	COMDAT ?SetTimeOut@CSQL@@QAEXK@Z
_TEXT	SEGMENT
_dwCommandTimeout$ = 8					; size = 4
?SetTimeOut@CSQL@@QAEXK@Z PROC				; CSQL::SetTimeOut, COMDAT
; _this$ = ecx

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 85   : 	this->dwTimeout = dwCommandTimeout;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwCommandTimeout$[ebp]
  00006	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 86   : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetTimeOut@CSQL@@QAEXK@Z ENDP				; CSQL::SetTimeOut
_TEXT	ENDS
PUBLIC	?IsConnected@CSQL@@QAE_NXZ			; CSQL::IsConnected
; Function compile flags: /Ogtp
;	COMDAT ?IsConnected@CSQL@@QAE_NXZ
_TEXT	SEGMENT
?IsConnected@CSQL@@QAE_NXZ PROC				; CSQL::IsConnected, COMDAT
; _this$ = ecx

; 92   : 	return this->bConnected;

  00000	8a 41 10	 mov	 al, BYTE PTR [ecx+16]

; 93   : }

  00003	c3		 ret	 0
?IsConnected@CSQL@@QAE_NXZ ENDP				; CSQL::IsConnected
_TEXT	ENDS
PUBLIC	??_C@_0CF@GIMGDFEP@UID?$DN?$CFs?$DLPWD?$DN?$CFs?$DLTRUSTED_CONNECTION@ ; `string'
PUBLIC	??_C@_0BI@DBBFHKN@TRUSTED_CONNECTION?$DNyes?$DL?$AA@ ; `string'
PUBLIC	??_C@_0BF@EGPIJBHM@MARS_Connection?$DNyes?$DL?$AA@ ; `string'
PUBLIC	??_C@_0CA@DKNHJPDK@NETWORK?$DNDBMSSOCN?$DLADDRESS?$DN?$CFs?0?$CFd?$DL?$AA@ ; `string'
PUBLIC	??_C@_07PEOJBJKP@APP?$DN?$CFs?$DL?$AA@		; `string'
PUBLIC	??_C@_0N@GDMFOAOK@DATABASE?$DN?$CFs?$DL?$AA@	; `string'
PUBLIC	??_C@_0BF@BGPPMBIG@DRIVER?$DN?$CFs?$DLSERVER?$DN?$CFs?$DL?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?BuildConnectionString@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@PADH@Z ; CSQL::BuildConnectionString
EXTRN	_strcat_s:PROC
EXTRN	_sprintf_s:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0CF@GIMGDFEP@UID?$DN?$CFs?$DLPWD?$DN?$CFs?$DLTRUSTED_CONNECTION@
CONST	SEGMENT
??_C@_0CF@GIMGDFEP@UID?$DN?$CFs?$DLPWD?$DN?$CFs?$DLTRUSTED_CONNECTION@ DB 'U'
	DB	'ID=%s;PWD=%s;TRUSTED_CONNECTION=no;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DBBFHKN@TRUSTED_CONNECTION?$DNyes?$DL?$AA@
CONST	SEGMENT
??_C@_0BI@DBBFHKN@TRUSTED_CONNECTION?$DNyes?$DL?$AA@ DB 'TRUSTED_CONNECTI'
	DB	'ON=yes;', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EGPIJBHM@MARS_Connection?$DNyes?$DL?$AA@
CONST	SEGMENT
??_C@_0BF@EGPIJBHM@MARS_Connection?$DNyes?$DL?$AA@ DB 'MARS_Connection=ye'
	DB	's;', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DKNHJPDK@NETWORK?$DNDBMSSOCN?$DLADDRESS?$DN?$CFs?0?$CFd?$DL?$AA@
CONST	SEGMENT
??_C@_0CA@DKNHJPDK@NETWORK?$DNDBMSSOCN?$DLADDRESS?$DN?$CFs?0?$CFd?$DL?$AA@ DB 'N'
	DB	'ETWORK=DBMSSOCN;ADDRESS=%s,%d;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PEOJBJKP@APP?$DN?$CFs?$DL?$AA@
CONST	SEGMENT
??_C@_07PEOJBJKP@APP?$DN?$CFs?$DL?$AA@ DB 'APP=%s;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GDMFOAOK@DATABASE?$DN?$CFs?$DL?$AA@
CONST	SEGMENT
??_C@_0N@GDMFOAOK@DATABASE?$DN?$CFs?$DL?$AA@ DB 'DATABASE=%s;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BGPPMBIG@DRIVER?$DN?$CFs?$DLSERVER?$DN?$CFs?$DL?$AA@
CONST	SEGMENT
??_C@_0BF@BGPPMBIG@DRIVER?$DN?$CFs?$DLSERVER?$DN?$CFs?$DL?$AA@ DB 'DRIVER'
	DB	'=%s;SERVER=%s;', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?BuildConnectionString@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@PADH@Z
_TEXT	SEGMENT
tv218 = -1032						; size = 4
tv86 = -1032						; size = 4
tv74 = -1032						; size = 4
_sTemp$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_SQLCon$ = 8						; size = 4
_sOut$ = 12						; size = 4
_iOutSz$ = 16						; size = 4
?BuildConnectionString@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@PADH@Z PROC ; CSQL::BuildConnectionString, COMDAT
; _this$ = ecx

; 259  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx

; 260  :     char sTemp[1024];
; 261  : 
; 262  : 	//-----------------------------------------------------------------------------------------------
; 263  : 	// Important note!
; 264  : 	//-----------------------------------------------------------------------------------------------
; 265  : 	//		When connecting through the SQLOLEDB provider use the syntax Network Library=dbmssocn
; 266  : 	//			and when connecting through MSDASQL provider use the syntax Network=dbmssocn
; 267  : 	//-----------------------------------------------------------------------------------------------
; 268  : 
; 269  : 	//Driver: {SQL Server}
; 270  : 
; 271  : 	sprintf_s(sOut, iOutSz, "DRIVER=%s;SERVER=%s;", SQLCon->sDriver, SQLCon->sServer);

  00014	8b 5d 10	 mov	 ebx, DWORD PTR _iOutSz$[ebp]
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _SQLCon$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 0c	 mov	 edi, DWORD PTR _sOut$[ebp]
  0001f	8d 86 fe 01 00
	00		 lea	 eax, DWORD PTR [esi+510]
  00025	50		 push	 eax
  00026	8d 86 ff 00 00
	00		 lea	 eax, DWORD PTR [esi+255]
  0002c	50		 push	 eax
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@BGPPMBIG@DRIVER?$DN?$CFs?$DLSERVER?$DN?$CFs?$DL?$AA@
  00032	53		 push	 ebx
  00033	57		 push	 edi
  00034	e8 00 00 00 00	 call	 _sprintf_s

; 272  : 
; 273  : 	if(strlen(SQLCon->sDatabase) > 0)

  00039	8d 8e fd 02 00
	00		 lea	 ecx, DWORD PTR [esi+765]
  0003f	8b c1		 mov	 eax, ecx
  00041	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00044	83 c4 14	 add	 esp, 20			; 00000014H
  00047	89 95 f8 fb ff
	ff		 mov	 DWORD PTR tv218[ebp], edx
  0004d	8d 49 00	 npad	 3
$LL9@BuildConne:
  00050	8a 10		 mov	 dl, BYTE PTR [eax]
  00052	40		 inc	 eax
  00053	84 d2		 test	 dl, dl
  00055	75 f9		 jne	 SHORT $LL9@BuildConne
  00057	2b 85 f8 fb ff
	ff		 sub	 eax, DWORD PTR tv218[ebp]
  0005d	74 28		 je	 SHORT $LN6@BuildConne

; 274  : 	{
; 275  : 		sprintf_s(sTemp, sizeof(sTemp), "DATABASE=%s;", SQLCon->sDatabase);

  0005f	51		 push	 ecx
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GDMFOAOK@DATABASE?$DN?$CFs?$DL?$AA@
  00065	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _sTemp$[ebp]
  0006b	68 00 04 00 00	 push	 1024			; 00000400H
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _sprintf_s

; 276  : 		strcat_s(sOut, iOutSz, sTemp);

  00076	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _sTemp$[ebp]
  0007c	51		 push	 ecx
  0007d	53		 push	 ebx
  0007e	57		 push	 edi
  0007f	e8 00 00 00 00	 call	 _strcat_s
  00084	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN6@BuildConne:

; 277  : 	}
; 278  : 
; 279  : 	if(strlen(SQLCon->sApplicationName) > 0)

  00087	8b c6		 mov	 eax, esi
  00089	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0008c	8d 64 24 00	 npad	 4
$LL10@BuildConne:
  00090	8a 08		 mov	 cl, BYTE PTR [eax]
  00092	40		 inc	 eax
  00093	84 c9		 test	 cl, cl
  00095	75 f9		 jne	 SHORT $LL10@BuildConne
  00097	2b c2		 sub	 eax, edx
  00099	74 28		 je	 SHORT $LN5@BuildConne

; 280  : 	{
; 281  : 		sprintf_s(sTemp, sizeof(sTemp), "APP=%s;", SQLCon->sApplicationName);

  0009b	56		 push	 esi
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_07PEOJBJKP@APP?$DN?$CFs?$DL?$AA@
  000a1	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _sTemp$[ebp]
  000a7	68 00 04 00 00	 push	 1024			; 00000400H
  000ac	52		 push	 edx
  000ad	e8 00 00 00 00	 call	 _sprintf_s

; 282  : 		strcat_s(sOut, iOutSz, sTemp);

  000b2	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _sTemp$[ebp]
  000b8	50		 push	 eax
  000b9	53		 push	 ebx
  000ba	57		 push	 edi
  000bb	e8 00 00 00 00	 call	 _strcat_s
  000c0	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN5@BuildConne:

; 283  : 	}
; 284  : 
; 285  : 	if(SQLCon->bUseTCPIPConnection)

  000c3	80 be 01 06 00
	00 00		 cmp	 BYTE PTR [esi+1537], 0
  000ca	74 35		 je	 SHORT $LN4@BuildConne

; 286  : 	{
; 287  : 		sprintf_s(sTemp, sizeof(sTemp), "NETWORK=DBMSSOCN;ADDRESS=%s,%d;", SQLCon->sServer, SQLCon->iPort);

  000cc	8b 8e fc 05 00
	00		 mov	 ecx, DWORD PTR [esi+1532]
  000d2	51		 push	 ecx
  000d3	8d 86 fe 01 00
	00		 lea	 eax, DWORD PTR [esi+510]
  000d9	50		 push	 eax
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@DKNHJPDK@NETWORK?$DNDBMSSOCN?$DLADDRESS?$DN?$CFs?0?$CFd?$DL?$AA@
  000df	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _sTemp$[ebp]
  000e5	68 00 04 00 00	 push	 1024			; 00000400H
  000ea	52		 push	 edx
  000eb	e8 00 00 00 00	 call	 _sprintf_s

; 288  : 		strcat_s(sOut, iOutSz, sTemp);

  000f0	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _sTemp$[ebp]
  000f6	50		 push	 eax
  000f7	53		 push	 ebx
  000f8	57		 push	 edi
  000f9	e8 00 00 00 00	 call	 _strcat_s
  000fe	83 c4 20	 add	 esp, 32			; 00000020H
$LN4@BuildConne:

; 289  : 	}
; 290  : 
; 291  : 	if(SQLCon->bUseMARS)

  00101	80 be 02 06 00
	00 00		 cmp	 BYTE PTR [esi+1538], 0
  00108	74 0f		 je	 SHORT $LN3@BuildConne

; 292  : 	{
; 293  : 		strcat_s(sOut, iOutSz, "MARS_Connection=yes;");

  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EGPIJBHM@MARS_Connection?$DNyes?$DL?$AA@
  0010f	53		 push	 ebx
  00110	57		 push	 edi
  00111	e8 00 00 00 00	 call	 _strcat_s
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@BuildConne:

; 294  : 	}
; 295  : 
; 296  : 	if(SQLCon->bUseTrustedConnection)

  00119	80 be 00 06 00
	00 00		 cmp	 BYTE PTR [esi+1536], 0
  00120	74 11		 je	 SHORT $LN2@BuildConne

; 297  : 	{
; 298  : 		strcat_s(sOut, iOutSz, "TRUSTED_CONNECTION=yes;");

  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@DBBFHKN@TRUSTED_CONNECTION?$DNyes?$DL?$AA@
  00127	53		 push	 ebx
  00128	57		 push	 edi
  00129	e8 00 00 00 00	 call	 _strcat_s
  0012e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 299  : 	}
; 300  : 	else{

  00131	eb 35		 jmp	 SHORT $LN11@BuildConne
$LN2@BuildConne:

; 301  : 		sprintf_s(sTemp, sizeof(sTemp), "UID=%s;PWD=%s;TRUSTED_CONNECTION=no;", SQLCon->sUID, SQLCon->sPwd);

  00133	8d 8e fb 04 00
	00		 lea	 ecx, DWORD PTR [esi+1275]
  00139	51		 push	 ecx
  0013a	81 c6 fc 03 00
	00		 add	 esi, 1020		; 000003fcH
  00140	56		 push	 esi
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@GIMGDFEP@UID?$DN?$CFs?$DLPWD?$DN?$CFs?$DLTRUSTED_CONNECTION@
  00146	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _sTemp$[ebp]
  0014c	68 00 04 00 00	 push	 1024			; 00000400H
  00151	52		 push	 edx
  00152	e8 00 00 00 00	 call	 _sprintf_s

; 302  : 		strcat_s(sOut, iOutSz, sTemp);

  00157	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _sTemp$[ebp]
  0015d	50		 push	 eax
  0015e	53		 push	 ebx
  0015f	57		 push	 edi
  00160	e8 00 00 00 00	 call	 _strcat_s
  00165	83 c4 20	 add	 esp, 32			; 00000020H
$LN11@BuildConne:

; 303  : 	}
; 304  : 
; 305  : 	return true;
; 306  : }

  00168	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	33 cd		 xor	 ecx, ebp
  0016f	b0 01		 mov	 al, 1
  00171	5b		 pop	 ebx
  00172	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c2 0c 00	 ret	 12			; 0000000cH
?BuildConnectionString@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@PADH@Z ENDP ; CSQL::BuildConnectionString
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetErrorMessage@CSQL@@QAE_NPAHPADHPAX@Z	; CSQL::GetErrorMessage
EXTRN	_SQLErrorA@32:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GetErrorMessage@CSQL@@QAE_NPAHPADHPAX@Z
_TEXT	SEGMENT
_iOutErrorMsgSz$ = -28					; size = 2
_sSQLState$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_iOutErr$ = 8						; size = 4
_sOutError$ = 12					; size = 4
_iErrBufSz$ = 16					; size = 4
_hStmt$ = 20						; size = 4
?GetErrorMessage@CSQL@@QAE_NPAHPADHPAX@Z PROC		; CSQL::GetErrorMessage, COMDAT
; _this$ = ecx

; 311  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 0c	 mov	 edx, DWORD PTR _sOutError$[ebp]
  00013	56		 push	 esi
  00014	8b 75 14	 mov	 esi, DWORD PTR _hStmt$[ebp]
  00017	57		 push	 edi

; 312  : 	SQLCHAR     sSQLState[20];
; 313  : 	SQLSMALLINT iOutErrorMsgSz;
; 314  : 
; 315  : 	return SQL_SUCCEEDED(SQLErrorA(this->hSQLEnvironment, this->hSQLConnection,
; 316  : 		hStmt, sSQLState, (SQLINTEGER *)iOutErr, (SQLCHAR *)sOutError, iErrBufSz, &iOutErrorMsgSz));

  00018	8d 7d e4	 lea	 edi, DWORD PTR _iOutErrorMsgSz$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 10	 mov	 edi, DWORD PTR _iErrBufSz$[ebp]
  0001f	57		 push	 edi
  00020	52		 push	 edx
  00021	8b c1		 mov	 eax, ecx
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _iOutErr$[ebp]
  00026	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00029	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002c	51		 push	 ecx
  0002d	8d 4d e8	 lea	 ecx, DWORD PTR _sSQLState$[ebp]
  00030	51		 push	 ecx
  00031	56		 push	 esi
  00032	52		 push	 edx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _SQLErrorA@32

; 317  : }

  00039	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003c	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  00040	b8 00 00 00 00	 mov	 eax, 0
  00045	0f 94 c0	 sete	 al
  00048	5f		 pop	 edi
  00049	33 cd		 xor	 ecx, ebp
  0004b	5e		 pop	 esi
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 10 00	 ret	 16			; 00000010H
?GetErrorMessage@CSQL@@QAE_NPAHPADHPAX@Z ENDP		; CSQL::GetErrorMessage
_TEXT	ENDS
PUBLIC	??_C@_04MOIEMOLJ@CSQL?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ThrowError@CSQL@@QAE_NPAX@Z			; CSQL::ThrowError
;	COMDAT ??_C@_04MOIEMOLJ@CSQL?$AA@
CONST	SEGMENT
??_C@_04MOIEMOLJ@CSQL?$AA@ DB 'CSQL', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ThrowError@CSQL@@QAE_NPAX@Z
_TEXT	SEGMENT
_iNativeError$ = -2056					; size = 4
_sErrorMsg$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_hStmt$ = 8						; size = 4
?ThrowError@CSQL@@QAE_NPAX@Z PROC			; CSQL::ThrowError, COMDAT
; _this$ = ecx

; 334  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 08 00
	00		 sub	 esp, 2056		; 00000808H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _hStmt$[ebp]
  00016	56		 push	 esi

; 335  : 	char sErrorMsg[2048];
; 336  : 	int iNativeError = 0;
; 337  : 
; 338  : 	if(GetErrorMessage(&iNativeError, sErrorMsg, sizeof(sErrorMsg), hStmt))

  00017	50		 push	 eax
  00018	68 00 08 00 00	 push	 2048			; 00000800H
  0001d	8b f1		 mov	 esi, ecx
  0001f	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _sErrorMsg$[ebp]
  00025	50		 push	 eax
  00026	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _iNativeError$[ebp]
  0002c	51		 push	 ecx
  0002d	8b ce		 mov	 ecx, esi
  0002f	c7 85 f8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _iNativeError$[ebp], 0
  00039	e8 00 00 00 00	 call	 ?GetErrorMessage@CSQL@@QAE_NPAHPADHPAX@Z ; CSQL::GetErrorMessage
  0003e	84 c0		 test	 al, al
  00040	74 32		 je	 SHORT $LN2@ThrowError

; 339  : 	{
; 340  : 		if(this->pErrorHandler)

  00042	8b 36		 mov	 esi, DWORD PTR [esi]
  00044	85 f6		 test	 esi, esi
  00046	74 19		 je	 SHORT $LN1@ThrowError

; 341  : 		{
; 342  : 			this->pErrorHandler("CSQL", sErrorMsg, iNativeError);

  00048	8b 95 f8 f7 ff
	ff		 mov	 edx, DWORD PTR _iNativeError$[ebp]
  0004e	52		 push	 edx
  0004f	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _sErrorMsg$[ebp]
  00055	50		 push	 eax
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_04MOIEMOLJ@CSQL?$AA@
  0005b	ff d6		 call	 esi
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 343  : 			#ifdef CSQL_THROW_HARD_ERRORS
; 344  : 				__debugbreak();

  00060	cc		 int	 3
$LN1@ThrowError:

; 345  : 			#endif
; 346  : 		}
; 347  : 		return true;

  00061	b0 01		 mov	 al, 1
  00063	5e		 pop	 esi

; 348  : 	}
; 349  : 
; 350  : 	return false;
; 351  : }

  00064	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00067	33 cd		 xor	 ecx, ebp
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN2@ThrowError:
  00074	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00077	33 cd		 xor	 ecx, ebp
  00079	32 c0		 xor	 al, al
  0007b	5e		 pop	 esi
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
?ThrowError@CSQL@@QAE_NPAX@Z ENDP			; CSQL::ThrowError
_TEXT	ENDS
PUBLIC	?Disconnect@CSQL@@QAEXXZ			; CSQL::Disconnect
EXTRN	_SQLFreeHandle@8:PROC
EXTRN	_SQLDisconnect@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Disconnect@CSQL@@QAEXXZ
_TEXT	SEGMENT
?Disconnect@CSQL@@QAEXXZ PROC				; CSQL::Disconnect, COMDAT
; _this$ = ecx

; 356  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 357  :     if(this->bConnected)

  00004	33 db		 xor	 ebx, ebx
  00006	38 5e 10	 cmp	 BYTE PTR [esi+16], bl
  00009	74 1f		 je	 SHORT $LN1@Disconnect

; 358  :     {
; 359  :         SQLDisconnect(this->hSQLConnection);

  0000b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _SQLDisconnect@4

; 360  :         SQLFreeHandle(SQL_HANDLE_DBC, this->hSQLConnection);

  00014	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00017	51		 push	 ecx
  00018	6a 02		 push	 2
  0001a	e8 00 00 00 00	 call	 _SQLFreeHandle@8

; 361  :         SQLFreeHandle(SQL_HANDLE_ENV, this->hSQLEnvironment);

  0001f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00022	52		 push	 edx
  00023	6a 01		 push	 1
  00025	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$LN1@Disconnect:

; 362  :     }
; 363  : 
; 364  :     this->hSQLConnection = NULL;

  0002a	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx

; 365  :     this->hSQLEnvironment = NULL;

  0002d	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 366  : 
; 367  :     this->bConnected = false;

  00030	88 5e 10	 mov	 BYTE PTR [esi+16], bl

; 368  :     this->bThrowErrors = true;

  00033	66 c7 46 04 01
	00		 mov	 WORD PTR [esi+4], 1

; 369  : 	this->bUseBulkOperations = false;
; 370  : 	this->dwTimeout = 30;

  00039	c7 46 14 1e 00
	00 00		 mov	 DWORD PTR [esi+20], 30	; 0000001eH
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx

; 371  : }

  00042	c3		 ret	 0
?Disconnect@CSQL@@QAEXXZ ENDP				; CSQL::Disconnect
_TEXT	ENDS
PUBLIC	?SetErrorHandler@CSQL@@QAEXP6AHPBD0H@Z@Z	; CSQL::SetErrorHandler
; Function compile flags: /Ogtp
;	COMDAT ?SetErrorHandler@CSQL@@QAEXP6AHPBD0H@Z@Z
_TEXT	SEGMENT
_pHandler$ = 8						; size = 4
?SetErrorHandler@CSQL@@QAEXP6AHPBD0H@Z@Z PROC		; CSQL::SetErrorHandler, COMDAT
; _this$ = ecx

; 642  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 643  : 	this->pErrorHandler = pHandler;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pHandler$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 644  : }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?SetErrorHandler@CSQL@@QAEXP6AHPBD0H@Z@Z ENDP		; CSQL::SetErrorHandler
_TEXT	ENDS
PUBLIC	??0CSQL@@QAE@XZ					; CSQL::CSQL
; Function compile flags: /Ogtp
;	COMDAT ??0CSQL@@QAE@XZ
_TEXT	SEGMENT
??0CSQL@@QAE@XZ PROC					; CSQL::CSQL, COMDAT
; _this$ = ecx

; 69   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 70   : 	this->bConnected = false;

  00003	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0

; 71   : 	this->Disconnect();

  00007	e8 00 00 00 00	 call	 ?Disconnect@CSQL@@QAEXXZ ; CSQL::Disconnect

; 72   : }

  0000c	8b c6		 mov	 eax, esi
  0000e	5e		 pop	 esi
  0000f	c3		 ret	 0
??0CSQL@@QAE@XZ ENDP					; CSQL::CSQL
_TEXT	ENDS
PUBLIC	??1CSQL@@QAE@XZ					; CSQL::~CSQL
; Function compile flags: /Ogtp
;	COMDAT ??1CSQL@@QAE@XZ
_TEXT	SEGMENT
??1CSQL@@QAE@XZ PROC					; CSQL::~CSQL, COMDAT
; _this$ = ecx

; 78   :     this->Disconnect();

  00000	e9 00 00 00 00	 jmp	 ?Disconnect@CSQL@@QAEXXZ ; CSQL::Disconnect
??1CSQL@@QAE@XZ ENDP					; CSQL::~CSQL
_TEXT	ENDS
PUBLIC	?ThrowErrorIfSet@CSQL@@QAE_NPAX@Z		; CSQL::ThrowErrorIfSet
; Function compile flags: /Ogtp
;	COMDAT ?ThrowErrorIfSet@CSQL@@QAE_NPAX@Z
_TEXT	SEGMENT
_hStmt$ = 8						; size = 4
?ThrowErrorIfSet@CSQL@@QAE_NPAX@Z PROC			; CSQL::ThrowErrorIfSet, COMDAT
; _this$ = ecx

; 322  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 323  : 	if(this->bThrowErrors)

  00003	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  00007	74 06		 je	 SHORT $LN1@ThrowError@2

; 329  : }

  00009	5d		 pop	 ebp

; 324  : 	{
; 325  : 		return this->ThrowError(hStmt);

  0000a	e9 00 00 00 00	 jmp	 ?ThrowError@CSQL@@QAE_NPAX@Z ; CSQL::ThrowError
$LN1@ThrowError@2:

; 326  : 	}
; 327  : 
; 328  : 	return false;

  0000f	32 c0		 xor	 al, al

; 329  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?ThrowErrorIfSet@CSQL@@QAE_NPAX@Z ENDP			; CSQL::ThrowErrorIfSet
_TEXT	ENDS
PUBLIC	?Execute@CSQL@@QAE_NPBD@Z			; CSQL::Execute
EXTRN	_SQLFreeStmt@8:PROC
EXTRN	_SQLExecDirectA@12:PROC
EXTRN	_SQLSetStmtOption@12:PROC
EXTRN	_SQLAllocHandle@12:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Execute@CSQL@@QAE_NPBD@Z
_TEXT	SEGMENT
_stmtHandle$ = -4					; size = 4
_sSQL$ = 8						; size = 4
?Execute@CSQL@@QAE_NPBD@Z PROC				; CSQL::Execute, COMDAT
; _this$ = ecx

; 398  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 399  :     if(!bConnected)

  00007	80 7f 10 00	 cmp	 BYTE PTR [edi+16], 0
  0000b	75 09		 jne	 SHORT $LN9@Execute

; 400  : 	{
; 401  :         return false;

  0000d	32 c0		 xor	 al, al
  0000f	5f		 pop	 edi

; 432  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN9@Execute:

; 402  : 	}
; 403  : 
; 404  :     SQLRETURN Result = 0;
; 405  : 
; 406  : 	bool bResult = false;
; 407  : 
; 408  :     HSTMT stmtHandle = NULL;
; 409  : 
; 410  : 	Result = SQLAllocHandle(SQL_HANDLE_STMT, this->hSQLConnection, &stmtHandle);

  00016	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00019	53		 push	 ebx
  0001a	8d 45 fc	 lea	 eax, DWORD PTR _stmtHandle$[ebp]
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	6a 03		 push	 3
  00021	32 db		 xor	 bl, bl
  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _stmtHandle$[ebp], 0
  0002a	e8 00 00 00 00	 call	 _SQLAllocHandle@12

; 411  :     if(SQL_SUCCEEDED(Result))

  0002f	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  00033	75 74		 jne	 SHORT $LN8@Execute

; 412  :     {
; 413  : 		SQLSetStmtOption(stmtHandle, SQL_RETRIEVE_DATA, SQL_RD_OFF);

  00035	8b 55 fc	 mov	 edx, DWORD PTR _stmtHandle$[ebp]
  00038	56		 push	 esi
  00039	6a 00		 push	 0
  0003b	6a 0b		 push	 11			; 0000000bH
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 _SQLSetStmtOption@12

; 414  : 		SQLSetStmtOption(stmtHandle, SQL_ATTR_QUERY_TIMEOUT, this->dwTimeout);

  00043	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _stmtHandle$[ebp]
  00049	50		 push	 eax
  0004a	6a 00		 push	 0
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 _SQLSetStmtOption@12

; 415  : 
; 416  : 		Result = SQLExecDirectA(stmtHandle, (unsigned char *)sSQL, strlen(sSQL));

  00052	8b 55 08	 mov	 edx, DWORD PTR _sSQL$[ebp]
  00055	8b c2		 mov	 eax, edx
  00057	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0005a	8d 9b 00 00 00
	00		 npad	 6
$LL12@Execute:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	40		 inc	 eax
  00063	84 c9		 test	 cl, cl
  00065	75 f9		 jne	 SHORT $LL12@Execute
  00067	2b c6		 sub	 eax, esi
  00069	50		 push	 eax
  0006a	52		 push	 edx
  0006b	8b 55 fc	 mov	 edx, DWORD PTR _stmtHandle$[ebp]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 _SQLExecDirectA@12
  00074	0f b7 c0	 movzx	 eax, ax

; 417  :         if(SQL_SUCCEEDED(Result) || Result == SQL_NO_DATA)

  00077	8b c8		 mov	 ecx, eax
  00079	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0007c	5e		 pop	 esi
  0007d	66 85 c9	 test	 cx, cx
  00080	74 0c		 je	 SHORT $LN6@Execute
  00082	66 83 f8 64	 cmp	 ax, 100			; 00000064H
  00086	74 06		 je	 SHORT $LN6@Execute

; 423  :         } else this->ThrowErrorIfSet(stmtHandle);

  00088	8b 55 fc	 mov	 edx, DWORD PTR _stmtHandle$[ebp]
  0008b	52		 push	 edx
  0008c	eb 1f		 jmp	 SHORT $LN13@Execute
$LN6@Execute:

; 418  :         {
; 419  :             if(Result == SQL_SUCCESS || Result == SQL_SUCCESS_WITH_INFO || Result == SQL_NO_DATA)

  0008e	66 85 c0	 test	 ax, ax
  00091	74 12		 je	 SHORT $LN4@Execute
  00093	66 83 f8 01	 cmp	 ax, 1
  00097	74 0c		 je	 SHORT $LN4@Execute
  00099	66 83 f8 64	 cmp	 ax, 100			; 00000064H
  0009d	74 06		 je	 SHORT $LN4@Execute

; 422  :             } else this->ThrowErrorIfSet(stmtHandle);

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _stmtHandle$[ebp]
  000a2	50		 push	 eax
  000a3	eb 08		 jmp	 SHORT $LN13@Execute
$LN4@Execute:

; 420  :             {
; 421  :                 bResult = true;

  000a5	b3 01		 mov	 bl, 1

; 423  :         } else this->ThrowErrorIfSet(stmtHandle);

  000a7	eb 0b		 jmp	 SHORT $LN1@Execute
$LN8@Execute:

; 424  :     } else this->ThrowErrorIfSet(stmtHandle);

  000a9	8b 4d fc	 mov	 ecx, DWORD PTR _stmtHandle$[ebp]
  000ac	51		 push	 ecx
$LN13@Execute:
  000ad	8b cf		 mov	 ecx, edi
  000af	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CSQL@@QAE_NPAX@Z ; CSQL::ThrowErrorIfSet
$LN1@Execute:

; 425  : 
; 426  : 	SQLFreeStmt(stmtHandle, SQL_CLOSE);

  000b4	8b 55 fc	 mov	 edx, DWORD PTR _stmtHandle$[ebp]
  000b7	6a 00		 push	 0
  000b9	52		 push	 edx
  000ba	e8 00 00 00 00	 call	 _SQLFreeStmt@8

; 427  : 	SQLFreeHandle(SQL_HANDLE_STMT, stmtHandle);

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _stmtHandle$[ebp]
  000c2	50		 push	 eax
  000c3	6a 03		 push	 3
  000c5	e8 00 00 00 00	 call	 _SQLFreeHandle@8

; 428  : 
; 429  : 	stmtHandle = NULL;
; 430  :     
; 431  : 	return bResult;

  000ca	8a c3		 mov	 al, bl
  000cc	5b		 pop	 ebx
  000cd	5f		 pop	 edi

; 432  : }

  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c2 04 00	 ret	 4
?Execute@CSQL@@QAE_NPBD@Z ENDP				; CSQL::Execute
_TEXT	ENDS
PUBLIC	?Execute@CSQL@@QAE_NPBDPAVCRecordSet@@@Z	; CSQL::Execute
EXTRN	_SQLNumResultCols@8:PROC
EXTRN	_SQLRowCount@8:PROC
EXTRN	_SQLExecute@4:PROC
EXTRN	_SQLPrepareA@12:PROC
EXTRN	?SetErrorHandler@CRecordSet@@QAEXP6AHPBD0H@Z@Z:PROC ; CRecordSet::SetErrorHandler
; Function compile flags: /Ogtp
;	COMDAT ?Execute@CSQL@@QAE_NPBDPAVCRecordSet@@@Z
_TEXT	SEGMENT
_sSQL$ = 8						; size = 4
_lpMyRS$ = 12						; size = 4
?Execute@CSQL@@QAE_NPBDPAVCRecordSet@@@Z PROC		; CSQL::Execute, COMDAT
; _this$ = ecx

; 437  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 438  : 	if(!this->bConnected)

  00006	80 7f 10 00	 cmp	 BYTE PTR [edi+16], 0
  0000a	75 07		 jne	 SHORT $LN10@Execute@2

; 439  : 	{
; 440  :         return false;

  0000c	32 c0		 xor	 al, al
  0000e	5f		 pop	 edi

; 477  : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
$LN10@Execute@2:

; 441  : 	}
; 442  : 
; 443  : 	lpMyRS->SetErrorHandler(this->pErrorHandler);

  00013	8b 07		 mov	 eax, DWORD PTR [edi]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b 75 0c	 mov	 esi, DWORD PTR _lpMyRS$[ebp]
  0001a	50		 push	 eax
  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?SetErrorHandler@CRecordSet@@QAEXP6AHPBD0H@Z@Z ; CRecordSet::SetErrorHandler

; 444  : 
; 445  : 	SQLRETURN Result = 0;
; 446  : 
; 447  :     Result = SQLAllocHandle(SQL_HANDLE_STMT, this->hSQLConnection, &lpMyRS->hSTMT);

  00022	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00025	83 c6 04	 add	 esi, 4
  00028	56		 push	 esi
  00029	51		 push	 ecx
  0002a	6a 03		 push	 3
  0002c	e8 00 00 00 00	 call	 _SQLAllocHandle@12

; 448  :     if(SQL_SUCCEEDED(Result))

  00031	66 a9 fe ff	 test	 ax, -2			; fffffffeH

; 449  :     {
; 450  : 		SQLSetStmtOption(lpMyRS->hSTMT, SQL_ATTR_QUERY_TIMEOUT, this->dwTimeout);

  00035	8b 06		 mov	 eax, DWORD PTR [esi]
  00037	0f 85 b5 00 00
	00		 jne	 $LN9@Execute@2
  0003d	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00040	52		 push	 edx
  00041	6a 00		 push	 0
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _SQLSetStmtOption@12

; 451  : 		SQLSetStmtOption(lpMyRS->hSTMT, SQL_CONCURRENCY, SQL_CONCUR_READ_ONLY);

  00049	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004b	6a 01		 push	 1
  0004d	6a 07		 push	 7
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _SQLSetStmtOption@12

; 452  : 		SQLSetStmtOption(lpMyRS->hSTMT, SQL_CURSOR_TYPE, SQL_CURSOR_STATIC);

  00055	8b 16		 mov	 edx, DWORD PTR [esi]
  00057	6a 03		 push	 3
  00059	6a 06		 push	 6
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _SQLSetStmtOption@12

; 453  : 
; 454  : 		Result = SQLPrepareA(lpMyRS->hSTMT, (unsigned char *)sSQL, strlen(sSQL));

  00061	8b 55 08	 mov	 edx, DWORD PTR _sSQL$[ebp]
  00064	8b c2		 mov	 eax, edx
  00066	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL13@Execute@2:
  00070	8a 08		 mov	 cl, BYTE PTR [eax]
  00072	40		 inc	 eax
  00073	84 c9		 test	 cl, cl
  00075	75 f9		 jne	 SHORT $LL13@Execute@2
  00077	2b c3		 sub	 eax, ebx
  00079	50		 push	 eax
  0007a	8b 06		 mov	 eax, DWORD PTR [esi]
  0007c	52		 push	 edx
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _SQLPrepareA@12

; 455  :         if(SQL_SUCCEEDED(Result))

  00083	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  00087	75 1c		 jne	 SHORT $LN8@Execute@2

; 456  :         {
; 457  : 			Result = SQLExecute(lpMyRS->hSTMT);

  00089	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 _SQLExecute@4
  00091	0f b7 c0	 movzx	 eax, ax

; 458  :             if(Result == SQL_SUCCESS || Result == SQL_SUCCESS_WITH_INFO || Result == SQL_NO_DATA)

  00094	66 85 c0	 test	 ax, ax
  00097	74 1f		 je	 SHORT $LN6@Execute@2
  00099	66 83 f8 01	 cmp	 ax, 1
  0009d	74 19		 je	 SHORT $LN6@Execute@2
  0009f	66 83 f8 64	 cmp	 ax, 100			; 00000064H
  000a3	74 13		 je	 SHORT $LN6@Execute@2
$LN8@Execute@2:

; 471  : 
; 472  :             } else this->ThrowErrorIfSet(lpMyRS->hSTMT);

  000a5	8b 16		 mov	 edx, DWORD PTR [esi]
  000a7	52		 push	 edx

; 473  :         } else this->ThrowErrorIfSet(lpMyRS->hSTMT);
; 474  :     } else this->ThrowErrorIfSet(lpMyRS->hSTMT);

  000a8	8b cf		 mov	 ecx, edi
  000aa	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CSQL@@QAE_NPAX@Z ; CSQL::ThrowErrorIfSet
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx

; 475  : 
; 476  : 	return false;

  000b1	32 c0		 xor	 al, al
  000b3	5f		 pop	 edi

; 477  : }

  000b4	5d		 pop	 ebp
  000b5	c2 08 00	 ret	 8
$LN6@Execute@2:

; 459  :             {
; 460  : 				if(SQLRowCount(lpMyRS->hSTMT, &lpMyRS->RowCount) != SQL_SUCCESS)

  000b8	8b 5d 0c	 mov	 ebx, DWORD PTR _lpMyRS$[ebp]
  000bb	8b 06		 mov	 eax, DWORD PTR [esi]
  000bd	8d 7b 08	 lea	 edi, DWORD PTR [ebx+8]
  000c0	57		 push	 edi
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 _SQLRowCount@8
  000c7	66 85 c0	 test	 ax, ax
  000ca	74 06		 je	 SHORT $LN5@Execute@2

; 461  : 				{
; 462  : 					lpMyRS->RowCount = 0;

  000cc	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN5@Execute@2:

; 463  : 				}
; 464  : 
; 465  : 				if(SQLNumResultCols(lpMyRS->hSTMT, (SQLSMALLINT *) &lpMyRS->ColumnCount) != SQL_SUCCESS)

  000d2	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000d4	8d 7b 0c	 lea	 edi, DWORD PTR [ebx+12]
  000d7	57		 push	 edi
  000d8	51		 push	 ecx
  000d9	e8 00 00 00 00	 call	 _SQLNumResultCols@8
  000de	66 85 c0	 test	 ax, ax
  000e1	74 06		 je	 SHORT $LN4@Execute@2

; 466  : 				{
; 467  : 					lpMyRS->ColumnCount = 0;

  000e3	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN4@Execute@2:
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx

; 468  : 				}
; 469  : 
; 470  : 				return true;

  000eb	b0 01		 mov	 al, 1
  000ed	5f		 pop	 edi

; 477  : }

  000ee	5d		 pop	 ebp
  000ef	c2 08 00	 ret	 8
$LN9@Execute@2:

; 473  :         } else this->ThrowErrorIfSet(lpMyRS->hSTMT);
; 474  :     } else this->ThrowErrorIfSet(lpMyRS->hSTMT);

  000f2	50		 push	 eax
  000f3	8b cf		 mov	 ecx, edi
  000f5	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CSQL@@QAE_NPAX@Z ; CSQL::ThrowErrorIfSet
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx

; 475  : 
; 476  : 	return false;

  000fc	32 c0		 xor	 al, al
  000fe	5f		 pop	 edi

; 477  : }

  000ff	5d		 pop	 ebp
  00100	c2 08 00	 ret	 8
?Execute@CSQL@@QAE_NPBDPAVCRecordSet@@@Z ENDP		; CSQL::Execute
_TEXT	ENDS
PUBLIC	?Execute@CSQL@@QAE_NPBDPAVCBoundRecordSet@@_N@Z	; CSQL::Execute
EXTRN	?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z:PROC ; CBoundRecordSet::Bind
EXTRN	?GetDefaultConversion@CBoundRecordSet@@QAE?AW4CType@CTypes@@W4SQLType@SQLTypes@@@Z:PROC ; CBoundRecordSet::GetDefaultConversion
EXTRN	?GetColumnInfo@CBoundRecordSet@@QAE_NHPADHPAH1111@Z:PROC ; CBoundRecordSet::GetColumnInfo
EXTRN	_calloc:PROC
EXTRN	?SetErrorHandler@CBoundRecordSet@@QAEXP6AHPBD0H@Z@Z:PROC ; CBoundRecordSet::SetErrorHandler
; Function compile flags: /Ogtp
;	COMDAT ?Execute@CSQL@@QAE_NPBDPAVCBoundRecordSet@@_N@Z
_TEXT	SEGMENT
_iIsNullable$157340 = -8				; size = 4
_iColumnNameLength$157339 = -4				; size = 4
_iDataType$157341 = 8					; size = 4
_sSQL$ = 8						; size = 4
tv354 = 12						; size = 4
tv340 = 12						; size = 4
_lpMyRS$ = 12						; size = 4
_AutoBindAll$ = 16					; size = 1
?Execute@CSQL@@QAE_NPBDPAVCBoundRecordSet@@_N@Z PROC	; CSQL::Execute, COMDAT
; _this$ = ecx

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 490  : 	if(!this->bConnected)

  00009	80 7f 10 00	 cmp	 BYTE PTR [edi+16], 0
  0000d	75 09		 jne	 SHORT $LN15@Execute@3

; 491  : 	{
; 492  :         return false;

  0000f	32 c0		 xor	 al, al
  00011	5f		 pop	 edi

; 564  : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
$LN15@Execute@3:

; 493  : 	}
; 494  : 
; 495  : 	lpMyRS->SetErrorHandler(this->pErrorHandler);

  00018	8b 07		 mov	 eax, DWORD PTR [edi]
  0001a	53		 push	 ebx
  0001b	8b 5d 0c	 mov	 ebx, DWORD PTR _lpMyRS$[ebp]
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	8b cb		 mov	 ecx, ebx
  00022	e8 00 00 00 00	 call	 ?SetErrorHandler@CBoundRecordSet@@QAEXP6AHPBD0H@Z@Z ; CBoundRecordSet::SetErrorHandler

; 496  : 
; 497  : 	SQLRETURN Result = 0;
; 498  : 
; 499  :     Result = SQLAllocHandle(SQL_HANDLE_STMT, this->hSQLConnection, &lpMyRS->hSTMT);

  00027	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0002a	8d 73 0c	 lea	 esi, DWORD PTR [ebx+12]
  0002d	56		 push	 esi
  0002e	51		 push	 ecx
  0002f	6a 03		 push	 3
  00031	e8 00 00 00 00	 call	 _SQLAllocHandle@12

; 500  :     if(SQL_SUCCEEDED(Result))

  00036	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  0003a	0f 85 7d 01 00
	00		 jne	 $LN14@Execute@3

; 501  :     {
; 502  : 		SQLSetStmtOption(lpMyRS->hSTMT, SQL_ATTR_QUERY_TIMEOUT, this->dwTimeout);

  00040	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00043	8b 06		 mov	 eax, DWORD PTR [esi]
  00045	52		 push	 edx
  00046	6a 00		 push	 0
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _SQLSetStmtOption@12

; 503  : 		SQLSetStmtOption(lpMyRS->hSTMT, SQL_CONCURRENCY, SQL_CONCUR_READ_ONLY);

  0004e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00050	6a 01		 push	 1
  00052	6a 07		 push	 7
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _SQLSetStmtOption@12

; 504  : 		SQLSetStmtOption(lpMyRS->hSTMT, SQL_CURSOR_TYPE, SQL_CURSOR_STATIC);

  0005a	8b 16		 mov	 edx, DWORD PTR [esi]
  0005c	6a 03		 push	 3
  0005e	6a 06		 push	 6
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 _SQLSetStmtOption@12

; 505  : 		
; 506  : 		Result = SQLPrepareA(lpMyRS->hSTMT, (unsigned char *)sSQL, strlen(sSQL));

  00066	8b 55 08	 mov	 edx, DWORD PTR _sSQL$[ebp]
  00069	8b c2		 mov	 eax, edx
  0006b	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0006e	89 4d 0c	 mov	 DWORD PTR tv340[ebp], ecx
$LL20@Execute@3:
  00071	8a 08		 mov	 cl, BYTE PTR [eax]
  00073	40		 inc	 eax
  00074	84 c9		 test	 cl, cl
  00076	75 f9		 jne	 SHORT $LL20@Execute@3
  00078	2b 45 0c	 sub	 eax, DWORD PTR tv340[ebp]
  0007b	50		 push	 eax
  0007c	52		 push	 edx
  0007d	8b 16		 mov	 edx, DWORD PTR [esi]
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 _SQLPrepareA@12

; 507  : 		if(SQL_SUCCEEDED(Result))

  00085	66 a9 fe ff	 test	 ax, -2			; fffffffeH

; 508  :         {
; 509  : 			Result = SQLExecute(lpMyRS->hSTMT);

  00089	8b 06		 mov	 eax, DWORD PTR [esi]
  0008b	50		 push	 eax
  0008c	0f 85 2e 01 00
	00		 jne	 $LN13@Execute@3
  00092	e8 00 00 00 00	 call	 _SQLExecute@4
  00097	0f b7 c0	 movzx	 eax, ax

; 510  :             if(Result == SQL_SUCCESS || Result == SQL_SUCCESS_WITH_INFO || Result == SQL_NO_DATA)

  0009a	66 85 c0	 test	 ax, ax
  0009d	74 10		 je	 SHORT $LN11@Execute@3
  0009f	66 83 f8 01	 cmp	 ax, 1
  000a3	74 0a		 je	 SHORT $LN11@Execute@3
  000a5	66 83 f8 64	 cmp	 ax, 100			; 00000064H

; 558  : 
; 559  :             } else this->ThrowErrorIfSet(lpMyRS->hSTMT);

  000a9	0f 85 0e 01 00
	00		 jne	 $LN14@Execute@3
$LN11@Execute@3:

; 511  :             {
; 512  : 				if(SQLRowCount(lpMyRS->hSTMT, &lpMyRS->RowCount) != SQL_SUCCESS)

  000af	8b 16		 mov	 edx, DWORD PTR [esi]
  000b1	8d 7b 10	 lea	 edi, DWORD PTR [ebx+16]
  000b4	57		 push	 edi
  000b5	52		 push	 edx
  000b6	e8 00 00 00 00	 call	 _SQLRowCount@8
  000bb	66 85 c0	 test	 ax, ax
  000be	74 06		 je	 SHORT $LN22@Execute@3

; 513  : 				{
; 514  : 					lpMyRS->RowCount = 0;

  000c0	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN22@Execute@3:

; 515  : 				}
; 516  : 
; 517  : 				if(SQLNumResultCols(lpMyRS->hSTMT, (SQLSMALLINT *) &lpMyRS->Columns.Count) != SQL_SUCCESS)

  000c6	8b 06		 mov	 eax, DWORD PTR [esi]
  000c8	8d 7b 08	 lea	 edi, DWORD PTR [ebx+8]
  000cb	57		 push	 edi
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _SQLNumResultCols@8
  000d2	66 85 c0	 test	 ax, ax
  000d5	74 06		 je	 SHORT $LN23@Execute@3

; 518  : 				{
; 519  : 					lpMyRS->Columns.Count = 0;

  000d7	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN23@Execute@3:

; 520  : 				}
; 521  : 
; 522  : 				if(lpMyRS->Columns.Count > 0) //Fill in the column info for the RecordSet.

  000dd	8b 37		 mov	 esi, DWORD PTR [edi]
  000df	85 f6		 test	 esi, esi
  000e1	0f 8e cb 00 00
	00		 jle	 $LN5@Execute@3

; 523  : 				{
; 524  : 					#ifdef _USE_GLOBAL_MEMPOOL
; 525  : 						lpMyRS->Columns.Column = (LPRECORDSET_COLUMNINFO)
; 526  : 							pMem->Allocate(lpMyRS->Columns.Count, sizeof(RECORDSET_COLUMNINFO));
; 527  : 					#else
; 528  : 						lpMyRS->Columns.Column = (LPRECORDSET_COLUMNINFO)
; 529  : 							calloc(lpMyRS->Columns.Count, sizeof(RECORDSET_COLUMNINFO));

  000e7	68 20 04 00 00	 push	 1056			; 00000420H
  000ec	56		 push	 esi
  000ed	e8 00 00 00 00	 call	 _calloc

; 530  : 					#endif
; 531  : 
; 532  : 					for(int iCol = 1; iCol < (lpMyRS->Columns.Count + 1); iCol++)

  000f2	bf 01 00 00 00	 mov	 edi, 1
  000f7	46		 inc	 esi
  000f8	83 c4 08	 add	 esp, 8
  000fb	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  000fe	3b f7		 cmp	 esi, edi
  00100	0f 8e ac 00 00
	00		 jle	 $LN5@Execute@3

; 523  : 				{
; 524  : 					#ifdef _USE_GLOBAL_MEMPOOL
; 525  : 						lpMyRS->Columns.Column = (LPRECORDSET_COLUMNINFO)
; 526  : 							pMem->Allocate(lpMyRS->Columns.Count, sizeof(RECORDSET_COLUMNINFO));
; 527  : 					#else
; 528  : 						lpMyRS->Columns.Column = (LPRECORDSET_COLUMNINFO)
; 529  : 							calloc(lpMyRS->Columns.Count, sizeof(RECORDSET_COLUMNINFO));

  00106	c7 45 0c 20 04
	00 00		 mov	 DWORD PTR tv354[ebp], 1056 ; 00000420H
  0010d	8d 49 00	 npad	 3
$LL21@Execute@3:

; 533  : 					{
; 534  : 						LPRECORDSET_COLUMNINFO Pointer = &lpMyRS->Columns.Column[iCol-1];

  00110	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00113	8b 55 0c	 mov	 edx, DWORD PTR tv354[ebp]

; 535  : 						memset(&Pointer, sizeof(RECORDSET_COLUMNINFO), 0);
; 536  : 
; 537  : 						int iColumnNameLength = 0;

  00116	33 c0		 xor	 eax, eax
  00118	8d b4 11 e0 fb
	ff ff		 lea	 esi, DWORD PTR [ecx+edx-1056]
  0011f	89 45 fc	 mov	 DWORD PTR _iColumnNameLength$157339[ebp], eax

; 538  : 						int iIsNullable = 0;

  00122	89 45 f8	 mov	 DWORD PTR _iIsNullable$157340[ebp], eax

; 539  : 						int iDataType = 0;

  00125	89 45 08	 mov	 DWORD PTR _iDataType$157341[ebp], eax

; 540  : 
; 541  : 						lpMyRS->GetColumnInfo(iCol, Pointer->Name, sizeof(Pointer->Name),
; 542  : 							&iColumnNameLength, &iDataType, &Pointer->MaxSize,
; 543  : 							&Pointer->DecimalPlaces, &iIsNullable);

  00128	8d 45 f8	 lea	 eax, DWORD PTR _iIsNullable$157340[ebp]
  0012b	50		 push	 eax
  0012c	8d 8e 14 04 00
	00		 lea	 ecx, DWORD PTR [esi+1044]
  00132	51		 push	 ecx
  00133	8d 96 10 04 00
	00		 lea	 edx, DWORD PTR [esi+1040]
  00139	52		 push	 edx
  0013a	8d 45 08	 lea	 eax, DWORD PTR _iDataType$157341[ebp]
  0013d	50		 push	 eax
  0013e	8d 4d fc	 lea	 ecx, DWORD PTR _iColumnNameLength$157339[ebp]
  00141	51		 push	 ecx
  00142	68 00 04 00 00	 push	 1024			; 00000400H
  00147	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  0014a	52		 push	 edx
  0014b	57		 push	 edi
  0014c	8b cb		 mov	 ecx, ebx
  0014e	e8 00 00 00 00	 call	 ?GetColumnInfo@CBoundRecordSet@@QAE_NHPADHPAH1111@Z ; CBoundRecordSet::GetColumnInfo

; 544  : 
; 545  : 						Pointer->DataType = (SQLTypes::SQLType)iDataType;

  00153	8b 45 08	 mov	 eax, DWORD PTR _iDataType$157341[ebp]
  00156	89 86 0c 04 00
	00		 mov	 DWORD PTR [esi+1036], eax

; 546  : 						Pointer->Name[iColumnNameLength] = '\0';

  0015c	8b 4d fc	 mov	 ecx, DWORD PTR _iColumnNameLength$157339[ebp]
  0015f	c6 44 31 0c 00	 mov	 BYTE PTR [ecx+esi+12], 0

; 547  : 						Pointer->IsNullable = (iIsNullable > 0);

  00164	83 7d f8 00	 cmp	 DWORD PTR _iIsNullable$157340[ebp], 0
  00168	0f 9f c2	 setg	 dl

; 548  : 						Pointer->Ordinal = iCol;
; 549  : 						Pointer->IsBound = false;
; 550  : 						if(AutoBindAll)

  0016b	80 7d 10 00	 cmp	 BYTE PTR _AutoBindAll$[ebp], 0
  0016f	88 96 1d 04 00
	00		 mov	 BYTE PTR [esi+1053], dl
  00175	89 be 18 04 00
	00		 mov	 DWORD PTR [esi+1048], edi
  0017b	c6 86 1c 04 00
	00 00		 mov	 BYTE PTR [esi+1052], 0
  00182	74 1a		 je	 SHORT $LN6@Execute@3

; 551  : 						{
; 552  : 							lpMyRS->Bind(iCol-1, lpMyRS->GetDefaultConversion(Pointer->DataType));

  00184	8b 86 0c 04 00
	00		 mov	 eax, DWORD PTR [esi+1036]
  0018a	50		 push	 eax
  0018b	8b cb		 mov	 ecx, ebx
  0018d	e8 00 00 00 00	 call	 ?GetDefaultConversion@CBoundRecordSet@@QAE?AW4CType@CTypes@@W4SQLType@SQLTypes@@@Z ; CBoundRecordSet::GetDefaultConversion
  00192	50		 push	 eax
  00193	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
  00196	51		 push	 ecx
  00197	8b cb		 mov	 ecx, ebx
  00199	e8 00 00 00 00	 call	 ?Bind@CBoundRecordSet@@QAEPAXHW4CType@CTypes@@@Z ; CBoundRecordSet::Bind
$LN6@Execute@3:

; 530  : 					#endif
; 531  : 
; 532  : 					for(int iCol = 1; iCol < (lpMyRS->Columns.Count + 1); iCol++)

  0019e	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  001a1	81 45 0c 20 04
	00 00		 add	 DWORD PTR tv354[ebp], 1056 ; 00000420H
  001a8	47		 inc	 edi
  001a9	42		 inc	 edx
  001aa	3b fa		 cmp	 edi, edx
  001ac	0f 8c 5e ff ff
	ff		 jl	 $LL21@Execute@3
$LN5@Execute@3:
  001b2	5e		 pop	 esi
  001b3	5b		 pop	 ebx

; 553  : 						}
; 554  : 					}
; 555  : 				}
; 556  : 
; 557  : 				return true;

  001b4	b0 01		 mov	 al, 1
  001b6	5f		 pop	 edi

; 564  : }

  001b7	8b e5		 mov	 esp, ebp
  001b9	5d		 pop	 ebp
  001ba	c2 0c 00	 ret	 12			; 0000000cH
$LN14@Execute@3:

; 560  :         } else this->ThrowErrorIfSet(lpMyRS->hSTMT);
; 561  :     } else this->ThrowErrorIfSet(lpMyRS->hSTMT);

  001bd	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001bf	51		 push	 ecx
$LN13@Execute@3:
  001c0	8b cf		 mov	 ecx, edi
  001c2	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CSQL@@QAE_NPAX@Z ; CSQL::ThrowErrorIfSet
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx

; 562  : 
; 563  : 	return false;

  001c9	32 c0		 xor	 al, al
  001cb	5f		 pop	 edi

; 564  : }

  001cc	8b e5		 mov	 esp, ebp
  001ce	5d		 pop	 ebp
  001cf	c2 0c 00	 ret	 12			; 0000000cH
?Execute@CSQL@@QAE_NPBDPAVCBoundRecordSet@@_N@Z ENDP	; CSQL::Execute
_TEXT	ENDS
PUBLIC	??_C@_0BB@KJPEOBBM@SELECT?5db_name?$CI?$CJ?$AA@	; `string'
PUBLIC	?GetFocus@CSQL@@QAEHPADH@Z			; CSQL::GetFocus
EXTRN	??1CRecordSet@@QAE@XZ:PROC			; CRecordSet::~CRecordSet
EXTRN	?Close@CRecordSet@@QAE_NXZ:PROC			; CRecordSet::Close
EXTRN	?sColumnEx@CRecordSet@@QAE_NHPADHPAH@Z:PROC	; CRecordSet::sColumnEx
EXTRN	?Fetch@CRecordSet@@QAE_NXZ:PROC			; CRecordSet::Fetch
EXTRN	??0CRecordSet@@QAE@XZ:PROC			; CRecordSet::CRecordSet
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT ??_C@_0BB@KJPEOBBM@SELECT?5db_name?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@KJPEOBBM@SELECT?5db_name?$CI?$CJ?$AA@ DB 'SELECT db_name()', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetFocus@CSQL@@QAEHPADH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFocus@CSQL@@QAEHPADH@Z$0
__ehfuncinfo$?GetFocus@CSQL@@QAEHPADH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetFocus@CSQL@@QAEHPADH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?GetFocus@CSQL@@QAEHPADH@Z
_TEXT	SEGMENT
_rsTemp$ = -36						; size = 20
_iLength$157375 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sOutDatabaseName$ = 8					; size = 4
_iOutDatabaseNameSz$ = 12				; size = 4
?GetFocus@CSQL@@QAEHPADH@Z PROC				; CSQL::GetFocus, COMDAT
; _this$ = ecx

; 598  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetFocus@CSQL@@QAEHPADH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx

; 599  :     if(!bConnected)

  00028	80 7e 10 00	 cmp	 BYTE PTR [esi+16], 0
  0002c	75 15		 jne	 SHORT $LN7@GetFocus

; 600  :         return -1;

  0002e	83 c8 ff	 or	 eax, -1

; 624  : }

  00031	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00034	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003b	59		 pop	 ecx
  0003c	5e		 pop	 esi
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
$LN7@GetFocus:

; 601  : 
; 602  : 	int iResult = 0;
; 603  : 
; 604  : 	CRecordSet rsTemp;

  00043	8d 4d dc	 lea	 ecx, DWORD PTR _rsTemp$[ebp]
  00046	e8 00 00 00 00	 call	 ??0CRecordSet@@QAE@XZ	; CRecordSet::CRecordSet

; 605  : 
; 606  : 	if(this->Execute("SELECT db_name()", &rsTemp))

  0004b	8d 45 dc	 lea	 eax, DWORD PTR _rsTemp$[ebp]
  0004e	50		 push	 eax
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KJPEOBBM@SELECT?5db_name?$CI?$CJ?$AA@
  00054	8b ce		 mov	 ecx, esi
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005d	e8 00 00 00 00	 call	 ?Execute@CSQL@@QAE_NPBDPAVCRecordSet@@@Z ; CSQL::Execute
  00062	84 c0		 test	 al, al
  00064	74 58		 je	 SHORT $LN6@GetFocus

; 607  : 	{
; 608  : 		if(rsTemp.Fetch())

  00066	8d 4d dc	 lea	 ecx, DWORD PTR _rsTemp$[ebp]
  00069	e8 00 00 00 00	 call	 ?Fetch@CRecordSet@@QAE_NXZ ; CRecordSet::Fetch
  0006e	84 c0		 test	 al, al
  00070	74 3d		 je	 SHORT $LN5@GetFocus

; 609  : 		{
; 610  : 			int iLength = 0;
; 611  : 			if(rsTemp.sColumnEx(1, sOutDatabaseName, iOutDatabaseNameSz, &iLength))

  00072	8b 55 0c	 mov	 edx, DWORD PTR _iOutDatabaseNameSz$[ebp]
  00075	8b 45 08	 mov	 eax, DWORD PTR _sOutDatabaseName$[ebp]
  00078	8d 4d f0	 lea	 ecx, DWORD PTR _iLength$157375[ebp]
  0007b	51		 push	 ecx
  0007c	52		 push	 edx
  0007d	50		 push	 eax
  0007e	6a 01		 push	 1
  00080	8d 4d dc	 lea	 ecx, DWORD PTR _rsTemp$[ebp]
  00083	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iLength$157375[ebp], 0
  0008a	e8 00 00 00 00	 call	 ?sColumnEx@CRecordSet@@QAE_NHPADHPAH@Z ; CRecordSet::sColumnEx
  0008f	84 c0		 test	 al, al
  00091	74 0d		 je	 SHORT $LN4@GetFocus

; 612  : 			{
; 613  : 				iResult = iLength;

  00093	8b 75 f0	 mov	 esi, DWORD PTR _iLength$157375[ebp]

; 614  : 			}
; 615  : 			else iResult = -4;
; 616  : 		}
; 617  : 		else iResult = -3;
; 618  : 
; 619  : 		rsTemp.Close();

  00096	8d 4d dc	 lea	 ecx, DWORD PTR _rsTemp$[ebp]
  00099	e8 00 00 00 00	 call	 ?Close@CRecordSet@@QAE_NXZ ; CRecordSet::Close
  0009e	eb 23		 jmp	 SHORT $LN1@GetFocus
$LN4@GetFocus:
  000a0	8d 4d dc	 lea	 ecx, DWORD PTR _rsTemp$[ebp]
  000a3	be fc ff ff ff	 mov	 esi, -4			; fffffffcH
  000a8	e8 00 00 00 00	 call	 ?Close@CRecordSet@@QAE_NXZ ; CRecordSet::Close
  000ad	eb 14		 jmp	 SHORT $LN1@GetFocus
$LN5@GetFocus:
  000af	8d 4d dc	 lea	 ecx, DWORD PTR _rsTemp$[ebp]
  000b2	be fd ff ff ff	 mov	 esi, -3			; fffffffdH
  000b7	e8 00 00 00 00	 call	 ?Close@CRecordSet@@QAE_NXZ ; CRecordSet::Close
  000bc	eb 05		 jmp	 SHORT $LN1@GetFocus
$LN6@GetFocus:

; 620  : 	}
; 621  : 	else iResult = -2;

  000be	be fe ff ff ff	 mov	 esi, -2			; fffffffeH
$LN1@GetFocus:

; 622  : 
; 623  : 	return iResult;

  000c3	8d 4d dc	 lea	 ecx, DWORD PTR _rsTemp$[ebp]
  000c6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cd	e8 00 00 00 00	 call	 ??1CRecordSet@@QAE@XZ	; CRecordSet::~CRecordSet
  000d2	8b c6		 mov	 eax, esi

; 624  : }

  000d4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000de	59		 pop	 ecx
  000df	5e		 pop	 esi
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFocus@CSQL@@QAEHPADH@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _rsTemp$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CRecordSet@@QAE@XZ	; CRecordSet::~CRecordSet
__ehhandler$?GetFocus@CSQL@@QAEHPADH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetFocus@CSQL@@QAEHPADH@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetFocus@CSQL@@QAEHPADH@Z ENDP				; CSQL::GetFocus
PUBLIC	??_C@_08GKIIBAGD@USE?5?$FL?$CFs?$FN?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Focus@CSQL@@QAE_NPBD@Z				; CSQL::Focus
;	COMDAT ??_C@_08GKIIBAGD@USE?5?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_08GKIIBAGD@USE?5?$FL?$CFs?$FN?$AA@ DB 'USE [%s]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Focus@CSQL@@QAE_NPBD@Z
_TEXT	SEGMENT
_sSQL$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_sDatabaseName$ = 8					; size = 4
?Focus@CSQL@@QAE_NPBD@Z PROC				; CSQL::Focus, COMDAT
; _this$ = ecx

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _sDatabaseName$[ebp]
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx

; 630  :     if(!this->bConnected)

  00019	80 7e 10 00	 cmp	 BYTE PTR [esi+16], 0
  0001d	75 13		 jne	 SHORT $LN1@Focus

; 631  :         return false;

  0001f	32 c0		 xor	 al, al
  00021	5e		 pop	 esi

; 637  : }

  00022	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00025	33 cd		 xor	 ecx, ebp
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN1@Focus:

; 632  : 
; 633  : 	char sSQL[1024];
; 634  : 	sprintf_s(sSQL, sizeof(sSQL), "USE [%s]", sDatabaseName);

  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_08GKIIBAGD@USE?5?$FL?$CFs?$FN?$AA@
  00038	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _sSQL$[ebp]
  0003e	68 00 04 00 00	 push	 1024			; 00000400H
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _sprintf_s
  00049	83 c4 10	 add	 esp, 16			; 00000010H

; 635  : 
; 636  : 	return this->Execute(sSQL);

  0004c	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _sSQL$[ebp]
  00052	51		 push	 ecx
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?Execute@CSQL@@QAE_NPBD@Z ; CSQL::Execute

; 637  : }

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005d	33 cd		 xor	 ecx, ebp
  0005f	5e		 pop	 esi
  00060	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?Focus@CSQL@@QAE_NPBD@Z ENDP				; CSQL::Focus
_TEXT	ENDS
PUBLIC	_sConnectionString$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?Connect@CSQL@@QAE_NPBDP6AH00H@Z@Z		; CSQL::Connect
EXTRN	_SQLDriverConnectA@32:PROC
EXTRN	_SQLSetConnectAttr@16:PROC
EXTRN	_SQLSetConnectOption@12:PROC
EXTRN	_SQLSetEnvAttr@16:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Connect@CSQL@@QAE_NPBDP6AH00H@Z@Z
_TEXT	SEGMENT
_iConStrOutSz$ = -1036					; size = 2
_sConnectionString$GSCopy$ = -1032			; size = 4
_sConStrOut$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_sConnectionString$ = 8					; size = 4
_pHandler$ = 12						; size = 4
?Connect@CSQL@@QAE_NPBDP6AH00H@Z@Z PROC			; CSQL::Connect, COMDAT
; _this$ = ecx

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 04 00
	00		 sub	 esp, 1036		; 0000040cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _sConnectionString$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx

; 160  :     SQLRETURN Result;
; 161  :     SQLCHAR sConStrOut[1024];
; 162  :     SQLSMALLINT iConStrOutSz = 0;
; 163  : 
; 164  : 	this->SetErrorHandler(pHandler);

  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _pHandler$[ebp]
  0001d	51		 push	 ecx
  0001e	8b ce		 mov	 ecx, esi

; 244  :     {
; 245  :         ThrowErrorIfSet(NULL);

  00020	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _sConnectionString$GSCopy$[ebp], eax
  00026	c7 85 f4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _iConStrOutSz$[ebp], 0
  00030	e8 00 00 00 00	 call	 ?SetErrorHandler@CSQL@@QAEXP6AHPBD0H@Z@Z ; CSQL::SetErrorHandler
  00035	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  00039	e8 00 00 00 00	 call	 ?Disconnect@CSQL@@QAEXXZ ; CSQL::Disconnect
  0003e	8d 5e 08	 lea	 ebx, DWORD PTR [esi+8]
  00041	53		 push	 ebx
  00042	6a 00		 push	 0
  00044	6a 01		 push	 1
  00046	e8 00 00 00 00	 call	 _SQLAllocHandle@12
  0004b	6a 00		 push	 0
  0004d	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  00051	74 1b		 je	 SHORT $LN9@Connect

; 165  : 
; 166  : 	this->bConnected = false;
; 167  : 	this->Disconnect();
; 168  : 
; 169  :     // Allocate the environment handle
; 170  :     Result = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &this->hSQLEnvironment);
; 171  :     if(!SQL_SUCCEEDED(Result))
; 172  :     {
; 173  :         ThrowErrorIfSet(NULL);

  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CSQL@@QAE_NPAX@Z ; CSQL::ThrowErrorIfSet
  0005a	5e		 pop	 esi

; 174  : 		return false;

  0005b	32 c0		 xor	 al, al
  0005d	5b		 pop	 ebx

; 249  :     }
; 250  : 
; 251  :     this->bConnected = true;
; 252  : 
; 253  :     return true;
; 254  : }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	33 cd		 xor	 ecx, ebp
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 08 00	 ret	 8
$LN9@Connect:

; 175  :     }
; 176  : 
; 177  :     // Set the environment attributes
; 178  : 	Result = SQLSetEnvAttr(this->hSQLEnvironment, SQL_ATTR_ODBC_VERSION, (void *) SQL_OV_ODBC3, 0);

  0006e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00070	6a 03		 push	 3
  00072	68 c8 00 00 00	 push	 200			; 000000c8H
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 _SQLSetEnvAttr@16

; 179  :     if(!SQL_SUCCEEDED(Result))

  0007d	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  00081	74 27		 je	 SHORT $LN8@Connect

; 180  :     {
; 181  :         ThrowErrorIfSet(NULL);

  00083	6a 00		 push	 0
  00085	8b ce		 mov	 ecx, esi
  00087	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CSQL@@QAE_NPAX@Z ; CSQL::ThrowErrorIfSet

; 182  :         SQLFreeHandle(SQL_HANDLE_ENV, this->hSQLEnvironment);

  0008c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0008e	50		 push	 eax
  0008f	6a 01		 push	 1
  00091	e8 00 00 00 00	 call	 _SQLFreeHandle@8
  00096	5e		 pop	 esi

; 183  :         return false;

  00097	32 c0		 xor	 al, al
  00099	5b		 pop	 ebx

; 249  :     }
; 250  : 
; 251  :     this->bConnected = true;
; 252  : 
; 253  :     return true;
; 254  : }

  0009a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009d	33 cd		 xor	 ecx, ebp
  0009f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 08 00	 ret	 8
$LN8@Connect:

; 184  :     }
; 185  : 
; 186  :     // Allocate the connection handle
; 187  :     Result = SQLAllocHandle(SQL_HANDLE_DBC, this->hSQLEnvironment, &this->hSQLConnection);

  000aa	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000ac	57		 push	 edi
  000ad	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  000b0	57		 push	 edi
  000b1	51		 push	 ecx
  000b2	6a 02		 push	 2
  000b4	e8 00 00 00 00	 call	 _SQLAllocHandle@12

; 188  :     if(!SQL_SUCCEEDED(Result))

  000b9	66 a9 fe ff	 test	 ax, -2			; fffffffeH

; 189  :     {
; 190  :         ThrowErrorIfSet(NULL);
; 191  :         SQLFreeHandle(SQL_HANDLE_DBC, this->hSQLConnection);
; 192  :         SQLFreeHandle(SQL_HANDLE_ENV, this->hSQLEnvironment);
; 193  :         return false;

  000bd	0f 85 81 00 00
	00		 jne	 $LN13@Connect

; 194  :     }
; 195  : 
; 196  : 	// Set login timeout to 5 seconds.
; 197  :     if(!SQL_SUCCEEDED(SQLSetConnectOption(this->hSQLConnection, SQL_LOGIN_TIMEOUT, 5)))

  000c3	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c5	6a 05		 push	 5
  000c7	6a 67		 push	 103			; 00000067H
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _SQLSetConnectOption@12
  000cf	66 a9 fe ff	 test	 ax, -2			; fffffffeH

; 198  :     {
; 199  :         ThrowErrorIfSet(NULL);
; 200  :         SQLFreeHandle(SQL_HANDLE_DBC, this->hSQLConnection);
; 201  :         SQLFreeHandle(SQL_HANDLE_ENV, this->hSQLEnvironment);
; 202  :         return false;

  000d3	75 6f		 jne	 SHORT $LN13@Connect

; 203  :     }
; 204  :     if(!SQL_SUCCEEDED(SQLSetConnectOption(this->hSQLConnection, SQL_CURSOR_TYPE, SQL_CURSOR_STATIC)))

  000d5	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000d7	6a 03		 push	 3
  000d9	6a 06		 push	 6
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _SQLSetConnectOption@12
  000e1	66 a9 fe ff	 test	 ax, -2			; fffffffeH

; 205  :     {
; 206  :         ThrowErrorIfSet(NULL);
; 207  :         SQLFreeHandle(SQL_HANDLE_DBC, this->hSQLConnection);
; 208  :         SQLFreeHandle(SQL_HANDLE_ENV, this->hSQLEnvironment);
; 209  :         return false;

  000e5	75 5d		 jne	 SHORT $LN13@Connect

; 210  :     }
; 211  :     if(!SQL_SUCCEEDED(SQLSetConnectOption(this->hSQLConnection, SQL_CONCURRENCY, SQL_CONCUR_READ_ONLY)))

  000e7	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000e9	6a 01		 push	 1
  000eb	6a 07		 push	 7
  000ed	51		 push	 ecx
  000ee	e8 00 00 00 00	 call	 _SQLSetConnectOption@12
  000f3	66 a9 fe ff	 test	 ax, -2			; fffffffeH

; 212  :     {
; 213  :         ThrowErrorIfSet(NULL);
; 214  :         SQLFreeHandle(SQL_HANDLE_DBC, this->hSQLConnection);
; 215  :         SQLFreeHandle(SQL_HANDLE_ENV, this->hSQLEnvironment);
; 216  :         return false;

  000f7	75 4b		 jne	 SHORT $LN13@Connect

; 217  :     }
; 218  : 
; 219  : 	if(bUseBulkOperations)

  000f9	80 7e 05 00	 cmp	 BYTE PTR [esi+5], 0
  000fd	74 17		 je	 SHORT $LN2@Connect

; 220  : 	{
; 221  : 		if(!SQL_SUCCEEDED(SQLSetConnectAttr(this->hSQLConnection,
; 222  : 			SQL_COPT_SS_BCP, (void *)SQL_BCP_ON, SQL_IS_INTEGER)))

  000ff	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00101	6a fa		 push	 -6			; fffffffaH
  00103	6a 01		 push	 1
  00105	68 c3 04 00 00	 push	 1219			; 000004c3H
  0010a	51		 push	 ecx
  0010b	e8 00 00 00 00	 call	 _SQLSetConnectAttr@16
  00110	66 a9 fe ff	 test	 ax, -2			; fffffffeH

; 223  : 		{
; 224  : 			ThrowErrorIfSet(NULL);
; 225  : 			SQLFreeHandle(SQL_HANDLE_DBC, this->hSQLConnection);
; 226  : 			SQLFreeHandle(SQL_HANDLE_ENV, this->hSQLEnvironment);
; 227  : 			return false;

  00114	75 2e		 jne	 SHORT $LN13@Connect
$LN2@Connect:

; 228  : 		}
; 229  : 	}
; 230  : 
; 231  : 	// Connect
; 232  :     Result = SQLDriverConnectA(
; 233  :         this->hSQLConnection,         // Connection handle.
; 234  :         NULL,                         // Window handle.
; 235  :         (SQLCHAR *)sConnectionString, // Input connect string.
; 236  :         SQL_NTS,                      // Null-terminated string.
; 237  :         sConStrOut,                   // Address of output buffer.
; 238  :         sizeof(sConStrOut),           // Size of output buffer.
; 239  :         &iConStrOutSz,                // Address of output length.
; 240  :         SQL_DRIVER_NOPROMPT
; 241  :     );

  00116	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _sConnectionString$GSCopy$[ebp]
  0011c	6a 00		 push	 0
  0011e	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _iConStrOutSz$[ebp]
  00124	51		 push	 ecx
  00125	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00127	68 00 04 00 00	 push	 1024			; 00000400H
  0012c	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _sConStrOut$[ebp]
  00132	52		 push	 edx
  00133	6a fd		 push	 -3			; fffffffdH
  00135	50		 push	 eax
  00136	6a 00		 push	 0
  00138	51		 push	 ecx
  00139	e8 00 00 00 00	 call	 _SQLDriverConnectA@32

; 242  : 
; 243  :     if(!SQL_SUCCEEDED(Result))

  0013e	66 a9 fe ff	 test	 ax, -2			; fffffffeH
  00142	74 32		 je	 SHORT $LN1@Connect
$LN13@Connect:

; 244  :     {
; 245  :         ThrowErrorIfSet(NULL);

  00144	6a 00		 push	 0
  00146	8b ce		 mov	 ecx, esi
  00148	e8 00 00 00 00	 call	 ?ThrowErrorIfSet@CSQL@@QAE_NPAX@Z ; CSQL::ThrowErrorIfSet

; 246  :         SQLFreeHandle(SQL_HANDLE_DBC, this->hSQLConnection);

  0014d	8b 17		 mov	 edx, DWORD PTR [edi]
  0014f	52		 push	 edx
  00150	6a 02		 push	 2
  00152	e8 00 00 00 00	 call	 _SQLFreeHandle@8

; 247  :         SQLFreeHandle(SQL_HANDLE_ENV, this->hSQLEnvironment);

  00157	8b 03		 mov	 eax, DWORD PTR [ebx]
  00159	50		 push	 eax
  0015a	6a 01		 push	 1
  0015c	e8 00 00 00 00	 call	 _SQLFreeHandle@8
  00161	5f		 pop	 edi
  00162	5e		 pop	 esi

; 248  :         return false;

  00163	32 c0		 xor	 al, al
  00165	5b		 pop	 ebx

; 249  :     }
; 250  : 
; 251  :     this->bConnected = true;
; 252  : 
; 253  :     return true;
; 254  : }

  00166	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00169	33 cd		 xor	 ecx, ebp
  0016b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00170	8b e5		 mov	 esp, ebp
  00172	5d		 pop	 ebp
  00173	c2 08 00	 ret	 8
$LN1@Connect:
  00176	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00179	5f		 pop	 edi
  0017a	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1
  0017e	5e		 pop	 esi
  0017f	33 cd		 xor	 ecx, ebp
  00181	b0 01		 mov	 al, 1
  00183	5b		 pop	 ebx
  00184	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c2 08 00	 ret	 8
?Connect@CSQL@@QAE_NPBDP6AH00H@Z@Z ENDP			; CSQL::Connect
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?Execute@CSQL@@QAE_NPBD0@Z			; CSQL::Execute
EXTRN	__strcmpi:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Execute@CSQL@@QAE_NPBD0@Z
_TEXT	SEGMENT
_sOldDatabase$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_sDatabase$ = 8						; size = 4
_sSQL$ = 12						; size = 4
?Execute@CSQL@@QAE_NPBD0@Z PROC				; CSQL::Execute, COMDAT
; _this$ = ecx

; 376  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _sSQL$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _sDatabase$[ebp]

; 377  : 	char sOldDatabase[1024];
; 378  : 	this->GetFocus(sOldDatabase, sizeof(sOldDatabase));

  0001c	68 00 04 00 00	 push	 1024			; 00000400H
  00021	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _sOldDatabase$[ebp]
  00027	50		 push	 eax
  00028	8b f1		 mov	 esi, ecx
  0002a	e8 00 00 00 00	 call	 ?GetFocus@CSQL@@QAEHPADH@Z ; CSQL::GetFocus

; 379  : 
; 380  : 	if(_strcmpi(sOldDatabase, sDatabase) != 0)

  0002f	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _sOldDatabase$[ebp]
  00035	57		 push	 edi
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 __strcmpi
  0003c	83 c4 08	 add	 esp, 8
  0003f	85 c0		 test	 eax, eax
  00041	74 08		 je	 SHORT $LN2@Execute@4

; 381  : 	{
; 382  : 		this->Focus(sDatabase);

  00043	57		 push	 edi
  00044	8b ce		 mov	 ecx, esi
  00046	e8 00 00 00 00	 call	 ?Focus@CSQL@@QAE_NPBD@Z	; CSQL::Focus
$LN2@Execute@4:

; 383  : 	}
; 384  : 
; 385  : 	bool bResult = this->Execute(sSQL);

  0004b	53		 push	 ebx
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?Execute@CSQL@@QAE_NPBD@Z ; CSQL::Execute

; 386  : 
; 387  : 	if(_strcmpi(sOldDatabase, sDatabase) != 0)

  00053	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _sOldDatabase$[ebp]
  00059	57		 push	 edi
  0005a	52		 push	 edx
  0005b	8a d8		 mov	 bl, al
  0005d	e8 00 00 00 00	 call	 __strcmpi
  00062	83 c4 08	 add	 esp, 8
  00065	85 c0		 test	 eax, eax
  00067	74 0e		 je	 SHORT $LN5@Execute@4

; 388  : 	{
; 389  : 		this->Focus(sOldDatabase);

  00069	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _sOldDatabase$[ebp]
  0006f	50		 push	 eax
  00070	8b ce		 mov	 ecx, esi
  00072	e8 00 00 00 00	 call	 ?Focus@CSQL@@QAE_NPBD@Z	; CSQL::Focus
$LN5@Execute@4:

; 390  : 	}
; 391  : 
; 392  : 	return bResult;
; 393  : }

  00077	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	8a c3		 mov	 al, bl
  0007e	33 cd		 xor	 ecx, ebp
  00080	5b		 pop	 ebx
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
?Execute@CSQL@@QAE_NPBD0@Z ENDP				; CSQL::Execute
_TEXT	ENDS
PUBLIC	?Execute@CSQL@@QAE_NPBDPAVCBoundRecordSet@@@Z	; CSQL::Execute
; Function compile flags: /Ogtp
;	COMDAT ?Execute@CSQL@@QAE_NPBDPAVCBoundRecordSet@@@Z
_TEXT	SEGMENT
_sSQL$ = 8						; size = 4
_lpMyRS$ = 12						; size = 4
?Execute@CSQL@@QAE_NPBDPAVCBoundRecordSet@@@Z PROC	; CSQL::Execute, COMDAT
; _this$ = ecx

; 482  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 483  : 	return this->Execute(sSQL, lpMyRS, true);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _lpMyRS$[ebp]
  00006	8b 55 08	 mov	 edx, DWORD PTR _sSQL$[ebp]
  00009	6a 01		 push	 1
  0000b	50		 push	 eax
  0000c	52		 push	 edx
  0000d	e8 00 00 00 00	 call	 ?Execute@CSQL@@QAE_NPBDPAVCBoundRecordSet@@_N@Z ; CSQL::Execute

; 484  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?Execute@CSQL@@QAE_NPBDPAVCBoundRecordSet@@@Z ENDP	; CSQL::Execute
_TEXT	ENDS
PUBLIC	_lpMyRS$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?Execute@CSQL@@QAE_NPBD0PAVCBoundRecordSet@@_N@Z ; CSQL::Execute
; Function compile flags: /Ogtp
;	COMDAT ?Execute@CSQL@@QAE_NPBD0PAVCBoundRecordSet@@_N@Z
_TEXT	SEGMENT
_lpMyRS$GSCopy$ = -1032					; size = 4
_sOldDatabase$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_sDatabase$ = 8						; size = 4
_sSQL$ = 12						; size = 4
_lpMyRS$ = 16						; size = 4
_AutoBindAll$ = 20					; size = 1
?Execute@CSQL@@QAE_NPBD0PAVCBoundRecordSet@@_N@Z PROC	; CSQL::Execute, COMDAT
; _this$ = ecx

; 576  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 10	 mov	 eax, DWORD PTR _lpMyRS$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _sSQL$[ebp]
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _sDatabase$[ebp]
  0001f	8b f1		 mov	 esi, ecx

; 577  : 	char sOldDatabase[1024];
; 578  : 	this->GetFocus(sOldDatabase, sizeof(sOldDatabase));

  00021	68 00 04 00 00	 push	 1024			; 00000400H
  00026	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _sOldDatabase$[ebp]
  0002c	51		 push	 ecx
  0002d	8b ce		 mov	 ecx, esi

; 583  : 	}
; 584  : 
; 585  : 	bool bResult = Execute(sSQL, lpMyRS, AutoBindAll);

  0002f	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _lpMyRS$GSCopy$[ebp], eax
  00035	e8 00 00 00 00	 call	 ?GetFocus@CSQL@@QAEHPADH@Z ; CSQL::GetFocus
  0003a	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _sOldDatabase$[ebp]
  00040	57		 push	 edi
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 __strcmpi
  00047	83 c4 08	 add	 esp, 8
  0004a	85 c0		 test	 eax, eax
  0004c	74 08		 je	 SHORT $LN2@Execute@5

; 579  : 
; 580  : 	if(_strcmpi(sOldDatabase, sDatabase) != 0)
; 581  : 	{
; 582  : 		this->Focus(sDatabase);

  0004e	57		 push	 edi
  0004f	8b ce		 mov	 ecx, esi
  00051	e8 00 00 00 00	 call	 ?Focus@CSQL@@QAE_NPBD@Z	; CSQL::Focus
$LN2@Execute@5:

; 583  : 	}
; 584  : 
; 585  : 	bool bResult = Execute(sSQL, lpMyRS, AutoBindAll);

  00056	8b 45 14	 mov	 eax, DWORD PTR _AutoBindAll$[ebp]
  00059	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _lpMyRS$GSCopy$[ebp]
  0005f	50		 push	 eax
  00060	51		 push	 ecx
  00061	53		 push	 ebx
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?Execute@CSQL@@QAE_NPBDPAVCBoundRecordSet@@_N@Z ; CSQL::Execute

; 586  : 
; 587  : 	if(_strcmpi(sOldDatabase, sDatabase) != 0)

  00069	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _sOldDatabase$[ebp]
  0006f	57		 push	 edi
  00070	52		 push	 edx
  00071	8a d8		 mov	 bl, al
  00073	e8 00 00 00 00	 call	 __strcmpi
  00078	83 c4 08	 add	 esp, 8
  0007b	85 c0		 test	 eax, eax
  0007d	74 0e		 je	 SHORT $LN5@Execute@5

; 588  : 	{
; 589  : 		this->Focus(sOldDatabase);

  0007f	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _sOldDatabase$[ebp]
  00085	50		 push	 eax
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?Focus@CSQL@@QAE_NPBD@Z	; CSQL::Focus
$LN5@Execute@5:

; 590  : 	}
; 591  : 
; 592  : 	return bResult;
; 593  : }

  0008d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	8a c3		 mov	 al, bl
  00094	33 cd		 xor	 ecx, ebp
  00096	5b		 pop	 ebx
  00097	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 10 00	 ret	 16			; 00000010H
?Execute@CSQL@@QAE_NPBD0PAVCBoundRecordSet@@_N@Z ENDP	; CSQL::Execute
_TEXT	ENDS
PUBLIC	??0CSQL@@QAE@PBDP6AH00H@Z@Z			; CSQL::CSQL
; Function compile flags: /Ogtp
;	COMDAT ??0CSQL@@QAE@PBDP6AH00H@Z@Z
_TEXT	SEGMENT
_sConnectionString$ = 8					; size = 4
_pHandler$ = 12						; size = 4
??0CSQL@@QAE@PBDP6AH00H@Z@Z PROC			; CSQL::CSQL, COMDAT
; _this$ = ecx

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : 	this->Connect(sConnectionString, pHandler);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pHandler$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _sConnectionString$[ebp]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	8b ce		 mov	 ecx, esi
  00010	e8 00 00 00 00	 call	 ?Connect@CSQL@@QAE_NPBDP6AH00H@Z@Z ; CSQL::Connect

; 29   : }

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??0CSQL@@QAE@PBDP6AH00H@Z@Z ENDP			; CSQL::CSQL
_TEXT	ENDS
PUBLIC	?Connect@CSQL@@QAE_NPBD@Z			; CSQL::Connect
; Function compile flags: /Ogtp
;	COMDAT ?Connect@CSQL@@QAE_NPBD@Z
_TEXT	SEGMENT
_sConnectionString$ = 8					; size = 4
?Connect@CSQL@@QAE_NPBD@Z PROC				; CSQL::Connect, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 132  : 	return this->Connect(sConnectionString, &DefaultSQLErrorHandler);

  00003	8b 45 08	 mov	 eax, DWORD PTR _sConnectionString$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ?DefaultSQLErrorHandler@@YAHPBD0H@Z ; DefaultSQLErrorHandler
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?Connect@CSQL@@QAE_NPBDP6AH00H@Z@Z ; CSQL::Connect

; 133  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?Connect@CSQL@@QAE_NPBD@Z ENDP				; CSQL::Connect
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?Connect@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@P6AHPBD1H@Z@Z ; CSQL::Connect
; Function compile flags: /Ogtp
;	COMDAT ?Connect@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@P6AHPBD1H@Z@Z
_TEXT	SEGMENT
_sConnectionString$ = -1028				; size = 1024
__$ArrayPad$ = -4					; size = 4
_SQLCon$ = 8						; size = 4
_pHandler$ = 12						; size = 4
?Connect@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@P6AHPBD1H@Z@Z PROC ; CSQL::Connect, COMDAT
; _this$ = ecx

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _SQLCon$[ebp]
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx

; 139  :     char sConnectionString[1024];
; 140  : 
; 141  : 	if(!this->BuildConnectionString(SQLCon, sConnectionString, sizeof(sConnectionString)))

  00019	68 00 04 00 00	 push	 1024			; 00000400H
  0001e	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _sConnectionString$[ebp]
  00024	51		 push	 ecx
  00025	50		 push	 eax
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?BuildConnectionString@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@PADH@Z ; CSQL::BuildConnectionString
  0002d	84 c0		 test	 al, al
  0002f	75 11		 jne	 SHORT $LN1@Connect@2
  00031	5e		 pop	 esi

; 147  : }

  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	33 cd		 xor	 ecx, ebp
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN1@Connect@2:

; 142  : 	{
; 143  : 		return false;
; 144  : 	}
; 145  : 
; 146  : 	return this->Connect(sConnectionString, pHandler);

  00042	8b 55 0c	 mov	 edx, DWORD PTR _pHandler$[ebp]
  00045	52		 push	 edx
  00046	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _sConnectionString$[ebp]
  0004c	50		 push	 eax
  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 ?Connect@CSQL@@QAE_NPBDP6AH00H@Z@Z ; CSQL::Connect

; 147  : }

  00054	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00057	33 cd		 xor	 ecx, ebp
  00059	5e		 pop	 esi
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
?Connect@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@P6AHPBD1H@Z@Z ENDP ; CSQL::Connect
_TEXT	ENDS
PUBLIC	?Connect@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@@Z	; CSQL::Connect
; Function compile flags: /Ogtp
;	COMDAT ?Connect@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@@Z
_TEXT	SEGMENT
_SQLCon$ = 8						; size = 4
?Connect@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@@Z PROC	; CSQL::Connect, COMDAT
; _this$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 153  : 	return this->Connect(SQLCon, &DefaultSQLErrorHandler);

  00003	8b 45 08	 mov	 eax, DWORD PTR _SQLCon$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ?DefaultSQLErrorHandler@@YAHPBD0H@Z ; DefaultSQLErrorHandler
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?Connect@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@P6AHPBD1H@Z@Z ; CSQL::Connect

; 154  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?Connect@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@@Z ENDP	; CSQL::Connect
_TEXT	ENDS
PUBLIC	?Execute@CSQL@@QAE_NPBD0PAVCBoundRecordSet@@@Z	; CSQL::Execute
; Function compile flags: /Ogtp
;	COMDAT ?Execute@CSQL@@QAE_NPBD0PAVCBoundRecordSet@@@Z
_TEXT	SEGMENT
_sDatabase$ = 8						; size = 4
_sSQL$ = 12						; size = 4
_lpMyRS$ = 16						; size = 4
?Execute@CSQL@@QAE_NPBD0PAVCBoundRecordSet@@@Z PROC	; CSQL::Execute, COMDAT
; _this$ = ecx

; 569  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 570  : 	return this->Execute(sDatabase, sSQL, lpMyRS, true);

  00003	8b 45 10	 mov	 eax, DWORD PTR _lpMyRS$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _sSQL$[ebp]
  00009	6a 01		 push	 1
  0000b	50		 push	 eax
  0000c	8b 45 08	 mov	 eax, DWORD PTR _sDatabase$[ebp]
  0000f	52		 push	 edx
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?Execute@CSQL@@QAE_NPBD0PAVCBoundRecordSet@@_N@Z ; CSQL::Execute

; 571  : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
?Execute@CSQL@@QAE_NPBD0PAVCBoundRecordSet@@@Z ENDP	; CSQL::Execute
_TEXT	ENDS
PUBLIC	??0CSQL@@QAE@PAU_TAG_SQLCONNECTION@@@Z		; CSQL::CSQL
; Function compile flags: /Ogtp
;	COMDAT ??0CSQL@@QAE@PAU_TAG_SQLCONNECTION@@@Z
_TEXT	SEGMENT
_SQLCon$ = 8						; size = 4
??0CSQL@@QAE@PAU_TAG_SQLCONNECTION@@@Z PROC		; CSQL::CSQL, COMDAT
; _this$ = ecx

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 35   : 	this->Connect(SQLCon);

  00003	8b 45 08	 mov	 eax, DWORD PTR _SQLCon$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?Connect@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@@Z ; CSQL::Connect

; 36   : }

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??0CSQL@@QAE@PAU_TAG_SQLCONNECTION@@@Z ENDP		; CSQL::CSQL
_TEXT	ENDS
PUBLIC	??0CSQL@@QAE@PAU_TAG_SQLCONNECTION@@P6AHPBD1H@Z@Z ; CSQL::CSQL
; Function compile flags: /Ogtp
;	COMDAT ??0CSQL@@QAE@PAU_TAG_SQLCONNECTION@@P6AHPBD1H@Z@Z
_TEXT	SEGMENT
_SQLCon$ = 8						; size = 4
_pHandler$ = 12						; size = 4
??0CSQL@@QAE@PAU_TAG_SQLCONNECTION@@P6AHPBD1H@Z@Z PROC	; CSQL::CSQL, COMDAT
; _this$ = ecx

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   : 	this->Connect(SQLCon, pHandler);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pHandler$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _SQLCon$[ebp]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	8b ce		 mov	 ecx, esi
  00010	e8 00 00 00 00	 call	 ?Connect@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@P6AHPBD1H@Z@Z ; CSQL::Connect

; 43   : }

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??0CSQL@@QAE@PAU_TAG_SQLCONNECTION@@P6AHPBD1H@Z@Z ENDP	; CSQL::CSQL
_TEXT	ENDS
PUBLIC	??0CSQL@@QAE@PBD@Z				; CSQL::CSQL
; Function compile flags: /Ogtp
;	COMDAT ??0CSQL@@QAE@PBD@Z
_TEXT	SEGMENT
_sConnectionString$ = 8					; size = 4
??0CSQL@@QAE@PBD@Z PROC					; CSQL::CSQL, COMDAT
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	this->Connect(sConnectionString);

  00003	8b 45 08	 mov	 eax, DWORD PTR _sConnectionString$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?Connect@CSQL@@QAE_NPBD@Z ; CSQL::Connect

; 50   : }

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??0CSQL@@QAE@PBD@Z ENDP					; CSQL::CSQL
_TEXT	ENDS
PUBLIC	??_C@_0N@KKFHAHLJ@?$HLSQL?5Server?$HN?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Connect@CSQL@@QAE_NPBD0@Z			; CSQL::Connect
EXTRN	_strcpy_s:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0N@KKFHAHLJ@?$HLSQL?5Server?$HN?$AA@
CONST	SEGMENT
??_C@_0N@KKFHAHLJ@?$HLSQL?5Server?$HN?$AA@ DB '{SQL Server}', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Connect@CSQL@@QAE_NPBD0@Z
_TEXT	SEGMENT
_CS$ = -1544						; size = 1540
__$ArrayPad$ = -4					; size = 4
_sServer$ = 8						; size = 4
_sDatabase$ = 12					; size = 4
?Connect@CSQL@@QAE_NPBD0@Z PROC				; CSQL::Connect, COMDAT
; _this$ = ecx

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 06 00
	00		 sub	 esp, 1544		; 00000608H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _sDatabase$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _sServer$[ebp]

; 99   : 	SQLCONNECTIONSTRING CS;
; 100  : 	memset(&CS, 0, sizeof(CS));

  0001c	68 04 06 00 00	 push	 1540			; 00000604H
  00021	8d 85 f8 f9 ff
	ff		 lea	 eax, DWORD PTR _CS$[ebp]
  00027	6a 00		 push	 0
  00029	50		 push	 eax
  0002a	8b f1		 mov	 esi, ecx
  0002c	e8 00 00 00 00	 call	 _memset

; 101  : 
; 102  : 	CS.bUseTrustedConnection = true;
; 103  : 	strcpy_s(CS.sDriver, sizeof(CS.sDriver), "{SQL Server}");

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KKFHAHLJ@?$HLSQL?5Server?$HN?$AA@
  00036	8d 8d f7 fa ff
	ff		 lea	 ecx, DWORD PTR _CS$[ebp+255]
  0003c	68 ff 00 00 00	 push	 255			; 000000ffH
  00041	51		 push	 ecx
  00042	c6 45 f8 01	 mov	 BYTE PTR _CS$[ebp+1536], 1
  00046	e8 00 00 00 00	 call	 _strcpy_s

; 104  : 	strcpy_s(CS.sDatabase, sizeof(CS.sDatabase), sDatabase);

  0004b	53		 push	 ebx
  0004c	8d 95 f5 fc ff
	ff		 lea	 edx, DWORD PTR _CS$[ebp+765]
  00052	68 ff 00 00 00	 push	 255			; 000000ffH
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 _strcpy_s

; 105  : 	strcpy_s(CS.sServer, sizeof(CS.sServer), sServer);

  0005d	57		 push	 edi
  0005e	8d 85 f6 fb ff
	ff		 lea	 eax, DWORD PTR _CS$[ebp+510]
  00064	68 ff 00 00 00	 push	 255			; 000000ffH
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _strcpy_s
  0006f	83 c4 30	 add	 esp, 48			; 00000030H

; 106  : 
; 107  : 	return this->Connect(&CS, &DefaultSQLErrorHandler);

  00072	68 00 00 00 00	 push	 OFFSET ?DefaultSQLErrorHandler@@YAHPBD0H@Z ; DefaultSQLErrorHandler
  00077	8d 8d f8 f9 ff
	ff		 lea	 ecx, DWORD PTR _CS$[ebp]
  0007d	51		 push	 ecx
  0007e	8b ce		 mov	 ecx, esi
  00080	e8 00 00 00 00	 call	 ?Connect@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@P6AHPBD1H@Z@Z ; CSQL::Connect

; 108  : }

  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	33 cd		 xor	 ecx, ebp
  0008c	5b		 pop	 ebx
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
?Connect@CSQL@@QAE_NPBD0@Z ENDP				; CSQL::Connect
_TEXT	ENDS
PUBLIC	??_C@_0BE@IJGCIDDE@?$HLSQL?5Native?5Client?$HN?$AA@ ; `string'
PUBLIC	_sPassword$GSCopy$
PUBLIC	_sUser$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?Connect@CSQL@@QAE_NPBD000@Z			; CSQL::Connect
;	COMDAT ??_C@_0BE@IJGCIDDE@?$HLSQL?5Native?5Client?$HN?$AA@
CONST	SEGMENT
??_C@_0BE@IJGCIDDE@?$HLSQL?5Native?5Client?$HN?$AA@ DB '{SQL Native Clien'
	DB	't}', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Connect@CSQL@@QAE_NPBD000@Z
_TEXT	SEGMENT
_sUser$GSCopy$ = -1552					; size = 4
_sPassword$GSCopy$ = -1548				; size = 4
_CS$ = -1544						; size = 1540
__$ArrayPad$ = -4					; size = 4
_sServer$ = 8						; size = 4
_sDatabase$ = 12					; size = 4
_sUser$ = 16						; size = 4
_sPassword$ = 20					; size = 4
?Connect@CSQL@@QAE_NPBD000@Z PROC			; CSQL::Connect, COMDAT
; _this$ = ecx

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 06 00
	00		 sub	 esp, 1552		; 00000610H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 10	 mov	 eax, DWORD PTR _sUser$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _sDatabase$[ebp]
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _sServer$[ebp]

; 114  : 	SQLCONNECTIONSTRING CS;
; 115  : 	memset(&CS, 0, sizeof(CS));

  0001f	68 04 06 00 00	 push	 1540			; 00000604H
  00024	8b f1		 mov	 esi, ecx
  00026	8b 4d 14	 mov	 ecx, DWORD PTR _sPassword$[ebp]
  00029	8d 95 f8 f9 ff
	ff		 lea	 edx, DWORD PTR _CS$[ebp]
  0002f	6a 00		 push	 0
  00031	52		 push	 edx
  00032	89 85 f0 f9 ff
	ff		 mov	 DWORD PTR _sUser$GSCopy$[ebp], eax
  00038	89 8d f4 f9 ff
	ff		 mov	 DWORD PTR _sPassword$GSCopy$[ebp], ecx
  0003e	e8 00 00 00 00	 call	 _memset

; 116  : 
; 117  : 	CS.bUseTrustedConnection = false;
; 118  : 	//strcpy_s(CS.sDriver, sizeof(CS.sDriver), "{SQL Server}");
; 119  : 	strcpy_s(CS.sDriver, sizeof(CS.sDriver), "{SQL Native Client}");

  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@IJGCIDDE@?$HLSQL?5Native?5Client?$HN?$AA@
  00048	8d 85 f7 fa ff
	ff		 lea	 eax, DWORD PTR _CS$[ebp+255]
  0004e	68 ff 00 00 00	 push	 255			; 000000ffH
  00053	50		 push	 eax
  00054	c6 45 f8 00	 mov	 BYTE PTR _CS$[ebp+1536], 0
  00058	e8 00 00 00 00	 call	 _strcpy_s

; 120  : 	strcpy_s(CS.sDatabase, sizeof(CS.sDatabase), sDatabase);

  0005d	53		 push	 ebx
  0005e	8d 8d f5 fc ff
	ff		 lea	 ecx, DWORD PTR _CS$[ebp+765]
  00064	68 ff 00 00 00	 push	 255			; 000000ffH
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 _strcpy_s

; 121  : 	strcpy_s(CS.sServer, sizeof(CS.sServer), sServer);

  0006f	57		 push	 edi
  00070	8d 95 f6 fb ff
	ff		 lea	 edx, DWORD PTR _CS$[ebp+510]
  00076	68 ff 00 00 00	 push	 255			; 000000ffH
  0007b	52		 push	 edx
  0007c	e8 00 00 00 00	 call	 _strcpy_s

; 122  : 	strcpy_s(CS.sUID, sizeof(CS.sUID), sUser);

  00081	8b 85 f0 f9 ff
	ff		 mov	 eax, DWORD PTR _sUser$GSCopy$[ebp]
  00087	50		 push	 eax
  00088	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _CS$[ebp+1020]
  0008e	68 ff 00 00 00	 push	 255			; 000000ffH
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _strcpy_s

; 123  : 	strcpy_s(CS.sPwd, sizeof(CS.sPwd), sPassword);

  00099	8b 95 f4 f9 ff
	ff		 mov	 edx, DWORD PTR _sPassword$GSCopy$[ebp]
  0009f	52		 push	 edx
  000a0	8d 85 f3 fe ff
	ff		 lea	 eax, DWORD PTR _CS$[ebp+1275]
  000a6	68 ff 00 00 00	 push	 255			; 000000ffH
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _strcpy_s
  000b1	83 c4 48	 add	 esp, 72			; 00000048H

; 124  : 
; 125  : 	return this->Connect(&CS, &DefaultSQLErrorHandler);

  000b4	68 00 00 00 00	 push	 OFFSET ?DefaultSQLErrorHandler@@YAHPBD0H@Z ; DefaultSQLErrorHandler
  000b9	8d 8d f8 f9 ff
	ff		 lea	 ecx, DWORD PTR _CS$[ebp]
  000bf	51		 push	 ecx
  000c0	8b ce		 mov	 ecx, esi
  000c2	e8 00 00 00 00	 call	 ?Connect@CSQL@@QAE_NPAU_TAG_SQLCONNECTION@@P6AHPBD1H@Z@Z ; CSQL::Connect

; 126  : }

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	33 cd		 xor	 ecx, ebp
  000ce	5b		 pop	 ebx
  000cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 10 00	 ret	 16			; 00000010H
?Connect@CSQL@@QAE_NPBD000@Z ENDP			; CSQL::Connect
_TEXT	ENDS
PUBLIC	??0CSQL@@QAE@PBD0@Z				; CSQL::CSQL
; Function compile flags: /Ogtp
;	COMDAT ??0CSQL@@QAE@PBD0@Z
_TEXT	SEGMENT
_sServer$ = 8						; size = 4
_sDatabase$ = 12					; size = 4
??0CSQL@@QAE@PBD0@Z PROC				; CSQL::CSQL, COMDAT
; _this$ = ecx

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   : 	this->Connect(sServer, sDatabase);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _sDatabase$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _sServer$[ebp]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	8b ce		 mov	 ecx, esi
  00010	e8 00 00 00 00	 call	 ?Connect@CSQL@@QAE_NPBD0@Z ; CSQL::Connect

; 57   : }

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??0CSQL@@QAE@PBD0@Z ENDP				; CSQL::CSQL
_TEXT	ENDS
PUBLIC	??0CSQL@@QAE@PBD000@Z				; CSQL::CSQL
; Function compile flags: /Ogtp
;	COMDAT ??0CSQL@@QAE@PBD000@Z
_TEXT	SEGMENT
_sServer$ = 8						; size = 4
_sDatabase$ = 12					; size = 4
_sUser$ = 16						; size = 4
_sPassword$ = 20					; size = 4
??0CSQL@@QAE@PBD000@Z PROC				; CSQL::CSQL, COMDAT
; _this$ = ecx

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	this->Connect(sServer, sDatabase, sUser, sPassword);

  00003	8b 45 14	 mov	 eax, DWORD PTR _sPassword$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _sDatabase$[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	8b 45 08	 mov	 eax, DWORD PTR _sServer$[ebp]
  0000e	8b f1		 mov	 esi, ecx
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _sUser$[ebp]
  00013	51		 push	 ecx
  00014	52		 push	 edx
  00015	50		 push	 eax
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?Connect@CSQL@@QAE_NPBD000@Z ; CSQL::Connect

; 64   : }

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 10 00	 ret	 16			; 00000010H
??0CSQL@@QAE@PBD000@Z ENDP				; CSQL::CSQL
_TEXT	ENDS
END
