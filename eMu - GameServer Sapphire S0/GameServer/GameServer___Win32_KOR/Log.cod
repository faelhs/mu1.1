; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\Log.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_7CLog@@6B@					; CLog::`vftable'
PUBLIC	??0CLog@@QAE@XZ					; CLog::CLog
PUBLIC	??_R4CLog@@6B@					; CLog::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCLog@@@8				; CLog `RTTI Type Descriptor'
PUBLIC	??_R3CLog@@8					; CLog::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CLog@@8					; CLog::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CLog@@8				; CLog::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECLog@@UAEPAXI@Z:PROC			; CLog::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CLog@@8
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\log.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CLog@@8 DD FLAT:??_R0?AVCLog@@@8		; CLog::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CLog@@8
rdata$r	ENDS
;	COMDAT ??_R2CLog@@8
rdata$r	SEGMENT
??_R2CLog@@8 DD	FLAT:??_R1A@?0A@EA@CLog@@8		; CLog::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CLog@@8
rdata$r	SEGMENT
??_R3CLog@@8 DD	00H					; CLog::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CLog@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCLog@@@8
_DATA	SEGMENT
??_R0?AVCLog@@@8 DD FLAT:??_7type_info@@6B@		; CLog `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCLog@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CLog@@6B@
rdata$r	SEGMENT
??_R4CLog@@6B@ DD 00H					; CLog::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCLog@@@8
	DD	FLAT:??_R3CLog@@8
rdata$r	ENDS
;	COMDAT ??_7CLog@@6B@
CONST	SEGMENT
??_7CLog@@6B@ DD FLAT:??_R4CLog@@6B@			; CLog::`vftable'
	DD	FLAT:??_ECLog@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0CLog@@QAE@XZ
_TEXT	SEGMENT
??0CLog@@QAE@XZ PROC					; CLog::CLog, COMDAT
; _this$ = ecx

; 8    : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CLog@@6B@

; 9    : 	this->m_count = 0;

  00008	c7 80 a4 10 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+4260], 0

; 10   : }

  00012	c3		 ret	 0
??0CLog@@QAE@XZ ENDP					; CLog::CLog
_TEXT	ENDS
PUBLIC	??1CLog@@UAE@XZ					; CLog::~CLog
EXTRN	__imp__CloseHandle@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ??1CLog@@UAE@XZ
_TEXT	SEGMENT
??1CLog@@UAE@XZ PROC					; CLog::~CLog, COMDAT
; _this$ = ecx

; 13   : {

  00000	53		 push	 ebx
  00001	57		 push	 edi
  00002	8b d9		 mov	 ebx, ecx

; 14   : 	for(int n = 0; n < this->m_count; n++)

  00004	33 ff		 xor	 edi, edi
  00006	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7CLog@@6B@
  0000c	39 bb a4 10 00
	00		 cmp	 DWORD PTR [ebx+4260], edi
  00012	7e 2e		 jle	 SHORT $LN2@CLog

; 13   : {

  00014	56		 push	 esi
  00015	8d b3 14 02 00
	00		 lea	 esi, DWORD PTR [ebx+532]
  0001b	eb 03 8d 49 00	 npad	 5
$LL9@CLog:

; 15   : 	{
; 16   : 		if(this->m_LogInfo[n].Active != 0)

  00020	83 be f0 fd ff
	ff 00		 cmp	 DWORD PTR [esi-528], 0
  00027	74 09		 je	 SHORT $LN3@CLog

; 17   : 		{
; 18   : 			CloseHandle(this->m_LogInfo[n].File);

  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN3@CLog:

; 14   : 	for(int n = 0; n < this->m_count; n++)

  00032	47		 inc	 edi
  00033	81 c6 14 02 00
	00		 add	 esi, 532		; 00000214H
  00039	3b bb a4 10 00
	00		 cmp	 edi, DWORD PTR [ebx+4260]
  0003f	7c df		 jl	 SHORT $LL9@CLog
  00041	5e		 pop	 esi
$LN2@CLog:
  00042	5f		 pop	 edi
  00043	5b		 pop	 ebx

; 19   : 		}
; 20   : 	}
; 21   : }

  00044	c3		 ret	 0
??1CLog@@UAE@XZ ENDP					; CLog::~CLog
_TEXT	ENDS
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?MsgBox@@YAXPADZZ				; MsgBox
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_vsprintf:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?MsgBox@@YAXPADZZ
_TEXT	SEGMENT
_szBuffer$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_szLog$ = 8						; size = 4
?MsgBox@@YAXPADZZ PROC					; MsgBox, COMDAT

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 02 00
	00		 sub	 esp, 516		; 00000204H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 174  : 	char szBuffer[512] = "";

  00013	68 ff 01 00 00	 push	 511			; 000001ffH
  00018	8d 85 fd fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp+1]
  0001e	6a 00		 push	 0
  00020	50		 push	 eax
  00021	c6 85 fc fd ff
	ff 00		 mov	 BYTE PTR _szBuffer$[ebp], 0
  00028	e8 00 00 00 00	 call	 _memset

; 175  : 	// ---
; 176  : 	va_list pArguments;
; 177  : 	// ---
; 178  : 	va_start(pArguments, szLog);
; 179  : 	// ---
; 180  : 	vsprintf(szBuffer, szLog, pArguments);

  0002d	8b 55 08	 mov	 edx, DWORD PTR _szLog$[ebp]
  00030	8d 4d 0c	 lea	 ecx, DWORD PTR _szLog$[ebp+4]
  00033	51		 push	 ecx
  00034	52		 push	 edx
  00035	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _vsprintf
  00041	83 c4 18	 add	 esp, 24			; 00000018H

; 181  : 	// ---
; 182  : 	va_end(pArguments);
; 183  : 	// ---
; 184  : 	MessageBox(NULL, szBuffer, "error", MB_OK|MB_APPLMODAL);

  00044	6a 00		 push	 0
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_05KKCIMGE@error?$AA@
  0004b	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _szBuffer$[ebp]
  00051	51		 push	 ecx
  00052	6a 00		 push	 0
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 185  : }

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005d	33 cd		 xor	 ecx, ebp
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?MsgBox@@YAXPADZZ ENDP					; MsgBox
_TEXT	ENDS
PUBLIC	??$strcpy_s@$0BAA@@@YAHAAY0BAA@DPBD@Z		; strcpy_s<256>
EXTRN	_strcpy_s:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\string.h
;	COMDAT ??$strcpy_s@$0BAA@@@YAHAAY0BAA@DPBD@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Source$ = 12						; size = 4
??$strcpy_s@$0BAA@@@YAHAAY0BAA@DPBD@Z PROC		; strcpy_s<256>, COMDAT

; 104  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Deref_post_z_ char, _Dest, _In_z_ const char *, _Source)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Source$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00009	50		 push	 eax
  0000a	68 00 01 00 00	 push	 256			; 00000100H
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _strcpy_s
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$strcpy_s@$0BAA@@@YAHAAY0BAA@DPBD@Z ENDP		; strcpy_s<256>
_TEXT	ENDS
PUBLIC	??$vsprintf_s@$0EAA@@@YAHAAY0EAA@DPBDPAD@Z	; vsprintf_s<1024>
EXTRN	_vsprintf_s:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdio.h
;	COMDAT ??$vsprintf_s@$0EAA@@@YAHAAY0EAA@DPBDPAD@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
__Args$ = 16						; size = 4
??$vsprintf_s@$0EAA@@@YAHAAY0EAA@DPBDPAD@Z PROC		; vsprintf_s<1024>, COMDAT

; 367  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(int, vsprintf_s, _Deref_post_z_ char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format, va_list, _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 10	 mov	 eax, DWORD PTR __Args$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00009	8b 55 08	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	68 00 04 00 00	 push	 1024			; 00000400H
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _vsprintf_s
  00019	83 c4 10	 add	 esp, 16			; 00000010H
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$vsprintf_s@$0EAA@@@YAHAAY0EAA@DPBDPAD@Z ENDP		; vsprintf_s<1024>
_TEXT	ENDS
EXTRN	__localtime64_s:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _localtime_s
_TEXT	SEGMENT
_localtime_s PROC					; COMDAT
; __Tm$ = ecx
; __Time$ = eax

; 121  :     return _localtime64_s(_Tm, _Time);

  00000	50		 push	 eax
  00001	51		 push	 ecx
  00002	e8 00 00 00 00	 call	 __localtime64_s
  00007	83 c4 08	 add	 esp, 8

; 122  : }

  0000a	c3		 ret	 0
_localtime_s ENDP
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCLog@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCLog@@UAEPAXI@Z PROC				; CLog::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CLog@@UAE@XZ		; CLog::~CLog
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCLog@@UAEPAXI@Z ENDP				; CLog::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0CA@LIGNENEN@?4?2?$CFs?2LOG_?$CF02d?4?$CF02d?4?$CF04d?$FL?$CFs?$FN?4txt?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?AddLog@CLog@@QAEXHPAD@Z			; CLog::AddLog
EXTRN	__imp__SetFilePointer@16:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	?szServerName@@3PADA:BYTE			; szServerName
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
;	COMDAT ??_C@_0CA@LIGNENEN@?4?2?$CFs?2LOG_?$CF02d?4?$CF02d?4?$CF04d?$FL?$CFs?$FN?4txt?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\string.h
CONST	SEGMENT
??_C@_0CA@LIGNENEN@?4?2?$CFs?2LOG_?$CF02d?4?$CF02d?4?$CF04d?$FL?$CFs?$FN?4txt?$AA@ DB '.'
	DB	'\%s\LOG_%02d.%02d.%04d[%s].txt', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\log.cpp
CONST	ENDS
;	COMDAT ?AddLog@CLog@@QAEXHPAD@Z
_TEXT	SEGMENT
_time$153452 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_active$ = 8						; size = 4
_directory$ = 12					; size = 4
?AddLog@CLog@@QAEXHPAD@Z PROC				; CLog::AddLog, COMDAT
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	if(this->m_count < 0 || this->m_count >= MAX_LOG)

  00010	8b 81 a4 10 00
	00		 mov	 eax, DWORD PTR [ecx+4260]
  00016	8b 55 0c	 mov	 edx, DWORD PTR _directory$[ebp]
  00019	85 c0		 test	 eax, eax
  0001b	0f 88 f2 00 00
	00		 js	 $LN4@AddLog
  00021	83 f8 08	 cmp	 eax, 8
  00024	0f 8d e9 00 00
	00		 jge	 $LN4@AddLog

; 26   : 	{
; 27   : 		return;
; 28   : 	}
; 29   : 	// ---
; 30   : 	LOG_INFO * lpInfo = &this->m_LogInfo[this->m_count++];

  0002a	56		 push	 esi
  0002b	8b f0		 mov	 esi, eax
  0002d	69 f6 14 02 00
	00		 imul	 esi, 532		; 00000214H
  00033	57		 push	 edi
  00034	8d 74 0e 04	 lea	 esi, DWORD PTR [esi+ecx+4]
  00038	40		 inc	 eax

; 31   : 	// ---
; 32   : 	lpInfo->Active = active;
; 33   : 	// ---
; 34   : 	strcpy_s(lpInfo->Directory, directory);

  00039	52		 push	 edx
  0003a	89 81 a4 10 00
	00		 mov	 DWORD PTR [ecx+4260], eax
  00040	8b 45 08	 mov	 eax, DWORD PTR _active$[ebp]
  00043	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00046	68 00 01 00 00	 push	 256			; 00000100H
  0004b	57		 push	 edi
  0004c	89 06		 mov	 DWORD PTR [esi], eax
  0004e	e8 00 00 00 00	 call	 _strcpy_s
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 35   : 	// ---
; 36   : 	if(lpInfo->Active != 0)

  00056	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00059	0f 84 b2 00 00
	00		 je	 $LN10@AddLog

; 37   : 	{
; 38   : 		CreateDirectory(lpInfo->Directory, NULL);

  0005f	53		 push	 ebx
  00060	6a 00		 push	 0
  00062	57		 push	 edi
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8

; 39   : 		// ---
; 40   : 		SYSTEMTIME time;
; 41   : 		// ---
; 42   : 		GetLocalTime(&time);

  00069	8d 4d ec	 lea	 ecx, DWORD PTR _time$153452[ebp]
  0006c	51		 push	 ecx
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 43   : 		// ---
; 44   : 		lpInfo->Day = time.wDay;
; 45   : 		// ---
; 46   : 		lpInfo->Month = time.wMonth;
; 47   : 		// ---
; 48   : 		lpInfo->Year = time.wYear;

  00073	0f b7 55 ec	 movzx	 edx, WORD PTR _time$153452[ebp]
  00077	0f b7 4d ee	 movzx	 ecx, WORD PTR _time$153452[ebp+2]
  0007b	0f b7 45 f2	 movzx	 eax, WORD PTR _time$153452[ebp+6]

; 49   : 		// ---
; 50   : 		wsprintf(lpInfo->Filename,".\\%s\\LOG_%02d.%02d.%04d[%s].txt",lpInfo->Directory, lpInfo->Day, lpInfo->Month, lpInfo->Year, szServerName);

  0007f	68 00 00 00 00	 push	 OFFSET ?szServerName@@3PADA ; szServerName
  00084	52		 push	 edx
  00085	51		 push	 ecx
  00086	50		 push	 eax
  00087	57		 push	 edi
  00088	8d 9e 10 01 00
	00		 lea	 ebx, DWORD PTR [esi+272]
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@LIGNENEN@?4?2?$CFs?2LOG_?$CF02d?4?$CF02d?4?$CF04d?$FL?$CFs?$FN?4txt?$AA@
  00093	53		 push	 ebx
  00094	89 86 04 01 00
	00		 mov	 DWORD PTR [esi+260], eax
  0009a	89 8e 08 01 00
	00		 mov	 DWORD PTR [esi+264], ecx
  000a0	89 96 0c 01 00
	00		 mov	 DWORD PTR [esi+268], edx
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000ac	83 c4 1c	 add	 esp, 28			; 0000001cH

; 51   : 		// ---
; 52   : 		lpInfo->File = CreateFile(lpInfo->Filename, GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);

  000af	6a 00		 push	 0
  000b1	68 80 00 00 00	 push	 128			; 00000080H
  000b6	6a 04		 push	 4
  000b8	6a 00		 push	 0
  000ba	6a 01		 push	 1
  000bc	68 00 00 00 40	 push	 1073741824		; 40000000H
  000c1	53		 push	 ebx
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  000c8	89 86 10 02 00
	00		 mov	 DWORD PTR [esi+528], eax
  000ce	5b		 pop	 ebx

; 53   : 		// ---
; 54   : 		if(lpInfo->File == INVALID_HANDLE_VALUE)

  000cf	83 f8 ff	 cmp	 eax, -1
  000d2	75 18		 jne	 SHORT $LN2@AddLog

; 55   : 		{
; 56   : 			lpInfo->Active = 0;

  000d4	5f		 pop	 edi
  000d5	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  000db	5e		 pop	 esi

; 65   : 			// ---
; 66   : 			return;
; 67   : 		}
; 68   : 	}
; 69   : }

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000df	33 cd		 xor	 ecx, ebp
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 08 00	 ret	 8
$LN2@AddLog:

; 57   : 			return;
; 58   : 		}
; 59   : 		// ---
; 60   : 		if(SetFilePointer(lpInfo->File, 0, 0, FILE_END) == INVALID_SET_FILE_POINTER)

  000ec	6a 02		 push	 2
  000ee	6a 00		 push	 0
  000f0	6a 00		 push	 0
  000f2	50		 push	 eax
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16
  000f9	83 f8 ff	 cmp	 eax, -1
  000fc	75 13		 jne	 SHORT $LN10@AddLog

; 61   : 		{
; 62   : 			lpInfo->Active = 0;
; 63   : 			// ---
; 64   : 			CloseHandle(lpInfo->File);

  000fe	8b 96 10 02 00
	00		 mov	 edx, DWORD PTR [esi+528]
  00104	52		 push	 edx
  00105	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN10@AddLog:
  00111	5f		 pop	 edi
  00112	5e		 pop	 esi
$LN4@AddLog:

; 65   : 			// ---
; 66   : 			return;
; 67   : 		}
; 68   : 	}
; 69   : }

  00113	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00116	33 cd		 xor	 ecx, ebp
  00118	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c2 08 00	 ret	 8
?AddLog@CLog@@QAEXHPAD@Z ENDP				; CLog::AddLog
_TEXT	ENDS
PUBLIC	??_C@_0BG@HIBPHJNN@?$FL?5?$CF02d?3?$CF02d?3?$CF02d?5?$CFs?$AN?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Output@CLog@@QAAXW4eLogType@@PADZZ		; CLog::Output
EXTRN	__imp__WriteFile@20:PROC
;	COMDAT ??_C@_0BG@HIBPHJNN@?$FL?5?$CF02d?3?$CF02d?3?$CF02d?5?$CFs?$AN?6?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdio.h
CONST	SEGMENT
??_C@_0BG@HIBPHJNN@?$FL?5?$CF02d?3?$CF02d?3?$CF02d?5?$CFs?$AN?6?$AA@ DB '['
	DB	' %02d:%02d:%02d %s', 0dH, 0aH, 00H		; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\log.cpp
CONST	ENDS
;	COMDAT ?Output@CLog@@QAAXW4eLogType@@PADZZ
_TEXT	SEGMENT
_OutSize$ = -2072					; size = 4
_time$ = -2068						; size = 16
_temp$ = -2052						; size = 1024
_buff$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_type$ = 12						; size = 4
_text$ = 16						; size = 4
?Output@CLog@@QAAXW4eLogType@@PADZZ PROC		; CLog::Output, COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 08 00
	00		 sub	 esp, 2072		; 00000818H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]

; 73   : 	if(type < 0 || type >= this->m_count)

  00019	85 c0		 test	 eax, eax
  0001b	0f 88 d8 01 00
	00		 js	 $LN6@Output
  00021	3b 81 a4 10 00
	00		 cmp	 eax, DWORD PTR [ecx+4260]
  00027	0f 8d cc 01 00
	00		 jge	 $LN6@Output

; 74   : 	{
; 75   : 		return;
; 76   : 	}
; 77   : 	// ---
; 78   : 	LOG_INFO * lpInfo = &this->m_LogInfo[type];

  0002d	69 c0 14 02 00
	00		 imul	 eax, 532		; 00000214H

; 79   : 	// ---
; 80   : 	if(lpInfo->Active == 0)

  00033	83 7c 08 04 00	 cmp	 DWORD PTR [eax+ecx+4], 0
  00038	56		 push	 esi
  00039	8d 74 08 04	 lea	 esi, DWORD PTR [eax+ecx+4]
  0003d	0f 84 b5 01 00
	00		 je	 $LN14@Output

; 81   : 	{
; 82   : 		return;
; 83   : 	}
; 84   : 	// ---
; 85   : 	SYSTEMTIME time;
; 86   : 	// ---
; 87   : 	GetLocalTime(&time);

  00043	53		 push	 ebx
  00044	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _time$[ebp]
  0004a	50		 push	 eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 88   : 	// ---
; 89   : 	if(time.wDay != lpInfo->Day || time.wMonth != lpInfo->Month || time.wYear != lpInfo->Year)

  00051	0f b7 8d f2 f7
	ff ff		 movzx	 ecx, WORD PTR _time$[ebp+6]
  00058	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__wsprintfA
  0005e	3b 8e 04 01 00
	00		 cmp	 ecx, DWORD PTR [esi+260]
  00064	75 22		 jne	 SHORT $LN3@Output
  00066	0f b7 95 ee f7
	ff ff		 movzx	 edx, WORD PTR _time$[ebp+2]
  0006d	3b 96 08 01 00
	00		 cmp	 edx, DWORD PTR [esi+264]
  00073	75 13		 jne	 SHORT $LN3@Output
  00075	0f b7 85 ec f7
	ff ff		 movzx	 eax, WORD PTR _time$[ebp]
  0007c	3b 86 0c 01 00
	00		 cmp	 eax, DWORD PTR [esi+268]
  00082	0f 84 c2 00 00
	00		 je	 $LN13@Output
$LN3@Output:

; 90   : 	{
; 91   : 		CloseHandle(lpInfo->File);

  00088	8b 8e 10 02 00
	00		 mov	 ecx, DWORD PTR [esi+528]
  0008e	57		 push	 edi
  0008f	51		 push	 ecx
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 92   : 		// ---
; 93   : 		lpInfo->Day = time.wDay;
; 94   : 		// ---
; 95   : 		lpInfo->Month = time.wMonth;
; 96   : 		// ---
; 97   : 		lpInfo->Year = time.wYear;

  00096	0f b7 95 ec f7
	ff ff		 movzx	 edx, WORD PTR _time$[ebp]
  0009d	0f b7 8d ee f7
	ff ff		 movzx	 ecx, WORD PTR _time$[ebp+2]
  000a4	0f b7 85 f2 f7
	ff ff		 movzx	 eax, WORD PTR _time$[ebp+6]

; 98   : 		// ---
; 99   : 		wsprintf(lpInfo->Filename,".\\%s\\LOG_%02d.%02d.%04d[%s].txt",lpInfo->Directory, lpInfo->Day, lpInfo->Month, lpInfo->Year, szServerName);

  000ab	68 00 00 00 00	 push	 OFFSET ?szServerName@@3PADA ; szServerName
  000b0	52		 push	 edx
  000b1	51		 push	 ecx
  000b2	50		 push	 eax
  000b3	89 96 0c 01 00
	00		 mov	 DWORD PTR [esi+268], edx
  000b9	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  000bc	52		 push	 edx
  000bd	8d be 10 01 00
	00		 lea	 edi, DWORD PTR [esi+272]
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@LIGNENEN@?4?2?$CFs?2LOG_?$CF02d?4?$CF02d?4?$CF04d?$FL?$CFs?$FN?4txt?$AA@
  000c8	57		 push	 edi
  000c9	89 86 04 01 00
	00		 mov	 DWORD PTR [esi+260], eax
  000cf	89 8e 08 01 00
	00		 mov	 DWORD PTR [esi+264], ecx
  000d5	ff d3		 call	 ebx
  000d7	83 c4 1c	 add	 esp, 28			; 0000001cH

; 100  : 		// ---
; 101  : 		lpInfo->File = CreateFile(lpInfo->Filename, GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);

  000da	6a 00		 push	 0
  000dc	68 80 00 00 00	 push	 128			; 00000080H
  000e1	6a 04		 push	 4
  000e3	6a 00		 push	 0
  000e5	6a 01		 push	 1
  000e7	68 00 00 00 40	 push	 1073741824		; 40000000H
  000ec	57		 push	 edi
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  000f3	89 86 10 02 00
	00		 mov	 DWORD PTR [esi+528], eax
  000f9	5f		 pop	 edi

; 102  : 		// ---
; 103  : 		if(lpInfo->File == INVALID_HANDLE_VALUE)

  000fa	83 f8 ff	 cmp	 eax, -1
  000fd	75 16		 jne	 SHORT $LN2@Output

; 104  : 		{
; 105  : 			lpInfo->Active = 0;

  000ff	5b		 pop	 ebx
  00100	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00106	5e		 pop	 esi

; 133  : }

  00107	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	33 cd		 xor	 ecx, ebp
  0010c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
$LN2@Output:

; 106  : 			return;
; 107  : 		}
; 108  : 		// ---
; 109  : 		if(SetFilePointer(lpInfo->File, 0, 0, FILE_END) == INVALID_SET_FILE_POINTER)

  00115	6a 02		 push	 2
  00117	6a 00		 push	 0
  00119	6a 00		 push	 0
  0011b	50		 push	 eax
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16
  00122	83 f8 ff	 cmp	 eax, -1
  00125	75 23		 jne	 SHORT $LN13@Output

; 110  : 		{
; 111  : 			lpInfo->Active = 0;
; 112  : 			// ---
; 113  : 			CloseHandle(lpInfo->File);

  00127	8b 86 10 02 00
	00		 mov	 eax, DWORD PTR [esi+528]
  0012d	50		 push	 eax
  0012e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0013a	5b		 pop	 ebx
  0013b	5e		 pop	 esi

; 133  : }

  0013c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013f	33 cd		 xor	 ecx, ebp
  00141	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c3		 ret	 0
$LN13@Output:

; 114  : 			// ---
; 115  : 			return;
; 116  : 		}
; 117  : 	}
; 118  : 	// ---
; 119  : 	char temp[1024] = {0};

  0014a	68 ff 03 00 00	 push	 1023			; 000003ffH
  0014f	8d 8d fd f7 ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp+1]
  00155	6a 00		 push	 0
  00157	51		 push	 ecx
  00158	c6 85 fc f7 ff
	ff 00		 mov	 BYTE PTR _temp$[ebp], 0
  0015f	e8 00 00 00 00	 call	 _memset

; 120  : 	// ---
; 121  : 	va_list arg;
; 122  : 	va_start(arg,text);
; 123  : 	vsprintf_s(temp,text,arg);

  00164	8b 45 10	 mov	 eax, DWORD PTR _text$[ebp]
  00167	8d 55 14	 lea	 edx, DWORD PTR _text$[ebp+4]
  0016a	52		 push	 edx
  0016b	50		 push	 eax
  0016c	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00172	68 00 04 00 00	 push	 1024			; 00000400H
  00177	51		 push	 ecx
  00178	e8 00 00 00 00	 call	 _vsprintf_s

; 124  : 	va_end(arg);
; 125  : 	// ---
; 126  : 	char buff[1024] = {0};

  0017d	68 ff 03 00 00	 push	 1023			; 000003ffH
  00182	8d 95 fd fb ff
	ff		 lea	 edx, DWORD PTR _buff$[ebp+1]
  00188	6a 00		 push	 0
  0018a	52		 push	 edx
  0018b	c6 85 fc fb ff
	ff 00		 mov	 BYTE PTR _buff$[ebp], 0
  00192	e8 00 00 00 00	 call	 _memset

; 127  : 	// ---
; 128  : 	wsprintf(buff,"[ %02d:%02d:%02d %s\r\n",time.wHour, time.wMinute, time.wSecond, temp);

  00197	0f b7 8d f8 f7
	ff ff		 movzx	 ecx, WORD PTR _time$[ebp+12]
  0019e	0f b7 95 f6 f7
	ff ff		 movzx	 edx, WORD PTR _time$[ebp+10]
  001a5	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  001ab	50		 push	 eax
  001ac	0f b7 85 f4 f7
	ff ff		 movzx	 eax, WORD PTR _time$[ebp+8]
  001b3	51		 push	 ecx
  001b4	52		 push	 edx
  001b5	50		 push	 eax
  001b6	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _buff$[ebp]
  001bc	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HIBPHJNN@?$FL?5?$CF02d?3?$CF02d?3?$CF02d?5?$CFs?$AN?6?$AA@
  001c1	51		 push	 ecx
  001c2	ff d3		 call	 ebx

; 129  : 	// ---
; 130  : 	DWORD OutSize;
; 131  : 	// ---
; 132  : 	WriteFile(lpInfo->File, buff, strlen(buff), &OutSize, 0);

  001c4	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _buff$[ebp]
  001ca	83 c4 40	 add	 esp, 64			; 00000040H
  001cd	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL12@Output:
  001d0	8a 08		 mov	 cl, BYTE PTR [eax]
  001d2	40		 inc	 eax
  001d3	84 c9		 test	 cl, cl
  001d5	75 f9		 jne	 SHORT $LL12@Output
  001d7	8b 8e 10 02 00
	00		 mov	 ecx, DWORD PTR [esi+528]
  001dd	2b c2		 sub	 eax, edx
  001df	6a 00		 push	 0
  001e1	8d 95 e8 f7 ff
	ff		 lea	 edx, DWORD PTR _OutSize$[ebp]
  001e7	52		 push	 edx
  001e8	50		 push	 eax
  001e9	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _buff$[ebp]
  001ef	50		 push	 eax
  001f0	51		 push	 ecx
  001f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  001f7	5b		 pop	 ebx
$LN14@Output:
  001f8	5e		 pop	 esi
$LN6@Output:

; 133  : }

  001f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fc	33 cd		 xor	 ecx, ebp
  001fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00203	8b e5		 mov	 esp, ebp
  00205	5d		 pop	 ebp
  00206	c3		 ret	 0
?Output@CLog@@QAAXW4eLogType@@PADZZ ENDP		; CLog::Output
_TEXT	ENDS
PUBLIC	??_C@_09DFAEMDJO@?$FL?$CF?48s?$FN?5?$CFs?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogAdd@@YAXW4eLogColor@@PADZZ			; LogAdd
EXTRN	?LogAddText@CServerDisplayer@@QAEXW4eLogColor@@PADH@Z:PROC ; CServerDisplayer::LogAddText
EXTRN	?gServerDisplayer@@3VCServerDisplayer@@A:BYTE	; gServerDisplayer
EXTRN	_asctime_s:PROC
;	COMDAT ??_C@_09DFAEMDJO@?$FL?$CF?48s?$FN?5?$CFs?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
CONST	SEGMENT
??_C@_09DFAEMDJO@?$FL?$CF?48s?$FN?5?$CFs?$AA@ DB '[%.8s] %s', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\log.cpp
CONST	ENDS
;	COMDAT ?LogAdd@@YAXW4eLogColor@@PADZZ
_TEXT	SEGMENT
_ltime$ = -2128						; size = 8
_today$ = -2120						; size = 36
_szBuffer$ = -2084					; size = 1024
_szTemp$ = -1060					; size = 1024
_szTime$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_Color$ = 8						; size = 4
_szLog$ = 12						; size = 4
?LogAdd@@YAXW4eLogColor@@PADZZ PROC			; LogAdd, COMDAT

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 08 00
	00		 sub	 esp, 2128		; 00000850H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 137  : 	tm today;
; 138  : 	// ---
; 139  : 	time_t ltime;
; 140  : 	// ---
; 141  : 	time(&ltime);

  00013	8d 85 b0 f7 ff
	ff		 lea	 eax, DWORD PTR _ltime$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 __time64

; 142  : 	// ---
; 143  : 	if(localtime_s(&today,&ltime) != 0)

  0001f	8d 8d b0 f7 ff
	ff		 lea	 ecx, DWORD PTR _ltime$[ebp]
  00025	51		 push	 ecx
  00026	8d 95 b8 f7 ff
	ff		 lea	 edx, DWORD PTR _today$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 __localtime64_s
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	85 c0		 test	 eax, eax
  00037	0f 85 ca 00 00
	00		 jne	 $LN3@LogAdd

; 144  : 	{
; 145  : 		return;
; 146  : 	}
; 147  : 	// ---
; 148  : 	char szTime[32] = {0};

  0003d	88 45 dc	 mov	 BYTE PTR _szTime$[ebp], al
  00040	89 45 dd	 mov	 DWORD PTR _szTime$[ebp+1], eax
  00043	89 45 e1	 mov	 DWORD PTR _szTime$[ebp+5], eax
  00046	89 45 e5	 mov	 DWORD PTR _szTime$[ebp+9], eax
  00049	89 45 e9	 mov	 DWORD PTR _szTime$[ebp+13], eax
  0004c	89 45 ed	 mov	 DWORD PTR _szTime$[ebp+17], eax
  0004f	89 45 f1	 mov	 DWORD PTR _szTime$[ebp+21], eax
  00052	89 45 f5	 mov	 DWORD PTR _szTime$[ebp+25], eax
  00055	66 89 45 f9	 mov	 WORD PTR _szTime$[ebp+29], ax
  00059	88 45 fb	 mov	 BYTE PTR _szTime$[ebp+31], al

; 149  : 	// ---
; 150  : 	if(asctime_s(szTime, sizeof(szTime), &today) != 0)

  0005c	8d 85 b8 f7 ff
	ff		 lea	 eax, DWORD PTR _today$[ebp]
  00062	50		 push	 eax
  00063	8d 4d dc	 lea	 ecx, DWORD PTR _szTime$[ebp]
  00066	6a 20		 push	 32			; 00000020H
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _asctime_s
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	85 c0		 test	 eax, eax
  00073	0f 85 8e 00 00
	00		 jne	 $LN3@LogAdd

; 151  : 	{
; 152  : 		return;
; 153  : 	}
; 154  : 	// ---
; 155  : 	char szBuffer[1024] = {0};

  00079	68 ff 03 00 00	 push	 1023			; 000003ffH
  0007e	50		 push	 eax
  0007f	8d 95 dd f7 ff
	ff		 lea	 edx, DWORD PTR _szBuffer$[ebp+1]
  00085	52		 push	 edx
  00086	88 85 dc f7 ff
	ff		 mov	 BYTE PTR _szBuffer$[ebp], al
  0008c	e8 00 00 00 00	 call	 _memset

; 156  : 	// ---
; 157  : 	va_list pArguments;
; 158  : 	// ---
; 159  : 	va_start(pArguments, szLog);
; 160  : 	// ---
; 161  : 	vsprintf(szBuffer, szLog, pArguments);

  00091	8b 4d 0c	 mov	 ecx, DWORD PTR _szLog$[ebp]
  00094	8d 45 10	 lea	 eax, DWORD PTR _szLog$[ebp+4]
  00097	50		 push	 eax
  00098	51		 push	 ecx
  00099	8d 95 dc f7 ff
	ff		 lea	 edx, DWORD PTR _szBuffer$[ebp]
  0009f	52		 push	 edx
  000a0	e8 00 00 00 00	 call	 _vsprintf

; 162  : 	// ---
; 163  : 	va_end(pArguments);
; 164  : 	// ---
; 165  : 	char szTemp[1024] = {0};

  000a5	68 ff 03 00 00	 push	 1023			; 000003ffH
  000aa	8d 85 dd fb ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp+1]
  000b0	6a 00		 push	 0
  000b2	50		 push	 eax
  000b3	c6 85 dc fb ff
	ff 00		 mov	 BYTE PTR _szTemp$[ebp], 0
  000ba	e8 00 00 00 00	 call	 _memset

; 166  : 	// ---
; 167  : 	wsprintf(szTemp,"[%.8s] %s", &szTime[11], szBuffer);

  000bf	8d 8d dc f7 ff
	ff		 lea	 ecx, DWORD PTR _szBuffer$[ebp]
  000c5	51		 push	 ecx
  000c6	8d 55 e7	 lea	 edx, DWORD PTR _szTime$[ebp+11]
  000c9	52		 push	 edx
  000ca	8d 85 dc fb ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_09DFAEMDJO@?$FL?$CF?48s?$FN?5?$CFs?$AA@
  000d5	50		 push	 eax
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 168  : 	// ---
; 169  : 	gServerDisplayer.LogAddText(Color, szTemp, strlen(szTemp));

  000dc	8d 85 dc fb ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  000e2	83 c4 34	 add	 esp, 52			; 00000034H
  000e5	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL9@LogAdd:
  000e8	8a 08		 mov	 cl, BYTE PTR [eax]
  000ea	40		 inc	 eax
  000eb	84 c9		 test	 cl, cl
  000ed	75 f9		 jne	 SHORT $LL9@LogAdd
  000ef	2b c2		 sub	 eax, edx
  000f1	8b 55 08	 mov	 edx, DWORD PTR _Color$[ebp]
  000f4	50		 push	 eax
  000f5	8d 8d dc fb ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  000fb	51		 push	 ecx
  000fc	52		 push	 edx
  000fd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gServerDisplayer@@3VCServerDisplayer@@A ; gServerDisplayer
  00102	e8 00 00 00 00	 call	 ?LogAddText@CServerDisplayer@@QAEXW4eLogColor@@PADH@Z ; CServerDisplayer::LogAddText
$LN3@LogAdd:

; 170  : }

  00107	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	33 cd		 xor	 ecx, ebp
  0010c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
?LogAdd@@YAXW4eLogColor@@PADZZ ENDP			; LogAdd
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__EgLog@@YAXXZ
text$yc	SEGMENT
??__EgLog@@YAXXZ PROC					; `dynamic initializer for 'gLog'', COMDAT

; 5    : CLog gLog;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gLog@@3VCLog@@A ; gLog
  00005	e8 00 00 00 00	 call	 ??0CLog@@QAE@XZ		; CLog::CLog
  0000a	68 00 00 00 00	 push	 OFFSET ??__FgLog@@YAXXZ	; `dynamic atexit destructor for 'gLog''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__EgLog@@YAXXZ ENDP					; `dynamic initializer for 'gLog''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__FgLog@@YAXXZ
text$yd	SEGMENT
??__FgLog@@YAXXZ PROC					; `dynamic atexit destructor for 'gLog'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gLog@@3VCLog@@A ; gLog
  00005	e9 00 00 00 00	 jmp	 ??1CLog@@UAE@XZ		; CLog::~CLog
??__FgLog@@YAXXZ ENDP					; `dynamic atexit destructor for 'gLog''
text$yd	ENDS
PUBLIC	?gLog@@3VCLog@@A				; gLog
_BSS	SEGMENT
?gLog@@3VCLog@@A DB 010a8H DUP (?)			; gLog
_BSS	ENDS
CRT$XCU	SEGMENT
_gLog$initializer$ DD FLAT:??__EgLog@@YAXXZ
CRT$XCU	ENDS
END
