; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\ItemBlock.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?gItemBlock@@3VCItemBlock@@A			; gItemBlock
_BSS	SEGMENT
?gItemBlock@@3VCItemBlock@@A DB 04b4H DUP (?)		; gItemBlock
_BSS	ENDS
PUBLIC	?IsCheckItem@CItemBlock@@QAE_NPAVCItem@@@Z	; CItemBlock::IsCheckItem
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itemblock.cpp
;	COMDAT ?IsCheckItem@CItemBlock@@QAE_NPAVCItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?IsCheckItem@CItemBlock@@QAE_NPAVCItem@@@Z PROC		; CItemBlock::IsCheckItem, COMDAT
; _this$ = ecx

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b 31		 mov	 esi, DWORD PTR [ecx]

; 46   : 	for(int i = 0; i < this->iCount; i++)

  00007	33 c0		 xor	 eax, eax
  00009	57		 push	 edi
  0000a	85 f6		 test	 esi, esi
  0000c	7e 1e		 jle	 SHORT $LN4@IsCheckIte
  0000e	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  00011	0f bf 7a 06	 movsx	 edi, WORD PTR [edx+6]
  00015	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
$LL6@IsCheckIte:

; 47   : 	{
; 48   : 		if(pItem->m_Type == ITEMGET(this->m_Data[i].Type, this->m_Data[i].ID))

  00018	8b 5a fc	 mov	 ebx, DWORD PTR [edx-4]
  0001b	c1 e3 09	 shl	 ebx, 9
  0001e	03 1a		 add	 ebx, DWORD PTR [edx]
  00020	3b fb		 cmp	 edi, ebx
  00022	74 11		 je	 SHORT $LN10@IsCheckIte

; 46   : 	for(int i = 0; i < this->iCount; i++)

  00024	40		 inc	 eax
  00025	83 c2 0c	 add	 edx, 12			; 0000000cH
  00028	3b c6		 cmp	 eax, esi
  0002a	7c ec		 jl	 SHORT $LL6@IsCheckIte
$LN4@IsCheckIte:
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 51   : 			{
; 52   : 				return 1;
; 53   : 			}
; 54   : 			else
; 55   : 			{
; 56   : 				return 0;
; 57   : 			}
; 58   : 		}
; 59   : 	}
; 60   : 	// ---
; 61   : 	return 0;

  0002e	32 c0		 xor	 al, al
  00030	5b		 pop	 ebx

; 62   : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN10@IsCheckIte:

; 49   : 		{
; 50   : 			if(pItem->m_Level == this->m_Data[i].Level)

  00035	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  00038	0f bf 52 08	 movsx	 edx, WORD PTR [edx+8]
  0003c	8d 44 40 03	 lea	 eax, DWORD PTR [eax+eax*2+3]
  00040	3b 14 81	 cmp	 edx, DWORD PTR [ecx+eax*4]
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	0f 94 c0	 sete	 al
  00048	5b		 pop	 ebx

; 62   : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?IsCheckItem@CItemBlock@@QAE_NPAVCItem@@@Z ENDP		; CItemBlock::IsCheckItem
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::allocator<std::pair<unsigned long const ,TokenizerSection> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::allocator<std::pair<unsigned long const ,TokenizerSection> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::allocator<std::pair<unsigned long const ,TokenizerSection> >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::allocator<std::pair<unsigned long const ,TokenizerSection> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::allocator<std::pair<unsigned long const ,TokenizerSection> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::allocator<std::pair<unsigned long const ,TokenizerSection> >
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z ; std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z PROC ; std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 41   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z ENDP ; std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBKVTokenizerSection@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node><std::pair<unsigned long const ,TokenizerSection> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBKVTokenizerSection@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBKVTokenizerSection@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node><std::pair<unsigned long const ,TokenizerSection> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBKVTokenizerSection@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node><std::pair<unsigned long const ,TokenizerSection> >
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long const ,TokenizerRow> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long const ,TokenizerRow> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long const ,TokenizerRow> >
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT

; 485  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 486  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00006	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 10	 mov	 esi, DWORD PTR __Count$[ebp]
  0000d	57		 push	 edi
  0000e	83 fe 04	 cmp	 esi, 4
  00011	72 14		 jb	 SHORT $LN11@compare
$LL4@compare:
  00013	8b 02		 mov	 eax, DWORD PTR [edx]
  00015	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00017	75 12		 jne	 SHORT $LN5@compare
  00019	83 ee 04	 sub	 esi, 4
  0001c	83 c1 04	 add	 ecx, 4
  0001f	83 c2 04	 add	 edx, 4
  00022	83 fe 04	 cmp	 esi, 4
  00025	73 ec		 jae	 SHORT $LL4@compare
$LN11@compare:
  00027	85 f6		 test	 esi, esi
  00029	74 45		 je	 SHORT $LN6@compare
$LN5@compare:
  0002b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0002e	0f b6 39	 movzx	 edi, BYTE PTR [ecx]
  00031	2b c7		 sub	 eax, edi
  00033	75 31		 jne	 SHORT $LN7@compare
  00035	83 fe 01	 cmp	 esi, 1
  00038	76 36		 jbe	 SHORT $LN6@compare
  0003a	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  0003e	0f b6 79 01	 movzx	 edi, BYTE PTR [ecx+1]
  00042	2b c7		 sub	 eax, edi
  00044	75 20		 jne	 SHORT $LN7@compare
  00046	83 fe 02	 cmp	 esi, 2
  00049	76 25		 jbe	 SHORT $LN6@compare
  0004b	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0004f	0f b6 79 02	 movzx	 edi, BYTE PTR [ecx+2]
  00053	2b c7		 sub	 eax, edi
  00055	75 0f		 jne	 SHORT $LN7@compare
  00057	83 fe 03	 cmp	 esi, 3
  0005a	76 14		 jbe	 SHORT $LN6@compare
  0005c	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00060	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00064	2b c1		 sub	 eax, ecx
$LN7@compare:
  00066	c1 f8 1f	 sar	 eax, 31			; 0000001fH
  00069	5f		 pop	 edi
  0006a	83 c8 01	 or	 eax, 1
  0006d	5e		 pop	 esi

; 487  : 		}

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
$LN6@compare:
  00070	5f		 pop	 edi

; 486  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00071	33 c0		 xor	 eax, eax
  00073	5e		 pop	 esi

; 487  : 		}

  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Ogtp
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 490  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 491  : 		return (_CSTD strlen(_First));

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL3@length:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL3@length
  00017	2b c2		 sub	 eax, edx

; 492  : 		}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 496  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 498  : 		}

  00003	5d		 pop	 ebp

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00004	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?find@?$char_traits@D@std@@SAPBDPBDIABD@Z	; std::char_traits<char>::find
EXTRN	_memchr:PROC
; Function compile flags: /Ogtp
;	COMDAT ?find@?$char_traits@D@std@@SAPBDPBDIABD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 4
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z PROC		; std::char_traits<char>::find, COMDAT

; 510  : 		{	// look for _Ch in [_First, _First + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 511  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Ch$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00009	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0000c	50		 push	 eax
  0000d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00010	52		 push	 edx
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _memchr
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 512  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z ENDP		; std::char_traits<char>::find
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
EXTRN	_memmove:PROC
; Function compile flags: /Ogtp
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 516  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 518  : 		}

  00003	5d		 pop	 ebp

; 517  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00004	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 521  : 		{	// assign _Count * _Ch to [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 522  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	0f be 4d 10	 movsx	 ecx, BYTE PTR __Ch$[ebp]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	52		 push	 edx
  00010	e8 00 00 00 00	 call	 _memset
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 523  : 		}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 526  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 527  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  0000b	88 0a		 mov	 BYTE PTR [edx], cl

; 528  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
; Function compile flags: /Ogtp
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 541  : 		{	// convert metacharacter to character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 542  : 		return ((_Elem)_Meta);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	8a 00		 mov	 al, BYTE PTR [eax]

; 543  : 		}

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
; Function compile flags: /Ogtp
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 546  : 		{	// convert character to metacharacter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 547  : 		return ((unsigned char)_Ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 548  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
; Function compile flags: /Ogtp
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 552  : 		{	// test for metacharacter equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 		return (_Left == _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0000f	0f 94 c0	 sete	 al

; 554  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
; Function compile flags: /Ogtp
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 563  : 		return (EOF);

  00000	83 c8 ff	 or	 eax, -1

; 564  : 		}

  00003	c3		 ret	 0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??0runtime_error@std@@QAE@PBD@Z			; std::runtime_error::runtime_error
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0runtime_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@PBD@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 170  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 171  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@PBD@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
; Function compile flags: /Ogtp
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
EXTRN	__Getctype:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T154562 = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 117  : 		{	// return ctype stuff

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  : 		return (::_Getctype());

  00003	8d 45 f0	 lea	 eax, DWORD PTR $T154562[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __Getctype
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	89 11		 mov	 DWORD PTR [ecx], edx
  00016	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00019	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0001f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00022	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00025	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00028	83 c4 04	 add	 esp, 4
  0002b	8b c1		 mov	 eax, ecx

; 119  : 		}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 71   : 			{	// construct with specified stamp value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 72   : 			}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
; Function compile flags: /Ogtp
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$103592 = -4					; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 75   : 			{	// get stamp, with lazy allocation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 76   : 			if (_Id == 0)

  00007	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0000a	75 24		 jne	 SHORT $LN6@operator

; 77   : 				{	// still zero, allocate stamp
; 78   : 				_BEGIN_LOCK(_LOCK_LOCALE)

  0000c	6a 00		 push	 0
  0000e	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$103592[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 79   : 					if (_Id == 0)

  00016	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00019	75 0d		 jne	 SHORT $LN1@operator

; 80   : 						_Id = ++_Id_cnt;

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00020	40		 inc	 eax
  00021	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00026	89 06		 mov	 DWORD PTR [esi], eax
$LN1@operator:

; 81   : 				_END_LOCK()

  00028	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$103592[ebp]
  0002b	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN6@operator:

; 82   : 				}
; 83   : 			return (_Id);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	5e		 pop	 esi

; 84   : 			}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
PUBLIC	?_Incref@facet@locale@std@@QAEXXZ		; std::locale::facet::_Incref
; Function compile flags: /Ogtp
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
__Lock$103598 = -4					; size = 4
?_Incref@facet@locale@std@@QAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 111  : 			{	// safely increment the reference count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 112  : 			_BEGIN_LOCK(_LOCK_LOCALE)

  00007	6a 00		 push	 0
  00009	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$103598[ebp]
  0000c	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 113  : 				if (_Refs < (size_t)(-1))

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	83 f8 ff	 cmp	 eax, -1
  00017	73 04		 jae	 SHORT $LN1@Incref

; 114  : 					++_Refs;

  00019	40		 inc	 eax
  0001a	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@Incref:

; 115  : 			_END_LOCK()

  0001d	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$103598[ebp]
  00020	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00025	5e		 pop	 esi

; 116  : 			}

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?_Incref@facet@locale@std@@QAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
PUBLIC	?_Decref@facet@locale@std@@QAEPAV123@XZ		; std::locale::facet::_Decref
; Function compile flags: /Ogtp
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT
__Lock$103603 = -4					; size = 4
?_Decref@facet@locale@std@@QAEPAV123@XZ PROC		; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 119  : 			{	// safely decrement the reference count, return this when dead

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 120  : 			_BEGIN_LOCK(_LOCK_LOCALE)

  00008	6a 00		 push	 0
  0000a	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$103603[ebp]
  0000d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 121  : 				if (0 < _Refs && _Refs < (size_t)(-1))

  00012	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00015	85 c0		 test	 eax, eax
  00017	74 09		 je	 SHORT $LN1@Decref
  00019	83 f8 ff	 cmp	 eax, -1
  0001c	73 04		 jae	 SHORT $LN1@Decref

; 122  : 					--_Refs;

  0001e	48		 dec	 eax
  0001f	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN1@Decref:

; 123  : 				return (_Refs == 0 ? this : 0);

  00022	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00025	f7 de		 neg	 esi
  00027	1b f6		 sbb	 esi, esi
  00029	f7 d6		 not	 esi
  0002b	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$103603[ebp]
  0002e	23 f7		 and	 esi, edi
  00030	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00035	5f		 pop	 edi
  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi

; 124  : 			_END_LOCK()
; 125  : 			}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?_Decref@facet@locale@std@@QAEPAV123@XZ ENDP		; std::locale::facet::_Decref
_TEXT	ENDS
PUBLIC	?_Register@facet@locale@std@@QAEXXZ		; std::locale::facet::_Register
EXTRN	?_Facet_Register@facet@locale@std@@CAXPAV123@@Z:PROC ; std::locale::facet::_Facet_Register
; Function compile flags: /Ogtp
;	COMDAT ?_Register@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
?_Register@facet@locale@std@@QAEXXZ PROC		; std::locale::facet::_Register, COMDAT
; _this$ = ecx

; 129  :  #if defined(_M_CEE)
; 130  : 			_Facet_Register_m(this);
; 131  : 
; 132  :  #else /* defined(_M_CEE) */
; 133  : 			_Facet_Register(this);

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 ?_Facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::_Facet_Register
  00006	59		 pop	 ecx

; 134  :  #endif /* defined(_M_CEE) */
; 135  : 			}

  00007	c3		 ret	 0
?_Register@facet@locale@std@@QAEXXZ ENDP		; std::locale::facet::_Register
_TEXT	ENDS
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??1facet@locale@std@@UAE@XZ			; std::locale::facet::~facet
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Efacet@locale@std@@UAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@UAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 164  : 			{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@

; 165  : 			}

  00006	c3		 ret	 0
??1facet@locale@std@@UAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
; Function compile flags: /Ogtp
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 170  : 			{	// construct with initial reference count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Initrefs$[ebp]
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
  0000e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 171  : 			}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
; Function compile flags: /Ogtp
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Lock$154588 = 8					; size = 4
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 309  : 		{	// construct by copying

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b 30		 mov	 esi, DWORD PTR [eax]
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx

; 310  : 		_Ptr->_Incref();

  0000c	6a 00		 push	 0
  0000e	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$154588[ebp]
  00011	89 37		 mov	 DWORD PTR [edi], esi
  00013	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	83 f8 ff	 cmp	 eax, -1
  0001e	73 04		 jae	 SHORT $LN3@locale
  00020	40		 inc	 eax
  00021	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN3@locale:
  00024	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$154588[ebp]
  00027	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit

; 311  : 		}

  0002c	8b c7		 mov	 eax, edi
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
PUBLIC	??0locale@std@@QAE@XZ				; std::locale::locale
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	?_Init@locale@std@@CAPAV_Locimp@12@XZ:PROC	; std::locale::_Init
; Function compile flags: /Ogtp
;	COMDAT ??0locale@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$154596 = -4					; size = 4
??0locale@std@@QAE@XZ PROC				; std::locale::locale, COMDAT
; _this$ = ecx

; 315  : 		{	// construct from current locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Init
  0000d	89 07		 mov	 DWORD PTR [edi], eax

; 316  : 		_Getgloballocale()->_Incref();

  0000f	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  00014	6a 00		 push	 0
  00016	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$154596[ebp]
  00019	8b f0		 mov	 esi, eax
  0001b	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	83 f8 ff	 cmp	 eax, -1
  00026	73 04		 jae	 SHORT $LN3@locale@2
  00028	40		 inc	 eax
  00029	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN3@locale@2:
  0002c	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$154596[ebp]
  0002f	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit

; 317  : 		}

  00034	8b c7		 mov	 eax, edi
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??0locale@std@@QAE@XZ ENDP				; std::locale::locale
_TEXT	ENDS
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
; Function compile flags: /Ogtp
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$154609 = -4					; size = 4
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 409  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 410  : 		if (_Ptr != 0)

  00005	8b 39		 mov	 edi, DWORD PTR [ecx]
  00007	85 ff		 test	 edi, edi
  00009	74 3b		 je	 SHORT $LN4@locale@3

; 411  : 			_DELETE_CRT(_Ptr->_Decref());

  0000b	6a 00		 push	 0
  0000d	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$154609[ebp]
  00010	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00015	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00018	85 c0		 test	 eax, eax
  0001a	74 09		 je	 SHORT $LN6@locale@3
  0001c	83 f8 ff	 cmp	 eax, -1
  0001f	73 04		 jae	 SHORT $LN6@locale@3
  00021	48		 dec	 eax
  00022	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN6@locale@3:
  00025	56		 push	 esi
  00026	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00029	f7 de		 neg	 esi
  0002b	1b f6		 sbb	 esi, esi
  0002d	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$154609[ebp]
  00030	f7 d6		 not	 esi
  00032	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00037	23 f7		 and	 esi, edi
  00039	74 0a		 je	 SHORT $LN9@locale@3
  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	8b 10		 mov	 edx, DWORD PTR [eax]
  0003f	6a 01		 push	 1
  00041	8b ce		 mov	 ecx, esi
  00043	ff d2		 call	 edx
$LN9@locale@3:
  00045	5e		 pop	 esi
$LN4@locale@3:
  00046	5f		 pop	 edi

; 412  : 		}

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
; Function compile flags: /Ogtp
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 436  : 		{	// look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 437  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 438  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR __Id$[ebp]
  00009	3b 71 0c	 cmp	 esi, DWORD PTR [ecx+12]
  0000c	73 25		 jae	 SHORT $LN6@Getfacet
  0000e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00011	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]

; 439  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00014	85 c0		 test	 eax, eax
  00016	75 21		 jne	 SHORT $LN1@Getfacet
$LN10@Getfacet:
  00018	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  0001c	74 1b		 je	 SHORT $LN1@Getfacet

; 440  : 			return (_Facptr);	// found facet or not transparent
; 441  : 		else
; 442  : 			{	// look in current locale
; 443  : 			locale::_Locimp *_Ptr = _Getgloballocale();

  0001e	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 444  : 			return (_Id < _Ptr->_Facetcount
; 445  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 446  : 				: 0);	// no entry in current locale

  00023	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  00026	73 0f		 jae	 SHORT $LN8@Getfacet
  00028	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002b	8b 04 b1	 mov	 eax, DWORD PTR [ecx+esi*4]
  0002e	5e		 pop	 esi

; 447  : 			}
; 448  : 		}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN6@Getfacet:

; 437  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 438  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

  00033	33 c0		 xor	 eax, eax

; 439  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00035	eb e1		 jmp	 SHORT $LN10@Getfacet
$LN8@Getfacet:

; 444  : 			return (_Id < _Ptr->_Facetcount
; 445  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 446  : 				: 0);	// no entry in current locale

  00037	33 c0		 xor	 eax, eax
$LN1@Getfacet:
  00039	5e		 pop	 esi

; 447  : 			}
; 448  : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@UAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar@2
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar@2:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_Gfacet@locale@std@@UAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7codecvt_base@std@@6B@			; std::codecvt_base::`vftable'
PUBLIC	??0codecvt_base@std@@QAE@I@Z			; std::codecvt_base::codecvt_base
PUBLIC	??_R4codecvt_base@std@@6B@			; std::codecvt_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVcodecvt_base@std@@@8			; std::codecvt_base `RTTI Type Descriptor'
PUBLIC	??_R3codecvt_base@std@@8			; std::codecvt_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2codecvt_base@std@@8			; std::codecvt_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@codecvt_base@std@@8		; std::codecvt_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?do_always_noconv@codecvt_base@std@@MBE_NXZ	; std::codecvt_base::do_always_noconv
PUBLIC	?do_max_length@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_max_length
PUBLIC	?do_encoding@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_encoding
EXTRN	??_Ecodecvt_base@std@@UAEPAXI@Z:PROC		; std::codecvt_base::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@codecvt_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@codecvt_base@std@@8 DD FLAT:??_R0?AVcodecvt_base@std@@@8 ; std::codecvt_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2codecvt_base@std@@8
rdata$r	SEGMENT
??_R2codecvt_base@std@@8 DD FLAT:??_R1A@?0A@EA@codecvt_base@std@@8 ; std::codecvt_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3codecvt_base@std@@8
rdata$r	SEGMENT
??_R3codecvt_base@std@@8 DD 00H				; std::codecvt_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcodecvt_base@std@@@8
_DATA	SEGMENT
??_R0?AVcodecvt_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::codecvt_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcodecvt_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4codecvt_base@std@@6B@
rdata$r	SEGMENT
??_R4codecvt_base@std@@6B@ DD 00H			; std::codecvt_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcodecvt_base@std@@@8
	DD	FLAT:??_R3codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7codecvt_base@std@@6B@
CONST	SEGMENT
??_7codecvt_base@std@@6B@ DD FLAT:??_R4codecvt_base@std@@6B@ ; std::codecvt_base::`vftable'
	DD	FLAT:??_Ecodecvt_base@std@@UAEPAXI@Z
	DD	FLAT:?do_always_noconv@codecvt_base@std@@MBE_NXZ
	DD	FLAT:?do_max_length@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_encoding@codecvt_base@std@@MBEHXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0codecvt_base@std@@QAE@I@Z
_TEXT	SEGMENT
__Refs$ = 8						; size = 4
??0codecvt_base@std@@QAE@I@Z PROC			; std::codecvt_base::codecvt_base, COMDAT
; _this$ = ecx

; 752  : 		{	// default constructor

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Refs$[ebp]
  00008	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7codecvt_base@std@@6B@

; 753  : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0codecvt_base@std@@QAE@I@Z ENDP			; std::codecvt_base::codecvt_base
_TEXT	ENDS
PUBLIC	?always_noconv@codecvt_base@std@@QBE_NXZ	; std::codecvt_base::always_noconv
; Function compile flags: /Ogtp
;	COMDAT ?always_noconv@codecvt_base@std@@QBE_NXZ
_TEXT	SEGMENT
?always_noconv@codecvt_base@std@@QBE_NXZ PROC		; std::codecvt_base::always_noconv, COMDAT
; _this$ = ecx

; 757  : 		return (do_always_noconv());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00005	ff e2		 jmp	 edx
?always_noconv@codecvt_base@std@@QBE_NXZ ENDP		; std::codecvt_base::always_noconv
_TEXT	ENDS
PUBLIC	??1codecvt_base@std@@UAE@XZ			; std::codecvt_base::~codecvt_base
; Function compile flags: /Ogtp
;	COMDAT ??1codecvt_base@std@@UAE@XZ
_TEXT	SEGMENT
??1codecvt_base@std@@UAE@XZ PROC			; std::codecvt_base::~codecvt_base, COMDAT
; _this$ = ecx

; 772  : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00006	c3		 ret	 0
??1codecvt_base@std@@UAE@XZ ENDP			; std::codecvt_base::~codecvt_base
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_always_noconv@codecvt_base@std@@MBE_NXZ
_TEXT	SEGMENT
?do_always_noconv@codecvt_base@std@@MBE_NXZ PROC	; std::codecvt_base::do_always_noconv, COMDAT
; _this$ = ecx

; 777  : 		return (true);

  00000	b0 01		 mov	 al, 1

; 778  : 		}

  00002	c3		 ret	 0
?do_always_noconv@codecvt_base@std@@MBE_NXZ ENDP	; std::codecvt_base::do_always_noconv
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_max_length@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
?do_max_length@codecvt_base@std@@MBEHXZ PROC		; std::codecvt_base::do_max_length, COMDAT
; _this$ = ecx

; 782  : 		return (1);

  00000	b8 01 00 00 00	 mov	 eax, 1

; 783  : 		}

  00005	c3		 ret	 0
?do_max_length@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_max_length
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_encoding@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
?do_encoding@codecvt_base@std@@MBEHXZ PROC		; std::codecvt_base::do_encoding, COMDAT
; _this$ = ecx

; 787  : 		return (1);	// -1 ==> state dependent, 0 ==> varying length

  00000	b8 01 00 00 00	 mov	 eax, 1

; 788  : 		}

  00005	c3		 ret	 0
?do_encoding@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_encoding
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gcodecvt_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gcodecvt_base@std@@UAEPAXI@Z PROC			; std::codecvt_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00010	74 09		 je	 SHORT $LN8@scalar@3
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN8@scalar@3:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_Gcodecvt_base@std@@UAEPAXI@Z ENDP			; std::codecvt_base::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 2011 : 		{	// default constructor

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Refs$[ebp]
  00008	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 2012 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
; Function compile flags: /Ogtp
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 2016 : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00006	c3		 ret	 0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00010	74 09		 je	 SHORT $LN8@scalar@4
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN8@scalar@4:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?is@?$ctype@D@std@@QBE_NFD@Z			; std::ctype<char>::is
; Function compile flags: /Ogtp
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 1
?is@?$ctype@D@std@@QBE_NFD@Z PROC			; std::ctype<char>::is, COMDAT
; _this$ = ecx

; 2271 : 		{	// test if element fits any mask classifications

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2272 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

  00003	0f b6 45 0c	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00007	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000a	66 8b 55 08	 mov	 dx, WORD PTR __Maskval$[ebp]
  0000e	66 85 14 41	 test	 WORD PTR [ecx+eax*2], dx
  00012	b8 00 00 00 00	 mov	 eax, 0
  00017	0f 95 c0	 setne	 al

; 2273 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?is@?$ctype@D@std@@QBE_NFD@Z ENDP			; std::ctype<char>::is
_TEXT	ENDS
PUBLIC	?widen@?$ctype@D@std@@QBEDD@Z			; std::ctype<char>::widen
; Function compile flags: /Ogtp
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?widen@?$ctype@D@std@@QBEDD@Z PROC			; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2324 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2325 : 		return (do_widen(_Byte));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 2326 : 		}

  00008	5d		 pop	 ebp

; 2325 : 		return (do_widen(_Byte));

  00009	ff e0		 jmp	 eax
?widen@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::widen
_TEXT	ENDS
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
; Function compile flags: /Ogtp
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T154702 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2399 : 		{	// initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 2400 : 		_Ctype = _Lobj._Getctype();

  00007	8d 45 f0	 lea	 eax, DWORD PTR $T154702[ebp]
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 __Getctype
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  0001d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00020	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00023	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00026	83 c4 04	 add	 esp, 4
  00029	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0002c	5e		 pop	 esi

; 2401 : 		}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
PUBLIC	??0error_code@std@@QAE@HABVerror_category@1@@Z	; std::error_code::error_code
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 204  : 		{	// construct from error code and category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 0c	 mov	 edx, DWORD PTR __Cat$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx
  0000d	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 205  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z ; std::make_error_code
EXTRN	?iostream_category@std@@YAABVerror_category@1@XZ:PROC ; std::iostream_category
; Function compile flags: /Ogtp
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z PROC ; std::make_error_code, COMDAT

; 446  : 	{	// make an error_code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	return (error_code(_Errno, iostream_category()));

  00003	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  00008	8b 55 0c	 mov	 edx, DWORD PTR __Errno$[ebp]
  0000b	8b c8		 mov	 ecx, eax
  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00010	89 10		 mov	 DWORD PTR [eax], edx
  00012	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 448  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z ENDP ; std::make_error_code
_TEXT	ENDS
PUBLIC	?_Makestr@system_error@std@@AAEXXZ		; std::system_error::_Makestr
; Function compile flags: /Ogtp
;	COMDAT ?_Makestr@system_error@std@@AAEXXZ
_TEXT	SEGMENT
?_Makestr@system_error@std@@AAEXXZ PROC			; std::system_error::_Makestr, COMDAT
; _this$ = ecx

; 563  : //		_Mymes = this->runtime_error::what();
; 564  : //		if (!_Mymes.empty())
; 565  : //			_Mymes.append(": ");
; 566  : //		_Mymes.append(_Mycode.message());
; 567  : 		}

  00000	c3		 ret	 0
?_Makestr@system_error@std@@AAEXXZ ENDP			; std::system_error::_Makestr
_TEXT	ENDS
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
; Function compile flags: /Ogtp
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 336  : 		return (_Mystate);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 337  : 		}

  00003	c3		 ret	 0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
; Function compile flags: /Ogtp
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 358  : 		return (rdstate() == goodbit);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00005	0f 94 c0	 sete	 al

; 359  : 		}

  00008	c3		 ret	 0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
PUBLIC	?eof@ios_base@std@@QBE_NXZ			; std::ios_base::eof
; Function compile flags: /Ogtp
;	COMDAT ?eof@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?eof@ios_base@std@@QBE_NXZ PROC				; std::ios_base::eof, COMDAT
; _this$ = ecx

; 363  : 		return ((int)rdstate() & (int)eofbit);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	83 e0 01	 and	 eax, 1

; 364  : 		}

  00006	c3		 ret	 0
?eof@ios_base@std@@QBE_NXZ ENDP				; std::ios_base::eof
_TEXT	ENDS
PUBLIC	?fail@ios_base@std@@QBE_NXZ			; std::ios_base::fail
; Function compile flags: /Ogtp
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?fail@ios_base@std@@QBE_NXZ PROC			; std::ios_base::fail, COMDAT
; _this$ = ecx

; 368  : 		return (((int)rdstate()
; 369  : 			& ((int)badbit | (int)failbit)) != 0);

  00000	f6 41 0c 06	 test	 BYTE PTR [ecx+12], 6
  00004	b8 00 00 00 00	 mov	 eax, 0
  00009	0f 95 c0	 setne	 al

; 370  : 		}

  0000c	c3		 ret	 0
?fail@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::fail
_TEXT	ENDS
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
; Function compile flags: /Ogtp
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 395  : 		return (_Fmtfl);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 396  : 		}

  00003	c3		 ret	 0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
; Function compile flags: /Ogtp
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
$T154754 = -4						; size = 4
__Lock$154767 = 8					; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 451  : 		{	// get locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 452  : 		return (*_Ploc);

  00004	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00007	56		 push	 esi
  00008	8b 30		 mov	 esi, DWORD PTR [eax]
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	6a 00		 push	 0
  00010	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$154767[ebp]
  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T154754[ebp], 0
  0001a	89 37		 mov	 DWORD PTR [edi], esi
  0001c	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00021	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00024	83 f8 ff	 cmp	 eax, -1
  00027	73 04		 jae	 SHORT $LN7@getloc
  00029	40		 inc	 eax
  0002a	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN7@getloc:
  0002d	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$154767[ebp]
  00030	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00035	8b c7		 mov	 eax, edi
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 453  : 		}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
PUBLIC	??_7ios_base@std@@6B@				; std::ios_base::`vftable'
PUBLIC	??1ios_base@std@@UAE@XZ				; std::ios_base::~ios_base
PUBLIC	??_R4ios_base@std@@6B@				; std::ios_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z:PROC	; std::ios_base::_Ios_base_dtor
EXTRN	??_Eios_base@std@@UAEPAXI@Z:PROC		; std::ios_base::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
_DATA	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ios_base@std@@6B@
rdata$r	SEGMENT
??_R4ios_base@std@@6B@ DD 00H				; std::ios_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVios_base@std@@@8
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT
??_7ios_base@std@@6B@ DD FLAT:??_R4ios_base@std@@6B@	; std::ios_base::`vftable'
	DD	FLAT:??_Eios_base@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ios_base@std@@UAE@XZ PROC				; std::ios_base::~ios_base, COMDAT
; _this$ = ecx

; 541  : 		_Ios_base_dtor(this);

  00000	51		 push	 ecx
  00001	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00007	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0000c	59		 pop	 ecx

; 542  : 		}

  0000d	c3		 ret	 0
??1ios_base@std@@UAE@XZ ENDP				; std::ios_base::~ios_base
_TEXT	ENDS
PUBLIC	??0ios_base@std@@IAE@XZ				; std::ios_base::ios_base
; Function compile flags: /Ogtp
;	COMDAT ??0ios_base@std@@IAE@XZ
_TEXT	SEGMENT
??0ios_base@std@@IAE@XZ PROC				; std::ios_base::ios_base, COMDAT
; _this$ = ecx

; 549  : 	__CLR_OR_THIS_CALL ios_base()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@

; 550  : 		{	// default constructor
; 551  : 		}

  00008	c3		 ret	 0
??0ios_base@std@@IAE@XZ ENDP				; std::ios_base::ios_base
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gios_base@std@@UAEPAXI@Z PROC			; std::ios_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	56		 push	 esi
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  0000d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00012	83 c4 04	 add	 esp, 4
  00015	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00019	74 09		 je	 SHORT $LN6@scalar@5
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00021	83 c4 04	 add	 esp, 4
$LN6@scalar@5:
  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??_Gios_base@std@@UAEPAXI@Z ENDP			; std::ios_base::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1507 : 		return (this->_Mysize);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1508 : 		}

  00003	c3		 ret	 0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1512 : 		return (this->_Mysize);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1513 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	??0?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::_Yarn<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 3315 : 		{	// default construct

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00008	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 3316 : 		}

  0000c	c3		 ret	 0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
PUBLIC	?c_str@?$_Yarn@D@std@@QBEPBDXZ			; std::_Yarn<char>::c_str
; Function compile flags: /Ogtp
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 3376 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	75 03		 jne	 SHORT $LN4@c_str
  00006	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
$LN4@c_str:

; 3377 : 		}

  00009	c3		 ret	 0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
PUBLIC	??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
PUBLIC	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
EXTRN	??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ostream
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 79   : 		{	// destroy the object

  00000	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00003	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00006	c7 44 0a f8 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@

; 80   : 		}

  0000e	c3		 ret	 0
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 38   : 		}

  00000	51		 push	 ecx
  00001	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00007	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
; Function compile flags: /Ogtp
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 86   : 		return (_Mystrbuf);

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]

; 87   : 		}

  00003	c3		 ret	 0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
PUBLIC	??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
PUBLIC	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	010H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 63   : 		{	// destroy the object

  00000	8b 41 f0	 mov	 eax, DWORD PTR [ecx-16]
  00003	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00006	c7 44 0a f0 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-16], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@

; 64   : 		}

  0000e	c3		 ret	 0
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct::*
; Function compile flags: /Ogtp
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct::*, COMDAT
; _this$ = ecx

; 105  : 			return (_Ok ? _CONVERTIBLE_TO_TRUE : 0);

  00000	33 c0		 xor	 eax, eax
  00002	38 41 04	 cmp	 BYTE PTR [ecx+4], al
  00005	0f 95 c0	 setne	 al
  00008	48		 dec	 eax

; 106  : 			}

  00009	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct::*
_TEXT	ENDS
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 83   : 			if (_Myistr.rdbuf() != 0)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 44 02 38	 mov	 eax, DWORD PTR [edx+eax+56]
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN1@Sentry_bas

; 84   : 				_Myistr.rdbuf()->_Unlock();

  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	8b c8		 mov	 ecx, eax
  00013	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00016	ff e0		 jmp	 eax
$LN1@Sentry_bas:

; 85   : 			}

  00018	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator==
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 331  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator==
_TEXT	ENDS
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 331  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator==
_TEXT	ENDS
PUBLIC	??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`vftable'
PUBLIC	??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
EXTRN	??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_iostream<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	FLAT:??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	018H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 963  : 		{	// destroy the object

  00000	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00003	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00006	c7 44 0a e8 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-24], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@

; 964  : 		}

  0000e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	c7 44 0a f8 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  0001c	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  0001f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00022	c7 44 0a e8 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  0002a	c3		 ret	 0
??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??_Glocale@std@@QAEPAXI@Z			; std::locale::`scalar deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT
__Lock$154865 = -4					; size = 4
___flags$ = 8						; size = 4
??_Glocale@std@@QAEPAXI@Z PROC				; std::locale::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	57		 push	 edi
  00008	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0000a	85 ff		 test	 edi, edi
  0000c	74 3b		 je	 SHORT $LN7@scalar@6
  0000e	6a 00		 push	 0
  00010	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$154865[ebp]
  00013	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00018	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001b	85 c0		 test	 eax, eax
  0001d	74 09		 je	 SHORT $LN9@scalar@6
  0001f	83 f8 ff	 cmp	 eax, -1
  00022	73 04		 jae	 SHORT $LN9@scalar@6
  00024	48		 dec	 eax
  00025	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN9@scalar@6:
  00028	56		 push	 esi
  00029	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0002c	f7 de		 neg	 esi
  0002e	1b f6		 sbb	 esi, esi
  00030	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$154865[ebp]
  00033	f7 d6		 not	 esi
  00035	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0003a	23 f7		 and	 esi, edi
  0003c	74 0a		 je	 SHORT $LN13@scalar@6
  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	6a 01		 push	 1
  00044	8b ce		 mov	 ecx, esi
  00046	ff d2		 call	 edx
$LN13@scalar@6:
  00048	5e		 pop	 esi
$LN7@scalar@6:
  00049	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0004d	74 09		 je	 SHORT $LN12@scalar@6
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00055	83 c4 04	 add	 esp, 4
$LN12@scalar@6:
  00058	5f		 pop	 edi
  00059	8b c3		 mov	 eax, ebx
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??_Glocale@std@@QAEPAXI@Z ENDP				; std::locale::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00003	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	c7 44 02 f8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00011	50		 push	 eax
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  00018	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0001d	59		 pop	 ecx
  0001e	c3		 ret	 0
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
PUBLIC	??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00003	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	c7 44 02 f0 00
	00 00 00	 mov	 DWORD PTR [edx+eax-16], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00011	50		 push	 eax
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  00018	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0001d	59		 pop	 ecx
  0001e	c3		 ret	 0
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
PUBLIC	??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00003	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	c7 44 02 e8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-24], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  00011	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00014	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00017	c7 44 02 f8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  0001f	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  00022	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00025	c7 44 02 e8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  0002d	50		 push	 eax
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  00034	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00039	59		 pop	 ecx
  0003a	c3		 ret	 0
??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2003 : 		{	// determine current pointer to buffer for mutable string

  00000	8b c1		 mov	 eax, ecx

; 2004 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2005 : 			: this->_Bx._Buf);

  00002	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00006	72 02		 jb	 SHORT $LN4@Myptr
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Myptr:

; 2006 : 		}

  0000a	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2009 : 		{	// determine current pointer to buffer for nonmutable string

  00000	8b c1		 mov	 eax, ecx

; 2010 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2011 : 			: this->_Bx._Buf);

  00002	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00006	72 02		 jb	 SHORT $LN4@Myptr@2
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Myptr@2:

; 2012 : 		}

  0000a	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2021 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 459  : 		}

  00000	c3		 ret	 0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Yarn@D@std@@AAEXXZ			; std::_Yarn<char>::_Tidy
EXTRN	_free:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 3391 : 		{	// discard any string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3392 : 		if (_Myptr != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN4@Tidy

; 3393 : 
; 3394 :  #ifdef _DEBUG
; 3395 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3396 : 
; 3397 :  #else /* _DEBUG */
; 3398 : 			_CSTD free(_Myptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN4@Tidy:

; 3399 :  #endif /* _DEBUG */
; 3400 : 
; 3401 : 		_Myptr = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3402 : 		}

  00019	c3		 ret	 0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
PUBLIC	??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
PUBLIC	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
EXTRN	??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ios<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
rdata$r	SEGMENT
??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
CONST	ENDS
;	COMDAT ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 167  : 	__CLR_OR_THIS_CALL basic_ios()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@

; 168  : 		{	// default constructor, do nothing
; 169  : 		}

  00008	c3		 ret	 0
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	56		 push	 esi
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  0000d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00012	83 c4 04	 add	 esp, 4
  00015	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00019	74 09		 je	 SHORT $LN9@scalar@7
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00021	83 c4 04	 add	 esp, 4
$LN9@scalar@7:
  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 76   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 77   : 			if (_Myistr.rdbuf() != 0)

  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00010	8b 4c 02 38	 mov	 ecx, DWORD PTR [edx+eax+56]
  00014	85 c9		 test	 ecx, ecx
  00016	74 07		 je	 SHORT $LN8@Sentry_bas@2

; 78   : 				_Myistr.rdbuf()->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001d	ff d2		 call	 edx
$LN8@Sentry_bas@2:

; 79   : 			}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 141  : 		return (sync());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  00005	ff e2		 jmp	 edx
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
PUBLIC	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
; Function compile flags: /Ogtp
;	COMDAT ?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::eback, COMDAT
; _this$ = ecx

; 218  : 		return (*_IGfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 219  : 		}

  00005	c3		 ret	 0
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::eback
_TEXT	ENDS
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
; Function compile flags: /Ogtp
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = ecx

; 223  : 		return (*_IGnext);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 224  : 		}

  00005	c3		 ret	 0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
_TEXT	ENDS
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
; Function compile flags: /Ogtp
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 267  : 		--*_IGcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 268  : 		return ((*_IGnext)++);

  00005	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000d	89 11		 mov	 DWORD PTR [ecx], edx

; 269  : 		}

  0000f	c3		 ret	 0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
_TEXT	ENDS
PUBLIC	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
; Function compile flags: /Ogtp
;	COMDAT ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc, COMDAT
; _this$ = ecx

; 273  : 		--*_IGcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 274  : 		return (++(*_IGnext));

  00005	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	40		 inc	 eax
  0000b	89 01		 mov	 DWORD PTR [ecx], eax

; 275  : 		}

  0000d	c3		 ret	 0
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
_TEXT	ENDS
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
; Function compile flags: /Ogtp
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = ecx

; 279  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Gnavail
  00008	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  0000b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000d	99		 cdq

; 280  : 		}

  0000e	c3		 ret	 0
$LN3@Gnavail:

; 279  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 280  : 		}

  00012	c3		 ret	 0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??R?$less@K@std@@QBE_NABK0@Z			; std::less<unsigned long>::operator()
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xfunctional
;	COMDAT ??R?$less@K@std@@QBE_NABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@K@std@@QBE_NABK0@Z PROC			; std::less<unsigned long>::operator(), COMDAT
; _this$ = ecx

; 124  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 125  : 		return (_Left < _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0000b	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0000d	1b c0		 sbb	 eax, eax
  0000f	f7 d8		 neg	 eax

; 126  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??R?$less@K@std@@QBE_NABK0@Z ENDP			; std::less<unsigned long>::operator()
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::allocator<std::pair<unsigned long const ,TokenizerRow> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::allocator<std::pair<unsigned long const ,TokenizerRow> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::allocator<std::pair<unsigned long const ,TokenizerRow> >
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::is_open
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
;	COMDAT ?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::is_open, COMDAT
; _this$ = ecx

; 212  : 		return (_Myfile != 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 54	 cmp	 DWORD PTR [ecx+84], eax
  00005	0f 95 c0	 setne	 al

; 213  : 		}

  00008	c3		 ret	 0
?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::is_open
_TEXT	ENDS
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator==
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 331  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 1911 : 		{	// assign _Count copies of _Ch beginning at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1912 : 		if (_Count == 1)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	83 f8 01	 cmp	 eax, 1
  00009	75 15		 jne	 SHORT $LN2@Chassign

; 1913 : 			_Traits::assign(*(_Myptr() + _Off), _Ch);

  0000b	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0000f	72 02		 jb	 SHORT $LN7@Chassign
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN7@Chassign:
  00013	8a 45 10	 mov	 al, BYTE PTR __Ch$[ebp]
  00016	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00019	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1916 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Chassign:

; 1914 : 		else
; 1915 : 			_Traits::assign(_Myptr() + _Off, _Count, _Ch);

  00020	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00024	72 02		 jb	 SHORT $LN13@Chassign
  00026	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN13@Chassign:
  00028	03 4d 08	 add	 ecx, DWORD PTR __Off$[ebp]
  0002b	50		 push	 eax
  0002c	0f be 45 10	 movsx	 eax, BYTE PTR __Ch$[ebp]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _memset
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1916 : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtp
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1973 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1974 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + this->_Mysize <= _Ptr)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 2d		 je	 SHORT $LN2@Inside
  0000b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0000e	83 fa 10	 cmp	 edx, 16			; 00000010H
  00011	72 04		 jb	 SHORT $LN8@Inside
  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN9@Inside
$LN8@Inside:
  00017	8b c1		 mov	 eax, ecx
$LN9@Inside:
  00019	3b f0		 cmp	 esi, eax
  0001b	72 1b		 jb	 SHORT $LN2@Inside
  0001d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00020	72 04		 jb	 SHORT $LN12@Inside
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN13@Inside
$LN12@Inside:
  00026	8b c1		 mov	 eax, ecx
$LN13@Inside:
  00028	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0002b	03 c8		 add	 ecx, eax
  0002d	3b ce		 cmp	 ecx, esi
  0002f	76 07		 jbe	 SHORT $LN2@Inside

; 1976 : 		else
; 1977 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 1978 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN2@Inside:

; 1975 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 1978 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2016 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
EXTRN	?_Addstd@ios_base@std@@SAXPAV12@@Z:PROC		; std::ios_base::_Addstd
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
CONST	SEGMENT
??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
	DD	08H
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0
__ehfuncinfo$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T155087 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
__Addit$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 54   : 	__CLR_OR_THIS_CALL basic_ostream(_Uninitialized, bool _Addit = true)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002b	33 c0		 xor	 eax, eax
  0002d	89 45 f0	 mov	 DWORD PTR $T155087[ebp], eax
  00030	39 45 10	 cmp	 DWORD PTR _$initVBases$[ebp], eax
  00033	74 17		 je	 SHORT $LN2@basic_ostr
  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
  0003b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  00042	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  00045	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T155087[ebp], 1
$LN2@basic_ostr:
  0004c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00051	c7 04 16 00 00
	00 00		 mov	 DWORD PTR [esi+edx], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@

; 55   : 		{	// construct uninitialized
; 56   : 		if (_Addit)

  00058	38 45 0c	 cmp	 BYTE PTR __Addit$[ebp], al
  0005b	74 10		 je	 SHORT $LN13@basic_ostr

; 57   : 			ios_base::_Addstd(this);	// suppress for basic_iostream

  0005d	8b 06		 mov	 eax, DWORD PTR [esi]
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	03 c6		 add	 eax, esi
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  0006a	83 c4 04	 add	 esp, 4
$LN13@basic_ostr:

; 58   : 		}

  0006d	8b c6		 mov	 eax, esi
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	5e		 pop	 esi
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T155087[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN8@basic_ostr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T155087[ebp], -2 ; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 08	 add	 ecx, 8
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN8@basic_ostr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 74   : 		return (_Tiestr);

  00000	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]

; 75   : 		}

  00003	c3		 ret	 0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
PUBLIC	?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ; std::basic_streambuf<char,std::char_traits<char> >::getloc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
$T155117 = -4						; size = 4
__Lock$155130 = 8					; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::getloc, COMDAT
; _this$ = ecx

; 129  : 		{	// get locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 130  : 		return (*_Plocale);

  00004	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00007	56		 push	 esi
  00008	8b 30		 mov	 esi, DWORD PTR [eax]
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	6a 00		 push	 0
  00010	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$155130[ebp]
  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T155117[ebp], 0
  0001a	89 37		 mov	 DWORD PTR [edi], esi
  0001c	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00021	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00024	83 f8 ff	 cmp	 eax, -1
  00027	73 04		 jae	 SHORT $LN7@getloc@2
  00029	40		 inc	 eax
  0002a	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN7@getloc@2:
  0002d	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$155130[ebp]
  00030	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00035	8b c7		 mov	 eax, edi
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 131  : 		}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::getloc
_TEXT	ENDS
PUBLIC	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
; Function compile flags: /Ogtp
;	COMDAT ?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setg, COMDAT
; _this$ = ecx

; 248  : 		{	// set pointers for read buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 249  : 		*_IGfirst = _First;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00009	89 10		 mov	 DWORD PTR [eax], edx

; 250  : 		*_IGnext = _Next;

  0000b	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Next$[ebp]
  00011	89 02		 mov	 DWORD PTR [edx], eax

; 251  : 		*_IGcount = (int)(_Last - _Next);

  00013	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00016	2b d0		 sub	 edx, eax
  00018	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0001b	89 10		 mov	 DWORD PTR [eax], edx

; 252  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 0c 00	 ret	 12			; 0000000cH
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setg
_TEXT	ENDS
PUBLIC	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z ; std::basic_streambuf<char,std::char_traits<char> >::_Init
; Function compile flags: /Ogtp
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z
_TEXT	SEGMENT
__Gf$ = 8						; size = 4
__Gn$ = 12						; size = 4
__Gc$ = 16						; size = 4
__Pf$ = 20						; size = 4
__Pn$ = 24						; size = 4
__Pc$ = 28						; size = 4
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 327  : 		{	// initialize buffer parameters as specified

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 328  : 		_IGfirst = _Gf;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Gf$[ebp]

; 329  : 		_IPfirst = _Pf;

  00006	8b 55 14	 mov	 edx, DWORD PTR __Pf$[ebp]
  00009	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 330  : 		_IGnext = _Gn;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Gn$[ebp]
  0000f	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 331  : 		_IPnext = _Pn;

  00012	8b 55 18	 mov	 edx, DWORD PTR __Pn$[ebp]
  00015	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 332  : 		_IGcount = _Gc;

  00018	8b 45 10	 mov	 eax, DWORD PTR __Gc$[ebp]
  0001b	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 333  : 		_IPcount = _Pc;

  0001e	8b 55 1c	 mov	 edx, DWORD PTR __Pc$[ebp]
  00021	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  00024	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 334  : 		}

  00027	5d		 pop	 ebp
  00028	c2 18 00	 ret	 24			; 00000018H
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Myval
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator*, COMDAT
; _this$ = ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator*
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerRow@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Myval
; Function compile flags: /Ogtp
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerRow@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerRow@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerRow@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::allocator<std::pair<unsigned long const ,TokenizerRow> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::allocator<std::pair<unsigned long const ,TokenizerRow> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::allocator<std::pair<unsigned long const ,TokenizerRow> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerSection@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Myval
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerSection@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerSection@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBKVTokenizerSection@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerSection@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerSection@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerSection@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerSection@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ PROC ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*, COMDAT
; _this$ = ecx

; 71   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 72   : 		if (this->_Getcont() == 0
; 73   : 			|| this->_Ptr == 0
; 74   : 			|| this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 75   : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 76   : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 77   : 			{	// report error
; 78   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 79   : 			_SCL_SECURE_OUT_OF_RANGE;
; 80   : 			}
; 81   : 
; 82   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 83   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 84   : 		_SCL_SECURE_VALIDATE_RANGE(
; 85   : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr
; 86   : 			&& this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 87   : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 88   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 89   : 
; 90   : 		__analysis_assume(this->_Ptr != 0);
; 91   : 
; 92   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 93   : 		}

  00002	c3		 ret	 0
??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerRow@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerRow@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerRow@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBKVTokenizerRow@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z	; std::codecvt<char,char,int>::unshift
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__First2$ = 12						; size = 4
__Last2$ = 16						; size = 4
__Mid2$ = 20						; size = 4
?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z PROC	; std::codecvt<char,char,int>::unshift, COMDAT
; _this$ = ecx

; 823  : 		{	// generate bytes to return to default shift state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 824  : 		return (do_unshift(_State, _First2, _Last2, _Mid2));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 825  : 		}

  00008	5d		 pop	 ebp

; 824  : 		return (do_unshift(_State, _First2, _Last2, _Mid2));

  00009	ff e0		 jmp	 eax
?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z ENDP	; std::codecvt<char,char,int>::unshift
_TEXT	ENDS
PUBLIC	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setp, COMDAT
; _this$ = ecx

; 289  : 		{	// set pointers for write buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 290  : 		*_IPfirst = _First;

  00003	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 02		 mov	 DWORD PTR [edx], eax

; 291  : 		*_IPnext = _First;

  0000b	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 292  : 		*_IPcount = (int)(_Last - _First);

  00010	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00013	2b d0		 sub	 edx, eax
  00015	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00018	89 10		 mov	 DWORD PTR [eax], edx

; 293  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setp
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::size, COMDAT
; _this$ = ecx

; 869  : 		return (this->_Mysize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 870  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::size
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Color
; Function compile flags: /Ogtp
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		return ((char&)(*_Pnode)._Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 2c	 add	 eax, 44			; 0000002cH

; 608  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Isnil
; Function compile flags: /Ogtp
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 2d	 add	 eax, 45			; 0000002dH

; 613  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Left
; Function compile flags: /Ogtp
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Parent
; Function compile flags: /Ogtp
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 628  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Right
; Function compile flags: /Ogtp
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 633  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max
; Function compile flags: /Ogtp
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0000d	75 0c		 jne	 SHORT $LN1@Max
  0000f	90		 npad	 1
$LL2@Max:

; 643  : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN1@Max:

; 644  : 		return (_Pnode);
; 645  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min
; Function compile flags: /Ogtp
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0000c	75 0c		 jne	 SHORT $LN1@Min
  0000e	8b ff		 npad	 2
$LL2@Min:

; 650  : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00018	74 f6		 je	 SHORT $LL2@Min
$LN1@Min:

; 651  : 		return (_Pnode);
; 652  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min
_TEXT	ENDS
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 336  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::size, COMDAT
; _this$ = ecx

; 869  : 		return (this->_Mysize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 870  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::size
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Color
; Function compile flags: /Ogtp
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		return ((char&)(*_Pnode)._Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 24	 add	 eax, 36			; 00000024H

; 608  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Isnil
; Function compile flags: /Ogtp
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 25	 add	 eax, 37			; 00000025H

; 613  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Left
; Function compile flags: /Ogtp
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Parent
; Function compile flags: /Ogtp
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 628  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Right
; Function compile flags: /Ogtp
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 633  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Max
; Function compile flags: /Ogtp
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000d	75 0c		 jne	 SHORT $LN1@Max@2
  0000f	90		 npad	 1
$LL2@Max@2:

; 643  : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00019	74 f5		 je	 SHORT $LL2@Max@2
$LN1@Max@2:

; 644  : 		return (_Pnode);
; 645  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Min
; Function compile flags: /Ogtp
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000c	75 0c		 jne	 SHORT $LN1@Min@2
  0000e	8b ff		 npad	 2
$LL2@Min@2:

; 650  : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00018	74 f6		 je	 SHORT $LL2@Min@2
$LN1@Min@2:

; 651  : 		return (_Pnode);
; 652  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Isnil
; Function compile flags: /Ogtp
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 25	 add	 eax, 37			; 00000025H

; 613  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Left
; Function compile flags: /Ogtp
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Right
; Function compile flags: /Ogtp
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 633  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Right
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 50   : 	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 51   : 		{	// construct with pointer _Parg
; 52   : 		this->_Adopt(_Pstring);
; 53   : 		this->_Ptr = _Parg;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 54   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator!=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 336  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 220  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@K@1@@Z ; std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@K@1@@Z PROC ; std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 41   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@K@1@@Z ENDP ; std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z ; std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z PROC ; std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 41   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z ENDP ; std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Parent
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 628  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::key_comp
; Function compile flags: /Ogtp
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::key_comp, COMDAT
; _this$ = ecx

; 888  : 		{	// return object for comparing keys

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 889  : 		return (this->comp);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 890  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?key_comp@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::key_comp
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 10		 mov	 edx, DWORD PTR [eax]
  00004	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00008	75 40		 jne	 SHORT $LN3@operator@2

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0000d	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00011	75 1a		 jne	 SHORT $LN34@operator@2

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00019	75 0f		 jne	 SHORT $LN17@operator@2
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator@2:
  00020	8b ca		 mov	 ecx, edx
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00028	74 f6		 je	 SHORT $LL18@operator@2
$LN17@operator@2:
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0002c	c3		 ret	 0
$LN34@operator@2:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00030	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00034	75 12		 jne	 SHORT $LN1@operator@2
$LL2@operator@2:
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0003b	75 0b		 jne	 SHORT $LN1@operator@2

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003d	89 10		 mov	 DWORD PTR [eax], edx
  0003f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00042	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00046	74 ee		 je	 SHORT $LL2@operator@2
$LN1@operator@2:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00048	89 10		 mov	 DWORD PTR [eax], edx
$LN3@operator@2:

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0004a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::key_comp
; Function compile flags: /Ogtp
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 888  : 		{	// return object for comparing keys

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 889  : 		return (this->comp);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 890  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?key_comp@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 10		 mov	 edx, DWORD PTR [eax]
  00004	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00008	75 40		 jne	 SHORT $LN3@operator@3

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0000d	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00011	75 1a		 jne	 SHORT $LN34@operator@3

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00019	75 0f		 jne	 SHORT $LN17@operator@3
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator@3:
  00020	8b ca		 mov	 ecx, edx
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00028	74 f6		 je	 SHORT $LL18@operator@3
$LN17@operator@3:
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0002c	c3		 ret	 0
$LN34@operator@3:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00030	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00034	75 12		 jne	 SHORT $LN1@operator@3
$LL2@operator@3:
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0003b	75 0b		 jne	 SHORT $LN1@operator@3

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003d	89 10		 mov	 DWORD PTR [eax], edx
  0003f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00042	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00046	74 ee		 je	 SHORT $LL2@operator@3
$LN1@operator@3:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00048	89 10		 mov	 DWORD PTR [eax], edx
$LN3@operator@3:

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0004a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$move@AAK@std@@YA$$QAKAAK@Z			; std::move<unsigned long &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAK@std@@YA$$QAKAAK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAK@std@@YA$$QAKAAK@Z PROC			; std::move<unsigned long &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAK@std@@YA$$QAKAAK@Z ENDP			; std::move<unsigned long &>
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBKVTokenizerRow@@@?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>::_Kfn<unsigned long const ,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??$_Kfn@$$CBKVTokenizerRow@@@?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBKVTokenizerRow@@@?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerRow@@@1@@Z PROC ; std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>::_Kfn<unsigned long const ,TokenizerRow>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBKVTokenizerRow@@@?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerRow@@@1@@Z ENDP ; std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0>::_Kfn<unsigned long const ,TokenizerRow>
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBKVTokenizerSection@@@?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerSection@@@1@@Z ; std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>::_Kfn<unsigned long const ,TokenizerSection>
; Function compile flags: /Ogtp
;	COMDAT ??$_Kfn@$$CBKVTokenizerSection@@@?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerSection@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBKVTokenizerSection@@@?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerSection@@@1@@Z PROC ; std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>::_Kfn<unsigned long const ,TokenizerSection>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBKVTokenizerSection@@@?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKVTokenizerSection@@@1@@Z ENDP ; std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0>::_Kfn<unsigned long const ,TokenizerSection>
_TEXT	ENDS
PUBLIC	??$move@AAVTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z ; std::move<TokenizerSection &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAVTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAVTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z PROC ; std::move<TokenizerSection &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAVTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z ENDP ; std::move<TokenizerSection &>
_TEXT	ENDS
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
PUBLIC	??$move@AAVTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z ; std::move<TokenizerRow &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAVTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAVTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z PROC ; std::move<TokenizerRow &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAVTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z ENDP ; std::move<TokenizerRow &>
_TEXT	ENDS
PUBLIC	??$addressof@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z ; std::addressof<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z PROC ; std::addressof<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node><std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
;	COMDAT ??$?0U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node><std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node><std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T155440 = -12						; size = 12
$T155445 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 43		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 55 55 55
	05		 cmp	 ecx, 89478485		; 05555555H
  00015	77 13		 ja	 SHORT $LN1@Allocate
  00017	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0001a	c1 e0 04	 shl	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00028	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002a	8d 4d 08	 lea	 ecx, DWORD PTR $T155445[ebp]
  0002d	51		 push	 ecx
  0002e	8d 4d f4	 lea	 ecx, DWORD PTR $T155440[ebp]
  00031	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T155445[ebp], 0
  00038	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003d	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00042	8d 55 f4	 lea	 edx, DWORD PTR $T155440[ebp]
  00045	52		 push	 edx
  00046	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T155440[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$addressof@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z ; std::addressof<std::pair<unsigned long const ,TokenizerRow> >
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z PROC ; std::addressof<std::pair<unsigned long const ,TokenizerRow> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<unsigned long const ,TokenizerRow> >
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node><std::pair<unsigned long const ,TokenizerRow> >
; Function compile flags: /Ogtp
;	COMDAT ??$?0U?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node><std::pair<unsigned long const ,TokenizerRow> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node><std::pair<unsigned long const ,TokenizerRow> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T155455 = -12						; size = 12
$T155459 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 46		 je	 SHORT $LN5@Allocate@2

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 66 66 66
	06		 cmp	 ecx, 107374182		; 06666666H
  00015	77 16		 ja	 SHORT $LN1@Allocate@2
  00017	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0002b	75 28		 jne	 SHORT $LN5@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T155459[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T155455[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T155459[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T155455[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T155455[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:

; 40   : 	}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN9@Allocate@2:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T155464 = -12						; size = 12
$T155468 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3a		 je	 SHORT $LN5@Allocate@3

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	83 f9 ff	 cmp	 ecx, -1
  00012	77 0d		 ja	 SHORT $LN1@Allocate@3
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0001f	75 28		 jne	 SHORT $LN5@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00021	8d 45 08	 lea	 eax, DWORD PTR $T155468[ebp]
  00024	50		 push	 eax
  00025	8d 4d f4	 lea	 ecx, DWORD PTR $T155464[ebp]
  00028	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T155468[ebp], 0
  0002f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00034	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00039	8d 4d f4	 lea	 ecx, DWORD PTR $T155464[ebp]
  0003c	51		 push	 ecx
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T155464[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00044	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@3:
$LN5@Allocate@3:

; 40   : 	}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN9@Allocate@3:
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::size, COMDAT
; _this$ = ecx

; 869  : 		return (this->_Mysize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 870  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::size
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rmost
; Function compile flags: /Ogtp
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00008	74 06		 je	 SHORT $LN8@operator@4

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0000f	c3		 ret	 0
$LN8@operator@4:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00016	75 17		 jne	 SHORT $LN40@operator@4

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  00018	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001b	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0001f	75 30		 jne	 SHORT $LN21@operator@4
$LL22@operator@4:
  00021	8b d1		 mov	 edx, ecx
  00023	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00026	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0002a	74 f5		 je	 SHORT $LL22@operator@4

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0002e	c3		 ret	 0
$LN40@operator@4:

; 89   : 		else
; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00036	75 11		 jne	 SHORT $LN3@operator@4
$LL4@operator@4:
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0003c	75 0b		 jne	 SHORT $LN3@operator@4

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  0003e	89 10		 mov	 DWORD PTR [eax], edx
  00040	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00043	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0
  00047	74 ef		 je	 SHORT $LL4@operator@4
$LN3@operator@4:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0004f	75 02		 jne	 SHORT $LN1@operator@4

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

$LN21@operator@4:

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00051	89 10		 mov	 DWORD PTR [eax], edx
$LN1@operator@4:

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00053	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lmost
; Function compile flags: /Ogtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Color
; Function compile flags: /Ogtp
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		return ((char&)(*_Pnode)._Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 24	 add	 eax, 36			; 00000024H

; 608  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00008	74 06		 je	 SHORT $LN8@operator@5

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0000f	c3		 ret	 0
$LN8@operator@5:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00016	75 17		 jne	 SHORT $LN40@operator@5

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  00018	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001b	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0001f	75 30		 jne	 SHORT $LN21@operator@5
$LL22@operator@5:
  00021	8b d1		 mov	 edx, ecx
  00023	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00026	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0002a	74 f5		 je	 SHORT $LL22@operator@5

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0002e	c3		 ret	 0
$LN40@operator@5:

; 89   : 		else
; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00036	75 11		 jne	 SHORT $LN3@operator@5
$LL4@operator@5:
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0003c	75 0b		 jne	 SHORT $LN3@operator@5

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  0003e	89 10		 mov	 DWORD PTR [eax], edx
  00040	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00043	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00047	74 ef		 je	 SHORT $LL4@operator@5
$LN3@operator@5:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0004f	75 02		 jne	 SHORT $LN1@operator@5

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

$LN21@operator@5:

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00051	89 10		 mov	 DWORD PTR [eax], edx
$LN1@operator@5:

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00053	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
PUBLIC	?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z	; std::codecvt<char,char,int>::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z PROC	; std::codecvt<char,char,int>::_Init, COMDAT
; _this$ = ecx

; 863  : 		}

  00000	c2 04 00	 ret	 4
?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z ENDP	; std::codecvt<char,char,int>::_Init
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::max_size
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Max
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000d	75 0c		 jne	 SHORT $LN1@Max@3
  0000f	90		 npad	 1
$LL2@Max@3:

; 643  : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00019	74 f5		 je	 SHORT $LL2@Max@3
$LN1@Max@3:

; 644  : 		return (_Pnode);
; 645  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Min
; Function compile flags: /Ogtp
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000c	75 0c		 jne	 SHORT $LN1@Min@3
  0000e	8b ff		 npad	 2
$LL2@Min@3:

; 650  : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00018	74 f6		 je	 SHORT $LL2@Min@3
$LN1@Min@3:

; 651  : 		return (_Pnode);
; 652  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::max_size
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@KVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@KVTokenizerRow@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long,TokenizerRow> >
; Function compile flags: /Ogtp
;	COMDAT ??$forward@U?$pair@KVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@KVTokenizerRow@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@KVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@KVTokenizerRow@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long,TokenizerRow> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@KVTokenizerRow@@@std@@@std@@YA$$QAU?$pair@KVTokenizerRow@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long,TokenizerRow> >
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long const ,TokenizerSection> >
; Function compile flags: /Ogtp
;	COMDAT ??$forward@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long const ,TokenizerSection> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YA$$QAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long const ,TokenizerSection> >
_TEXT	ENDS
PUBLIC	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator==<char,char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 263  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 264  : 	}

  00002	c3		 ret	 0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
PUBLIC	??$forward@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
_TEXT	ENDS
PUBLIC	??$forward@AAU?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAAAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long const ,TokenizerRow> &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAU?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAAAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAAAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long const ,TokenizerRow> &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAAAU?$pair@$$CBKVTokenizerRow@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long const ,TokenizerRow> &>
_TEXT	ENDS
PUBLIC	??$addressof@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z ; std::addressof<std::pair<unsigned long const ,TokenizerSection> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z PROC ; std::addressof<std::pair<unsigned long const ,TokenizerSection> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAPAU?$pair@$$CBKVTokenizerSection@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<unsigned long const ,TokenizerSection> >
_TEXT	ENDS
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &>
_TEXT	ENDS
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
_TEXT	ENDS
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &>
_TEXT	ENDS
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T155724 = -12						; size = 12
$T155728 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 46		 je	 SHORT $LN5@Allocate@4

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 66 66 66
	06		 cmp	 ecx, 107374182		; 06666666H
  00015	77 16		 ja	 SHORT $LN1@Allocate@4
  00017	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0002b	75 28		 jne	 SHORT $LN5@Allocate@4
$LN1@Allocate@4:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T155728[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T155724[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T155728[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T155724[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T155724[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@4:
$LN5@Allocate@4:

; 40   : 	}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN9@Allocate@4:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$forward@$$CBK@std@@YA$$QBKABK@Z		; std::forward<unsigned long const >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@$$CBK@std@@YA$$QBKABK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@$$CBK@std@@YA$$QBKABK@Z PROC			; std::forward<unsigned long const >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@$$CBK@std@@YA$$QBKABK@Z ENDP			; std::forward<unsigned long const >
_TEXT	ENDS
PUBLIC	??$forward@VTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z ; std::forward<TokenizerSection>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@VTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@VTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z PROC ; std::forward<TokenizerSection>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@VTokenizerSection@@@std@@YA$$QAVTokenizerSection@@AAV1@@Z ENDP ; std::forward<TokenizerSection>
_TEXT	ENDS
PUBLIC	??$move@ABK@std@@YA$$QBKABK@Z			; std::move<unsigned long const &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@ABK@std@@YA$$QBKABK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@ABK@std@@YA$$QBKABK@Z PROC			; std::move<unsigned long const &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@ABK@std@@YA$$QBKABK@Z ENDP			; std::move<unsigned long const &>
_TEXT	ENDS
PUBLIC	??$forward@K@std@@YA$$QAKAAK@Z			; std::forward<unsigned long>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@K@std@@YA$$QAKAAK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@K@std@@YA$$QAKAAK@Z PROC			; std::forward<unsigned long>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@K@std@@YA$$QAKAAK@Z ENDP			; std::forward<unsigned long>
_TEXT	ENDS
PUBLIC	??$forward@VTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z ; std::forward<TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@VTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@VTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z PROC ; std::forward<TokenizerRow>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@VTokenizerRow@@@std@@YA$$QAVTokenizerRow@@AAV1@@Z ENDP ; std::forward<TokenizerRow>
_TEXT	ENDS
PUBLIC	??$forward@ABK@std@@YAABKABK@Z			; std::forward<unsigned long const &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@ABK@std@@YAABKABK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABK@std@@YAABKABK@Z PROC			; std::forward<unsigned long const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABK@std@@YAABKABK@Z ENDP			; std::forward<unsigned long const &>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
PUBLIC	??$forward@AAVTokenizerRow@@@std@@YAAAVTokenizerRow@@AAV1@@Z ; std::forward<TokenizerRow &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAVTokenizerRow@@@std@@YAAAVTokenizerRow@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAVTokenizerRow@@@std@@YAAAVTokenizerRow@@AAV1@@Z PROC ; std::forward<TokenizerRow &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAVTokenizerRow@@@std@@YAAAVTokenizerRow@@AAV1@@Z ENDP ; std::forward<TokenizerRow &>
_TEXT	ENDS
PUBLIC	?IsEnableToTrade@CItemBlock@@QAE_NPAUOBJECTSTRUCT@@@Z ; CItemBlock::IsEnableToTrade
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itemblock.cpp
;	COMDAT ?IsEnableToTrade@CItemBlock@@QAE_NPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_bTrade$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?IsEnableToTrade@CItemBlock@@QAE_NPAUOBJECTSTRUCT@@@Z PROC ; CItemBlock::IsEnableToTrade, COMDAT
; _this$ = ecx

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 28   : 	BOOL bTrade = 1;

  00007	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0000a	8b d9		 mov	 ebx, ecx
  0000c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bTrade$[ebp], 1
  00013	33 f6		 xor	 esi, esi
  00015	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL5@IsEnableTo:

; 31   : 	{
; 32   : 		if(lpObj->Trade[n].IsItem() == 1)

  00020	8b 8f b4 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3252]
  00026	03 ce		 add	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	83 f8 01	 cmp	 eax, 1
  00030	75 1b		 jne	 SHORT $LN4@IsEnableTo

; 33   : 		{
; 34   : 			if(this->IsCheckItem(&lpObj->Trade[n]) == 1)

  00032	8b 87 b4 0c 00
	00		 mov	 eax, DWORD PTR [edi+3252]
  00038	03 c6		 add	 eax, esi
  0003a	50		 push	 eax
  0003b	8b cb		 mov	 ecx, ebx
  0003d	e8 00 00 00 00	 call	 ?IsCheckItem@CItemBlock@@QAE_NPAVCItem@@@Z ; CItemBlock::IsCheckItem
  00042	3c 01		 cmp	 al, 1
  00044	75 07		 jne	 SHORT $LN4@IsEnableTo

; 35   : 			{
; 36   : 				bTrade = 0;

  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bTrade$[ebp], 0
$LN4@IsEnableTo:

; 29   : 	// ---
; 30   : 	for(int n = 0; n < TRADE_BOX_SIZE; n++)

  0004d	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00053	81 fe 00 15 00
	00		 cmp	 esi, 5376		; 00001500H
  00059	7c c5		 jl	 SHORT $LL5@IsEnableTo

; 37   : 			}
; 38   : 		}
; 39   : 	}
; 40   : 	// ---
; 41   : 	return bTrade;

  0005b	83 7d fc 00	 cmp	 DWORD PTR _bTrade$[ebp], 0
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	0f 95 c0	 setne	 al
  00064	5b		 pop	 ebx

; 42   : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?IsEnableToTrade@CItemBlock@@QAE_NPAUOBJECTSTRUCT@@@Z ENDP ; CItemBlock::IsEnableToTrade
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >, COMDAT
; _this$ = ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 556  : 		}

  0000a	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 483  : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
_TEXT	ENDS
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 336  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN7@scalar@8
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN7@scalar@8:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?c_str@locale@std@@QBEPBDXZ			; std::locale::c_str
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ?c_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@locale@std@@QBEPBDXZ PROC			; std::locale::c_str, COMDAT
; _this$ = ecx

; 432  : 		return (_Ptr->_Name.c_str());

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00005	85 c0		 test	 eax, eax
  00007	75 03		 jne	 SHORT $LN6@c_str@2
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN6@c_str@2:

; 433  : 		}

  0000c	c3		 ret	 0
?c_str@locale@std@@QBEPBDXZ ENDP			; std::locale::c_str
_TEXT	ENDS
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z		; std::ctype<char>::ctype<char>
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
CONST	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T155817 = -16						; size = 16
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 2365 : 		{	// construct from current locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx

; 2366 : 		_Init(_Lobj);

  0000c	8d 4d f0	 lea	 ecx, DWORD PTR $T155817[ebp]
  0000f	51		 push	 ecx
  00010	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  00019	e8 00 00 00 00	 call	 __Getctype
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00023	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00026	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00029	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0002c	89 56 10	 mov	 DWORD PTR [esi+16], edx
  0002f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00032	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00035	83 c4 04	 add	 esp, 4

; 2367 : 		}

  00038	8b c6		 mov	 eax, esi
  0003a	5e		 pop	 esi
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
_TEXT	ENDS
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2405 : 		if (0 < _Ctype._Delfl)

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	85 c0		 test	 eax, eax
  00005	7e 0d		 jle	 SHORT $LN6@Tidy@2

; 2406 : 			free((void *)_Ctype._Table);

  00007	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _free
  00010	83 c4 04	 add	 esp, 4

; 2409 : 		}

  00013	c3		 ret	 0
$LN6@Tidy@2:

; 2407 : 		else if (_Ctype._Delfl < 0)

  00014	79 0a		 jns	 SHORT $LN1@Tidy@2

; 2408 : 			delete[] (void *)_Ctype._Table;

  00016	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001f	59		 pop	 ecx
$LN1@Tidy@2:

; 2409 : 		}

  00020	c3		 ret	 0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
EXTRN	__Tolower:PROC
; Function compile flags: /Ogtp
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2412 : 		{	// convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2413 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00007	83 c1 08	 add	 ecx, 8
  0000a	51		 push	 ecx
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Tolower
  00011	83 c4 08	 add	 esp, 8

; 2414 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2418 : 		{	// convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2419 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2420 : 		for (; _First != _Last; ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 19		 je	 SHORT $LN8@do_tolower
  0000f	57		 push	 edi
  00010	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
$LL3@do_tolower:

; 2421 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

  00013	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00016	57		 push	 edi
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 __Tolower
  0001d	88 06		 mov	 BYTE PTR [esi], al
  0001f	46		 inc	 esi
  00020	83 c4 08	 add	 esp, 8
  00023	3b f3		 cmp	 esi, ebx
  00025	75 ec		 jne	 SHORT $LL3@do_tolower
  00027	5f		 pop	 edi
$LN8@do_tolower:

; 2422 : 		return ((const _Elem *)_First);

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx

; 2423 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
EXTRN	__Toupper:PROC
; Function compile flags: /Ogtp
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2426 : 		{	// convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2427 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00007	83 c1 08	 add	 ecx, 8
  0000a	51		 push	 ecx
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Toupper
  00011	83 c4 08	 add	 esp, 8

; 2428 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2432 : 		{	// convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2433 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2434 : 		for (; _First != _Last; ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 19		 je	 SHORT $LN8@do_toupper
  0000f	57		 push	 edi
  00010	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
$LL3@do_toupper:

; 2435 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

  00013	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00016	57		 push	 edi
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 __Toupper
  0001d	88 06		 mov	 BYTE PTR [esi], al
  0001f	46		 inc	 esi
  00020	83 c4 08	 add	 esp, 8
  00023	3b f3		 cmp	 esi, ebx
  00025	75 ec		 jne	 SHORT $LL3@do_toupper
  00027	5f		 pop	 edi
$LN8@do_toupper:

; 2436 : 		return ((const _Elem *)_First);

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx

; 2437 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2440 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2441 : 		return (_Byte);

  00003	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]

; 2442 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2446 : 		{	// widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2447 : 		_DEBUG_RANGE(_First, _Last);
; 2448 : 		_DEBUG_POINTER(_Dest);
; 2449 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	8b ce		 mov	 ecx, esi
  0000f	2b c8		 sub	 ecx, eax
  00011	51		 push	 ecx
  00012	50		 push	 eax
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _memcpy
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2450 : 		return (_Last);

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi

; 2451 : 		}

  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2454 : 		{	// narrow char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2455 : 		return (_Ch);

  00003	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]

; 2456 : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2460 : 		{	// narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2461 : 		_DEBUG_RANGE(_First, _Last);
; 2462 : 		_DEBUG_POINTER(_Dest);
; 2463 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 14	 mov	 edx, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	8b ce		 mov	 ecx, esi
  0000f	2b c8		 sub	 ecx, eax
  00011	51		 push	 ecx
  00012	50		 push	 eax
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _memcpy
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2464 : 		return (_Last);

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi

; 2465 : 		}

  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
; Function compile flags: /Ogtp
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2394 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2395 : 		_Tidy();

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0000c	85 c0		 test	 eax, eax
  0000e	7e 14		 jle	 SHORT $LN14@ctype
  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _free
  00019	83 c4 04	 add	 esp, 4

; 2396 : 		}

  0001c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00022	5e		 pop	 esi
  00023	c3		 ret	 0
$LN14@ctype:

; 2395 : 		_Tidy();

  00024	79 0c		 jns	 SHORT $LN13@ctype
  00026	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002f	83 c4 04	 add	 esp, 4
$LN13@ctype:

; 2396 : 		}

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00038	5e		 pop	 esi
  00039	c3		 ret	 0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0000f	85 c0		 test	 eax, eax
  00011	7e 0b		 jle	 SHORT $LN16@scalar@9
  00013	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _free
  0001c	eb 0b		 jmp	 SHORT $LN17@scalar@9
$LN16@scalar@9:
  0001e	79 0c		 jns	 SHORT $LN6@scalar@9
  00020	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
$LN17@scalar@9:
  00029	83 c4 04	 add	 esp, 4
$LN6@scalar@9:
  0002c	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00036	74 09		 je	 SHORT $LN15@scalar@9
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
$LN15@scalar@9:
  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\system_error
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
_DATA	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
__Errcode$ = 8						; size = 8
$T155911 = 16						; size = 4
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 516  : 		{	// construct from error code and message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 10	 mov	 eax, DWORD PTR __Message$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8d 4d 10	 lea	 ecx, DWORD PTR $T155911[ebp]
  0000c	51		 push	 ecx
  0000d	8b ce		 mov	 ecx, esi
  0000f	89 45 10	 mov	 DWORD PTR $T155911[ebp], eax
  00012	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00017	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp+4]
  0001a	8b 55 08	 mov	 edx, DWORD PTR __Errcode$[ebp]
  0001d	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@
  00026	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 517  : 		_Makestr();
; 518  : 		}

  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN10@scalar@10
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN10@scalar@10:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
CONST	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
$T155937 = 12						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 237  : 			{	// construct with message

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00006	53		 push	 ebx
  00007	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 38		 mov	 edi, DWORD PTR [eax]
  00010	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00013	8d 4d 0c	 lea	 ecx, DWORD PTR $T155937[ebp]
  00016	51		 push	 ecx
  00017	8b ce		 mov	 ecx, esi
  00019	89 45 0c	 mov	 DWORD PTR $T155937[ebp], eax
  0001c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00021	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00024	5f		 pop	 edi
  00025	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@

; 238  : 			}

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
_TEXT	ENDS
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
; Function compile flags: /Ogtp
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ ; `string'
PUBLIC	__TI4?AVfailure@ios_base@std@@
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@	; `string'
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	__CTA4?AVfailure@ios_base@std@@
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\system_error
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT __CTA4?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA4?AVfailure@ios_base@std@@ DD 04H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ DB 'ios_base::failbit se'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT __TI4?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI4?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA4?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ DB 'ios_base::badbit set', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
CONST	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T155969 = -20						; size = 20
$T155967 = -20						; size = 20
$T155965 = -20						; size = 20
__State$ = 8						; size = 4
$T156060 = 12						; size = 4
$T156024 = 12						; size = 4
$T155988 = 12						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 310  : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  : 		_Mystate = (iostate)(_State & _Statmask);

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	83 e0 17	 and	 eax, 23			; 00000017H
  00009	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 312  : 		if ((_Mystate & _Except) == 0)

  0000c	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000f	83 ec 14	 sub	 esp, 20			; 00000014H
  00012	23 c8		 and	 ecx, eax
  00014	0f 84 bd 00 00
	00		 je	 $LN1@clear

; 313  : 			;
; 314  : 		else if (_Reraise)

  0001a	80 7d 0c 00	 cmp	 BYTE PTR __Reraise$[ebp], 0
  0001e	74 09		 je	 SHORT $LN6@clear

; 315  : 			_RERAISE;

  00020	6a 00		 push	 0
  00022	6a 00		 push	 0
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN57@clear:
$LN6@clear:

; 316  : 		else if (_Mystate & _Except & badbit)
; 317  : 			_THROW_NCEE(failure, "ios_base::badbit set");

  00029	be 01 00 00 00	 mov	 esi, 1
  0002e	f6 c1 04	 test	 cl, 4
  00031	74 35		 je	 SHORT $LN4@clear
  00033	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  00038	8b f8		 mov	 edi, eax
  0003a	8d 45 0c	 lea	 eax, DWORD PTR $T155988[ebp]
  0003d	50		 push	 eax
  0003e	8d 4d ec	 lea	 ecx, DWORD PTR $T155965[ebp]
  00041	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR $T155988[ebp], OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  00048	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0004d	68 00 00 00 00	 push	 OFFSET __TI4?AVfailure@ios_base@std@@
  00052	8d 4d ec	 lea	 ecx, DWORD PTR $T155965[ebp]
  00055	51		 push	 ecx
  00056	89 75 f8	 mov	 DWORD PTR $T155965[ebp+12], esi
  00059	89 7d fc	 mov	 DWORD PTR $T155965[ebp+16], edi
  0005c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T155965[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00063	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN58@clear:
$LN4@clear:

; 318  : 		else if (_Mystate & _Except & failbit)

  00068	f6 c1 02	 test	 cl, 2
  0006b	74 35		 je	 SHORT $LN2@clear

; 319  : 			_THROW_NCEE(failure, "ios_base::failbit set");

  0006d	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  00072	8d 55 0c	 lea	 edx, DWORD PTR $T156024[ebp]
  00075	52		 push	 edx
  00076	8d 4d ec	 lea	 ecx, DWORD PTR $T155967[ebp]
  00079	8b f8		 mov	 edi, eax
  0007b	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR $T156024[ebp], OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  00082	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00087	68 00 00 00 00	 push	 OFFSET __TI4?AVfailure@ios_base@std@@
  0008c	8d 45 ec	 lea	 eax, DWORD PTR $T155967[ebp]
  0008f	50		 push	 eax
  00090	89 75 f8	 mov	 DWORD PTR $T155967[ebp+12], esi
  00093	89 7d fc	 mov	 DWORD PTR $T155967[ebp+16], edi
  00096	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T155967[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  0009d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN59@clear:
$LN2@clear:

; 320  : 		else
; 321  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

  000a2	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  000a7	8d 4d 0c	 lea	 ecx, DWORD PTR $T156060[ebp]
  000aa	51		 push	 ecx
  000ab	8d 4d ec	 lea	 ecx, DWORD PTR $T155969[ebp]
  000ae	8b f8		 mov	 edi, eax
  000b0	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR $T156060[ebp], OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000b7	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000bc	68 00 00 00 00	 push	 OFFSET __TI4?AVfailure@ios_base@std@@
  000c1	8d 55 ec	 lea	 edx, DWORD PTR $T155969[ebp]
  000c4	52		 push	 edx
  000c5	89 75 f8	 mov	 DWORD PTR $T155969[ebp+12], esi
  000c8	89 7d fc	 mov	 DWORD PTR $T155969[ebp+16], edi
  000cb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T155969[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000d2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN60@clear:
$LN1@clear:

; 322  : 		}

  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c2 08 00	 ret	 8
$LN56@clear:
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@
  00016	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00019	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0001c	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0001f	5f		 pop	 edi
  00020	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
PUBLIC	?clear@ios_base@std@@QAEXH@Z			; std::ios_base::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
?clear@ios_base@std@@QAEXH@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 325  : 		{	// set state to argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 326  : 		clear(_State, false);

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	6a 00		 push	 0
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 327  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?clear@ios_base@std@@QAEXH@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
PUBLIC	?_Init@ios_base@std@@IAEXXZ			; std::ios_base::_Init
; Function compile flags: /Ogtp
;	COMDAT ?_Init@ios_base@std@@IAEXXZ
_TEXT	SEGMENT
__Lock$156115 = -8					; size = 4
$T156111 = -4						; size = 4
?_Init@ios_base@std@@IAEXXZ PROC			; std::ios_base::_Init, COMDAT
; _this$ = ecx

; 554  : 		{	// initialize a new ios_base

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 555  : 		_Ploc = 0;

  0000b	33 ff		 xor	 edi, edi

; 556  : 		_Stdstr = 0;
; 557  : 		_Except = goodbit;
; 558  : 		_Fmtfl = (fmtflags)(skipws | dec);
; 559  : 		_Prec = 6;
; 560  : 		_Wide = 0;
; 561  : 		_Arr = 0;
; 562  : 		_Calls = 0;
; 563  : 		clear(goodbit);

  0000d	57		 push	 edi
  0000e	57		 push	 edi
  0000f	89 7e 30	 mov	 DWORD PTR [esi+48], edi
  00012	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00015	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00018	c7 46 14 01 02
	00 00		 mov	 DWORD PTR [esi+20], 513	; 00000201H
  0001f	c7 46 18 06 00
	00 00		 mov	 DWORD PTR [esi+24], 6
  00026	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00029	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  0002c	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  0002f	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  00032	89 7e 2c	 mov	 DWORD PTR [esi+44], edi
  00035	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 564  : 		_Ploc = _NEW_CRT locale;

  0003a	6a 04		 push	 4
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b d8		 mov	 ebx, eax
  00043	83 c4 04	 add	 esp, 4
  00046	3b df		 cmp	 ebx, edi
  00048	74 39		 je	 SHORT $LN3@Init
  0004a	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Init
  0004f	89 03		 mov	 DWORD PTR [ebx], eax
  00051	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  00056	57		 push	 edi
  00057	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$156115[ebp]
  0005a	89 45 fc	 mov	 DWORD PTR $T156111[ebp], eax
  0005d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00062	8b 4d fc	 mov	 ecx, DWORD PTR $T156111[ebp]
  00065	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00068	83 f8 ff	 cmp	 eax, -1
  0006b	73 04		 jae	 SHORT $LN9@Init
  0006d	40		 inc	 eax
  0006e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN9@Init:
  00071	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$156115[ebp]
  00074	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00079	5f		 pop	 edi
  0007a	89 5e 30	 mov	 DWORD PTR [esi+48], ebx
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx

; 565  : 		}

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
$LN3@Init:

; 564  : 		_Ploc = _NEW_CRT locale;

  00083	89 7e 30	 mov	 DWORD PTR [esi+48], edi
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx

; 565  : 		}

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?_Init@ios_base@std@@IAEXXZ ENDP			; std::ios_base::_Init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN13@scalar@11
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN13@scalar@11:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@
  00016	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00019	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0001c	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0001f	5f		 pop	 edi
  00020	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00023	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 44 02 38	 mov	 eax, DWORD PTR [edx+eax+56]
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN4@sentry
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	8b c8		 mov	 ecx, eax
  00013	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00016	ff e0		 jmp	 eax
$LN4@sentry:
  00018	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1496 : 		{	// return pointer to null-terminated nonmutable array

  00000	8b c1		 mov	 eax, ecx

; 1497 : 		return (_Myptr());

  00002	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00006	72 02		 jb	 SHORT $LN6@c_str@3
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
$LN6@c_str@3:

; 1498 : 		}

  0000a	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 3365 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3366 : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Yarn
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN6@Yarn:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3367 : 		}

  00019	c3		 ret	 0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
PUBLIC	??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
PUBLIC	?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<char,std::char_traits<char> >::imbue
EXTRN	??1_Mutex@std@@QAE@XZ:PROC			; std::_Mutex::~_Mutex
EXTRN	??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
CONST	ENDS
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__Lock$156235 = -8					; size = 4
_this$ = -4						; size = 4
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 79   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 80   : 		_DELETE_CRT(_Plocale);

  0000a	8b 5e 38	 mov	 ebx, DWORD PTR [esi+56]
  0000d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  00016	85 db		 test	 ebx, ebx
  00018	74 4d		 je	 SHORT $LN6@basic_stre
  0001a	57		 push	 edi
  0001b	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0001d	85 ff		 test	 edi, edi
  0001f	74 3c		 je	 SHORT $LN12@basic_stre
  00021	6a 00		 push	 0
  00023	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$156235[ebp]
  00026	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  0002b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002e	85 c0		 test	 eax, eax
  00030	74 09		 je	 SHORT $LN14@basic_stre
  00032	83 f8 ff	 cmp	 eax, -1
  00035	73 04		 jae	 SHORT $LN14@basic_stre
  00037	48		 dec	 eax
  00038	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN14@basic_stre:
  0003b	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0003e	f7 de		 neg	 esi
  00040	1b f6		 sbb	 esi, esi
  00042	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$156235[ebp]
  00045	f7 d6		 not	 esi
  00047	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0004c	23 f7		 and	 esi, edi
  0004e	74 0a		 je	 SHORT $LN18@basic_stre
  00050	8b 06		 mov	 eax, DWORD PTR [esi]
  00052	8b 10		 mov	 edx, DWORD PTR [eax]
  00054	6a 01		 push	 1
  00056	8b ce		 mov	 ecx, esi
  00058	ff d2		 call	 edx
$LN18@basic_stre:
  0005a	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
$LN12@basic_stre:
  0005d	53		 push	 ebx
  0005e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00063	83 c4 04	 add	 esp, 4
  00066	5f		 pop	 edi
$LN6@basic_stre:

; 81   : 		}

  00067	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0006a	e8 00 00 00 00	 call	 ??1_Mutex@std@@QAE@XZ	; std::_Mutex::~_Mutex
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
_TEXT	ENDS
EXTRN	?_Lock@_Mutex@std@@QAEXXZ:PROC			; std::_Mutex::_Lock
; Function compile flags: /Ogtp
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 207  : 		_Mylock._Lock();

  00000	83 c1 04	 add	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ?_Lock@_Mutex@std@@QAEXXZ ; std::_Mutex::_Lock
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
EXTRN	?_Unlock@_Mutex@std@@QAEXXZ:PROC		; std::_Mutex::_Unlock
; Function compile flags: /Ogtp
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 212  : 		_Mylock._Unlock();

  00000	83 c1 04	 add	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ?_Unlock@_Mutex@std@@QAEXXZ ; std::_Mutex::_Unlock
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 338  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 339  : 		}

  00003	c2 04 00	 ret	 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::overflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 343  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 344  : 		}

  00003	c2 04 00	 ret	 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
_TEXT	SEGMENT
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc, COMDAT
; _this$ = ecx

; 348  : 		return (0);

  00000	33 c0		 xor	 eax, eax
  00002	33 d2		 xor	 edx, edx

; 349  : 		}

  00004	c3		 ret	 0
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 353  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 354  : 		}

  00003	c3		 ret	 0
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::underflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 434  : 		{	// offer buffer to external agent (do nothing)

  00000	8b c1		 mov	 eax, ecx

; 435  : 		return (this);
; 436  : 		}

  00002	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 440  : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 441  : 		}

  00002	c3		 ret	 0
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sync
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 445  : 		}

  00000	c2 04 00	 ret	 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
PUBLIC	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
; Function compile flags: /Ogtp
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pptr, COMDAT
; _this$ = ecx

; 233  : 		return (*_IPnext);

  00000	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 234  : 		}

  00005	c3		 ret	 0
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pptr
_TEXT	ENDS
PUBLIC	?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::gbump
; Function compile flags: /Ogtp
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::gbump, COMDAT
; _this$ = ecx

; 242  : 		{	// alter current position in read buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 243  : 		*_IGcount -= _Off;

  00003	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 244  : 		*_IGnext += _Off;

  0000b	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0000e	01 11		 add	 DWORD PTR [ecx], edx

; 245  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gbump
_TEXT	ENDS
PUBLIC	?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbump
; Function compile flags: /Ogtp
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbump, COMDAT
; _this$ = ecx

; 283  : 		{	// alter current position in write buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 284  : 		*_IPcount -= _Off;

  00003	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 285  : 		*_IPnext += _Off;

  0000b	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  0000e	01 11		 add	 DWORD PTR [ecx], edx

; 286  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbump
_TEXT	ENDS
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
; Function compile flags: /Ogtp
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 310  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  00000	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Pnavail
  00008	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  0000b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000d	99		 cdq

; 311  : 		}

  0000e	c3		 ret	 0
$LN3@Pnavail:

; 310  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 311  : 		}

  00012	c3		 ret	 0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
PUBLIC	??0?$fpos@H@std@@QAE@_J@Z			; std::fpos<int>::fpos<int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ??0?$fpos@H@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 8
??0?$fpos@H@std@@QAE@_J@Z PROC				; std::fpos<int>::fpos<int>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with stream offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp+4]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx
  0000d	33 c9		 xor	 ecx, ecx
  0000f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00012	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00015	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00018	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 41   : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??0?$fpos@H@std@@QAE@_J@Z ENDP				; std::fpos<int>::fpos<int>
_TEXT	ENDS
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetc, COMDAT
; _this$ = ecx

; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 0e		 je	 SHORT $LN3@sgetc
  00008	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000b	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0000e	7e 06		 jle	 SHORT $LN3@sgetc
  00010	8b 00		 mov	 eax, DWORD PTR [eax]
  00012	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 154  : 		}

  00015	c3		 ret	 0
$LN3@sgetc:

; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001b	ff e0		 jmp	 eax
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 357  : 		{	// get a character from stream, point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 358  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())
; 359  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00008	ff d2		 call	 edx
  0000a	83 f8 ff	 cmp	 eax, -1
  0000d	75 04		 jne	 SHORT $LN3@uflow
  0000f	0b c0		 or	 eax, eax
  00011	5e		 pop	 esi

; 360  : 		}

  00012	c3		 ret	 0
$LN3@uflow:

; 358  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())
; 359  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));

  00013	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00016	ff 08		 dec	 DWORD PTR [eax]
  00018	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00020	89 10		 mov	 DWORD PTR [eax], edx
  00022	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00025	5e		 pop	 esi

; 360  : 		}

  00026	c3		 ret	 0
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
_TEXT	SEGMENT
__Copied$ = -8						; size = 8
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn, COMDAT
; _this$ = ecx

; 364  : 		{	// get _Count characters from stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 365  : 		int_type _Meta;
; 366  : 		streamsize _Size, _Copied;
; 367  : 
; 368  : 		for (_Copied = 0; 0 < _Count; )

  00006	33 c0		 xor	 eax, eax
  00008	53		 push	 ebx
  00009	8b d9		 mov	 ebx, ecx
  0000b	89 45 f8	 mov	 DWORD PTR __Copied$[ebp], eax
  0000e	89 45 fc	 mov	 DWORD PTR __Copied$[ebp+4], eax
  00011	39 45 10	 cmp	 DWORD PTR __Count$[ebp+4], eax
  00014	0f 8c a3 00 00
	00		 jl	 $LN30@xsgetn
  0001a	7f 09		 jg	 SHORT $LN31@xsgetn
  0001c	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001f	0f 86 98 00 00
	00		 jbe	 $LN30@xsgetn
$LN31@xsgetn:
  00025	56		 push	 esi
  00026	57		 push	 edi
$LL7@xsgetn:

; 369  : 			if (0 < (_Size = _Gnavail()))

  00027	8b cb		 mov	 ecx, ebx
  00029	e8 00 00 00 00	 call	 ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
  0002e	8b fa		 mov	 edi, edx
  00030	8b f0		 mov	 esi, eax
  00032	85 ff		 test	 edi, edi
  00034	7c 47		 jl	 SHORT $LN5@xsgetn
  00036	7f 04		 jg	 SHORT $LN25@xsgetn
  00038	85 f6		 test	 esi, esi
  0003a	74 41		 je	 SHORT $LN5@xsgetn
$LN25@xsgetn:

; 370  : 				{	// copy from read buffer
; 371  : 				if (_Count < _Size)

  0003c	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp+4]
  0003f	3b c7		 cmp	 eax, edi
  00041	7f 0c		 jg	 SHORT $LN4@xsgetn
  00043	7c 05		 jl	 SHORT $LN29@xsgetn
  00045	39 75 0c	 cmp	 DWORD PTR __Count$[ebp], esi
  00048	73 05		 jae	 SHORT $LN4@xsgetn
$LN29@xsgetn:

; 372  : 					_Size = _Count;

  0004a	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  0004d	8b f8		 mov	 edi, eax
$LN4@xsgetn:

; 373  : 				_Traits::copy(_Ptr, gptr(), (size_t)_Size);

  0004f	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00052	8b 08		 mov	 ecx, DWORD PTR [eax]
  00054	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00057	56		 push	 esi
  00058	51		 push	 ecx
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 _memcpy

; 374  : 				_Ptr += _Size;

  0005f	01 75 08	 add	 DWORD PTR __Ptr$[ebp], esi

; 375  : 				_Copied += _Size;
; 376  : 				_Count -= _Size;
; 377  : 				gbump((int)_Size);

  00062	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	01 75 f8	 add	 DWORD PTR __Copied$[ebp], esi
  0006b	11 7d fc	 adc	 DWORD PTR __Copied$[ebp+4], edi
  0006e	29 75 0c	 sub	 DWORD PTR __Count$[ebp], esi
  00071	19 7d 10	 sbb	 DWORD PTR __Count$[ebp+4], edi
  00074	29 30		 sub	 DWORD PTR [eax], esi
  00076	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00079	01 30		 add	 DWORD PTR [eax], esi
  0007b	eb 28		 jmp	 SHORT $LN1@xsgetn
$LN5@xsgetn:

; 378  : 				}
; 379  : 			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  0007d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0007f	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00082	8b cb		 mov	 ecx, ebx
  00084	ff d2		 call	 edx
  00086	83 ca ff	 or	 edx, -1
  00089	3b c2		 cmp	 eax, edx
  0008b	74 2e		 je	 SHORT $LN32@xsgetn

; 380  : 				break;	// end of file, quit
; 381  : 			else
; 382  : 				{	// get a single character
; 383  : 				*_Ptr++ = _Traits::to_char_type(_Meta);

  0008d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00090	41		 inc	 ecx

; 384  : 				++_Copied;

  00091	83 45 f8 01	 add	 DWORD PTR __Copied$[ebp], 1
  00095	88 41 ff	 mov	 BYTE PTR [ecx-1], al
  00098	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
  0009b	83 55 fc 00	 adc	 DWORD PTR __Copied$[ebp+4], 0

; 385  : 				--_Count;

  0009f	01 55 0c	 add	 DWORD PTR __Count$[ebp], edx
  000a2	11 55 10	 adc	 DWORD PTR __Count$[ebp+4], edx
$LN1@xsgetn:

; 365  : 		int_type _Meta;
; 366  : 		streamsize _Size, _Copied;
; 367  : 
; 368  : 		for (_Copied = 0; 0 < _Count; )

  000a5	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp+4], 0
  000a9	0f 8f 78 ff ff
	ff		 jg	 $LL7@xsgetn
  000af	7c 0a		 jl	 SHORT $LN32@xsgetn
  000b1	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000b5	0f 87 6c ff ff
	ff		 ja	 $LL7@xsgetn
$LN32@xsgetn:
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
$LN30@xsgetn:

; 386  : 				}
; 387  : 
; 388  : 		return (_Copied);

  000bd	8b 45 f8	 mov	 eax, DWORD PTR __Copied$[ebp]
  000c0	8b 55 fc	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000c3	5b		 pop	 ebx

; 389  : 		}

  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c2 0c 00	 ret	 12			; 0000000cH
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
_TEXT	SEGMENT
__Copied$ = -8						; size = 8
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn, COMDAT
; _this$ = ecx

; 393  : 		{	// put _Count characters to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 394  : 		streamsize _Size, _Copied;
; 395  : 
; 396  : 		for (_Copied = 0; 0 < _Count; )

  00006	33 c0		 xor	 eax, eax
  00008	53		 push	 ebx
  00009	8b d9		 mov	 ebx, ecx
  0000b	89 45 f8	 mov	 DWORD PTR __Copied$[ebp], eax
  0000e	89 45 fc	 mov	 DWORD PTR __Copied$[ebp+4], eax
  00011	39 45 10	 cmp	 DWORD PTR __Count$[ebp+4], eax
  00014	0f 8c a7 00 00
	00		 jl	 $LN30@xsputn
  0001a	7f 09		 jg	 SHORT $LN31@xsputn
  0001c	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001f	0f 86 9c 00 00
	00		 jbe	 $LN30@xsputn
$LN31@xsputn:
  00025	56		 push	 esi
  00026	57		 push	 edi
$LL7@xsputn:

; 397  : 			if (0 < (_Size = _Pnavail()))

  00027	8b cb		 mov	 ecx, ebx
  00029	e8 00 00 00 00	 call	 ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
  0002e	8b fa		 mov	 edi, edx
  00030	8b f0		 mov	 esi, eax
  00032	85 ff		 test	 edi, edi
  00034	7c 47		 jl	 SHORT $LN5@xsputn
  00036	7f 04		 jg	 SHORT $LN25@xsputn
  00038	85 f6		 test	 esi, esi
  0003a	74 41		 je	 SHORT $LN5@xsputn
$LN25@xsputn:

; 398  : 				{	// copy to write buffer
; 399  : 				if (_Count < _Size)

  0003c	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp+4]
  0003f	3b c7		 cmp	 eax, edi
  00041	7f 0c		 jg	 SHORT $LN4@xsputn
  00043	7c 05		 jl	 SHORT $LN29@xsputn
  00045	39 75 0c	 cmp	 DWORD PTR __Count$[ebp], esi
  00048	73 05		 jae	 SHORT $LN4@xsputn
$LN29@xsputn:

; 400  : 					_Size = _Count;

  0004a	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  0004d	8b f8		 mov	 edi, eax
$LN4@xsputn:

; 401  : 				_Traits::copy(pptr(), _Ptr, (size_t)_Size);

  0004f	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00052	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00055	8b 11		 mov	 edx, DWORD PTR [ecx]
  00057	56		 push	 esi
  00058	50		 push	 eax
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 _memcpy

; 402  : 				_Ptr += _Size;

  0005f	01 75 08	 add	 DWORD PTR __Ptr$[ebp], esi

; 403  : 				_Copied += _Size;
; 404  : 				_Count -= _Size;
; 405  : 				pbump((int)_Size);

  00062	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	01 75 f8	 add	 DWORD PTR __Copied$[ebp], esi
  0006b	11 7d fc	 adc	 DWORD PTR __Copied$[ebp+4], edi
  0006e	29 75 0c	 sub	 DWORD PTR __Count$[ebp], esi
  00071	19 7d 10	 sbb	 DWORD PTR __Count$[ebp+4], edi
  00074	29 30		 sub	 DWORD PTR [eax], esi
  00076	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00079	01 30		 add	 DWORD PTR [eax], esi

; 406  : 				}
; 407  : 			else if (_Traits::eq_int_type(_Traits::eof(),

  0007b	eb 2c		 jmp	 SHORT $LN1@xsputn
$LN5@xsputn:

; 408  : 				overflow(_Traits::to_int_type(*_Ptr))))

  0007d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00080	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00083	8b 13		 mov	 edx, DWORD PTR [ebx]
  00085	50		 push	 eax
  00086	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00089	8b cb		 mov	 ecx, ebx
  0008b	ff d0		 call	 eax
  0008d	83 c9 ff	 or	 ecx, -1
  00090	3b c1		 cmp	 eax, ecx
  00092	74 2b		 je	 SHORT $LN32@xsputn

; 409  : 				break;	// single character put failed, quit
; 410  : 			else
; 411  : 				{	// count character successfully put
; 412  : 				++_Ptr;

  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	01 45 08	 add	 DWORD PTR __Ptr$[ebp], eax

; 413  : 				++_Copied;

  0009c	01 45 f8	 add	 DWORD PTR __Copied$[ebp], eax
  0009f	83 55 fc 00	 adc	 DWORD PTR __Copied$[ebp+4], 0

; 414  : 				--_Count;

  000a3	01 4d 0c	 add	 DWORD PTR __Count$[ebp], ecx
  000a6	11 4d 10	 adc	 DWORD PTR __Count$[ebp+4], ecx
$LN1@xsputn:

; 394  : 		streamsize _Size, _Copied;
; 395  : 
; 396  : 		for (_Copied = 0; 0 < _Count; )

  000a9	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp+4], 0
  000ad	0f 8f 74 ff ff
	ff		 jg	 $LL7@xsputn
  000b3	7c 0a		 jl	 SHORT $LN32@xsputn
  000b5	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000b9	0f 87 68 ff ff
	ff		 ja	 $LL7@xsputn
$LN32@xsputn:
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
$LN30@xsputn:

; 415  : 				}
; 416  : 
; 417  : 		return (_Copied);

  000c1	8b 45 f8	 mov	 eax, DWORD PTR __Copied$[ebp]
  000c4	8b 55 fc	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000c7	5b		 pop	 ebx

; 418  : 		}

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 0c 00	 ret	 12			; 0000000cH
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
EXTRN	?_BADOFF@std@@3_JB:QWORD			; std::_BADOFF
; Function compile flags: /Ogtp
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 8
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 423  : 		{	// change position by offset, according to way and mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 424  : 		return (streampos(_BADOFF));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB
  0000c	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00012	89 08		 mov	 DWORD PTR [eax], ecx
  00014	33 c9		 xor	 ecx, ecx
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0001f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 425  : 		}

  00022	5d		 pop	 ebp
  00023	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 429  : 		{	// change to specified position, according to mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 430  : 		return (streampos(_BADOFF));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB
  0000c	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00012	89 08		 mov	 DWORD PTR [eax], ecx
  00014	33 c9		 xor	 ecx, ecx
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0001f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 431  : 		}

  00022	5d		 pop	 ebp
  00023	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
PUBLIC	?is_open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_fstream<char,std::char_traits<char> >::is_open
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
;	COMDAT ?is_open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?is_open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::is_open, COMDAT
; _this$ = ecx

; 1312 : 		return (_Filebuffer.is_open());

  00000	33 c0		 xor	 eax, eax
  00002	39 41 6c	 cmp	 DWORD PTR [ecx+108], eax
  00005	0f 95 c0	 setne	 al

; 1313 : 		}

  00008	c3		 ret	 0
?is_open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::is_open
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 f8	 lea	 esi, DWORD PTR [ecx-8]
  00007	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00009	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000c	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0000f	c7 44 02 f8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00017	50		 push	 eax
  00018	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  0001e	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00023	83 c4 04	 add	 esp, 4
  00026	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0002a	74 09		 je	 SHORT $LN13@scalar@12
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00032	83 c4 04	 add	 esp, 4
$LN13@scalar@12:
  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 f0	 lea	 esi, DWORD PTR [ecx-16]
  00007	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00009	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000c	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  0000f	c7 44 02 f0 00
	00 00 00	 mov	 DWORD PTR [edx+eax-16], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00017	50		 push	 eax
  00018	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  0001e	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00023	83 c4 04	 add	 esp, 4
  00026	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0002a	74 09		 je	 SHORT $LN13@scalar@13
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00032	83 c4 04	 add	 esp, 4
$LN13@scalar@13:
  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@14
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@14:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_iostream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 e8	 lea	 esi, DWORD PTR [ecx-24]
  00007	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00009	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000c	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0000f	c7 44 02 e8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-24], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  00017	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	c7 44 02 f8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00025	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  00028	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002b	c7 44 02 e8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00033	50		 push	 eax
  00034	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  0003a	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0003f	83 c4 04	 add	 esp, 4
  00042	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00046	74 09		 je	 SHORT $LN17@scalar@15
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
$LN17@scalar@15:
  00051	8b c6		 mov	 eax, esi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_iostream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1618 : 		{	// look for [_Ptr, _Ptr + _Count) beginnng at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1619 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1620 : 		if (_Count != 0)
; 1621 : 			_DEBUG_POINTER(_Ptr);
; 1622 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1623 : 
; 1624 : 		if (_Count == 0 && _Off <= this->_Mysize)

  00004	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	85 d2		 test	 edx, edx
  0000f	75 05		 jne	 SHORT $LN6@find
  00011	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]

; 1625 : 			return (_Off);	// null string always matches (if inside string)

  00014	76 76		 jbe	 SHORT $LN7@find
$LN6@find:
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi

; 1626 : 
; 1627 : 		size_type _Nm;
; 1628 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))

  00019	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
  0001c	3b c7		 cmp	 eax, edi
  0001e	73 66		 jae	 SHORT $LN2@find
  00020	2b f8		 sub	 edi, eax
  00022	3b d7		 cmp	 edx, edi
  00024	77 60		 ja	 SHORT $LN2@find

; 1629 : 			{	// room for match, look for it
; 1630 : 			const _Elem *_Uptr, *_Vptr;
; 1631 : 			for (_Nm -= _Count - 1, _Vptr = _Myptr() + _Off;

  00026	be 01 00 00 00	 mov	 esi, 1
  0002b	2b f2		 sub	 esi, edx
  0002d	03 fe		 add	 edi, esi
  0002f	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00033	72 02		 jb	 SHORT $LN11@find
  00035	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN11@find:
  00037	8d 1c 01	 lea	 ebx, DWORD PTR [ecx+eax]

; 1632 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1633 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00040	57		 push	 edi
  00041	51		 push	 ecx
  00042	53		 push	 ebx
  00043	e8 00 00 00 00	 call	 _memchr
  00048	8b f0		 mov	 esi, eax
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	85 f6		 test	 esi, esi
  0004f	74 35		 je	 SHORT $LN2@find
$LL4@find:

; 1634 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)

  00051	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  00054	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00057	52		 push	 edx
  00058	50		 push	 eax
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	85 c0		 test	 eax, eax
  00064	74 2c		 je	 SHORT $LN20@find

; 1632 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1633 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

  00066	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00069	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0006c	2b de		 sub	 ebx, esi
  0006e	8d 7c 1f ff	 lea	 edi, DWORD PTR [edi+ebx-1]
  00072	57		 push	 edi
  00073	52		 push	 edx
  00074	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
  00077	53		 push	 ebx
  00078	e8 00 00 00 00	 call	 _memchr
  0007d	8b f0		 mov	 esi, eax
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	85 f6		 test	 esi, esi
  00084	75 cb		 jne	 SHORT $LL4@find
$LN2@find:
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi

; 1636 : 			}
; 1637 : 
; 1638 : 		return (npos);	// no match

  00088	83 c8 ff	 or	 eax, -1
  0008b	5b		 pop	 ebx
$LN7@find:

; 1639 : 		}

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 0c 00	 ret	 12			; 0000000cH
$LN20@find:

; 1635 : 					return (_Uptr - _Myptr());	// found a match

  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00099	72 02		 jb	 SHORT $LN17@find
  0009b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN17@find:
  0009d	5f		 pop	 edi
  0009e	8b c6		 mov	 eax, esi
  000a0	5e		 pop	 esi
  000a1	2b c1		 sub	 eax, ecx
  000a3	5b		 pop	 ebx

; 1639 : 		}

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 0c 00	 ret	 12			; 0000000cH
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; Function compile flags: /Ogtp
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1888 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1889 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1890 : 		if (_Count != 0)
; 1891 : 			_DEBUG_POINTER(_Ptr);
; 1892 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1893 : 
; 1894 : 		if (this->_Mysize < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 08	 mov	 edi, DWORD PTR __Off$[ebp]
  0000c	3b c7		 cmp	 eax, edi
  0000e	73 0a		 jae	 SHORT $LN2@compare@2

; 1895 : 			_Xran();	// _Off off end

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00015	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@compare@2:
$LN2@compare@2:

; 1896 : 		if (this->_Mysize - _Off < _N0)

  0001a	8b 75 0c	 mov	 esi, DWORD PTR __N0$[ebp]
  0001d	2b c7		 sub	 eax, edi
  0001f	3b c6		 cmp	 eax, esi
  00021	73 02		 jae	 SHORT $LN1@compare@2

; 1897 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size

  00023	8b f0		 mov	 esi, eax
$LN1@compare@2:

; 1898 : 
; 1899 : 		size_type _Ans = _Traits::compare(_Myptr() + _Off, _Ptr,
; 1900 : 			_N0 < _Count ? _N0 : _Count);

  00025	8b 5d 14	 mov	 ebx, DWORD PTR __Count$[ebp]
  00028	8b d6		 mov	 edx, esi
  0002a	3b f3		 cmp	 esi, ebx
  0002c	72 02		 jb	 SHORT $LN6@compare@2
  0002e	8b d3		 mov	 edx, ebx
$LN6@compare@2:
  00030	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00034	72 04		 jb	 SHORT $LN16@compare@2
  00036	8b 01		 mov	 eax, DWORD PTR [ecx]
  00038	eb 02		 jmp	 SHORT $LN17@compare@2
$LN16@compare@2:
  0003a	8b c1		 mov	 eax, ecx
$LN17@compare@2:
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003f	52		 push	 edx
  00040	51		 push	 ecx
  00041	03 c7		 add	 eax, edi
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1901 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 1902 : 			: _N0 == _Count ? 0 : +1);

  0004c	85 c0		 test	 eax, eax
  0004e	75 15		 jne	 SHORT $LN8@compare@2
  00050	3b f3		 cmp	 esi, ebx
  00052	73 0a		 jae	 SHORT $LN7@compare@2
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	83 c8 ff	 or	 eax, -1
  00059	5b		 pop	 ebx

; 1903 : 		}

  0005a	5d		 pop	 ebp
  0005b	c2 10 00	 ret	 16			; 00000010H
$LN7@compare@2:

; 1901 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 1902 : 			: _N0 == _Count ? 0 : +1);

  0005e	33 c0		 xor	 eax, eax
  00060	3b f3		 cmp	 esi, ebx
  00062	0f 95 c0	 setne	 al
$LN8@compare@2:
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx

; 1903 : 		}

  00068	5d		 pop	 ebp
  00069	c2 10 00	 ret	 16			; 00000010H
$LN18@compare@2:
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
; Function compile flags: /Ogtp
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 1906 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1907 : 		return (this->_Alval);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1908 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtp
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1953 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1954 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0000a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000d	72 02		 jb	 SHORT $LN5@Eos
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN5@Eos:
  00011	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1955 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1988 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1989 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 22		 je	 SHORT $LN9@Tidy@3

; 1990 : 			;
; 1991 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 1c		 jb	 SHORT $LN9@Tidy@3

; 1992 : 			{	// copy any leftovers to small buffer and deallocate
; 1993 : 			_Elem *_Ptr = this->_Bx._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 1994 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN7@Tidy@3

; 1995 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@Tidy@3:

; 1996 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

  00028	53		 push	 ebx
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4
  00031	5b		 pop	 ebx
$LN9@Tidy@3:

; 1997 : 			}
; 1998 : 		this->_Myres = this->_BUF_SIZE - 1;
; 1999 : 		_Eos(_Newsize);

  00032	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00035	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0003c	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 2000 : 		}

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 454  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 455  : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 42   : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		ios_base::clear((iostate)(_Mystrbuf == 0
; 44   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

  00003	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00007	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  0000a	75 03		 jne	 SHORT $LN4@clear@2
  0000c	83 c8 04	 or	 eax, 4
$LN4@clear@2:
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Reraise$[ebp]
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 45   : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc, COMDAT
; _this$ = ecx

; 146  : 		return (0 < _Gnavail()
; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 1a		 je	 SHORT $LN3@sbumpc
  00008	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000b	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0000e	7e 12		 jle	 SHORT $LN3@sbumpc
  00010	8b c2		 mov	 eax, edx
  00012	ff 08		 dec	 DWORD PTR [eax]
  00014	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00017	8b 01		 mov	 eax, DWORD PTR [ecx]
  00019	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0001c	89 11		 mov	 DWORD PTR [ecx], edx
  0001e	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 148  : 		}

  00021	c3		 ret	 0
$LN3@sbumpc:

; 146  : 		return (0 < _Gnavail()
; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00027	ff e2		 jmp	 edx
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 556  : 		}

  0000a	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Key
; Function compile flags: /Ogtp
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Key
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator*, COMDAT
; _this$ = ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >, COMDAT
; _this$ = ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 556  : 		}

  0000a	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Key
; Function compile flags: /Ogtp
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Key
; Function compile flags: /Ogtp
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAAAKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerSection@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerSection@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerSection@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerSection@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; _this$ = ecx

; 641  : 		if (_Mysb::eback() == &_Mychar)

  00000	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00003	8d 41 48	 lea	 eax, DWORD PTR [ecx+72]
  00006	39 02		 cmp	 DWORD PTR [edx], eax
  00008	75 16		 jne	 SHORT $LN6@Reset_back

; 642  : 			_Mysb::setg(_Set_eback, _Set_egptr, _Set_egptr);

  0000a	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  0000d	56		 push	 esi
  0000e	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  00011	89 32		 mov	 DWORD PTR [edx], esi
  00013	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00016	89 02		 mov	 DWORD PTR [edx], eax
  00018	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  0001b	2b c0		 sub	 eax, eax
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	5e		 pop	 esi
$LN6@Reset_back:

; 643  : 		}

  00020	c3		 ret	 0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
PUBLIC	??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ PROC ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*, COMDAT
; _this$ = ecx

; 343  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 344  : 		}

  00002	c3		 ret	 0
??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ENDP ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerRow@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerRow@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerRow@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBKVTokenizerRow@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 315  : 		_IGfirst = &_Gfirst;
; 316  : 		_IPfirst = &_Pfirst;
; 317  : 		_IGnext = &_Gnext;

  00000	8d 51 18	 lea	 edx, DWORD PTR [ecx+24]
  00003	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 318  : 		_IPnext = &_Pnext;

  00006	8d 51 1c	 lea	 edx, DWORD PTR [ecx+28]
  00009	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  0000c	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  0000f	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 319  : 		_IGcount = &_Gcount;

  00012	8d 51 28	 lea	 edx, DWORD PTR [ecx+40]
  00015	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00018	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  0001b	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 320  : 		_IPcount = &_Pcount;

  0001e	8d 51 2c	 lea	 edx, DWORD PTR [ecx+44]
  00021	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 321  : 		setp(0, 0);

  00024	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002a	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00033	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00036	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 322  : 		setg(0, 0, 0);

  0003c	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00045	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00048	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0004e	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 323  : 		}

  00057	c3		 ret	 0
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >
_TEXT	ENDS
PUBLIC	??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 325  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 326  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1517 : 		size_type _Num = this->_Alval.max_size();
; 1518 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1519 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lmost
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rmost
; Function compile flags: /Ogtp
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Root
; Function compile flags: /Ogtp
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Root, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Root
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 483  : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
$T156833 = -12						; size = 12
$T156831 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 43		 je	 SHORT $LN1@allocate
  0000f	81 f9 55 55 55
	05		 cmp	 ecx, 89478485		; 05555555H
  00015	77 13		 ja	 SHORT $LN3@allocate
  00017	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0001a	c1 e0 04	 shl	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax
  00028	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  0002a	8d 4d 08	 lea	 ecx, DWORD PTR $T156831[ebp]
  0002d	51		 push	 ecx
  0002e	8d 4d f4	 lea	 ecx, DWORD PTR $T156833[ebp]
  00031	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T156831[ebp], 0
  00038	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003d	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00042	8d 55 f4	 lea	 edx, DWORD PTR $T156833[ebp]
  00045	52		 push	 edx
  00046	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T156833[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lmost
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rmost
; Function compile flags: /Ogtp
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Root
; Function compile flags: /Ogtp
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Root
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 483  : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
$T156887 = -12						; size = 12
$T156885 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 46		 je	 SHORT $LN1@allocate@2
  0000f	81 f9 66 66 66
	06		 cmp	 ecx, 107374182		; 06666666H
  00015	77 16		 ja	 SHORT $LN3@allocate@2
  00017	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 28		 jne	 SHORT $LN1@allocate@2
$LN3@allocate@2:
  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T156885[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T156887[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T156885[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T156887[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T156887[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@2:
$LN1@allocate@2:

; 188  : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN12@allocate@2:
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Root
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Root
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T156926 = -12						; size = 12
$T156924 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 3a		 je	 SHORT $LN1@allocate@3
  0000f	83 f9 ff	 cmp	 ecx, -1
  00012	77 0d		 ja	 SHORT $LN3@allocate@3
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	75 28		 jne	 SHORT $LN1@allocate@3
$LN3@allocate@3:
  00021	8d 45 08	 lea	 eax, DWORD PTR $T156924[ebp]
  00024	50		 push	 eax
  00025	8d 4d f4	 lea	 ecx, DWORD PTR $T156926[ebp]
  00028	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T156924[ebp], 0
  0002f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00034	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00039	8d 4d f4	 lea	 ecx, DWORD PTR $T156926[ebp]
  0003c	51		 push	 ecx
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T156926[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00044	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@3:
$LN1@allocate@3:

; 188  : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN12@allocate@3:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	56		 push	 esi

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
  0000c	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000f	8b 30		 mov	 esi, DWORD PTR [eax]
  00011	80 7e 2d 00	 cmp	 BYTE PTR [esi+45], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0c		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Lrotate:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0b		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003e	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  00040	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate:

; 1775 : 		else
; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	56		 push	 esi

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000c	89 32		 mov	 DWORD PTR [edx], esi

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00011	80 7e 2d 00	 cmp	 BYTE PTR [esi+45], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0d		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN4@Rrotate:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0d		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00041	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00044	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate:

; 1805 : 		else
; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 267  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator++
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	56		 push	 esi

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
  0000c	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000f	8b 30		 mov	 esi, DWORD PTR [eax]
  00011	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate@2

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Lrotate@2:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0c		 jne	 SHORT $LN4@Lrotate@2

; 1772 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Lrotate@2:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0b		 jne	 SHORT $LN2@Lrotate@2

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003e	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  00040	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate@2:

; 1775 : 		else
; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	56		 push	 esi

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000c	89 32		 mov	 DWORD PTR [edx], esi

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00011	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate@2

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Rrotate@2:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0d		 jne	 SHORT $LN4@Rrotate@2

; 1802 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN4@Rrotate@2:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0d		 jne	 SHORT $LN2@Rrotate@2

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00041	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00044	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate@2:

; 1805 : 		else
; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 267  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator!=<char,char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator!=<char,char>, COMDAT

; 271  : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 272  : 	}

  00002	c3		 ret	 0
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator!=<char,char>
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	_Ty _Tmp = _Move(_Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00009	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]
  0000c	8a 16		 mov	 dl, BYTE PTR [esi]
  0000e	88 10		 mov	 BYTE PTR [eax], dl

; 104  : 	_Right = _Move(_Tmp);

  00010	88 0e		 mov	 BYTE PTR [esi], cl
  00012	5e		 pop	 esi

; 105  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T157273 = -16						; size = 12
$T157257 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00007	6a 30		 push	 48			; 00000030H
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 1a		 je	 SHORT $LN5@Buynode

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00024	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00027	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  0002a	66 89 48 2c	 mov	 WORD PTR [eax+44], cx
  0002e	5e		 pop	 esi

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode:
  00033	8d 45 fc	 lea	 eax, DWORD PTR $T157257[ebp]
  00036	89 4d fc	 mov	 DWORD PTR $T157257[ebp], ecx
  00039	50		 push	 eax
  0003a	8d 4d f0	 lea	 ecx, DWORD PTR $T157273[ebp]
  0003d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00042	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00047	8d 4d f0	 lea	 ecx, DWORD PTR $T157273[ebp]
  0004a	51		 push	 ecx
  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T157273[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00052	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode:
$LN26@Buynode:
  00057	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode
; Function compile flags: /Ogtp
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T157327 = -16						; size = 12
$T157310 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00007	6a 28		 push	 40			; 00000028H
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 1a		 je	 SHORT $LN5@Buynode@2

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00024	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00027	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  0002a	66 89 48 24	 mov	 WORD PTR [eax+36], cx
  0002e	5e		 pop	 esi

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode@2:
  00033	8d 45 fc	 lea	 eax, DWORD PTR $T157310[ebp]
  00036	89 4d fc	 mov	 DWORD PTR $T157310[ebp], ecx
  00039	50		 push	 eax
  0003a	8d 4d f0	 lea	 ecx, DWORD PTR $T157327[ebp]
  0003d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00042	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00047	8d 4d f0	 lea	 ecx, DWORD PTR $T157327[ebp]
  0004a	51		 push	 ecx
  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T157327[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00052	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode@2:
$LN26@Buynode@2:
  00057	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >, COMDAT
; _this$ = ecx

; 208  : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 209  : 		}

  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 306  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >, COMDAT
; _this$ = ecx

; 208  : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 209  : 		}

  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >, COMDAT
; _this$ = ecx

; 208  : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 209  : 		}

  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 306  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??_7?$codecvt@DDH@std@@6B@			; std::codecvt<char,char,int>::`vftable'
PUBLIC	??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z	; std::codecvt<char,char,int>::codecvt<char,char,int>
PUBLIC	??_R4?$codecvt@DDH@std@@6B@			; std::codecvt<char,char,int>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$codecvt@DDH@std@@@8			; std::codecvt<char,char,int> `RTTI Type Descriptor'
PUBLIC	??_R3?$codecvt@DDH@std@@8			; std::codecvt<char,char,int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$codecvt@DDH@std@@8			; std::codecvt<char,char,int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$codecvt@DDH@std@@8		; std::codecvt<char,char,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::do_in
PUBLIC	?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::do_out
PUBLIC	?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z ; std::codecvt<char,char,int>::do_unshift
PUBLIC	?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z	; std::codecvt<char,char,int>::do_length
EXTRN	??_E?$codecvt@DDH@std@@MAEPAXI@Z:PROC		; std::codecvt<char,char,int>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$codecvt@DDH@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
rdata$r	SEGMENT
??_R1A@?0A@EA@?$codecvt@DDH@std@@8 DD FLAT:??_R0?AV?$codecvt@DDH@std@@@8 ; std::codecvt<char,char,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$codecvt@DDH@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$codecvt@DDH@std@@8
rdata$r	SEGMENT
??_R2?$codecvt@DDH@std@@8 DD FLAT:??_R1A@?0A@EA@?$codecvt@DDH@std@@8 ; std::codecvt<char,char,int>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@codecvt_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$codecvt@DDH@std@@8
rdata$r	SEGMENT
??_R3?$codecvt@DDH@std@@8 DD 00H			; std::codecvt<char,char,int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$codecvt@DDH@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$codecvt@DDH@std@@@8
_DATA	SEGMENT
??_R0?AV?$codecvt@DDH@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::codecvt<char,char,int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$codecvt@DDH@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$codecvt@DDH@std@@6B@
rdata$r	SEGMENT
??_R4?$codecvt@DDH@std@@6B@ DD 00H			; std::codecvt<char,char,int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$codecvt@DDH@std@@@8
	DD	FLAT:??_R3?$codecvt@DDH@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$codecvt@DDH@std@@6B@
CONST	SEGMENT
??_7?$codecvt@DDH@std@@6B@ DD FLAT:??_R4?$codecvt@DDH@std@@6B@ ; std::codecvt<char,char,int>::`vftable'
	DD	FLAT:??_E?$codecvt@DDH@std@@MAEPAXI@Z
	DD	FLAT:?do_always_noconv@codecvt_base@std@@MBE_NXZ
	DD	FLAT:?do_max_length@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_encoding@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
	DD	FLAT:?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
	DD	FLAT:?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z
	DD	FLAT:?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z PROC	; std::codecvt<char,char,int>::codecvt<char,char,int>, COMDAT
; _this$ = ecx

; 843  : 		{	// construct from specified locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 0c	 mov	 ecx, DWORD PTR __Refs$[ebp]
  00008	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$codecvt@DDH@std@@6B@

; 844  : 		_Init(_Lobj);
; 845  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z ENDP	; std::codecvt<char,char,int>::codecvt<char,char,int>
_TEXT	ENDS
PUBLIC	??1?$codecvt@DDH@std@@MAE@XZ			; std::codecvt<char,char,int>::~codecvt<char,char,int>
; Function compile flags: /Ogtp
;	COMDAT ??1?$codecvt@DDH@std@@MAE@XZ
_TEXT	SEGMENT
??1?$codecvt@DDH@std@@MAE@XZ PROC			; std::codecvt<char,char,int>::~codecvt<char,char,int>, COMDAT
; _this$ = ecx

; 859  : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00006	c3		 ret	 0
??1?$codecvt@DDH@std@@MAE@XZ ENDP			; std::codecvt<char,char,int>::~codecvt<char,char,int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
___formal$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,int>::do_in, COMDAT
; _this$ = ecx

; 868  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 869  : 		_Mid1 = _First1, _Mid2 = _First2;

  00003	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __First1$[ebp]
  00009	8b 55 20	 mov	 edx, DWORD PTR __Mid2$[ebp]
  0000c	89 08		 mov	 DWORD PTR [eax], ecx
  0000e	8b 45 18	 mov	 eax, DWORD PTR __First2$[ebp]
  00011	89 02		 mov	 DWORD PTR [edx], eax

; 870  : 		return (noconv);	// convert nothing

  00013	b8 03 00 00 00	 mov	 eax, 3

; 871  : 		}

  00018	5d		 pop	 ebp
  00019	c2 1c 00	 ret	 28			; 0000001cH
?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::do_in
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
___formal$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,int>::do_out, COMDAT
; _this$ = ecx

; 876  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 877  : 		_Mid1 = _First1, _Mid2 = _First2;

  00003	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __First1$[ebp]
  00009	8b 55 20	 mov	 edx, DWORD PTR __Mid2$[ebp]
  0000c	89 08		 mov	 DWORD PTR [eax], ecx
  0000e	8b 45 18	 mov	 eax, DWORD PTR __First2$[ebp]
  00011	89 02		 mov	 DWORD PTR [edx], eax

; 878  : 		return (noconv);	// convert nothing

  00013	b8 03 00 00 00	 mov	 eax, 3

; 879  : 		}

  00018	5d		 pop	 ebp
  00019	c2 1c 00	 ret	 28			; 0000001cH
?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::do_out
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First2$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid2$ = 20						; size = 4
?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z PROC	; std::codecvt<char,char,int>::do_unshift, COMDAT
; _this$ = ecx

; 883  : 		{	// generate bytes to return to default shift state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 884  : 		_Mid2 = _First2;

  00003	8b 45 14	 mov	 eax, DWORD PTR __Mid2$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 885  : 		return (noconv);	// convert nothing

  0000b	b8 03 00 00 00	 mov	 eax, 3

; 886  : 		}

  00010	5d		 pop	 ebp
  00011	c2 10 00	 ret	 16			; 00000010H
?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z ENDP	; std::codecvt<char,char,int>::do_unshift
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Count$ = 20						; size = 4
?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z PROC	; std::codecvt<char,char,int>::do_length, COMDAT
; _this$ = ecx

; 890  : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 891  : 		return ((int)(_Count < (size_t)(_Last1 - _First1)
; 892  : 			? _Count : _Last1 - _First1));	// assume 1-to-1 conversion

  00003	8b 45 10	 mov	 eax, DWORD PTR __Last1$[ebp]
  00006	2b 45 0c	 sub	 eax, DWORD PTR __First1$[ebp]
  00009	8b 4d 14	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000c	3b c8		 cmp	 ecx, eax
  0000e	73 02		 jae	 SHORT $LN4@do_length
  00010	8b c1		 mov	 eax, ecx
$LN4@do_length:

; 893  : 		}

  00012	5d		 pop	 ebp
  00013	c2 10 00	 ret	 16			; 00000010H
?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z ENDP	; std::codecvt<char,char,int>::do_length
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@DDH@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$codecvt@DDH@std@@MAEPAXI@Z PROC			; std::codecvt<char,char,int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00010	74 09		 je	 SHORT $LN10@scalar@16
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN10@scalar@16:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$codecvt@DDH@std@@MAEPAXI@Z ENDP			; std::codecvt<char,char,int>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_size, COMDAT
; _this$ = ecx

; 874  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_size
_TEXT	ENDS
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 419  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 421  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator--
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::max_size, COMDAT
; _this$ = ecx

; 874  : 		return (this->_Alval.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::max_size, COMDAT
; _this$ = ecx

; 874  : 		return (this->_Alval.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	56		 push	 esi

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
  0000c	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000f	8b 30		 mov	 esi, DWORD PTR [eax]
  00011	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate@3

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Lrotate@3:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0c		 jne	 SHORT $LN4@Lrotate@3

; 1772 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Lrotate@3:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0b		 jne	 SHORT $LN2@Lrotate@3

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003e	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  00040	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate@3:

; 1775 : 		else
; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	56		 push	 esi

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000c	89 32		 mov	 DWORD PTR [edx], esi

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00011	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate@3

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Rrotate@3:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0d		 jne	 SHORT $LN4@Rrotate@3

; 1802 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN4@Rrotate@3:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0d		 jne	 SHORT $LN2@Rrotate@3

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00041	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00044	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate@3:

; 1805 : 		else
; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 10		 mov	 edx, DWORD PTR [eax]
  00004	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00008	75 40		 jne	 SHORT $LN3@operator@6

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0000d	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00011	75 1a		 jne	 SHORT $LN34@operator@6

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00019	75 0f		 jne	 SHORT $LN17@operator@6
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator@6:
  00020	8b ca		 mov	 ecx, edx
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00028	74 f6		 je	 SHORT $LL18@operator@6
$LN17@operator@6:
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0002c	c3		 ret	 0
$LN34@operator@6:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00030	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00034	75 12		 jne	 SHORT $LN1@operator@6
$LL2@operator@6:
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0003b	75 0b		 jne	 SHORT $LN1@operator@6

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003d	89 10		 mov	 DWORD PTR [eax], edx
  0003f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00042	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00046	74 ee		 je	 SHORT $LL2@operator@6
$LN1@operator@6:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00048	89 10		 mov	 DWORD PTR [eax], edx
$LN3@operator@6:

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0004a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00008	74 06		 je	 SHORT $LN8@operator@7

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0000f	c3		 ret	 0
$LN8@operator@7:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00016	75 17		 jne	 SHORT $LN40@operator@7

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  00018	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001b	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0001f	75 30		 jne	 SHORT $LN21@operator@7
$LL22@operator@7:
  00021	8b d1		 mov	 edx, ecx
  00023	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00026	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0002a	74 f5		 je	 SHORT $LL22@operator@7

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0002e	c3		 ret	 0
$LN40@operator@7:

; 89   : 		else
; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00036	75 11		 jne	 SHORT $LN3@operator@7
$LL4@operator@7:
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0003c	75 0b		 jne	 SHORT $LN3@operator@7

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  0003e	89 10		 mov	 DWORD PTR [eax], edx
  00040	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00043	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00047	74 ef		 je	 SHORT $LL4@operator@7
$LN3@operator@7:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0004f	75 02		 jne	 SHORT $LN1@operator@7

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

$LN21@operator@7:

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00051	89 10		 mov	 DWORD PTR [eax], edx
$LN1@operator@7:

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00053	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 419  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 421  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 146  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 146  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 146  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
$T157825 = -12						; size = 12
$T157823 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 46		 je	 SHORT $LN1@allocate@4
  0000f	81 f9 66 66 66
	06		 cmp	 ecx, 107374182		; 06666666H
  00015	77 16		 ja	 SHORT $LN3@allocate@4
  00017	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 28		 jne	 SHORT $LN1@allocate@4
$LN3@allocate@4:
  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T157823[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T157825[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T157823[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T157825[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T157825[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@4:
$LN1@allocate@4:

; 188  : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN12@allocate@4:
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z
_TEXT	SEGMENT
$T157888 = -16						; size = 12
$T157871 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN15@Tree_val
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 551  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T157871[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T157888[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T157871[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T157888[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T157888[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val:
$LN36@Tree_val:
  0006e	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
_TEXT	ENDS
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@	; `string'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	__CTA2?AVruntime_error@std@@
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
;	COMDAT __CTA2?AVruntime_error@std@@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdexcept
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T157920 = -28						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T157946 = 8						; size = 4
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 76   :         {	// construct from NTBS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_Locinfo@std@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx
  00029	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002c	33 db		 xor	 ebx, ebx
  0002e	53		 push	 ebx
  0002f	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00034	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00037	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0003a	88 5e 08	 mov	 BYTE PTR [esi+8], bl
  0003d	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00040	88 5e 10	 mov	 BYTE PTR [esi+16], bl
  00043	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00046	88 5e 18	 mov	 BYTE PTR [esi+24], bl
  00049	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  0004c	88 5e 20	 mov	 BYTE PTR [esi+32], bl

; 77   :         if (_Pch == 0)

  0004f	8b 45 08	 mov	 eax, DWORD PTR __Pch$[ebp]
  00052	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00056	3b c3		 cmp	 eax, ebx
  00058	75 28		 jne	 SHORT $LN1@Locinfo

; 78   :             _THROW_NCEE(runtime_error, "bad locale name");

  0005a	8d 45 08	 lea	 eax, DWORD PTR $T157946[ebp]
  0005d	50		 push	 eax
  0005e	8d 4d e4	 lea	 ecx, DWORD PTR $T157920[ebp]
  00061	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T157946[ebp], OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
  00068	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0006d	68 00 00 00 00	 push	 OFFSET __TI2?AVruntime_error@std@@
  00072	8d 4d e4	 lea	 ecx, DWORD PTR $T157920[ebp]
  00075	51		 push	 ecx
  00076	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T157920[ebp], OFFSET ??_7runtime_error@std@@6B@
  0007d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN22@Locinfo:
$LN1@Locinfo:

; 79   :         _Locinfo_ctor(this, _Pch);

  00082	50		 push	 eax
  00083	56		 push	 esi
  00084	e8 00 00 00 00	 call	 ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
  00089	83 c4 08	 add	 esp, 8

; 80   :         }

  0008c	8b c6		 mov	 eax, esi
  0008e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00091	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00098	59		 pop	 ecx
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
$LN21@Locinfo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
  00034	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00038	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003b	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0003e	33 c8		 xor	 ecx, eax
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
  0004a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1_Locinfo@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1_Locinfo@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 93   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Locinfo@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 94   :         _Locinfo_dtor(this);

  0002a	56		 push	 esi
  0002b	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  00032	e8 00 00 00 00	 call	 ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor

; 95   :         }

  00037	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0003a	33 ff		 xor	 edi, edi
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b c7		 cmp	 eax, edi
  00041	74 09		 je	 SHORT $LN10@Locinfo@2
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _free
  00049	83 c4 04	 add	 esp, 4
$LN10@Locinfo@2:
  0004c	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  0004f	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00052	3b c7		 cmp	 eax, edi
  00054	74 09		 je	 SHORT $LN15@Locinfo@2
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _free
  0005c	83 c4 04	 add	 esp, 4
$LN15@Locinfo@2:
  0005f	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00062	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00065	3b c7		 cmp	 eax, edi
  00067	74 09		 je	 SHORT $LN20@Locinfo@2
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _free
  0006f	83 c4 04	 add	 esp, 4
$LN20@Locinfo@2:
  00072	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00075	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00078	3b c7		 cmp	 eax, edi
  0007a	74 09		 je	 SHORT $LN25@Locinfo@2
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _free
  00082	83 c4 04	 add	 esp, 4
$LN25@Locinfo@2:
  00085	8b ce		 mov	 ecx, esi
  00087	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0008a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00091	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00096	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00099	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a0	59		 pop	 ecx
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??1_Locinfo@std@@QAE@XZ:
  00034	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00038	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003b	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0003e	33 c8		 xor	 ecx, eax
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
  0004a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
xdata$x	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T158016 = -68						; size = 36
$T158075 = -32						; size = 16
$T158020 = -16						; size = 4
$T158015 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2371 : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2372 : 		if (_Ppf != 0 && *_Ppf == 0)

  00027	8b 45 08	 mov	 eax, DWORD PTR __Ppf$[ebp]
  0002a	33 db		 xor	 ebx, ebx
  0002c	89 5d f0	 mov	 DWORD PTR $T158020[ebp], ebx
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 8c 00 00
	00		 je	 $LN28@Getcat
  00037	39 18		 cmp	 DWORD PTR [eax], ebx
  00039	0f 85 84 00 00
	00		 jne	 $LN28@Getcat

; 2373 : 			*_Ppf = _NEW_CRT ctype<_Elem>(
; 2374 : 				_Locinfo(_Ploc->c_str()));

  0003f	6a 18		 push	 24			; 00000018H
  00041	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00046	8b f0		 mov	 esi, eax
  00048	83 c4 04	 add	 esp, 4
  0004b	89 75 f0	 mov	 DWORD PTR $T158015[ebp], esi
  0004e	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00051	85 f6		 test	 esi, esi
  00053	74 53		 je	 SHORT $LN4@Getcat
  00055	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0005d	85 c9		 test	 ecx, ecx
  0005f	74 04		 je	 SHORT $LN14@Getcat
  00061	8b c1		 mov	 eax, ecx
  00063	eb 03		 jmp	 SHORT $LN15@Getcat
$LN14@Getcat:
  00065	83 c0 1c	 add	 eax, 28			; 0000001cH
$LN15@Getcat:
  00068	50		 push	 eax
  00069	8d 4d bc	 lea	 ecx, DWORD PTR $T158016[ebp]
  0006c	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00071	8d 4d e0	 lea	 ecx, DWORD PTR $T158075[ebp]
  00074	51		 push	 ecx
  00075	bb 01 00 00 00	 mov	 ebx, 1
  0007a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00081	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  00087	e8 00 00 00 00	 call	 __Getctype
  0008c	8b 10		 mov	 edx, DWORD PTR [eax]
  0008e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00091	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00094	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00097	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0009a	89 56 10	 mov	 DWORD PTR [esi+16], edx
  0009d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000a0	83 c4 04	 add	 esp, 4
  000a3	89 46 14	 mov	 DWORD PTR [esi+20], eax
  000a6	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  000a8	33 f6		 xor	 esi, esi
$LN5@Getcat:
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Ppf$[ebp]
  000ad	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b4	89 31		 mov	 DWORD PTR [ecx], esi
  000b6	f6 c3 01	 test	 bl, 1
  000b9	74 08		 je	 SHORT $LN28@Getcat
  000bb	8d 4d bc	 lea	 ecx, DWORD PTR $T158016[ebp]
  000be	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN28@Getcat:

; 2375 : 		return (_X_CTYPE);

  000c3	b8 02 00 00 00	 mov	 eax, 2

; 2376 : 		}

  000c8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d2	59		 pop	 ecx
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T158015[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 550  : 		{	// construct empty string

  00000	8b c1		 mov	 eax, ecx

; 551  : 		_Tidy();

  00002	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
  00009	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00010	c6 00 00	 mov	 BYTE PTR [eax], 0

; 552  : 		}

  00013	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 753  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 754  : 		_Tidy(true);

  00003	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00007	72 0b		 jb	 SHORT $LN11@basic_stri
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
$LN11@basic_stri:
  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00022	c6 06 00	 mov	 BYTE PTR [esi], 0
  00025	5e		 pop	 esi

; 755  : 		}

  00026	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1109 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1110 : 		if (this->_Mysize < _Off)

  00006	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0000c	57		 push	 edi
  0000d	3b c1		 cmp	 eax, ecx
  0000f	73 0a		 jae	 SHORT $LN3@erase

; 1111 : 			_Xran();	// _Off off end

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00016	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN28@erase:
$LN3@erase:

; 1112 : 		if (this->_Mysize - _Off < _Count)

  0001b	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0001e	2b c1		 sub	 eax, ecx
  00020	3b c7		 cmp	 eax, edi
  00022	73 02		 jae	 SHORT $LN2@erase

; 1113 : 			_Count = this->_Mysize - _Off;	// trim _Count

  00024	8b f8		 mov	 edi, eax
$LN2@erase:

; 1114 : 		if (0 < _Count)

  00026	85 ff		 test	 edi, edi
  00028	74 50		 je	 SHORT $LN25@erase

; 1115 : 			{	// move elements down
; 1116 : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 1117 : 				this->_Mysize - _Off - _Count);

  0002a	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0002d	53		 push	 ebx
  0002e	83 fa 10	 cmp	 edx, 16			; 00000010H
  00031	72 04		 jb	 SHORT $LN11@erase
  00033	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00035	eb 02		 jmp	 SHORT $LN12@erase
$LN11@erase:
  00037	8b de		 mov	 ebx, esi
$LN12@erase:
  00039	83 fa 10	 cmp	 edx, 16			; 00000010H
  0003c	72 04		 jb	 SHORT $LN15@erase
  0003e	8b 16		 mov	 edx, DWORD PTR [esi]
  00040	eb 02		 jmp	 SHORT $LN16@erase
$LN15@erase:
  00042	8b d6		 mov	 edx, esi
$LN16@erase:
  00044	2b c7		 sub	 eax, edi
  00046	03 d9		 add	 ebx, ecx
  00048	50		 push	 eax
  00049	03 df		 add	 ebx, edi
  0004b	03 d1		 add	 edx, ecx
  0004d	53		 push	 ebx
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 _memmove

; 1118 : 			size_type _Newsize = this->_Mysize - _Count;

  00054	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	2b c7		 sub	 eax, edi

; 1119 : 			_Eos(_Newsize);

  0005c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00060	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00063	5b		 pop	 ebx
  00064	72 0e		 jb	 SHORT $LN23@erase
  00066	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00068	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
  0006c	5f		 pop	 edi

; 1120 : 			}
; 1121 : 		return (*this);

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi

; 1122 : 		}

  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8

; 1119 : 			_Eos(_Newsize);

$LN23@erase:
  00074	8b ce		 mov	 ecx, esi
  00076	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
$LN25@erase:

; 1120 : 			}
; 1121 : 		return (*this);

  0007a	5f		 pop	 edi
  0007b	8b c6		 mov	 eax, esi
  0007d	5e		 pop	 esi

; 1122 : 		}

  0007e	5d		 pop	 ebp
  0007f	c2 08 00	 ret	 8
$LN27@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
; Function compile flags: /Ogtp
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
__Off$ = 12						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1648 : 		{	// look for _Ch at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1649 : 		return (find((const _Elem *)&_Ch, _Off, 1));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	6a 01		 push	 1
  00008	50		 push	 eax
  00009	8d 55 08	 lea	 edx, DWORD PTR __Ch$[ebp]
  0000c	52		 push	 edx
  0000d	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find

; 1650 : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; Function compile flags: /Ogtp
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1875 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1876 : 		_DEBUG_POINTER(_Ptr);
; 1877 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	8b c6		 mov	 eax, esi
  00009	57		 push	 edi
  0000a	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000d	8d 49 00	 npad	 3
$LL5@compare@3:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL5@compare@3
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0001d	56		 push	 esi
  0001e	50		 push	 eax
  0001f	6a 00		 push	 0
  00021	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 1878 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 54   : 		{	// merge _State into state, possible reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 		if (_State != goodbit)

  00003	8b 55 08	 mov	 edx, DWORD PTR __State$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 18		 je	 SHORT $LN6@setstate

; 56   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000d	0b c2		 or	 eax, edx
  0000f	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00013	75 03		 jne	 SHORT $LN8@setstate
  00015	83 c8 04	 or	 eax, 4
$LN8@setstate:
  00018	8b 55 0c	 mov	 edx, DWORD PTR __Reraise$[ebp]
  0001b	52		 push	 edx
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN6@setstate:

; 57   : 		}

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::snextc, COMDAT
; _this$ = ecx

; 163  : 		{	// point to next character and return it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

  00003	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	85 c0		 test	 eax, eax
  0000a	74 3b		 je	 SHORT $LN17@snextc
  0000c	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00011	83 f9 01	 cmp	 ecx, 1
  00014	7e 12		 jle	 SHORT $LN5@snextc
  00016	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00019	ff 08		 dec	 DWORD PTR [eax]
  0001b	8b 76 20	 mov	 esi, DWORD PTR [esi+32]
  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
  00020	40		 inc	 eax
  00021	89 06		 mov	 DWORD PTR [esi], eax
  00023	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00026	5e		 pop	 esi

; 168  : 		}

  00027	c3		 ret	 0
$LN5@snextc:

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

  00028	85 c0		 test	 eax, eax
  0002a	74 1b		 je	 SHORT $LN17@snextc
  0002c	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0002f	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00032	7e 13		 jle	 SHORT $LN17@snextc
  00034	8b c2		 mov	 eax, edx
  00036	ff 08		 dec	 DWORD PTR [eax]
  00038	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00040	89 10		 mov	 DWORD PTR [eax], edx
  00042	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00045	eb 09		 jmp	 SHORT $LN18@snextc
$LN17@snextc:
  00047	8b 06		 mov	 eax, DWORD PTR [esi]
  00049	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0004c	8b ce		 mov	 ecx, esi
  0004e	ff d2		 call	 edx
$LN18@snextc:
  00050	83 f8 ff	 cmp	 eax, -1
  00053	75 04		 jne	 SHORT $LN3@snextc
  00055	0b c0		 or	 eax, eax
  00057	5e		 pop	 esi

; 168  : 		}

  00058	c3		 ret	 0
$LN3@snextc:

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

  00059	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0005c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005f	74 0f		 je	 SHORT $LN35@snextc
  00061	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00064	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00067	7e 07		 jle	 SHORT $LN35@snextc
  00069	8b 10		 mov	 edx, DWORD PTR [eax]
  0006b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0006e	5e		 pop	 esi

; 168  : 		}

  0006f	c3		 ret	 0

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

$LN35@snextc:
  00070	8b 06		 mov	 eax, DWORD PTR [esi]
  00072	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00075	8b ce		 mov	 ecx, esi
  00077	5e		 pop	 esi
  00078	ff e2		 jmp	 edx
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::snextc
_TEXT	ENDS
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator->
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator->, COMDAT
; _this$ = ecx

; 401  : 		return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 402  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator->
_TEXT	ENDS
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKVTokenizerSection@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator->
; Function compile flags: /Ogtp
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKVTokenizerSection@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKVTokenizerSection@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator->, COMDAT
; _this$ = ecx

; 401  : 		return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 402  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBKVTokenizerSection@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator->
_TEXT	ENDS
PUBLIC	??1?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $LN14@Pair_base
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN14@Pair_base:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi
  00025	c3		 ret	 0
??1?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1351 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1352 : 		return (_STRING_ITERATOR(_Myptr()));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	72 02		 jb	 SHORT $LN5@begin
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN5@begin:
  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 1353 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >
_TEXT	ENDS
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA DD 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
_BSS	ENDS
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
__File$ = 8						; size = 4
__Which$ = 12						; size = 4
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 555  : 		{	// initialize to C stream _File after {new, open, close}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 556  : 		__PURE_APPDOMAIN_GLOBAL static _Myst _Stinit;	// initial state
; 557  : 
; 558  : 		_Closef = _Which == _Openfl;

  00003	83 7d 0c 01	 cmp	 DWORD PTR __Which$[ebp], 1

; 559  : 		_Wrotesome = false;
; 560  : 
; 561  : 		_Mysb::_Init();	// initialize stream buffer base object

  00007	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	8d 51 18	 lea	 edx, DWORD PTR [ecx+24]
  00010	89 51 20	 mov	 DWORD PTR [ecx+32], edx
  00013	8d 51 1c	 lea	 edx, DWORD PTR [ecx+28]
  00016	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  00019	0f 94 c0	 sete	 al
  0001c	88 41 50	 mov	 BYTE PTR [ecx+80], al
  0001f	8d 51 28	 lea	 edx, DWORD PTR [ecx+40]
  00022	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00025	c6 41 49 00	 mov	 BYTE PTR [ecx+73], 0
  00029	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  0002c	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0002f	8d 51 2c	 lea	 edx, DWORD PTR [ecx+44]
  00032	89 51 34	 mov	 DWORD PTR [ecx+52], edx
  00035	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0003b	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0003e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00044	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0004d	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00050	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00056	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00059	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0005f	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00062	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 562  : 
; 563  :  #ifndef _IORCNT
; 564  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 565  :   #define _IOWCNT _IOCNT
; 566  :  #endif /* _IORCNT */
; 567  : 
; 568  :   #pragma warning(push)
; 569  :   #pragma warning(disable: 6240)	/* prefast noise VSW 489858 */
; 570  : 		if (_File != 0 && sizeof (_Elem) == 1)

  00068	8b 45 08	 mov	 eax, DWORD PTR __File$[ebp]
  0006b	85 c0		 test	 eax, eax
  0006d	74 18		 je	 SHORT $LN10@Init@2

; 571  :   #pragma warning(pop)
; 572  : 
; 573  : 			{	// point inside C stream with [first, first + count) buffer
; 574  : 			_Elem **_Pb = (_Elem **)&_File->_IOBASE;

  0006f	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 575  : 			_Elem **_Pn = (_Elem **)&_File->_IOPTR;
; 576  : 			int *_Nr = (int *)&_File->_IORCNT;
; 577  : 			int *_Nw = (int *)&_File->_IOWCNT;
; 578  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);

  00072	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00075	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00078	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0007b	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0007e	89 41 24	 mov	 DWORD PTR [ecx+36], eax
  00081	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00084	89 51 34	 mov	 DWORD PTR [ecx+52], edx
$LN10@Init@2:

; 579  : 			}
; 580  : 
; 581  : 		_Myfile = _File;

  00087	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 582  : 		_State = _Stinit;

  0008a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  00090	89 51 4c	 mov	 DWORD PTR [ecx+76], edx

; 583  : 		_Pcvt = 0;	// pointer to codecvt facet

  00093	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 584  : 		}

  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
; Function compile flags: /Ogtp
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z
_TEXT	SEGMENT
__Newpcvt$ = 8						; size = 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT
; _this$ = ecx

; 628  : 		{	// initialize codecvt pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 629  : 		if (_Newpcvt->always_noconv())

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Newpcvt$[ebp]
  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0000d	8b f1		 mov	 esi, ecx
  0000f	8b cf		 mov	 ecx, edi
  00011	ff d2		 call	 edx
  00013	84 c0		 test	 al, al
  00015	74 0d		 je	 SHORT $LN2@Initcvt

; 630  : 			_Pcvt = 0;	// nothing to do

  00017	5f		 pop	 edi
  00018	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
  0001f	5e		 pop	 esi

; 635  : 			}
; 636  : 		}

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN2@Initcvt:

; 631  : 		else
; 632  : 			{	// set up for nontrivial codecvt facet
; 633  : 			_Pcvt = _Newpcvt;
; 634  : 			_Mysb::_Init();	// reset any buffering

  00024	8b ce		 mov	 ecx, esi
  00026	89 7e 44	 mov	 DWORD PTR [esi+68], edi
  00029	e8 00 00 00 00	 call	 ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 635  : 			}
; 636  : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
PUBLIC	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
EXTRN	??0_Mutex@std@@QAE@XZ:PROC			; std::_Mutex::_Mutex
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0
__ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Lock$158585 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 25   : 		{	// construct with no buffers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  00036	e8 00 00 00 00	 call	 ??0_Mutex@std@@QAE@XZ	; std::_Mutex::_Mutex
  0003b	6a 04		 push	 4
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00049	8b f8		 mov	 edi, eax
  0004b	83 c4 04	 add	 esp, 4
  0004e	85 ff		 test	 edi, edi
  00050	74 2e		 je	 SHORT $LN3@basic_stre@2
  00052	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Init
  00057	89 07		 mov	 DWORD PTR [edi], eax
  00059	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0005e	6a 00		 push	 0
  00060	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$158585[ebp]
  00063	8b d8		 mov	 ebx, eax
  00065	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  0006a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0006d	83 f8 ff	 cmp	 eax, -1
  00070	73 04		 jae	 SHORT $LN8@basic_stre@2
  00072	40		 inc	 eax
  00073	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN8@basic_stre@2:
  00076	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$158585[ebp]
  00079	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0007e	eb 02		 jmp	 SHORT $LN4@basic_stre@2
$LN3@basic_stre@2:
  00080	33 ff		 xor	 edi, edi
$LN4@basic_stre@2:

; 26   : 		_Init();

  00082	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00085	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00088	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  0008b	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  0008e	8d 56 1c	 lea	 edx, DWORD PTR [esi+28]
  00091	89 56 24	 mov	 DWORD PTR [esi+36], edx
  00094	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  00097	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0009a	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0009d	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  000a0	89 4e 30	 mov	 DWORD PTR [esi+48], ecx
  000a3	8d 56 2c	 lea	 edx, DWORD PTR [esi+44]
  000a6	89 56 34	 mov	 DWORD PTR [esi+52], edx
  000a9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000af	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000b2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000b8	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  000bb	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000c1	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  000c4	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  000ca	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000cd	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000d3	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  000d6	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 27   : 		}

  000dc	8b c6		 mov	 eax, esi
  000de	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e8	59		 pop	 ecx
  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1_Mutex@std@@QAE@XZ	; std::_Mutex::~_Mutex
__ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 807  : 		return (iterator(_Lmost(), this));

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound
; Function compile flags: /Ogtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1742 : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00009	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0000d	75 19		 jne	 SHORT $LN3@Lbound
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL4@Lbound:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	73 05		 jae	 SHORT $LN2@Lbound

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  0001c	eb 04		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00026	74 ec		 je	 SHORT $LL4@Lbound
$LN3@Lbound:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
$T158726 = -16						; size = 12
$T158712 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  00009	6a 30		 push	 48			; 00000030H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN15@Tree_val@2
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 2c	 mov	 BYTE PTR [ecx+44], al

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 2d	 mov	 BYTE PTR [edx+45], al

; 551  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val@2:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T158712[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T158726[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T158712[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T158726[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T158726[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val@2:
$LN36@Tree_val@2:
  0006e	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lbound
; Function compile flags: /Ogtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1742 : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00009	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000d	75 19		 jne	 SHORT $LN3@Lbound@2
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL4@Lbound@2:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	73 05		 jae	 SHORT $LN2@Lbound@2

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  0001c	eb 04		 jmp	 SHORT $LN1@Lbound@2
$LN2@Lbound@2:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound@2:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00026	74 ec		 je	 SHORT $LL4@Lbound@2
$LN3@Lbound@2:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z
_TEXT	SEGMENT
$T158845 = -16						; size = 12
$T158828 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN15@Tree_val@3
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 551  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val@3:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T158828[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T158845[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T158828[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T158845[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T158845[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val@3:
$LN36@Tree_val@3:
  0006e	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lbound
; Function compile flags: /Ogtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1742 : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00009	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000d	75 19		 jne	 SHORT $LN3@Lbound@3
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL4@Lbound@3:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	73 05		 jae	 SHORT $LN2@Lbound@3

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  0001c	eb 04		 jmp	 SHORT $LN1@Lbound@3
$LN2@Lbound@3:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound@3:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00026	74 ec		 je	 SHORT $LL4@Lbound@3
$LN3@Lbound@3:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
$T159025 = -40						; size = 12
__Newres$ = -28						; size = 4
$T159008 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1919 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi

; 1920 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f0		 mov	 esi, eax
  00035	83 ce 0f	 or	 esi, 15			; 0000000fH

; 1921 : 		if (max_size() < _Newres)

  00038	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0003b	76 04		 jbe	 SHORT $LN9@Copy

; 1922 : 			_Newres = _Newsize;	// undo roundup if too big

  0003d	8b f0		 mov	 esi, eax
  0003f	eb 27		 jmp	 SHORT $LN39@Copy
$LN9@Copy:

; 1923 : 		else if (this->_Myres / 2 <= _Newres / 3)

  00041	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]
  00044	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00049	f7 e6		 mul	 esi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	d1 e9		 shr	 ecx, 1
  0004f	d1 ea		 shr	 edx, 1
  00051	3b ca		 cmp	 ecx, edx
  00053	76 13		 jbe	 SHORT $LN39@Copy

; 1924 : 			;
; 1925 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0005a	2b c1		 sub	 eax, ecx

; 1926 : 			_Newres = this->_Myres
; 1927 : 				+ this->_Myres / 2;	// grow exponentially if possible

  0005c	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]
  0005f	3b d8		 cmp	 ebx, eax
  00061	76 05		 jbe	 SHORT $LN39@Copy

; 1928 : 		else
; 1929 : 			_Newres = max_size();	// settle for max_size()

  00063	be fe ff ff ff	 mov	 esi, -2			; fffffffeH
$LN39@Copy:

; 1930 : 
; 1931 : 		_Elem *_Ptr;
; 1932 : 		_TRY_BEGIN

  00068	33 c0		 xor	 eax, eax

; 1933 : 			_Ptr = this->_Alval.allocate(_Newres + 1);

  0006a	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0006d	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  00070	3b c8		 cmp	 ecx, eax
  00072	76 12		 jbe	 SHORT $LN47@Copy
  00074	83 f9 ff	 cmp	 ecx, -1
  00077	77 12		 ja	 SHORT $LN46@Copy
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007f	83 c4 04	 add	 esp, 4
  00082	85 c0		 test	 eax, eax
  00084	74 05		 je	 SHORT $LN46@Copy
$LN47@Copy:
  00086	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  00089	eb 51		 jmp	 SHORT $LN19@Copy
$LN46@Copy:
  0008b	8d 4d e8	 lea	 ecx, DWORD PTR $T159008[ebp]
  0008e	51		 push	 ecx
  0008f	8d 4d d8	 lea	 ecx, DWORD PTR $T159025[ebp]
  00092	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T159008[ebp], 0
  00099	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0009e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000a3	8d 55 d8	 lea	 edx, DWORD PTR $T159025[ebp]
  000a6	52		 push	 edx
  000a7	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T159025[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN112@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 1934 : 		_CATCH_ALL
; 1935 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000b3	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 1936 : 			_TRY_BEGIN
; 1937 : 				_Ptr = this->_Alval.allocate(_Newres + 1);

  000b6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	89 45 e4	 mov	 DWORD PTR __Newres$[ebp], eax
  000bc	40		 inc	 eax
  000bd	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  000c0	50		 push	 eax
  000c1	83 c1 18	 add	 ecx, 24			; 00000018H
  000c4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000c8	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  000cd	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax

; 1941 : 			_CATCH_END
; 1942 : 		_CATCH_END

  000d0	b8 00 00 00 00	 mov	 eax, $LN107@Copy
  000d5	c3		 ret	 0
$LN107@Copy:
  000d6	8b 7d ec	 mov	 edi, DWORD PTR _this$[ebp]
  000d9	8b 75 e4	 mov	 esi, DWORD PTR __Newres$[ebp]
$LN19@Copy:

; 1943 : 
; 1944 : 		if (0 < _Oldlen)

  000dc	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  000df	85 db		 test	 ebx, ebx
  000e1	74 1a		 je	 SHORT $LN78@Copy

; 1945 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  000e3	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  000e7	72 04		 jb	 SHORT $LN76@Copy
  000e9	8b 07		 mov	 eax, DWORD PTR [edi]
  000eb	eb 02		 jmp	 SHORT $LN77@Copy
$LN76@Copy:
  000ed	8b c7		 mov	 eax, edi
$LN77@Copy:
  000ef	53		 push	 ebx
  000f0	50		 push	 eax
  000f1	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _memcpy
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN78@Copy:

; 1946 : 		_Tidy(true);

  000fd	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00101	72 0b		 jb	 SHORT $LN88@Copy
  00103	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00105	51		 push	 ecx
  00106	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0010b	83 c4 04	 add	 esp, 4
$LN88@Copy:

; 1947 : 		this->_Bx._Ptr = _Ptr;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00111	c6 07 00	 mov	 BYTE PTR [edi], 0
  00114	89 07		 mov	 DWORD PTR [edi], eax

; 1948 : 		this->_Myres = _Newres;

  00116	89 77 14	 mov	 DWORD PTR [edi+20], esi

; 1949 : 		_Eos(_Oldlen);

  00119	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
  0011c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0011f	72 02		 jb	 SHORT $LN102@Copy
  00121	8b f8		 mov	 edi, eax
$LN102@Copy:
  00123	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 1950 : 		}

  00127	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0012a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00131	59		 pop	 ecx
  00132	5f		 pop	 edi
  00133	5e		 pop	 esi
  00134	5b		 pop	 ebx
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 1938 : 			_CATCH_ALL
; 1939 : 			_Tidy(true);	// failed again, discard storage and reraise

  0013b	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0013e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00142	72 0b		 jb	 SHORT $LN64@Copy
  00144	8b 16		 mov	 edx, DWORD PTR [esi]
  00146	52		 push	 edx
  00147	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0014c	83 c4 04	 add	 esp, 4
$LN64@Copy:

; 1940 : 			_RERAISE;

  0014f	6a 00		 push	 0
  00151	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00158	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0015f	6a 00		 push	 0
  00161	c6 06 00	 mov	 BYTE PTR [esi], 0
  00164	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN113@Copy:
$LN111@Copy:
  00169	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator++
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 272  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++

; 273  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 274  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 272  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++

; 273  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 274  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
EXTRN	??0bad_cast@std@@QAE@PBD@Z:PROC			; std::bad_cast::bad_cast
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	??1bad_cast@std@@UAE@XZ:PROC			; std::bad_cast::~bad_cast
EXTRN	??0bad_cast@std@@QAE@ABV01@@Z:PROC		; std::bad_cast::bad_cast
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T159193 = -36						; size = 12
__Lock$150864 = -24					; size = 4
__Lock$159200 = -20					; size = 4
__Psave$150865 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Lock$159222 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 504  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 505  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$150864[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 506  : 		const locale::facet *_Psave =
; 507  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 508  : 
; 509  : 		size_t _Id = _Facet::id;

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, 0 ; std::ctype<char>::id
  00039	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	89 5d f0	 mov	 DWORD PTR __Psave$150865[ebp], ebx
  00049	75 2b		 jne	 SHORT $LN11@use_facet
  0004b	6a 00		 push	 0
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$159200[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, 0 ; std::ctype<char>::id
  0005c	75 10		 jne	 SHORT $LN10@use_facet
  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00063	40		 inc	 eax
  00064	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00069	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN10@use_facet:
  0006e	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$159200[ebp]
  00071	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN11@use_facet:

; 510  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00076	8b 7d 08	 mov	 edi, DWORD PTR __Loc$[ebp]
  00079	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
  0007f	8b 07		 mov	 eax, DWORD PTR [edi]
  00081	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  00084	73 22		 jae	 SHORT $LN20@use_facet
  00086	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00089	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  0008c	85 c9		 test	 ecx, ecx
  0008e	75 1c		 jne	 SHORT $LN16@use_facet
$LN30@use_facet:
  00090	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  00094	74 16		 je	 SHORT $LN16@use_facet
  00096	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009b	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  0009e	73 12		 jae	 SHORT $LN31@use_facet
  000a0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000a3	8b 34 b2	 mov	 esi, DWORD PTR [edx+esi*4]
  000a6	eb 06		 jmp	 SHORT $LN15@use_facet
$LN20@use_facet:
  000a8	33 c9		 xor	 ecx, ecx
  000aa	eb e4		 jmp	 SHORT $LN30@use_facet
$LN16@use_facet:
  000ac	8b f1		 mov	 esi, ecx
$LN15@use_facet:

; 511  : 
; 512  : 		if (_Pf != 0)

  000ae	85 f6		 test	 esi, esi
  000b0	75 65		 jne	 SHORT $LN28@use_facet
$LN31@use_facet:

; 513  : 			;	// got facet from locale
; 514  : 		else if (_Psave != 0)

  000b2	85 db		 test	 ebx, ebx
  000b4	74 04		 je	 SHORT $LN4@use_facet

; 515  : 			_Pf = _Psave;	// lazy facet already allocated

  000b6	8b f3		 mov	 esi, ebx
  000b8	eb 5d		 jmp	 SHORT $LN28@use_facet
$LN4@use_facet:

; 516  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000ba	8d 45 f0	 lea	 eax, DWORD PTR __Psave$150865[ebp]
  000bd	57		 push	 edi
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
  000c4	83 c4 08	 add	 esp, 8
  000c7	83 f8 ff	 cmp	 eax, -1
  000ca	75 1b		 jne	 SHORT $LN2@use_facet

; 517  : 
; 518  :  #if _HAS_EXCEPTIONS
; 519  : 
; 520  : 			_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000d1	8d 4d dc	 lea	 ecx, DWORD PTR $T159193[ebp]
  000d4	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@PBD@Z ; std::bad_cast::bad_cast
  000d9	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000de	8d 4d dc	 lea	 ecx, DWORD PTR $T159193[ebp]
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@use_facet:
$LN2@use_facet:

; 521  : 
; 522  :  #else /* _HAS_EXCEPTIONS */
; 523  : 			abort();	// lazy disallowed
; 524  :  #endif /* _HAS_EXCEPTIONS */
; 525  : 
; 526  : 		else
; 527  : 			{	// queue up lazy facet for destruction
; 528  : 			_Pf = _Psave;

  000e7	8b 75 f0	 mov	 esi, DWORD PTR __Psave$150865[ebp]

; 529  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 530  : 
; 531  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 532  : 			_Pfmod->_Incref();

  000ea	6a 00		 push	 0
  000ec	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$159222[ebp]
  000ef	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
  000f5	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  000fa	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000fd	83 f8 ff	 cmp	 eax, -1
  00100	73 04		 jae	 SHORT $LN24@use_facet
  00102	40		 inc	 eax
  00103	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN24@use_facet:
  00106	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$159222[ebp]
  00109	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit

; 533  : 			_Pfmod->_Register();

  0010e	56		 push	 esi
  0010f	e8 00 00 00 00	 call	 ?_Facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::_Facet_Register
  00114	83 c4 04	 add	 esp, 4
$LN28@use_facet:

; 534  : 			}
; 535  : 
; 536  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00117	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$150864[ebp]
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00121	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00126	8b c6		 mov	 eax, esi

; 537  : 	_END_LOCK()
; 538  : 	}

  00128	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00132	59		 pop	 ecx
  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
$LN36@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$150864[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\string
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 186  : 	{	// test for string vs. NTCS equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 	return (_Left.compare(_Right) == 0);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000c	8d 64 24 00	 npad	 4
$LL7@operator@8:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL7@operator@8
  00017	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001a	2b c6		 sub	 eax, esi
  0001c	50		 push	 eax
  0001d	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00020	52		 push	 edx
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00029	f7 d8		 neg	 eax
  0002b	1b c0		 sbb	 eax, eax
  0002d	40		 inc	 eax
  0002e	5e		 pop	 esi

; 188  : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::codecvt<char,char,int>::_Getcat
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T159257 = -52						; size = 36
$T159261 = -16						; size = 4
$T159256 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::codecvt<char,char,int>::_Getcat, COMDAT

; 849  : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 850  : 		if (_Ppf != 0 && *_Ppf == 0)

  00027	8b 45 08	 mov	 eax, DWORD PTR __Ppf$[ebp]
  0002a	33 db		 xor	 ebx, ebx
  0002c	89 5d f0	 mov	 DWORD PTR $T159261[ebp], ebx
  0002f	85 c0		 test	 eax, eax
  00031	74 65		 je	 SHORT $LN26@Getcat@2
  00033	39 18		 cmp	 DWORD PTR [eax], ebx
  00035	75 61		 jne	 SHORT $LN26@Getcat@2

; 851  : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 852  : 				_Locinfo(_Ploc->c_str()));

  00037	6a 08		 push	 8
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	8b f0		 mov	 esi, eax
  00040	83 c4 04	 add	 esp, 4
  00043	89 75 f0	 mov	 DWORD PTR $T159256[ebp], esi
  00046	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00049	85 f6		 test	 esi, esi
  0004b	74 30		 je	 SHORT $LN4@Getcat@2
  0004d	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00055	85 c9		 test	 ecx, ecx
  00057	74 04		 je	 SHORT $LN14@Getcat@2
  00059	8b c1		 mov	 eax, ecx
  0005b	eb 03		 jmp	 SHORT $LN15@Getcat@2
$LN14@Getcat@2:
  0005d	83 c0 1c	 add	 eax, 28			; 0000001cH
$LN15@Getcat@2:
  00060	50		 push	 eax
  00061	8d 4d cc	 lea	 ecx, DWORD PTR $T159257[ebp]
  00064	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00069	bb 01 00 00 00	 mov	 ebx, 1
  0006e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00075	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$codecvt@DDH@std@@6B@
  0007b	eb 02		 jmp	 SHORT $LN5@Getcat@2
$LN4@Getcat@2:
  0007d	33 f6		 xor	 esi, esi
$LN5@Getcat@2:
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR __Ppf$[ebp]
  00082	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00089	89 31		 mov	 DWORD PTR [ecx], esi
  0008b	f6 c3 01	 test	 bl, 1
  0008e	74 08		 je	 SHORT $LN26@Getcat@2
  00090	8d 4d cc	 lea	 ecx, DWORD PTR $T159257[ebp]
  00093	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN26@Getcat@2:

; 853  : 		return (_X_CTYPE);

  00098	b8 02 00 00 00	 mov	 eax, 2

; 854  : 		}

  0009d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a7	59		 pop	 ecx
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T159256[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::codecvt<char,char,int>::_Getcat
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 807  : 		return (iterator(_Lmost(), this));

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::begin
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 267  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 306  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 419  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 421  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 228  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>
; Function compile flags: /Ogtp
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 228  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>
; Function compile flags: /Ogtp
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 228  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??1?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $LN14@Pair_base@2
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN14@Pair_base@2:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi
  00025	c3		 ret	 0
??1?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T159533 = -16						; size = 12
$T159510 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00007	6a 28		 push	 40			; 00000028H
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 1a		 je	 SHORT $LN5@Buynode@3

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00024	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00027	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  0002a	66 89 48 24	 mov	 WORD PTR [eax+36], cx
  0002e	5e		 pop	 esi

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode@3:
  00033	8d 45 fc	 lea	 eax, DWORD PTR $T159510[ebp]
  00036	89 4d fc	 mov	 DWORD PTR $T159510[ebp], ecx
  00039	50		 push	 eax
  0003a	8d 4d f0	 lea	 ecx, DWORD PTR $T159533[ebp]
  0003d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00042	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00047	8d 4d f0	 lea	 ecx, DWORD PTR $T159533[ebp]
  0004a	51		 push	 ecx
  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T159533[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00052	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode@3:
$LN26@Buynode@3:
  00057	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z
_TEXT	SEGMENT
$T159659 = -16						; size = 12
$T159594 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN20@Tree
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 699  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 698  : 		{	// construct empty tree

$LN20@Tree:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T159594[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T159659[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T159594[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T159659[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T159659[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@Tree:
$LN42@Tree:
  0006e	cc		 int	 3
??0?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 272  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++

; 273  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 274  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 570  : 		{	// flush output stream

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 571  : 		ios_base::iostate _State = ios_base::goodbit;
; 572  : 		if (!ios_base::fail() && _Myios::rdbuf()->pubsync() == -1)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	f6 44 30 0c 06	 test	 BYTE PTR [eax+esi+12], 6
  00010	75 17		 jne	 SHORT $LN1@flush
  00012	8b 44 30 38	 mov	 eax, DWORD PTR [eax+esi+56]
  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	8b c8		 mov	 ecx, eax
  0001a	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0001d	ff d0		 call	 eax
  0001f	83 f8 ff	 cmp	 eax, -1
  00022	75 05		 jne	 SHORT $LN1@flush

; 573  : 			_State |= ios_base::badbit;	// sync failed

  00024	bf 04 00 00 00	 mov	 edi, 4
$LN1@flush:

; 574  : 		_Myios::setstate(_State);

  00029	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002e	03 ce		 add	 ecx, esi
  00030	85 ff		 test	 edi, edi
  00032	74 16		 je	 SHORT $LN21@flush
  00034	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00037	0b c7		 or	 eax, edi
  00039	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0003d	75 03		 jne	 SHORT $LN19@flush
  0003f	83 c8 04	 or	 eax, 4
$LN19@flush:
  00042	6a 00		 push	 0
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN21@flush:

; 575  : 		return (*this);

  0004a	5f		 pop	 edi
  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi

; 576  : 		}

  0004e	c3		 ret	 0
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (iterator(this->_Myhead, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 818  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (iterator(this->_Myhead, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 818  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::end
_TEXT	ENDS
PUBLIC	??1?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
;	COMDAT ??1?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $LN16@pair
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN16@pair:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi
  00025	c3		 ret	 0
??1?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0
__ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
xdata$x	ENDS
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT
__Lock$159915 = -20					; size = 4
$T159891 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Byte$ = 8						; size = 1
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT
; _this$ = ecx

; 124  : 		{	// convert _Byte to character using imbued locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 125  : 		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);

  00028	8d 45 f0	 lea	 eax, DWORD PTR $T159891[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00031	50		 push	 eax
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00039	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0003e	8b 7d f0	 mov	 edi, DWORD PTR $T159891[ebp]
  00041	83 c4 04	 add	 esp, 4
  00044	8b d8		 mov	 ebx, eax
  00046	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004d	85 ff		 test	 edi, edi
  0004f	74 39		 je	 SHORT $LN7@widen
  00051	6a 00		 push	 0
  00053	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$159915[ebp]
  00056	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  0005b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0005e	85 c0		 test	 eax, eax
  00060	74 09		 je	 SHORT $LN9@widen
  00062	83 f8 ff	 cmp	 eax, -1
  00065	73 04		 jae	 SHORT $LN9@widen
  00067	48		 dec	 eax
  00068	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN9@widen:
  0006b	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0006e	f7 de		 neg	 esi
  00070	1b f6		 sbb	 esi, esi
  00072	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$159915[ebp]
  00075	f7 d6		 not	 esi
  00077	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0007c	23 f7		 and	 esi, edi
  0007e	74 0a		 je	 SHORT $LN7@widen
  00080	8b 16		 mov	 edx, DWORD PTR [esi]
  00082	8b 02		 mov	 eax, DWORD PTR [edx]
  00084	6a 01		 push	 1
  00086	8b ce		 mov	 ecx, esi
  00088	ff d0		 call	 eax
$LN7@widen:

; 126  : 		return (_Ctype_fac.widen(_Byte));

  0008a	8b 13		 mov	 edx, DWORD PTR [ebx]
  0008c	8b 45 08	 mov	 eax, DWORD PTR __Byte$[ebp]
  0008f	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00092	50		 push	 eax
  00093	8b cb		 mov	 ecx, ebx
  00095	ff d2		 call	 edx

; 127  : 		}

  00097	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a1	59		 pop	 ecx
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR $T159891[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$12 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0
__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$12
__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T159930 = 8						; size = 4
__Noskip$ = 8						; size = 1
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT
; _this$ = ecx

; 116  : 		{	// test stream state and skip whitespace as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 117  : 		if (ios_base::good())

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00035	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
  00039	03 ce		 add	 ecx, esi
  0003b	85 c0		 test	 eax, eax
  0003d	0f 85 28 01 00
	00		 jne	 $LN1@Ipfx

; 118  : 			{	// state okay, flush tied stream and skip whitespace
; 119  : 			if (_Myios::tie() != 0)

  00043	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  00046	85 c9		 test	 ecx, ecx
  00048	74 05		 je	 SHORT $LN10@Ipfx

; 120  : 				_Myios::tie()->flush();

  0004a	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN10@Ipfx:

; 121  : 
; 122  : 			if (!_Noskip && ios_base::flags() & ios_base::skipws)

  0004f	80 7d 08 00	 cmp	 BYTE PTR __Noskip$[ebp], 0
  00053	0f 85 a0 00 00
	00		 jne	 $LN17@Ipfx
  00059	8b 06		 mov	 eax, DWORD PTR [esi]
  0005b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005e	8b 4c 32 14	 mov	 ecx, DWORD PTR [edx+esi+20]
  00062	f6 c1 01	 test	 cl, 1
  00065	0f 84 8e 00 00
	00		 je	 $LN17@Ipfx

; 123  : 				{	// skip whitespace
; 124  : 				const _Ctype& _Ctype_fac = _USE(ios_base::getloc(), _Ctype);

  0006b	8d 4d 08	 lea	 ecx, DWORD PTR $T159930[ebp]
  0006e	51		 push	 ecx
  0006f	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  00072	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00077	50		 push	 eax
  00078	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0007f	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00084	83 c4 04	 add	 esp, 4
  00087	8d 4d 08	 lea	 ecx, DWORD PTR $T159930[ebp]
  0008a	8b f8		 mov	 edi, eax
  0008c	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 125  : 
; 126  : 				_TRY_IO_BEGIN
; 127  : 				int_type _Meta = _Myios::rdbuf()->sgetc();

  00091	8b 16		 mov	 edx, DWORD PTR [esi]
  00093	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00096	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  0009a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0009d	83 38 00	 cmp	 DWORD PTR [eax], 0
  000a0	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  000a7	74 0f		 je	 SHORT $LN33@Ipfx
  000a9	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000ac	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000af	7e 07		 jle	 SHORT $LN33@Ipfx
  000b1	8b 00		 mov	 eax, DWORD PTR [eax]
  000b3	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000b6	eb 08		 jmp	 SHORT $LL144@Ipfx
$LN33@Ipfx:
  000b8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ba	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000bd	ff d2		 call	 edx
  000bf	90		 npad	 1
$LL144@Ipfx:

; 130  : 					if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000c0	83 f8 ff	 cmp	 eax, -1
  000c3	75 21		 jne	 SHORT $LN4@Ipfx

; 131  : 						{	// end of file, quit
; 132  : 						_Myios::setstate(ios_base::eofbit);

  000c5	8b 06		 mov	 eax, DWORD PTR [esi]
  000c7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ca	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
  000ce	03 ce		 add	 ecx, esi
  000d0	83 c8 01	 or	 eax, 1
  000d3	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  000d7	75 03		 jne	 SHORT $LN56@Ipfx
  000d9	83 c8 04	 or	 eax, 4
$LN56@Ipfx:
  000dc	6a 00		 push	 0
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 133  : 						break;

  000e4	eb 0c		 jmp	 SHORT $LN5@Ipfx
$LN4@Ipfx:

; 134  : 						}
; 135  : 					else if (!_Ctype_fac.is(_Ctype::space,
; 136  : 						_Traits::to_char_type(_Meta)))

  000e6	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  000e9	0f b6 c8	 movzx	 ecx, al
  000ec	f6 04 4a 48	 test	 BYTE PTR [edx+ecx*2], 72 ; 00000048H
  000f0	75 2a		 jne	 SHORT $LN6@Ipfx
$LN5@Ipfx:
  000f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN17@Ipfx:

; 139  : 				}
; 140  : 
; 141  : 			if (ios_base::good())

  000f9	8b 06		 mov	 eax, DWORD PTR [esi]
  000fb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fe	03 ce		 add	 ecx, esi
  00100	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00104	75 65		 jne	 SHORT $LN1@Ipfx

; 142  : 				return (true);

  00106	b0 01		 mov	 al, 1

; 146  : 		}

  00108	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0010b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00112	59		 pop	 ecx
  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c2 04 00	 ret	 4
$LN6@Ipfx:

; 128  : 
; 129  : 				for (; ; _Meta = _Myios::rdbuf()->snextc())

  0011c	8b 06		 mov	 eax, DWORD PTR [esi]
  0011e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00121	8b 4c 31 38	 mov	 ecx, DWORD PTR [ecx+esi+56]
  00125	e8 00 00 00 00	 call	 ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
  0012a	eb 94		 jmp	 SHORT $LL144@Ipfx
__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0:

; 137  : 						break;	// not whitespace, quit
; 138  : 				_CATCH_IO_END

  0012c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00131	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00134	03 c1		 add	 eax, ecx
  00136	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00139	83 c9 04	 or	 ecx, 4
  0013c	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00140	75 03		 jne	 SHORT $LN69@Ipfx
  00142	83 c9 04	 or	 ecx, 4
$LN69@Ipfx:
  00145	83 e1 17	 and	 ecx, 23			; 00000017H
  00148	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0014b	85 48 10	 test	 DWORD PTR [eax+16], ecx
  0014e	75 12		 jne	 SHORT $LN78@Ipfx
  00150	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00157	b8 00 00 00 00	 mov	 eax, $LN18@Ipfx
  0015c	c3		 ret	 0
$LN18@Ipfx:
  0015d	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00160	eb 97		 jmp	 SHORT $LN17@Ipfx
$LN78@Ipfx:
  00162	6a 00		 push	 0
  00164	6a 00		 push	 0
  00166	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN151@Ipfx:
$LN1@Ipfx:

; 143  : 			}
; 144  : 		_Myios::setstate(ios_base::failbit);

  0016b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0016e	83 c8 02	 or	 eax, 2
  00171	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00175	75 03		 jne	 SHORT $LN140@Ipfx
  00177	83 c8 04	 or	 eax, 4
$LN140@Ipfx:
  0017a	6a 00		 push	 0
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 145  : 		return (false);

  00182	32 c0		 xor	 al, al

; 146  : 		}

  00184	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00187	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0018e	59		 pop	 ecx
  0018f	5f		 pop	 edi
  00190	5e		 pop	 esi
  00191	5b		 pop	 ebx
  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c2 04 00	 ret	 4
$LN150@Ipfx:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR $T159930[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
$T160475 = -16						; size = 12
$T160416 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 30		 push	 48			; 00000030H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN20@Tree@2
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 2c	 mov	 BYTE PTR [ecx+44], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 2d	 mov	 BYTE PTR [edx+45], al

; 699  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 698  : 		{	// construct empty tree

$LN20@Tree@2:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T160416[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T160475[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T160416[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T160475[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T160475[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@Tree@2:
$LN42@Tree@2:
  0006e	cc		 int	 3
??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::lower_bound
; Function compile flags: /Ogtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0000d	75 19		 jne	 SHORT $LN36@lower_boun
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL6@lower_boun:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	73 05		 jae	 SHORT $LN4@lower_boun
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN4@lower_boun:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun:
  00022	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00026	74 ec		 je	 SHORT $LL6@lower_boun
$LN36@lower_boun:
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z
_TEXT	SEGMENT
$T160693 = -16						; size = 12
$T160627 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN20@Tree@3
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 699  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 698  : 		{	// construct empty tree

$LN20@Tree@3:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T160627[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T160693[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T160627[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T160693[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T160693[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@Tree@3:
$LN42@Tree@3:
  0006e	cc		 int	 3
??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (iterator(this->_Myhead, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 818  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::end
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::lower_bound
; Function compile flags: /Ogtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0000d	75 19		 jne	 SHORT $LN36@lower_boun@2
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL6@lower_boun@2:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	73 05		 jae	 SHORT $LN4@lower_boun@2
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $LN3@lower_boun@2
$LN4@lower_boun@2:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun@2:
  00022	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00026	74 ec		 je	 SHORT $LL6@lower_boun@2
$LN36@lower_boun@2:
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::lower_bound
; Function compile flags: /Ogtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0000d	75 19		 jne	 SHORT $LN36@lower_boun@3
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL6@lower_boun@3:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	73 05		 jae	 SHORT $LN4@lower_boun@3
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $LN3@lower_boun@3
$LN4@lower_boun@3:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun@3:
  00022	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00026	74 ec		 je	 SHORT $LL6@lower_boun@3
$LN36@lower_boun@3:
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
	DD	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
_TEXT	SEGMENT
__File$ = 8						; size = 4
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 152  : 		{	// construct from pointer to C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >

; 153  : 		_Init(_File, _Newfl);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __File$[ebp]
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	8b ce		 mov	 ecx, esi
  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00019	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 154  : 		}

  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z		; std::_Fgetc<char>
EXTRN	_fgetc:PROC
; Function compile flags: /Ogtp
;	COMDAT ??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 4
__File$ = 12						; size = 4
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT

; 35   : 	{	// get a char element from a C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   : 	int _Meta;
; 37   : 	if ((_Meta = fgetc(_File)) == EOF)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __File$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _fgetc
  0000c	83 c4 04	 add	 esp, 4
  0000f	83 f8 ff	 cmp	 eax, -1
  00012	75 04		 jne	 SHORT $LN2@Fgetc

; 38   : 		return (false);

  00014	32 c0		 xor	 al, al

; 43   : 		}
; 44   : 	}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN2@Fgetc:

; 39   : 	else
; 40   : 		{	// got one, convert to char
; 41   : 		_Byte = (char)_Meta;

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Byte$[ebp]
  0001b	88 01		 mov	 BYTE PTR [ecx], al

; 42   : 		return (true);

  0001d	b0 01		 mov	 al, 1

; 43   : 		}
; 44   : 	}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
PUBLIC	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z		; std::_Fputc<char>
EXTRN	_fputc:PROC
; Function compile flags: /Ogtp
;	COMDAT ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
__File$ = 12						; size = 4
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT

; 80   : 	{	// put a char element to a C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 81   : 	return (fputc(_Byte, _File) != EOF);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __File$[ebp]
  00006	0f be 4d 08	 movsx	 ecx, BYTE PTR __Byte$[ebp]
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _fputc
  00011	33 d2		 xor	 edx, edx
  00013	83 c4 08	 add	 esp, 8
  00016	83 f8 ff	 cmp	 eax, -1
  00019	0f 95 c0	 setne	 al

; 82   : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
PUBLIC	??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z		; std::_Ungetc<char>
EXTRN	_ungetc:PROC
; Function compile flags: /Ogtp
;	COMDAT ??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 4
__File$ = 12						; size = 4
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT

; 104  : 	{	// put back a char element to a C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 105  : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Byte$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __File$[ebp]
  00009	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0000c	50		 push	 eax
  0000d	52		 push	 edx
  0000e	e8 00 00 00 00	 call	 _ungetc
  00013	33 c9		 xor	 ecx, ecx
  00015	83 c4 08	 add	 esp, 8
  00018	83 f8 ff	 cmp	 eax, -1
  0001b	0f 95 c0	 setne	 al

; 106  : 	}

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
EXTRN	__lock_file:PROC
; Function compile flags: /Ogtp
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 309  : 		if (_Myfile)

  00000	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $LN1@Lock

; 310  : 			_CSTD _lock_file(_Myfile);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 __lock_file
  0000d	59		 pop	 ecx
$LN1@Lock:

; 311  : 		}

  0000e	c3		 ret	 0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
EXTRN	__unlock_file:PROC
; Function compile flags: /Ogtp
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 315  : 		if (_Myfile)

  00000	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $LN1@Unlock

; 316  : 			_CSTD _unlock_file(_Myfile);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 __unlock_file
  0000d	59		 pop	 ecx
$LN1@Unlock:

; 317  : 		}

  0000e	c3		 ret	 0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
EXTRN	_fflush:PROC
; Function compile flags: /Ogtp
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 543  : 		{	// synchronize C stream with external file

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 544  : 		return (_Myfile == 0
; 545  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 546  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);

  00003	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  00007	74 23		 je	 SHORT $LN3@sync
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0000e	6a ff		 push	 -1
  00010	ff d2		 call	 edx
  00012	83 f8 ff	 cmp	 eax, -1
  00015	74 15		 je	 SHORT $LN3@sync
  00017	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _fflush
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	79 05		 jns	 SHORT $LN3@sync
  00027	83 c8 ff	 or	 eax, -1
  0002a	5e		 pop	 esi

; 547  : 		}

  0002b	c3		 ret	 0
$LN3@sync:

; 544  : 		return (_Myfile == 0
; 545  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 546  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 547  : 		}

  0002f	c3		 ret	 0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
PUBLIC	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::egptr, COMDAT
; _this$ = ecx

; 238  : 		return (*_IGnext + *_IGcount);

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	03 01		 add	 eax, DWORD PTR [ecx]

; 239  : 		}

  0000a	c3		 ret	 0
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::egptr
_TEXT	ENDS
PUBLIC	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
; Function compile flags: /Ogtp
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::epptr, COMDAT
; _this$ = ecx

; 256  : 		return (*_IPnext + *_IPcount);

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00003	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	03 01		 add	 eax, DWORD PTR [ecx]

; 257  : 		}

  0000a	c3		 ret	 0
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::epptr
_TEXT	ENDS
PUBLIC	?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec
; Function compile flags: /Ogtp
;	COMDAT ?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec, COMDAT
; _this$ = ecx

; 261  : 		++*_IGcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 00		 inc	 DWORD PTR [eax]

; 262  : 		return (--*_IGnext);

  00005	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	48		 dec	 eax
  0000b	89 01		 mov	 DWORD PTR [ecx], eax

; 263  : 		}

  0000d	c3		 ret	 0
?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec
_TEXT	ENDS
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
; Function compile flags: /Ogtp
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 304  : 		--*_IPcount;

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 305  : 		return ((*_IPnext)++);

  00005	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000d	89 11		 mov	 DWORD PTR [ecx], edx

; 306  : 		}

  0000f	c3		 ret	 0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
PUBLIC	??0?$fpos@H@std@@QAE@H_J@Z			; std::fpos<int>::fpos<int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ??0?$fpos@H@std@@QAE@H_J@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Fileposition$ = 12					; size = 8
??0?$fpos@H@std@@QAE@H_J@Z PROC				; std::fpos<int>::fpos<int>, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with conversion state and C file position

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 10	 mov	 edx, DWORD PTR __Fileposition$[ebp+4]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR __Fileposition$[ebp]
  0000b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __State$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00017	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001e	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00021	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 46   : 		}

  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??0?$fpos@H@std@@QAE@H_J@Z ENDP				; std::fpos<int>::fpos<int>
_TEXT	ENDS
PUBLIC	?state@?$fpos@H@std@@QBEHXZ			; std::fpos<int>::state
; Function compile flags: /Ogtp
;	COMDAT ?state@?$fpos@H@std@@QBEHXZ
_TEXT	SEGMENT
?state@?$fpos@H@std@@QBEHXZ PROC			; std::fpos<int>::state, COMDAT
; _this$ = ecx

; 50   : 		return (_Mystate);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 51   : 		}

  00003	c3		 ret	 0
?state@?$fpos@H@std@@QBEHXZ ENDP			; std::fpos<int>::state
_TEXT	ENDS
PUBLIC	?seekpos@?$fpos@H@std@@QBE_JXZ			; std::fpos<int>::seekpos
; Function compile flags: /Ogtp
;	COMDAT ?seekpos@?$fpos@H@std@@QBE_JXZ
_TEXT	SEGMENT
?seekpos@?$fpos@H@std@@QBE_JXZ PROC			; std::fpos<int>::seekpos, COMDAT
; _this$ = ecx

; 60   : 		return (_Fpos);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]

; 61   : 		}

  00006	c3		 ret	 0
?seekpos@?$fpos@H@std@@QBE_JXZ ENDP			; std::fpos<int>::seekpos
_TEXT	ENDS
PUBLIC	??B?$fpos@H@std@@QBE_JXZ			; std::fpos<int>::operator __int64
; Function compile flags: /Ogtp
;	COMDAT ??B?$fpos@H@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@H@std@@QBE_JXZ PROC				; std::fpos<int>::operator __int64, COMDAT
; _this$ = ecx

; 65   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	99		 cdq
  00004	03 01		 add	 eax, DWORD PTR [ecx]
  00006	13 51 04	 adc	 edx, DWORD PTR [ecx+4]

; 66   : 		}

  00009	c3		 ret	 0
??B?$fpos@H@std@@QBE_JXZ ENDP				; std::fpos<int>::operator __int64
_TEXT	ENDS
PUBLIC	?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::in
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC	; std::codecvt<char,char,int>::in, COMDAT
; _this$ = ecx

; 808  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 809  : 		return (do_in(_State,
; 810  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 811  : 		}

  00008	5d		 pop	 ebp

; 809  : 		return (do_in(_State,
; 810  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

  00009	ff e0		 jmp	 eax
?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP	; std::codecvt<char,char,int>::in
_TEXT	ENDS
PUBLIC	?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::out
; Function compile flags: /Ogtp
;	COMDAT ?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,int>::out, COMDAT
; _this$ = ecx

; 816  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last2)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (do_out(_State,
; 818  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 819  : 		}

  00008	5d		 pop	 ebp

; 817  : 		return (do_out(_State,
; 818  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

  00009	ff e0		 jmp	 eax
?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::out
_TEXT	ENDS
PUBLIC	?not_eof@?$char_traits@D@std@@SAHABH@Z		; std::char_traits<char>::not_eof
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC		; std::char_traits<char>::not_eof, COMDAT

; 557  : 		{	// return anything but EOF

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 558  : 		return (_Meta != eof() ? _Meta : !eof());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0000b	f7 d8		 neg	 eax
  0000d	1b c0		 sbb	 eax, eax
  0000f	23 c1		 and	 eax, ecx

; 559  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 408  : 		{	// get an element from stream, but don't point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 409  : 		int_type _Meta;
; 410  : 		if (_Mysb::gptr() != 0
; 411  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00003	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	85 c9		 test	 ecx, ecx
  0000a	74 12		 je	 SHORT $LN4@underflow
  0000c	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0000f	8b 12		 mov	 edx, DWORD PTR [edx]
  00011	8b c1		 mov	 eax, ecx
  00013	03 d0		 add	 edx, eax
  00015	3b c2		 cmp	 eax, edx
  00017	73 05		 jae	 SHORT $LN4@underflow

; 412  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

  00019	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0001c	5e		 pop	 esi

; 419  : 			}
; 420  : 		}

  0001d	c3		 ret	 0
$LN4@underflow:

; 413  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
  00020	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00023	57		 push	 edi
  00024	8b ce		 mov	 ecx, esi
  00026	ff d2		 call	 edx
  00028	8b f8		 mov	 edi, eax
  0002a	83 ff ff	 cmp	 edi, -1
  0002d	75 05		 jne	 SHORT $LN2@underflow

; 414  : 			return (_Meta);	// uflow failed, return EOF

  0002f	5f		 pop	 edi
  00030	0b c0		 or	 eax, eax
  00032	5e		 pop	 esi

; 419  : 			}
; 420  : 		}

  00033	c3		 ret	 0
$LN2@underflow:

; 415  : 		else
; 416  : 			{	// get a char, don't point past it
; 417  : 			pbackfail(_Meta);

  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00039	57		 push	 edi
  0003a	8b ce		 mov	 ecx, esi
  0003c	ff d2		 call	 edx

; 418  : 			return (_Meta);

  0003e	8b c7		 mov	 eax, edi
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 419  : 			}
; 420  : 		}

  00042	c3		 ret	 0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
; Function compile flags: /Ogtp
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT
; _this$ = ecx

; 647  : 		if (_Mysb::eback() != &_Mychar)

  00000	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00003	56		 push	 esi
  00004	8b 32		 mov	 esi, DWORD PTR [edx]
  00006	8d 41 48	 lea	 eax, DWORD PTR [ecx+72]
  00009	3b f0		 cmp	 esi, eax
  0000b	74 12		 je	 SHORT $LN1@Set_back

; 648  : 			{	// save current get buffer
; 649  : 			_Set_eback = _Mysb::eback();

  0000d	89 71 3c	 mov	 DWORD PTR [ecx+60], esi

; 650  : 			_Set_egptr = _Mysb::egptr();

  00010	8b 71 30	 mov	 esi, DWORD PTR [ecx+48]
  00013	8b 36		 mov	 esi, DWORD PTR [esi]
  00015	57		 push	 edi
  00016	8b 79 20	 mov	 edi, DWORD PTR [ecx+32]
  00019	03 37		 add	 esi, DWORD PTR [edi]
  0001b	5f		 pop	 edi
  0001c	89 71 40	 mov	 DWORD PTR [ecx+64], esi
$LN1@Set_back:

; 651  : 			}
; 652  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00024	89 02		 mov	 DWORD PTR [edx], eax
  00026	8b d1		 mov	 edx, ecx
  00028	2b d0		 sub	 edx, eax
  0002a	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0002d	83 c2 49	 add	 edx, 73			; 00000049H
  00030	89 10		 mov	 DWORD PTR [eax], edx
  00032	5e		 pop	 esi

; 653  : 		}

  00033	c3		 ret	 0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 383  : 		{	// put an element back to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 384  : 		if (_Mysb::gptr() != 0
; 385  : 			&& _Mysb::eback() < _Mysb::gptr()
; 386  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)
; 387  : 			|| _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
; 388  : 				_Meta)))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	85 c0		 test	 eax, eax
  00011	74 2d		 je	 SHORT $LN10@pbackfail
  00013	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00016	39 01		 cmp	 DWORD PTR [ecx], eax
  00018	73 26		 jae	 SHORT $LN10@pbackfail
  0001a	83 fb ff	 cmp	 ebx, -1
  0001d	74 08		 je	 SHORT $LN9@pbackfail
  0001f	0f b6 50 ff	 movzx	 edx, BYTE PTR [eax-1]
  00023	3b d3		 cmp	 edx, ebx
  00025	75 19		 jne	 SHORT $LN10@pbackfail
$LN9@pbackfail:

; 389  : 			{	// just back up position
; 390  : 			_Mysb::_Gndec();

  00027	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0002a	ff 00		 inc	 DWORD PTR [eax]
  0002c	8b 76 20	 mov	 esi, DWORD PTR [esi+32]
  0002f	ff 0e		 dec	 DWORD PTR [esi]

; 391  : 			return (_Traits::not_eof(_Meta));

  00031	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00034	f7 d8		 neg	 eax
  00036	1b c0		 sbb	 eax, eax
  00038	5e		 pop	 esi
  00039	23 c3		 and	 eax, ebx
  0003b	5b		 pop	 ebx

; 402  : 			}
; 403  : 		else
; 404  : 			return (_Traits::eof());	// nowhere to put back
; 405  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
$LN10@pbackfail:

; 392  : 			}
; 393  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

  00040	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00043	85 c0		 test	 eax, eax
  00045	74 38		 je	 SHORT $LN6@pbackfail
  00047	83 fb ff	 cmp	 ebx, -1
  0004a	74 33		 je	 SHORT $LN6@pbackfail

; 395  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

  0004c	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  00050	75 12		 jne	 SHORT $LN4@pbackfail
  00052	50		 push	 eax
  00053	0f b6 c3	 movzx	 eax, bl
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _ungetc
  0005c	83 c4 08	 add	 esp, 8
  0005f	83 f8 ff	 cmp	 eax, -1

; 396  : 			return (_Meta);	// no facet and unget succeeded, return

  00062	75 13		 jne	 SHORT $LN55@pbackfail
$LN4@pbackfail:

; 397  : 		else if (_Mysb::gptr() != &_Mychar)

  00064	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00067	8d 46 48	 lea	 eax, DWORD PTR [esi+72]
  0006a	39 01		 cmp	 DWORD PTR [ecx], eax
  0006c	74 11		 je	 SHORT $LN6@pbackfail

; 398  : 			{	// putback to _Mychar
; 399  : 			_Mychar = _Traits::to_char_type(_Meta);
; 400  : 			_Set_back();	// switch to _Mychar buffer

  0006e	8b ce		 mov	 ecx, esi
  00070	88 18		 mov	 BYTE PTR [eax], bl
  00072	e8 00 00 00 00	 call	 ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
$LN55@pbackfail:

; 401  : 			return (_Meta);

  00077	5e		 pop	 esi
  00078	8b c3		 mov	 eax, ebx
  0007a	5b		 pop	 ebx

; 402  : 			}
; 403  : 		else
; 404  : 			return (_Traits::eof());	// nowhere to put back
; 405  : 		}

  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
$LN6@pbackfail:
  0007f	5e		 pop	 esi

; 394  : 			return (_Traits::eof());	// no open C stream or EOF, fail

  00080	83 c8 ff	 or	 eax, -1
  00083	5b		 pop	 ebx

; 402  : 			}
; 403  : 		else
; 404  : 			return (_Traits::eof());	// nowhere to put back
; 405  : 		}

  00084	5d		 pop	 ebp
  00085	c2 04 00	 ret	 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
EXTRN	_setvbuf:PROC
; Function compile flags: /Ogtp
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Count$ = 12						; size = 8
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 530  : 		{	// offer _Buffer to C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 531  : 		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,
; 532  : 			_Buffer == 0 && _Count == 0 ? _IONBF : _IOFBF,
; 533  : 			(size_t)_Count * sizeof (_Elem)) != 0)

  00006	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  00009	85 c9		 test	 ecx, ecx
  0000b	74 40		 je	 SHORT $LN2@setbuf
  0000d	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  00014	85 d2		 test	 edx, edx
  00016	75 0e		 jne	 SHORT $LN6@setbuf
  00018	8b c6		 mov	 eax, esi
  0001a	0b 45 10	 or	 eax, DWORD PTR __Count$[ebp+4]
  0001d	75 07		 jne	 SHORT $LN6@setbuf
  0001f	b8 04 00 00 00	 mov	 eax, 4
  00024	eb 02		 jmp	 SHORT $LN7@setbuf
$LN6@setbuf:
  00026	33 c0		 xor	 eax, eax
$LN7@setbuf:
  00028	56		 push	 esi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 _setvbuf
  00031	83 c4 10	 add	 esp, 16			; 00000010H
  00034	5e		 pop	 esi
  00035	85 c0		 test	 eax, eax
  00037	75 14		 jne	 SHORT $LN2@setbuf

; 535  : 		else
; 536  : 			{	// new buffer, reinitialize pointers
; 537  : 			_Init(_Myfile, _Openfl);

  00039	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  0003c	6a 01		 push	 1
  0003e	51		 push	 ecx
  0003f	8b cf		 mov	 ecx, edi
  00041	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 538  : 			return (this);

  00046	8b c7		 mov	 eax, edi
  00048	5f		 pop	 edi

; 539  : 			}
; 540  : 		}

  00049	5d		 pop	 ebp
  0004a	c2 0c 00	 ret	 12			; 0000000cH
$LN2@setbuf:

; 534  : 			return (0);	// failed

  0004d	33 c0		 xor	 eax, eax
  0004f	5f		 pop	 edi

; 539  : 			}
; 540  : 		}

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1959 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1960 : 		if (max_size() < _Newsize)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	83 fb fe	 cmp	 ebx, -2			; fffffffeH
  0000d	76 0a		 jbe	 SHORT $LN6@Grow

; 1961 : 			_Xlen();	// result too long

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN49@Grow:
$LN6@Grow:

; 1962 : 		if (this->_Myres < _Newsize)

  00019	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0001c	3b c3		 cmp	 eax, ebx
  0001e	73 18		 jae	 SHORT $LN5@Grow

; 1963 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  00020	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1969 : 		return (0 < _Newsize);	// return true only if more work to do

  0002a	33 c9		 xor	 ecx, ecx
  0002c	3b cb		 cmp	 ecx, ebx
  0002e	1b c0		 sbb	 eax, eax
  00030	5e		 pop	 esi
  00031	f7 d8		 neg	 eax
  00033	5b		 pop	 ebx

; 1970 : 		}

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN5@Grow:

; 1964 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00038	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  0003c	74 4e		 je	 SHORT $LN3@Grow
  0003e	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00041	73 49		 jae	 SHORT $LN3@Grow

; 1965 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1966 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

  00043	57		 push	 edi
  00044	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00047	3b df		 cmp	 ebx, edi
  00049	73 02		 jae	 SHORT $LN9@Grow
  0004b	8b fb		 mov	 edi, ebx
$LN9@Grow:
  0004d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00050	72 1d		 jb	 SHORT $LN30@Grow
  00052	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00054	85 ff		 test	 edi, edi
  00056	74 0b		 je	 SHORT $LN28@Grow
  00058	57		 push	 edi
  00059	53		 push	 ebx
  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 _memcpy
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@Grow:
  00063	53		 push	 ebx
  00064	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00069	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  0006c	83 c4 04	 add	 esp, 4
$LN30@Grow:
  0006f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00072	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 1969 : 		return (0 < _Newsize);	// return true only if more work to do

  00079	33 c9		 xor	 ecx, ecx
  0007b	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0007f	3b cb		 cmp	 ecx, ebx
  00081	5f		 pop	 edi
  00082	1b c0		 sbb	 eax, eax
  00084	5e		 pop	 esi
  00085	f7 d8		 neg	 eax
  00087	5b		 pop	 ebx

; 1970 : 		}

  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
$LN3@Grow:

; 1967 : 		else if (_Newsize == 0)

  0008c	85 db		 test	 ebx, ebx
  0008e	75 0d		 jne	 SHORT $LN46@Grow

; 1968 : 			_Eos(0);	// new size is zero, just null terminate

  00090	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00093	83 f8 10	 cmp	 eax, 16			; 00000010H
  00096	72 02		 jb	 SHORT $LN44@Grow
  00098	8b 36		 mov	 esi, DWORD PTR [esi]
$LN44@Grow:
  0009a	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN46@Grow:

; 1969 : 		return (0 < _Newsize);	// return true only if more work to do

  0009d	33 c9		 xor	 ecx, ecx
  0009f	3b cb		 cmp	 ecx, ebx
  000a1	1b c0		 sbb	 eax, eax
  000a3	5e		 pop	 esi
  000a4	f7 d8		 neg	 eax
  000a6	5b		 pop	 ebx

; 1970 : 		}

  000a7	5d		 pop	 ebp
  000a8	c2 08 00	 ret	 8
$LN48@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 807  : 		return (iterator(_Lmost(), this));

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::begin
_TEXT	ENDS
PUBLIC	?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
_TEXT	SEGMENT
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::init, COMDAT
; _this$ = ecx

; 154  : 		{	// initialize with stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 155  : 		_Init();	// initialize ios_base

  00006	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init

; 156  : 		_Mystrbuf = _Strbuf;

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Strbuf$[ebp]

; 157  : 		_Tiestr = 0;
; 158  : 		_Fillch = widen(' ');

  0000e	6a 20		 push	 32			; 00000020H
  00010	8b ce		 mov	 ecx, esi
  00012	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00015	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  0001c	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen

; 159  : 
; 160  : 		if (_Mystrbuf == 0)

  00021	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00025	88 46 40	 mov	 BYTE PTR [esi+64], al
  00028	75 10		 jne	 SHORT $LN10@init

; 161  : 			setstate(badbit);

  0002a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0002d	83 c8 04	 or	 eax, 4
  00030	6a 00		 push	 0
  00032	50		 push	 eax
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN10@init:

; 162  : 
; 163  : 		if (_Isstd)

  0003a	80 7d 0c 00	 cmp	 BYTE PTR __Isstd$[ebp], 0
  0003e	74 09		 je	 SHORT $LN1@init

; 164  : 			_Addstd(this);	// special handling for standard streams

  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  00046	83 c4 04	 add	 esp, 4
$LN1@init:
  00049	5e		 pop	 esi

; 165  : 		}

  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::init
_TEXT	ENDS
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\string
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z PROC ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 216  : 	{	// test for string vs. NTCS inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 217  : 	return (!(_Left == _Right));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000c	8d 64 24 00	 npad	 4
$LL9@operator@9:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL9@operator@9
  00017	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001a	2b c6		 sub	 eax, esi
  0001c	50		 push	 eax
  0001d	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00020	52		 push	 edx
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00029	f7 d8		 neg	 eax
  0002b	1b c0		 sbb	 eax, eax
  0002d	f7 d8		 neg	 eax
  0002f	5e		 pop	 esi

; 218  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ENDP ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
PUBLIC	??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T161298 = -36						; size = 12
__Lock$151145 = -24					; size = 4
__Lock$161305 = -20					; size = 4
__Psave$151146 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Lock$161327 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,int> >, COMDAT

; 504  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 505  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$151145[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 506  : 		const locale::facet *_Psave =
; 507  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 508  : 
; 509  : 		size_t _Id = _Facet::id;

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A, 0 ; std::codecvt<char,char,int>::id
  00039	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	89 5d f0	 mov	 DWORD PTR __Psave$151146[ebp], ebx
  00049	75 2b		 jne	 SHORT $LN11@use_facet@2
  0004b	6a 00		 push	 0
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$161305[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A, 0 ; std::codecvt<char,char,int>::id
  0005c	75 10		 jne	 SHORT $LN10@use_facet@2
  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00063	40		 inc	 eax
  00064	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00069	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A, eax ; std::codecvt<char,char,int>::id
$LN10@use_facet@2:
  0006e	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$161305[ebp]
  00071	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN11@use_facet@2:

; 510  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00076	8b 7d 08	 mov	 edi, DWORD PTR __Loc$[ebp]
  00079	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A ; std::codecvt<char,char,int>::id
  0007f	8b 07		 mov	 eax, DWORD PTR [edi]
  00081	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  00084	73 22		 jae	 SHORT $LN20@use_facet@2
  00086	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00089	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  0008c	85 c9		 test	 ecx, ecx
  0008e	75 1c		 jne	 SHORT $LN16@use_facet@2
$LN30@use_facet@2:
  00090	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  00094	74 16		 je	 SHORT $LN16@use_facet@2
  00096	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009b	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  0009e	73 12		 jae	 SHORT $LN31@use_facet@2
  000a0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000a3	8b 34 b2	 mov	 esi, DWORD PTR [edx+esi*4]
  000a6	eb 06		 jmp	 SHORT $LN15@use_facet@2
$LN20@use_facet@2:
  000a8	33 c9		 xor	 ecx, ecx
  000aa	eb e4		 jmp	 SHORT $LN30@use_facet@2
$LN16@use_facet@2:
  000ac	8b f1		 mov	 esi, ecx
$LN15@use_facet@2:

; 511  : 
; 512  : 		if (_Pf != 0)

  000ae	85 f6		 test	 esi, esi
  000b0	75 65		 jne	 SHORT $LN28@use_facet@2
$LN31@use_facet@2:

; 513  : 			;	// got facet from locale
; 514  : 		else if (_Psave != 0)

  000b2	85 db		 test	 ebx, ebx
  000b4	74 04		 je	 SHORT $LN4@use_facet@2

; 515  : 			_Pf = _Psave;	// lazy facet already allocated

  000b6	8b f3		 mov	 esi, ebx
  000b8	eb 5d		 jmp	 SHORT $LN28@use_facet@2
$LN4@use_facet@2:

; 516  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000ba	8d 45 f0	 lea	 eax, DWORD PTR __Psave$151146[ebp]
  000bd	57		 push	 edi
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::codecvt<char,char,int>::_Getcat
  000c4	83 c4 08	 add	 esp, 8
  000c7	83 f8 ff	 cmp	 eax, -1
  000ca	75 1b		 jne	 SHORT $LN2@use_facet@2

; 517  : 
; 518  :  #if _HAS_EXCEPTIONS
; 519  : 
; 520  : 			_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000d1	8d 4d dc	 lea	 ecx, DWORD PTR $T161298[ebp]
  000d4	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@PBD@Z ; std::bad_cast::bad_cast
  000d9	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000de	8d 4d dc	 lea	 ecx, DWORD PTR $T161298[ebp]
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@use_facet@2:
$LN2@use_facet@2:

; 521  : 
; 522  :  #else /* _HAS_EXCEPTIONS */
; 523  : 			abort();	// lazy disallowed
; 524  :  #endif /* _HAS_EXCEPTIONS */
; 525  : 
; 526  : 		else
; 527  : 			{	// queue up lazy facet for destruction
; 528  : 			_Pf = _Psave;

  000e7	8b 75 f0	 mov	 esi, DWORD PTR __Psave$151146[ebp]

; 529  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 530  : 
; 531  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 532  : 			_Pfmod->_Incref();

  000ea	6a 00		 push	 0
  000ec	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$161327[ebp]
  000ef	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
  000f5	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  000fa	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000fd	83 f8 ff	 cmp	 eax, -1
  00100	73 04		 jae	 SHORT $LN24@use_facet@2
  00102	40		 inc	 eax
  00103	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN24@use_facet@2:
  00106	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$161327[ebp]
  00109	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit

; 533  : 			_Pfmod->_Register();

  0010e	56		 push	 esi
  0010f	e8 00 00 00 00	 call	 ?_Facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::_Facet_Register
  00114	83 c4 04	 add	 esp, 4
$LN28@use_facet@2:

; 534  : 			}
; 535  : 
; 536  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00117	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$151145[ebp]
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00121	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00126	8b c6		 mov	 eax, esi

; 537  : 	_END_LOCK()
; 538  : 	}

  00128	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00132	59		 pop	 ecx
  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
$LN36@use_facet@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$151145[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,int> >
PUBLIC	??1?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
;	COMDAT ??1?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $LN16@pair@2
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN16@pair@2:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi
  00025	c3		 ret	 0
??1?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 99   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0002c	89 06		 mov	 DWORD PTR [esi], eax
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00033	8b 44 02 38	 mov	 eax, DWORD PTR [edx+eax+56]
  00037	85 c0		 test	 eax, eax
  00039	74 09		 je	 SHORT $LN4@sentry@2
  0003b	8b 10		 mov	 edx, DWORD PTR [eax]
  0003d	8b c8		 mov	 ecx, eax
  0003f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00042	ff d0		 call	 eax
$LN4@sentry@2:

; 100  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00044	8b 4d 0c	 mov	 ecx, DWORD PTR __Noskip$[ebp]
  00047	51		 push	 ecx
  00048	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00051	e8 00 00 00 00	 call	 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
  00056	88 46 04	 mov	 BYTE PTR [esi+4], al

; 101  : 			}

  00059	8b c6		 mov	 eax, esi
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00065	59		 pop	 ecx
  00066	5e		 pop	 esi
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
$T161486 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000a	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  00012	75 18		 jne	 SHORT $LN9@find@2
  00014	56		 push	 esi
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$LL10@find@2:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	73 05		 jae	 SHORT $LN8@find@2
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $LN7@find@2
$LN8@find@2:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@find@2:
  00025	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00029	74 ec		 je	 SHORT $LL10@find@2
  0002b	5e		 pop	 esi
$LN9@find@2:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	89 55 0c	 mov	 DWORD PTR __Where$[ebp], edx
  00032	3b d0		 cmp	 edx, eax
  00034	74 18		 je	 SHORT $LN3@find@2
  00036	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00038	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003b	72 11		 jb	 SHORT $LN3@find@2
  0003d	8d 45 0c	 lea	 eax, DWORD PTR __Where$[ebp]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00045	89 10		 mov	 DWORD PTR [eax], edx
  00047	5f		 pop	 edi

; 1429 : 		}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN3@find@2:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0004e	89 45 fc	 mov	 DWORD PTR $T161486[ebp], eax
  00051	8d 45 fc	 lea	 eax, DWORD PTR $T161486[ebp]
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00059	89 10		 mov	 DWORD PTR [eax], edx
  0005b	5f		 pop	 edi

; 1429 : 		}

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::find
; Function compile flags: /Ogtp
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
$T161709 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000a	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  00012	75 18		 jne	 SHORT $LN9@find@3
  00014	56		 push	 esi
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$LL10@find@3:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	73 05		 jae	 SHORT $LN8@find@3
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $LN7@find@3
$LN8@find@3:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@find@3:
  00025	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00029	74 ec		 je	 SHORT $LL10@find@3
  0002b	5e		 pop	 esi
$LN9@find@3:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	89 55 0c	 mov	 DWORD PTR __Where$[ebp], edx
  00032	3b d0		 cmp	 edx, eax
  00034	74 18		 je	 SHORT $LN3@find@3
  00036	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00038	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003b	72 11		 jb	 SHORT $LN3@find@3
  0003d	8d 45 0c	 lea	 eax, DWORD PTR __Where$[ebp]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00045	89 10		 mov	 DWORD PTR [eax], edx
  00047	5f		 pop	 edi

; 1429 : 		}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN3@find@3:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0004e	89 45 fc	 mov	 DWORD PTR $T161709[ebp], eax
  00051	8d 45 fc	 lea	 eax, DWORD PTR $T161709[ebp]
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00059	89 10		 mov	 DWORD PTR [eax], edx
  0005b	5f		 pop	 edi

; 1429 : 		}

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::find
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
__Loc$ = 8						; size = 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 550  : 		{	// set locale to argument (capture nontrivial codecvt facet)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 551  : 		_Initcvt(&_USE(_Loc, _Cvt));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	50		 push	 eax
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
  00010	8b f0		 mov	 esi, eax
  00012	8b 16		 mov	 edx, DWORD PTR [esi]
  00014	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00017	83 c4 04	 add	 esp, 4
  0001a	8b ce		 mov	 ecx, esi
  0001c	ff d0		 call	 eax
  0001e	84 c0		 test	 al, al
  00020	74 0d		 je	 SHORT $LN4@imbue
  00022	c7 47 44 00 00
	00 00		 mov	 DWORD PTR [edi+68], 0
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi

; 552  : 		}

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4

; 551  : 		_Initcvt(&_USE(_Loc, _Cvt));

$LN4@imbue:
  0002f	8b cf		 mov	 ecx, edi
  00031	89 77 44	 mov	 DWORD PTR [edi+68], esi
  00034	e8 00 00 00 00	 call	 ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi

; 552  : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 845  : 		{	// append _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 846  : 		if (npos - this->_Mysize <= _Count)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000d	83 c9 ff	 or	 ecx, -1
  00010	2b c8		 sub	 ecx, eax
  00012	3b cb		 cmp	 ecx, ebx
  00014	77 0a		 ja	 SHORT $LN2@append

; 847  : 			_Xlen();	// result too long

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0001b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN67@append:
$LN2@append:

; 848  : 
; 849  : 		size_type _Num;
; 850  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  00020	85 db		 test	 ebx, ebx
  00022	74 7c		 je	 SHORT $LN61@append
  00024	57		 push	 edi
  00025	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  00028	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0002b	76 0a		 jbe	 SHORT $LN13@append
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00032	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN68@append:
$LN13@append:
  00037	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0003a	3b cf		 cmp	 ecx, edi
  0003c	73 35		 jae	 SHORT $LN12@append
  0003e	50		 push	 eax
  0003f	57		 push	 edi
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00047	85 ff		 test	 edi, edi
  00049	74 54		 je	 SHORT $LN63@append
$LN66@append:

; 851  : 			{	// make room and append new stuff using assign
; 852  : 			_Chassign(this->_Mysize, _Count, _Ch);

  0004b	8b 55 0c	 mov	 edx, DWORD PTR __Ch$[ebp]
  0004e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00051	52		 push	 edx
  00052	53		 push	 ebx
  00053	50		 push	 eax
  00054	8b ce		 mov	 ecx, esi
  00056	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 853  : 			_Eos(_Num);

  0005b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0005f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00062	72 35		 jb	 SHORT $LN59@append
  00064	8b 06		 mov	 eax, DWORD PTR [esi]
  00066	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0006a	5f		 pop	 edi

; 854  : 			}
; 855  : 		return (*this);

  0006b	8b c6		 mov	 eax, esi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx

; 856  : 		}

  0006f	5d		 pop	 ebp
  00070	c2 08 00	 ret	 8

; 848  : 
; 849  : 		size_type _Num;
; 850  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

$LN12@append:
  00073	85 ff		 test	 edi, edi
  00075	75 d4		 jne	 SHORT $LN66@append
  00077	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0007a	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0007d	72 0e		 jb	 SHORT $LN51@append
  0007f	8b 06		 mov	 eax, DWORD PTR [esi]
  00081	5f		 pop	 edi
  00082	c6 00 00	 mov	 BYTE PTR [eax], 0

; 854  : 			}
; 855  : 		return (*this);

  00085	8b c6		 mov	 eax, esi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx

; 856  : 		}

  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8

; 848  : 
; 849  : 		size_type _Num;
; 850  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

$LN51@append:
  0008d	5f		 pop	 edi
  0008e	8b c6		 mov	 eax, esi
  00090	5e		 pop	 esi
  00091	c6 00 00	 mov	 BYTE PTR [eax], 0
  00094	5b		 pop	 ebx

; 856  : 		}

  00095	5d		 pop	 ebp
  00096	c2 08 00	 ret	 8

; 853  : 			_Eos(_Num);

$LN59@append:
  00099	8b c6		 mov	 eax, esi
  0009b	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN63@append:
  0009f	5f		 pop	 edi
$LN61@append:

; 854  : 			}
; 855  : 		return (*this);

  000a0	8b c6		 mov	 eax, esi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx

; 856  : 		}

  000a4	5d		 pop	 ebp
  000a5	c2 08 00	 ret	 8
$LN64@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 893  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 894  : 		if (_Right.size() < _Roff)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Roff$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	57		 push	 edi
  0000e	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
  00011	3b fb		 cmp	 edi, ebx
  00013	73 0a		 jae	 SHORT $LN5@assign

; 895  : 			_Xran();	// _Roff off end

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN83@assign:
$LN5@assign:

; 896  : 		size_type _Num = _Right.size() - _Roff;
; 897  : 		if (_Count < _Num)

  0001f	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	2b fb		 sub	 edi, ebx
  00024	3b c7		 cmp	 eax, edi
  00026	73 02		 jae	 SHORT $LN4@assign

; 898  : 			_Num = _Count;	// trim _Num to size

  00028	8b f8		 mov	 edi, eax
$LN4@assign:

; 899  : 
; 900  : 		if (this == &_Right)

  0002a	3b f1		 cmp	 esi, ecx
  0002c	75 1f		 jne	 SHORT $LN3@assign

; 901  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002e	6a ff		 push	 -1
  00030	03 fb		 add	 edi, ebx
  00032	57		 push	 edi
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0003a	53		 push	 ebx
  0003b	6a 00		 push	 0
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00044	5f		 pop	 edi

; 906  : 			}
; 907  : 		return (*this);

  00045	8b c6		 mov	 eax, esi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx

; 908  : 		}

  00049	5d		 pop	 ebp
  0004a	c2 0c 00	 ret	 12			; 0000000cH
$LN3@assign:

; 902  : 		else if (_Grow(_Num))

  0004d	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00050	76 0a		 jbe	 SHORT $LN20@assign
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00057	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN84@assign:
$LN20@assign:
  0005c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005f	3b c7		 cmp	 eax, edi
  00061	73 28		 jae	 SHORT $LN19@assign
  00063	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00066	50		 push	 eax
  00067	57		 push	 edi
  00068	8b ce		 mov	 ecx, esi
  0006a	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00072	85 ff		 test	 edi, edi
  00074	74 68		 je	 SHORT $LN78@assign
$LN82@assign:

; 903  : 			{	// make room and assign new stuff
; 904  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  00076	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0007b	39 41 14	 cmp	 DWORD PTR [ecx+20], eax
  0007e	72 02		 jb	 SHORT $LN64@assign
  00080	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN64@assign:
  00082	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00085	72 2a		 jb	 SHORT $LN68@assign
  00087	8b 06		 mov	 eax, DWORD PTR [esi]
  00089	eb 28		 jmp	 SHORT $LN69@assign

; 902  : 		else if (_Grow(_Num))

$LN19@assign:
  0008b	85 ff		 test	 edi, edi
  0008d	75 e7		 jne	 SHORT $LN82@assign
  0008f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00092	83 f8 10	 cmp	 eax, 16			; 00000010H
  00095	72 0e		 jb	 SHORT $LN58@assign
  00097	8b 06		 mov	 eax, DWORD PTR [esi]
  00099	5f		 pop	 edi
  0009a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 906  : 			}
; 907  : 		return (*this);

  0009d	8b c6		 mov	 eax, esi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx

; 908  : 		}

  000a1	5d		 pop	 ebp
  000a2	c2 0c 00	 ret	 12			; 0000000cH

; 902  : 		else if (_Grow(_Num))

$LN58@assign:
  000a5	5f		 pop	 edi
  000a6	8b c6		 mov	 eax, esi
  000a8	5e		 pop	 esi
  000a9	c6 00 00	 mov	 BYTE PTR [eax], 0
  000ac	5b		 pop	 ebx

; 908  : 		}

  000ad	5d		 pop	 ebp
  000ae	c2 0c 00	 ret	 12			; 0000000cH

; 903  : 			{	// make room and assign new stuff
; 904  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

$LN68@assign:
  000b1	8b c6		 mov	 eax, esi
$LN69@assign:
  000b3	57		 push	 edi
  000b4	03 cb		 add	 ecx, ebx
  000b6	51		 push	 ecx
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _memcpy
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 905  : 			_Eos(_Num);

  000c0	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c4	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000c7	72 0f		 jb	 SHORT $LN76@assign
  000c9	8b 06		 mov	 eax, DWORD PTR [esi]
  000cb	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  000cf	5f		 pop	 edi

; 906  : 			}
; 907  : 		return (*this);

  000d0	8b c6		 mov	 eax, esi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx

; 908  : 		}

  000d4	5d		 pop	 ebp
  000d5	c2 0c 00	 ret	 12			; 0000000cH

; 905  : 			_Eos(_Num);

$LN76@assign:
  000d8	8b c6		 mov	 eax, esi
  000da	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN78@assign:

; 906  : 			}
; 907  : 		return (*this);

  000de	5f		 pop	 edi
  000df	8b c6		 mov	 eax, esi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx

; 908  : 		}

  000e3	5d		 pop	 ebp
  000e4	c2 0c 00	 ret	 12			; 0000000cH
$LN80@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 911  : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 912  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 913  : 		if (_Count != 0)
; 914  : 			_DEBUG_POINTER(_Ptr);
; 915  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 916  : 
; 917  : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 59		 je	 SHORT $LN85@assign@2
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN12@assign@2
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN13@assign@2
$LN12@assign@2:
  0001a	8b c6		 mov	 eax, esi
$LN13@assign@2:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 47		 jb	 SHORT $LN85@assign@2
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN16@assign@2
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN17@assign@2
$LN16@assign@2:
  00029	8b c6		 mov	 eax, esi
$LN17@assign@2:
  0002b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0002e	03 d0		 add	 edx, eax
  00030	3b d3		 cmp	 edx, ebx
  00032	76 33		 jbe	 SHORT $LN85@assign@2

; 918  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 17		 jb	 SHORT $LN20@assign@2
  00039	8b 06		 mov	 eax, DWORD PTR [esi]
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0003e	51		 push	 ecx
  0003f	2b d8		 sub	 ebx, eax
  00041	53		 push	 ebx
  00042	56		 push	 esi
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 926  : 		}

  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8

; 918  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

$LN20@assign@2:
  00050	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00053	8b c6		 mov	 eax, esi
  00055	51		 push	 ecx
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx

; 926  : 		}

  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
$LN85@assign@2:
  00067	57		 push	 edi

; 919  : 
; 920  : 		if (_Grow(_Count))

  00068	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0006b	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0006e	76 0a		 jbe	 SHORT $LN27@assign@2
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00075	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN89@assign@2:
$LN27@assign@2:
  0007a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0007d	3b c7		 cmp	 eax, edi
  0007f	73 1a		 jae	 SHORT $LN26@assign@2
  00081	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00084	52		 push	 edx
  00085	57		 push	 edi
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0008d	85 ff		 test	 edi, edi
  0008f	74 5b		 je	 SHORT $LN82@assign@2
$LN88@assign@2:

; 921  : 			{	// make room and assign new stuff
; 922  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

  00091	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00095	72 2a		 jb	 SHORT $LN72@assign@2
  00097	8b 06		 mov	 eax, DWORD PTR [esi]
  00099	eb 28		 jmp	 SHORT $LN73@assign@2

; 919  : 
; 920  : 		if (_Grow(_Count))

$LN26@assign@2:
  0009b	85 ff		 test	 edi, edi
  0009d	75 f2		 jne	 SHORT $LN88@assign@2
  0009f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000a2	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a5	72 0e		 jb	 SHORT $LN65@assign@2
  000a7	8b 06		 mov	 eax, DWORD PTR [esi]
  000a9	5f		 pop	 edi
  000aa	c6 00 00	 mov	 BYTE PTR [eax], 0

; 924  : 			}
; 925  : 		return (*this);

  000ad	8b c6		 mov	 eax, esi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx

; 926  : 		}

  000b1	5d		 pop	 ebp
  000b2	c2 08 00	 ret	 8

; 919  : 
; 920  : 		if (_Grow(_Count))

$LN65@assign@2:
  000b5	5f		 pop	 edi
  000b6	8b c6		 mov	 eax, esi
  000b8	5e		 pop	 esi
  000b9	c6 00 00	 mov	 BYTE PTR [eax], 0
  000bc	5b		 pop	 ebx

; 926  : 		}

  000bd	5d		 pop	 ebp
  000be	c2 08 00	 ret	 8

; 921  : 			{	// make room and assign new stuff
; 922  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

$LN72@assign@2:
  000c1	8b c6		 mov	 eax, esi
$LN73@assign@2:
  000c3	57		 push	 edi
  000c4	53		 push	 ebx
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _memcpy
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 923  : 			_Eos(_Count);

  000ce	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000d2	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000d5	72 0f		 jb	 SHORT $LN80@assign@2
  000d7	8b 06		 mov	 eax, DWORD PTR [esi]
  000d9	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  000dd	5f		 pop	 edi

; 924  : 			}
; 925  : 		return (*this);

  000de	8b c6		 mov	 eax, esi
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx

; 926  : 		}

  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8

; 923  : 			_Eos(_Count);

$LN80@assign@2:
  000e6	8b c6		 mov	 eax, esi
  000e8	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN82@assign@2:

; 924  : 			}
; 925  : 		return (*this);

  000ec	5f		 pop	 edi
  000ed	8b c6		 mov	 eax, esi
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx

; 926  : 		}

  000f1	5d		 pop	 ebp
  000f2	c2 08 00	 ret	 8
$LN86@assign@2:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z ; std::basic_istream<char,std::char_traits<char> >::getline
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
xdata$x	SEGMENT
__catchsym$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$0
__tryblocktable$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$14
__unwindtable$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z
_TEXT	SEGMENT
__Ok$ = -32						; size = 8
_this$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Str$ = 8						; size = 4
__Count$ = 12						; size = 8
__Delim$ = 20						; size = 1
?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z PROC ; std::basic_istream<char,std::char_traits<char> >::getline, COMDAT
; _this$ = ecx

; 628  : 		{	// get up to _Count characters into NTCS, discard _Delim

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi

; 629  : 		_DEBUG_POINTER(_Str);
; 630  : 		ios_base::iostate _State = ios_base::goodbit;

  00030	33 db		 xor	 ebx, ebx

; 631  : 		_Chcount = 0;

  00032	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00035	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx

; 632  : 		const sentry _Ok(*this, true);

  00038	8b 06		 mov	 eax, DWORD PTR [esi]
  0003a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003d	8b 4c 31 38	 mov	 ecx, DWORD PTR [ecx+esi+56]
  00041	89 5d ec	 mov	 DWORD PTR __State$[ebp], ebx
  00044	89 75 e0	 mov	 DWORD PTR __Ok$[ebp], esi
  00047	3b cb		 cmp	 ecx, ebx
  00049	74 07		 je	 SHORT $LN24@getline
  0004b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00050	ff d0		 call	 eax
$LN24@getline:
  00052	6a 01		 push	 1
  00054	8b ce		 mov	 ecx, esi
  00056	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  00059	e8 00 00 00 00	 call	 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
  0005e	88 45 e4	 mov	 BYTE PTR __Ok$[ebp+4], al
  00061	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 633  : 
; 634  : 		if (_Ok && 0 < _Count)

  00068	84 c0		 test	 al, al
  0006a	0f 84 a7 00 00
	00		 je	 $LN19@getline
  00070	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp+4]
  00073	85 ff		 test	 edi, edi
  00075	0f 8c 9c 00 00
	00		 jl	 $LN19@getline
  0007b	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0007e	7f 08		 jg	 SHORT $LN161@getline
  00080	85 db		 test	 ebx, ebx
  00082	0f 84 8c 00 00
	00		 je	 $LN166@getline
$LN161@getline:

; 635  : 			{	// state okay, use facet to extract
; 636  : 			int_type _Metadelim = _Traits::to_int_type(_Delim);
; 637  : 
; 638  : 			_TRY_IO_BEGIN
; 639  : 			int_type _Meta = _Myios::rdbuf()->sgetc();

  00088	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008d	8b 4c 32 38	 mov	 ecx, DWORD PTR [edx+esi+56]
  00091	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00094	83 38 00	 cmp	 DWORD PTR [eax], 0
  00097	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0009b	74 0f		 je	 SHORT $LN39@getline
  0009d	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000a0	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000a3	7e 07		 jle	 SHORT $LN39@getline
  000a5	8b 00		 mov	 eax, DWORD PTR [eax]
  000a7	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000aa	eb 07		 jmp	 SHORT $LL160@getline
$LN39@getline:
  000ac	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ae	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000b1	ff d2		 call	 edx
$LL160@getline:

; 640  : 
; 641  : 			for (; ; _Meta = _Myios::rdbuf()->snextc())
; 642  : 				if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000b3	83 f8 ff	 cmp	 eax, -1
  000b6	75 06		 jne	 SHORT $LN6@getline

; 643  : 					{	// end of file, quit
; 644  : 					_State |= ios_base::eofbit;

  000b8	83 4d ec 01	 or	 DWORD PTR __State$[ebp], 1

; 645  : 					break;

  000bc	eb 4f		 jmp	 SHORT $LN7@getline
$LN6@getline:

; 646  : 					}
; 647  : 				else if (_Meta == _Metadelim)

  000be	0f b6 4d 14	 movzx	 ecx, BYTE PTR __Delim$[ebp]
  000c2	3b c1		 cmp	 eax, ecx
  000c4	75 33		 jne	 SHORT $LN4@getline

; 648  : 					{	// got a delimiter, discard it and quit
; 649  : 					++_Chcount;

  000c6	83 46 08 01	 add	 DWORD PTR [esi+8], 1

; 650  : 					_Myios::rdbuf()->sbumpc();

  000ca	8b 06		 mov	 eax, DWORD PTR [esi]
  000cc	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0
  000d0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d3	8b 4c 31 38	 mov	 ecx, DWORD PTR [ecx+esi+56]
  000d7	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000da	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000dd	74 11		 je	 SHORT $LN59@getline
  000df	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  000e2	83 38 00	 cmp	 DWORD PTR [eax], 0
  000e5	7e 09		 jle	 SHORT $LN59@getline
  000e7	ff 08		 dec	 DWORD PTR [eax]
  000e9	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  000ec	ff 01		 inc	 DWORD PTR [ecx]
  000ee	eb 1d		 jmp	 SHORT $LN7@getline
$LN59@getline:
  000f0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f2	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000f5	ff d0		 call	 eax

; 651  : 					break;

  000f7	eb 14		 jmp	 SHORT $LN7@getline
$LN4@getline:

; 652  : 					}
; 653  : 				else if (--_Count <= 0)

  000f9	83 c3 ff	 add	 ebx, -1
  000fc	83 d7 ff	 adc	 edi, -1
  000ff	85 ff		 test	 edi, edi
  00101	7f 7a		 jg	 SHORT $LN2@getline
  00103	7c 04		 jl	 SHORT $LN162@getline
  00105	85 db		 test	 ebx, ebx
  00107	75 74		 jne	 SHORT $LN2@getline
$LN162@getline:

; 654  : 					{	// buffer full, quit
; 655  : 					_State |= ios_base::failbit;

  00109	83 4d ec 02	 or	 DWORD PTR __State$[ebp], 2
$LN7@getline:
  0010d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN166@getline:

; 662  : 					}
; 663  : 			_CATCH_IO_END

  00114	8b 5d ec	 mov	 ebx, DWORD PTR __State$[ebp]
$LN19@getline:

; 664  : 			}
; 665  : 
; 666  : 		*_Str = _Elem();	// add terminating null character

  00117	8b 4d 08	 mov	 ecx, DWORD PTR __Str$[ebp]
  0011a	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 667  : 		_Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);

  0011d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00120	0b 56 0c	 or	 edx, DWORD PTR [esi+12]
  00123	75 03		 jne	 SHORT $LN14@getline
  00125	83 cb 02	 or	 ebx, 2
$LN14@getline:
  00128	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0012a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0012d	8b c3		 mov	 eax, ebx
  0012f	03 ce		 add	 ecx, esi
  00131	85 c0		 test	 eax, eax
  00133	74 14		 je	 SHORT $LN143@getline
  00135	0b 41 0c	 or	 eax, DWORD PTR [ecx+12]
  00138	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0013c	75 03		 jne	 SHORT $LN145@getline
  0013e	83 c8 04	 or	 eax, 4
$LN145@getline:
  00141	6a 00		 push	 0
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN143@getline:

; 668  : 		return (*this);

  00149	8b 45 e0	 mov	 eax, DWORD PTR __Ok$[ebp]
  0014c	8b 10		 mov	 edx, DWORD PTR [eax]
  0014e	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00151	8b 4c 01 38	 mov	 ecx, DWORD PTR [ecx+eax+56]
  00155	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0015c	85 c9		 test	 ecx, ecx
  0015e	74 07		 je	 SHORT $LN150@getline
  00160	8b 11		 mov	 edx, DWORD PTR [ecx]
  00162	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00165	ff d0		 call	 eax
$LN150@getline:
  00167	8b c6		 mov	 eax, esi

; 669  : 		}

  00169	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0016c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00173	59		 pop	 ecx
  00174	5f		 pop	 edi
  00175	5e		 pop	 esi
  00176	5b		 pop	 ebx
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c2 10 00	 ret	 16			; 00000010H
$LN2@getline:

; 656  : 					break;
; 657  : 					}
; 658  : 				else
; 659  : 					{	// got a character, add it to string
; 660  : 					++_Chcount;

  0017d	83 46 08 01	 add	 DWORD PTR [esi+8], 1

; 661  : 					*_Str++ = _Traits::to_char_type(_Meta);

  00181	8b 4d 08	 mov	 ecx, DWORD PTR __Str$[ebp]
  00184	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0
  00188	88 01		 mov	 BYTE PTR [ecx], al
  0018a	41		 inc	 ecx
  0018b	89 4d 08	 mov	 DWORD PTR __Str$[ebp], ecx
  0018e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00190	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00193	8b 4c 32 38	 mov	 ecx, DWORD PTR [edx+esi+56]
  00197	e8 00 00 00 00	 call	 ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
  0019c	e9 12 ff ff ff	 jmp	 $LL160@getline
__catch$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$0:

; 662  : 					}
; 663  : 			_CATCH_IO_END

  001a1	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a9	03 c1		 add	 eax, ecx
  001ab	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001ae	83 c9 04	 or	 ecx, 4
  001b1	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  001b5	75 03		 jne	 SHORT $LN78@getline
  001b7	83 c9 04	 or	 ecx, 4
$LN78@getline:
  001ba	83 e1 17	 and	 ecx, 23			; 00000017H
  001bd	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  001c0	85 48 10	 test	 DWORD PTR [eax+16], ecx
  001c3	75 15		 jne	 SHORT $LN87@getline
  001c5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  001cc	b8 00 00 00 00	 mov	 eax, $LN20@getline
  001d1	c3		 ret	 0
$LN20@getline:
  001d2	8b 75 e8	 mov	 esi, DWORD PTR _this$[ebp]
  001d5	e9 3a ff ff ff	 jmp	 $LN166@getline
$LN87@getline:
  001da	6a 00		 push	 0
  001dc	6a 00		 push	 0
  001de	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN170@getline:
$LN169@getline:
  001e3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$3:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z$2:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::getline
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
EXTRN	?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z:PROC		; std::_Fiopen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0
__ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
$T163056 = 16						; size = 4
__Prot$ = 16						; size = 4
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 218  : 		{	// open a C stream with specified mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 219  : 		_Filet *_File;
; 220  : 		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)

  00026	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  0002a	0f 85 97 00 00
	00		 jne	 $LN1@open
  00030	8b 45 10	 mov	 eax, DWORD PTR __Prot$[ebp]
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR __Mode$[ebp]
  00036	8b 55 08	 mov	 edx, DWORD PTR __Filename$[ebp]
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z ; std::_Fiopen
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	85 c0		 test	 eax, eax
  00046	74 7f		 je	 SHORT $LN1@open

; 222  : 
; 223  : 		_Init(_File, _Openfl);

  00048	6a 01		 push	 1
  0004a	50		 push	 eax
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 224  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

  00052	8d 45 10	 lea	 eax, DWORD PTR $T163056[ebp]
  00055	50		 push	 eax
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ; std::basic_streambuf<char,std::char_traits<char> >::getloc
  0005d	50		 push	 eax
  0005e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00065	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
  0006a	8b f8		 mov	 edi, eax
  0006c	8b 17		 mov	 edx, DWORD PTR [edi]
  0006e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00071	83 c4 04	 add	 esp, 4
  00074	8b cf		 mov	 ecx, edi
  00076	ff d0		 call	 eax
  00078	84 c0		 test	 al, al
  0007a	74 24		 je	 SHORT $LN7@open
  0007c	8d 4d 10	 lea	 ecx, DWORD PTR $T163056[ebp]
  0007f	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
  00086	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 225  : 		return (this);	// open succeeded

  0008b	8b c6		 mov	 eax, esi

; 226  : 		}

  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 0c 00	 ret	 12			; 0000000cH

; 224  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

$LN7@open:
  000a0	8b ce		 mov	 ecx, esi
  000a2	89 7e 44	 mov	 DWORD PTR [esi+68], edi
  000a5	e8 00 00 00 00	 call	 ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
  000aa	8d 4d 10	 lea	 ecx, DWORD PTR $T163056[ebp]
  000ad	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 225  : 		return (this);	// open succeeded

  000b2	8b c6		 mov	 eax, esi

; 226  : 		}

  000b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000be	59		 pop	 ecx
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH
$LN1@open:

; 221  : 			return (0);	// open failed

  000c7	33 c0		 xor	 eax, eax

; 226  : 		}

  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0:
  00000	8d 4d 10	 lea	 ecx, DWORD PTR $T163056[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 935  : 		{	// assign _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 936  : 		if (_Count == npos)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	83 ff ff	 cmp	 edi, -1
  0000d	75 0a		 jne	 SHORT $LN2@assign@3

; 937  : 			_Xlen();	// result too long

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN82@assign@3:
$LN2@assign@3:

; 938  : 
; 939  : 		if (_Grow(_Count))

  00019	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0001c	76 0a		 jbe	 SHORT $LN13@assign@3
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00023	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN83@assign@3:
$LN13@assign@3:
  00028	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002b	3b c7		 cmp	 eax, edi
  0002d	73 22		 jae	 SHORT $LN12@assign@3
  0002f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00032	50		 push	 eax
  00033	57		 push	 edi
  00034	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00039	85 ff		 test	 edi, edi
  0003b	74 79		 je	 SHORT $LN77@assign@3
$LN81@assign@3:

; 940  : 			{	// make room and assign new stuff
; 941  : 			_Chassign(0, _Count, _Ch);

  0003d	83 ff 01	 cmp	 edi, 1
  00040	75 3c		 jne	 SHORT $LN56@assign@3
  00042	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00046	72 2d		 jb	 SHORT $LN61@assign@3
  00048	8b 06		 mov	 eax, DWORD PTR [esi]
  0004a	8a 4d 0c	 mov	 cl, BYTE PTR __Ch$[ebp]
  0004d	88 08		 mov	 BYTE PTR [eax], cl
  0004f	eb 48		 jmp	 SHORT $LN69@assign@3

; 938  : 
; 939  : 		if (_Grow(_Count))

$LN12@assign@3:
  00051	85 ff		 test	 edi, edi
  00053	75 e8		 jne	 SHORT $LN81@assign@3
  00055	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00058	83 f8 10	 cmp	 eax, 16			; 00000010H
  0005b	72 0d		 jb	 SHORT $LN51@assign@3
  0005d	8b 06		 mov	 eax, DWORD PTR [esi]
  0005f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00062	5f		 pop	 edi

; 943  : 			}
; 944  : 		return (*this);

  00063	8b c6		 mov	 eax, esi
  00065	5e		 pop	 esi

; 945  : 		}

  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8

; 938  : 
; 939  : 		if (_Grow(_Count))

$LN51@assign@3:
  0006a	8b c6		 mov	 eax, esi
  0006c	5f		 pop	 edi
  0006d	c6 00 00	 mov	 BYTE PTR [eax], 0
  00070	5e		 pop	 esi

; 945  : 		}

  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8

; 940  : 			{	// make room and assign new stuff
; 941  : 			_Chassign(0, _Count, _Ch);

$LN61@assign@3:
  00075	8a 4d 0c	 mov	 cl, BYTE PTR __Ch$[ebp]
  00078	8b c6		 mov	 eax, esi
  0007a	88 08		 mov	 BYTE PTR [eax], cl
  0007c	eb 1b		 jmp	 SHORT $LN69@assign@3
$LN56@assign@3:
  0007e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00082	72 04		 jb	 SHORT $LN67@assign@3
  00084	8b 06		 mov	 eax, DWORD PTR [esi]
  00086	eb 02		 jmp	 SHORT $LN68@assign@3
$LN67@assign@3:
  00088	8b c6		 mov	 eax, esi
$LN68@assign@3:
  0008a	0f be 55 0c	 movsx	 edx, BYTE PTR __Ch$[ebp]
  0008e	57		 push	 edi
  0008f	52		 push	 edx
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _memset
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN69@assign@3:

; 942  : 			_Eos(_Count);

  00099	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0009d	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000a0	72 0e		 jb	 SHORT $LN75@assign@3
  000a2	8b 06		 mov	 eax, DWORD PTR [esi]
  000a4	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  000a8	5f		 pop	 edi

; 943  : 			}
; 944  : 		return (*this);

  000a9	8b c6		 mov	 eax, esi
  000ab	5e		 pop	 esi

; 945  : 		}

  000ac	5d		 pop	 ebp
  000ad	c2 08 00	 ret	 8

; 942  : 			_Eos(_Count);

$LN75@assign@3:
  000b0	8b c6		 mov	 eax, esi
  000b2	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN77@assign@3:

; 943  : 			}
; 944  : 		return (*this);

  000b6	5f		 pop	 edi
  000b7	8b c6		 mov	 eax, esi
  000b9	5e		 pop	 esi

; 945  : 		}

  000ba	5d		 pop	 ebp
  000bb	c2 08 00	 ret	 8
$LN79@assign@3:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
;	COMDAT ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
CONST	SEGMENT
??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
	DD	010H
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z$0
__ehfuncinfo$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T163299 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 33   : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002d	33 db		 xor	 ebx, ebx
  0002f	89 5d f0	 mov	 DWORD PTR $T163299[ebp], ebx
  00032	39 5d 10	 cmp	 DWORD PTR _$initVBases$[ebp], ebx
  00035	74 17		 je	 SHORT $LN1@basic_istr
  00037	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
  0003d	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  00044	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00047	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T163299[ebp], 1
$LN1@basic_istr:
  0004e	8b 07		 mov	 eax, DWORD PTR [edi]
  00050	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00053	c7 04 0f 00 00
	00 00		 mov	 DWORD PTR [edi+ecx], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@

; 34   : 		_Myios::init(_Strbuf, _Isstd);

  0005a	8b 17		 mov	 edx, DWORD PTR [edi]
  0005c	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0005f	89 5f 0c	 mov	 DWORD PTR [edi+12], ebx
  00062	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00065	03 f7		 add	 esi, edi
  00067	8b ce		 mov	 ecx, esi
  00069	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init
  0006e	8b 45 08	 mov	 eax, DWORD PTR __Strbuf$[ebp]
  00071	6a 20		 push	 32			; 00000020H
  00073	8b ce		 mov	 ecx, esi
  00075	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00078	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  0007b	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
  00080	88 46 40	 mov	 BYTE PTR [esi+64], al
  00083	39 5e 38	 cmp	 DWORD PTR [esi+56], ebx
  00086	75 0f		 jne	 SHORT $LN19@basic_istr
  00088	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0008b	83 c8 04	 or	 eax, 4
  0008e	53		 push	 ebx
  0008f	50		 push	 eax
  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN19@basic_istr:
  00097	38 5d 0c	 cmp	 BYTE PTR __Isstd$[ebp], bl
  0009a	74 09		 je	 SHORT $LN23@basic_istr
  0009c	56		 push	 esi
  0009d	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  000a2	83 c4 04	 add	 esp, 4
$LN23@basic_istr:

; 35   : 		}

  000a5	8b c7		 mov	 eax, edi
  000a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b1	59		 pop	 ecx
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T163299[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_istr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T163299[ebp], -2 ; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@basic_istr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
PUBLIC	??_G?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAXI@Z ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAXI@Z PROC ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  0000a	72 0c		 jb	 SHORT $LN18@scalar@17
  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN18@scalar@17:
  00018	33 c0		 xor	 eax, eax
  0001a	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001e	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00025	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00028	88 46 04	 mov	 BYTE PTR [esi+4], al
  0002b	74 09		 je	 SHORT $LN30@scalar@17
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00033	83 c4 04	 add	 esp, 4
$LN30@scalar@17:
  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??_G?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAXI@Z ENDP ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	?GetInt@TokenizerRow@@QAEHKKH@Z			; TokenizerRow::GetInt
EXTRN	_atoi:PROC
EXTRN	_sscanf_s:PROC
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\tokenizer.h
CONST	ENDS
;	COMDAT ?GetInt@TokenizerRow@@QAEHKKH@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
_Column$ = 8						; size = 4
_pOffset$142290 = 12					; size = 4
_Default$ = 12						; size = 4
_Hex$ = 16						; size = 4
?GetInt@TokenizerRow@@QAEHKKH@Z PROC			; TokenizerRow::GetInt, COMDAT
; _this$ = ecx

; 31   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 32   : 		
; 33   : 		std::map<DWORD, std::string>::iterator it = this->Columns.find(Column);

  00007	8d 45 08	 lea	 eax, DWORD PTR _Column$[ebp]
  0000a	50		 push	 eax
  0000b	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  0000e	51		 push	 ecx
  0000f	8b ce		 mov	 ecx, esi
  00011	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find

; 34   : 		
; 35   : 		if(it == this->Columns.end())

  00016	8b 45 fc	 mov	 eax, DWORD PTR _it$[ebp]
  00019	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0001c	5e		 pop	 esi

; 36   : 		{
; 37   : 			return Default;

  0001d	74 29		 je	 SHORT $LN45@GetInt

; 43   : 			sscanf_s(it->second.c_str(), "%x", &pOffset);

  0001f	83 c0 10	 add	 eax, 16			; 00000010H
  00022	83 7d 10 00	 cmp	 DWORD PTR _Hex$[ebp], 0
  00026	74 29		 je	 SHORT $LN1@GetInt

; 38   : 		}
; 39   : 
; 40   : 		if(Hex)
; 41   : 		{
; 42   : 			unsigned int pOffset = Default;

  00028	8b 55 0c	 mov	 edx, DWORD PTR _Default$[ebp]
  0002b	89 55 0c	 mov	 DWORD PTR _pOffset$142290[ebp], edx

; 43   : 			sscanf_s(it->second.c_str(), "%x", &pOffset);

  0002e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00032	72 02		 jb	 SHORT $LN29@GetInt
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
$LN29@GetInt:
  00036	8d 4d 0c	 lea	 ecx, DWORD PTR _pOffset$142290[ebp]
  00039	51		 push	 ecx
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _sscanf_s
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN45@GetInt:

; 44   : 			return pOffset;

  00048	8b 45 0c	 mov	 eax, DWORD PTR _pOffset$142290[ebp]

; 48   : 
; 49   : 	}

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
$LN1@GetInt:

; 45   : 		}
; 46   : 
; 47   : 		return atoi(it->second.c_str());

  00051	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00055	72 02		 jb	 SHORT $LN43@GetInt
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
$LN43@GetInt:
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _atoi
  0005f	83 c4 04	 add	 esp, 4

; 48   : 
; 49   : 	}

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 0c 00	 ret	 12			; 0000000cH
?GetInt@TokenizerRow@@QAEHKKH@Z ENDP			; TokenizerRow::GetInt
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 543  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 544  : 		_Tidy();
; 545  : 		assign(_Right, 0, npos);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	6a ff		 push	 -1
  00009	8b f1		 mov	 esi, ecx
  0000b	6a 00		 push	 0
  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001b	50		 push	 eax
  0001c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 546  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogtp
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 788  : 		{	// append 1 * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 789  : 		return (append((size_type)1, _Ch));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 790  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 929  : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 930  : 		_DEBUG_POINTER(_Ptr);
; 931  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	8b c6		 mov	 eax, esi
  00009	57		 push	 edi
  0000a	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000d	8d 49 00	 npad	 3
$LL5@assign@4:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL5@assign@4
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 932  : 		}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z ; std::basic_istream<char,std::char_traits<char> >::getline
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
;	COMDAT ?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Count$ = 12						; size = 8
?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z PROC ; std::basic_istream<char,std::char_traits<char> >::getline, COMDAT
; _this$ = ecx

; 622  : 		{	// get up to _Count characters into NTCS, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 623  : 		return (getline(_Str, _Count, _Myios::widen('\n')));

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000b	6a 0a		 push	 10			; 0000000aH
  0000d	03 ce		 add	 ecx, esi
  0000f	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
  00014	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp+4]
  00017	0f b6 c8	 movzx	 ecx, al
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __Str$[ebp]
  00021	52		 push	 edx
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	8b ce		 mov	 ecx, esi
  00026	e8 00 00 00 00	 call	 ?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z ; std::basic_istream<char,std::char_traits<char> >::getline
  0002b	5e		 pop	 esi

; 624  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::getline
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_memcpy_s:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0
__ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
__Dest$148858 = -56					; size = 4
__Src$148859 = -52					; size = 4
__Ch$148857 = -45					; size = 1
__Str$148853 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 423  : 		{	// get an element from stream, point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f1		 mov	 esi, ecx

; 424  : 		if (_Mysb::gptr() != 0
; 425  : 			&& _Mysb::gptr() < _Mysb::egptr())

  0002d	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	33 d2		 xor	 edx, edx
  00034	3b c2		 cmp	 eax, edx
  00036	74 27		 je	 SHORT $LN18@uflow@2
  00038	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0003b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003d	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00040	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00042	03 c8		 add	 ecx, eax
  00044	3b c1		 cmp	 eax, ecx
  00046	73 17		 jae	 SHORT $LN18@uflow@2

; 426  : 			return (_Traits::to_int_type(
; 427  : 				*_Mysb::_Gninc()));	// return buffered

  00048	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0004b	ff 08		 dec	 DWORD PTR [eax]
  0004d	8b 76 20	 mov	 esi, DWORD PTR [esi+32]
  00050	8b 06		 mov	 eax, DWORD PTR [esi]
  00052	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00055	89 16		 mov	 DWORD PTR [esi], edx
  00057	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0005a	e9 33 01 00 00	 jmp	 $LN14@uflow@2
$LN18@uflow@2:

; 428  : 		else if (_Myfile == 0)

  0005f	39 56 54	 cmp	 DWORD PTR [esi+84], edx

; 429  : 			return (_Traits::eof());	// no open C stream, fail

  00062	0f 84 27 01 00
	00		 je	 $LN198@uflow@2

; 430  : 		_Reset_back();	// revert from _Mychar buffer

  00068	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0006b	8d 7e 48	 lea	 edi, DWORD PTR [esi+72]
  0006e	39 39		 cmp	 DWORD PTR [ecx], edi
  00070	75 14		 jne	 SHORT $LN41@uflow@2
  00072	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00075	8b 7e 3c	 mov	 edi, DWORD PTR [esi+60]
  00078	89 39		 mov	 DWORD PTR [ecx], edi
  0007a	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0007d	89 01		 mov	 DWORD PTR [ecx], eax
  0007f	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00082	2b c0		 sub	 eax, eax
  00084	89 01		 mov	 DWORD PTR [ecx], eax
$LN41@uflow@2:

; 431  : 		if (_Pcvt == 0)

  00086	39 56 44	 cmp	 DWORD PTR [esi+68], edx
  00089	75 1d		 jne	 SHORT $LN15@uflow@2

; 432  : 			{	// no codecvt facet, just get it
; 433  : 			_Elem _Ch = 0;
; 434  : 			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)
; 435  : 				: _Traits::eof());

  0008b	8b 76 54	 mov	 esi, DWORD PTR [esi+84]
  0008e	56		 push	 esi
  0008f	e8 00 00 00 00	 call	 _fgetc
  00094	83 c4 04	 add	 esp, 4
  00097	83 f8 ff	 cmp	 eax, -1
  0009a	0f 84 ef 00 00
	00		 je	 $LN198@uflow@2
  000a0	0f b6 c0	 movzx	 eax, al
  000a3	e9 ea 00 00 00	 jmp	 $LN14@uflow@2
$LN15@uflow@2:

; 436  : 			}
; 437  : 		else
; 438  : 			{	// build string until codecvt succeeds
; 439  : 			string _Str;

  000a8	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR __Str$148853[ebp+20], 15 ; 0000000fH
  000af	89 55 e4	 mov	 DWORD PTR __Str$148853[ebp+16], edx
  000b2	88 55 d4	 mov	 BYTE PTR __Str$148853[ebp], dl
  000b5	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx

; 440  : 
; 441  : 			for (; ; )
; 442  : 				{	// get using codecvt facet
; 443  : 				_Elem _Ch, *_Dest;
; 444  : 				const char *_Src;
; 445  : 				int _Nleft;
; 446  : 				int _Meta = fgetc(_Myfile);

  000b8	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 _fgetc
  000c1	83 c4 04	 add	 esp, 4

; 447  : 
; 448  : 				if (_Meta == EOF)

  000c4	83 f8 ff	 cmp	 eax, -1
  000c7	0f 84 ba 00 00
	00		 je	 $LN1@uflow@2
$LN13@uflow@2:

; 449  : 					return (_Traits::eof());	// partial char?
; 450  : 
; 451  : 				_Str.append(1, (char)_Meta);	// append byte and convert

  000cd	50		 push	 eax
  000ce	6a 01		 push	 1
  000d0	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148853[ebp]
  000d3	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 452  : 				switch (_Pcvt->in(_State,
; 453  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
; 454  : 					&_Ch, &_Ch + 1, _Dest))

  000d8	8b 4d e8	 mov	 ecx, DWORD PTR __Str$148853[ebp+20]
  000db	8b 45 d4	 mov	 eax, DWORD PTR __Str$148853[ebp]
  000de	8b d0		 mov	 edx, eax
  000e0	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000e3	73 05		 jae	 SHORT $LN105@uflow@2
  000e5	8d 55 d4	 lea	 edx, DWORD PTR __Str$148853[ebp]
  000e8	8b c2		 mov	 eax, edx
$LN105@uflow@2:
  000ea	03 55 e4	 add	 edx, DWORD PTR __Str$148853[ebp+16]
  000ed	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  000f0	8b 39		 mov	 edi, DWORD PTR [ecx]
  000f2	8d 5d c8	 lea	 ebx, DWORD PTR __Dest$148858[ebp]
  000f5	53		 push	 ebx
  000f6	8d 5d d4	 lea	 ebx, DWORD PTR __Ch$148857[ebp+1]
  000f9	53		 push	 ebx
  000fa	8d 5d d3	 lea	 ebx, DWORD PTR __Ch$148857[ebp]
  000fd	53		 push	 ebx
  000fe	8d 5d cc	 lea	 ebx, DWORD PTR __Src$148859[ebp]
  00101	53		 push	 ebx
  00102	52		 push	 edx
  00103	50		 push	 eax
  00104	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  00107	50		 push	 eax
  00108	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0010b	ff d0		 call	 eax
  0010d	85 c0		 test	 eax, eax
  0010f	78 76		 js	 SHORT $LN1@uflow@2
  00111	83 f8 01	 cmp	 eax, 1
  00114	7e 38		 jle	 SHORT $LN8@uflow@2
  00116	83 f8 03	 cmp	 eax, 3
  00119	75 6c		 jne	 SHORT $LN1@uflow@2

; 468  : 					break;
; 469  : 
; 470  : 				case codecvt_base::noconv:
; 471  : 					if (_Str.size() < sizeof (_Elem))

  0011b	83 7d e4 01	 cmp	 DWORD PTR __Str$148853[ebp+16], 1
  0011f	72 51		 jb	 SHORT $LN4@uflow@2

; 472  : 						break;	// no conversion, but need more chars
; 473  : 
; 474  : 					_CRT_SECURE_MEMCPY(&_Ch, sizeof (_Elem), &*_Str.begin(),

  00121	83 7d e8 10	 cmp	 DWORD PTR __Str$148853[ebp+20], 16 ; 00000010H
  00125	8b 45 d4	 mov	 eax, DWORD PTR __Str$148853[ebp]
  00128	73 03		 jae	 SHORT $LN170@uflow@2
  0012a	8d 45 d4	 lea	 eax, DWORD PTR __Str$148853[ebp]
$LN170@uflow@2:
  0012d	6a 01		 push	 1
  0012f	50		 push	 eax
  00130	8d 4d d3	 lea	 ecx, DWORD PTR __Ch$148857[ebp]
  00133	6a 01		 push	 1
  00135	51		 push	 ecx
  00136	e8 00 00 00 00	 call	 _memcpy_s

; 475  : 						sizeof (_Elem));	// copy raw bytes to element
; 476  : 
; 477  : 					return (_Traits::to_int_type(_Ch));	// return result

  0013b	0f b6 75 d3	 movzx	 esi, BYTE PTR __Ch$148857[ebp]
  0013f	83 c4 10	 add	 esp, 16			; 00000010H
  00142	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148853[ebp]
  00145	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0014a	8b c6		 mov	 eax, esi
  0014c	eb 44		 jmp	 SHORT $LN14@uflow@2
$LN8@uflow@2:

; 455  : 					{	// test result of converting one element
; 456  : 				case codecvt_base::partial:
; 457  : 				case codecvt_base::ok:
; 458  : 					if (_Dest != &_Ch)

  0014e	8d 4d d3	 lea	 ecx, DWORD PTR __Ch$148857[ebp]
  00151	39 4d c8	 cmp	 DWORD PTR __Dest$148858[ebp], ecx
  00154	75 58		 jne	 SHORT $LN192@uflow@2

; 464  : 						}
; 465  : 					else
; 466  : 						_Str.erase((size_t)0,	// partial, discard used input
; 467  : 							(size_t)(_Src - &*_Str.begin()));

  00156	83 7d e8 10	 cmp	 DWORD PTR __Str$148853[ebp+20], 16 ; 00000010H
  0015a	8b 45 d4	 mov	 eax, DWORD PTR __Str$148853[ebp]
  0015d	73 03		 jae	 SHORT $LN149@uflow@2
  0015f	8d 45 d4	 lea	 eax, DWORD PTR __Str$148853[ebp]
$LN149@uflow@2:
  00162	8b 55 cc	 mov	 edx, DWORD PTR __Src$148859[ebp]
  00165	2b d0		 sub	 edx, eax
  00167	52		 push	 edx
  00168	6a 00		 push	 0
  0016a	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148853[ebp]
  0016d	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
$LN4@uflow@2:

; 440  : 
; 441  : 			for (; ; )
; 442  : 				{	// get using codecvt facet
; 443  : 				_Elem _Ch, *_Dest;
; 444  : 				const char *_Src;
; 445  : 				int _Nleft;
; 446  : 				int _Meta = fgetc(_Myfile);

  00172	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 _fgetc
  0017b	83 c4 04	 add	 esp, 4

; 447  : 
; 448  : 				if (_Meta == EOF)

  0017e	83 f8 ff	 cmp	 eax, -1
  00181	0f 85 46 ff ff
	ff		 jne	 $LN13@uflow@2
$LN1@uflow@2:

; 478  : 
; 479  : 				default:
; 480  : 					return (_Traits::eof());	// conversion failed

  00187	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148853[ebp]
  0018a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN198@uflow@2:
  0018f	83 c8 ff	 or	 eax, -1
$LN14@uflow@2:

; 481  : 					}
; 482  : 				}
; 483  : 			}
; 484  : 		}

  00192	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00195	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0019c	59		 pop	 ecx
  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	5b		 pop	 ebx
  001a0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a3	33 cd		 xor	 ecx, ebp
  001a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c3		 ret	 0
$LN192@uflow@2:

; 459  : 						{	// got an element, put back excess and deliver it
; 460  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

  001ae	83 7d e8 10	 cmp	 DWORD PTR __Str$148853[ebp+20], 16 ; 00000010H
  001b2	8b 7d d4	 mov	 edi, DWORD PTR __Str$148853[ebp]
  001b5	73 03		 jae	 SHORT $LN126@uflow@2
  001b7	8d 7d d4	 lea	 edi, DWORD PTR __Str$148853[ebp]
$LN126@uflow@2:
  001ba	2b 7d cc	 sub	 edi, DWORD PTR __Src$148859[ebp]
  001bd	03 7d e4	 add	 edi, DWORD PTR __Str$148853[ebp+16]

; 461  : 						for (; 0 < _Nleft; )

  001c0	85 ff		 test	 edi, edi
  001c2	7e 1a		 jle	 SHORT $LN5@uflow@2
$LN6@uflow@2:

; 462  : 							ungetc(_Src[--_Nleft], _Myfile);

  001c4	8b 45 cc	 mov	 eax, DWORD PTR __Src$148859[ebp]
  001c7	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  001ca	0f be 4c 07 ff	 movsx	 ecx, BYTE PTR [edi+eax-1]
  001cf	4f		 dec	 edi
  001d0	52		 push	 edx
  001d1	51		 push	 ecx
  001d2	e8 00 00 00 00	 call	 _ungetc
  001d7	83 c4 08	 add	 esp, 8
  001da	85 ff		 test	 edi, edi
  001dc	7f e6		 jg	 SHORT $LN6@uflow@2
$LN5@uflow@2:

; 463  : 						return (_Traits::to_int_type(_Ch));

  001de	0f b6 75 d3	 movzx	 esi, BYTE PTR __Ch$148857[ebp]
  001e2	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148853[ebp]
  001e5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001ea	8b c6		 mov	 eax, esi
  001ec	eb a4		 jmp	 SHORT $LN14@uflow@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148853[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 571  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 572  : 		_Tidy();
; 573  : 		assign(_Right, _Roff, _Count);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00018	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001f	52		 push	 edx
  00020	8b ce		 mov	 ecx, esi
  00022	c6 06 00	 mov	 BYTE PTR [esi], 0
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 574  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 606  : 		{	// construct from _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		_Tidy();
; 608  : 		assign(_Count, _Ch);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00015	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001c	8b ce		 mov	 ecx, esi
  0001e	c6 06 00	 mov	 BYTE PTR [esi], 0
  00021	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 609  : 		}

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 887  : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 888  : 		return (assign(_Right, 0, npos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	6a ff		 push	 -1
  00008	6a 00		 push	 0
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 889  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >
;	COMDAT ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
CONST	SEGMENT
??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
	DD	08H
CONST	ENDS
;	COMDAT ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
	DD	018H
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$0
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$1
	DD	02H
	DD	00H
__ehfuncinfo$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T164283 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
_$initVBases$ = 12					; size = 4
??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 939  : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002d	33 db		 xor	 ebx, ebx
  0002f	89 5d f0	 mov	 DWORD PTR $T164283[ebp], ebx
  00032	39 5d 0c	 cmp	 DWORD PTR _$initVBases$[ebp], ebx
  00035	74 1e		 je	 SHORT $LN1@basic_iost
  00037	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0003d	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00044	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  0004b	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T164283[ebp], 1
$LN1@basic_iost:
  00055	8b 07		 mov	 eax, DWORD PTR [edi]
  00057	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005a	c7 04 0f 00 00
	00 00		 mov	 DWORD PTR [edi+ecx], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00061	8b 17		 mov	 edx, DWORD PTR [edi]
  00063	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00066	89 5f 0c	 mov	 DWORD PTR [edi+12], ebx
  00069	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0006c	03 f7		 add	 esi, edi
  0006e	8b ce		 mov	 ecx, esi
  00070	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init
  00075	8b 45 08	 mov	 eax, DWORD PTR __Strbuf$[ebp]
  00078	6a 20		 push	 32			; 00000020H
  0007a	8b ce		 mov	 ecx, esi
  0007c	89 46 38	 mov	 DWORD PTR [esi+56], eax
  0007f	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  00082	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
  00087	88 46 40	 mov	 BYTE PTR [esi+64], al
  0008a	39 5e 38	 cmp	 DWORD PTR [esi+56], ebx
  0008d	75 12		 jne	 SHORT $LN30@basic_iost
  0008f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00092	83 c8 04	 or	 eax, 4
  00095	83 c8 04	 or	 eax, 4
  00098	53		 push	 ebx
  00099	50		 push	 eax
  0009a	8b ce		 mov	 ecx, esi
  0009c	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN30@basic_iost:
  000a1	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  000a4	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a7	c7 44 17 10 00
	00 00 00	 mov	 DWORD PTR [edi+edx+16], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  000af	8b 07		 mov	 eax, DWORD PTR [edi]
  000b1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b4	c7 04 0f 00 00
	00 00		 mov	 DWORD PTR [edi+ecx], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@

; 940  : 		}

  000bb	8b c7		 mov	 eax, edi
  000bd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c7	59		 pop	 ecx
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T164283[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_iost
  0000c	83 65 f0 fe	 and	 DWORD PTR $T164283[ebp], -2 ; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 18	 add	 ecx, 24			; 00000018H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@basic_iost:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$1:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 10	 add	 ecx, 16			; 00000010H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__ehhandler$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >
PUBLIC	__$ArrayPad$
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
EXTRN	_fwrite:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ$0
__ehfuncinfo$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
_TEXT	SEGMENT
__Dest$149739 = -48					; size = 4
__Str$149743 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT
; _this$ = ecx

; 587  : 		{	// put shift to initial conversion state, as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx

; 588  : 		if (_Pcvt == 0 || !_Wrotesome)

  0002d	33 db		 xor	 ebx, ebx
  0002f	39 5f 44	 cmp	 DWORD PTR [edi+68], ebx
  00032	0f 84 e9 00 00
	00		 je	 $LN14@Endwrite
  00038	38 5f 49	 cmp	 BYTE PTR [edi+73], bl
  0003b	0f 84 e0 00 00
	00		 je	 $LN14@Endwrite

; 590  : 		else
; 591  : 			{	// may have to put
; 592  : 			const int _STRING_INC = 8;
; 593  : 			char *_Dest;
; 594  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))

  00041	8b 07		 mov	 eax, DWORD PTR [edi]
  00043	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00046	6a ff		 push	 -1
  00048	ff d2		 call	 edx
  0004a	83 f8 ff	 cmp	 eax, -1

; 595  : 				return (false);

  0004d	0f 84 c2 00 00
	00		 je	 $LN220@Endwrite

; 596  : 
; 597  : 			string _Str(_STRING_INC, '\0');

  00053	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00058	33 c0		 xor	 eax, eax
  0005a	88 5d d4	 mov	 BYTE PTR __Str$149743[ebp], bl
  0005d	89 4d e8	 mov	 DWORD PTR __Str$149743[ebp+20], ecx
  00060	89 45 d4	 mov	 DWORD PTR __Str$149743[ebp], eax
  00063	89 45 d8	 mov	 DWORD PTR __Str$149743[ebp+4], eax
  00066	c7 45 e4 08 00
	00 00		 mov	 DWORD PTR __Str$149743[ebp+16], 8
  0006d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00070	73 03		 jae	 SHORT $LN126@Endwrite
  00072	8d 45 d4	 lea	 eax, DWORD PTR __Str$149743[ebp]
$LN126@Endwrite:
  00075	88 58 08	 mov	 BYTE PTR [eax+8], bl
  00078	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
$LN219@Endwrite:
  0007b	8b 45 d4	 mov	 eax, DWORD PTR __Str$149743[ebp]
  0007e	8b 5d e8	 mov	 ebx, DWORD PTR __Str$149743[ebp+20]
$LN11@Endwrite:

; 598  : 			for (; ; )
; 599  : 				switch (_Pcvt->unshift(_State,
; 600  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

  00081	8b d0		 mov	 edx, eax
  00083	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00086	73 05		 jae	 SHORT $LN157@Endwrite
  00088	8d 55 d4	 lea	 edx, DWORD PTR __Str$149743[ebp]
  0008b	8b c2		 mov	 eax, edx
$LN157@Endwrite:
  0008d	03 55 e4	 add	 edx, DWORD PTR __Str$149743[ebp+16]
  00090	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  00093	8b 31		 mov	 esi, DWORD PTR [ecx]
  00095	8d 5d d0	 lea	 ebx, DWORD PTR __Dest$149739[ebp]
  00098	53		 push	 ebx
  00099	52		 push	 edx
  0009a	50		 push	 eax
  0009b	8d 47 4c	 lea	 eax, DWORD PTR [edi+76]
  0009e	50		 push	 eax
  0009f	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000a2	ff d0		 call	 eax
  000a4	83 e8 00	 sub	 eax, 0
  000a7	74 0d		 je	 SHORT $LN7@Endwrite
  000a9	48		 dec	 eax
  000aa	74 0e		 je	 SHORT $LN6@Endwrite
  000ac	83 e8 02	 sub	 eax, 2

; 620  : 
; 621  : 				default:
; 622  : 					return (false);	// conversion failed

  000af	8d 4d d4	 lea	 ecx, DWORD PTR __Str$149743[ebp]
  000b2	75 5c		 jne	 SHORT $LN221@Endwrite

; 615  : 					break;
; 616  : 					}
; 617  : 
; 618  : 				case codecvt_base::noconv:
; 619  : 					return (true);	// nothing to do

  000b4	eb 66		 jmp	 SHORT $LN222@Endwrite
$LN7@Endwrite:

; 601  : 				{	// test result of homing conversion
; 602  : 				case codecvt_base::ok:
; 603  : 					_Wrotesome = false;	// homed successfully

  000b6	c6 47 49 00	 mov	 BYTE PTR [edi+73], 0
$LN6@Endwrite:

; 604  : 
; 605  : 				case codecvt_base::partial:	// fall through
; 606  : 					{	// put any generated bytes
; 607  : 					size_t _Count = _Dest - &*_Str.begin();

  000ba	8b 5d e8	 mov	 ebx, DWORD PTR __Str$149743[ebp+20]
  000bd	8b 45 d4	 mov	 eax, DWORD PTR __Str$149743[ebp]
  000c0	8b c8		 mov	 ecx, eax
  000c2	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000c5	73 03		 jae	 SHORT $LN178@Endwrite
  000c7	8d 4d d4	 lea	 ecx, DWORD PTR __Str$149743[ebp]
$LN178@Endwrite:
  000ca	8b 75 d0	 mov	 esi, DWORD PTR __Dest$149739[ebp]
  000cd	2b f1		 sub	 esi, ecx

; 608  : 					if (0 < _Count && _Count !=
; 609  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))

  000cf	74 22		 je	 SHORT $LN5@Endwrite
  000d1	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000d4	73 03		 jae	 SHORT $LN197@Endwrite
  000d6	8d 45 d4	 lea	 eax, DWORD PTR __Str$149743[ebp]
$LN197@Endwrite:
  000d9	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  000dc	51		 push	 ecx
  000dd	56		 push	 esi
  000de	6a 01		 push	 1
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _fwrite
  000e6	83 c4 10	 add	 esp, 16			; 00000010H
  000e9	3b f0		 cmp	 esi, eax
  000eb	75 20		 jne	 SHORT $LN212@Endwrite
  000ed	8b 5d e8	 mov	 ebx, DWORD PTR __Str$149743[ebp+20]
  000f0	8b 45 d4	 mov	 eax, DWORD PTR __Str$149743[ebp]
$LN5@Endwrite:

; 611  : 					if (!_Wrotesome)

  000f3	80 7f 49 00	 cmp	 BYTE PTR [edi+73], 0
  000f7	74 20		 je	 SHORT $LN213@Endwrite

; 613  : 					if (_Count == 0)

  000f9	85 f6		 test	 esi, esi
  000fb	75 84		 jne	 SHORT $LN11@Endwrite

; 614  : 						_Str.append(_STRING_INC, '\0');	// try with more space

  000fd	56		 push	 esi
  000fe	6a 08		 push	 8
  00100	8d 4d d4	 lea	 ecx, DWORD PTR __Str$149743[ebp]
  00103	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 623  : 				}

  00108	e9 6e ff ff ff	 jmp	 $LN219@Endwrite
$LN212@Endwrite:

; 610  : 						return (false);	// write failed

  0010d	8d 4d d4	 lea	 ecx, DWORD PTR __Str$149743[ebp]
$LN221@Endwrite:
  00110	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN220@Endwrite:
  00115	32 c0		 xor	 al, al
  00117	eb 0a		 jmp	 SHORT $LN13@Endwrite
$LN213@Endwrite:

; 612  : 						return (true);

  00119	8d 4d d4	 lea	 ecx, DWORD PTR __Str$149743[ebp]
$LN222@Endwrite:
  0011c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN14@Endwrite:

; 589  : 			return (true);

  00121	b0 01		 mov	 al, 1
$LN13@Endwrite:

; 624  : 			}
; 625  : 		}

  00123	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00126	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012d	59		 pop	 ecx
  0012e	5f		 pop	 edi
  0012f	5e		 pop	 esi
  00130	5b		 pop	 ebx
  00131	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00134	33 cd		 xor	 ecx, ebp
  00136	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Str$149743[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	??$_Destroy@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 63   : 	_Ptr->~_Ty();

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  0000b	72 0c		 jb	 SHORT $LN20@Destroy
  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$LN20@Destroy:
  00019	33 c0		 xor	 eax, eax
  0001b	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00022	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00025	88 46 04	 mov	 BYTE PTR [esi+4], al
  00028	5e		 pop	 esi

; 64   : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$_Destroy@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$?0ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Val2$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 0e		 mov	 DWORD PTR [esi], ecx
  00010	6a ff		 push	 -1
  00012	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00015	6a 00		 push	 0
  00017	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0001e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00025	52		 push	 edx
  00026	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00029	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 164  : 		}

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
??$?0ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 592  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		_Tidy();
; 594  : 		assign(_Ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b c2		 mov	 eax, edx
  0000b	57		 push	 edi
  0000c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00013	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001a	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001d	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$LL31@basic_stri@2:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL31@basic_stri@2
  00027	2b c7		 sub	 eax, edi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00032	5f		 pop	 edi

; 595  : 		}

  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 763  : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 764  : 		return (assign(_Right));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	6a ff		 push	 -1
  00008	6a 00		 push	 0
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 765  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 768  : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 769  : 		return (assign(_Ptr));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	8b c6		 mov	 eax, esi
  00009	57		 push	 edi
  0000a	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000d	8d 49 00	 npad	 3
$LL7@operator@10:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL7@operator@10
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 770  : 		}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
; Function compile flags: /Ogtp
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T165489 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 1848 : 		{	// return [_Off, _Off + _Count) as new string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1849 : 		return (_Myt(*this, _Off, _Count, get_allocator()));

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00010	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00017	89 45 fc	 mov	 DWORD PTR $T165489[ebp], eax
  0001a	88 06		 mov	 BYTE PTR [esi], al
  0001c	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0001f	50		 push	 eax
  00020	52		 push	 edx
  00021	51		 push	 ecx
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi

; 1850 : 		}

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z$0
__ehfuncinfo$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Src$148709 = -56					; size = 4
__Dest$148710 = -52					; size = 4
__Ch$148708 = -48					; size = 1
__Str$148711 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Meta$ = 8						; size = 4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 322  : 		{	// put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 323  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  0002b	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]

; 324  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  0002e	33 c0		 xor	 eax, eax
  00030	8b f1		 mov	 esi, ecx
  00032	83 fb ff	 cmp	 ebx, -1
  00035	0f 84 94 01 00
	00		 je	 $LN14@overflow

; 325  : 		else if (_Mysb::pptr() != 0
; 326  : 			&& _Mysb::pptr() < _Mysb::epptr())

  0003b	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	3b d0		 cmp	 edx, eax
  00042	74 20		 je	 SHORT $LN18@overflow
  00044	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00047	8b 39		 mov	 edi, DWORD PTR [ecx]
  00049	03 fa		 add	 edi, edx
  0004b	3b d7		 cmp	 edx, edi
  0004d	73 15		 jae	 SHORT $LN18@overflow

; 327  : 			{	// room in buffer, store it
; 328  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  0004f	ff 09		 dec	 DWORD PTR [ecx]
  00051	8b 76 24	 mov	 esi, DWORD PTR [esi+36]
  00054	8b 06		 mov	 eax, DWORD PTR [esi]
  00056	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00059	89 0e		 mov	 DWORD PTR [esi], ecx
  0005b	88 18		 mov	 BYTE PTR [eax], bl

; 329  : 			return (_Meta);

  0005d	8b c3		 mov	 eax, ebx
  0005f	e9 6b 01 00 00	 jmp	 $LN14@overflow
$LN18@overflow:

; 330  : 			}
; 331  : 		else if (_Myfile == 0)

  00064	39 46 54	 cmp	 DWORD PTR [esi+84], eax

; 332  : 			return (_Traits::eof());	// no open C stream, fail

  00067	0f 84 5f 01 00
	00		 je	 $LN270@overflow

; 333  : 		_Reset_back();	// revert from _Mychar buffer

  0006d	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00070	8d 7e 48	 lea	 edi, DWORD PTR [esi+72]
  00073	39 3a		 cmp	 DWORD PTR [edx], edi
  00075	75 14		 jne	 SHORT $LN57@overflow
  00077	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  0007a	8b 7e 3c	 mov	 edi, DWORD PTR [esi+60]
  0007d	89 3a		 mov	 DWORD PTR [edx], edi
  0007f	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00082	89 0a		 mov	 DWORD PTR [edx], ecx
  00084	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00087	2b c9		 sub	 ecx, ecx
  00089	89 0a		 mov	 DWORD PTR [edx], ecx
$LN57@overflow:

; 334  : 		if (_Pcvt == 0)

  0008b	39 46 44	 cmp	 DWORD PTR [esi+68], eax
  0008e	75 20		 jne	 SHORT $LN15@overflow

; 335  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)
; 336  : 				? _Meta : _Traits::eof());	// no codecvt facet, put as is

  00090	8b 76 54	 mov	 esi, DWORD PTR [esi+84]
  00093	0f be c3	 movsx	 eax, bl
  00096	56		 push	 esi
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _fputc
  0009d	83 c4 08	 add	 esp, 8
  000a0	83 f8 ff	 cmp	 eax, -1
  000a3	0f 84 23 01 00
	00		 je	 $LN270@overflow
  000a9	8b c3		 mov	 eax, ebx
  000ab	e9 1f 01 00 00	 jmp	 $LN14@overflow
$LN15@overflow:

; 337  : 		else
; 338  : 			{	// put using codecvt facet
; 339  : 			const int _STRING_INC = 8;
; 340  : 			const _Elem _Ch = _Traits::to_char_type(_Meta);
; 341  : 			const _Elem *_Src;
; 342  : 			char *_Dest;
; 343  : 
; 344  : 			string _Str(_STRING_INC, '\0');

  000b0	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  000b5	8b d0		 mov	 edx, eax
  000b7	88 45 d4	 mov	 BYTE PTR __Str$148711[ebp], al
  000ba	88 5d d0	 mov	 BYTE PTR __Ch$148708[ebp], bl
  000bd	89 4d e8	 mov	 DWORD PTR __Str$148711[ebp+20], ecx
  000c0	89 55 d4	 mov	 DWORD PTR __Str$148711[ebp], edx
  000c3	89 45 d8	 mov	 DWORD PTR __Str$148711[ebp+4], eax
  000c6	c7 45 e4 08 00
	00 00		 mov	 DWORD PTR __Str$148711[ebp+16], 8
  000cd	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000d0	73 03		 jae	 SHORT $LN168@overflow
  000d2	8d 55 d4	 lea	 edx, DWORD PTR __Str$148711[ebp]
$LN168@overflow:
  000d5	88 42 08	 mov	 BYTE PTR [edx+8], al
  000d8	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
$LN273@overflow:
  000db	8b 45 d4	 mov	 eax, DWORD PTR __Str$148711[ebp]
  000de	8b 5d e8	 mov	 ebx, DWORD PTR __Str$148711[ebp+20]
$LN13@overflow:

; 345  : 			for (; ; )
; 346  : 				switch (_Pcvt->out(_State,
; 347  : 					&_Ch, &_Ch + 1, _Src,
; 348  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

  000e1	8b d0		 mov	 edx, eax
  000e3	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000e6	73 05		 jae	 SHORT $LN199@overflow
  000e8	8d 55 d4	 lea	 edx, DWORD PTR __Str$148711[ebp]
  000eb	8b c2		 mov	 eax, edx
$LN199@overflow:
  000ed	03 55 e4	 add	 edx, DWORD PTR __Str$148711[ebp+16]
  000f0	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  000f3	8b 39		 mov	 edi, DWORD PTR [ecx]
  000f5	8d 5d cc	 lea	 ebx, DWORD PTR __Dest$148710[ebp]
  000f8	53		 push	 ebx
  000f9	52		 push	 edx
  000fa	50		 push	 eax
  000fb	8d 55 c8	 lea	 edx, DWORD PTR __Src$148709[ebp]
  000fe	52		 push	 edx
  000ff	8d 45 d1	 lea	 eax, DWORD PTR __Ch$148708[ebp+1]
  00102	50		 push	 eax
  00103	8d 55 d0	 lea	 edx, DWORD PTR __Ch$148708[ebp]
  00106	52		 push	 edx
  00107	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  0010a	50		 push	 eax
  0010b	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0010e	ff d0		 call	 eax
  00110	85 c0		 test	 eax, eax
  00112	0f 88 ac 00 00
	00		 js	 $LN1@overflow
  00118	83 f8 01	 cmp	 eax, 1
  0011b	7f 63		 jg	 SHORT $LN264@overflow

; 349  : 				{	// test result of converting one element
; 350  : 				case codecvt_base::partial:
; 351  : 				case codecvt_base::ok:
; 352  : 					{	// converted something, try to put it out
; 353  : 					size_t _Count = _Dest - &*_Str.begin();

  0011d	8b 5d e8	 mov	 ebx, DWORD PTR __Str$148711[ebp+20]
  00120	8b 45 d4	 mov	 eax, DWORD PTR __Str$148711[ebp]
  00123	8b c8		 mov	 ecx, eax
  00125	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00128	73 03		 jae	 SHORT $LN220@overflow
  0012a	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
$LN220@overflow:
  0012d	8b 7d cc	 mov	 edi, DWORD PTR __Dest$148710[ebp]
  00130	2b f9		 sub	 edi, ecx

; 354  : 					if (0 < _Count && _Count !=
; 355  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))

  00132	74 22		 je	 SHORT $LN8@overflow
  00134	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00137	73 03		 jae	 SHORT $LN239@overflow
  00139	8d 45 d4	 lea	 eax, DWORD PTR __Str$148711[ebp]
$LN239@overflow:
  0013c	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  0013f	51		 push	 ecx
  00140	57		 push	 edi
  00141	6a 01		 push	 1
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 _fwrite
  00149	83 c4 10	 add	 esp, 16			; 00000010H
  0014c	3b f8		 cmp	 edi, eax
  0014e	75 74		 jne	 SHORT $LN1@overflow
  00150	8b 5d e8	 mov	 ebx, DWORD PTR __Str$148711[ebp+20]
  00153	8b 45 d4	 mov	 eax, DWORD PTR __Str$148711[ebp]
$LN8@overflow:

; 356  : 						return (_Traits::eof());	// write failed
; 357  : 
; 358  : 					_Wrotesome = true;	// write succeeded
; 359  : 					if (_Src != &_Ch)

  00156	8d 55 d0	 lea	 edx, DWORD PTR __Ch$148708[ebp]
  00159	c6 46 49 01	 mov	 BYTE PTR [esi+73], 1
  0015d	39 55 c8	 cmp	 DWORD PTR __Src$148709[ebp], edx
  00160	75 55		 jne	 SHORT $LN266@overflow

; 361  : 
; 362  : 					if (0 < _Count)

  00162	85 ff		 test	 edi, edi
  00164	0f 85 77 ff ff
	ff		 jne	 $LN13@overflow

; 363  : 						;
; 364  : 					else if (_Str.size() < 4 * _STRING_INC)

  0016a	83 7d e4 20	 cmp	 DWORD PTR __Str$148711[ebp+16], 32 ; 00000020H

; 365  : 						_Str.append(_STRING_INC, '\0');	// try with more space

  0016e	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
  00171	73 54		 jae	 SHORT $LN4@overflow
  00173	57		 push	 edi
  00174	6a 08		 push	 8
  00176	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 377  : 				}

  0017b	e9 5b ff ff ff	 jmp	 $LN273@overflow
$LN264@overflow:

; 345  : 			for (; ; )
; 346  : 				switch (_Pcvt->out(_State,
; 347  : 					&_Ch, &_Ch + 1, _Src,
; 348  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

  00180	83 f8 03	 cmp	 eax, 3
  00183	75 3f		 jne	 SHORT $LN1@overflow

; 366  : 					else
; 367  : 						return (_Traits::eof());	// conversion failed
; 368  : 					break;
; 369  : 					}
; 370  : 
; 371  : 				case codecvt_base::noconv:
; 372  : 					return (_Fputc(_Ch, _Myfile) ? _Meta
; 373  : 						: _Traits::eof());	// no conversion, put as is

  00185	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00188	8b 4d d0	 mov	 ecx, DWORD PTR __Ch$148708[ebp]
  0018b	50		 push	 eax
  0018c	51		 push	 ecx
  0018d	e8 00 00 00 00	 call	 ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ; std::_Fputc<char>
  00192	83 c4 08	 add	 esp, 8
  00195	84 c0		 test	 al, al
  00197	74 0f		 je	 SHORT $LN25@overflow
  00199	8b 75 08	 mov	 esi, DWORD PTR __Meta$[ebp]
  0019c	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
  0019f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001a4	8b c6		 mov	 eax, esi
  001a6	eb 27		 jmp	 SHORT $LN14@overflow
$LN25@overflow:
  001a8	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
  001ab	83 ce ff	 or	 esi, -1
  001ae	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001b3	8b c6		 mov	 eax, esi
  001b5	eb 18		 jmp	 SHORT $LN14@overflow
$LN266@overflow:

; 360  : 						return (_Meta);	// converted whole element

  001b7	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
  001ba	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001bf	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  001c2	eb 0b		 jmp	 SHORT $LN14@overflow
$LN1@overflow:

; 374  : 
; 375  : 				default:
; 376  : 					return (_Traits::eof());	// conversion failed

  001c4	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
$LN4@overflow:
  001c7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN270@overflow:
  001cc	83 c8 ff	 or	 eax, -1
$LN14@overflow:

; 378  : 			}
; 379  : 		}

  001cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d9	59		 pop	 ecx
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	5b		 pop	 ebx
  001dd	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e0	33 cd		 xor	 ecx, ebp
  001e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Str$148711[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
EXTRN	_fgetpos:PROC
EXTRN	__fseeki64:PROC
; Function compile flags: /Ogtp
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Fileposition$ = 12					; size = 8
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 490  : 		{	// change position by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 491  : 		fpos_t _Fileposition;
; 492  : 
; 493  : 		if (_Mysb::gptr() == &_Mychar	// something putback
; 494  : 			&& _Way == ios_base::cur	// a relative seek
; 495  : 			&& _Pcvt == 0)	// not converting

  00007	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0000a	8d 46 48	 lea	 eax, DWORD PTR [esi+72]
  0000d	57		 push	 edi
  0000e	39 01		 cmp	 DWORD PTR [ecx], eax
  00010	75 1a		 jne	 SHORT $LN22@seekoff
  00012	83 7d 14 01	 cmp	 DWORD PTR __Way$[ebp], 1
  00016	75 14		 jne	 SHORT $LN22@seekoff
  00018	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  0001c	75 0e		 jne	 SHORT $LN22@seekoff

; 496  : 			_Off -= (off_type)sizeof (_Elem);	// back up over _Elem bytes

  0001e	8b 5d 0c	 mov	 ebx, DWORD PTR __Off$[ebp]
  00021	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00024	83 c3 ff	 add	 ebx, -1
  00027	83 d7 ff	 adc	 edi, -1
  0002a	eb 06		 jmp	 SHORT $LN5@seekoff
$LN22@seekoff:
  0002c	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0002f	8b 5d 0c	 mov	 ebx, DWORD PTR __Off$[ebp]
$LN5@seekoff:

; 497  : 
; 498  : 		if (_Myfile == 0 || !_Endwrite()
; 499  : 			|| (_Off != 0 || _Way != ios_base::cur)
; 500  : 				&& _FSEEK_OFF(_Myfile, _Off, _Way) != 0
; 501  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  00032	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  00036	0f 84 88 00 00
	00		 je	 $LN24@seekoff
  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00043	84 c0		 test	 al, al
  00045	74 7d		 je	 SHORT $LN24@seekoff
  00047	8b d3		 mov	 edx, ebx
  00049	0b d7		 or	 edx, edi
  0004b	75 06		 jne	 SHORT $LN23@seekoff
  0004d	83 7d 14 01	 cmp	 DWORD PTR __Way$[ebp], 1
  00051	74 16		 je	 SHORT $LN2@seekoff
$LN23@seekoff:
  00053	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00056	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  00059	50		 push	 eax
  0005a	57		 push	 edi
  0005b	53		 push	 ebx
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 __fseeki64
  00062	83 c4 10	 add	 esp, 16			; 00000010H
  00065	85 c0		 test	 eax, eax
  00067	75 5b		 jne	 SHORT $LN24@seekoff
$LN2@seekoff:
  00069	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0006c	8d 55 0c	 lea	 edx, DWORD PTR __Fileposition$[ebp]
  0006f	52		 push	 edx
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _fgetpos
  00076	83 c4 08	 add	 esp, 8
  00079	85 c0		 test	 eax, eax
  0007b	75 47		 jne	 SHORT $LN24@seekoff

; 503  : 
; 504  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

  0007d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00080	8d 46 48	 lea	 eax, DWORD PTR [esi+72]
  00083	39 01		 cmp	 DWORD PTR [ecx], eax
  00085	75 14		 jne	 SHORT $LN17@seekoff
  00087	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  0008a	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0008d	89 11		 mov	 DWORD PTR [ecx], edx
  0008f	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00092	89 01		 mov	 DWORD PTR [ecx], eax
  00094	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00097	2b c0		 sub	 eax, eax
  00099	89 02		 mov	 DWORD PTR [edx], eax
$LN17@seekoff:

; 505  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  0009b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0009e	8b 4d 0c	 mov	 ecx, DWORD PTR __Fileposition$[ebp]
  000a1	8b 55 10	 mov	 edx, DWORD PTR __Fileposition$[ebp+4]
  000a4	5f		 pop	 edi
  000a5	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000a8	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  000ab	5e		 pop	 esi
  000ac	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000b2	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000b9	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000bc	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000bf	5b		 pop	 ebx

; 506  : 			_Fileposition));	// return new position
; 507  : 		}

  000c0	5d		 pop	 ebp
  000c1	c2 14 00	 ret	 20			; 00000014H
$LN24@seekoff:

; 502  : 			return (pos_type(_BADOFF));	// report failure

  000c4	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000c7	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB+4
  000cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?_BADOFF@std@@3_JB
  000d3	5f		 pop	 edi
  000d4	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000d7	33 c9		 xor	 ecx, ecx
  000d9	5e		 pop	 esi
  000da	89 10		 mov	 DWORD PTR [eax], edx
  000dc	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000df	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  000e2	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000e5	5b		 pop	 ebx

; 506  : 			_Fileposition));	// return new position
; 507  : 		}

  000e6	5d		 pop	 ebp
  000e7	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
EXTRN	_fsetpos:PROC
; Function compile flags: /Ogtp
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT
__Fileposition$ = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 512  : 		{	// change position to _Pos

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 513  : 		fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);

  00006	8b 45 14	 mov	 eax, DWORD PTR __Pos$[ebp+8]
  00009	53		 push	 ebx

; 514  : 		off_type _Off = (off_type)_Pos - (off_type)_FPOSOFF(_Fileposition);

  0000a	8b 5d 10	 mov	 ebx, DWORD PTR __Pos$[ebp+4]
  0000d	56		 push	 esi
  0000e	8b f1		 mov	 esi, ecx
  00010	8b 4d 18	 mov	 ecx, DWORD PTR __Pos$[ebp+12]
  00013	89 4d fc	 mov	 DWORD PTR __Fileposition$[ebp+4], ecx

; 515  : 
; 516  : 		if (_Myfile == 0 || !_Endwrite()
; 517  : 			|| fsetpos(_Myfile, &_Fileposition) != 0
; 518  : 			|| _Off != 0 && _FSEEK_OFF(_Myfile, _Off, SEEK_CUR) != 0
; 519  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  00016	33 c9		 xor	 ecx, ecx
  00018	57		 push	 edi
  00019	8b 7d 0c	 mov	 edi, DWORD PTR __Pos$[ebp]
  0001c	89 45 f8	 mov	 DWORD PTR __Fileposition$[ebp], eax
  0001f	39 4e 54	 cmp	 DWORD PTR [esi+84], ecx
  00022	0f 84 87 00 00
	00		 je	 $LN2@seekpos
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0002f	84 c0		 test	 al, al
  00031	74 7a		 je	 SHORT $LN16@seekpos
  00033	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00036	8d 55 f8	 lea	 edx, DWORD PTR __Fileposition$[ebp]
  00039	52		 push	 edx
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _fsetpos
  00040	83 c4 08	 add	 esp, 8
  00043	85 c0		 test	 eax, eax
  00045	75 66		 jne	 SHORT $LN16@seekpos
  00047	8b cf		 mov	 ecx, edi
  00049	0b cb		 or	 ecx, ebx
  0004b	74 14		 je	 SHORT $LN1@seekpos
  0004d	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  00050	6a 01		 push	 1
  00052	53		 push	 ebx
  00053	57		 push	 edi
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 __fseeki64
  0005a	83 c4 10	 add	 esp, 16			; 00000010H
  0005d	85 c0		 test	 eax, eax
  0005f	75 4c		 jne	 SHORT $LN16@seekpos
$LN1@seekpos:
  00061	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  00064	8d 45 f8	 lea	 eax, DWORD PTR __Fileposition$[ebp]
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _fgetpos
  0006e	83 c4 08	 add	 esp, 8
  00071	85 c0		 test	 eax, eax
  00073	75 38		 jne	 SHORT $LN16@seekpos

; 521  : 
; 522  : 		_State = _POS_TYPE_TO_STATE(_Pos);

  00075	8b 55 1c	 mov	 edx, DWORD PTR __Pos$[ebp+16]

; 523  : 
; 524  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

  00078	8b ce		 mov	 ecx, esi
  0007a	89 56 4c	 mov	 DWORD PTR [esi+76], edx
  0007d	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 525  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  00082	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00085	8b 4d f8	 mov	 ecx, DWORD PTR __Fileposition$[ebp]
  00088	8b 55 fc	 mov	 edx, DWORD PTR __Fileposition$[ebp+4]
  0008b	5f		 pop	 edi
  0008c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0008f	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  00092	5e		 pop	 esi
  00093	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00099	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000a0	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000a3	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000a6	5b		 pop	 ebx

; 526  : 			_Fileposition));	// return new position
; 527  : 		}

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 20 00	 ret	 32			; 00000020H
$LN16@seekpos:

; 525  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000ad	33 c9		 xor	 ecx, ecx
$LN2@seekpos:

; 520  : 			return (pos_type(_BADOFF));	// report failure

  000af	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?_BADOFF@std@@3_JB
  000b8	5f		 pop	 edi
  000b9	89 10		 mov	 DWORD PTR [eax], edx
  000bb	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?_BADOFF@std@@3_JB+4
  000c1	5e		 pop	 esi
  000c2	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000c5	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000c8	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  000cb	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000ce	5b		 pop	 ebx

; 526  : 			_Fileposition));	// return new position
; 527  : 		}

  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 713  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 714  : 		if (this == &_Right)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 5d		 je	 SHORT $LN45@assign@5

; 715  : 			;
; 716  : 		else if (get_allocator() != _Right.get_allocator()
; 717  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 718  : 			*this = _Right;
; 719  : 		else
; 720  : 			{	// not same, clear this and steal from _Right
; 721  : 			_Tidy(true);

  0000e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00012	72 0b		 jb	 SHORT $LN33@assign@5
  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
$LN33@assign@5:
  0001f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00026	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002d	c6 06 00	 mov	 BYTE PTR [esi], 0

; 722  : 			if (_Right._Myres < this->_BUF_SIZE)

  00030	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00034	73 11		 jae	 SHORT $LN2@assign@5

; 723  : 				_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 724  : 					_Right._Mysize + 1);

  00036	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00039	41		 inc	 ecx
  0003a	51		 push	 ecx
  0003b	57		 push	 edi
  0003c	56		 push	 esi
  0003d	e8 00 00 00 00	 call	 _memmove
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 725  : 			else

  00045	eb 0a		 jmp	 SHORT $LN1@assign@5
$LN2@assign@5:

; 726  : 				{	// copy pointer
; 727  : 				this->_Bx._Ptr = _Right._Bx._Ptr;

  00047	8b 17		 mov	 edx, DWORD PTR [edi]
  00049	89 16		 mov	 DWORD PTR [esi], edx

; 728  : 				_Right._Bx._Ptr = 0;

  0004b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1@assign@5:

; 729  : 				}
; 730  : 			this->_Mysize = _Right._Mysize;

  00051	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00054	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 731  : 			this->_Myres = _Right._Myres;

  00057	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0005a	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 732  : 
; 733  : 			_Right._Mysize = 0;

  0005d	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 734  : 			_Right._Myres = 0;

  00064	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
$LN45@assign@5:

; 735  : 			}
; 736  : 		return (*this);

  0006b	5f		 pop	 edi
  0006c	8b c6		 mov	 eax, esi
  0006e	5e		 pop	 esi

; 737  : 		}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
EXTRN	_fclose:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 292  : 		{	// close the C stream

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 293  : 		_Myt *_Ans = this;
; 294  : 		if (_Myfile == 0)

  00004	33 db		 xor	 ebx, ebx
  00006	57		 push	 edi
  00007	8b fe		 mov	 edi, esi
  00009	39 5e 54	 cmp	 DWORD PTR [esi+84], ebx

; 295  : 			_Ans = 0;
; 296  : 		else

  0000c	74 1b		 je	 SHORT $LN18@close

; 297  : 			{	// put any homing sequence and close file
; 298  : 			if (!_Endwrite())

  0000e	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00013	84 c0		 test	 al, al
  00015	75 02		 jne	 SHORT $LN2@close

; 299  : 				_Ans = 0;

  00017	33 ff		 xor	 edi, edi
$LN2@close:

; 300  : 			if (fclose(_Myfile) != 0)

  00019	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _fclose
  00022	83 c4 04	 add	 esp, 4
  00025	85 c0		 test	 eax, eax
  00027	74 02		 je	 SHORT $LN1@close
$LN18@close:

; 301  : 				_Ans = 0;

  00029	33 ff		 xor	 edi, edi
$LN1@close:

; 302  : 			}
; 303  : 		_Init(0, _Closefl);

  0002b	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0002e	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00031	88 5e 50	 mov	 BYTE PTR [esi+80], bl
  00034	88 5e 49	 mov	 BYTE PTR [esi+73], bl
  00037	8d 56 18	 lea	 edx, DWORD PTR [esi+24]
  0003a	89 56 20	 mov	 DWORD PTR [esi+32], edx
  0003d	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00040	89 4e 24	 mov	 DWORD PTR [esi+36], ecx
  00043	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00046	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00049	8d 56 28	 lea	 edx, DWORD PTR [esi+40]
  0004c	89 56 30	 mov	 DWORD PTR [esi+48], edx
  0004f	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00052	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  00055	89 18		 mov	 DWORD PTR [eax], ebx
  00057	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  0005a	89 1a		 mov	 DWORD PTR [edx], ebx
  0005c	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0005f	89 18		 mov	 DWORD PTR [eax], ebx
  00061	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00064	89 19		 mov	 DWORD PTR [ecx], ebx
  00066	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00069	89 1a		 mov	 DWORD PTR [edx], ebx
  0006b	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0006e	89 18		 mov	 DWORD PTR [eax], ebx
  00070	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA

; 304  : 		return (_Ans);

  00079	8b c7		 mov	 eax, edi
  0007b	5f		 pop	 edi
  0007c	89 5e 44	 mov	 DWORD PTR [esi+68], ebx
  0007f	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx

; 305  : 		}

  00084	c3		 ret	 0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 213  : 		_Destroy(_Ptr);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  0000b	72 0c		 jb	 SHORT $LN22@destroy
  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$LN22@destroy:
  00019	33 c0		 xor	 eax, eax
  0001b	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00022	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00025	88 46 04	 mov	 BYTE PTR [esi+4], al
  00028	5e		 pop	 esi

; 214  : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy
_TEXT	ENDS
PUBLIC	??$?0$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@AAU01@@Z ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@AAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@AAU01@@Z PROC ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 195  : 		{	// construct from compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 0e		 mov	 DWORD PTR [esi], ecx
  0000d	6a ff		 push	 -1
  0000f	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00012	6a 00		 push	 0
  00014	83 c0 04	 add	 eax, 4
  00017	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0001e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00025	50		 push	 eax
  00026	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00029	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 196  : 		}

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??$?0$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@AAU01@@Z ENDP ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 702  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 703  : 		_Tidy();
; 704  : 		assign(_STD forward<_Myt>(_Right));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	50		 push	 eax
  00018	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 705  : 		}

  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 708  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 710  : 		}

  00003	5d		 pop	 ebp

; 709  : 		return (assign(_STD forward<_Myt>(_Right)));

  00004	e9 00 00 00 00	 jmp	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::close
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
;	COMDAT ?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 1340 : 		{	// close the C stream

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1341 : 		if (_Filebuffer.close() == 0)

  00003	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00006	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  0000b	85 c0		 test	 eax, eax
  0000d	75 1f		 jne	 SHORT $LN9@close@2

; 1342 : 			_Myios::setstate(ios_base::failbit);

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
  00018	03 ce		 add	 ecx, esi
  0001a	83 c8 02	 or	 eax, 2
  0001d	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00021	75 03		 jne	 SHORT $LN11@close@2
  00023	83 c8 04	 or	 eax, 4
$LN11@close@2:
  00026	6a 00		 push	 0
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN9@close@2:
  0002e	5e		 pop	 esi

; 1343 : 		}

  0002f	c3		 ret	 0
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::close
_TEXT	ENDS
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ$0
__ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 143  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 144  : 		if (_Myfile != 0)

  0002f	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	74 1e		 je	 SHORT $LN11@basic_file

; 145  : 			_Reset_back();	// revert from _Mychar buffer

  0003c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0003f	8d 56 48	 lea	 edx, DWORD PTR [esi+72]
  00042	39 11		 cmp	 DWORD PTR [ecx], edx
  00044	75 14		 jne	 SHORT $LN11@basic_file
  00046	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  00049	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0004c	89 11		 mov	 DWORD PTR [ecx], edx
  0004e	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00051	89 01		 mov	 DWORD PTR [ecx], eax
  00053	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00056	2b c0		 sub	 eax, eax
  00058	89 02		 mov	 DWORD PTR [edx], eax
$LN11@basic_file:

; 146  : 		if (_Closef)

  0005a	80 7e 50 00	 cmp	 BYTE PTR [esi+80], 0
  0005e	74 07		 je	 SHORT $LN1@basic_file

; 147  : 			close();

  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN1@basic_file:

; 148  : 		}

  00067	8b ce		 mov	 ecx, esi
  00069	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00070	e8 00 00 00 00	 call	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
  00075	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00078	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007f	59		 pop	 ecx
  00080	5e		 pop	 esi
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$0
__ehfuncinfo$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0002f	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	74 1e		 je	 SHORT $LN14@scalar@18
  0003c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0003f	8d 56 48	 lea	 edx, DWORD PTR [esi+72]
  00042	39 11		 cmp	 DWORD PTR [ecx], edx
  00044	75 14		 jne	 SHORT $LN14@scalar@18
  00046	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  00049	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0004c	89 11		 mov	 DWORD PTR [ecx], edx
  0004e	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00051	89 01		 mov	 DWORD PTR [ecx], eax
  00053	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00056	2b c0		 sub	 eax, eax
  00058	89 02		 mov	 DWORD PTR [edx], eax
$LN14@scalar@18:
  0005a	80 7e 50 00	 cmp	 BYTE PTR [esi+80], 0
  0005e	74 07		 je	 SHORT $LN4@scalar@18
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN4@scalar@18:
  00067	8b ce		 mov	 ecx, esi
  00069	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00070	e8 00 00 00 00	 call	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
  00075	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00079	74 09		 je	 SHORT $LN16@scalar@18
  0007b	56		 push	 esi
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00081	83 c4 04	 add	 esp, 4
$LN16@scalar@18:
  00084	8b c6		 mov	 eax, esi
  00086	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00089	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00090	59		 pop	 ecx
  00091	5e		 pop	 esi
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??0?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Val2$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 0e		 mov	 DWORD PTR [esi], ecx
  00010	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00013	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0001a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00021	52		 push	 edx
  00022	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 146  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$_Pair_base@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 287  : 	_Alval.destroy(_Pdest);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Pdest$[ebp]
  00007	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  0000b	72 0c		 jb	 SHORT $LN24@Dest_val
  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$LN24@Dest_val:
  00019	33 c0		 xor	 eax, eax
  0001b	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00022	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00025	88 46 04	 mov	 BYTE PTR [esi+4], al
  00028	5e		 pop	 esi

; 288  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	3d fe ff ff 07	 cmp	 eax, 134217726		; 07fffffeH
  0000e	72 23		 jb	 SHORT $LN17@Insert

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  00010	8b 75 14	 mov	 esi, DWORD PTR __Newnode$[ebp]
  00013	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00016	50		 push	 eax
  00017	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0002e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN377@Insert:
$LN17@Insert:

; 1640 : 			}
; 1641 : 		++this->_Mysize;
; 1642 : 		_Newnode->_Parent = _Wherenode;

  00033	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00036	40		 inc	 eax
  00037	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0003a	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0003d	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00040	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00043	32 db		 xor	 bl, bl
  00045	3b c2		 cmp	 eax, edx
  00047	75 10		 jne	 SHORT $LN16@Insert

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00049	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1647 : 			_Lmost() = _Newnode;

  0004c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004f	89 3a		 mov	 DWORD PTR [edx], edi

; 1648 : 			_Rmost() = _Newnode;

  00051	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00054	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00057	eb 20		 jmp	 SHORT $LN11@Insert
$LN16@Insert:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  00059	38 5d 0c	 cmp	 BYTE PTR __Addleft$[ebp], bl
  0005c	74 0d		 je	 SHORT $LN14@Insert

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  0005e	89 38		 mov	 DWORD PTR [eax], edi

; 1653 : 			if (_Wherenode == _Lmost())

  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	3b 02		 cmp	 eax, DWORD PTR [edx]
  00065	75 12		 jne	 SHORT $LN11@Insert

; 1654 : 				_Lmost() = _Newnode;

  00067	89 3a		 mov	 DWORD PTR [edx], edi

; 1655 : 			}
; 1656 : 		else

  00069	eb 0e		 jmp	 SHORT $LN11@Insert
$LN14@Insert:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  0006b	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 1659 : 			if (_Wherenode == _Rmost())

  0006e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00071	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00074	75 03		 jne	 SHORT $LN11@Insert

; 1660 : 				_Rmost() = _Newnode;

  00076	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN11@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00079	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007c	8b c7		 mov	 eax, edi
  0007e	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  00081	0f 85 8f 01 00
	00		 jne	 $LN9@Insert
$LL10@Insert:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0008d	3b 16		 cmp	 edx, DWORD PTR [esi]
  0008f	0f 85 c1 00 00
	00		 jne	 $LN8@Insert

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00095	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00098	38 5e 2c	 cmp	 BYTE PTR [esi+44], bl
  0009b	75 1c		 jne	 SHORT $LN7@Insert

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0009d	c6 42 2c 01	 mov	 BYTE PTR [edx+44], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  000a1	c6 46 2c 01	 mov	 BYTE PTR [esi+44], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  000a5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a8	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000ab	88 5a 2c	 mov	 BYTE PTR [edx+44], bl

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000ae	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1677 : 					}
; 1678 : 				else

  000b4	e9 51 01 00 00	 jmp	 $LN316@Insert
$LN7@Insert:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000b9	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  000bc	75 3a		 jne	 SHORT $LN111@Insert

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  000be	8b c2		 mov	 eax, edx

; 1683 : 						_Lrotate(_Pnode);

  000c0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000c3	8b 32		 mov	 esi, DWORD PTR [edx]
  000c5	89 70 08	 mov	 DWORD PTR [eax+8], esi
  000c8	8b 32		 mov	 esi, DWORD PTR [edx]
  000ca	38 5e 2d	 cmp	 BYTE PTR [esi+45], bl
  000cd	75 03		 jne	 SHORT $LN110@Insert
  000cf	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN110@Insert:
  000d2	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d5	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000d8	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000db	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000de	75 05		 jne	 SHORT $LN109@Insert
  000e0	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000e3	eb 0e		 jmp	 SHORT $LN106@Insert
$LN109@Insert:
  000e5	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000e8	3b 06		 cmp	 eax, DWORD PTR [esi]
  000ea	75 04		 jne	 SHORT $LN107@Insert
  000ec	89 16		 mov	 DWORD PTR [esi], edx
  000ee	eb 03		 jmp	 SHORT $LN106@Insert
$LN107@Insert:
  000f0	89 56 08	 mov	 DWORD PTR [esi+8], edx
$LN106@Insert:
  000f3	89 02		 mov	 DWORD PTR [edx], eax
  000f5	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN111@Insert:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000f8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000fb	c6 42 2c 01	 mov	 BYTE PTR [edx+44], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000ff	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00102	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00105	88 5a 2c	 mov	 BYTE PTR [edx+44], bl

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00108	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0010b	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0010e	8b 32		 mov	 esi, DWORD PTR [edx]
  00110	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00113	89 3a		 mov	 DWORD PTR [edx], edi
  00115	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00118	38 5f 2d	 cmp	 BYTE PTR [edi+45], bl
  0011b	75 03		 jne	 SHORT $LN173@Insert
  0011d	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN173@Insert:
  00120	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00123	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00126	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00129	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  0012c	75 0b		 jne	 SHORT $LN172@Insert
  0012e	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00131	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00134	e9 cb 00 00 00	 jmp	 $LN376@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN172@Insert:
  00139	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0013c	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  0013f	75 0b		 jne	 SHORT $LN170@Insert
  00141	89 77 08	 mov	 DWORD PTR [edi+8], esi
  00144	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00147	e9 b8 00 00 00	 jmp	 $LN376@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN170@Insert:
  0014c	89 37		 mov	 DWORD PTR [edi], esi
  0014e	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00151	e9 ae 00 00 00	 jmp	 $LN376@Insert
$LN8@Insert:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  00156	8b 36		 mov	 esi, DWORD PTR [esi]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  00158	38 5e 2c	 cmp	 BYTE PTR [esi+44], bl
  0015b	75 1c		 jne	 SHORT $LN3@Insert

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0015d	c6 42 2c 01	 mov	 BYTE PTR [edx+44], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  00161	c6 46 2c 01	 mov	 BYTE PTR [esi+44], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  00165	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00168	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0016b	88 5a 2c	 mov	 BYTE PTR [edx+44], bl

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  0016e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00171	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1703 : 					}
; 1704 : 				else

  00174	e9 91 00 00 00	 jmp	 $LN316@Insert
$LN3@Insert:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00179	3b 02		 cmp	 eax, DWORD PTR [edx]
  0017b	75 3c		 jne	 SHORT $LN253@Insert

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  0017d	8b c2		 mov	 eax, edx

; 1709 : 						_Rrotate(_Pnode);

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00184	89 30		 mov	 DWORD PTR [eax], esi
  00186	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00189	38 5e 2d	 cmp	 BYTE PTR [esi+45], bl
  0018c	75 03		 jne	 SHORT $LN252@Insert
  0018e	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN252@Insert:
  00191	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00194	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00197	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0019a	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0019d	75 05		 jne	 SHORT $LN251@Insert
  0019f	89 56 04	 mov	 DWORD PTR [esi+4], edx
  001a2	eb 0f		 jmp	 SHORT $LN248@Insert
$LN251@Insert:
  001a4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001a7	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  001aa	75 05		 jne	 SHORT $LN249@Insert
  001ac	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001af	eb 02		 jmp	 SHORT $LN248@Insert
$LN249@Insert:
  001b1	89 16		 mov	 DWORD PTR [esi], edx
$LN248@Insert:
  001b3	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001b6	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN253@Insert:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  001b9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bc	c6 42 2c 01	 mov	 BYTE PTR [edx+44], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  001c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001c3	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001c6	88 5a 2c	 mov	 BYTE PTR [edx+44], bl

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001c9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001cc	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001cf	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  001d2	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d4	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  001d7	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d9	38 5f 2d	 cmp	 BYTE PTR [edi+45], bl
  001dc	75 03		 jne	 SHORT $LN315@Insert
  001de	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN315@Insert:
  001e1	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001e4	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001e7	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  001ea	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  001ed	75 05		 jne	 SHORT $LN314@Insert
  001ef	89 77 04	 mov	 DWORD PTR [edi+4], esi
  001f2	eb 0e		 jmp	 SHORT $LN311@Insert
$LN314@Insert:
  001f4	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001f7	3b 17		 cmp	 edx, DWORD PTR [edi]
  001f9	75 04		 jne	 SHORT $LN312@Insert
  001fb	89 37		 mov	 DWORD PTR [edi], esi
  001fd	eb 03		 jmp	 SHORT $LN311@Insert
$LN312@Insert:
  001ff	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN311@Insert:
  00202	89 16		 mov	 DWORD PTR [esi], edx
$LN376@Insert:
  00204	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00207	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN316@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  0020a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0020d	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  00210	0f 84 71 fe ff
	ff		 je	 $LL10@Insert
$LN9@Insert:

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00216	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00219	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1720 : 		return (iterator(_Newnode, this));

  0021c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0021f	89 38		 mov	 DWORD PTR [eax], edi
  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	c6 41 2c 01	 mov	 BYTE PTR [ecx+44], 1
  00227	5b		 pop	 ebx

; 1721 : 		}

  00228	5d		 pop	 ebp
  00229	c2 10 00	 ret	 16			; 00000010H
$LN375@Insert:
?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z$0
__ehfuncinfo$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z
_TEXT	SEGMENT
$T168226 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z PROC ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR $T168226[ebp], eax
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c0		 test	 eax, eax
  00032	74 28		 je	 SHORT $LN3@construct
  00034	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00037	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	6a ff		 push	 -1
  0003d	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00040	6a 00		 push	 0
  00042	83 c2 04	 add	 edx, 4
  00045	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0004c	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00053	52		 push	 edx
  00054	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00057	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@construct:

; 209  : 		}

  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00066	59		 pop	 ecx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T168226[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAU21@@Z ENDP ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
PUBLIC	??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Val2$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 0e		 mov	 DWORD PTR [esi], ecx
  00010	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00013	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0001a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00021	52		 push	 edx
  00022	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 164  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Pair_base@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Pair_base<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
PUBLIC	??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	070H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	060H
CONST	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	070H
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$4
	DD	03H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1
	DD	05H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T168533 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$ = 16						; size = 4
_$initVBases$ = 20					; size = 4
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1171 : 		{	// construct with named file and specified mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002d	33 c0		 xor	 eax, eax
  0002f	89 45 f0	 mov	 DWORD PTR $T168533[ebp], eax
  00032	39 45 14	 cmp	 DWORD PTR _$initVBases$[ebp], eax
  00035	74 1e		 je	 SHORT $LN2@basic_fstr
  00037	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0003d	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00044	c7 47 70 00 00
	00 00		 mov	 DWORD PTR [edi+112], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  0004b	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  0004e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T168533[ebp], 1
$LN2@basic_fstr:
  00055	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00057	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005a	c7 04 17 00 00
	00 00		 mov	 DWORD PTR [edi+edx], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00061	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00064	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00067	8b 07		 mov	 eax, DWORD PTR [edi]
  00069	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0006c	03 df		 add	 ebx, edi
  0006e	8b cb		 mov	 ecx, ebx
  00070	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init
  00075	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00078	6a 20		 push	 32			; 00000020H
  0007a	8b cb		 mov	 ecx, ebx
  0007c	89 73 38	 mov	 DWORD PTR [ebx+56], esi
  0007f	c7 43 3c 00 00
	00 00		 mov	 DWORD PTR [ebx+60], 0
  00086	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
  0008b	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  0008f	88 43 40	 mov	 BYTE PTR [ebx+64], al
  00092	75 13		 jne	 SHORT $LN42@basic_fstr
  00094	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00097	83 c8 04	 or	 eax, 4
  0009a	83 c8 04	 or	 eax, 4
  0009d	6a 00		 push	 0
  0009f	50		 push	 eax
  000a0	8b cb		 mov	 ecx, ebx
  000a2	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN42@basic_fstr:
  000a7	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  000aa	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ad	c7 44 17 10 00
	00 00 00	 mov	 DWORD PTR [edi+edx+16], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ba	c7 04 0f 00 00
	00 00		 mov	 DWORD PTR [edi+ecx], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  000c1	8b 17		 mov	 edx, DWORD PTR [edi]
  000c3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c6	8b ce		 mov	 ecx, esi
  000c8	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  000cf	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  000d6	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
  000db	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  000de	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  000e1	33 db		 xor	 ebx, ebx
  000e3	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  000e9	c6 46 50 00	 mov	 BYTE PTR [esi+80], 0
  000ed	c6 46 49 00	 mov	 BYTE PTR [esi+73], 0
  000f1	8d 56 18	 lea	 edx, DWORD PTR [esi+24]
  000f4	89 56 20	 mov	 DWORD PTR [esi+32], edx
  000f7	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  000fa	89 4e 24	 mov	 DWORD PTR [esi+36], ecx
  000fd	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00100	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00103	8d 56 28	 lea	 edx, DWORD PTR [esi+40]
  00106	89 56 30	 mov	 DWORD PTR [esi+48], edx
  00109	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  0010c	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  0010f	89 18		 mov	 DWORD PTR [eax], ebx
  00111	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00114	89 1a		 mov	 DWORD PTR [edx], ebx
  00116	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00119	89 18		 mov	 DWORD PTR [eax], ebx
  0011b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0011e	89 19		 mov	 DWORD PTR [ecx], ebx
  00120	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00123	89 1a		 mov	 DWORD PTR [edx], ebx
  00125	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00128	89 18		 mov	 DWORD PTR [eax], ebx
  0012a	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  0012d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA
  00133	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  00136	89 5e 44	 mov	 DWORD PTR [esi+68], ebx

; 1172 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00139	8b 55 10	 mov	 edx, DWORD PTR __Prot$[ebp]
  0013c	8b 45 0c	 mov	 eax, DWORD PTR __Mode$[ebp]
  0013f	8b 4d 08	 mov	 ecx, DWORD PTR __Filename$[ebp]
  00142	52		 push	 edx
  00143	50		 push	 eax
  00144	51		 push	 ecx
  00145	8b ce		 mov	 ecx, esi
  00147	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0014b	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00150	85 c0		 test	 eax, eax
  00152	75 1d		 jne	 SHORT $LN81@basic_fstr

; 1173 : 			_Myios::setstate(ios_base::failbit);

  00154	8b 17		 mov	 edx, DWORD PTR [edi]
  00156	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00159	8b 44 39 0c	 mov	 eax, DWORD PTR [ecx+edi+12]
  0015d	03 cf		 add	 ecx, edi
  0015f	83 c8 02	 or	 eax, 2
  00162	39 59 38	 cmp	 DWORD PTR [ecx+56], ebx
  00165	75 03		 jne	 SHORT $LN79@basic_fstr
  00167	83 c8 04	 or	 eax, 4
$LN79@basic_fstr:
  0016a	53		 push	 ebx
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN81@basic_fstr:

; 1174 : 		}

  00171	8b c7		 mov	 eax, edi
  00173	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00176	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017d	59		 pop	 ecx
  0017e	5f		 pop	 edi
  0017f	5e		 pop	 esi
  00180	5b		 pop	 ebx
  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T168533[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN6@basic_fstr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T168533[ebp], -2 ; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 70	 add	 ecx, 112		; 00000070H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN6@basic_fstr:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$4:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 10	 add	 ecx, 16			; 00000010H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1:
  00027	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	83 c1 18	 add	 ecx, 24			; 00000018H
  0002d	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2:
  00032	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	83 c1 18	 add	 ecx, 24			; 00000018H
  00038	e9 00 00 00 00	 jmp	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z:
  0003d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00041	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00044	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00047	33 c8		 xor	 ecx, eax
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
  00053	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	SEGMENT
__unwindtable$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ$2
__ehfuncinfo$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
$T168811 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1302 : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00029	8b 41 90	 mov	 eax, DWORD PTR [ecx-112]
  0002c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002f	c7 44 0a 90 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-112], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@

; 1303 : 		}

  00037	8d 71 a8	 lea	 esi, DWORD PTR [ecx-88]
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	89 75 ec	 mov	 DWORD PTR $T168811[ebp], esi
  00044	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0004a	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  0004e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00052	74 1e		 je	 SHORT $LN15@basic_fstr@2
  00054	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00057	8d 56 48	 lea	 edx, DWORD PTR [esi+72]
  0005a	39 11		 cmp	 DWORD PTR [ecx], edx
  0005c	75 14		 jne	 SHORT $LN15@basic_fstr@2
  0005e	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  00061	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00064	89 11		 mov	 DWORD PTR [ecx], edx
  00066	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00069	89 01		 mov	 DWORD PTR [ecx], eax
  0006b	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0006e	2b c0		 sub	 eax, eax
  00070	89 02		 mov	 DWORD PTR [edx], eax
$LN15@basic_fstr@2:
  00072	80 7e 50 00	 cmp	 BYTE PTR [esi+80], 0
  00076	74 07		 je	 SHORT $LN5@basic_fstr@2
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN5@basic_fstr@2:
  0007f	8b ce		 mov	 ecx, esi
  00081	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00085	e8 00 00 00 00	 call	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
  0008a	8b 46 e8	 mov	 eax, DWORD PTR [esi-24]
  0008d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00090	c7 44 31 e8 00
	00 00 00	 mov	 DWORD PTR [ecx+esi-24], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  00098	8b 56 f8	 mov	 edx, DWORD PTR [esi-8]
  0009b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0009e	c7 44 30 f8 00
	00 00 00	 mov	 DWORD PTR [eax+esi-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  000a6	8b 4e e8	 mov	 ecx, DWORD PTR [esi-24]
  000a9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ac	c7 44 32 e8 00
	00 00 00	 mov	 DWORD PTR [edx+esi-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  000b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000be	59		 pop	 ecx
  000bf	5e		 pop	 esi
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 e9 58	 sub	 ecx, 88			; 00000058H
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__unwindfunclet$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ$2:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR $T168811[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
PUBLIC	??0?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Val2$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 0e		 mov	 DWORD PTR [esi], ecx
  00010	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00013	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0001a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00021	52		 push	 edx
  00022	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 228  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAK$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv797 = -12						; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	80 7b 2d 00	 cmp	 BYTE PTR [ebx+45], 0
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00013	74 0a		 je	 SHORT $LN40@erase@2

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN297@erase@2:
$LN40@erase@2:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1207 : 		++_Where;	// save successor iterator for return

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00022	89 5d f8	 mov	 DWORD PTR __Erasednode$[ebp], ebx
  00025	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  0002a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002c	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00030	74 05		 je	 SHORT $LN39@erase@2

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00032	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00035	eb 17		 jmp	 SHORT $LN291@erase@2
$LN39@erase@2:
  00037	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0003a	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0003e	74 04		 je	 SHORT $LN37@erase@2

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00040	8b f9		 mov	 edi, ecx

; 1218 : 		else

  00042	eb 0a		 jmp	 SHORT $LN291@erase@2
$LN37@erase@2:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00047	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  0004a	3b c3		 cmp	 eax, ebx
  0004c	75 72		 jne	 SHORT $LN35@erase@2
$LN291@erase@2:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004e	80 7f 2d 00	 cmp	 BYTE PTR [edi+45], 0
  00052	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00055	75 03		 jne	 SHORT $LN34@erase@2

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00057	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase@2:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00060	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00063	75 05		 jne	 SHORT $LN33@erase@2

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00065	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00068	eb 0b		 jmp	 SHORT $LN30@erase@2
$LN33@erase@2:
  0006a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0006c	75 04		 jne	 SHORT $LN31@erase@2

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006e	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  00070	eb 03		 jmp	 SHORT $LN30@erase@2
$LN31@erase@2:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  00072	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase@2:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	39 18		 cmp	 DWORD PTR [eax], ebx
  0007a	75 1b		 jne	 SHORT $LN29@erase@2

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007c	80 7f 2d 00	 cmp	 BYTE PTR [edi+45], 0
  00080	74 04		 je	 SHORT $LN43@erase@2
  00082	8b c6		 mov	 eax, esi
  00084	eb 0c		 jmp	 SHORT $LN44@erase@2
$LN43@erase@2:
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c4 04	 add	 esp, 4
$LN44@erase@2:
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	89 02		 mov	 DWORD PTR [edx], eax
$LN29@erase@2:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  00097	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009a	89 4d f4	 mov	 DWORD PTR tv797[ebp], ecx
  0009d	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000a0	75 78		 jne	 SHORT $LN165@erase@2

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000a2	80 7f 2d 00	 cmp	 BYTE PTR [edi+45], 0
  000a6	74 07		 je	 SHORT $LN45@erase@2
  000a8	8b c6		 mov	 eax, esi
  000aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000ad	eb 6b		 jmp	 SHORT $LN165@erase@2
$LN45@erase@2:

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR tv797[ebp]
  000b8	83 c4 04	 add	 esp, 4
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000be	eb 5a		 jmp	 SHORT $LN165@erase@2
$LN35@erase@2:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c0	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase@2

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f0		 mov	 esi, eax

; 1257 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase@2
$LN26@erase@2:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 2d 00	 cmp	 BYTE PTR [edi+45], 0
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	75 03		 jne	 SHORT $LN24@erase@2

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase@2:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e1	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000e4	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000e7	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN25@erase@2:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f0	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000f3	75 05		 jne	 SHORT $LN23@erase@2

; 1271 : 				_Root() = _Pnode;	// link down from root

  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f8	eb 0e		 jmp	 SHORT $LN20@erase@2
$LN23@erase@2:
  000fa	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000fd	39 19		 cmp	 DWORD PTR [ecx], ebx
  000ff	75 04		 jne	 SHORT $LN21@erase@2

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00101	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  00103	eb 03		 jmp	 SHORT $LN20@erase@2
$LN21@erase@2:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  00105	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase@2:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00108	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0010b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  0010e	8a 53 2c	 mov	 dl, BYTE PTR [ebx+44]
  00111	8a 48 2c	 mov	 cl, BYTE PTR [eax+44]
  00114	88 50 2c	 mov	 BYTE PTR [eax+44], dl
  00117	88 4b 2c	 mov	 BYTE PTR [ebx+44], cl
$LN165@erase@2:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	b3 01		 mov	 bl, 1
  00122	38 58 2c	 cmp	 BYTE PTR [eax+44], bl
  00125	0f 85 fa 00 00
	00		 jne	 $LN19@erase@2
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	3b 7a 04	 cmp	 edi, DWORD PTR [edx+4]
  00131	0f 84 eb 00 00
	00		 je	 $LN16@erase@2
$LL18@erase@2:
  00137	38 5f 2c	 cmp	 BYTE PTR [edi+44], bl
  0013a	0f 85 e2 00 00
	00		 jne	 $LN16@erase@2

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00140	8b 06		 mov	 eax, DWORD PTR [esi]
  00142	3b f8		 cmp	 edi, eax
  00144	75 65		 jne	 SHORT $LN15@erase@2

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  00146	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  00149	80 78 2c 00	 cmp	 BYTE PTR [eax+44], 0
  0014d	75 13		 jne	 SHORT $LN14@erase@2

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0014f	88 58 2c	 mov	 BYTE PTR [eax+44], bl

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  00152	56		 push	 esi
  00153	c6 46 2c 00	 mov	 BYTE PTR [esi+44], 0
  00157	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN14@erase@2:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00162	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00166	75 74		 jne	 SHORT $LN294@erase@2

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00168	8b 10		 mov	 edx, DWORD PTR [eax]
  0016a	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  0016d	75 08		 jne	 SHORT $LN11@erase@2
  0016f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00172	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  00175	74 61		 je	 SHORT $LN295@erase@2
$LN11@erase@2:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  00177	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017a	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  0017d	75 15		 jne	 SHORT $LN9@erase@2

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	88 5a 2c	 mov	 BYTE PTR [edx+44], bl

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  00184	50		 push	 eax
  00185	c6 40 2c 00	 mov	 BYTE PTR [eax+44], 0
  00189	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  0018e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN9@erase@2:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00194	8a 56 2c	 mov	 dl, BYTE PTR [esi+44]
  00197	88 50 2c	 mov	 BYTE PTR [eax+44], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0019a	88 5e 2c	 mov	 BYTE PTR [esi+44], bl

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0019d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1323 : 						_Lrotate(_Fixnodeparent);

  001a0	56		 push	 esi
  001a1	88 58 2c	 mov	 BYTE PTR [eax+44], bl
  001a4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001a9	eb 74		 jmp	 SHORT $LN296@erase@2
$LN15@erase@2:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001ab	80 78 2c 00	 cmp	 BYTE PTR [eax+44], 0
  001af	75 12		 jne	 SHORT $LN7@erase@2

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001b1	88 58 2c	 mov	 BYTE PTR [eax+44], bl

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001b4	56		 push	 esi
  001b5	c6 46 2c 00	 mov	 BYTE PTR [esi+44], 0
  001b9	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001be	8b 06		 mov	 eax, DWORD PTR [esi]
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN7@erase@2:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001c3	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001c7	75 13		 jne	 SHORT $LN294@erase@2

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001cc	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  001cf	75 1e		 jne	 SHORT $LN4@erase@2
  001d1	8b 10		 mov	 edx, DWORD PTR [eax]
  001d3	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  001d6	75 17		 jne	 SHORT $LN4@erase@2
$LN295@erase@2:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001d8	c6 40 2c 00	 mov	 BYTE PTR [eax+44], 0
$LN294@erase@2:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001dc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1344 : 						_Fixnode = _Fixnodeparent;

  001df	8b fe		 mov	 edi, esi
  001e1	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001e4	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001e7	0f 85 4a ff ff
	ff		 jne	 $LL18@erase@2

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001ed	eb 33		 jmp	 SHORT $LN16@erase@2
$LN4@erase@2:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001ef	8b 10		 mov	 edx, DWORD PTR [eax]
  001f1	38 5a 2c	 cmp	 BYTE PTR [edx+44], bl
  001f4	75 15		 jne	 SHORT $LN2@erase@2

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001f9	88 5a 2c	 mov	 BYTE PTR [edx+44], bl

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  001fc	50		 push	 eax
  001fd	c6 40 2c 00	 mov	 BYTE PTR [eax+44], 0
  00201	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00206	8b 06		 mov	 eax, DWORD PTR [esi]
  00208	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN2@erase@2:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0020b	8a 56 2c	 mov	 dl, BYTE PTR [esi+44]
  0020e	88 50 2c	 mov	 BYTE PTR [eax+44], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00211	88 5e 2c	 mov	 BYTE PTR [esi+44], bl

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00214	8b 00		 mov	 eax, DWORD PTR [eax]

; 1359 : 						_Rrotate(_Fixnodeparent);

  00216	56		 push	 esi
  00217	88 58 2c	 mov	 BYTE PTR [eax+44], bl
  0021a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate
$LN296@erase@2:
  0021f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN16@erase@2:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00222	88 5f 2c	 mov	 BYTE PTR [edi+44], bl
$LN19@erase@2:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00225	8b 55 f8	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00228	83 c2 0c	 add	 edx, 12			; 0000000cH
  0022b	52		 push	 edx
  0022c	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00235	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00241	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00244	83 c4 0c	 add	 esp, 12			; 0000000cH
  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
  00249	5b		 pop	 ebx
  0024a	85 c0		 test	 eax, eax
  0024c	74 04		 je	 SHORT $LN1@erase@2

; 1373 : 			--this->_Mysize;

  0024e	48		 dec	 eax
  0024f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase@2:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  00252	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00255	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00258	89 08		 mov	 DWORD PTR [eax], ecx

; 1376 : 		}

  0025a	8b e5		 mov	 esp, ebp
  0025c	5d		 pop	 ebp
  0025d	c2 08 00	 ret	 8
$LN293@erase@2:
?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase
; Function compile flags: /Ogtp
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 2d 00	 cmp	 BYTE PTR [edi+45], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 2b		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	50		 push	 eax
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  00020	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00023	51		 push	 ecx
  00024	8d 43 0d	 lea	 eax, DWORD PTR [ebx+13]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	80 7e 2d 00	 cmp	 BYTE PTR [esi+45], 0
  0003a	8b fe		 mov	 edi, esi
  0003c	74 d5		 je	 SHORT $LL3@Erase
$LN1@Erase:
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Linsert
; Function compile flags: /Ogtp
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
$T169448 = 16						; size = 4
$T169446 = 16						; size = 4
__Where$152031 = 16					; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx

; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00012	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00016	8b f1		 mov	 esi, ecx
  00018	b1 01		 mov	 cl, 1
  0001a	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 2d		 jne	 SHORT $LN11@Linsert
  0001f	8b 5a 0c	 mov	 ebx, DWORD PTR [edx+12]
$LL12@Linsert:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Leftish$[ebp], 0
  00026	8b f0		 mov	 esi, eax
  00028	74 08		 je	 SHORT $LN10@Linsert

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0002a	39 58 0c	 cmp	 DWORD PTR [eax+12], ebx
  0002d	0f 93 c1	 setae	 cl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00030	eb 06		 jmp	 SHORT $LN145@Linsert
$LN10@Linsert:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00032	3b 58 0c	 cmp	 ebx, DWORD PTR [eax+12]
  00035	0f 92 c1	 setb	 cl
$LN145@Linsert:
  00038	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0003b	84 c9		 test	 cl, cl
  0003d	74 04		 je	 SHORT $LN15@Linsert
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 03		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert:

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00046	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0004a	74 d6		 je	 SHORT $LL12@Linsert
$LN11@Linsert:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  0004c	8b de		 mov	 ebx, esi
  0004e	89 5d 10	 mov	 DWORD PTR __Where$152031[ebp], ebx

; 970  : 			if (!_Addleft)

  00051	84 c9		 test	 cl, cl
  00053	74 35		 je	 SHORT $LN99@Linsert

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00055	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00058	8d 4d 10	 lea	 ecx, DWORD PTR $T169446[ebp]
  0005b	3b 30		 cmp	 esi, DWORD PTR [eax]
  0005d	75 20		 jne	 SHORT $LN4@Linsert
  0005f	52		 push	 edx
  00060	56		 push	 esi
  00061	6a 01		 push	 1
  00063	51		 push	 ecx
  00064	8b cf		 mov	 ecx, edi
  00066	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  0006b	8b 10		 mov	 edx, DWORD PTR [eax]
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	89 10		 mov	 DWORD PTR [eax], edx
  00074	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  00078	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@Linsert:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  0007f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--
  00084	8b 5d 10	 mov	 ebx, DWORD PTR __Where$152031[ebp]
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  0008a	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0008d	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  00090	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00093	73 25		 jae	 SHORT $LN2@Linsert

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  00095	52		 push	 edx
  00096	8b 55 fc	 mov	 edx, DWORD PTR __Addleft$[ebp]
  00099	56		 push	 esi
  0009a	52		 push	 edx
  0009b	8d 45 10	 lea	 eax, DWORD PTR $T169448[ebp]
  0009e	50		 push	 eax
  0009f	8b cf		 mov	 ecx, edi
  000a1	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000b3	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Linsert:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  000ba	50		 push	 eax
  000bb	83 c7 0d	 add	 edi, 13			; 0000000dH
  000be	57		 push	 edi
  000bf	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000c4	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000cd	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	89 18		 mov	 DWORD PTR [eax], ebx
  000d7	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000db	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z
_TEXT	SEGMENT
$T169953 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR $T169953[ebp], eax
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c0		 test	 eax, eax
  00032	74 28		 je	 SHORT $LN7@Cons_val
  00034	8b 55 10	 mov	 edx, DWORD PTR __Src$[ebp]
  00037	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	6a ff		 push	 -1
  0003d	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00040	6a 00		 push	 0
  00042	83 c2 04	 add	 edx, 4
  00045	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0004c	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00053	52		 push	 edx
  00054	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00057	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN7@Cons_val:

; 281  : 	}

  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00066	59		 pop	 ecx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T169953[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
PUBLIC	??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 0e		 mov	 DWORD PTR [esi], ecx
  0000d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00010	83 c0 04	 add	 eax, 4
  00013	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0001a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00021	50		 push	 eax
  00022	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 256  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??$?0KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8d 71 70	 lea	 esi, DWORD PTR [ecx+112]
  00004	8b ce		 mov	 ecx, esi
  00006	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  0000b	56		 push	 esi
  0000c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00012	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00017	83 c4 04	 add	 esp, 4
  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8d 79 90	 lea	 edi, DWORD PTR [ecx-112]
  00008	8d 77 70	 lea	 esi, DWORD PTR [edi+112]
  0000b	8b ce		 mov	 ecx, esi
  0000d	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  00012	56		 push	 esi
  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00019	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0001e	83 c4 04	 add	 esp, 4
  00021	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00025	74 09		 je	 SHORT $LN11@scalar@19
  00027	57		 push	 edi
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	83 c4 04	 add	 esp, 4
$LN11@scalar@19:
  00030	8b c7		 mov	 eax, edi
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	51		 push	 ecx
  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001a	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1419 : 		this->_Mysize = 0;

  00022	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00029	5e		 pop	 esi

; 1420 : 		}

  0002a	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
_TEXT	ENDS
PUBLIC	??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0
__unwindtable$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$2
__ehfuncinfo$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
$T170293 = -32						; size = 12
__Ptr$170297 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T170246 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002d	6a 30		 push	 48			; 00000030H
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	8b f0		 mov	 esi, eax
  00036	33 c0		 xor	 eax, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	89 75 ec	 mov	 DWORD PTR __Ptr$170297[ebp], esi
  0003e	3b f0		 cmp	 esi, eax
  00040	74 57		 je	 SHORT $LN12@Buynode@4
  00042	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00045	89 0e		 mov	 DWORD PTR [esi], ecx
  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0004d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00050	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	66 89 46 2c	 mov	 WORD PTR [esi+44], ax
  00057	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  0005a	52		 push	 edx
  0005b	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005e	50		 push	 eax
  0005f	83 c7 0d	 add	 edi, 13			; 0000000dH
  00062	57		 push	 edi
  00063	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00066	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  0006e	8b c6		 mov	 eax, esi

; 599  : 		}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
__catch$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$170297[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4

; 595  : 		_RERAISE;

  00090	33 c0		 xor	 eax, eax
  00092	50		 push	 eax
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Buynode@4:

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@4:
  00099	8d 55 08	 lea	 edx, DWORD PTR $T170246[ebp]
  0009c	52		 push	 edx
  0009d	8d 4d e0	 lea	 ecx, DWORD PTR $T170293[ebp]
  000a0	89 45 08	 mov	 DWORD PTR $T170246[ebp], eax
  000a3	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ad	8d 45 e0	 lea	 eax, DWORD PTR $T170293[ebp]
  000b0	50		 push	 eax
  000b1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T170293[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Buynode@4:
$LN44@Buynode@4:
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
; Function compile flags: /Ogtp
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
$T170347 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Node$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1089 : 		{	// try to insert node at _Node using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1090 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1091 : 		if (_Where._Getcont() != this)
; 1092 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1093 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1094 : 
; 1095 : 		const value_type& _Val = this->_Myval(_Node);
; 1096 : 
; 1097 : 		const_iterator _Next;
; 1098 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1099 : 
; 1100 : 		if (size() == 0)

  00009	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0

; 1101 : 			return (_Insert(true, this->_Myhead, _Node));	// empty tree

  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	57		 push	 edi
  00011	8b 7d 10	 mov	 edi, DWORD PTR __Node$[ebp]
  00014	75 17		 jne	 SHORT $LN33@Insert@2
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	50		 push	 eax
  0001b	6a 01		 push	 1
  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  00023	8b c7		 mov	 eax, edi
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 1181 : 		}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
$LN33@Insert@2:
  0002d	53		 push	 ebx

; 1102 : 		else if (this->_Multi)
; 1103 : 			{	// insert even if duplicate
; 1104 : 			if (_Where == begin())
; 1105 : 				{	// insert at beginning if before first element
; 1106 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1107 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1108 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1109 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1110 : 				}
; 1111 : 			else if (_Where == end())
; 1112 : 				{	// insert at end if after last element
; 1113 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1114 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1115 : 					return (_Insert(false, _Rmost(), _Node));
; 1116 : 				}
; 1117 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1118 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1119 : 				&& !_DEBUG_LT_PRED(this->comp,
; 1120 : 					this->_Kfn(_Val),
; 1121 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1122 : 				{	// insert before _Where
; 1123 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1124 : 					return (_Insert(false, _Next._Mynode(), _Node));
; 1125 : 				else
; 1126 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1127 : 				}
; 1128 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1129 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1130 : 				&& (++(_Next = _Where) == end()
; 1131 : 					|| !_DEBUG_LT_PRED(this->comp,
; 1132 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1133 : 				{	// insert after _Where
; 1134 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1135 : 					return (_Insert(false, _Where._Mynode(), _Node));
; 1136 : 				else
; 1137 : 					return (_Insert(true, _Next._Mynode(), _Node));
; 1138 : 				}
; 1139 : 			else
; 1140 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1141 : 			}
; 1142 : 		else
; 1143 : 			{	// insert only if unique
; 1144 : 			if (_Where == begin())

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  00031	3b 18		 cmp	 ebx, DWORD PTR [eax]
  00033	75 26		 jne	 SHORT $LN14@Insert@2

; 1145 : 				{	// insert at beginning if before first element
; 1146 : 				if (_DEBUG_LT_PRED(this->comp,

  00035	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00038	3b 4b 0c	 cmp	 ecx, DWORD PTR [ebx+12]
  0003b	0f 83 f4 00 00
	00		 jae	 $LN333@Insert@2

; 1147 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1148 : 					return (_Insert(true, _Where._Mynode(), _Node));

  00041	57		 push	 edi
  00042	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00045	53		 push	 ebx
  00046	6a 01		 push	 1
  00048	57		 push	 edi
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  00050	5b		 pop	 ebx
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 1181 : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
$LN14@Insert@2:

; 1149 : 				}
; 1150 : 			else if (_Where == end())

  0005b	3b d8		 cmp	 ebx, eax
  0005d	75 27		 jne	 SHORT $LN11@Insert@2

; 1151 : 				{	// insert at end if after last element
; 1152 : 				if (_DEBUG_LT_PRED(this->comp,

  0005f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00062	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00065	3b 57 0c	 cmp	 edx, DWORD PTR [edi+12]
  00068	0f 83 c7 00 00
	00		 jae	 $LN333@Insert@2

; 1153 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1154 : 					return (_Insert(false, _Rmost(), _Node));

  0006e	57		 push	 edi
  0006f	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00072	50		 push	 eax
  00073	6a 00		 push	 0
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  0007b	5b		 pop	 ebx
  0007c	8b c7		 mov	 eax, edi
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 1181 : 		}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 0c 00	 ret	 12			; 0000000cH
$LN11@Insert@2:

; 1155 : 				}
; 1156 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1157 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1158 : 				&& _DEBUG_LT_PRED(this->comp,

  00086	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00089	3b 43 0c	 cmp	 eax, DWORD PTR [ebx+12]
  0008c	73 4d		 jae	 SHORT $LN332@Insert@2
  0008e	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  00091	89 5d 10	 mov	 DWORD PTR __Next$[ebp], ebx
  00094	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator--
  00099	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  0009c	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0009f	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  000a2	73 37		 jae	 SHORT $LN332@Insert@2

; 1159 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1160 : 					this->_Kfn(_Val)))
; 1161 : 				{	// insert before _Where
; 1162 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  000a4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a7	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0

; 1163 : 					return (_Insert(false, _Next._Mynode(), _Node));

  000ab	57		 push	 edi
  000ac	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  000af	8b ce		 mov	 ecx, esi
  000b1	74 14		 je	 SHORT $LN7@Insert@2
  000b3	50		 push	 eax
  000b4	6a 00		 push	 0
  000b6	57		 push	 edi
  000b7	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  000bc	5b		 pop	 ebx
  000bd	8b c7		 mov	 eax, edi
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi

; 1181 : 		}

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH
$LN7@Insert@2:

; 1164 : 				else
; 1165 : 					return (_Insert(true, _Where._Mynode(), _Node));

  000c7	53		 push	 ebx
  000c8	6a 01		 push	 1
  000ca	57		 push	 edi
  000cb	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  000d0	5b		 pop	 ebx
  000d1	8b c7		 mov	 eax, edi
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi

; 1181 : 		}

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 0c 00	 ret	 12			; 0000000cH
$LN332@Insert@2:

; 1166 : 				}
; 1167 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1168 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1169 : 				&& (++(_Next = _Where) == end()
; 1170 : 					|| _DEBUG_LT_PRED(this->comp,

  000db	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000de	39 43 0c	 cmp	 DWORD PTR [ebx+12], eax
  000e1	73 52		 jae	 SHORT $LN333@Insert@2
  000e3	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  000e6	89 5d 10	 mov	 DWORD PTR __Next$[ebp], ebx
  000e9	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >,std::_Iterator_base0>::operator++
  000ee	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  000f1	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000f4	74 08		 je	 SHORT $LN3@Insert@2
  000f6	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000f9	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000fc	73 37		 jae	 SHORT $LN333@Insert@2
$LN3@Insert@2:

; 1171 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1172 : 				{	// insert after _Where
; 1173 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  000fe	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00101	80 7a 2d 00	 cmp	 BYTE PTR [edx+45], 0

; 1174 : 					return (_Insert(false, _Where._Mynode(), _Node));

  00105	57		 push	 edi
  00106	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00109	8b ce		 mov	 ecx, esi
  0010b	74 14		 je	 SHORT $LN2@Insert@2
  0010d	53		 push	 ebx
  0010e	6a 00		 push	 0
  00110	57		 push	 edi
  00111	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  00116	5b		 pop	 ebx
  00117	8b c7		 mov	 eax, edi
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi

; 1181 : 		}

  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Insert@2:

; 1175 : 				else
; 1176 : 					return (_Insert(true, _Next._Mynode(), _Node));

  00121	50		 push	 eax
  00122	6a 01		 push	 1
  00124	57		 push	 edi
  00125	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  0012a	5b		 pop	 ebx
  0012b	8b c7		 mov	 eax, edi
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi

; 1181 : 		}

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c2 0c 00	 ret	 12			; 0000000cH
$LN333@Insert@2:

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00135	6a 00		 push	 0
  00137	57		 push	 edi
  00138	8d 45 f8	 lea	 eax, DWORD PTR $T170347[ebp]
  0013b	50		 push	 eax
  0013c	8b ce		 mov	 ecx, esi
  0013e	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Linsert
  00143	8b 08		 mov	 ecx, DWORD PTR [eax]
  00145	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00148	5b		 pop	 ebx
  00149	5f		 pop	 edi
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
  0014c	5e		 pop	 esi

; 1181 : 		}

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0
__ehfuncinfo$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
$T170997 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR $T170997[ebp], eax
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c0		 test	 eax, eax
  00032	74 24		 je	 SHORT $LN3@construct@2
  00034	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00037	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0003e	83 c2 04	 add	 edx, 4
  00041	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00048	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0004f	52		 push	 edx
  00050	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00053	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@construct@2:

; 209  : 		}

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T170997[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T171222 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00012	75 38		 jne	 SHORT $LN115@erase@3
  00014	3b d0		 cmp	 edx, eax
  00016	75 34		 jne	 SHORT $LN115@erase@3

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	50		 push	 eax
  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 00		 mov	 DWORD PTR [eax], eax
  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1383 : 			return (begin());

  00034	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00037	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	89 10		 mov	 DWORD PTR [eax], edx
  00045	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 0c 00	 ret	 12			; 0000000cH
$LN115@erase@3:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0004c	3b ca		 cmp	 ecx, edx
  0004e	74 62		 je	 SHORT $LN1@erase@3
$LL2@erase@3:

; 1388 : 				erase(_First++);

  00050	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00054	8b d1		 mov	 edx, ecx
  00056	75 46		 jne	 SHORT $LN77@erase@3
  00058	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0005b	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0005f	75 1e		 jne	 SHORT $LN117@erase@3
  00061	8b c8		 mov	 ecx, eax
  00063	8b 01		 mov	 eax, DWORD PTR [ecx]
  00065	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00069	75 0f		 jne	 SHORT $LN91@erase@3
  0006b	eb 03 8d 49 00	 npad	 5
$LL92@erase@3:
  00070	8b c8		 mov	 ecx, eax
  00072	8b 01		 mov	 eax, DWORD PTR [ecx]
  00074	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00078	74 f6		 je	 SHORT $LL92@erase@3
$LN91@erase@3:
  0007a	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  0007d	eb 1f		 jmp	 SHORT $LN77@erase@3
$LN117@erase@3:
  0007f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00082	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00086	75 13		 jne	 SHORT $LN75@erase@3
$LL76@erase@3:
  00088	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0008b	75 0e		 jne	 SHORT $LN75@erase@3
  0008d	8b c8		 mov	 ecx, eax
  0008f	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  00092	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00095	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00099	74 ed		 je	 SHORT $LL76@erase@3
$LN75@erase@3:
  0009b	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
$LN77@erase@3:
  0009e	52		 push	 edx
  0009f	8d 45 fc	 lea	 eax, DWORD PTR $T171222[ebp]
  000a2	50		 push	 eax
  000a3	8b ce		 mov	 ecx, esi
  000a5	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  000ad	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  000b0	75 9e		 jne	 SHORT $LL2@erase@3
$LN1@erase@3:

; 1389 : 			return (iterator(_First._Ptr, this));

  000b2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b5	89 08		 mov	 DWORD PTR [eax], ecx
  000b7	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1516 : 		{	// copy entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d e8	 mov	 DWORD PTR _this$[ebp], ebx

; 1517 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1518 : 
; 1519 : 		if (!this->_Isnil(_Rootnode))

  00030	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00033	80 7f 2d 00	 cmp	 BYTE PTR [edi+45], 0
  00037	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0003a	89 45 ec	 mov	 DWORD PTR __Newroot$[ebp], eax
  0003d	75 48		 jne	 SHORT $LN8@Copy@2

; 1520 : 			{	// copy a node, then any subtrees
; 1521 : 			_Nodeptr _Pnode = this->_Buynode(this->_Myval(_Rootnode));

  0003f	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00042	51		 push	 ecx
  00043	8b cb		 mov	 ecx, ebx
  00045	e8 00 00 00 00	 call	 ??$_Buynode@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>

; 1522 : 			_Pnode->_Parent = _Wherenode;

  0004a	8b 55 0c	 mov	 edx, DWORD PTR __Wherenode$[ebp]

; 1523 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1524 : 			if (this->_Isnil(_Newroot))

  0004d	8b 4d ec	 mov	 ecx, DWORD PTR __Newroot$[ebp]
  00050	8b f0		 mov	 esi, eax
  00052	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00055	8a 47 2c	 mov	 al, BYTE PTR [edi+44]
  00058	88 46 2c	 mov	 BYTE PTR [esi+44], al
  0005b	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  0005f	74 03		 je	 SHORT $LN2@Copy@2

; 1525 : 				_Newroot = _Pnode;	// memorize new root

  00061	89 75 ec	 mov	 DWORD PTR __Newroot$[ebp], esi
$LN2@Copy@2:

; 1526 : 
; 1527 : 			_TRY_BEGIN
; 1528 : 			this->_Left(_Pnode) = _Copy(this->_Left(_Rootnode), _Pnode);

  00064	8b 17		 mov	 edx, DWORD PTR [edi]
  00066	56		 push	 esi
  00067	52		 push	 edx
  00068	8b cb		 mov	 ecx, ebx
  0006a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00071	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
  00076	89 06		 mov	 DWORD PTR [esi], eax

; 1529 : 			this->_Right(_Pnode) = _Copy(this->_Right(_Rootnode), _Pnode);

  00078	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0007b	56		 push	 esi
  0007c	50		 push	 eax
  0007d	8b cb		 mov	 ecx, ebx
  0007f	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
  00084	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN8@Copy@2:

; 1533 : 			_CATCH_END
; 1534 : 			}
; 1535 : 
; 1536 : 		return (_Newroot);	// return newly constructed tree

  00087	8b 45 ec	 mov	 eax, DWORD PTR __Newroot$[ebp]

; 1537 : 		}

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00094	59		 pop	 ecx
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$0:

; 1530 : 			_CATCH_ALL
; 1531 : 			_Erase(_Newroot);	// subtree copy failed, bail out

  0009e	8b 4d ec	 mov	 ecx, DWORD PTR __Newroot$[ebp]
  000a1	51		 push	 ecx
  000a2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase

; 1532 : 			_RERAISE;

  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@Copy@2:
$LN28@Copy@2:
  000b3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
$T171870 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR $T171870[ebp], eax
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c0		 test	 eax, eax
  00032	74 24		 je	 SHORT $LN7@Cons_val@2
  00034	8b 55 10	 mov	 edx, DWORD PTR __Src$[ebp]
  00037	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0003e	83 c2 04	 add	 edx, 4
  00041	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00048	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0004f	52		 push	 edx
  00050	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00053	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN7@Cons_val@2:

; 281  : 	}

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T171870[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T171934 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T171934[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase

; 1867 : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
; Function compile flags: /Ogtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1500 : 		{	// copy entire tree from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1501 : 		_Root() = _Copy(_Right._Root(), this->_Myhead);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b f1		 mov	 esi, ecx
  00011	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
  0001b	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1502 : 		this->_Mysize = _Right.size();

  0001e	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 1503 : 		if (!this->_Isnil(_Root()))

  00021	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00024	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00027	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002a	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0002e	75 38		 jne	 SHORT $LN2@Copy@3

; 1504 : 			{	// nonempty tree, look for new smallest and largest
; 1505 : 			_Lmost() = this->_Min(_Root());

  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00036	75 0a		 jne	 SHORT $LN25@Copy@3
$LL26@Copy@3:
  00038	8b c1		 mov	 eax, ecx
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00040	74 f6		 je	 SHORT $LL26@Copy@3
$LN25@Copy@3:
  00042	89 02		 mov	 DWORD PTR [edx], eax

; 1506 : 			_Rmost() = this->_Max(_Root());

  00044	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00047	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0004d	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  00051	75 0b		 jne	 SHORT $LN43@Copy@3
$LL44@Copy@3:
  00053	8b c8		 mov	 ecx, eax
  00055	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00058	80 78 2d 00	 cmp	 BYTE PTR [eax+45], 0
  0005c	74 f5		 je	 SHORT $LL44@Copy@3
$LN43@Copy@3:
  0005e	5f		 pop	 edi
  0005f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx

; 1512 : 			}
; 1513 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN2@Copy@3:

; 1507 : 			}
; 1508 : 		else
; 1509 : 			{	// empty tree, just tidy head pointers
; 1510 : 			_Lmost() = this->_Myhead;

  00068	89 12		 mov	 DWORD PTR [edx], edx

; 1511 : 			_Rmost() = this->_Myhead;

  0006a	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0006d	5f		 pop	 edi
  0006e	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx

; 1512 : 			}
; 1513 : 		}

  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T172256 = -36						; size = 12
$T172198 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T172376 = 8						; size = 4
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 715  : 		{	// construct tree by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00030	33 ff		 xor	 edi, edi
  00032	6a 30		 push	 48			; 00000030H
  00034	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00037	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b c7		 cmp	 eax, edi
  00041	74 62		 je	 SHORT $LN27@Tree@4
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00046	89 00		 mov	 DWORD PTR [eax], eax
  00048	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004b	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0004e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00051	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00054	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00057	b0 01		 mov	 al, 1
  00059	88 41 2c	 mov	 BYTE PTR [ecx+44], al
  0005c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0005f	88 42 2d	 mov	 BYTE PTR [edx+45], al
  00062	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi

; 716  : 		_TRY_BEGIN

  00065	88 45 fc	 mov	 BYTE PTR __$EHRec$[ebp+12], al

; 717  : 		_Copy(_Right);

  00068	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0006b	50		 push	 eax
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy

; 721  : 		_CATCH_END
; 722  : 		}

  00073	8b c6		 mov	 eax, esi
  00075	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00078	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007f	59		 pop	 ecx
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
__catch$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 718  : 		_CATCH_ALL
; 719  : 		_Tidy();

  00089	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0008f	8b 10		 mov	 edx, DWORD PTR [eax]
  00091	50		 push	 eax
  00092	52		 push	 edx
  00093	8d 55 08	 lea	 edx, DWORD PTR $T172376[ebp]
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase

; 720  : 		_RERAISE;

  0009c	33 ff		 xor	 edi, edi
  0009e	57		 push	 edi
  0009f	57		 push	 edi
  000a0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN78@Tree@4:

; 715  : 		{	// construct tree by copying _Right

$LN27@Tree@4:
  000a5	8d 45 e8	 lea	 eax, DWORD PTR $T172198[ebp]
  000a8	50		 push	 eax
  000a9	8d 4d dc	 lea	 ecx, DWORD PTR $T172256[ebp]
  000ac	89 7d e8	 mov	 DWORD PTR $T172198[ebp], edi
  000af	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000b4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000b9	8d 4d dc	 lea	 ecx, DWORD PTR $T172256[ebp]
  000bc	51		 push	 ecx
  000bd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T172256[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000c4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN79@Tree@4:
$LN77@Tree@4:
  000c9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
$T172474 = -32						; size = 12
__Ptr$172478 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T172427 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002d	6a 30		 push	 48			; 00000030H
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	8b f0		 mov	 esi, eax
  00036	33 c0		 xor	 eax, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	89 75 ec	 mov	 DWORD PTR __Ptr$172478[ebp], esi
  0003e	3b f0		 cmp	 esi, eax
  00040	74 57		 je	 SHORT $LN12@Buynode@5
  00042	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00045	89 0e		 mov	 DWORD PTR [esi], ecx
  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0004d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00050	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	66 89 46 2c	 mov	 WORD PTR [esi+44], ax
  00057	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  0005a	52		 push	 edx
  0005b	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005e	50		 push	 eax
  0005f	83 c7 0d	 add	 edi, 13			; 0000000dH
  00062	57		 push	 edi
  00063	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00066	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@PAU?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  0006e	8b c6		 mov	 eax, esi

; 599  : 		}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
__catch$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$172478[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4

; 595  : 		_RERAISE;

  00090	33 c0		 xor	 eax, eax
  00092	50		 push	 eax
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Buynode@5:

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@5:
  00099	8d 55 08	 lea	 edx, DWORD PTR $T172427[ebp]
  0009c	52		 push	 edx
  0009d	8d 4d e0	 lea	 ecx, DWORD PTR $T172474[ebp]
  000a0	89 45 08	 mov	 DWORD PTR $T172427[ebp], eax
  000a3	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ad	8d 45 e0	 lea	 eax, DWORD PTR $T172474[ebp]
  000b0	50		 push	 eax
  000b1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T172474[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Buynode@5:
$LN44@Buynode@5:
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T172620 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 791  : 		_Tidy();

  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T172620[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase

; 792  : 		}

  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	??4?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T172666 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::operator=, COMDAT
; _this$ = ecx

; 795  : 		{	// replace contents from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 796  : 		if (this != &_Right)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 1a		 je	 SHORT $LN28@operator@11

; 797  : 			{	// worth doing
; 798  : 			erase(begin(), end());

  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 45 08	 lea	 eax, DWORD PTR $T172666[ebp]
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase

; 799  : 			this->comp = _Right.comp;
; 800  : 			_Copy(_Right);

  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
$LN28@operator@11:

; 801  : 			}
; 802  : 		return (*this);

  00028	5f		 pop	 edi
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi

; 803  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??4?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::operator=
_TEXT	ENDS
PUBLIC	??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@ABV01@@Z ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 111  : 		{	// construct map by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >

; 112  : 		}

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
??$insert@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 760  : 		typename _STD tr1::enable_if<!_STD tr1::is_same<const_iterator,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 761  : 			typename _STD tr1::remove_reference<_Valty>::type>::value,
; 762  : 				iterator>::type
; 763  : 		insert(const_iterator _Where,
; 764  : 			_Valty&& _Val)
; 765  : 		{	// try to insert node with value _Val using _Where as a hint
; 766  : 		return (_Insert(_Where,
; 767  : 			this->_Buynode(_STD forward<_Valty>(_Val))));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00016	50		 push	 eax
  00017	51		 push	 ecx
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  00020	8b c7		 mov	 eax, edi
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 768  : 		}

  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??$insert@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T172905 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T172905[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T173102 = -16						; size = 12
$T172986 = -4						; size = 4
??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 30		 push	 48			; 00000030H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN25@map
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 2c	 mov	 BYTE PTR [ecx+44], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 2d	 mov	 BYTE PTR [edx+45], al

; 107  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0

; 106  : 		{	// construct empty map from defaults

$LN25@map:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T172986[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T173102[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T172986[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T173102[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T173102[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@map:
$LN48@map:
  0006c	cc		 int	 3
??0?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??4?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T173211 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator=, COMDAT
; _this$ = ecx

; 148  : 		{	// assign by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 149  : 		_Mybase::operator=(_Right);

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 1a		 je	 SHORT $LN30@operator@12
  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 45 08	 lea	 eax, DWORD PTR $T173211[ebp]
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
$LN30@operator@12:

; 150  : 		return (*this);

  00028	5f		 pop	 edi
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi

; 151  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??4?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator=
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z$1
__ehfuncinfo$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	ENDS
;	COMDAT ??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z
_TEXT	SEGMENT
$T173243 = -80						; size = 4
$T147850 = -76						; size = 28
$T147996 = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Keyval$ = 8						; size = 4
??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z PROC ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[], COMDAT
; _this$ = ecx

; 165  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0002e	8b f1		 mov	 esi, ecx

; 166  : 		iterator _Where = this->lower_bound(_Keyval);

  00030	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00033	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00036	33 db		 xor	 ebx, ebx
  00038	8b f9		 mov	 edi, ecx
  0003a	38 58 2d	 cmp	 BYTE PTR [eax+45], bl
  0003d	75 15		 jne	 SHORT $LN11@operator@13
  0003f	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LL12@operator@13:
  00041	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00044	73 05		 jae	 SHORT $LN10@operator@13
  00046	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00049	eb 04		 jmp	 SHORT $LN9@operator@13
$LN10@operator@13:
  0004b	8b f8		 mov	 edi, eax
  0004d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@operator@13:
  0004f	38 58 2d	 cmp	 BYTE PTR [eax+45], bl
  00052	74 ed		 je	 SHORT $LL12@operator@13
$LN11@operator@13:

; 167  : 		if (_Where == this->end()
; 168  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00054	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00057	74 0b		 je	 SHORT $LN1@operator@13
  00059	8b 02		 mov	 eax, DWORD PTR [edx]
  0005b	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  0005e	0f 83 83 00 00
	00		 jae	 $LN195@operator@13
$LN1@operator@13:

; 169  : 			_Where = this->insert(_Where,
; 170  : 				_STD pair<key_type, mapped_type>(
; 171  : 					_STD move(_Keyval),
; 172  : 					mapped_type()));

  00064	8b 02		 mov	 eax, DWORD PTR [edx]
  00066	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0006b	89 4d c8	 mov	 DWORD PTR $T147850[ebp+20], ecx
  0006e	89 5d c4	 mov	 DWORD PTR $T147850[ebp+16], ebx
  00071	88 5d b4	 mov	 BYTE PTR $T147850[ebp], bl
  00074	89 4d e8	 mov	 DWORD PTR $T147996[ebp+24], ecx
  00077	8d 4d b4	 lea	 ecx, DWORD PTR $T147850[ebp]
  0007a	51		 push	 ecx
  0007b	8d 4d d4	 lea	 ecx, DWORD PTR $T147996[ebp+4]
  0007e	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00081	89 45 d0	 mov	 DWORD PTR $T147996[ebp], eax
  00084	89 5d e4	 mov	 DWORD PTR $T147996[ebp+20], ebx
  00087	88 5d d4	 mov	 BYTE PTR $T147996[ebp+4], bl
  0008a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0008f	8d 55 d0	 lea	 edx, DWORD PTR $T147996[ebp]
  00092	52		 push	 edx
  00093	8b ce		 mov	 ecx, esi
  00095	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00099	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0009e	50		 push	 eax
  0009f	57		 push	 edi
  000a0	8d 45 b0	 lea	 eax, DWORD PTR $T173243[ebp]
  000a3	50		 push	 eax
  000a4	8b ce		 mov	 ecx, esi
  000a6	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
  000ab	8b 75 b0	 mov	 esi, DWORD PTR $T173243[ebp]
  000ae	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  000b3	39 7d e8	 cmp	 DWORD PTR $T147996[ebp+24], edi
  000b6	72 0c		 jb	 SHORT $LN153@operator@13
  000b8	8b 4d d4	 mov	 ecx, DWORD PTR $T147996[ebp+4]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c1	83 c4 04	 add	 esp, 4
$LN153@operator@13:
  000c4	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T147996[ebp+24], 15 ; 0000000fH
  000cb	89 5d e4	 mov	 DWORD PTR $T147996[ebp+20], ebx
  000ce	88 5d d4	 mov	 BYTE PTR $T147996[ebp+4], bl
  000d1	39 7d c8	 cmp	 DWORD PTR $T147850[ebp+20], edi
  000d4	72 0c		 jb	 SHORT $LN194@operator@13
  000d6	8b 55 b4	 mov	 edx, DWORD PTR $T147850[ebp]
  000d9	52		 push	 edx
  000da	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000df	83 c4 04	 add	 esp, 4
$LN194@operator@13:

; 173  : 		return ((*_Where).second);

  000e2	8d 46 10	 lea	 eax, DWORD PTR [esi+16]

; 169  : 			_Where = this->insert(_Where,
; 170  : 				_STD pair<key_type, mapped_type>(
; 171  : 					_STD move(_Keyval),
; 172  : 					mapped_type()));

  000e5	eb 03		 jmp	 SHORT $LN175@operator@13
$LN195@operator@13:

; 173  : 		return ((*_Where).second);

  000e7	8d 47 10	 lea	 eax, DWORD PTR [edi+16]

; 169  : 			_Where = this->insert(_Where,
; 170  : 				_STD pair<key_type, mapped_type>(
; 171  : 					_STD move(_Keyval),
; 172  : 					mapped_type()));

$LN175@operator@13:

; 174  : 		}

  000ea	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ed	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f4	59		 pop	 ecx
  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fb	33 cd		 xor	 ecx, ebp
  000fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z$0:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR $T147850[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z$1:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR $T147996[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$pair@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
__ehhandler$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z ENDP ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
PUBLIC	??0TokenizerRow@@QAE@ABV0@@Z			; TokenizerRow::TokenizerRow
; Function compile flags: /Ogtp
;	COMDAT ??0TokenizerRow@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0TokenizerRow@@QAE@ABV0@@Z PROC			; TokenizerRow::TokenizerRow, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  00010	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00013	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00016	5f		 pop	 edi
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??0TokenizerRow@@QAE@ABV0@@Z ENDP			; TokenizerRow::TokenizerRow
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	_pRow$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z ; Tokenizer::ParseLine
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z$1
__ehfuncinfo$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\tokenizer.h
xdata$x	ENDS
;	COMDAT ?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z
_TEXT	SEGMENT
_pRow$GSCopy$ = -60					; size = 4
$T173984 = -56						; size = 4
$T173983 = -56						; size = 4
_dump$ = -52						; size = 4
_clearingspace$ = -46					; size = 1
_openstring$ = -45					; size = 1
_data$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_line$ = 8						; size = 28
_pRow$ = 36						; size = 4
?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z PROC ; Tokenizer::ParseLine, COMDAT
; _this$ = ecx

; 101  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 45 24	 mov	 eax, DWORD PTR _pRow$[ebp]

; 169  : 
; 170  : 		return true;

  0002e	89 45 c4	 mov	 DWORD PTR _pRow$GSCopy$[ebp], eax
  00031	33 db		 xor	 ebx, ebx
  00033	53		 push	 ebx
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00039	8d 4d d4	 lea	 ecx, DWORD PTR _data$[ebp]
  0003c	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0003f	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _data$[ebp+20], 15 ; 0000000fH
  00046	89 5d e4	 mov	 DWORD PTR _data$[ebp+16], ebx
  00049	88 5d d4	 mov	 BYTE PTR _data$[ebp], bl
  0004c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00051	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00056	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0005a	39 55 1c	 cmp	 DWORD PTR _line$[ebp+20], edx
  0005d	72 08		 jb	 SHORT $LN55@ParseLine

; 102  : 
; 103  : 		std::string data = "";
; 104  : 
; 105  : 		char* dump = (char*)line.c_str();

  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00062	89 4d cc	 mov	 DWORD PTR _dump$[ebp], ecx
  00065	eb 06		 jmp	 SHORT $LN56@ParseLine
$LN55@ParseLine:
  00067	8d 45 08	 lea	 eax, DWORD PTR _line$[ebp]
  0006a	89 45 cc	 mov	 DWORD PTR _dump$[ebp], eax
$LN56@ParseLine:

; 106  : 		
; 107  : 		bool openstring = false;
; 108  : 		bool clearingspace = true;
; 109  : 		
; 110  : 		int column = 0;

  0006d	33 f6		 xor	 esi, esi

; 111  : 
; 112  : 		for(unsigned int i = 0; i < line.length(); i++)

  0006f	33 ff		 xor	 edi, edi
  00071	88 5d d3	 mov	 BYTE PTR _openstring$[ebp], bl
  00074	c6 45 d2 01	 mov	 BYTE PTR _clearingspace$[ebp], 1
  00078	39 5d 18	 cmp	 DWORD PTR _line$[ebp+16], ebx
  0007b	0f 86 e8 00 00
	00		 jbe	 $LN14@ParseLine
$LL16@ParseLine:

; 113  : 		{
; 114  : 
; 115  : 			if(clearingspace)
; 116  : 			{
; 117  : 				if(dump[i] == ' ' || dump[i] == '\t')

  00081	8b 4d cc	 mov	 ecx, DWORD PTR _dump$[ebp]
  00084	38 5d d2	 cmp	 BYTE PTR _clearingspace$[ebp], bl
  00087	74 16		 je	 SHORT $LN13@ParseLine
  00089	8a 04 0f	 mov	 al, BYTE PTR [edi+ecx]
  0008c	3c 20		 cmp	 al, 32			; 00000020H
  0008e	0f 84 c6 00 00
	00		 je	 $LN15@ParseLine
  00094	3c 09		 cmp	 al, 9
  00096	0f 84 be 00 00
	00		 je	 $LN15@ParseLine

; 118  : 				{
; 119  : 					continue;
; 120  : 				}
; 121  : 				clearingspace = false;

  0009c	88 5d d2	 mov	 BYTE PTR _clearingspace$[ebp], bl
$LN13@ParseLine:

; 122  : 			}
; 123  : 
; 124  : 			if(openstring)
; 125  : 			{
; 126  : 				if(dump[i] == '"')

  0009f	8a 04 0f	 mov	 al, BYTE PTR [edi+ecx]
  000a2	38 5d d3	 cmp	 BYTE PTR _openstring$[ebp], bl
  000a5	74 0c		 je	 SHORT $LN10@ParseLine
  000a7	3c 22		 cmp	 al, 34			; 00000022H
  000a9	75 4c		 jne	 SHORT $LN9@ParseLine

; 127  : 				{
; 128  : 					openstring = false;

  000ab	88 5d d3	 mov	 BYTE PTR _openstring$[ebp], bl

; 129  : 					continue;

  000ae	e9 a7 00 00 00	 jmp	 $LN15@ParseLine
$LN10@ParseLine:

; 130  : 				}
; 131  : 				data += dump[i];
; 132  : 			}
; 133  : 			else
; 134  : 			{
; 135  : 				if(dump[i] == '"')

  000b3	3c 22		 cmp	 al, 34			; 00000022H
  000b5	75 38		 jne	 SHORT $LN7@ParseLine

; 136  : 				{
; 137  : 					if(data != "")

  000b7	8b 45 d4	 mov	 eax, DWORD PTR _data$[ebp]
  000ba	39 55 e8	 cmp	 DWORD PTR _data$[ebp+20], edx
  000bd	73 03		 jae	 SHORT $LN85@ParseLine
  000bf	8d 45 d4	 lea	 eax, DWORD PTR _data$[ebp]
$LN85@ParseLine:
  000c2	53		 push	 ebx
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d1	3b c3		 cmp	 eax, ebx
  000d3	0f 85 40 01 00
	00		 jne	 $LN258@ParseLine
  000d9	33 c0		 xor	 eax, eax
  000db	39 5d e4	 cmp	 DWORD PTR _data$[ebp+16], ebx
  000de	0f 95 c0	 setne	 al
  000e1	3b c3		 cmp	 eax, ebx
  000e3	0f 85 30 01 00
	00		 jne	 $LN258@ParseLine

; 140  : 					}
; 141  : 					openstring = true;

  000e9	c6 45 d3 01	 mov	 BYTE PTR _openstring$[ebp], 1

; 142  : 					continue;

  000ed	eb 6b		 jmp	 SHORT $LN15@ParseLine
$LN7@ParseLine:

; 143  : 				}
; 144  : 				else
; 145  : 				{
; 146  : 					if(dump[i] == '\t' || dump[i] == ' ')

  000ef	3c 09		 cmp	 al, 9
  000f1	74 11		 je	 SHORT $LN3@ParseLine
  000f3	3c 20		 cmp	 al, 32			; 00000020H
  000f5	74 0d		 je	 SHORT $LN3@ParseLine
$LN9@ParseLine:

; 152  : 						}
; 153  : 						continue;
; 154  : 					}   
; 155  : 					data += dump[i];

  000f7	50		 push	 eax
  000f8	6a 01		 push	 1
  000fa	8d 4d d4	 lea	 ecx, DWORD PTR _data$[ebp]
  000fd	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 156  : 				}
; 157  : 			}
; 158  : 
; 159  : 		}

  00102	eb 56		 jmp	 SHORT $LN15@ParseLine
$LN3@ParseLine:

; 147  : 					{
; 148  : 						if(data != "")

  00104	8b 45 d4	 mov	 eax, DWORD PTR _data$[ebp]
  00107	39 55 e8	 cmp	 DWORD PTR _data$[ebp+20], edx
  0010a	73 03		 jae	 SHORT $LN158@ParseLine
  0010c	8d 45 d4	 lea	 eax, DWORD PTR _data$[ebp]
$LN158@ParseLine:
  0010f	53		 push	 ebx
  00110	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0011b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011e	3b c3		 cmp	 eax, ebx
  00120	75 0c		 jne	 SHORT $LN269@ParseLine
  00122	33 c0		 xor	 eax, eax
  00124	39 5d e4	 cmp	 DWORD PTR _data$[ebp+16], ebx
  00127	0f 95 c0	 setne	 al
  0012a	3b c3		 cmp	 eax, ebx
  0012c	74 2c		 je	 SHORT $LN15@ParseLine
$LN269@ParseLine:

; 149  : 						{
; 150  : 							pRow.Columns[column++] = data;

  0012e	8d 4d c8	 lea	 ecx, DWORD PTR $T173983[ebp]
  00131	51		 push	 ecx
  00132	8b 4d c4	 mov	 ecx, DWORD PTR _pRow$GSCopy$[ebp]
  00135	89 75 c8	 mov	 DWORD PTR $T173983[ebp], esi
  00138	46		 inc	 esi
  00139	e8 00 00 00 00	 call	 ??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
  0013e	6a ff		 push	 -1
  00140	53		 push	 ebx
  00141	8d 55 d4	 lea	 edx, DWORD PTR _data$[ebp]
  00144	52		 push	 edx
  00145	8b c8		 mov	 ecx, eax
  00147	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 151  : 							data = "";

  0014c	53		 push	 ebx
  0014d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00152	8d 4d d4	 lea	 ecx, DWORD PTR _data$[ebp]
  00155	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN15@ParseLine:

; 147  : 					{
; 148  : 						if(data != "")

  0015a	47		 inc	 edi
  0015b	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00160	3b 7d 18	 cmp	 edi, DWORD PTR _line$[ebp+16]
  00163	0f 82 18 ff ff
	ff		 jb	 $LL16@ParseLine
$LN14@ParseLine:

; 160  : 
; 161  : 		if(data != "")

  00169	8b 45 d4	 mov	 eax, DWORD PTR _data$[ebp]
  0016c	39 55 e8	 cmp	 DWORD PTR _data$[ebp+20], edx
  0016f	73 03		 jae	 SHORT $LN198@ParseLine
  00171	8d 45 d4	 lea	 eax, DWORD PTR _data$[ebp]
$LN198@ParseLine:
  00174	53		 push	 ebx
  00175	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00180	83 c4 0c	 add	 esp, 12			; 0000000cH
  00183	3b c3		 cmp	 eax, ebx
  00185	75 0c		 jne	 SHORT $LN271@ParseLine
  00187	33 c0		 xor	 eax, eax
  00189	39 5d e4	 cmp	 DWORD PTR _data$[ebp+16], ebx
  0018c	0f 95 c0	 setne	 al
  0018f	3b c3		 cmp	 eax, ebx
  00191	74 1e		 je	 SHORT $LN202@ParseLine
$LN271@ParseLine:

; 162  : 		{
; 163  : 			pRow.Columns[column++] = data;

  00193	8b 4d c4	 mov	 ecx, DWORD PTR _pRow$GSCopy$[ebp]
  00196	8d 55 c8	 lea	 edx, DWORD PTR $T173984[ebp]
  00199	89 75 c8	 mov	 DWORD PTR $T173984[ebp], esi
  0019c	52		 push	 edx
  0019d	46		 inc	 esi
  0019e	e8 00 00 00 00	 call	 ??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAK@Z ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
  001a3	6a ff		 push	 -1
  001a5	53		 push	 ebx
  001a6	8d 4d d4	 lea	 ecx, DWORD PTR _data$[ebp]
  001a9	51		 push	 ecx
  001aa	8b c8		 mov	 ecx, eax
  001ac	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN202@ParseLine:

; 164  : 		}
; 165  : 
; 166  : 		data = "";

  001b1	53		 push	 ebx
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001b7	8d 4d d4	 lea	 ecx, DWORD PTR _data$[ebp]
  001ba	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 167  : 
; 168  : 		pRow.ColumnCount = column;

  001bf	8b 55 c4	 mov	 edx, DWORD PTR _pRow$GSCopy$[ebp]
  001c2	89 72 10	 mov	 DWORD PTR [edx+16], esi

; 169  : 
; 170  : 		return true;

  001c5	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  001ca	39 75 e8	 cmp	 DWORD PTR _data$[ebp+20], esi
  001cd	72 0c		 jb	 SHORT $LN222@ParseLine
  001cf	8b 45 d4	 mov	 eax, DWORD PTR _data$[ebp]
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001d8	83 c4 04	 add	 esp, 4
$LN222@ParseLine:
  001db	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _data$[ebp+20], 15 ; 0000000fH
  001e2	89 5d e4	 mov	 DWORD PTR _data$[ebp+16], ebx
  001e5	88 5d d4	 mov	 BYTE PTR _data$[ebp], bl
  001e8	39 75 1c	 cmp	 DWORD PTR _line$[ebp+20], esi
  001eb	72 0c		 jb	 SHORT $LN244@ParseLine
  001ed	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  001f0	51		 push	 ecx
  001f1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001f6	83 c4 04	 add	 esp, 4
$LN244@ParseLine:
  001f9	b0 01		 mov	 al, 1
$LN17@ParseLine:

; 171  : 
; 172  : 	}

  001fb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001fe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00205	59		 pop	 ecx
  00206	5f		 pop	 edi
  00207	5e		 pop	 esi
  00208	5b		 pop	 ebx
  00209	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020c	33 cd		 xor	 ecx, ebp
  0020e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00213	8b e5		 mov	 esp, ebp
  00215	5d		 pop	 ebp
  00216	c2 20 00	 ret	 32			; 00000020H
$LN258@ParseLine:

; 138  : 					{
; 139  : 						return false;

  00219	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  0021e	39 75 e8	 cmp	 DWORD PTR _data$[ebp+20], esi
  00221	72 0c		 jb	 SHORT $LN100@ParseLine
  00223	8b 45 d4	 mov	 eax, DWORD PTR _data$[ebp]
  00226	50		 push	 eax
  00227	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0022c	83 c4 04	 add	 esp, 4
$LN100@ParseLine:
  0022f	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _data$[ebp+20], 15 ; 0000000fH
  00236	89 5d e4	 mov	 DWORD PTR _data$[ebp+16], ebx
  00239	88 5d d4	 mov	 BYTE PTR _data$[ebp], bl
  0023c	39 75 1c	 cmp	 DWORD PTR _line$[ebp+20], esi
  0023f	72 0c		 jb	 SHORT $LN122@ParseLine
  00241	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00244	51		 push	 ecx
  00245	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0024a	83 c4 04	 add	 esp, 4
$LN122@ParseLine:
  0024d	32 c0		 xor	 al, al
  0024f	eb aa		 jmp	 SHORT $LN17@ParseLine
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _line$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z$1:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR _data$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z ENDP ; Tokenizer::ParseLine
PUBLIC	??0TokenizerRow@@QAE@XZ				; TokenizerRow::TokenizerRow
; Function compile flags: /Ogtp
;	COMDAT ??0TokenizerRow@@QAE@XZ
_TEXT	SEGMENT
$T175057 = -16						; size = 12
$T174903 = -4						; size = 4
??0TokenizerRow@@QAE@XZ PROC				; TokenizerRow::TokenizerRow, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 30		 push	 48			; 00000030H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN28@TokenizerR
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 2c	 mov	 BYTE PTR [ecx+44], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 2d	 mov	 BYTE PTR [edx+45], al
  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN28@TokenizerR:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T174903[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T175057[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T174903[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T175057[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T175057[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN53@TokenizerR:
$LN52@TokenizerR:
  0006c	cc		 int	 3
??0TokenizerRow@@QAE@XZ ENDP				; TokenizerRow::TokenizerRow
_TEXT	ENDS
PUBLIC	??1TokenizerRow@@QAE@XZ				; TokenizerRow::~TokenizerRow
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TokenizerRow@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TokenizerRow@@QAE@XZ$2
__ehfuncinfo$??1TokenizerRow@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1TokenizerRow@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1TokenizerRow@@QAE@XZ
_TEXT	SEGMENT
$T175280 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TokenizerRow@@QAE@XZ PROC				; TokenizerRow::~TokenizerRow, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1TokenizerRow@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T175280[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TokenizerRow@@QAE@XZ$2:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1TokenizerRow@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1TokenizerRow@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1TokenizerRow@@QAE@XZ ENDP				; TokenizerRow::~TokenizerRow
PUBLIC	??4TokenizerRow@@QAEAAV0@ABV0@@Z		; TokenizerRow::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4TokenizerRow@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
$T175429 = 8						; size = 4
___that$ = 8						; size = 4
??4TokenizerRow@@QAEAAV0@ABV0@@Z PROC			; TokenizerRow::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 1a		 je	 SHORT $LN5@operator@14
  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 45 08	 lea	 eax, DWORD PTR $T175429[ebp]
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
$LN5@operator@14:
  00028	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0002b	5f		 pop	 edi
  0002c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??4TokenizerRow@@QAEAAV0@ABV0@@Z ENDP			; TokenizerRow::operator=
_TEXT	ENDS
PUBLIC	??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ	; std::_Pair_base<unsigned long,TokenizerRow>::~_Pair_base<unsigned long,TokenizerRow>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ$3
__ehfuncinfo$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ
_TEXT	SEGMENT
$T175680 = -20						; size = 4
$T175712 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ PROC	; std::_Pair_base<unsigned long,TokenizerRow>::~_Pair_base<unsigned long,TokenizerRow>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00029	89 75 f0	 mov	 DWORD PTR $T175712[ebp], esi
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	8d 45 ec	 lea	 eax, DWORD PTR $T175680[ebp]
  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ$3:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T175712[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Pair_base@KVTokenizerRow@@@std@@QAE@XZ ENDP	; std::_Pair_base<unsigned long,TokenizerRow>::~_Pair_base<unsigned long,TokenizerRow>
PUBLIC	??0?$_Pair_base@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z ; std::_Pair_base<unsigned long,TokenizerRow>::_Pair_base<unsigned long,TokenizerRow>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z PROC ; std::_Pair_base<unsigned long,TokenizerRow>::_Pair_base<unsigned long,TokenizerRow>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 146  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$_Pair_base@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z ENDP ; std::_Pair_base<unsigned long,TokenizerRow>::_Pair_base<unsigned long,TokenizerRow>
_TEXT	ENDS
PUBLIC	??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ ; std::_Pair_base<unsigned long const ,TokenizerRow>::~_Pair_base<unsigned long const ,TokenizerRow>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ$3
__ehfuncinfo$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ
_TEXT	SEGMENT
$T175965 = -20						; size = 4
$T175996 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ PROC	; std::_Pair_base<unsigned long const ,TokenizerRow>::~_Pair_base<unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00029	89 75 f0	 mov	 DWORD PTR $T175996[ebp], esi
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	8d 45 ec	 lea	 eax, DWORD PTR $T175965[ebp]
  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ$3:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T175996[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@XZ ENDP	; std::_Pair_base<unsigned long const ,TokenizerRow>::~_Pair_base<unsigned long const ,TokenizerRow>
PUBLIC	??$?0ABKAAVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABKAAVTokenizerRow@@@Z ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow><unsigned long const &,TokenizerRow &>
; Function compile flags: /Ogtp
;	COMDAT ??$?0ABKAAVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABKAAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0ABKAAVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABKAAVTokenizerRow@@@Z PROC ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow><unsigned long const &,TokenizerRow &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 164  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$?0ABKAAVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABKAAVTokenizerRow@@@Z ENDP ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow><unsigned long const &,TokenizerRow &>
_TEXT	ENDS
PUBLIC	??$?0KVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow><unsigned long,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??$?0KVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0KVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z PROC ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow><unsigned long,TokenizerRow>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 164  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$?0KVTokenizerRow@@@?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z ENDP ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow><unsigned long,TokenizerRow>
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z PROC ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx

; 150  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 151  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z ENDP ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow>
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QBK$$QAVTokenizerRow@@@Z ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QBK$$QAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QBK$$QAVTokenizerRow@@@Z PROC ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 146  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$_Pair_base@$$CBKVTokenizerRow@@@std@@QAE@$$QBK$$QAVTokenizerRow@@@Z ENDP ; std::_Pair_base<unsigned long const ,TokenizerRow>::_Pair_base<unsigned long const ,TokenizerRow>
_TEXT	ENDS
PUBLIC	??1?$pair@KVTokenizerRow@@@std@@QAE@XZ		; std::pair<unsigned long,TokenizerRow>::~pair<unsigned long,TokenizerRow>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ$4
__ehfuncinfo$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$pair@KVTokenizerRow@@@std@@QAE@XZ
_TEXT	SEGMENT
$T176365 = -20						; size = 4
$T176339 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@KVTokenizerRow@@@std@@QAE@XZ PROC		; std::pair<unsigned long,TokenizerRow>::~pair<unsigned long,TokenizerRow>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00029	89 75 f0	 mov	 DWORD PTR $T176339[ebp], esi
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	8d 45 ec	 lea	 eax, DWORD PTR $T176365[ebp]
  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ$4:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T176339[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$pair@KVTokenizerRow@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$pair@KVTokenizerRow@@@std@@QAE@XZ ENDP		; std::pair<unsigned long,TokenizerRow>::~pair<unsigned long,TokenizerRow>
PUBLIC	??0?$pair@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z ; std::pair<unsigned long,TokenizerRow>::pair<unsigned long,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??0?$pair@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z PROC ; std::pair<unsigned long,TokenizerRow>::pair<unsigned long,TokenizerRow>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 228  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$pair@KVTokenizerRow@@@std@@QAE@$$QAK$$QAVTokenizerRow@@@Z ENDP ; std::pair<unsigned long,TokenizerRow>::pair<unsigned long,TokenizerRow>
_TEXT	ENDS
PUBLIC	??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ	; std::pair<unsigned long const ,TokenizerRow>::~pair<unsigned long const ,TokenizerRow>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ$4
__ehfuncinfo$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ
_TEXT	SEGMENT
$T176698 = -20						; size = 4
$T176686 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ PROC		; std::pair<unsigned long const ,TokenizerRow>::~pair<unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00029	89 75 f0	 mov	 DWORD PTR $T176686[ebp], esi
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	8d 45 ec	 lea	 eax, DWORD PTR $T176698[ebp]
  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ$4:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T176686[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ ENDP		; std::pair<unsigned long const ,TokenizerRow>::~pair<unsigned long const ,TokenizerRow>
PUBLIC	??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@AAU01@@Z ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long const ,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@AAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@AAU01@@Z PROC ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx

; 195  : 		{	// construct from compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	57		 push	 edi
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	89 06		 mov	 DWORD PTR [esi], eax
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0001e	5f		 pop	 edi
  0001f	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 196  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@AAU01@@Z ENDP ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long const ,TokenizerRow>
_TEXT	ENDS
PUBLIC	??$?0KVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU?$pair@KVTokenizerRow@@@1@@Z ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??$?0KVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU?$pair@KVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0KVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU?$pair@KVTokenizerRow@@@1@@Z PROC ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long,TokenizerRow>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	57		 push	 edi
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	89 06		 mov	 DWORD PTR [esi], eax
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0001e	5f		 pop	 edi
  0001f	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 256  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??$?0KVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU?$pair@KVTokenizerRow@@@1@@Z ENDP ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long,TokenizerRow>
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??0?$pair@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z PROC ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx

; 233  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 234  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$pair@$$CBKVTokenizerRow@@@std@@QAE@ABK$$QAVTokenizerRow@@@Z ENDP ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow>
_TEXT	ENDS
PUBLIC	??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU01@@Z ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long const ,TokenizerRow>
; Function compile flags: /Ogtp
;	COMDAT ??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU01@@Z PROC ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long const ,TokenizerRow>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	57		 push	 edi
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	89 06		 mov	 DWORD PTR [esi], eax
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0001b	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0001e	5f		 pop	 edi
  0001f	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 256  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??$?0$$CBKVTokenizerRow@@@?$pair@$$CBKVTokenizerRow@@@std@@QAE@$$QAU01@@Z ENDP ; std::pair<unsigned long const ,TokenizerRow>::pair<unsigned long const ,TokenizerRow><unsigned long const ,TokenizerRow>
_TEXT	ENDS
PUBLIC	??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z	; std::pair<unsigned long const ,TokenizerRow>::`scalar deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z$4
__ehfuncinfo$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
$T177224 = -20						; size = 4
$T177137 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z PROC	; std::pair<unsigned long const ,TokenizerRow>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  0002c	89 75 f0	 mov	 DWORD PTR $T177137[ebp], esi
  0002f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	8d 45 ec	 lea	 eax, DWORD PTR $T177224[ebp]
  00039	50		 push	 eax
  0003a	8b ce		 mov	 ecx, esi
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00048	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00051	83 c4 04	 add	 esp, 4
  00054	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00058	74 09		 je	 SHORT $LN49@scalar@20
  0005a	57		 push	 edi
  0005b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00060	83 c4 04	 add	 esp, 4
$LN49@scalar@20:
  00063	8b c7		 mov	 eax, edi
  00065	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006f	59		 pop	 ecx
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z$4:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T177137[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$pair@$$CBKVTokenizerRow@@@std@@QAEPAXI@Z ENDP	; std::pair<unsigned long const ,TokenizerRow>::`scalar deleting destructor'
PUBLIC	??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct<std::pair<unsigned long const ,TokenizerRow> &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z$0
__ehfuncinfo$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z
_TEXT	SEGMENT
$T177236 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct<std::pair<unsigned long const ,TokenizerRow> &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00025	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T177236[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN3@construct@3
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN3@construct@3:

; 209  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T177236[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@AAU21@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct<std::pair<unsigned long const ,TokenizerRow> &>
PUBLIC	??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct<std::pair<unsigned long,TokenizerRow> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z$0
__ehfuncinfo$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
$T177299 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct<std::pair<unsigned long,TokenizerRow> >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00025	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T177299[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN3@construct@4
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN3@construct@4:

; 209  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T177299[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@KVTokenizerRow@@@std@@@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct<std::pair<unsigned long,TokenizerRow> >
PUBLIC	?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z$0
__ehfuncinfo$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z
_TEXT	SEGMENT
$T177372 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00025	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T177372[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN3@construct@5
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN3@construct@5:

; 203  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T177372[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@$$QAU32@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::construct
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z
_TEXT	SEGMENT
$T177506 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T177506[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN7@Cons_val@3
  00036	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN7@Cons_val@3:

; 281  : 	}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T177506[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> &>
PUBLIC	??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z ; std::_Destroy<std::pair<unsigned long const ,TokenizerRow> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z$4
__ehfuncinfo$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z
_TEXT	SEGMENT
$T177897 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T177792 = 8						; size = 4
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z PROC ; std::_Destroy<std::pair<unsigned long const ,TokenizerRow> >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 63   : 	_Ptr->~_Ty();

  00024	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00027	83 c6 04	 add	 esi, 4
  0002a	89 75 08	 mov	 DWORD PTR $T177792[ebp], esi
  0002d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	8d 45 f0	 lea	 eax, DWORD PTR $T177897[ebp]
  00037	50		 push	 eax
  00038	8b ce		 mov	 ecx, esi
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00046	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004f	83 c4 04	 add	 esp, 4

; 64   : 	}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z$4:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR $T177792[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Destroy@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerRow@@@0@@Z ENDP ; std::_Destroy<std::pair<unsigned long const ,TokenizerRow> >
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long,TokenizerRow> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z
_TEXT	SEGMENT
$T178009 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long,TokenizerRow> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T178009[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN7@Cons_val@4
  00036	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN7@Cons_val@4:

; 281  : 	}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T178009[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long,TokenizerRow> >
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z
_TEXT	SEGMENT
$T178112 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T178112[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN7@Cons_val@5
  00036	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN7@Cons_val@5:

; 281  : 	}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T178112[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> >
PUBLIC	??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> &>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z$0
__unwindtable$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z$2
__ehfuncinfo$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
$T178197 = -32						; size = 12
__Ptr$178216 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T178154 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> &>, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002d	6a 28		 push	 40			; 00000028H
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	8b f0		 mov	 esi, eax
  00036	33 c0		 xor	 eax, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	89 75 ec	 mov	 DWORD PTR __Ptr$178216[ebp], esi
  0003e	3b f0		 cmp	 esi, eax
  00040	74 57		 je	 SHORT $LN12@Buynode@6
  00042	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00045	89 0e		 mov	 DWORD PTR [esi], ecx
  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0004d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00050	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	66 89 46 24	 mov	 WORD PTR [esi+36], ax
  00057	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  0005a	52		 push	 edx
  0005b	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005e	50		 push	 eax
  0005f	83 c7 0d	 add	 edi, 13			; 0000000dH
  00062	57		 push	 edi
  00063	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00066	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@AAU32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@AAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> &>
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  0006e	8b c6		 mov	 eax, esi

; 599  : 		}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
__catch$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$178216[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4

; 595  : 		_RERAISE;

  00090	33 c0		 xor	 eax, eax
  00092	50		 push	 eax
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Buynode@6:

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@6:
  00099	8d 55 08	 lea	 edx, DWORD PTR $T178154[ebp]
  0009c	52		 push	 edx
  0009d	8d 4d e0	 lea	 ecx, DWORD PTR $T178197[ebp]
  000a0	89 45 08	 mov	 DWORD PTR $T178154[ebp], eax
  000a3	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ad	8d 45 e0	 lea	 eax, DWORD PTR $T178197[ebp]
  000b0	50		 push	 eax
  000b1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T178197[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Buynode@6:
$LN44@Buynode@6:
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> &>
PUBLIC	?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::destroy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z$4
__ehfuncinfo$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z
_TEXT	SEGMENT
$T178664 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T178509 = 8						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 213  : 		_Destroy(_Ptr);

  00024	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00027	83 c6 04	 add	 esi, 4
  0002a	89 75 08	 mov	 DWORD PTR $T178509[ebp], esi
  0002d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	8d 45 f0	 lea	 eax, DWORD PTR $T178664[ebp]
  00037	50		 push	 eax
  00038	8b ce		 mov	 ecx, esi
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00046	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004f	83 c4 04	 add	 esp, 4

; 214  : 		}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z$4:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR $T178509[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?destroy@?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerRow@@@2@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerRow> >::destroy
PUBLIC	??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long,TokenizerRow> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
$T178763 = -32						; size = 12
__Ptr$178767 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T178715 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long,TokenizerRow> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002d	6a 28		 push	 40			; 00000028H
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	8b f0		 mov	 esi, eax
  00036	33 c0		 xor	 eax, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	89 75 ec	 mov	 DWORD PTR __Ptr$178767[ebp], esi
  0003e	3b f0		 cmp	 esi, eax
  00040	74 57		 je	 SHORT $LN12@Buynode@7
  00042	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00045	89 0e		 mov	 DWORD PTR [esi], ecx
  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0004d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00050	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	66 89 46 24	 mov	 WORD PTR [esi+36], ax
  00057	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  0005a	52		 push	 edx
  0005b	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005e	50		 push	 eax
  0005f	83 c7 0d	 add	 edi, 13			; 0000000dH
  00062	57		 push	 edi
  00063	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00066	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U?$pair@KVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU?$pair@KVTokenizerRow@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long,TokenizerRow> >
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  0006e	8b c6		 mov	 eax, esi

; 599  : 		}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
__catch$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$178767[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4

; 595  : 		_RERAISE;

  00090	33 c0		 xor	 eax, eax
  00092	50		 push	 eax
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Buynode@7:

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@7:
  00099	8d 55 08	 lea	 edx, DWORD PTR $T178715[ebp]
  0009c	52		 push	 edx
  0009d	8d 4d e0	 lea	 ecx, DWORD PTR $T178763[ebp]
  000a0	89 45 08	 mov	 DWORD PTR $T178715[ebp], eax
  000a3	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ad	8d 45 e0	 lea	 eax, DWORD PTR $T178763[ebp]
  000b0	50		 push	 eax
  000b1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T178763[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Buynode@7:
$LN44@Buynode@7:
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long,TokenizerRow> >
PUBLIC	??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
$T178869 = -32						; size = 12
__Ptr$178873 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T178821 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002d	6a 28		 push	 40			; 00000028H
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	8b f0		 mov	 esi, eax
  00036	33 c0		 xor	 eax, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	89 75 ec	 mov	 DWORD PTR __Ptr$178873[ebp], esi
  0003e	3b f0		 cmp	 esi, eax
  00040	74 57		 je	 SHORT $LN12@Buynode@8
  00042	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00045	89 0e		 mov	 DWORD PTR [esi], ecx
  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0004d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00050	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	66 89 46 24	 mov	 WORD PTR [esi+36], ax
  00057	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  0005a	52		 push	 edx
  0005b	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005e	50		 push	 eax
  0005f	83 c7 0d	 add	 edi, 13			; 0000000dH
  00062	57		 push	 edi
  00063	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00066	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow>,std::pair<unsigned long const ,TokenizerRow> >
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  0006e	8b c6		 mov	 eax, esi

; 599  : 		}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
__catch$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$178873[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4

; 595  : 		_RERAISE;

  00090	33 c0		 xor	 eax, eax
  00092	50		 push	 eax
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Buynode@8:

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@8:
  00099	8d 55 08	 lea	 edx, DWORD PTR $T178821[ebp]
  0009c	52		 push	 edx
  0009d	8d 4d e0	 lea	 ecx, DWORD PTR $T178869[ebp]
  000a0	89 45 08	 mov	 DWORD PTR $T178821[ebp], eax
  000a3	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ad	8d 45 e0	 lea	 eax, DWORD PTR $T178869[ebp]
  000b0	50		 push	 eax
  000b1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T178869[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Buynode@8:
$LN44@Buynode@8:
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> >
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z$4
__ehfuncinfo$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z
_TEXT	SEGMENT
$T179400 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
$T179177 = 12						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 287  : 	_Alval.destroy(_Pdest);

  00024	8b 75 0c	 mov	 esi, DWORD PTR __Pdest$[ebp]
  00027	83 c6 04	 add	 esi, 4
  0002a	89 75 0c	 mov	 DWORD PTR $T179177[ebp], esi
  0002d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	8d 45 f0	 lea	 eax, DWORD PTR $T179400[ebp]
  00037	50		 push	 eax
  00038	8b ce		 mov	 ecx, esi
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00046	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004f	83 c4 04	 add	 esp, 4

; 288  : 	}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z$4:
  00000	8b 4d 0c	 mov	 ecx, DWORD PTR $T179177[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	3d a9 aa aa 0a	 cmp	 eax, 178956969		; 0aaaaaa9H
  0000e	72 23		 jb	 SHORT $LN17@Insert@3

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  00010	8b 75 14	 mov	 esi, DWORD PTR __Newnode$[ebp]
  00013	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00016	50		 push	 eax
  00017	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0002e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN377@Insert@3:
$LN17@Insert@3:

; 1640 : 			}
; 1641 : 		++this->_Mysize;
; 1642 : 		_Newnode->_Parent = _Wherenode;

  00033	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00036	40		 inc	 eax
  00037	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0003a	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0003d	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00040	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00043	32 db		 xor	 bl, bl
  00045	3b c2		 cmp	 eax, edx
  00047	75 10		 jne	 SHORT $LN16@Insert@3

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00049	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1647 : 			_Lmost() = _Newnode;

  0004c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004f	89 3a		 mov	 DWORD PTR [edx], edi

; 1648 : 			_Rmost() = _Newnode;

  00051	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00054	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00057	eb 20		 jmp	 SHORT $LN11@Insert@3
$LN16@Insert@3:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  00059	38 5d 0c	 cmp	 BYTE PTR __Addleft$[ebp], bl
  0005c	74 0d		 je	 SHORT $LN14@Insert@3

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  0005e	89 38		 mov	 DWORD PTR [eax], edi

; 1653 : 			if (_Wherenode == _Lmost())

  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	3b 02		 cmp	 eax, DWORD PTR [edx]
  00065	75 12		 jne	 SHORT $LN11@Insert@3

; 1654 : 				_Lmost() = _Newnode;

  00067	89 3a		 mov	 DWORD PTR [edx], edi

; 1655 : 			}
; 1656 : 		else

  00069	eb 0e		 jmp	 SHORT $LN11@Insert@3
$LN14@Insert@3:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  0006b	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 1659 : 			if (_Wherenode == _Rmost())

  0006e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00071	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00074	75 03		 jne	 SHORT $LN11@Insert@3

; 1660 : 				_Rmost() = _Newnode;

  00076	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN11@Insert@3:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00079	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007c	8b c7		 mov	 eax, edi
  0007e	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00081	0f 85 8f 01 00
	00		 jne	 $LN9@Insert@3
$LL10@Insert@3:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0008d	3b 16		 cmp	 edx, DWORD PTR [esi]
  0008f	0f 85 c1 00 00
	00		 jne	 $LN8@Insert@3

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00095	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00098	38 5e 24	 cmp	 BYTE PTR [esi+36], bl
  0009b	75 1c		 jne	 SHORT $LN7@Insert@3

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0009d	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  000a1	c6 46 24 01	 mov	 BYTE PTR [esi+36], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  000a5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a8	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000ab	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000ae	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1677 : 					}
; 1678 : 				else

  000b4	e9 51 01 00 00	 jmp	 $LN316@Insert@3
$LN7@Insert@3:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000b9	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  000bc	75 3a		 jne	 SHORT $LN111@Insert@3

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  000be	8b c2		 mov	 eax, edx

; 1683 : 						_Lrotate(_Pnode);

  000c0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000c3	8b 32		 mov	 esi, DWORD PTR [edx]
  000c5	89 70 08	 mov	 DWORD PTR [eax+8], esi
  000c8	8b 32		 mov	 esi, DWORD PTR [edx]
  000ca	38 5e 25	 cmp	 BYTE PTR [esi+37], bl
  000cd	75 03		 jne	 SHORT $LN110@Insert@3
  000cf	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN110@Insert@3:
  000d2	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d5	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000d8	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000db	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000de	75 05		 jne	 SHORT $LN109@Insert@3
  000e0	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000e3	eb 0e		 jmp	 SHORT $LN106@Insert@3
$LN109@Insert@3:
  000e5	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000e8	3b 06		 cmp	 eax, DWORD PTR [esi]
  000ea	75 04		 jne	 SHORT $LN107@Insert@3
  000ec	89 16		 mov	 DWORD PTR [esi], edx
  000ee	eb 03		 jmp	 SHORT $LN106@Insert@3
$LN107@Insert@3:
  000f0	89 56 08	 mov	 DWORD PTR [esi+8], edx
$LN106@Insert@3:
  000f3	89 02		 mov	 DWORD PTR [edx], eax
  000f5	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN111@Insert@3:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000f8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000fb	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000ff	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00102	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00105	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00108	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0010b	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0010e	8b 32		 mov	 esi, DWORD PTR [edx]
  00110	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00113	89 3a		 mov	 DWORD PTR [edx], edi
  00115	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00118	38 5f 25	 cmp	 BYTE PTR [edi+37], bl
  0011b	75 03		 jne	 SHORT $LN173@Insert@3
  0011d	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN173@Insert@3:
  00120	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00123	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00126	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00129	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  0012c	75 0b		 jne	 SHORT $LN172@Insert@3
  0012e	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00131	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00134	e9 cb 00 00 00	 jmp	 $LN376@Insert@3

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN172@Insert@3:
  00139	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0013c	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  0013f	75 0b		 jne	 SHORT $LN170@Insert@3
  00141	89 77 08	 mov	 DWORD PTR [edi+8], esi
  00144	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00147	e9 b8 00 00 00	 jmp	 $LN376@Insert@3

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN170@Insert@3:
  0014c	89 37		 mov	 DWORD PTR [edi], esi
  0014e	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00151	e9 ae 00 00 00	 jmp	 $LN376@Insert@3
$LN8@Insert@3:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  00156	8b 36		 mov	 esi, DWORD PTR [esi]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  00158	38 5e 24	 cmp	 BYTE PTR [esi+36], bl
  0015b	75 1c		 jne	 SHORT $LN3@Insert@3

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0015d	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  00161	c6 46 24 01	 mov	 BYTE PTR [esi+36], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  00165	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00168	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0016b	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  0016e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00171	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1703 : 					}
; 1704 : 				else

  00174	e9 91 00 00 00	 jmp	 $LN316@Insert@3
$LN3@Insert@3:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00179	3b 02		 cmp	 eax, DWORD PTR [edx]
  0017b	75 3c		 jne	 SHORT $LN253@Insert@3

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  0017d	8b c2		 mov	 eax, edx

; 1709 : 						_Rrotate(_Pnode);

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00184	89 30		 mov	 DWORD PTR [eax], esi
  00186	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00189	38 5e 25	 cmp	 BYTE PTR [esi+37], bl
  0018c	75 03		 jne	 SHORT $LN252@Insert@3
  0018e	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN252@Insert@3:
  00191	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00194	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00197	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0019a	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0019d	75 05		 jne	 SHORT $LN251@Insert@3
  0019f	89 56 04	 mov	 DWORD PTR [esi+4], edx
  001a2	eb 0f		 jmp	 SHORT $LN248@Insert@3
$LN251@Insert@3:
  001a4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001a7	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  001aa	75 05		 jne	 SHORT $LN249@Insert@3
  001ac	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001af	eb 02		 jmp	 SHORT $LN248@Insert@3
$LN249@Insert@3:
  001b1	89 16		 mov	 DWORD PTR [esi], edx
$LN248@Insert@3:
  001b3	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001b6	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN253@Insert@3:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  001b9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bc	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  001c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001c3	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001c6	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001c9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001cc	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001cf	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  001d2	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d4	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  001d7	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d9	38 5f 25	 cmp	 BYTE PTR [edi+37], bl
  001dc	75 03		 jne	 SHORT $LN315@Insert@3
  001de	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN315@Insert@3:
  001e1	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001e4	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001e7	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  001ea	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  001ed	75 05		 jne	 SHORT $LN314@Insert@3
  001ef	89 77 04	 mov	 DWORD PTR [edi+4], esi
  001f2	eb 0e		 jmp	 SHORT $LN311@Insert@3
$LN314@Insert@3:
  001f4	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001f7	3b 17		 cmp	 edx, DWORD PTR [edi]
  001f9	75 04		 jne	 SHORT $LN312@Insert@3
  001fb	89 37		 mov	 DWORD PTR [edi], esi
  001fd	eb 03		 jmp	 SHORT $LN311@Insert@3
$LN312@Insert@3:
  001ff	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN311@Insert@3:
  00202	89 16		 mov	 DWORD PTR [esi], edx
$LN376@Insert@3:
  00204	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00207	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN316@Insert@3:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  0020a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0020d	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00210	0f 84 71 fe ff
	ff		 je	 $LL10@Insert@3
$LN9@Insert@3:

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00216	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00219	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1720 : 		return (iterator(_Newnode, this));

  0021c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0021f	89 38		 mov	 DWORD PTR [eax], edi
  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	c6 41 24 01	 mov	 BYTE PTR [ecx+36], 1
  00227	5b		 pop	 ebx

; 1721 : 		}

  00228	5d		 pop	 ebp
  00229	c2 10 00	 ret	 16			; 00000010H
$LN375@Insert@3:
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv797 = -12						; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	80 7b 25 00	 cmp	 BYTE PTR [ebx+37], 0
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00013	74 0a		 je	 SHORT $LN40@erase@4

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN297@erase@4:
$LN40@erase@4:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1207 : 		++_Where;	// save successor iterator for return

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00022	89 5d f8	 mov	 DWORD PTR __Erasednode$[ebp], ebx
  00025	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  0002a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002c	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00030	74 05		 je	 SHORT $LN39@erase@4

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00032	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00035	eb 17		 jmp	 SHORT $LN291@erase@4
$LN39@erase@4:
  00037	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0003a	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0003e	74 04		 je	 SHORT $LN37@erase@4

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00040	8b f9		 mov	 edi, ecx

; 1218 : 		else

  00042	eb 0a		 jmp	 SHORT $LN291@erase@4
$LN37@erase@4:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00047	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  0004a	3b c3		 cmp	 eax, ebx
  0004c	75 72		 jne	 SHORT $LN35@erase@4
$LN291@erase@4:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004e	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  00052	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00055	75 03		 jne	 SHORT $LN34@erase@4

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00057	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase@4:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00060	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00063	75 05		 jne	 SHORT $LN33@erase@4

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00065	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00068	eb 0b		 jmp	 SHORT $LN30@erase@4
$LN33@erase@4:
  0006a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0006c	75 04		 jne	 SHORT $LN31@erase@4

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006e	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  00070	eb 03		 jmp	 SHORT $LN30@erase@4
$LN31@erase@4:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  00072	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase@4:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	39 18		 cmp	 DWORD PTR [eax], ebx
  0007a	75 1b		 jne	 SHORT $LN29@erase@4

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007c	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  00080	74 04		 je	 SHORT $LN43@erase@4
  00082	8b c6		 mov	 eax, esi
  00084	eb 0c		 jmp	 SHORT $LN44@erase@4
$LN43@erase@4:
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Min
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c4 04	 add	 esp, 4
$LN44@erase@4:
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	89 02		 mov	 DWORD PTR [edx], eax
$LN29@erase@4:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  00097	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009a	89 4d f4	 mov	 DWORD PTR tv797[ebp], ecx
  0009d	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000a0	75 78		 jne	 SHORT $LN165@erase@4

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000a2	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  000a6	74 07		 je	 SHORT $LN45@erase@4
  000a8	8b c6		 mov	 eax, esi
  000aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000ad	eb 6b		 jmp	 SHORT $LN165@erase@4
$LN45@erase@4:

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Max
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR tv797[ebp]
  000b8	83 c4 04	 add	 esp, 4
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000be	eb 5a		 jmp	 SHORT $LN165@erase@4
$LN35@erase@4:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c0	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase@4

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f0		 mov	 esi, eax

; 1257 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase@4
$LN26@erase@4:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	75 03		 jne	 SHORT $LN24@erase@4

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase@4:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e1	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000e4	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000e7	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN25@erase@4:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f0	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000f3	75 05		 jne	 SHORT $LN23@erase@4

; 1271 : 				_Root() = _Pnode;	// link down from root

  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f8	eb 0e		 jmp	 SHORT $LN20@erase@4
$LN23@erase@4:
  000fa	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000fd	39 19		 cmp	 DWORD PTR [ecx], ebx
  000ff	75 04		 jne	 SHORT $LN21@erase@4

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00101	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  00103	eb 03		 jmp	 SHORT $LN20@erase@4
$LN21@erase@4:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  00105	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase@4:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00108	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0010b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  0010e	8a 53 24	 mov	 dl, BYTE PTR [ebx+36]
  00111	8a 48 24	 mov	 cl, BYTE PTR [eax+36]
  00114	88 50 24	 mov	 BYTE PTR [eax+36], dl
  00117	88 4b 24	 mov	 BYTE PTR [ebx+36], cl
$LN165@erase@4:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	b3 01		 mov	 bl, 1
  00122	38 58 24	 cmp	 BYTE PTR [eax+36], bl
  00125	0f 85 fa 00 00
	00		 jne	 $LN19@erase@4
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	3b 7a 04	 cmp	 edi, DWORD PTR [edx+4]
  00131	0f 84 eb 00 00
	00		 je	 $LN16@erase@4
$LL18@erase@4:
  00137	38 5f 24	 cmp	 BYTE PTR [edi+36], bl
  0013a	0f 85 e2 00 00
	00		 jne	 $LN16@erase@4

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00140	8b 06		 mov	 eax, DWORD PTR [esi]
  00142	3b f8		 cmp	 edi, eax
  00144	75 65		 jne	 SHORT $LN15@erase@4

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  00146	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  00149	80 78 24 00	 cmp	 BYTE PTR [eax+36], 0
  0014d	75 13		 jne	 SHORT $LN14@erase@4

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0014f	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  00152	56		 push	 esi
  00153	c6 46 24 00	 mov	 BYTE PTR [esi+36], 0
  00157	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN14@erase@4:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00162	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00166	75 74		 jne	 SHORT $LN294@erase@4

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00168	8b 10		 mov	 edx, DWORD PTR [eax]
  0016a	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  0016d	75 08		 jne	 SHORT $LN11@erase@4
  0016f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00172	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00175	74 61		 je	 SHORT $LN295@erase@4
$LN11@erase@4:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  00177	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017a	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  0017d	75 15		 jne	 SHORT $LN9@erase@4

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  00184	50		 push	 eax
  00185	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
  00189	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  0018e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN9@erase@4:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00194	8a 56 24	 mov	 dl, BYTE PTR [esi+36]
  00197	88 50 24	 mov	 BYTE PTR [eax+36], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0019a	88 5e 24	 mov	 BYTE PTR [esi+36], bl

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0019d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1323 : 						_Lrotate(_Fixnodeparent);

  001a0	56		 push	 esi
  001a1	88 58 24	 mov	 BYTE PTR [eax+36], bl
  001a4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001a9	eb 74		 jmp	 SHORT $LN296@erase@4
$LN15@erase@4:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001ab	80 78 24 00	 cmp	 BYTE PTR [eax+36], 0
  001af	75 12		 jne	 SHORT $LN7@erase@4

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001b1	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001b4	56		 push	 esi
  001b5	c6 46 24 00	 mov	 BYTE PTR [esi+36], 0
  001b9	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001be	8b 06		 mov	 eax, DWORD PTR [esi]
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN7@erase@4:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001c3	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001c7	75 13		 jne	 SHORT $LN294@erase@4

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001cc	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001cf	75 1e		 jne	 SHORT $LN4@erase@4
  001d1	8b 10		 mov	 edx, DWORD PTR [eax]
  001d3	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001d6	75 17		 jne	 SHORT $LN4@erase@4
$LN295@erase@4:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001d8	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
$LN294@erase@4:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001dc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1344 : 						_Fixnode = _Fixnodeparent;

  001df	8b fe		 mov	 edi, esi
  001e1	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001e4	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001e7	0f 85 4a ff ff
	ff		 jne	 $LL18@erase@4

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001ed	eb 33		 jmp	 SHORT $LN16@erase@4
$LN4@erase@4:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001ef	8b 10		 mov	 edx, DWORD PTR [eax]
  001f1	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001f4	75 15		 jne	 SHORT $LN2@erase@4

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001f9	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  001fc	50		 push	 eax
  001fd	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
  00201	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00206	8b 06		 mov	 eax, DWORD PTR [esi]
  00208	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN2@erase@4:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0020b	8a 56 24	 mov	 dl, BYTE PTR [esi+36]
  0020e	88 50 24	 mov	 BYTE PTR [eax+36], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00211	88 5e 24	 mov	 BYTE PTR [esi+36], bl

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00214	8b 00		 mov	 eax, DWORD PTR [eax]

; 1359 : 						_Rrotate(_Fixnodeparent);

  00216	56		 push	 esi
  00217	88 58 24	 mov	 BYTE PTR [eax+36], bl
  0021a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Rrotate
$LN296@erase@4:
  0021f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN16@erase@4:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00222	88 5f 24	 mov	 BYTE PTR [edi+36], bl
$LN19@erase@4:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00225	8b 55 f8	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00228	83 c2 0c	 add	 edx, 12			; 0000000cH
  0022b	52		 push	 edx
  0022c	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00235	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00241	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00244	83 c4 0c	 add	 esp, 12			; 0000000cH
  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
  00249	5b		 pop	 ebx
  0024a	85 c0		 test	 eax, eax
  0024c	74 04		 je	 SHORT $LN1@erase@4

; 1373 : 			--this->_Mysize;

  0024e	48		 dec	 eax
  0024f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase@4:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  00252	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00255	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00258	89 08		 mov	 DWORD PTR [eax], ecx

; 1376 : 		}

  0025a	8b e5		 mov	 esp, ebp
  0025c	5d		 pop	 ebp
  0025d	c2 08 00	 ret	 8
$LN293@erase@4:
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase
; Function compile flags: /Ogtp
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 2b		 jne	 SHORT $LN1@Erase@2
$LL3@Erase@2:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	50		 push	 eax
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  00020	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00023	51		 push	 ecx
  00024	8d 43 0d	 lea	 eax, DWORD PTR [ebx+13]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  0003a	8b fe		 mov	 edi, esi
  0003c	74 d5		 je	 SHORT $LL3@Erase@2
$LN1@Erase@2:
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Linsert
; Function compile flags: /Ogtp
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
$T180640 = 16						; size = 4
$T180638 = 16						; size = 4
__Where$152128 = 16					; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx

; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00012	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00016	8b f1		 mov	 esi, ecx
  00018	b1 01		 mov	 cl, 1
  0001a	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 2d		 jne	 SHORT $LN11@Linsert@2
  0001f	8b 5a 0c	 mov	 ebx, DWORD PTR [edx+12]
$LL12@Linsert@2:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Leftish$[ebp], 0
  00026	8b f0		 mov	 esi, eax
  00028	74 08		 je	 SHORT $LN10@Linsert@2

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0002a	39 58 0c	 cmp	 DWORD PTR [eax+12], ebx
  0002d	0f 93 c1	 setae	 cl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00030	eb 06		 jmp	 SHORT $LN145@Linsert@2
$LN10@Linsert@2:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00032	3b 58 0c	 cmp	 ebx, DWORD PTR [eax+12]
  00035	0f 92 c1	 setb	 cl
$LN145@Linsert@2:
  00038	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0003b	84 c9		 test	 cl, cl
  0003d	74 04		 je	 SHORT $LN15@Linsert@2
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 03		 jmp	 SHORT $LN16@Linsert@2
$LN15@Linsert@2:
  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert@2:

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00046	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0004a	74 d6		 je	 SHORT $LL12@Linsert@2
$LN11@Linsert@2:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  0004c	8b de		 mov	 ebx, esi
  0004e	89 5d 10	 mov	 DWORD PTR __Where$152128[ebp], ebx

; 970  : 			if (!_Addleft)

  00051	84 c9		 test	 cl, cl
  00053	74 35		 je	 SHORT $LN99@Linsert@2

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00055	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00058	8d 4d 10	 lea	 ecx, DWORD PTR $T180638[ebp]
  0005b	3b 30		 cmp	 esi, DWORD PTR [eax]
  0005d	75 20		 jne	 SHORT $LN4@Linsert@2
  0005f	52		 push	 edx
  00060	56		 push	 esi
  00061	6a 01		 push	 1
  00063	51		 push	 ecx
  00064	8b cf		 mov	 ecx, edi
  00066	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  0006b	8b 10		 mov	 edx, DWORD PTR [eax]
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	89 10		 mov	 DWORD PTR [eax], edx
  00074	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  00078	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@Linsert@2:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  0007f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--
  00084	8b 5d 10	 mov	 ebx, DWORD PTR __Where$152128[ebp]
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert@2:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  0008a	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0008d	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  00090	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00093	73 25		 jae	 SHORT $LN2@Linsert@2

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  00095	52		 push	 edx
  00096	8b 55 fc	 mov	 edx, DWORD PTR __Addleft$[ebp]
  00099	56		 push	 esi
  0009a	52		 push	 edx
  0009b	8d 45 10	 lea	 eax, DWORD PTR $T180640[ebp]
  0009e	50		 push	 eax
  0009f	8b cf		 mov	 ecx, edi
  000a1	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000b3	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Linsert@2:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  000ba	50		 push	 eax
  000bb	83 c7 0d	 add	 edi, 13			; 0000000dH
  000be	57		 push	 edi
  000bf	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@std@@U?$pair@$$CBKVTokenizerRow@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@0@PAU?$pair@$$CBKVTokenizerRow@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerRow> >,std::pair<unsigned long const ,TokenizerRow> >

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000c4	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000cd	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	89 18		 mov	 DWORD PTR [eax], ebx
  000d7	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000db	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	51		 push	 ecx
  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001a	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1419 : 		this->_Mysize = 0;

  00022	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00029	5e		 pop	 esi

; 1420 : 		}

  0002a	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1516 : 		{	// copy entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d e8	 mov	 DWORD PTR _this$[ebp], ebx

; 1517 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1518 : 
; 1519 : 		if (!this->_Isnil(_Rootnode))

  00030	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00033	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  00037	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0003a	89 45 ec	 mov	 DWORD PTR __Newroot$[ebp], eax
  0003d	75 48		 jne	 SHORT $LN8@Copy@4

; 1520 : 			{	// copy a node, then any subtrees
; 1521 : 			_Nodeptr _Pnode = this->_Buynode(this->_Myval(_Rootnode));

  0003f	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00042	51		 push	 ecx
  00043	8b cb		 mov	 ecx, ebx
  00045	e8 00 00 00 00	 call	 ??$_Buynode@AAU?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@AAU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> &>

; 1522 : 			_Pnode->_Parent = _Wherenode;

  0004a	8b 55 0c	 mov	 edx, DWORD PTR __Wherenode$[ebp]

; 1523 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1524 : 			if (this->_Isnil(_Newroot))

  0004d	8b 4d ec	 mov	 ecx, DWORD PTR __Newroot$[ebp]
  00050	8b f0		 mov	 esi, eax
  00052	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00055	8a 47 24	 mov	 al, BYTE PTR [edi+36]
  00058	88 46 24	 mov	 BYTE PTR [esi+36], al
  0005b	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0005f	74 03		 je	 SHORT $LN2@Copy@4

; 1525 : 				_Newroot = _Pnode;	// memorize new root

  00061	89 75 ec	 mov	 DWORD PTR __Newroot$[ebp], esi
$LN2@Copy@4:

; 1526 : 
; 1527 : 			_TRY_BEGIN
; 1528 : 			this->_Left(_Pnode) = _Copy(this->_Left(_Rootnode), _Pnode);

  00064	8b 17		 mov	 edx, DWORD PTR [edi]
  00066	56		 push	 esi
  00067	52		 push	 edx
  00068	8b cb		 mov	 ecx, ebx
  0006a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00071	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
  00076	89 06		 mov	 DWORD PTR [esi], eax

; 1529 : 			this->_Right(_Pnode) = _Copy(this->_Right(_Rootnode), _Pnode);

  00078	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0007b	56		 push	 esi
  0007c	50		 push	 eax
  0007d	8b cb		 mov	 ecx, ebx
  0007f	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
  00084	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN8@Copy@4:

; 1533 : 			_CATCH_END
; 1534 : 			}
; 1535 : 
; 1536 : 		return (_Newroot);	// return newly constructed tree

  00087	8b 45 ec	 mov	 eax, DWORD PTR __Newroot$[ebp]

; 1537 : 		}

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00094	59		 pop	 ecx
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z$0:

; 1530 : 			_CATCH_ALL
; 1531 : 			_Erase(_Newroot);	// subtree copy failed, bail out

  0009e	8b 4d ec	 mov	 ecx, DWORD PTR __Newroot$[ebp]
  000a1	51		 push	 ecx
  000a2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase

; 1532 : 			_RERAISE;

  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@Copy@4:
$LN28@Copy@4:
  000b3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
; Function compile flags: /Ogtp
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
$T181034 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Node$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1089 : 		{	// try to insert node at _Node using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1090 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1091 : 		if (_Where._Getcont() != this)
; 1092 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1093 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1094 : 
; 1095 : 		const value_type& _Val = this->_Myval(_Node);
; 1096 : 
; 1097 : 		const_iterator _Next;
; 1098 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1099 : 
; 1100 : 		if (size() == 0)

  00009	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0

; 1101 : 			return (_Insert(true, this->_Myhead, _Node));	// empty tree

  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	57		 push	 edi
  00011	8b 7d 10	 mov	 edi, DWORD PTR __Node$[ebp]
  00014	75 17		 jne	 SHORT $LN33@Insert@4
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	50		 push	 eax
  0001b	6a 01		 push	 1
  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  00023	8b c7		 mov	 eax, edi
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 1181 : 		}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
$LN33@Insert@4:
  0002d	53		 push	 ebx

; 1102 : 		else if (this->_Multi)
; 1103 : 			{	// insert even if duplicate
; 1104 : 			if (_Where == begin())
; 1105 : 				{	// insert at beginning if before first element
; 1106 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1107 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1108 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1109 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1110 : 				}
; 1111 : 			else if (_Where == end())
; 1112 : 				{	// insert at end if after last element
; 1113 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1114 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1115 : 					return (_Insert(false, _Rmost(), _Node));
; 1116 : 				}
; 1117 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1118 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1119 : 				&& !_DEBUG_LT_PRED(this->comp,
; 1120 : 					this->_Kfn(_Val),
; 1121 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1122 : 				{	// insert before _Where
; 1123 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1124 : 					return (_Insert(false, _Next._Mynode(), _Node));
; 1125 : 				else
; 1126 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1127 : 				}
; 1128 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1129 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1130 : 				&& (++(_Next = _Where) == end()
; 1131 : 					|| !_DEBUG_LT_PRED(this->comp,
; 1132 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1133 : 				{	// insert after _Where
; 1134 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1135 : 					return (_Insert(false, _Where._Mynode(), _Node));
; 1136 : 				else
; 1137 : 					return (_Insert(true, _Next._Mynode(), _Node));
; 1138 : 				}
; 1139 : 			else
; 1140 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1141 : 			}
; 1142 : 		else
; 1143 : 			{	// insert only if unique
; 1144 : 			if (_Where == begin())

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  00031	3b 18		 cmp	 ebx, DWORD PTR [eax]
  00033	75 26		 jne	 SHORT $LN14@Insert@4

; 1145 : 				{	// insert at beginning if before first element
; 1146 : 				if (_DEBUG_LT_PRED(this->comp,

  00035	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00038	3b 4b 0c	 cmp	 ecx, DWORD PTR [ebx+12]
  0003b	0f 83 f4 00 00
	00		 jae	 $LN333@Insert@4

; 1147 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1148 : 					return (_Insert(true, _Where._Mynode(), _Node));

  00041	57		 push	 edi
  00042	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00045	53		 push	 ebx
  00046	6a 01		 push	 1
  00048	57		 push	 edi
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  00050	5b		 pop	 ebx
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 1181 : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
$LN14@Insert@4:

; 1149 : 				}
; 1150 : 			else if (_Where == end())

  0005b	3b d8		 cmp	 ebx, eax
  0005d	75 27		 jne	 SHORT $LN11@Insert@4

; 1151 : 				{	// insert at end if after last element
; 1152 : 				if (_DEBUG_LT_PRED(this->comp,

  0005f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00062	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00065	3b 57 0c	 cmp	 edx, DWORD PTR [edi+12]
  00068	0f 83 c7 00 00
	00		 jae	 $LN333@Insert@4

; 1153 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1154 : 					return (_Insert(false, _Rmost(), _Node));

  0006e	57		 push	 edi
  0006f	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00072	50		 push	 eax
  00073	6a 00		 push	 0
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  0007b	5b		 pop	 ebx
  0007c	8b c7		 mov	 eax, edi
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 1181 : 		}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 0c 00	 ret	 12			; 0000000cH
$LN11@Insert@4:

; 1155 : 				}
; 1156 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1157 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1158 : 				&& _DEBUG_LT_PRED(this->comp,

  00086	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00089	3b 43 0c	 cmp	 eax, DWORD PTR [ebx+12]
  0008c	73 4d		 jae	 SHORT $LN332@Insert@4
  0008e	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  00091	89 5d 10	 mov	 DWORD PTR __Next$[ebp], ebx
  00094	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator--
  00099	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  0009c	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0009f	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  000a2	73 37		 jae	 SHORT $LN332@Insert@4

; 1159 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1160 : 					this->_Kfn(_Val)))
; 1161 : 				{	// insert before _Where
; 1162 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  000a4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a7	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0

; 1163 : 					return (_Insert(false, _Next._Mynode(), _Node));

  000ab	57		 push	 edi
  000ac	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  000af	8b ce		 mov	 ecx, esi
  000b1	74 14		 je	 SHORT $LN7@Insert@4
  000b3	50		 push	 eax
  000b4	6a 00		 push	 0
  000b6	57		 push	 edi
  000b7	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  000bc	5b		 pop	 ebx
  000bd	8b c7		 mov	 eax, edi
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi

; 1181 : 		}

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH
$LN7@Insert@4:

; 1164 : 				else
; 1165 : 					return (_Insert(true, _Where._Mynode(), _Node));

  000c7	53		 push	 ebx
  000c8	6a 01		 push	 1
  000ca	57		 push	 edi
  000cb	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  000d0	5b		 pop	 ebx
  000d1	8b c7		 mov	 eax, edi
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi

; 1181 : 		}

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 0c 00	 ret	 12			; 0000000cH
$LN332@Insert@4:

; 1166 : 				}
; 1167 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1168 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1169 : 				&& (++(_Next = _Where) == end()
; 1170 : 					|| _DEBUG_LT_PRED(this->comp,

  000db	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000de	39 43 0c	 cmp	 DWORD PTR [ebx+12], eax
  000e1	73 52		 jae	 SHORT $LN333@Insert@4
  000e3	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  000e6	89 5d 10	 mov	 DWORD PTR __Next$[ebp], ebx
  000e9	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >,std::_Iterator_base0>::operator++
  000ee	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  000f1	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000f4	74 08		 je	 SHORT $LN3@Insert@4
  000f6	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000f9	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000fc	73 37		 jae	 SHORT $LN333@Insert@4
$LN3@Insert@4:

; 1171 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1172 : 				{	// insert after _Where
; 1173 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  000fe	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00101	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0

; 1174 : 					return (_Insert(false, _Where._Mynode(), _Node));

  00105	57		 push	 edi
  00106	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00109	8b ce		 mov	 ecx, esi
  0010b	74 14		 je	 SHORT $LN2@Insert@4
  0010d	53		 push	 ebx
  0010e	6a 00		 push	 0
  00110	57		 push	 edi
  00111	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  00116	5b		 pop	 ebx
  00117	8b c7		 mov	 eax, edi
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi

; 1181 : 		}

  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Insert@4:

; 1175 : 				else
; 1176 : 					return (_Insert(true, _Next._Mynode(), _Node));

  00121	50		 push	 eax
  00122	6a 01		 push	 1
  00124	57		 push	 edi
  00125	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  0012a	5b		 pop	 ebx
  0012b	8b c7		 mov	 eax, edi
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi

; 1181 : 		}

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c2 0c 00	 ret	 12			; 0000000cH
$LN333@Insert@4:

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00135	6a 00		 push	 0
  00137	57		 push	 edi
  00138	8d 45 f8	 lea	 eax, DWORD PTR $T181034[ebp]
  0013b	50		 push	 eax
  0013c	8b ce		 mov	 ecx, esi
  0013e	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Linsert
  00143	8b 08		 mov	 ecx, DWORD PTR [eax]
  00145	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00148	5b		 pop	 ebx
  00149	5f		 pop	 edi
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
  0014c	5e		 pop	 esi

; 1181 : 		}

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::insert<std::pair<unsigned long const ,TokenizerRow> >
; Function compile flags: /Ogtp
;	COMDAT ??$insert@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
??$insert@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::insert<std::pair<unsigned long const ,TokenizerRow> >, COMDAT
; _this$ = ecx

; 760  : 		typename _STD tr1::enable_if<!_STD tr1::is_same<const_iterator,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 761  : 			typename _STD tr1::remove_reference<_Valty>::type>::value,
; 762  : 				iterator>::type
; 763  : 		insert(const_iterator _Where,
; 764  : 			_Valty&& _Val)
; 765  : 		{	// try to insert node with value _Val using _Where as a hint
; 766  : 		return (_Insert(_Where,
; 767  : 			this->_Buynode(_STD forward<_Valty>(_Val))));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> >
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00016	50		 push	 eax
  00017	51		 push	 ecx
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  00020	8b c7		 mov	 eax, edi
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 768  : 		}

  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??$insert@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::insert<std::pair<unsigned long const ,TokenizerRow> >
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T181691 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00012	75 38		 jne	 SHORT $LN115@erase@5
  00014	3b d0		 cmp	 edx, eax
  00016	75 34		 jne	 SHORT $LN115@erase@5

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	50		 push	 eax
  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Erase
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 00		 mov	 DWORD PTR [eax], eax
  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1383 : 			return (begin());

  00034	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00037	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	89 10		 mov	 DWORD PTR [eax], edx
  00045	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 0c 00	 ret	 12			; 0000000cH
$LN115@erase@5:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0004c	3b ca		 cmp	 ecx, edx
  0004e	74 62		 je	 SHORT $LN1@erase@5
$LL2@erase@5:

; 1388 : 				erase(_First++);

  00050	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00054	8b d1		 mov	 edx, ecx
  00056	75 46		 jne	 SHORT $LN77@erase@5
  00058	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0005b	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0005f	75 1e		 jne	 SHORT $LN117@erase@5
  00061	8b c8		 mov	 ecx, eax
  00063	8b 01		 mov	 eax, DWORD PTR [ecx]
  00065	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00069	75 0f		 jne	 SHORT $LN91@erase@5
  0006b	eb 03 8d 49 00	 npad	 5
$LL92@erase@5:
  00070	8b c8		 mov	 ecx, eax
  00072	8b 01		 mov	 eax, DWORD PTR [ecx]
  00074	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00078	74 f6		 je	 SHORT $LL92@erase@5
$LN91@erase@5:
  0007a	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  0007d	eb 1f		 jmp	 SHORT $LN77@erase@5
$LN117@erase@5:
  0007f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00082	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00086	75 13		 jne	 SHORT $LN75@erase@5
$LL76@erase@5:
  00088	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0008b	75 0e		 jne	 SHORT $LN75@erase@5
  0008d	8b c8		 mov	 ecx, eax
  0008f	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  00092	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00095	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00099	74 ed		 je	 SHORT $LL76@erase@5
$LN75@erase@5:
  0009b	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
$LN77@erase@5:
  0009e	52		 push	 edx
  0009f	8d 45 fc	 lea	 eax, DWORD PTR $T181691[ebp]
  000a2	50		 push	 eax
  000a3	8b ce		 mov	 ecx, esi
  000a5	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  000ad	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  000b0	75 9e		 jne	 SHORT $LL2@erase@5
$LN1@erase@5:

; 1389 : 			return (iterator(_First._Ptr, this));

  000b2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b5	89 08		 mov	 DWORD PTR [eax], ecx
  000b7	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
; Function compile flags: /Ogtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1500 : 		{	// copy entire tree from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1501 : 		_Root() = _Copy(_Right._Root(), this->_Myhead);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b f1		 mov	 esi, ecx
  00011	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
  0001b	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1502 : 		this->_Mysize = _Right.size();

  0001e	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 1503 : 		if (!this->_Isnil(_Root()))

  00021	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00024	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00027	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002a	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0002e	75 38		 jne	 SHORT $LN2@Copy@5

; 1504 : 			{	// nonempty tree, look for new smallest and largest
; 1505 : 			_Lmost() = this->_Min(_Root());

  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00036	75 0a		 jne	 SHORT $LN25@Copy@5
$LL26@Copy@5:
  00038	8b c1		 mov	 eax, ecx
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00040	74 f6		 je	 SHORT $LL26@Copy@5
$LN25@Copy@5:
  00042	89 02		 mov	 DWORD PTR [edx], eax

; 1506 : 			_Rmost() = this->_Max(_Root());

  00044	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00047	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0004d	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00051	75 0b		 jne	 SHORT $LN43@Copy@5
$LL44@Copy@5:
  00053	8b c8		 mov	 ecx, eax
  00055	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00058	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0005c	74 f5		 je	 SHORT $LL44@Copy@5
$LN43@Copy@5:
  0005e	5f		 pop	 edi
  0005f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx

; 1512 : 			}
; 1513 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN2@Copy@5:

; 1507 : 			}
; 1508 : 		else
; 1509 : 			{	// empty tree, just tidy head pointers
; 1510 : 			_Lmost() = this->_Myhead;

  00068	89 12		 mov	 DWORD PTR [edx], edx

; 1511 : 			_Rmost() = this->_Myhead;

  0006a	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0006d	5f		 pop	 edi
  0006e	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx

; 1512 : 			}
; 1513 : 		}

  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@KVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::insert<std::pair<unsigned long,TokenizerRow> >
; Function compile flags: /Ogtp
;	COMDAT ??$insert@U?$pair@KVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
??$insert@U?$pair@KVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::insert<std::pair<unsigned long,TokenizerRow> >, COMDAT
; _this$ = ecx

; 760  : 		typename _STD tr1::enable_if<!_STD tr1::is_same<const_iterator,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 761  : 			typename _STD tr1::remove_reference<_Valty>::type>::value,
; 762  : 				iterator>::type
; 763  : 		insert(const_iterator _Where,
; 764  : 			_Valty&& _Val)
; 765  : 		{	// try to insert node with value _Val using _Where as a hint
; 766  : 		return (_Insert(_Where,
; 767  : 			this->_Buynode(_STD forward<_Valty>(_Val))));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long,TokenizerRow> >
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00016	50		 push	 eax
  00017	51		 push	 ecx
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  00020	8b c7		 mov	 eax, edi
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 768  : 		}

  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??$insert@U?$pair@KVTokenizerRow@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::insert<std::pair<unsigned long,TokenizerRow> >
_TEXT	ENDS
PUBLIC	??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$16
__ehfuncinfo$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	ENDS
;	COMDAT ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z
_TEXT	SEGMENT
$T182213 = -72						; size = 24
$T182214 = -48						; size = 20
$T182639 = -28						; size = 12
$T183029 = -16						; size = 4
$T182445 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T183284 = 8						; size = 4
$T182972 = 8						; size = 4
$T182216 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z PROC ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[], COMDAT
; _this$ = ecx

; 210  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx

; 211  : 		iterator _Where = this->lower_bound(_Keyval);

  0002a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0002d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00030	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00034	75 1e		 jne	 SHORT $LN11@operator@15

; 212  : 		if (_Where == this->end()
; 213  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00036	8b 4d 08	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003b	eb 03 8d 49 00	 npad	 5
$LL12@operator@15:

; 211  : 		iterator _Where = this->lower_bound(_Keyval);

  00040	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00043	73 05		 jae	 SHORT $LN10@operator@15
  00045	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00048	eb 04		 jmp	 SHORT $LN9@operator@15
$LN10@operator@15:
  0004a	8b f8		 mov	 edi, eax
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@operator@15:
  0004e	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00052	74 ec		 je	 SHORT $LL12@operator@15
$LN11@operator@15:

; 212  : 		if (_Where == this->end()
; 213  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00054	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00057	74 0e		 je	 SHORT $LN1@operator@15
  00059	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0005c	8b 02		 mov	 eax, DWORD PTR [edx]
  0005e	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  00061	0f 83 c4 00 00
	00		 jae	 $LN216@operator@15
$LN1@operator@15:

; 214  : 			_Where = this->insert(_Where,
; 215  : 				value_type(_Keyval, mapped_type()));

  00067	33 db		 xor	 ebx, ebx
  00069	6a 30		 push	 48			; 00000030H
  0006b	89 5d d8	 mov	 DWORD PTR $T182214[ebp+8], ebx
  0006e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00073	83 c4 04	 add	 esp, 4
  00076	3b c3		 cmp	 eax, ebx
  00078	0f 84 c4 00 00
	00		 je	 $LN90@operator@15
  0007e	89 45 d4	 mov	 DWORD PTR $T182214[ebp+4], eax
  00081	89 00		 mov	 DWORD PTR [eax], eax
  00083	8b 45 d4	 mov	 eax, DWORD PTR $T182214[ebp+4]
  00086	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00089	8b 45 d4	 mov	 eax, DWORD PTR $T182214[ebp+4]
  0008c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0008f	8b 4d d4	 mov	 ecx, DWORD PTR $T182214[ebp+4]
  00092	b3 01		 mov	 bl, 1
  00094	88 59 2c	 mov	 BYTE PTR [ecx+44], bl
  00097	8b 55 d4	 mov	 edx, DWORD PTR $T182214[ebp+4]
  0009a	88 5a 2d	 mov	 BYTE PTR [edx+45], bl
  0009d	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8d 55 d0	 lea	 edx, DWORD PTR $T182214[ebp]
  000a5	89 4d b8	 mov	 DWORD PTR $T182213[ebp], ecx
  000a8	52		 push	 edx
  000a9	8d 4d bc	 lea	 ecx, DWORD PTR $T182213[ebp+4]
  000ac	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000b3	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  000b8	8b 45 e0	 mov	 eax, DWORD PTR $T182214[ebp+16]
  000bb	89 45 cc	 mov	 DWORD PTR $T182213[ebp+20], eax
  000be	8d 4d b8	 lea	 ecx, DWORD PTR $T182213[ebp]
  000c1	51		 push	 ecx
  000c2	8b ce		 mov	 ecx, esi
  000c4	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  000c7	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBKVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerRow> >
  000cc	50		 push	 eax
  000cd	57		 push	 edi
  000ce	8d 55 08	 lea	 edx, DWORD PTR $T182216[ebp]
  000d1	52		 push	 edx
  000d2	8b ce		 mov	 ecx, esi
  000d4	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  000d9	8b 7d 08	 mov	 edi, DWORD PTR $T182216[ebp]
  000dc	8d 45 bc	 lea	 eax, DWORD PTR $T182213[ebp+4]
  000df	89 45 08	 mov	 DWORD PTR $T182972[ebp], eax
  000e2	8b 45 c0	 mov	 eax, DWORD PTR $T182213[ebp+8]
  000e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e7	50		 push	 eax
  000e8	51		 push	 ecx
  000e9	8d 4d f0	 lea	 ecx, DWORD PTR $T183029[ebp]
  000ec	51		 push	 ecx
  000ed	8d 4d bc	 lea	 ecx, DWORD PTR $T182213[ebp+4]
  000f0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f4	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  000f9	8b 55 c0	 mov	 edx, DWORD PTR $T182213[ebp+8]
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00102	83 c4 04	 add	 esp, 4
  00105	8b 45 d4	 mov	 eax, DWORD PTR $T182214[ebp+4]
  00108	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010a	50		 push	 eax
  0010b	51		 push	 ecx
  0010c	8d 45 08	 lea	 eax, DWORD PTR $T183284[ebp]
  0010f	50		 push	 eax
  00110	8d 4d d0	 lea	 ecx, DWORD PTR $T182214[ebp]
  00113	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  0011a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  0011f	8b 4d d4	 mov	 ecx, DWORD PTR $T182214[ebp+4]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00128	83 c4 04	 add	 esp, 4
$LN216@operator@15:

; 216  : 		return ((*_Where).second);

  0012b	8d 47 10	 lea	 eax, DWORD PTR [edi+16]

; 217  : 		}

  0012e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00131	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00138	59		 pop	 ecx
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 04 00	 ret	 4

; 214  : 			_Where = this->insert(_Where,
; 215  : 				value_type(_Keyval, mapped_type()));

$LN90@operator@15:
  00142	8d 55 f0	 lea	 edx, DWORD PTR $T182445[ebp]
  00145	52		 push	 edx
  00146	8d 4d e4	 lea	 ecx, DWORD PTR $T182639[ebp]
  00149	89 5d f0	 mov	 DWORD PTR $T182445[ebp], ebx
  0014c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00151	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00156	8d 45 e4	 lea	 eax, DWORD PTR $T182639[ebp]
  00159	50		 push	 eax
  0015a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T182639[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00161	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN229@operator@15:
$LN228@operator@15:
  00166	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR $T182214[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TokenizerRow@@QAE@XZ
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$1:
  00008	8d 4d b8	 lea	 ecx, DWORD PTR $T182213[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBKVTokenizerRow@@@std@@QAE@XZ
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$13:
  00010	8b 4d 08	 mov	 ecx, DWORD PTR $T182972[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z$16:
  00018	8d 4d d0	 lea	 ecx, DWORD PTR $T182214[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z:
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ENDP ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
PUBLIC	??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$16
__ehfuncinfo$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	ENDS
;	COMDAT ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z
_TEXT	SEGMENT
$T183344 = -72						; size = 24
$T183345 = -48						; size = 20
$T183775 = -28						; size = 12
$T184177 = -16						; size = 4
$T183580 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T184449 = 8						; size = 4
$T184119 = 8						; size = 4
$T183348 = 8						; size = 4
$T183346 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z PROC ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[], COMDAT
; _this$ = ecx

; 165  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx

; 166  : 		iterator _Where = this->lower_bound(_Keyval);

  0002a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0002d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00030	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00034	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00037	75 1b		 jne	 SHORT $LN11@operator@16
  00039	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0003b	eb 03 8d 49 00	 npad	 5
$LL12@operator@16:
  00040	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00043	73 05		 jae	 SHORT $LN10@operator@16
  00045	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00048	eb 04		 jmp	 SHORT $LN9@operator@16
$LN10@operator@16:
  0004a	8b f8		 mov	 edi, eax
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@operator@16:
  0004e	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00052	74 ec		 je	 SHORT $LL12@operator@16
$LN11@operator@16:

; 167  : 		if (_Where == this->end()
; 168  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00054	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00057	74 0b		 je	 SHORT $LN1@operator@16
  00059	8b 02		 mov	 eax, DWORD PTR [edx]
  0005b	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  0005e	0f 83 c7 00 00
	00		 jae	 $LN222@operator@16
$LN1@operator@16:

; 169  : 			_Where = this->insert(_Where,
; 170  : 				_STD pair<key_type, mapped_type>(
; 171  : 					_STD move(_Keyval),
; 172  : 					mapped_type()));

  00064	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00066	33 db		 xor	 ebx, ebx
  00068	6a 30		 push	 48			; 00000030H
  0006a	89 4d 08	 mov	 DWORD PTR $T183346[ebp], ecx
  0006d	89 5d d8	 mov	 DWORD PTR $T183345[ebp+8], ebx
  00070	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00075	83 c4 04	 add	 esp, 4
  00078	3b c3		 cmp	 eax, ebx
  0007a	0f 84 c2 00 00
	00		 je	 $LN92@operator@16
  00080	89 45 d4	 mov	 DWORD PTR $T183345[ebp+4], eax
  00083	89 00		 mov	 DWORD PTR [eax], eax
  00085	8b 45 d4	 mov	 eax, DWORD PTR $T183345[ebp+4]
  00088	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0008b	8b 45 d4	 mov	 eax, DWORD PTR $T183345[ebp+4]
  0008e	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00091	8b 55 d4	 mov	 edx, DWORD PTR $T183345[ebp+4]
  00094	b3 01		 mov	 bl, 1
  00096	88 5a 2c	 mov	 BYTE PTR [edx+44], bl
  00099	8b 45 d4	 mov	 eax, DWORD PTR $T183345[ebp+4]
  0009c	88 58 2d	 mov	 BYTE PTR [eax+45], bl
  0009f	8b 4d 08	 mov	 ecx, DWORD PTR $T183346[ebp]
  000a2	8d 55 d0	 lea	 edx, DWORD PTR $T183345[ebp]
  000a5	89 4d b8	 mov	 DWORD PTR $T183344[ebp], ecx
  000a8	52		 push	 edx
  000a9	8d 4d bc	 lea	 ecx, DWORD PTR $T183344[ebp+4]
  000ac	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000b3	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  000b8	8b 45 e0	 mov	 eax, DWORD PTR $T183345[ebp+16]
  000bb	89 45 cc	 mov	 DWORD PTR $T183344[ebp+20], eax
  000be	8d 4d b8	 lea	 ecx, DWORD PTR $T183344[ebp]
  000c1	51		 push	 ecx
  000c2	8b ce		 mov	 ecx, esi
  000c4	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  000c7	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@KVTokenizerRow@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@KVTokenizerRow@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Buynode<std::pair<unsigned long,TokenizerRow> >
  000cc	50		 push	 eax
  000cd	57		 push	 edi
  000ce	8d 55 08	 lea	 edx, DWORD PTR $T183348[ebp]
  000d1	52		 push	 edx
  000d2	8b ce		 mov	 ecx, esi
  000d4	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Insert
  000d9	8b 7d 08	 mov	 edi, DWORD PTR $T183348[ebp]
  000dc	8d 45 bc	 lea	 eax, DWORD PTR $T183344[ebp+4]
  000df	89 45 08	 mov	 DWORD PTR $T184119[ebp], eax
  000e2	8b 45 c0	 mov	 eax, DWORD PTR $T183344[ebp+8]
  000e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e7	50		 push	 eax
  000e8	51		 push	 ecx
  000e9	8d 4d f0	 lea	 ecx, DWORD PTR $T184177[ebp]
  000ec	51		 push	 ecx
  000ed	8d 4d bc	 lea	 ecx, DWORD PTR $T183344[ebp+4]
  000f0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f4	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  000f9	8b 55 c0	 mov	 edx, DWORD PTR $T183344[ebp+8]
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00102	83 c4 04	 add	 esp, 4
  00105	8b 45 d4	 mov	 eax, DWORD PTR $T183345[ebp+4]
  00108	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010a	50		 push	 eax
  0010b	51		 push	 ecx
  0010c	8d 45 08	 lea	 eax, DWORD PTR $T184449[ebp]
  0010f	50		 push	 eax
  00110	8d 4d d0	 lea	 ecx, DWORD PTR $T183345[ebp]
  00113	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  0011a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  0011f	8b 4d d4	 mov	 ecx, DWORD PTR $T183345[ebp+4]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00128	83 c4 04	 add	 esp, 4
$LN222@operator@16:

; 173  : 		return ((*_Where).second);

  0012b	8d 47 10	 lea	 eax, DWORD PTR [edi+16]

; 174  : 		}

  0012e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00131	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00138	59		 pop	 ecx
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 04 00	 ret	 4

; 169  : 			_Where = this->insert(_Where,
; 170  : 				_STD pair<key_type, mapped_type>(
; 171  : 					_STD move(_Keyval),
; 172  : 					mapped_type()));

$LN92@operator@16:
  00142	8d 55 f0	 lea	 edx, DWORD PTR $T183580[ebp]
  00145	52		 push	 edx
  00146	8d 4d e4	 lea	 ecx, DWORD PTR $T183775[ebp]
  00149	89 5d f0	 mov	 DWORD PTR $T183580[ebp], ebx
  0014c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00151	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00156	8d 45 e4	 lea	 eax, DWORD PTR $T183775[ebp]
  00159	50		 push	 eax
  0015a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T183775[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00161	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN234@operator@16:
$LN233@operator@16:
  00166	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR $T183345[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TokenizerRow@@QAE@XZ
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$1:
  00008	8d 4d b8	 lea	 ecx, DWORD PTR $T183344[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$pair@KVTokenizerRow@@@std@@QAE@XZ
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$13:
  00010	8b 4d 08	 mov	 ecx, DWORD PTR $T184119[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__unwindfunclet$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z$16:
  00018	8d 4d d0	 lea	 ecx, DWORD PTR $T183345[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__ehhandler$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z:
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z ENDP ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
PUBLIC	??4?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T184493 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::operator=, COMDAT
; _this$ = ecx

; 795  : 		{	// replace contents from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 796  : 		if (this != &_Right)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 1a		 je	 SHORT $LN28@operator@17

; 797  : 			{	// worth doing
; 798  : 			erase(begin(), end());

  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 45 08	 lea	 eax, DWORD PTR $T184493[ebp]
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase

; 799  : 			this->comp = _Right.comp;
; 800  : 			_Copy(_Right);

  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
$LN28@operator@17:

; 801  : 			}
; 802  : 		return (*this);

  00028	5f		 pop	 edi
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi

; 803  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??4?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::operator=
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T184586 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T184586[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase

; 1867 : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T184778 = -36						; size = 12
$T184719 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T184897 = 8						; size = 4
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >, COMDAT
; _this$ = ecx

; 715  : 		{	// construct tree by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00030	33 ff		 xor	 edi, edi
  00032	6a 28		 push	 40			; 00000028H
  00034	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00037	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b c7		 cmp	 eax, edi
  00041	74 62		 je	 SHORT $LN27@Tree@5
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00046	89 00		 mov	 DWORD PTR [eax], eax
  00048	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004b	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0004e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00051	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00054	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00057	b0 01		 mov	 al, 1
  00059	88 41 24	 mov	 BYTE PTR [ecx+36], al
  0005c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0005f	88 42 25	 mov	 BYTE PTR [edx+37], al
  00062	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi

; 716  : 		_TRY_BEGIN

  00065	88 45 fc	 mov	 BYTE PTR __$EHRec$[ebp+12], al

; 717  : 		_Copy(_Right);

  00068	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0006b	50		 push	 eax
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy

; 721  : 		_CATCH_END
; 722  : 		}

  00073	8b c6		 mov	 eax, esi
  00075	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00078	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007f	59		 pop	 ecx
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
__catch$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 718  : 		_CATCH_ALL
; 719  : 		_Tidy();

  00089	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0008f	8b 10		 mov	 edx, DWORD PTR [eax]
  00091	50		 push	 eax
  00092	52		 push	 edx
  00093	8d 55 08	 lea	 edx, DWORD PTR $T184897[ebp]
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase

; 720  : 		_RERAISE;

  0009c	33 ff		 xor	 edi, edi
  0009e	57		 push	 edi
  0009f	57		 push	 edi
  000a0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN78@Tree@5:

; 715  : 		{	// construct tree by copying _Right

$LN27@Tree@5:
  000a5	8d 45 e8	 lea	 eax, DWORD PTR $T184719[ebp]
  000a8	50		 push	 eax
  000a9	8d 4d dc	 lea	 ecx, DWORD PTR $T184778[ebp]
  000ac	89 7d e8	 mov	 DWORD PTR $T184719[ebp], edi
  000af	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000b4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000b9	8d 4d dc	 lea	 ecx, DWORD PTR $T184778[ebp]
  000bc	51		 push	 ecx
  000bd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T184778[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000c4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN79@Tree@5:
$LN77@Tree@5:
  000c9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z$2:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
PUBLIC	??4?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAV01@ABV01@@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??4?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T185035 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator=, COMDAT
; _this$ = ecx

; 148  : 		{	// assign by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 149  : 		_Mybase::operator=(_Right);

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 1a		 je	 SHORT $LN30@operator@18
  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 45 08	 lea	 eax, DWORD PTR $T185035[ebp]
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
$LN30@operator@18:

; 150  : 		return (*this);

  00028	5f		 pop	 edi
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi

; 151  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??4?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T185161 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 791  : 		_Tidy();

  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T185161[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase

; 792  : 		}

  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
PUBLIC	??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@ABV01@@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@ABV01@@Z PROC ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >, COMDAT
; _this$ = ecx

; 111  : 		{	// construct map by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >

; 112  : 		}

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@ABV01@@Z ENDP ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >
_TEXT	ENDS
PUBLIC	??4TokenizerSection@@QAEAAV0@ABV0@@Z		; TokenizerSection::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4TokenizerSection@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
$T185339 = 8						; size = 4
___that$ = 8						; size = 4
??4TokenizerSection@@QAEAAV0@ABV0@@Z PROC		; TokenizerSection::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 1a		 je	 SHORT $LN5@operator@19
  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 45 08	 lea	 eax, DWORD PTR $T185339[ebp]
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
$LN5@operator@19:
  00028	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0002b	5f		 pop	 edi
  0002c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??4TokenizerSection@@QAEAAV0@ABV0@@Z ENDP		; TokenizerSection::operator=
_TEXT	ENDS
PUBLIC	??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::~map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T185507 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::~map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T185507[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::~map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >
PUBLIC	??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T185690 = -16						; size = 12
$T185589 = -4						; size = 4
??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN25@map@2
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 107  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0

; 106  : 		{	// construct empty map from defaults

$LN25@map@2:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T185589[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T185690[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T185589[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T185690[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T185690[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@map@2:
$LN48@map@2:
  0006c	cc		 int	 3
??0?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >
_TEXT	ENDS
PUBLIC	??0TokenizerSection@@QAE@ABV0@@Z		; TokenizerSection::TokenizerSection
; Function compile flags: /Ogtp
;	COMDAT ??0TokenizerSection@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0TokenizerSection@@QAE@ABV0@@Z PROC			; TokenizerSection::TokenizerSection, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  00010	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00013	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00016	5f		 pop	 edi
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??0TokenizerSection@@QAE@ABV0@@Z ENDP			; TokenizerSection::TokenizerSection
_TEXT	ENDS
PUBLIC	?GetSection@TokenizerGroup@@QAE_NKAAVTokenizerSection@@@Z ; TokenizerGroup::GetSection
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\tokenizer.h
;	COMDAT ?GetSection@TokenizerGroup@@QAE_NKAAVTokenizerSection@@@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
$T185956 = 8						; size = 4
_Index$ = 8						; size = 4
_section$ = 12						; size = 4
?GetSection@TokenizerGroup@@QAE_NKAAVTokenizerSection@@@Z PROC ; TokenizerGroup::GetSection, COMDAT
; _this$ = ecx

; 76   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 77   : 		std::map<DWORD, TokenizerSection>::iterator it = this->Sections.find(Index);

  00007	8d 45 08	 lea	 eax, DWORD PTR _Index$[ebp]
  0000a	50		 push	 eax
  0000b	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  0000e	51		 push	 ecx
  0000f	8b ce		 mov	 ecx, esi
  00011	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::find

; 78   : 		if(it == this->Sections.end())

  00016	8b 45 fc	 mov	 eax, DWORD PTR _it$[ebp]
  00019	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0001c	75 09		 jne	 SHORT $LN2@GetSection

; 79   : 		{
; 80   : 			return false;

  0001e	32 c0		 xor	 al, al
  00020	5e		 pop	 esi

; 86   : 		}
; 87   : 	}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN2@GetSection:

; 81   : 		}
; 82   : 		else
; 83   : 		{
; 84   : 			section = it->second;

  00027	8b 75 0c	 mov	 esi, DWORD PTR _section$[ebp]
  0002a	57		 push	 edi
  0002b	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0002e	3b f7		 cmp	 esi, edi
  00030	74 1a		 je	 SHORT $LN29@GetSection
  00032	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	50		 push	 eax
  00038	51		 push	 ecx
  00039	8d 55 08	 lea	 edx, DWORD PTR $T185956[ebp]
  0003c	52		 push	 edx
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00044	57		 push	 edi
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
$LN29@GetSection:
  0004c	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0004f	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00052	5f		 pop	 edi

; 85   : 			return true;

  00053	b0 01		 mov	 al, 1
  00055	5e		 pop	 esi

; 86   : 		}
; 87   : 	}

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
?GetSection@TokenizerGroup@@QAE_NKAAVTokenizerSection@@@Z ENDP ; TokenizerGroup::GetSection
_TEXT	ENDS
PUBLIC	??0TokenizerSection@@QAE@XZ			; TokenizerSection::TokenizerSection
; Function compile flags: /Ogtp
;	COMDAT ??0TokenizerSection@@QAE@XZ
_TEXT	SEGMENT
$T186180 = -16						; size = 12
$T186031 = -4						; size = 4
??0TokenizerSection@@QAE@XZ PROC			; TokenizerSection::TokenizerSection, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN28@TokenizerS
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al
  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN28@TokenizerS:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T186031[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T186180[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T186031[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T186180[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T186180[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN53@TokenizerS:
$LN52@TokenizerS:
  0006c	cc		 int	 3
??0TokenizerSection@@QAE@XZ ENDP			; TokenizerSection::TokenizerSection
_TEXT	ENDS
PUBLIC	??1TokenizerSection@@QAE@XZ			; TokenizerSection::~TokenizerSection
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TokenizerSection@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TokenizerSection@@QAE@XZ$2
__ehfuncinfo$??1TokenizerSection@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1TokenizerSection@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1TokenizerSection@@QAE@XZ
_TEXT	SEGMENT
$T186398 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TokenizerSection@@QAE@XZ PROC			; TokenizerSection::~TokenizerSection, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1TokenizerSection@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T186398[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TokenizerSection@@QAE@XZ$2:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??1TokenizerSection@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1TokenizerSection@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1TokenizerSection@@QAE@XZ ENDP			; TokenizerSection::~TokenizerSection
PUBLIC	??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ ; std::_Pair_base<unsigned long const ,TokenizerSection>::~_Pair_base<unsigned long const ,TokenizerSection>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ$3
__ehfuncinfo$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ
_TEXT	SEGMENT
$T186648 = -20						; size = 4
$T186680 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ PROC ; std::_Pair_base<unsigned long const ,TokenizerSection>::~_Pair_base<unsigned long const ,TokenizerSection>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00029	89 75 f0	 mov	 DWORD PTR $T186680[ebp], esi
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	8d 45 ec	 lea	 eax, DWORD PTR $T186648[ebp]
  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ$3:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T186680[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@XZ ENDP ; std::_Pair_base<unsigned long const ,TokenizerSection>::~_Pair_base<unsigned long const ,TokenizerSection>
PUBLIC	??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z ; std::_Pair_base<unsigned long const ,TokenizerSection>::_Pair_base<unsigned long const ,TokenizerSection>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z PROC ; std::_Pair_base<unsigned long const ,TokenizerSection>::_Pair_base<unsigned long const ,TokenizerSection>, COMDAT
; _this$ = ecx

; 150  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 151  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z ENDP ; std::_Pair_base<unsigned long const ,TokenizerSection>::_Pair_base<unsigned long const ,TokenizerSection>
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@$$QBK$$QAVTokenizerSection@@@Z ; std::_Pair_base<unsigned long const ,TokenizerSection>::_Pair_base<unsigned long const ,TokenizerSection>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@$$QBK$$QAVTokenizerSection@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@$$QBK$$QAVTokenizerSection@@@Z PROC ; std::_Pair_base<unsigned long const ,TokenizerSection>::_Pair_base<unsigned long const ,TokenizerSection>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 146  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$_Pair_base@$$CBKVTokenizerSection@@@std@@QAE@$$QBK$$QAVTokenizerSection@@@Z ENDP ; std::_Pair_base<unsigned long const ,TokenizerSection>::_Pair_base<unsigned long const ,TokenizerSection>
_TEXT	ENDS
PUBLIC	??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ	; std::pair<unsigned long const ,TokenizerSection>::~pair<unsigned long const ,TokenizerSection>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ$4
__ehfuncinfo$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ
_TEXT	SEGMENT
$T186996 = -20						; size = 4
$T186983 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ PROC	; std::pair<unsigned long const ,TokenizerSection>::~pair<unsigned long const ,TokenizerSection>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00029	89 75 f0	 mov	 DWORD PTR $T186983[ebp], esi
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	8d 45 ec	 lea	 eax, DWORD PTR $T186996[ebp]
  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ$4:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T186983[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ ENDP	; std::pair<unsigned long const ,TokenizerSection>::~pair<unsigned long const ,TokenizerSection>
PUBLIC	??0?$pair@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z ; std::pair<unsigned long const ,TokenizerSection>::pair<unsigned long const ,TokenizerSection>
; Function compile flags: /Ogtp
;	COMDAT ??0?$pair@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z PROC ; std::pair<unsigned long const ,TokenizerSection>::pair<unsigned long const ,TokenizerSection>, COMDAT
; _this$ = ecx

; 233  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Val2$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 0e		 mov	 DWORD PTR [esi], ecx
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  0001b	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001e	5f		 pop	 edi
  0001f	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 234  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$pair@$$CBKVTokenizerSection@@@std@@QAE@ABK$$QAVTokenizerSection@@@Z ENDP ; std::pair<unsigned long const ,TokenizerSection>::pair<unsigned long const ,TokenizerSection>
_TEXT	ENDS
PUBLIC	??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z ; std::pair<unsigned long const ,TokenizerSection>::`scalar deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z$4
__ehfuncinfo$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
$T187381 = -20						; size = 4
$T187323 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z PROC	; std::pair<unsigned long const ,TokenizerSection>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  0002c	89 75 f0	 mov	 DWORD PTR $T187323[ebp], esi
  0002f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	8d 45 ec	 lea	 eax, DWORD PTR $T187381[ebp]
  00039	50		 push	 eax
  0003a	8b ce		 mov	 ecx, esi
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00048	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00051	83 c4 04	 add	 esp, 4
  00054	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00058	74 09		 je	 SHORT $LN49@scalar@21
  0005a	57		 push	 edi
  0005b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00060	83 c4 04	 add	 esp, 4
$LN49@scalar@21:
  00063	8b c7		 mov	 eax, edi
  00065	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006f	59		 pop	 ecx
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z$4:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T187323[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$pair@$$CBKVTokenizerSection@@@std@@QAEPAXI@Z ENDP	; std::pair<unsigned long const ,TokenizerSection>::`scalar deleting destructor'
PUBLIC	??$?0$$CBKVTokenizerSection@@@?$pair@$$CBKVTokenizerSection@@@std@@QAE@$$QAU01@@Z ; std::pair<unsigned long const ,TokenizerSection>::pair<unsigned long const ,TokenizerSection><unsigned long const ,TokenizerSection>
; Function compile flags: /Ogtp
;	COMDAT ??$?0$$CBKVTokenizerSection@@@?$pair@$$CBKVTokenizerSection@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0$$CBKVTokenizerSection@@@?$pair@$$CBKVTokenizerSection@@@std@@QAE@$$QAU01@@Z PROC ; std::pair<unsigned long const ,TokenizerSection>::pair<unsigned long const ,TokenizerSection><unsigned long const ,TokenizerSection>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	57		 push	 edi
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	89 06		 mov	 DWORD PTR [esi], eax
  00016	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  0001b	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0001e	5f		 pop	 edi
  0001f	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 256  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??$?0$$CBKVTokenizerSection@@@?$pair@$$CBKVTokenizerSection@@@std@@QAE@$$QAU01@@Z ENDP ; std::pair<unsigned long const ,TokenizerSection>::pair<unsigned long const ,TokenizerSection><unsigned long const ,TokenizerSection>
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z ; std::_Destroy<std::pair<unsigned long const ,TokenizerSection> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z$4
__ehfuncinfo$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z
_TEXT	SEGMENT
$T187822 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T187719 = 8						; size = 4
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z PROC ; std::_Destroy<std::pair<unsigned long const ,TokenizerSection> >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 63   : 	_Ptr->~_Ty();

  00024	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00027	83 c6 04	 add	 esi, 4
  0002a	89 75 08	 mov	 DWORD PTR $T187719[ebp], esi
  0002d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	8d 45 f0	 lea	 eax, DWORD PTR $T187822[ebp]
  00037	50		 push	 eax
  00038	8b ce		 mov	 ecx, esi
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00046	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004f	83 c4 04	 add	 esp, 4

; 64   : 	}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z$4:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR $T187719[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Destroy@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@YAXPAU?$pair@$$CBKVTokenizerSection@@@0@@Z ENDP ; std::_Destroy<std::pair<unsigned long const ,TokenizerSection> >
PUBLIC	?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z$0
__ehfuncinfo$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z
_TEXT	SEGMENT
$T187865 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00025	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T187865[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN3@construct@6
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN3@construct@6:

; 203  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T187865[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@$$QAU32@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::construct
PUBLIC	?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::destroy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z$4
__ehfuncinfo$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z
_TEXT	SEGMENT
$T188353 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T188197 = 8						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z PROC ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 213  : 		_Destroy(_Ptr);

  00024	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00027	83 c6 04	 add	 esi, 4
  0002a	89 75 08	 mov	 DWORD PTR $T188197[ebp], esi
  0002d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	8d 45 f0	 lea	 eax, DWORD PTR $T188353[ebp]
  00037	50		 push	 eax
  00038	8b ce		 mov	 ecx, esi
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00046	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004f	83 c4 04	 add	 esp, 4

; 214  : 		}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z$4:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR $T188197[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?destroy@?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@QAEXPAU?$pair@$$CBKVTokenizerSection@@@2@@Z ENDP ; std::allocator<std::pair<unsigned long const ,TokenizerSection> >::destroy
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection>,std::pair<unsigned long const ,TokenizerSection> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z
_TEXT	SEGMENT
$T188480 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection>,std::pair<unsigned long const ,TokenizerSection> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T188480[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 c0		 test	 eax, eax
  00034	74 1b		 je	 SHORT $LN7@Cons_val@6
  00036	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  00039	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	56		 push	 esi
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  0004b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004e	89 57 10	 mov	 DWORD PTR [edi+16], edx
$LN7@Cons_val@6:

; 281  : 	}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T188480[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection>,std::pair<unsigned long const ,TokenizerSection> >
PUBLIC	??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerSection> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z
_TEXT	SEGMENT
$T188551 = -32						; size = 12
__Ptr$188555 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T188506 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerSection> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002d	6a 28		 push	 40			; 00000028H
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	8b f0		 mov	 esi, eax
  00036	33 c0		 xor	 eax, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	89 75 ec	 mov	 DWORD PTR __Ptr$188555[ebp], esi
  0003e	3b f0		 cmp	 esi, eax
  00040	74 57		 je	 SHORT $LN12@Buynode@9
  00042	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00045	89 0e		 mov	 DWORD PTR [esi], ecx
  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0004d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00050	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	66 89 46 24	 mov	 WORD PTR [esi+36], ax
  00057	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  0005a	52		 push	 edx
  0005b	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005e	50		 push	 eax
  0005f	83 c7 0d	 add	 edi, 13			; 0000000dH
  00062	57		 push	 edi
  00063	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00066	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection>,std::pair<unsigned long const ,TokenizerSection> >
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  0006e	8b c6		 mov	 eax, esi

; 599  : 		}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
__catch$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$188555[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4

; 595  : 		_RERAISE;

  00090	33 c0		 xor	 eax, eax
  00092	50		 push	 eax
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Buynode@9:

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@9:
  00099	8d 55 08	 lea	 edx, DWORD PTR $T188506[ebp]
  0009c	52		 push	 edx
  0009d	8d 4d e0	 lea	 ecx, DWORD PTR $T188551[ebp]
  000a0	89 45 08	 mov	 DWORD PTR $T188506[ebp], eax
  000a3	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ad	8d 45 e0	 lea	 eax, DWORD PTR $T188551[ebp]
  000b0	50		 push	 eax
  000b1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T188551[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Buynode@9:
$LN44@Buynode@9:
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerSection> >
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z$4
__ehfuncinfo$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z
_TEXT	SEGMENT
$T189068 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
$T188862 = 12						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 287  : 	_Alval.destroy(_Pdest);

  00024	8b 75 0c	 mov	 esi, DWORD PTR __Pdest$[ebp]
  00027	83 c6 04	 add	 esi, 4
  0002a	89 75 0c	 mov	 DWORD PTR $T188862[ebp], esi
  0002d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	8d 45 f0	 lea	 eax, DWORD PTR $T189068[ebp]
  00037	50		 push	 eax
  00038	8b ce		 mov	 ecx, esi
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00046	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004f	83 c4 04	 add	 esp, 4

; 288  : 	}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z$4:
  00000	8b 4d 0c	 mov	 ecx, DWORD PTR $T188862[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv797 = -12						; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	80 7b 25 00	 cmp	 BYTE PTR [ebx+37], 0
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00013	74 0a		 je	 SHORT $LN40@erase@6

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN297@erase@6:
$LN40@erase@6:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1207 : 		++_Where;	// save successor iterator for return

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00022	89 5d f8	 mov	 DWORD PTR __Erasednode$[ebp], ebx
  00025	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  0002a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002c	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00030	74 05		 je	 SHORT $LN39@erase@6

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00032	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00035	eb 17		 jmp	 SHORT $LN291@erase@6
$LN39@erase@6:
  00037	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0003a	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0003e	74 04		 je	 SHORT $LN37@erase@6

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00040	8b f9		 mov	 edi, ecx

; 1218 : 		else

  00042	eb 0a		 jmp	 SHORT $LN291@erase@6
$LN37@erase@6:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00047	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  0004a	3b c3		 cmp	 eax, ebx
  0004c	75 72		 jne	 SHORT $LN35@erase@6
$LN291@erase@6:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004e	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  00052	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00055	75 03		 jne	 SHORT $LN34@erase@6

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00057	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase@6:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00060	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00063	75 05		 jne	 SHORT $LN33@erase@6

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00065	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00068	eb 0b		 jmp	 SHORT $LN30@erase@6
$LN33@erase@6:
  0006a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0006c	75 04		 jne	 SHORT $LN31@erase@6

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006e	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  00070	eb 03		 jmp	 SHORT $LN30@erase@6
$LN31@erase@6:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  00072	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase@6:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	39 18		 cmp	 DWORD PTR [eax], ebx
  0007a	75 1b		 jne	 SHORT $LN29@erase@6

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007c	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  00080	74 04		 je	 SHORT $LN43@erase@6
  00082	8b c6		 mov	 eax, esi
  00084	eb 0c		 jmp	 SHORT $LN44@erase@6
$LN43@erase@6:
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Min
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c4 04	 add	 esp, 4
$LN44@erase@6:
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	89 02		 mov	 DWORD PTR [edx], eax
$LN29@erase@6:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  00097	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009a	89 4d f4	 mov	 DWORD PTR tv797[ebp], ecx
  0009d	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000a0	75 78		 jne	 SHORT $LN165@erase@6

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000a2	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  000a6	74 07		 je	 SHORT $LN45@erase@6
  000a8	8b c6		 mov	 eax, esi
  000aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000ad	eb 6b		 jmp	 SHORT $LN165@erase@6
$LN45@erase@6:

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Max
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR tv797[ebp]
  000b8	83 c4 04	 add	 esp, 4
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000be	eb 5a		 jmp	 SHORT $LN165@erase@6
$LN35@erase@6:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c0	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase@6

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f0		 mov	 esi, eax

; 1257 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase@6
$LN26@erase@6:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	75 03		 jne	 SHORT $LN24@erase@6

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase@6:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e1	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000e4	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000e7	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN25@erase@6:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f0	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000f3	75 05		 jne	 SHORT $LN23@erase@6

; 1271 : 				_Root() = _Pnode;	// link down from root

  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f8	eb 0e		 jmp	 SHORT $LN20@erase@6
$LN23@erase@6:
  000fa	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000fd	39 19		 cmp	 DWORD PTR [ecx], ebx
  000ff	75 04		 jne	 SHORT $LN21@erase@6

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00101	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  00103	eb 03		 jmp	 SHORT $LN20@erase@6
$LN21@erase@6:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  00105	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase@6:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00108	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0010b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  0010e	8a 53 24	 mov	 dl, BYTE PTR [ebx+36]
  00111	8a 48 24	 mov	 cl, BYTE PTR [eax+36]
  00114	88 50 24	 mov	 BYTE PTR [eax+36], dl
  00117	88 4b 24	 mov	 BYTE PTR [ebx+36], cl
$LN165@erase@6:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	b3 01		 mov	 bl, 1
  00122	38 58 24	 cmp	 BYTE PTR [eax+36], bl
  00125	0f 85 fa 00 00
	00		 jne	 $LN19@erase@6
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	3b 7a 04	 cmp	 edi, DWORD PTR [edx+4]
  00131	0f 84 eb 00 00
	00		 je	 $LN16@erase@6
$LL18@erase@6:
  00137	38 5f 24	 cmp	 BYTE PTR [edi+36], bl
  0013a	0f 85 e2 00 00
	00		 jne	 $LN16@erase@6

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00140	8b 06		 mov	 eax, DWORD PTR [esi]
  00142	3b f8		 cmp	 edi, eax
  00144	75 65		 jne	 SHORT $LN15@erase@6

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  00146	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  00149	80 78 24 00	 cmp	 BYTE PTR [eax+36], 0
  0014d	75 13		 jne	 SHORT $LN14@erase@6

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0014f	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  00152	56		 push	 esi
  00153	c6 46 24 00	 mov	 BYTE PTR [esi+36], 0
  00157	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN14@erase@6:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00162	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00166	75 74		 jne	 SHORT $LN294@erase@6

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00168	8b 10		 mov	 edx, DWORD PTR [eax]
  0016a	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  0016d	75 08		 jne	 SHORT $LN11@erase@6
  0016f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00172	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00175	74 61		 je	 SHORT $LN295@erase@6
$LN11@erase@6:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  00177	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017a	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  0017d	75 15		 jne	 SHORT $LN9@erase@6

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  00184	50		 push	 eax
  00185	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
  00189	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  0018e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN9@erase@6:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00194	8a 56 24	 mov	 dl, BYTE PTR [esi+36]
  00197	88 50 24	 mov	 BYTE PTR [eax+36], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0019a	88 5e 24	 mov	 BYTE PTR [esi+36], bl

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0019d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1323 : 						_Lrotate(_Fixnodeparent);

  001a0	56		 push	 esi
  001a1	88 58 24	 mov	 BYTE PTR [eax+36], bl
  001a4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001a9	eb 74		 jmp	 SHORT $LN296@erase@6
$LN15@erase@6:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001ab	80 78 24 00	 cmp	 BYTE PTR [eax+36], 0
  001af	75 12		 jne	 SHORT $LN7@erase@6

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001b1	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001b4	56		 push	 esi
  001b5	c6 46 24 00	 mov	 BYTE PTR [esi+36], 0
  001b9	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001be	8b 06		 mov	 eax, DWORD PTR [esi]
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN7@erase@6:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001c3	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001c7	75 13		 jne	 SHORT $LN294@erase@6

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001cc	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001cf	75 1e		 jne	 SHORT $LN4@erase@6
  001d1	8b 10		 mov	 edx, DWORD PTR [eax]
  001d3	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001d6	75 17		 jne	 SHORT $LN4@erase@6
$LN295@erase@6:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001d8	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
$LN294@erase@6:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001dc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1344 : 						_Fixnode = _Fixnodeparent;

  001df	8b fe		 mov	 edi, esi
  001e1	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001e4	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001e7	0f 85 4a ff ff
	ff		 jne	 $LL18@erase@6

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001ed	eb 33		 jmp	 SHORT $LN16@erase@6
$LN4@erase@6:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001ef	8b 10		 mov	 edx, DWORD PTR [eax]
  001f1	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001f4	75 15		 jne	 SHORT $LN2@erase@6

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001f9	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  001fc	50		 push	 eax
  001fd	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
  00201	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00206	8b 06		 mov	 eax, DWORD PTR [esi]
  00208	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN2@erase@6:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0020b	8a 56 24	 mov	 dl, BYTE PTR [esi+36]
  0020e	88 50 24	 mov	 BYTE PTR [eax+36], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00211	88 5e 24	 mov	 BYTE PTR [esi+36], bl

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00214	8b 00		 mov	 eax, DWORD PTR [eax]

; 1359 : 						_Rrotate(_Fixnodeparent);

  00216	56		 push	 esi
  00217	88 58 24	 mov	 BYTE PTR [eax+36], bl
  0021a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Rrotate
$LN296@erase@6:
  0021f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN16@erase@6:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00222	88 5f 24	 mov	 BYTE PTR [edi+36], bl
$LN19@erase@6:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00225	8b 55 f8	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00228	83 c2 0c	 add	 edx, 12			; 0000000cH
  0022b	52		 push	 edx
  0022c	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00235	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00241	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00244	83 c4 0c	 add	 esp, 12			; 0000000cH
  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
  00249	5b		 pop	 ebx
  0024a	85 c0		 test	 eax, eax
  0024c	74 04		 je	 SHORT $LN1@erase@6

; 1373 : 			--this->_Mysize;

  0024e	48		 dec	 eax
  0024f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase@6:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  00252	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00255	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00258	89 08		 mov	 DWORD PTR [eax], ecx

; 1376 : 		}

  0025a	8b e5		 mov	 esp, ebp
  0025c	5d		 pop	 ebp
  0025d	c2 08 00	 ret	 8
$LN293@erase@6:
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Erase
; Function compile flags: /Ogtp
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 2b		 jne	 SHORT $LN1@Erase@3
$LL3@Erase@3:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	50		 push	 eax
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  00020	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00023	51		 push	 ecx
  00024	8d 43 0d	 lea	 eax, DWORD PTR [ebx+13]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  0003a	8b fe		 mov	 edi, esi
  0003c	74 d5		 je	 SHORT $LL3@Erase@3
$LN1@Erase@3:
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
; Function compile flags: /Ogtp
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	3d a9 aa aa 0a	 cmp	 eax, 178956969		; 0aaaaaa9H
  0000e	72 23		 jb	 SHORT $LN17@Insert@5

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  00010	8b 75 14	 mov	 esi, DWORD PTR __Newnode$[ebp]
  00013	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00016	50		 push	 eax
  00017	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0002e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN377@Insert@5:
$LN17@Insert@5:

; 1640 : 			}
; 1641 : 		++this->_Mysize;
; 1642 : 		_Newnode->_Parent = _Wherenode;

  00033	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00036	40		 inc	 eax
  00037	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0003a	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0003d	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00040	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00043	32 db		 xor	 bl, bl
  00045	3b c2		 cmp	 eax, edx
  00047	75 10		 jne	 SHORT $LN16@Insert@5

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00049	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1647 : 			_Lmost() = _Newnode;

  0004c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004f	89 3a		 mov	 DWORD PTR [edx], edi

; 1648 : 			_Rmost() = _Newnode;

  00051	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00054	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00057	eb 20		 jmp	 SHORT $LN11@Insert@5
$LN16@Insert@5:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  00059	38 5d 0c	 cmp	 BYTE PTR __Addleft$[ebp], bl
  0005c	74 0d		 je	 SHORT $LN14@Insert@5

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  0005e	89 38		 mov	 DWORD PTR [eax], edi

; 1653 : 			if (_Wherenode == _Lmost())

  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	3b 02		 cmp	 eax, DWORD PTR [edx]
  00065	75 12		 jne	 SHORT $LN11@Insert@5

; 1654 : 				_Lmost() = _Newnode;

  00067	89 3a		 mov	 DWORD PTR [edx], edi

; 1655 : 			}
; 1656 : 		else

  00069	eb 0e		 jmp	 SHORT $LN11@Insert@5
$LN14@Insert@5:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  0006b	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 1659 : 			if (_Wherenode == _Rmost())

  0006e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00071	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00074	75 03		 jne	 SHORT $LN11@Insert@5

; 1660 : 				_Rmost() = _Newnode;

  00076	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN11@Insert@5:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00079	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007c	8b c7		 mov	 eax, edi
  0007e	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00081	0f 85 8f 01 00
	00		 jne	 $LN9@Insert@5
$LL10@Insert@5:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0008d	3b 16		 cmp	 edx, DWORD PTR [esi]
  0008f	0f 85 c1 00 00
	00		 jne	 $LN8@Insert@5

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00095	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00098	38 5e 24	 cmp	 BYTE PTR [esi+36], bl
  0009b	75 1c		 jne	 SHORT $LN7@Insert@5

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0009d	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  000a1	c6 46 24 01	 mov	 BYTE PTR [esi+36], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  000a5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a8	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000ab	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000ae	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1677 : 					}
; 1678 : 				else

  000b4	e9 51 01 00 00	 jmp	 $LN316@Insert@5
$LN7@Insert@5:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000b9	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  000bc	75 3a		 jne	 SHORT $LN111@Insert@5

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  000be	8b c2		 mov	 eax, edx

; 1683 : 						_Lrotate(_Pnode);

  000c0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000c3	8b 32		 mov	 esi, DWORD PTR [edx]
  000c5	89 70 08	 mov	 DWORD PTR [eax+8], esi
  000c8	8b 32		 mov	 esi, DWORD PTR [edx]
  000ca	38 5e 25	 cmp	 BYTE PTR [esi+37], bl
  000cd	75 03		 jne	 SHORT $LN110@Insert@5
  000cf	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN110@Insert@5:
  000d2	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d5	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000d8	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000db	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000de	75 05		 jne	 SHORT $LN109@Insert@5
  000e0	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000e3	eb 0e		 jmp	 SHORT $LN106@Insert@5
$LN109@Insert@5:
  000e5	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000e8	3b 06		 cmp	 eax, DWORD PTR [esi]
  000ea	75 04		 jne	 SHORT $LN107@Insert@5
  000ec	89 16		 mov	 DWORD PTR [esi], edx
  000ee	eb 03		 jmp	 SHORT $LN106@Insert@5
$LN107@Insert@5:
  000f0	89 56 08	 mov	 DWORD PTR [esi+8], edx
$LN106@Insert@5:
  000f3	89 02		 mov	 DWORD PTR [edx], eax
  000f5	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN111@Insert@5:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000f8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000fb	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000ff	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00102	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00105	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00108	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0010b	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0010e	8b 32		 mov	 esi, DWORD PTR [edx]
  00110	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00113	89 3a		 mov	 DWORD PTR [edx], edi
  00115	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00118	38 5f 25	 cmp	 BYTE PTR [edi+37], bl
  0011b	75 03		 jne	 SHORT $LN173@Insert@5
  0011d	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN173@Insert@5:
  00120	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00123	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00126	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00129	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  0012c	75 0b		 jne	 SHORT $LN172@Insert@5
  0012e	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00131	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00134	e9 cb 00 00 00	 jmp	 $LN376@Insert@5

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN172@Insert@5:
  00139	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0013c	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  0013f	75 0b		 jne	 SHORT $LN170@Insert@5
  00141	89 77 08	 mov	 DWORD PTR [edi+8], esi
  00144	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00147	e9 b8 00 00 00	 jmp	 $LN376@Insert@5

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN170@Insert@5:
  0014c	89 37		 mov	 DWORD PTR [edi], esi
  0014e	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00151	e9 ae 00 00 00	 jmp	 $LN376@Insert@5
$LN8@Insert@5:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  00156	8b 36		 mov	 esi, DWORD PTR [esi]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  00158	38 5e 24	 cmp	 BYTE PTR [esi+36], bl
  0015b	75 1c		 jne	 SHORT $LN3@Insert@5

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0015d	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  00161	c6 46 24 01	 mov	 BYTE PTR [esi+36], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  00165	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00168	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0016b	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  0016e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00171	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1703 : 					}
; 1704 : 				else

  00174	e9 91 00 00 00	 jmp	 $LN316@Insert@5
$LN3@Insert@5:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00179	3b 02		 cmp	 eax, DWORD PTR [edx]
  0017b	75 3c		 jne	 SHORT $LN253@Insert@5

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  0017d	8b c2		 mov	 eax, edx

; 1709 : 						_Rrotate(_Pnode);

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00184	89 30		 mov	 DWORD PTR [eax], esi
  00186	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00189	38 5e 25	 cmp	 BYTE PTR [esi+37], bl
  0018c	75 03		 jne	 SHORT $LN252@Insert@5
  0018e	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN252@Insert@5:
  00191	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00194	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00197	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0019a	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0019d	75 05		 jne	 SHORT $LN251@Insert@5
  0019f	89 56 04	 mov	 DWORD PTR [esi+4], edx
  001a2	eb 0f		 jmp	 SHORT $LN248@Insert@5
$LN251@Insert@5:
  001a4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001a7	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  001aa	75 05		 jne	 SHORT $LN249@Insert@5
  001ac	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001af	eb 02		 jmp	 SHORT $LN248@Insert@5
$LN249@Insert@5:
  001b1	89 16		 mov	 DWORD PTR [esi], edx
$LN248@Insert@5:
  001b3	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001b6	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN253@Insert@5:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  001b9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bc	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  001c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001c3	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001c6	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001c9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001cc	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001cf	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  001d2	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d4	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  001d7	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d9	38 5f 25	 cmp	 BYTE PTR [edi+37], bl
  001dc	75 03		 jne	 SHORT $LN315@Insert@5
  001de	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN315@Insert@5:
  001e1	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001e4	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001e7	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  001ea	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  001ed	75 05		 jne	 SHORT $LN314@Insert@5
  001ef	89 77 04	 mov	 DWORD PTR [edi+4], esi
  001f2	eb 0e		 jmp	 SHORT $LN311@Insert@5
$LN314@Insert@5:
  001f4	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001f7	3b 17		 cmp	 edx, DWORD PTR [edi]
  001f9	75 04		 jne	 SHORT $LN312@Insert@5
  001fb	89 37		 mov	 DWORD PTR [edi], esi
  001fd	eb 03		 jmp	 SHORT $LN311@Insert@5
$LN312@Insert@5:
  001ff	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN311@Insert@5:
  00202	89 16		 mov	 DWORD PTR [esi], edx
$LN376@Insert@5:
  00204	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00207	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN316@Insert@5:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  0020a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0020d	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00210	0f 84 71 fe ff
	ff		 je	 $LL10@Insert@5
$LN9@Insert@5:

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00216	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00219	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1720 : 		return (iterator(_Newnode, this));

  0021c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0021f	89 38		 mov	 DWORD PTR [eax], edi
  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	c6 41 24 01	 mov	 BYTE PTR [ecx+36], 1
  00227	5b		 pop	 ebx

; 1721 : 		}

  00228	5d		 pop	 ebp
  00229	c2 10 00	 ret	 16			; 00000010H
$LN375@Insert@5:
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	51		 push	 ecx
  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001a	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1419 : 		this->_Mysize = 0;

  00022	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00029	5e		 pop	 esi

; 1420 : 		}

  0002a	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Linsert
; Function compile flags: /Ogtp
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
$T190361 = 16						; size = 4
$T190359 = 16						; size = 4
__Where$152225 = 16					; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx

; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00012	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00016	8b f1		 mov	 esi, ecx
  00018	b1 01		 mov	 cl, 1
  0001a	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 2d		 jne	 SHORT $LN11@Linsert@3
  0001f	8b 5a 0c	 mov	 ebx, DWORD PTR [edx+12]
$LL12@Linsert@3:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Leftish$[ebp], 0
  00026	8b f0		 mov	 esi, eax
  00028	74 08		 je	 SHORT $LN10@Linsert@3

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0002a	39 58 0c	 cmp	 DWORD PTR [eax+12], ebx
  0002d	0f 93 c1	 setae	 cl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00030	eb 06		 jmp	 SHORT $LN145@Linsert@3
$LN10@Linsert@3:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00032	3b 58 0c	 cmp	 ebx, DWORD PTR [eax+12]
  00035	0f 92 c1	 setb	 cl
$LN145@Linsert@3:
  00038	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0003b	84 c9		 test	 cl, cl
  0003d	74 04		 je	 SHORT $LN15@Linsert@3
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 03		 jmp	 SHORT $LN16@Linsert@3
$LN15@Linsert@3:
  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert@3:

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00046	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0004a	74 d6		 je	 SHORT $LL12@Linsert@3
$LN11@Linsert@3:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  0004c	8b de		 mov	 ebx, esi
  0004e	89 5d 10	 mov	 DWORD PTR __Where$152225[ebp], ebx

; 970  : 			if (!_Addleft)

  00051	84 c9		 test	 cl, cl
  00053	74 35		 je	 SHORT $LN99@Linsert@3

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00055	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00058	8d 4d 10	 lea	 ecx, DWORD PTR $T190359[ebp]
  0005b	3b 30		 cmp	 esi, DWORD PTR [eax]
  0005d	75 20		 jne	 SHORT $LN4@Linsert@3
  0005f	52		 push	 edx
  00060	56		 push	 esi
  00061	6a 01		 push	 1
  00063	51		 push	 ecx
  00064	8b cf		 mov	 ecx, edi
  00066	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  0006b	8b 10		 mov	 edx, DWORD PTR [eax]
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	89 10		 mov	 DWORD PTR [eax], edx
  00074	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  00078	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@Linsert@3:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  0007f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--
  00084	8b 5d 10	 mov	 ebx, DWORD PTR __Where$152225[ebp]
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert@3:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  0008a	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0008d	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  00090	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00093	73 25		 jae	 SHORT $LN2@Linsert@3

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  00095	52		 push	 edx
  00096	8b 55 fc	 mov	 edx, DWORD PTR __Addleft$[ebp]
  00099	56		 push	 esi
  0009a	52		 push	 edx
  0009b	8d 45 10	 lea	 eax, DWORD PTR $T190361[ebp]
  0009e	50		 push	 eax
  0009f	8b cf		 mov	 ecx, edi
  000a1	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000b3	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Linsert@3:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  000ba	50		 push	 eax
  000bb	83 c7 0d	 add	 edi, 13			; 0000000dH
  000be	57		 push	 edi
  000bf	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@std@@U?$pair@$$CBKVTokenizerSection@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@0@PAU?$pair@$$CBKVTokenizerSection@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned long const ,TokenizerSection> >,std::pair<unsigned long const ,TokenizerSection> >

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000c4	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000cd	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	89 18		 mov	 DWORD PTR [eax], ebx
  000d7	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000db	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T190675 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00012	75 38		 jne	 SHORT $LN115@erase@7
  00014	3b d0		 cmp	 edx, eax
  00016	75 34		 jne	 SHORT $LN115@erase@7

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	50		 push	 eax
  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Erase
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 00		 mov	 DWORD PTR [eax], eax
  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1383 : 			return (begin());

  00034	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00037	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	89 10		 mov	 DWORD PTR [eax], edx
  00045	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 0c 00	 ret	 12			; 0000000cH
$LN115@erase@7:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0004c	3b ca		 cmp	 ecx, edx
  0004e	74 62		 je	 SHORT $LN1@erase@7
$LL2@erase@7:

; 1388 : 				erase(_First++);

  00050	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00054	8b d1		 mov	 edx, ecx
  00056	75 46		 jne	 SHORT $LN77@erase@7
  00058	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0005b	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0005f	75 1e		 jne	 SHORT $LN117@erase@7
  00061	8b c8		 mov	 ecx, eax
  00063	8b 01		 mov	 eax, DWORD PTR [ecx]
  00065	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00069	75 0f		 jne	 SHORT $LN91@erase@7
  0006b	eb 03 8d 49 00	 npad	 5
$LL92@erase@7:
  00070	8b c8		 mov	 ecx, eax
  00072	8b 01		 mov	 eax, DWORD PTR [ecx]
  00074	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00078	74 f6		 je	 SHORT $LL92@erase@7
$LN91@erase@7:
  0007a	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  0007d	eb 1f		 jmp	 SHORT $LN77@erase@7
$LN117@erase@7:
  0007f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00082	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00086	75 13		 jne	 SHORT $LN75@erase@7
$LL76@erase@7:
  00088	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0008b	75 0e		 jne	 SHORT $LN75@erase@7
  0008d	8b c8		 mov	 ecx, eax
  0008f	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  00092	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00095	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00099	74 ed		 je	 SHORT $LL76@erase@7
$LN75@erase@7:
  0009b	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
$LN77@erase@7:
  0009e	52		 push	 edx
  0009f	8d 45 fc	 lea	 eax, DWORD PTR $T190675[ebp]
  000a2	50		 push	 eax
  000a3	8b ce		 mov	 ecx, esi
  000a5	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  000ad	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  000b0	75 9e		 jne	 SHORT $LL2@erase@7
$LN1@erase@7:

; 1389 : 			return (iterator(_First._Ptr, this));

  000b2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b5	89 08		 mov	 DWORD PTR [eax], ecx
  000b7	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
; Function compile flags: /Ogtp
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
$T191066 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Node$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1089 : 		{	// try to insert node at _Node using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1090 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1091 : 		if (_Where._Getcont() != this)
; 1092 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1093 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1094 : 
; 1095 : 		const value_type& _Val = this->_Myval(_Node);
; 1096 : 
; 1097 : 		const_iterator _Next;
; 1098 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1099 : 
; 1100 : 		if (size() == 0)

  00009	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0

; 1101 : 			return (_Insert(true, this->_Myhead, _Node));	// empty tree

  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	57		 push	 edi
  00011	8b 7d 10	 mov	 edi, DWORD PTR __Node$[ebp]
  00014	75 17		 jne	 SHORT $LN33@Insert@6
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	50		 push	 eax
  0001b	6a 01		 push	 1
  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  00023	8b c7		 mov	 eax, edi
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 1181 : 		}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
$LN33@Insert@6:
  0002d	53		 push	 ebx

; 1102 : 		else if (this->_Multi)
; 1103 : 			{	// insert even if duplicate
; 1104 : 			if (_Where == begin())
; 1105 : 				{	// insert at beginning if before first element
; 1106 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1107 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1108 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1109 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1110 : 				}
; 1111 : 			else if (_Where == end())
; 1112 : 				{	// insert at end if after last element
; 1113 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1114 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1115 : 					return (_Insert(false, _Rmost(), _Node));
; 1116 : 				}
; 1117 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1118 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1119 : 				&& !_DEBUG_LT_PRED(this->comp,
; 1120 : 					this->_Kfn(_Val),
; 1121 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1122 : 				{	// insert before _Where
; 1123 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1124 : 					return (_Insert(false, _Next._Mynode(), _Node));
; 1125 : 				else
; 1126 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1127 : 				}
; 1128 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1129 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1130 : 				&& (++(_Next = _Where) == end()
; 1131 : 					|| !_DEBUG_LT_PRED(this->comp,
; 1132 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1133 : 				{	// insert after _Where
; 1134 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1135 : 					return (_Insert(false, _Where._Mynode(), _Node));
; 1136 : 				else
; 1137 : 					return (_Insert(true, _Next._Mynode(), _Node));
; 1138 : 				}
; 1139 : 			else
; 1140 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1141 : 			}
; 1142 : 		else
; 1143 : 			{	// insert only if unique
; 1144 : 			if (_Where == begin())

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  00031	3b 18		 cmp	 ebx, DWORD PTR [eax]
  00033	75 26		 jne	 SHORT $LN14@Insert@6

; 1145 : 				{	// insert at beginning if before first element
; 1146 : 				if (_DEBUG_LT_PRED(this->comp,

  00035	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00038	3b 4b 0c	 cmp	 ecx, DWORD PTR [ebx+12]
  0003b	0f 83 f4 00 00
	00		 jae	 $LN333@Insert@6

; 1147 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1148 : 					return (_Insert(true, _Where._Mynode(), _Node));

  00041	57		 push	 edi
  00042	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00045	53		 push	 ebx
  00046	6a 01		 push	 1
  00048	57		 push	 edi
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  00050	5b		 pop	 ebx
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 1181 : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
$LN14@Insert@6:

; 1149 : 				}
; 1150 : 			else if (_Where == end())

  0005b	3b d8		 cmp	 ebx, eax
  0005d	75 27		 jne	 SHORT $LN11@Insert@6

; 1151 : 				{	// insert at end if after last element
; 1152 : 				if (_DEBUG_LT_PRED(this->comp,

  0005f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00062	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00065	3b 57 0c	 cmp	 edx, DWORD PTR [edi+12]
  00068	0f 83 c7 00 00
	00		 jae	 $LN333@Insert@6

; 1153 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1154 : 					return (_Insert(false, _Rmost(), _Node));

  0006e	57		 push	 edi
  0006f	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00072	50		 push	 eax
  00073	6a 00		 push	 0
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  0007b	5b		 pop	 ebx
  0007c	8b c7		 mov	 eax, edi
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 1181 : 		}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 0c 00	 ret	 12			; 0000000cH
$LN11@Insert@6:

; 1155 : 				}
; 1156 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1157 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1158 : 				&& _DEBUG_LT_PRED(this->comp,

  00086	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00089	3b 43 0c	 cmp	 eax, DWORD PTR [ebx+12]
  0008c	73 4d		 jae	 SHORT $LN332@Insert@6
  0008e	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  00091	89 5d 10	 mov	 DWORD PTR __Next$[ebp], ebx
  00094	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator--
  00099	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  0009c	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0009f	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  000a2	73 37		 jae	 SHORT $LN332@Insert@6

; 1159 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1160 : 					this->_Kfn(_Val)))
; 1161 : 				{	// insert before _Where
; 1162 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  000a4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a7	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0

; 1163 : 					return (_Insert(false, _Next._Mynode(), _Node));

  000ab	57		 push	 edi
  000ac	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  000af	8b ce		 mov	 ecx, esi
  000b1	74 14		 je	 SHORT $LN7@Insert@6
  000b3	50		 push	 eax
  000b4	6a 00		 push	 0
  000b6	57		 push	 edi
  000b7	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  000bc	5b		 pop	 ebx
  000bd	8b c7		 mov	 eax, edi
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi

; 1181 : 		}

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH
$LN7@Insert@6:

; 1164 : 				else
; 1165 : 					return (_Insert(true, _Where._Mynode(), _Node));

  000c7	53		 push	 ebx
  000c8	6a 01		 push	 1
  000ca	57		 push	 edi
  000cb	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  000d0	5b		 pop	 ebx
  000d1	8b c7		 mov	 eax, edi
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi

; 1181 : 		}

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 0c 00	 ret	 12			; 0000000cH
$LN332@Insert@6:

; 1166 : 				}
; 1167 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1168 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1169 : 				&& (++(_Next = _Where) == end()
; 1170 : 					|| _DEBUG_LT_PRED(this->comp,

  000db	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000de	39 43 0c	 cmp	 DWORD PTR [ebx+12], eax
  000e1	73 52		 jae	 SHORT $LN333@Insert@6
  000e3	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  000e6	89 5d 10	 mov	 DWORD PTR __Next$[ebp], ebx
  000e9	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >,std::_Iterator_base0>::operator++
  000ee	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  000f1	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000f4	74 08		 je	 SHORT $LN3@Insert@6
  000f6	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000f9	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000fc	73 37		 jae	 SHORT $LN333@Insert@6
$LN3@Insert@6:

; 1171 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1172 : 				{	// insert after _Where
; 1173 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  000fe	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00101	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0

; 1174 : 					return (_Insert(false, _Where._Mynode(), _Node));

  00105	57		 push	 edi
  00106	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00109	8b ce		 mov	 ecx, esi
  0010b	74 14		 je	 SHORT $LN2@Insert@6
  0010d	53		 push	 ebx
  0010e	6a 00		 push	 0
  00110	57		 push	 edi
  00111	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  00116	5b		 pop	 ebx
  00117	8b c7		 mov	 eax, edi
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi

; 1181 : 		}

  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Insert@6:

; 1175 : 				else
; 1176 : 					return (_Insert(true, _Next._Mynode(), _Node));

  00121	50		 push	 eax
  00122	6a 01		 push	 1
  00124	57		 push	 edi
  00125	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  0012a	5b		 pop	 ebx
  0012b	8b c7		 mov	 eax, edi
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi

; 1181 : 		}

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c2 0c 00	 ret	 12			; 0000000cH
$LN333@Insert@6:

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00135	6a 00		 push	 0
  00137	57		 push	 edi
  00138	8d 45 f8	 lea	 eax, DWORD PTR $T191066[ebp]
  0013b	50		 push	 eax
  0013c	8b ce		 mov	 ecx, esi
  0013e	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Linsert
  00143	8b 08		 mov	 ecx, DWORD PTR [eax]
  00145	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00148	5b		 pop	 ebx
  00149	5f		 pop	 edi
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
  0014c	5e		 pop	 esi

; 1181 : 		}

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T191719 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T191719[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase

; 1867 : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::insert<std::pair<unsigned long const ,TokenizerSection> >
; Function compile flags: /Ogtp
;	COMDAT ??$insert@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
??$insert@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::insert<std::pair<unsigned long const ,TokenizerSection> >, COMDAT
; _this$ = ecx

; 760  : 		typename _STD tr1::enable_if<!_STD tr1::is_same<const_iterator,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 761  : 			typename _STD tr1::remove_reference<_Valty>::type>::value,
; 762  : 				iterator>::type
; 763  : 		insert(const_iterator _Where,
; 764  : 			_Valty&& _Val)
; 765  : 		{	// try to insert node with value _Val using _Where as a hint
; 766  : 		return (_Insert(_Where,
; 767  : 			this->_Buynode(_STD forward<_Valty>(_Val))));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerSection> >
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00016	50		 push	 eax
  00017	51		 push	 ecx
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  00020	8b c7		 mov	 eax, edi
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 768  : 		}

  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??$insert@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::insert<std::pair<unsigned long const ,TokenizerSection> >
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T191909 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 791  : 		_Tidy();

  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T191909[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase

; 792  : 		}

  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
PUBLIC	??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::operator[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$16
__ehfuncinfo$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
xdata$x	ENDS
;	COMDAT ??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z
_TEXT	SEGMENT
$T191953 = -72						; size = 24
$T191954 = -48						; size = 20
$T192382 = -28						; size = 12
$T192776 = -16						; size = 4
$T192185 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T193024 = 8						; size = 4
$T192712 = 8						; size = 4
$T191956 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z PROC ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::operator[], COMDAT
; _this$ = ecx

; 210  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx

; 211  : 		iterator _Where = this->lower_bound(_Keyval);

  0002a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0002d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00030	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00034	75 1e		 jne	 SHORT $LN11@operator@20

; 212  : 		if (_Where == this->end()
; 213  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00036	8b 4d 08	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003b	eb 03 8d 49 00	 npad	 5
$LL12@operator@20:

; 211  : 		iterator _Where = this->lower_bound(_Keyval);

  00040	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00043	73 05		 jae	 SHORT $LN10@operator@20
  00045	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00048	eb 04		 jmp	 SHORT $LN9@operator@20
$LN10@operator@20:
  0004a	8b f8		 mov	 edi, eax
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@operator@20:
  0004e	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00052	74 ec		 je	 SHORT $LL12@operator@20
$LN11@operator@20:

; 212  : 		if (_Where == this->end()
; 213  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00054	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00057	74 0e		 je	 SHORT $LN1@operator@20
  00059	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0005c	8b 02		 mov	 eax, DWORD PTR [edx]
  0005e	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  00061	0f 83 c4 00 00
	00		 jae	 $LN216@operator@20
$LN1@operator@20:

; 214  : 			_Where = this->insert(_Where,
; 215  : 				value_type(_Keyval, mapped_type()));

  00067	33 db		 xor	 ebx, ebx
  00069	6a 28		 push	 40			; 00000028H
  0006b	89 5d d8	 mov	 DWORD PTR $T191954[ebp+8], ebx
  0006e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00073	83 c4 04	 add	 esp, 4
  00076	3b c3		 cmp	 eax, ebx
  00078	0f 84 c4 00 00
	00		 je	 $LN90@operator@20
  0007e	89 45 d4	 mov	 DWORD PTR $T191954[ebp+4], eax
  00081	89 00		 mov	 DWORD PTR [eax], eax
  00083	8b 45 d4	 mov	 eax, DWORD PTR $T191954[ebp+4]
  00086	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00089	8b 45 d4	 mov	 eax, DWORD PTR $T191954[ebp+4]
  0008c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0008f	8b 4d d4	 mov	 ecx, DWORD PTR $T191954[ebp+4]
  00092	b3 01		 mov	 bl, 1
  00094	88 59 24	 mov	 BYTE PTR [ecx+36], bl
  00097	8b 55 d4	 mov	 edx, DWORD PTR $T191954[ebp+4]
  0009a	88 5a 25	 mov	 BYTE PTR [edx+37], bl
  0009d	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8d 55 d0	 lea	 edx, DWORD PTR $T191954[ebp]
  000a5	89 4d b8	 mov	 DWORD PTR $T191953[ebp], ecx
  000a8	52		 push	 edx
  000a9	8d 4d bc	 lea	 ecx, DWORD PTR $T191953[ebp+4]
  000ac	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000b3	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
  000b8	8b 45 e0	 mov	 eax, DWORD PTR $T191954[ebp+16]
  000bb	89 45 cc	 mov	 DWORD PTR $T191953[ebp+20], eax
  000be	8d 4d b8	 lea	 ecx, DWORD PTR $T191953[ebp]
  000c1	51		 push	 ecx
  000c2	8b ce		 mov	 ecx, esi
  000c4	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  000c7	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBKVTokenizerSection@@@std@@@?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBKVTokenizerSection@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Buynode<std::pair<unsigned long const ,TokenizerSection> >
  000cc	50		 push	 eax
  000cd	57		 push	 edi
  000ce	8d 55 08	 lea	 edx, DWORD PTR $T191956[ebp]
  000d1	52		 push	 edx
  000d2	8b ce		 mov	 ecx, esi
  000d4	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::_Insert
  000d9	8b 7d 08	 mov	 edi, DWORD PTR $T191956[ebp]
  000dc	8d 45 bc	 lea	 eax, DWORD PTR $T191953[ebp+4]
  000df	89 45 08	 mov	 DWORD PTR $T192712[ebp], eax
  000e2	8b 45 c0	 mov	 eax, DWORD PTR $T191953[ebp+8]
  000e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e7	50		 push	 eax
  000e8	51		 push	 ecx
  000e9	8d 4d f0	 lea	 ecx, DWORD PTR $T192776[ebp]
  000ec	51		 push	 ecx
  000ed	8d 4d bc	 lea	 ecx, DWORD PTR $T191953[ebp+4]
  000f0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f4	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  000f9	8b 55 c0	 mov	 edx, DWORD PTR $T191953[ebp+8]
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00102	83 c4 04	 add	 esp, 4
  00105	8b 45 d4	 mov	 eax, DWORD PTR $T191954[ebp+4]
  00108	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010a	50		 push	 eax
  0010b	51		 push	 ecx
  0010c	8d 45 08	 lea	 eax, DWORD PTR $T193024[ebp]
  0010f	50		 push	 eax
  00110	8d 4d d0	 lea	 ecx, DWORD PTR $T191954[ebp]
  00113	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  0011a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  0011f	8b 4d d4	 mov	 ecx, DWORD PTR $T191954[ebp+4]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00128	83 c4 04	 add	 esp, 4
$LN216@operator@20:

; 216  : 		return ((*_Where).second);

  0012b	8d 47 10	 lea	 eax, DWORD PTR [edi+16]

; 217  : 		}

  0012e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00131	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00138	59		 pop	 ecx
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 04 00	 ret	 4

; 214  : 			_Where = this->insert(_Where,
; 215  : 				value_type(_Keyval, mapped_type()));

$LN90@operator@20:
  00142	8d 55 f0	 lea	 edx, DWORD PTR $T192185[ebp]
  00145	52		 push	 edx
  00146	8d 4d e4	 lea	 ecx, DWORD PTR $T192382[ebp]
  00149	89 5d f0	 mov	 DWORD PTR $T192185[ebp], ebx
  0014c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00151	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00156	8d 45 e4	 lea	 eax, DWORD PTR $T192382[ebp]
  00159	50		 push	 eax
  0015a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T192382[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00161	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN229@operator@20:
$LN228@operator@20:
  00166	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR $T191954[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TokenizerSection@@QAE@XZ
__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$1:
  00008	8d 4d b8	 lea	 ecx, DWORD PTR $T191953[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBKVTokenizerSection@@@std@@QAE@XZ
__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$13:
  00010	8b 4d 08	 mov	 ecx, DWORD PTR $T192712[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__unwindfunclet$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z$16:
  00018	8d 4d d0	 lea	 ecx, DWORD PTR $T191954[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z:
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z ENDP ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::operator[]
PUBLIC	??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::~map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T193223 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::~map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T193223[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
__ehhandler$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::~map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >
PUBLIC	??0?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T193412 = -16						; size = 12
$T193306 = -4						; size = 4
??0?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN25@map@3
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 107  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0

; 106  : 		{	// construct empty map from defaults

$LN25@map@3:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T193306[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T193412[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T193306[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T193412[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T193412[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@map@3:
$LN48@map@3:
  0006c	cc		 int	 3
??0?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >
_TEXT	ENDS
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_02CBLDBPFN@?1?1?$AA@			; `string'
PUBLIC	_tok$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z ; Tokenizer::ParseFile
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CBLDBPFN@?1?1?$AA@
CONST	SEGMENT
??_C@_02CBLDBPFN@?1?1?$AA@ DB '//', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$14
	DD	03H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$21
	DD	01H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$24
	DD	07H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$31
	DD	03H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$34
	DD	03H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$37
	DD	01H
	DD	FLAT:__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$40
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\tokenizer.h
xdata$x	ENDS
;	COMDAT ?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z
_TEXT	SEGMENT
_f$ = -4496						; size = 184
$T197814 = -4312					; size = 4
$T197364 = -4308					; size = 12
$T196158 = -4296					; size = 12
$T195541 = -4284					; size = 4
$T193703 = -4280					; size = 12
$T198335 = -4268					; size = 4
$T198057 = -4264					; size = 4
$T197555 = -4260					; size = 4
_this$ = -4256						; size = 4
_tok$GSCopy$ = -4252					; size = 4
$T193531 = -4248					; size = 4
_it$197116 = -4244					; size = 4
$T195963 = -4240					; size = 4
$T197168 = -4236					; size = 4
_current_sec$144173 = -4232				; size = 4
_row$144309 = -4228					; size = 20
_sec_index$144174 = -4208				; size = 4
_sec$144171 = -4204					; size = 20
$T198915 = -4184					; size = 4
$T198585 = -4184					; size = 4
$T196824 = -4184					; size = 4
$T196497 = -4184					; size = 4
$T194928 = -4184					; size = 4
$T197120 = -4180					; size = 4
$T193440 = -4180					; size = 4
$T193437 = -4180					; size = 4
$T193436 = -4180					; size = 4
$T194173 = -4176					; size = 1
_sec_open$144175 = -4169				; size = 1
$T144289 = -4168					; size = 28
$T144195 = -4168					; size = 28
$T193439 = -4160					; size = 20
_line$144181 = -4140					; size = 28
_temp$144179 = -4112					; size = 4096
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_file$ = 8						; size = 28
_tok$ = 36						; size = 4
?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z PROC ; Tokenizer::ParseFile, COMDAT
; _this$ = ecx

; 175  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 84 11 00 00	 mov	 eax, 4484		; 00001184H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	89 8d 60 ef ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00038	8b 45 24	 mov	 eax, DWORD PTR _tok$[ebp]

; 231  : 					}
; 232  : 
; 233  : 					if(line.substr(0, 2) == "//") continue;

  0003b	89 85 64 ef ff
	ff		 mov	 DWORD PTR _tok$GSCopy$[ebp], eax
  00041	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00044	33 f6		 xor	 esi, esi
  00046	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  0004b	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  0004e	39 7d 1c	 cmp	 DWORD PTR _file$[ebp+20], edi
  00051	73 03		 jae	 SHORT $LN40@ParseFile

; 176  : 
; 177  : 		std::fstream f(file.c_str(), std::ios::in);

  00053	8d 45 08	 lea	 eax, DWORD PTR _file$[ebp]
$LN40@ParseFile:
  00056	6a 01		 push	 1
  00058	6a 40		 push	 64			; 00000040H
  0005a	6a 01		 push	 1
  0005c	50		 push	 eax
  0005d	8d 8d 70 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp]
  00063	e8 00 00 00 00	 call	 ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
  00068	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 178  : 
; 179  : 		if(f.is_open())

  0006c	39 b5 dc ee ff
	ff		 cmp	 DWORD PTR _f$[ebp+108], esi
  00072	0f 84 9f 0b 00
	00		 je	 $LN23@ParseFile

; 180  : 		{
; 181  : 
; 182  : 			if(f.good())

  00078	8b 8d 70 ee ff
	ff		 mov	 ecx, DWORD PTR _f$[ebp]
  0007e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00081	39 b4 15 7c ee
	ff ff		 cmp	 DWORD PTR _f$[ebp+edx+12], esi
  00088	0f 85 1e 0b 00
	00		 jne	 $LN22@ParseFile

; 183  : 			{
; 184  : 
; 185  : 				TokenizerSection sec = TokenizerSection();

  0008e	6a 28		 push	 40			; 00000028H
  00090	89 b5 9c ef ff
	ff		 mov	 DWORD PTR _sec$144171[ebp+8], esi
  00096	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009b	83 c4 04	 add	 esp, 4
  0009e	3b c6		 cmp	 eax, esi
  000a0	0f 84 d3 0a 00
	00		 je	 $LN76@ParseFile
  000a6	89 85 98 ef ff
	ff		 mov	 DWORD PTR _sec$144171[ebp+4], eax
  000ac	89 00		 mov	 DWORD PTR [eax], eax
  000ae	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  000b4	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000b7	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  000bd	89 40 08	 mov	 DWORD PTR [eax+8], eax
  000c0	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  000c6	c6 40 24 01	 mov	 BYTE PTR [eax+36], 1
  000ca	8b 8d 98 ef ff
	ff		 mov	 ecx, DWORD PTR _sec$144171[ebp+4]
  000d0	c6 41 25 01	 mov	 BYTE PTR [ecx+37], 1

; 186  : 				int current_sec = 0;
; 187  : 				int sec_index = 0;
; 188  : 				bool sec_open = false;
; 189  : 
; 190  : 				while(!f.eof())

  000d4	8b 95 70 ee ff
	ff		 mov	 edx, DWORD PTR _f$[ebp]
  000da	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000dd	8b 84 05 7c ee
	ff ff		 mov	 eax, DWORD PTR _f$[ebp+eax+12]
  000e4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000e8	89 b5 78 ef ff
	ff		 mov	 DWORD PTR _current_sec$144173[ebp], esi
  000ee	89 b5 90 ef ff
	ff		 mov	 DWORD PTR _sec_index$144174[ebp], esi
  000f4	c6 85 b7 ef ff
	ff 00		 mov	 BYTE PTR _sec_open$144175[ebp], 0
  000fb	a8 01		 test	 al, 1
  000fd	0f 85 f8 07 00
	00		 jne	 $LN20@ParseFile

; 226  : 
; 227  : 					std::string::size_type k = 0;
; 228  : 					while((k=line.find(13,k))!=line.npos) 

  00103	c6 85 b0 ef ff
	ff 0d		 mov	 BYTE PTR $T194173[ebp], 13 ; 0000000dH
  0010a	8d 9b 00 00 00
	00		 npad	 6
$LL21@ParseFile:

; 191  : 				{
; 192  : 
; 193  : 					char temp[4096];
; 194  : 					char* dump = NULL;
; 195  : 					std::string line = "";

  00110	6a 00		 push	 0
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00117	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  0011d	c7 85 e8 ef ff
	ff 0f 00 00 00	 mov	 DWORD PTR _line$144181[ebp+20], 15 ; 0000000fH
  00127	c7 85 e4 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _line$144181[ebp+16], 0
  00131	c6 85 d4 ef ff
	ff 00		 mov	 BYTE PTR _line$144181[ebp], 0
  00138	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 196  : 
; 197  : 					ZeroMemory(&temp[0], 4096);

  0013d	68 00 10 00 00	 push	 4096			; 00001000H
  00142	8d 8d f0 ef ff
	ff		 lea	 ecx, DWORD PTR _temp$144179[ebp]
  00148	6a 00		 push	 0
  0014a	51		 push	 ecx
  0014b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0014f	e8 00 00 00 00	 call	 _memset

; 198  : 
; 199  : 					f.getline(&temp[0], 4095);

  00154	8b 95 70 ee ff
	ff		 mov	 edx, DWORD PTR _f$[ebp]
  0015a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	6a 0a		 push	 10			; 0000000aH
  00162	8d 8c 0d 70 ee
	ff ff		 lea	 ecx, DWORD PTR _f$[ebp+ecx]
  00169	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
  0016e	0f b6 c0	 movzx	 eax, al
  00171	50		 push	 eax
  00172	6a 00		 push	 0
  00174	68 ff 0f 00 00	 push	 4095			; 00000fffH
  00179	8d 8d f0 ef ff
	ff		 lea	 ecx, DWORD PTR _temp$144179[ebp]
  0017f	51		 push	 ecx
  00180	8d 8d 70 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp]
  00186	e8 00 00 00 00	 call	 ?getline@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_JD@Z ; std::basic_istream<char,std::char_traits<char> >::getline

; 200  : 					line.assign(&temp[0]);

  0018b	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _temp$144179[ebp]
  00191	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL1332@ParseFile:
  00194	8a 08		 mov	 cl, BYTE PTR [eax]
  00196	40		 inc	 eax
  00197	84 c9		 test	 cl, cl
  00199	75 f9		 jne	 SHORT $LL1332@ParseFile
  0019b	2b c2		 sub	 eax, edx
  0019d	50		 push	 eax
  0019e	8d 95 f0 ef ff
	ff		 lea	 edx, DWORD PTR _temp$144179[ebp]
  001a4	52		 push	 edx
  001a5	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  001ab	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 201  : 
; 202  : 					dump = (char*)line.c_str();

  001b0	83 bd e8 ef ff
	ff 10		 cmp	 DWORD PTR _line$144181[ebp+20], 16 ; 00000010H
  001b7	8b bd d4 ef ff
	ff		 mov	 edi, DWORD PTR _line$144181[ebp]
  001bd	73 06		 jae	 SHORT $LN145@ParseFile
  001bf	8d bd d4 ef ff
	ff		 lea	 edi, DWORD PTR _line$144181[ebp]
$LN145@ParseFile:

; 203  : 
; 204  : 					int start = 0;
; 205  : 					int end = 0;
; 206  : 
; 207  : 					for(DWORD i = 0; i < line.length(); i++)

  001c5	8b 95 e4 ef ff
	ff		 mov	 edx, DWORD PTR _line$144181[ebp+16]
  001cb	33 f6		 xor	 esi, esi
  001cd	33 db		 xor	 ebx, ebx
  001cf	33 c0		 xor	 eax, eax
  001d1	85 d2		 test	 edx, edx
  001d3	74 13		 je	 SHORT $LN1307@ParseFile
$LL19@ParseFile:

; 208  : 					{
; 209  : 						if(dump[i] != ' ' && dump[i] != '\t')

  001d5	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  001d8	80 f9 20	 cmp	 cl, 32			; 00000020H
  001db	74 05		 je	 SHORT $LN16@ParseFile
  001dd	80 f9 09	 cmp	 cl, 9
  001e0	75 06		 jne	 SHORT $LN1307@ParseFile
$LN16@ParseFile:

; 203  : 
; 204  : 					int start = 0;
; 205  : 					int end = 0;
; 206  : 
; 207  : 					for(DWORD i = 0; i < line.length(); i++)

  001e2	40		 inc	 eax

; 210  : 						{
; 211  : 							break;
; 212  : 						}
; 213  : 						start++;

  001e3	46		 inc	 esi
  001e4	3b c2		 cmp	 eax, edx
  001e6	72 ed		 jb	 SHORT $LL19@ParseFile
$LN1307@ParseFile:

; 214  : 					}
; 215  : 
; 216  : 					for(DWORD i = line.length()-1; i > 0; i--) // warning C6295: Ill-defined for-loop Arrumado

  001e8	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]
  001eb	85 c9		 test	 ecx, ecx
  001ed	74 10		 je	 SHORT $LN1308@ParseFile
  001ef	90		 npad	 1
$LL15@ParseFile:

; 217  : 					{
; 218  : 						if(dump[i] != ' ' && dump[i] != '\t')

  001f0	8a 04 39	 mov	 al, BYTE PTR [ecx+edi]
  001f3	3c 20		 cmp	 al, 32			; 00000020H
  001f5	74 04		 je	 SHORT $LN12@ParseFile
  001f7	3c 09		 cmp	 al, 9
  001f9	75 04		 jne	 SHORT $LN1308@ParseFile
$LN12@ParseFile:

; 219  : 						{
; 220  : 							break;
; 221  : 						}
; 222  : 						end++;

  001fb	43		 inc	 ebx
  001fc	49		 dec	 ecx
  001fd	75 f1		 jne	 SHORT $LL15@ParseFile
$LN1308@ParseFile:

; 223  : 					}
; 224  : 
; 225  : 					line = line.substr(start, line.length() - end - start);

  001ff	2b d3		 sub	 edx, ebx
  00201	2b d6		 sub	 edx, esi
  00203	52		 push	 edx
  00204	56		 push	 esi
  00205	8d 85 b8 ef ff
	ff		 lea	 eax, DWORD PTR $T144195[ebp]
  0020b	50		 push	 eax
  0020c	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  00212	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  00217	8b f0		 mov	 esi, eax
  00219	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  0021f	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
  00224	3b ce		 cmp	 ecx, esi
  00226	74 70		 je	 SHORT $LN1336@ParseFile
  00228	39 9d e8 ef ff
	ff		 cmp	 DWORD PTR _line$144181[ebp+20], ebx
  0022e	72 0f		 jb	 SHORT $LN188@ParseFile
  00230	8b 95 d4 ef ff
	ff		 mov	 edx, DWORD PTR _line$144181[ebp]
  00236	52		 push	 edx
  00237	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0023c	83 c4 04	 add	 esp, 4
$LN188@ParseFile:
  0023f	33 ff		 xor	 edi, edi
  00241	c7 85 e8 ef ff
	ff 0f 00 00 00	 mov	 DWORD PTR _line$144181[ebp+20], 15 ; 0000000fH
  0024b	89 bd e4 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+16], edi
  00251	c6 85 d4 ef ff
	ff 00		 mov	 BYTE PTR _line$144181[ebp], 0
  00258	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  0025b	73 17		 jae	 SHORT $LN157@ParseFile
  0025d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00260	40		 inc	 eax
  00261	50		 push	 eax
  00262	8d 85 d4 ef ff
	ff		 lea	 eax, DWORD PTR _line$144181[ebp]
  00268	56		 push	 esi
  00269	50		 push	 eax
  0026a	e8 00 00 00 00	 call	 _memmove
  0026f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00272	eb 0a		 jmp	 SHORT $LN156@ParseFile
$LN157@ParseFile:
  00274	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00276	89 8d d4 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp], ecx
  0027c	89 3e		 mov	 DWORD PTR [esi], edi
$LN156@ParseFile:
  0027e	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00281	89 95 e4 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+16], edx
  00287	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0028a	89 85 e8 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+20], eax
  00290	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00293	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00296	eb 02		 jmp	 SHORT $LN158@ParseFile
$LN1336@ParseFile:
  00298	33 ff		 xor	 edi, edi
$LN158@ParseFile:
  0029a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0029e	39 9d cc ef ff
	ff		 cmp	 DWORD PTR $T144195[ebp+20], ebx
  002a4	72 0f		 jb	 SHORT $LN210@ParseFile
  002a6	8b 8d b8 ef ff
	ff		 mov	 ecx, DWORD PTR $T144195[ebp]
  002ac	51		 push	 ecx
  002ad	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002b2	83 c4 04	 add	 esp, 4
$LN210@ParseFile:

; 226  : 
; 227  : 					std::string::size_type k = 0;
; 228  : 					while((k=line.find(13,k))!=line.npos) 

  002b5	6a 01		 push	 1
  002b7	57		 push	 edi
  002b8	8d 95 b0 ef ff
	ff		 lea	 edx, DWORD PTR $T194173[ebp]
  002be	52		 push	 edx
  002bf	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  002c5	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  002ca	8b f0		 mov	 esi, eax
  002cc	83 fe ff	 cmp	 esi, -1
  002cf	0f 84 a7 00 00
	00		 je	 $LN10@ParseFile
  002d5	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL11@ParseFile:

; 229  : 					{
; 230  : 						line.erase(k, 1);

  002e0	8b 85 e4 ef ff
	ff		 mov	 eax, DWORD PTR _line$144181[ebp+16]
  002e6	bf 01 00 00 00	 mov	 edi, 1
  002eb	3b c6		 cmp	 eax, esi
  002ed	0f 82 b3 06 00
	00		 jb	 $LN1309@ParseFile
  002f3	8b c8		 mov	 ecx, eax
  002f5	2b ce		 sub	 ecx, esi
  002f7	3b cf		 cmp	 ecx, edi
  002f9	73 06		 jae	 SHORT $LN1329@ParseFile
  002fb	8b f9		 mov	 edi, ecx
  002fd	85 ff		 test	 edi, edi
  002ff	74 5b		 je	 SHORT $LN248@ParseFile
$LN1329@ParseFile:
  00301	8b 8d e8 ef ff
	ff		 mov	 ecx, DWORD PTR _line$144181[ebp+20]
  00307	8b 9d d4 ef ff
	ff		 mov	 ebx, DWORD PTR _line$144181[ebp]
  0030d	8b d3		 mov	 edx, ebx
  0030f	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00312	0f 83 99 00 00
	00		 jae	 $LN1349@ParseFile
  00318	8d 95 d4 ef ff
	ff		 lea	 edx, DWORD PTR _line$144181[ebp]
  0031e	8b ca		 mov	 ecx, edx
$LN239@ParseFile:
  00320	2b c7		 sub	 eax, edi
  00322	2b c6		 sub	 eax, esi
  00324	03 d7		 add	 edx, edi
  00326	50		 push	 eax
  00327	03 d6		 add	 edx, esi
  00329	52		 push	 edx
  0032a	03 ce		 add	 ecx, esi
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 _memmove
  00332	8b 85 e4 ef ff
	ff		 mov	 eax, DWORD PTR _line$144181[ebp+16]
  00338	8b 8d d4 ef ff
	ff		 mov	 ecx, DWORD PTR _line$144181[ebp]
  0033e	2b c7		 sub	 eax, edi
  00340	83 c4 0c	 add	 esp, 12			; 0000000cH
  00343	83 bd e8 ef ff
	ff 10		 cmp	 DWORD PTR _line$144181[ebp+20], 16 ; 00000010H
  0034a	89 85 e4 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+16], eax
  00350	73 06		 jae	 SHORT $LN247@ParseFile
  00352	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
$LN247@ParseFile:
  00358	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
$LN248@ParseFile:

; 226  : 
; 227  : 					std::string::size_type k = 0;
; 228  : 					while((k=line.find(13,k))!=line.npos) 

  0035c	6a 01		 push	 1
  0035e	56		 push	 esi
  0035f	8d 85 b0 ef ff
	ff		 lea	 eax, DWORD PTR $T194173[ebp]
  00365	50		 push	 eax
  00366	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  0036c	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00371	8b f0		 mov	 esi, eax
  00373	83 fe ff	 cmp	 esi, -1
  00376	0f 85 64 ff ff
	ff		 jne	 $LL11@ParseFile
$LN10@ParseFile:

; 231  : 					}
; 232  : 
; 233  : 					if(line.substr(0, 2) == "//") continue;

  0037c	6a 02		 push	 2
  0037e	6a 00		 push	 0
  00380	8d 8d b8 ef ff
	ff		 lea	 ecx, DWORD PTR $T144289[ebp]
  00386	51		 push	 ecx
  00387	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  0038d	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  00392	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  00395	8b cf		 mov	 ecx, edi
  00397	3b cf		 cmp	 ecx, edi
  00399	73 00		 jae	 SHORT $LN256@ParseFile
$LN256@ParseFile:
  0039b	8b d7		 mov	 edx, edi
  0039d	83 ff 02	 cmp	 edi, 2
  003a0	72 05		 jb	 SHORT $LN261@ParseFile
  003a2	ba 02 00 00 00	 mov	 edx, 2
$LN261@ParseFile:
  003a7	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  003ab	72 0b		 jb	 SHORT $LN271@ParseFile
  003ad	8b 30		 mov	 esi, DWORD PTR [eax]
  003af	eb 09		 jmp	 SHORT $LN272@ParseFile
$LN1349@ParseFile:

; 229  : 					{
; 230  : 						line.erase(k, 1);

  003b1	8b cb		 mov	 ecx, ebx
  003b3	e9 68 ff ff ff	 jmp	 $LN239@ParseFile

; 231  : 					}
; 232  : 
; 233  : 					if(line.substr(0, 2) == "//") continue;

$LN271@ParseFile:
  003b8	8b f0		 mov	 esi, eax
$LN272@ParseFile:
  003ba	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02CBLDBPFN@?1?1?$AA@
  003bf	83 fa 04	 cmp	 edx, 4
  003c2	72 14		 jb	 SHORT $LN1310@ParseFile
$LL276@ParseFile:
  003c4	8b 06		 mov	 eax, DWORD PTR [esi]
  003c6	3b 01		 cmp	 eax, DWORD PTR [ecx]
  003c8	75 12		 jne	 SHORT $LN277@ParseFile
  003ca	83 ea 04	 sub	 edx, 4
  003cd	83 c1 04	 add	 ecx, 4
  003d0	83 c6 04	 add	 esi, 4
  003d3	83 fa 04	 cmp	 edx, 4
  003d6	73 ec		 jae	 SHORT $LL276@ParseFile
$LN1310@ParseFile:
  003d8	85 d2		 test	 edx, edx
  003da	74 43		 je	 SHORT $LN278@ParseFile
$LN277@ParseFile:
  003dc	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  003df	0f b6 19	 movzx	 ebx, BYTE PTR [ecx]
  003e2	2b c3		 sub	 eax, ebx
  003e4	75 31		 jne	 SHORT $LN279@ParseFile
  003e6	83 fa 01	 cmp	 edx, 1
  003e9	76 34		 jbe	 SHORT $LN278@ParseFile
  003eb	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  003ef	0f b6 59 01	 movzx	 ebx, BYTE PTR [ecx+1]
  003f3	2b c3		 sub	 eax, ebx
  003f5	75 20		 jne	 SHORT $LN279@ParseFile
  003f7	83 fa 02	 cmp	 edx, 2
  003fa	76 23		 jbe	 SHORT $LN278@ParseFile
  003fc	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00400	0f b6 59 02	 movzx	 ebx, BYTE PTR [ecx+2]
  00404	2b c3		 sub	 eax, ebx
  00406	75 0f		 jne	 SHORT $LN279@ParseFile
  00408	83 fa 03	 cmp	 edx, 3
  0040b	76 12		 jbe	 SHORT $LN278@ParseFile
  0040d	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00411	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00415	2b c1		 sub	 eax, ecx
$LN279@ParseFile:
  00417	c1 f8 1f	 sar	 eax, 31			; 0000001fH
  0041a	83 c8 01	 or	 eax, 1
  0041d	eb 02		 jmp	 SHORT $LN280@ParseFile
$LN278@ParseFile:
  0041f	33 c0		 xor	 eax, eax
$LN280@ParseFile:
  00421	85 c0		 test	 eax, eax
  00423	75 12		 jne	 SHORT $LN263@ParseFile
  00425	83 ff 02	 cmp	 edi, 2
  00428	73 05		 jae	 SHORT $LN262@ParseFile
  0042a	83 c8 ff	 or	 eax, -1
  0042d	eb 08		 jmp	 SHORT $LN263@ParseFile
$LN262@ParseFile:
  0042f	33 c0		 xor	 eax, eax
  00431	83 ff 02	 cmp	 edi, 2
  00434	0f 95 c0	 setne	 al
$LN263@ParseFile:
  00437	33 ff		 xor	 edi, edi
  00439	3b c7		 cmp	 eax, edi
  0043b	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  00440	0f 94 c3	 sete	 bl
  00443	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00447	39 b5 cc ef ff
	ff		 cmp	 DWORD PTR $T144289[ebp+20], esi
  0044d	72 0f		 jb	 SHORT $LN293@ParseFile
  0044f	8b 95 b8 ef ff
	ff		 mov	 edx, DWORD PTR $T144289[ebp]
  00455	52		 push	 edx
  00456	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0045b	83 c4 04	 add	 esp, 4
$LN293@ParseFile:
  0045e	84 db		 test	 bl, bl
  00460	74 1c		 je	 SHORT $LN9@ParseFile
  00462	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00466	39 b5 e8 ef ff
	ff		 cmp	 DWORD PTR _line$144181[ebp+20], esi
  0046c	0f 82 6b 04 00
	00		 jb	 $LN1129@ParseFile
  00472	8b 85 d4 ef ff
	ff		 mov	 eax, DWORD PTR _line$144181[ebp]
  00478	50		 push	 eax
  00479	e9 57 04 00 00	 jmp	 $LN1350@ParseFile
$LN9@ParseFile:

; 234  : 
; 235  : 					if(line.compare("end") == false)

  0047e	8b 9d e4 ef ff
	ff		 mov	 ebx, DWORD PTR _line$144181[ebp+16]
  00484	8b d3		 mov	 edx, ebx
  00486	83 fb 03	 cmp	 ebx, 3
  00489	72 05		 jb	 SHORT $LN336@ParseFile
  0048b	ba 03 00 00 00	 mov	 edx, 3
$LN336@ParseFile:
  00490	39 b5 e8 ef ff
	ff		 cmp	 DWORD PTR _line$144181[ebp+20], esi
  00496	8b b5 d4 ef ff
	ff		 mov	 esi, DWORD PTR _line$144181[ebp]
  0049c	73 06		 jae	 SHORT $LN347@ParseFile
  0049e	8d b5 d4 ef ff
	ff		 lea	 esi, DWORD PTR _line$144181[ebp]
$LN347@ParseFile:
  004a4	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  004a9	83 fa 04	 cmp	 edx, 4
  004ac	72 16		 jb	 SHORT $LN1311@ParseFile
  004ae	8b ff		 npad	 2
$LL351@ParseFile:
  004b0	8b 06		 mov	 eax, DWORD PTR [esi]
  004b2	3b 01		 cmp	 eax, DWORD PTR [ecx]
  004b4	75 12		 jne	 SHORT $LN352@ParseFile
  004b6	83 ea 04	 sub	 edx, 4
  004b9	83 c1 04	 add	 ecx, 4
  004bc	83 c6 04	 add	 esi, 4
  004bf	83 fa 04	 cmp	 edx, 4
  004c2	73 ec		 jae	 SHORT $LL351@ParseFile
$LN1311@ParseFile:
  004c4	3b d7		 cmp	 edx, edi
  004c6	74 47		 je	 SHORT $LN353@ParseFile
$LN352@ParseFile:
  004c8	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  004cb	0f b6 39	 movzx	 edi, BYTE PTR [ecx]
  004ce	2b c7		 sub	 eax, edi
  004d0	75 31		 jne	 SHORT $LN354@ParseFile
  004d2	83 fa 01	 cmp	 edx, 1
  004d5	76 36		 jbe	 SHORT $LN1345@ParseFile
  004d7	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  004db	0f b6 79 01	 movzx	 edi, BYTE PTR [ecx+1]
  004df	2b c7		 sub	 eax, edi
  004e1	75 20		 jne	 SHORT $LN354@ParseFile
  004e3	83 fa 02	 cmp	 edx, 2
  004e6	76 25		 jbe	 SHORT $LN1345@ParseFile
  004e8	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  004ec	0f b6 79 02	 movzx	 edi, BYTE PTR [ecx+2]
  004f0	2b c7		 sub	 eax, edi
  004f2	75 0f		 jne	 SHORT $LN354@ParseFile
  004f4	83 fa 03	 cmp	 edx, 3
  004f7	76 14		 jbe	 SHORT $LN1345@ParseFile
  004f9	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  004fd	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00501	2b c1		 sub	 eax, ecx
$LN354@ParseFile:
  00503	c1 f8 1f	 sar	 eax, 31			; 0000001fH
  00506	83 c8 01	 or	 eax, 1
  00509	33 ff		 xor	 edi, edi
  0050b	eb 04		 jmp	 SHORT $LN355@ParseFile
$LN1345@ParseFile:
  0050d	33 ff		 xor	 edi, edi
$LN353@ParseFile:
  0050f	33 c0		 xor	 eax, eax
$LN355@ParseFile:
  00511	3b c7		 cmp	 eax, edi
  00513	0f 85 06 01 00
	00		 jne	 $LN8@ParseFile
  00519	83 fb 03	 cmp	 ebx, 3
  0051c	0f 82 fd 00 00
	00		 jb	 $LN8@ParseFile
  00522	33 c0		 xor	 eax, eax
  00524	83 fb 03	 cmp	 ebx, 3
  00527	0f 95 c0	 setne	 al
  0052a	3b c7		 cmp	 eax, edi
  0052c	0f 85 ed 00 00
	00		 jne	 $LN8@ParseFile

; 236  : 					{
; 237  : 						if(sec_open == false) 

  00532	80 bd b7 ef ff
	ff 00		 cmp	 BYTE PTR _sec_open$144175[ebp], 0
  00539	0f 84 71 04 00
	00		 je	 $LN1315@ParseFile

; 240  : 						}
; 241  : 						sec_open = false;
; 242  : 						sec.RowCount = sec_index;

  0053f	8b 95 90 ef ff
	ff		 mov	 edx, DWORD PTR _sec_index$144174[ebp]

; 243  : 						tok.Sections[current_sec] = sec;

  00545	8b 85 78 ef ff
	ff		 mov	 eax, DWORD PTR _current_sec$144173[ebp]
  0054b	8d 8d ac ef ff
	ff		 lea	 ecx, DWORD PTR $T193436[ebp]
  00551	51		 push	 ecx
  00552	8b 8d 64 ef ff
	ff		 mov	 ecx, DWORD PTR _tok$GSCopy$[ebp]
  00558	c6 85 b7 ef ff
	ff 00		 mov	 BYTE PTR _sec_open$144175[ebp], 0
  0055f	89 95 a4 ef ff
	ff		 mov	 DWORD PTR _sec$144171[ebp+16], edx
  00565	89 85 ac ef ff
	ff		 mov	 DWORD PTR $T193436[ebp], eax
  0056b	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@@std@@QAEAAVTokenizerSection@@ABK@Z ; std::map<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> > >::operator[]
  00570	8b f0		 mov	 esi, eax
  00572	8d 95 94 ef ff
	ff		 lea	 edx, DWORD PTR _sec$144171[ebp]
  00578	3b f2		 cmp	 esi, edx
  0057a	74 7d		 je	 SHORT $LN478@ParseFile
  0057c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0057f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00581	50		 push	 eax
  00582	51		 push	 ecx
  00583	8d 85 44 ef ff
	ff		 lea	 eax, DWORD PTR $T195541[ebp]
  00589	50		 push	 eax
  0058a	8b ce		 mov	 ecx, esi
  0058c	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00591	8b 8d 98 ef ff
	ff		 mov	 ecx, DWORD PTR _sec$144171[ebp+4]
  00597	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0059a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0059d	57		 push	 edi
  0059e	52		 push	 edx
  0059f	8b ce		 mov	 ecx, esi
  005a1	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
  005a6	89 47 04	 mov	 DWORD PTR [edi+4], eax
  005a9	8b 85 9c ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+8]
  005af	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  005b2	89 46 08	 mov	 DWORD PTR [esi+8], eax
  005b5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  005b8	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  005bc	75 33		 jne	 SHORT $LN479@ParseFile
  005be	8b 08		 mov	 ecx, DWORD PTR [eax]
  005c0	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  005c4	75 0a		 jne	 SHORT $LN502@ParseFile
$LL503@ParseFile:
  005c6	8b c1		 mov	 eax, ecx
  005c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  005ca	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  005ce	74 f6		 je	 SHORT $LL503@ParseFile
$LN502@ParseFile:
  005d0	89 02		 mov	 DWORD PTR [edx], eax
  005d2	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  005d5	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  005d8	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  005db	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  005df	75 0b		 jne	 SHORT $LN520@ParseFile
$LL521@ParseFile:
  005e1	8b c8		 mov	 ecx, eax
  005e3	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  005e6	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  005ea	74 f5		 je	 SHORT $LL521@ParseFile
$LN520@ParseFile:
  005ec	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  005ef	eb 08		 jmp	 SHORT $LN478@ParseFile
$LN479@ParseFile:
  005f1	89 12		 mov	 DWORD PTR [edx], edx
  005f3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  005f6	89 40 08	 mov	 DWORD PTR [eax+8], eax
$LN478@ParseFile:
  005f9	8b 8d a4 ef ff
	ff		 mov	 ecx, DWORD PTR _sec$144171[ebp+16]
  005ff	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
$LN1352@ParseFile:

; 244  : 						continue;

  00602	83 bd e8 ef ff
	ff 10		 cmp	 DWORD PTR _line$144181[ebp+20], 16 ; 00000010H
  00609	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0060d	0f 82 ca 02 00
	00		 jb	 $LN1129@ParseFile
  00613	8b 95 d4 ef ff
	ff		 mov	 edx, DWORD PTR _line$144181[ebp]
  00619	52		 push	 edx
  0061a	e9 b6 02 00 00	 jmp	 $LN1350@ParseFile
$LN8@ParseFile:

; 245  : 					}
; 246  : 					
; 247  : 					if(line == "") continue;

  0061f	33 c0		 xor	 eax, eax
  00621	3b df		 cmp	 ebx, edi
  00623	0f 95 c0	 setne	 al
  00626	3b c7		 cmp	 eax, edi
  00628	0f 94 c0	 sete	 al
  0062b	84 c0		 test	 al, al
  0062d	74 1d		 je	 SHORT $LN6@ParseFile
  0062f	83 bd e8 ef ff
	ff 10		 cmp	 DWORD PTR _line$144181[ebp+20], 16 ; 00000010H
  00636	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0063a	0f 82 9d 02 00
	00		 jb	 $LN1129@ParseFile
  00640	8b 85 d4 ef ff
	ff		 mov	 eax, DWORD PTR _line$144181[ebp]
  00646	50		 push	 eax
  00647	e9 89 02 00 00	 jmp	 $LN1350@ParseFile
$LN6@ParseFile:

; 248  : 
; 249  : 					TokenizerRow row;

  0064c	6a 30		 push	 48			; 00000030H
  0064e	89 bd 84 ef ff
	ff		 mov	 DWORD PTR _row$144309[ebp+8], edi
  00654	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00659	83 c4 04	 add	 esp, 4
  0065c	3b c7		 cmp	 eax, edi
  0065e	0f 84 e2 04 00
	00		 je	 $LN646@ParseFile
  00664	89 85 80 ef ff
	ff		 mov	 DWORD PTR _row$144309[ebp+4], eax
  0066a	89 00		 mov	 DWORD PTR [eax], eax
  0066c	8b 85 80 ef ff
	ff		 mov	 eax, DWORD PTR _row$144309[ebp+4]
  00672	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00675	8b 85 80 ef ff
	ff		 mov	 eax, DWORD PTR _row$144309[ebp+4]
  0067b	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0067e	8b 8d 80 ef ff
	ff		 mov	 ecx, DWORD PTR _row$144309[ebp+4]
  00684	c6 41 2c 01	 mov	 BYTE PTR [ecx+44], 1
  00688	8b 95 80 ef ff
	ff		 mov	 edx, DWORD PTR _row$144309[ebp+4]
  0068e	c6 42 2d 01	 mov	 BYTE PTR [edx+45], 1

; 250  : 					if(!this->ParseLine(line, row))

  00692	8d 85 7c ef ff
	ff		 lea	 eax, DWORD PTR _row$144309[ebp]
  00698	50		 push	 eax
  00699	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0069c	8b cc		 mov	 ecx, esp
  0069e	89 a5 ac ef ff
	ff		 mov	 DWORD PTR $T193437[ebp], esp
  006a4	6a ff		 push	 -1
  006a6	57		 push	 edi
  006a7	8d 95 d4 ef ff
	ff		 lea	 edx, DWORD PTR _line$144181[ebp]
  006ad	be 0f 00 00 00	 mov	 esi, 15			; 0000000fH
  006b2	89 71 14	 mov	 DWORD PTR [ecx+20], esi
  006b5	89 79 10	 mov	 DWORD PTR [ecx+16], edi
  006b8	52		 push	 edx
  006b9	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  006bd	c6 01 00	 mov	 BYTE PTR [ecx], 0
  006c0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  006c5	8b 8d 60 ef ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006cb	e8 00 00 00 00	 call	 ?ParseLine@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerRow@@@Z ; Tokenizer::ParseLine
  006d0	84 c0		 test	 al, al
  006d2	0f 84 74 03 00
	00		 je	 $LN1318@ParseFile

; 252  : 
; 253  : 					if(row.ColumnCount == 1)

  006d8	83 bd 8c ef ff
	ff 01		 cmp	 DWORD PTR _row$144309[ebp+16], 1
  006df	0f 85 50 01 00
	00		 jne	 $LN3@ParseFile

; 254  : 					{
; 255  : 						if(sec_open == false)

  006e5	80 bd b7 ef ff
	ff 00		 cmp	 BYTE PTR _sec_open$144175[ebp], 0
  006ec	0f 85 43 01 00
	00		 jne	 $LN3@ParseFile

; 256  : 						{
; 257  : 							sec_index = 0;
; 258  : 							current_sec = row.GetInt(0, 0);

  006f2	8d 85 ac ef ff
	ff		 lea	 eax, DWORD PTR $T197120[ebp]
  006f8	50		 push	 eax
  006f9	8d 8d 6c ef ff
	ff		 lea	 ecx, DWORD PTR _it$197116[ebp]
  006ff	51		 push	 ecx
  00700	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00706	89 bd 90 ef ff
	ff		 mov	 DWORD PTR _sec_index$144174[ebp], edi
  0070c	89 bd ac ef ff
	ff		 mov	 DWORD PTR $T197120[ebp], edi
  00712	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
  00717	8b 85 6c ef ff
	ff		 mov	 eax, DWORD PTR _it$197116[ebp]
  0071d	3b 85 80 ef ff
	ff		 cmp	 eax, DWORD PTR _row$144309[ebp+4]
  00723	75 08		 jne	 SHORT $LN825@ParseFile
  00725	89 bd 78 ef ff
	ff		 mov	 DWORD PTR _current_sec$144173[ebp], edi
  0072b	eb 1a		 jmp	 SHORT $LN826@ParseFile
$LN825@ParseFile:
  0072d	83 c0 10	 add	 eax, 16			; 00000010H
  00730	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00734	72 02		 jb	 SHORT $LN866@ParseFile
  00736	8b 00		 mov	 eax, DWORD PTR [eax]
$LN866@ParseFile:
  00738	50		 push	 eax
  00739	e8 00 00 00 00	 call	 _atoi
  0073e	83 c4 04	 add	 esp, 4
  00741	89 85 78 ef ff
	ff		 mov	 DWORD PTR _current_sec$144173[ebp], eax
$LN826@ParseFile:

; 259  : 							sec = TokenizerSection();

  00747	6a 28		 push	 40			; 00000028H
  00749	89 bd c8 ef ff
	ff		 mov	 DWORD PTR $T193439[ebp+8], edi
  0074f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00754	83 c4 04	 add	 esp, 4
  00757	3b c7		 cmp	 eax, edi
  00759	0f 84 b4 03 00
	00		 je	 $LN1319@ParseFile
  0075f	89 85 c4 ef ff
	ff		 mov	 DWORD PTR $T193439[ebp+4], eax
  00765	89 00		 mov	 DWORD PTR [eax], eax
  00767	8b 85 c4 ef ff
	ff		 mov	 eax, DWORD PTR $T193439[ebp+4]
  0076d	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00770	8b 85 c4 ef ff
	ff		 mov	 eax, DWORD PTR $T193439[ebp+4]
  00776	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00779	8b 95 c4 ef ff
	ff		 mov	 edx, DWORD PTR $T193439[ebp+4]
  0077f	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1
  00783	8b 85 c4 ef ff
	ff		 mov	 eax, DWORD PTR $T193439[ebp+4]
  00789	c6 40 25 01	 mov	 BYTE PTR [eax+37], 1
  0078d	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  00793	8b 08		 mov	 ecx, DWORD PTR [eax]
  00795	50		 push	 eax
  00796	51		 push	 ecx
  00797	8d 8d 5c ef ff
	ff		 lea	 ecx, DWORD PTR $T197555[ebp]
  0079d	51		 push	 ecx
  0079e	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  007a4	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  007a8	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  007ad	8d 95 c0 ef ff
	ff		 lea	 edx, DWORD PTR $T193439[ebp]
  007b3	52		 push	 edx
  007b4	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  007ba	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
  007bf	8b 85 d0 ef ff
	ff		 mov	 eax, DWORD PTR $T193439[ebp+16]
  007c5	89 85 a4 ef ff
	ff		 mov	 DWORD PTR _sec$144171[ebp+16], eax
  007cb	8b 85 c4 ef ff
	ff		 mov	 eax, DWORD PTR $T193439[ebp+4]
  007d1	8b 08		 mov	 ecx, DWORD PTR [eax]
  007d3	50		 push	 eax
  007d4	51		 push	 ecx
  007d5	8d 8d 28 ef ff
	ff		 lea	 ecx, DWORD PTR $T197814[ebp]
  007db	51		 push	 ecx
  007dc	8d 8d c0 ef ff
	ff		 lea	 ecx, DWORD PTR $T193439[ebp]
  007e2	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  007e6	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  007eb	8b 95 c4 ef ff
	ff		 mov	 edx, DWORD PTR $T193439[ebp+4]
  007f1	52		 push	 edx
  007f2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  007f7	83 c4 04	 add	 esp, 4

; 260  : 							sec_open = true;

  007fa	c6 85 b7 ef ff
	ff 01		 mov	 BYTE PTR _sec_open$144175[ebp], 1

; 261  : 							continue;

  00801	8b 85 80 ef ff
	ff		 mov	 eax, DWORD PTR _row$144309[ebp+4]
  00807	8b 08		 mov	 ecx, DWORD PTR [eax]
  00809	50		 push	 eax
  0080a	51		 push	 ecx
  0080b	8d 85 58 ef ff
	ff		 lea	 eax, DWORD PTR $T198057[ebp]
  00811	50		 push	 eax
  00812	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00818	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  0081c	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00821	8b 8d 80 ef ff
	ff		 mov	 ecx, DWORD PTR _row$144309[ebp+4]
  00827	51		 push	 ecx
  00828	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0082d	83 c4 04	 add	 esp, 4
  00830	e9 cd fd ff ff	 jmp	 $LN1352@ParseFile
$LN3@ParseFile:

; 262  : 						}
; 263  : 					}
; 264  : 
; 265  : 					sec.Rows[sec_index++] = row;

  00835	8b 85 90 ef ff
	ff		 mov	 eax, DWORD PTR _sec_index$144174[ebp]
  0083b	89 85 ac ef ff
	ff		 mov	 DWORD PTR $T193440[ebp], eax
  00841	40		 inc	 eax
  00842	89 85 90 ef ff
	ff		 mov	 DWORD PTR _sec_index$144174[ebp], eax
  00848	8d 85 ac ef ff
	ff		 lea	 eax, DWORD PTR $T193440[ebp]
  0084e	50		 push	 eax
  0084f	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  00855	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@$$QAK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  0085a	8b f0		 mov	 esi, eax
  0085c	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00862	3b f1		 cmp	 esi, ecx
  00864	74 23		 je	 SHORT $LN1053@ParseFile
  00866	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00869	8b 08		 mov	 ecx, DWORD PTR [eax]
  0086b	50		 push	 eax
  0086c	51		 push	 ecx
  0086d	8d 95 54 ef ff
	ff		 lea	 edx, DWORD PTR $T198335[ebp]
  00873	52		 push	 edx
  00874	8b ce		 mov	 ecx, esi
  00876	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  0087b	8d 85 7c ef ff
	ff		 lea	 eax, DWORD PTR _row$144309[ebp]
  00881	50		 push	 eax
  00882	8b ce		 mov	 ecx, esi
  00884	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy
$LN1053@ParseFile:
  00889	8b 8d 8c ef ff
	ff		 mov	 ecx, DWORD PTR _row$144309[ebp+16]
  0088f	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 266  : 
; 267  : 				}

  00892	8b 85 80 ef ff
	ff		 mov	 eax, DWORD PTR _row$144309[ebp+4]
  00898	8b 08		 mov	 ecx, DWORD PTR [eax]
  0089a	50		 push	 eax
  0089b	51		 push	 ecx
  0089c	8d 95 a8 ef ff
	ff		 lea	 edx, DWORD PTR $T198585[ebp]
  008a2	52		 push	 edx
  008a3	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  008a9	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  008ad	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  008b2	8b 85 80 ef ff
	ff		 mov	 eax, DWORD PTR _row$144309[ebp+4]
  008b8	50		 push	 eax
  008b9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  008be	83 c4 04	 add	 esp, 4
  008c1	83 bd e8 ef ff
	ff 10		 cmp	 DWORD PTR _line$144181[ebp+20], 16 ; 00000010H
  008c8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  008cc	72 0f		 jb	 SHORT $LN1129@ParseFile
  008ce	8b 8d d4 ef ff
	ff		 mov	 ecx, DWORD PTR _line$144181[ebp]
  008d4	51		 push	 ecx
$LN1350@ParseFile:
  008d5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  008da	83 c4 04	 add	 esp, 4
$LN1129@ParseFile:

; 186  : 				int current_sec = 0;
; 187  : 				int sec_index = 0;
; 188  : 				bool sec_open = false;
; 189  : 
; 190  : 				while(!f.eof())

  008dd	8b 95 70 ee ff
	ff		 mov	 edx, DWORD PTR _f$[ebp]
  008e3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  008e6	f6 84 05 7c ee
	ff ff 01	 test	 BYTE PTR _f$[ebp+eax+12], 1
  008ee	0f 84 1c f8 ff
	ff		 je	 $LL21@ParseFile

; 259  : 							sec = TokenizerSection();

  008f4	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  008f9	33 f6		 xor	 esi, esi
$LN20@ParseFile:

; 268  : 
; 269  : 			}

  008fb	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  00901	8b 08		 mov	 ecx, DWORD PTR [eax]
  00903	50		 push	 eax
  00904	51		 push	 ecx
  00905	8d 95 a8 ef ff
	ff		 lea	 edx, DWORD PTR $T198915[ebp]
  0090b	52		 push	 edx
  0090c	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  00912	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00916	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  0091b	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  00921	50		 push	 eax
  00922	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00926	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0092b	83 c4 04	 add	 esp, 4

; 274  : 			}
; 275  : 			
; 276  : 			f.close();

  0092e	8d 8d 88 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+24]
  00934	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00939	85 c0		 test	 eax, eax
  0093b	75 29		 jne	 SHORT $LN1229@ParseFile
  0093d	8b 8d 70 ee ff
	ff		 mov	 ecx, DWORD PTR _f$[ebp]
  00943	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00946	8b 84 0d 7c ee
	ff ff		 mov	 eax, DWORD PTR _f$[ebp+ecx+12]
  0094d	8d 8c 0d 70 ee
	ff ff		 lea	 ecx, DWORD PTR _f$[ebp+ecx]
  00954	83 c8 02	 or	 eax, 2
  00957	39 71 38	 cmp	 DWORD PTR [ecx+56], esi
  0095a	75 03		 jne	 SHORT $LN1231@ParseFile
  0095c	83 c8 04	 or	 eax, 4
$LN1231@ParseFile:
  0095f	56		 push	 esi
  00960	50		 push	 eax
  00961	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN1229@ParseFile:

; 277  : 
; 278  : 			return true;

  00966	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  0096c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00970	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  00975	8d 95 e0 ee ff
	ff		 lea	 edx, DWORD PTR _f$[ebp+112]
  0097b	52		 push	 edx
  0097c	c7 85 e0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _f$[ebp+112], OFFSET ??_7ios_base@std@@6B@
  00986	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0098b	83 c4 04	 add	 esp, 4
  0098e	39 7d 1c	 cmp	 DWORD PTR _file$[ebp+20], edi
  00991	72 0c		 jb	 SHORT $LN1250@ParseFile
  00993	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00996	50		 push	 eax
  00997	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0099c	83 c4 04	 add	 esp, 4
$LN1250@ParseFile:
  0099f	b0 01		 mov	 al, 1
  009a1	e9 ac 02 00 00	 jmp	 $LN24@ParseFile
$LN1309@ParseFile:

; 229  : 					{
; 230  : 						line.erase(k, 1);

  009a6	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  009ab	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN1354@ParseFile:
$LN1315@ParseFile:

; 238  : 						{
; 239  : 							return false; // falha de sintaxe

  009b0	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  009b5	39 b5 e8 ef ff
	ff		 cmp	 DWORD PTR _line$144181[ebp+20], esi
  009bb	72 0f		 jb	 SHORT $LN367@ParseFile
  009bd	8b 8d d4 ef ff
	ff		 mov	 ecx, DWORD PTR _line$144181[ebp]
  009c3	51		 push	 ecx
  009c4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  009c9	83 c4 04	 add	 esp, 4
$LN367@ParseFile:
  009cc	c7 85 e8 ef ff
	ff 0f 00 00 00	 mov	 DWORD PTR _line$144181[ebp+20], 15 ; 0000000fH
  009d6	89 bd e4 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+16], edi
  009dc	c6 85 d4 ef ff
	ff 00		 mov	 BYTE PTR _line$144181[ebp], 0
  009e3	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  009e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  009eb	50		 push	 eax
  009ec	51		 push	 ecx
  009ed	8d 95 a8 ef ff
	ff		 lea	 edx, DWORD PTR $T194928[ebp]
  009f3	52		 push	 edx
  009f4	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  009fa	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  009fe	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00a03	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  00a09	50		 push	 eax
  00a0a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a0f	83 c4 04	 add	 esp, 4
  00a12	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  00a18	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00a1c	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  00a21	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  00a27	51		 push	 ecx
  00a28	c7 85 e0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _f$[ebp+112], OFFSET ??_7ios_base@std@@6B@
  00a32	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00a37	83 c4 04	 add	 esp, 4
  00a3a	39 75 1c	 cmp	 DWORD PTR _file$[ebp+20], esi
  00a3d	0f 82 0d 02 00
	00		 jb	 $LN1279@ParseFile
  00a43	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00a46	52		 push	 edx
  00a47	e9 fc 01 00 00	 jmp	 $LN1353@ParseFile
$LN1318@ParseFile:

; 251  : 						return false;

  00a4c	8b 85 80 ef ff
	ff		 mov	 eax, DWORD PTR _row$144309[ebp+4]
  00a52	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a54	50		 push	 eax
  00a55	51		 push	 ecx
  00a56	8d 85 a8 ef ff
	ff		 lea	 eax, DWORD PTR $T196497[ebp]
  00a5c	50		 push	 eax
  00a5d	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00a63	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00a67	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00a6c	8b 8d 80 ef ff
	ff		 mov	 ecx, DWORD PTR _row$144309[ebp+4]
  00a72	51		 push	 ecx
  00a73	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a78	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
  00a7d	83 c4 04	 add	 esp, 4
  00a80	39 9d e8 ef ff
	ff		 cmp	 DWORD PTR _line$144181[ebp+20], ebx
  00a86	72 0f		 jb	 SHORT $LN744@ParseFile
  00a88	8b 95 d4 ef ff
	ff		 mov	 edx, DWORD PTR _line$144181[ebp]
  00a8e	52		 push	 edx
  00a8f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a94	83 c4 04	 add	 esp, 4
$LN744@ParseFile:
  00a97	89 b5 e8 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+20], esi
  00a9d	89 bd e4 ef ff
	ff		 mov	 DWORD PTR _line$144181[ebp+16], edi
  00aa3	c6 85 d4 ef ff
	ff 00		 mov	 BYTE PTR _line$144181[ebp], 0
  00aaa	8b 85 98 ef ff
	ff		 mov	 eax, DWORD PTR _sec$144171[ebp+4]
  00ab0	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ab2	50		 push	 eax
  00ab3	51		 push	 ecx
  00ab4	8d 85 a8 ef ff
	ff		 lea	 eax, DWORD PTR $T196824[ebp]
  00aba	50		 push	 eax
  00abb	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  00ac1	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00ac5	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00aca	8b 8d 98 ef ff
	ff		 mov	 ecx, DWORD PTR _sec$144171[ebp+4]
  00ad0	51		 push	 ecx
  00ad1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ad6	83 c4 04	 add	 esp, 4
  00ad9	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  00adf	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00ae3	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  00ae8	8d 95 e0 ee ff
	ff		 lea	 edx, DWORD PTR _f$[ebp+112]
  00aee	52		 push	 edx
  00aef	c7 85 e0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _f$[ebp+112], OFFSET ??_7ios_base@std@@6B@
  00af9	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00afe	83 c4 04	 add	 esp, 4
  00b01	39 5d 1c	 cmp	 DWORD PTR _file$[ebp+20], ebx
  00b04	0f 82 46 01 00
	00		 jb	 $LN1279@ParseFile
  00b0a	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00b0d	50		 push	 eax
  00b0e	e9 35 01 00 00	 jmp	 $LN1353@ParseFile
$LN1319@ParseFile:

; 259  : 							sec = TokenizerSection();

  00b13	8d 8d 74 ef ff
	ff		 lea	 ecx, DWORD PTR $T197168[ebp]
  00b19	51		 push	 ecx
  00b1a	8d 8d 2c ef ff
	ff		 lea	 ecx, DWORD PTR $T197364[ebp]
  00b20	89 bd 74 ef ff
	ff		 mov	 DWORD PTR $T197168[ebp], edi
  00b26	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00b2b	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00b30	8d 95 2c ef ff
	ff		 lea	 edx, DWORD PTR $T197364[ebp]
  00b36	52		 push	 edx
  00b37	c7 85 2c ef ff
	ff 00 00 00 00	 mov	 DWORD PTR $T197364[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00b41	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1355@ParseFile:

; 248  : 
; 249  : 					TokenizerRow row;

$LN646@ParseFile:
  00b46	8d 85 70 ef ff
	ff		 lea	 eax, DWORD PTR $T195963[ebp]
  00b4c	50		 push	 eax
  00b4d	8d 8d 38 ef ff
	ff		 lea	 ecx, DWORD PTR $T196158[ebp]
  00b53	89 bd 70 ef ff
	ff		 mov	 DWORD PTR $T195963[ebp], edi
  00b59	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00b5e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00b63	8d 8d 38 ef ff
	ff		 lea	 ecx, DWORD PTR $T196158[ebp]
  00b69	51		 push	 ecx
  00b6a	c7 85 38 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR $T196158[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00b74	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1356@ParseFile:

; 183  : 			{
; 184  : 
; 185  : 				TokenizerSection sec = TokenizerSection();

$LN76@ParseFile:
  00b79	8d 8d 68 ef ff
	ff		 lea	 ecx, DWORD PTR $T193531[ebp]
  00b7f	51		 push	 ecx
  00b80	8d 8d 48 ef ff
	ff		 lea	 ecx, DWORD PTR $T193703[ebp]
  00b86	89 b5 68 ef ff
	ff		 mov	 DWORD PTR $T193531[ebp], esi
  00b8c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00b91	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00b96	8d 95 48 ef ff
	ff		 lea	 edx, DWORD PTR $T193703[ebp]
  00b9c	52		 push	 edx
  00b9d	c7 85 48 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR $T193703[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00ba7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1357@ParseFile:
$LN22@ParseFile:

; 270  : 			else
; 271  : 			{
; 272  : 				f.close();

  00bac	8d 8d 88 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+24]
  00bb2	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00bb7	85 c0		 test	 eax, eax
  00bb9	75 29		 jne	 SHORT $LN1188@ParseFile
  00bbb	8b 85 70 ee ff
	ff		 mov	 eax, DWORD PTR _f$[ebp]
  00bc1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00bc4	8b 84 0d 7c ee
	ff ff		 mov	 eax, DWORD PTR _f$[ebp+ecx+12]
  00bcb	8d 8c 0d 70 ee
	ff ff		 lea	 ecx, DWORD PTR _f$[ebp+ecx]
  00bd2	83 c8 02	 or	 eax, 2
  00bd5	39 71 38	 cmp	 DWORD PTR [ecx+56], esi
  00bd8	75 03		 jne	 SHORT $LN1190@ParseFile
  00bda	83 c8 04	 or	 eax, 4
$LN1190@ParseFile:
  00bdd	56		 push	 esi
  00bde	50		 push	 eax
  00bdf	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN1188@ParseFile:

; 273  : 				return false;

  00be4	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  00bea	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00bee	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  00bf3	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  00bf9	51		 push	 ecx
  00bfa	c7 85 e0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _f$[ebp+112], OFFSET ??_7ios_base@std@@6B@
  00c04	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00c09	83 c4 04	 add	 esp, 4
  00c0c	39 7d 1c	 cmp	 DWORD PTR _file$[ebp+20], edi
  00c0f	72 3f		 jb	 SHORT $LN1279@ParseFile
  00c11	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00c14	52		 push	 edx
  00c15	eb 31		 jmp	 SHORT $LN1353@ParseFile
$LN23@ParseFile:

; 279  : 
; 280  : 		}
; 281  : 		else
; 282  : 		{
; 283  : 			return false;

  00c17	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp+112]
  00c1d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00c21	e8 00 00 00 00	 call	 ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
  00c26	8d 85 e0 ee ff
	ff		 lea	 eax, DWORD PTR _f$[ebp+112]
  00c2c	50		 push	 eax
  00c2d	c7 85 e0 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _f$[ebp+112], OFFSET ??_7ios_base@std@@6B@
  00c37	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00c3c	83 c4 04	 add	 esp, 4
  00c3f	39 7d 1c	 cmp	 DWORD PTR _file$[ebp+20], edi
  00c42	72 0c		 jb	 SHORT $LN1279@ParseFile
  00c44	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00c47	51		 push	 ecx
$LN1353@ParseFile:
  00c48	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c4d	83 c4 04	 add	 esp, 4
$LN1279@ParseFile:
  00c50	32 c0		 xor	 al, al
$LN24@ParseFile:

; 284  : 		}
; 285  : 
; 286  : 	}

  00c52	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00c55	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00c5c	59		 pop	 ecx
  00c5d	5f		 pop	 edi
  00c5e	5e		 pop	 esi
  00c5f	5b		 pop	 ebx
  00c60	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c63	33 cd		 xor	 ecx, ebp
  00c65	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c6a	8b e5		 mov	 esp, ebp
  00c6c	5d		 pop	 ebp
  00c6d	c2 20 00	 ret	 32			; 00000020H
$LN1347@ParseFile:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _file$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$1:
  00008	8d 8d 70 ee ff
	ff		 lea	 ecx, DWORD PTR _f$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$2:
  00013	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1TokenizerSection@@QAE@XZ
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$3:
  0001e	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR _line$144181[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$4:
  00029	8d 8d b8 ef ff
	ff		 lea	 ecx, DWORD PTR $T144195[ebp]
  0002f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$5:
  00034	8d 8d b8 ef ff
	ff		 lea	 ecx, DWORD PTR $T144289[ebp]
  0003a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$6:
  0003f	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00045	e9 00 00 00 00	 jmp	 ??1TokenizerRow@@QAE@XZ
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$8:
  0004a	8d 8d c0 ef ff
	ff		 lea	 ecx, DWORD PTR $T193439[ebp]
  00050	e9 00 00 00 00	 jmp	 ??1TokenizerSection@@QAE@XZ
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$31:
  00055	8d 8d c0 ef ff
	ff		 lea	 ecx, DWORD PTR $T193439[ebp]
  0005b	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$34:
  00060	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00066	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$37:
  0006b	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00071	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$40:
  00076	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  0007c	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$14:
  00081	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  00087	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$21:
  0008c	8d 8d 7c ef ff
	ff		 lea	 ecx, DWORD PTR _row$144309[ebp]
  00092	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
__unwindfunclet$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z$24:
  00097	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR _sec$144171[ebp]
  0009d	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__ehhandler$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z:
  000a2	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000a6	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000a9	8b 8a 6c ee ff
	ff		 mov	 ecx, DWORD PTR [edx-4500]
  000af	33 c8		 xor	 ecx, eax
  000b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b6	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000b9	33 c8		 xor	 ecx, eax
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z
  000c5	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z ENDP ; Tokenizer::ParseFile
PUBLIC	??0TokenizerGroup@@QAE@XZ			; TokenizerGroup::TokenizerGroup
; Function compile flags: /Ogtp
;	COMDAT ??0TokenizerGroup@@QAE@XZ
_TEXT	SEGMENT
$T199575 = -16						; size = 12
$T199423 = -4						; size = 4
??0TokenizerGroup@@QAE@XZ PROC				; TokenizerGroup::TokenizerGroup, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN28@TokenizerG
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al
  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN28@TokenizerG:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T199423[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T199575[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T199423[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T199575[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T199575[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN53@TokenizerG:
$LN52@TokenizerG:
  0006c	cc		 int	 3
??0TokenizerGroup@@QAE@XZ ENDP				; TokenizerGroup::TokenizerGroup
_TEXT	ENDS
PUBLIC	??1TokenizerGroup@@QAE@XZ			; TokenizerGroup::~TokenizerGroup
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TokenizerGroup@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TokenizerGroup@@QAE@XZ$2
__ehfuncinfo$??1TokenizerGroup@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1TokenizerGroup@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1TokenizerGroup@@QAE@XZ
_TEXT	SEGMENT
$T199788 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TokenizerGroup@@QAE@XZ PROC				; TokenizerGroup::~TokenizerGroup, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1TokenizerGroup@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T199788[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TokenizerGroup@@QAE@XZ$2:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
__ehhandler$??1TokenizerGroup@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1TokenizerGroup@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1TokenizerGroup@@QAE@XZ ENDP				; TokenizerGroup::~TokenizerGroup
PUBLIC	??_C@_0CE@LCGPCNNO@?4?2Customs?2Systems?2Hgt_ItemBlock?4@ ; `string'
PUBLIC	?Load@CItemBlock@@QAEXXZ			; CItemBlock::Load
;	COMDAT ??_C@_0CE@LCGPCNNO@?4?2Customs?2Systems?2Hgt_ItemBlock?4@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
CONST	SEGMENT
??_C@_0CE@LCGPCNNO@?4?2Customs?2Systems?2Hgt_ItemBlock?4@ DB '.\Customs\S'
	DB	'ystems\Hgt_ItemBlock.ini', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Load@CItemBlock@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CItemBlock@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@CItemBlock@@QAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@CItemBlock@@QAEXXZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CItemBlock@@QAEXXZ$14
__ehfuncinfo$?Load@CItemBlock@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?Load@CItemBlock@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\itemblock.cpp
xdata$x	ENDS
;	COMDAT ?Load@CItemBlock@@QAEXXZ
_TEXT	SEGMENT
_Section$ = -92						; size = 20
_Class$ = -72						; size = 16
$T200065 = -56						; size = 12
_token$ = -56						; size = 12
$T200331 = -44						; size = 12
$T202897 = -32						; size = 4
$T202636 = -32						; size = 4
$T200136 = -32						; size = 4
$T202293 = -28						; size = 4
$T200772 = -28						; size = 4
$T199871 = -28						; size = 4
$T199817 = -28						; size = 4
$T201758 = -24						; size = 4
__Where$202364 = -20					; size = 4
__Where$201753 = -20					; size = 4
__Where$201278 = -20					; size = 4
_it$200736 = -20					; size = 4
$T199820 = -20						; size = 4
$T199819 = -20						; size = 4
$T199818 = -20						; size = 4
$T201207 = -16						; size = 4
$T200782 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Load@CItemBlock@@QAEXXZ PROC				; CItemBlock::Load, COMDAT
; _this$ = ecx

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Load@CItemBlock@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 7    : 	Tokenizer          token;
; 8    : 	TokenizerGroup     Class;

  0002a	33 db		 xor	 ebx, ebx
  0002c	6a 28		 push	 40			; 00000028H
  0002e	89 5d c0	 mov	 DWORD PTR _Class$[ebp+8], ebx
  00031	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00036	83 c4 04	 add	 esp, 4
  00039	3b c3		 cmp	 eax, ebx
  0003b	0f 84 c1 02 00
	00		 je	 $LN37@Load
  00041	89 45 bc	 mov	 DWORD PTR _Class$[ebp+4], eax
  00044	89 00		 mov	 DWORD PTR [eax], eax
  00046	8b 45 bc	 mov	 eax, DWORD PTR _Class$[ebp+4]
  00049	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0004c	8b 45 bc	 mov	 eax, DWORD PTR _Class$[ebp+4]
  0004f	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00052	8b 45 bc	 mov	 eax, DWORD PTR _Class$[ebp+4]
  00055	c6 40 24 01	 mov	 BYTE PTR [eax+36], 1
  00059	8b 4d bc	 mov	 ecx, DWORD PTR _Class$[ebp+4]
  0005c	c6 41 25 01	 mov	 BYTE PTR [ecx+37], 1

; 9    : 	TokenizerSection   Section;

  00060	6a 28		 push	 40			; 00000028H
  00062	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00065	89 5d ac	 mov	 DWORD PTR _Section$[ebp+8], ebx
  00068	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0006d	83 c4 04	 add	 esp, 4
  00070	3b c3		 cmp	 eax, ebx
  00072	0f 84 66 02 00
	00		 je	 $LN88@Load
  00078	89 45 a8	 mov	 DWORD PTR _Section$[ebp+4], eax
  0007b	89 00		 mov	 DWORD PTR [eax], eax
  0007d	8b 45 a8	 mov	 eax, DWORD PTR _Section$[ebp+4]
  00080	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00083	8b 45 a8	 mov	 eax, DWORD PTR _Section$[ebp+4]
  00086	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00089	8b 55 a8	 mov	 edx, DWORD PTR _Section$[ebp+4]
  0008c	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1
  00090	8b 45 a8	 mov	 eax, DWORD PTR _Section$[ebp+4]
  00093	c6 40 25 01	 mov	 BYTE PTR [eax+37], 1

; 10   : 	// ---
; 11   : 	token.ParseFile(std::string(ITEMBLOCK_FILE), Class);

  00097	8d 4d b8	 lea	 ecx, DWORD PTR _Class$[ebp]
  0009a	51		 push	 ecx
  0009b	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0009e	8b cc		 mov	 ecx, esp
  000a0	89 65 e4	 mov	 DWORD PTR $T199817[ebp], esp
  000a3	6a 23		 push	 35			; 00000023H
  000a5	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  000ac	89 59 10	 mov	 DWORD PTR [ecx+16], ebx
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LCGPCNNO@?4?2Customs?2Systems?2Hgt_ItemBlock?4@
  000b4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000b8	88 19		 mov	 BYTE PTR [ecx], bl
  000ba	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000bf	8d 4d c8	 lea	 ecx, DWORD PTR _token$[ebp]
  000c2	e8 00 00 00 00	 call	 ?ParseFile@Tokenizer@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVTokenizerGroup@@@Z ; Tokenizer::ParseFile

; 12   : 	// ---	
; 13   : 	if(Class.GetSection(0, Section))

  000c7	8d 55 f0	 lea	 edx, DWORD PTR $T200782[ebp]
  000ca	52		 push	 edx
  000cb	8d 45 ec	 lea	 eax, DWORD PTR _it$200736[ebp]
  000ce	50		 push	 eax
  000cf	8d 4d b8	 lea	 ecx, DWORD PTR _Class$[ebp]
  000d2	89 5d f0	 mov	 DWORD PTR $T200782[ebp], ebx
  000d5	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::find
  000da	8b 45 ec	 mov	 eax, DWORD PTR _it$200736[ebp]
  000dd	3b 45 bc	 cmp	 eax, DWORD PTR _Class$[ebp+4]
  000e0	0f 84 9d 01 00
	00		 je	 $LN1@Load
  000e6	8d 70 10	 lea	 esi, DWORD PTR [eax+16]
  000e9	8d 4d a4	 lea	 ecx, DWORD PTR _Section$[ebp]
  000ec	3b ce		 cmp	 ecx, esi
  000ee	74 1c		 je	 SHORT $LN169@Load
  000f0	8b 45 a8	 mov	 eax, DWORD PTR _Section$[ebp+4]
  000f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f5	50		 push	 eax
  000f6	51		 push	 ecx
  000f7	8d 55 e4	 lea	 edx, DWORD PTR $T200772[ebp]
  000fa	52		 push	 edx
  000fb	8d 4d a4	 lea	 ecx, DWORD PTR _Section$[ebp]
  000fe	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  00103	56		 push	 esi
  00104	8d 4d a4	 lea	 ecx, DWORD PTR _Section$[ebp]
  00107	e8 00 00 00 00	 call	 ?_Copy@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::_Copy
$LN169@Load:
  0010c	8b 76 10	 mov	 esi, DWORD PTR [esi+16]
  0010f	89 75 b4	 mov	 DWORD PTR _Section$[ebp+16], esi

; 14   : 	{	
; 15   : 		for(int i = 0; i < Section.RowCount; i++)

  00112	85 f6		 test	 esi, esi
  00114	0f 8e 69 01 00
	00		 jle	 $LN1@Load
  0011a	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  0011f	90		 npad	 1
$LL3@Load:

; 16   : 		{
; 17   : 			this->m_Data[this->iCount].Type			= Section.Rows[i].GetInt(0);

  00120	8d 45 ec	 lea	 eax, DWORD PTR $T199818[ebp]
  00123	50		 push	 eax
  00124	8d 4d a4	 lea	 ecx, DWORD PTR _Section$[ebp]
  00127	89 5d ec	 mov	 DWORD PTR $T199818[ebp], ebx
  0012a	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  0012f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00132	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00135	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00139	75 0f		 jne	 SHORT $LN208@Load
  0013b	eb 03 8d 49 00	 npad	 5
$LL209@Load:
  00140	8b d1		 mov	 edx, ecx
  00142	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00144	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00148	74 f6		 je	 SHORT $LL209@Load
$LN208@Load:
  0014a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014d	89 55 ec	 mov	 DWORD PTR __Where$201278[ebp], edx
  00150	3b d0		 cmp	 edx, eax
  00152	74 0b		 je	 SHORT $LN202@Load
  00154	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00158	77 05		 ja	 SHORT $LN202@Load
  0015a	8d 4d ec	 lea	 ecx, DWORD PTR __Where$201278[ebp]
  0015d	eb 06		 jmp	 SHORT $LN203@Load
$LN202@Load:
  0015f	89 45 f0	 mov	 DWORD PTR $T201207[ebp], eax
  00162	8d 4d f0	 lea	 ecx, DWORD PTR $T201207[ebp]
$LN203@Load:
  00165	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00167	3b c8		 cmp	 ecx, eax
  00169	75 05		 jne	 SHORT $LN197@Load
  0016b	83 c8 ff	 or	 eax, -1
  0016e	eb 13		 jmp	 SHORT $LN198@Load
$LN197@Load:
  00170	39 71 24	 cmp	 DWORD PTR [ecx+36], esi
  00173	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00176	72 02		 jb	 SHORT $LN308@Load
  00178	8b 00		 mov	 eax, DWORD PTR [eax]
$LN308@Load:
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 _atoi
  00180	83 c4 04	 add	 esp, 4
$LN198@Load:
  00183	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00185	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]

; 18   : 			this->m_Data[this->iCount].ID			= Section.Rows[i].GetInt(1);

  00188	8d 55 ec	 lea	 edx, DWORD PTR $T199819[ebp]
  0018b	89 44 8f 04	 mov	 DWORD PTR [edi+ecx*4+4], eax
  0018f	52		 push	 edx
  00190	8d 4d a4	 lea	 ecx, DWORD PTR _Section$[ebp]
  00193	89 5d ec	 mov	 DWORD PTR $T199819[ebp], ebx
  00196	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  0019b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0019e	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001a1	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  001a5	75 15		 jne	 SHORT $LN322@Load
$LL323@Load:
  001a7	83 79 0c 01	 cmp	 DWORD PTR [ecx+12], 1
  001ab	73 05		 jae	 SHORT $LN321@Load
  001ad	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  001b0	eb 04		 jmp	 SHORT $LN320@Load
$LN321@Load:
  001b2	8b d1		 mov	 edx, ecx
  001b4	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN320@Load:
  001b6	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  001ba	74 eb		 je	 SHORT $LL323@Load
$LN322@Load:
  001bc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001bf	89 55 ec	 mov	 DWORD PTR __Where$201753[ebp], edx
  001c2	3b d0		 cmp	 edx, eax
  001c4	74 0b		 je	 SHORT $LN316@Load
  001c6	83 7a 0c 01	 cmp	 DWORD PTR [edx+12], 1
  001ca	77 05		 ja	 SHORT $LN316@Load
  001cc	8d 4d ec	 lea	 ecx, DWORD PTR __Where$201753[ebp]
  001cf	eb 06		 jmp	 SHORT $LN317@Load
$LN316@Load:
  001d1	89 45 e8	 mov	 DWORD PTR $T201758[ebp], eax
  001d4	8d 4d e8	 lea	 ecx, DWORD PTR $T201758[ebp]
$LN317@Load:
  001d7	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001d9	3b c8		 cmp	 ecx, eax
  001db	75 05		 jne	 SHORT $LN311@Load
  001dd	83 c8 ff	 or	 eax, -1
  001e0	eb 13		 jmp	 SHORT $LN312@Load
$LN311@Load:
  001e2	39 71 24	 cmp	 DWORD PTR [ecx+36], esi
  001e5	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  001e8	72 02		 jb	 SHORT $LN422@Load
  001ea	8b 00		 mov	 eax, DWORD PTR [eax]
$LN422@Load:
  001ec	50		 push	 eax
  001ed	e8 00 00 00 00	 call	 _atoi
  001f2	83 c4 04	 add	 esp, 4
$LN312@Load:
  001f5	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001f7	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]

; 19   : 			this->m_Data[this->iCount].Level		= Section.Rows[i].GetInt(2);

  001fa	8d 55 ec	 lea	 edx, DWORD PTR $T199820[ebp]
  001fd	89 44 8f 08	 mov	 DWORD PTR [edi+ecx*4+8], eax
  00201	52		 push	 edx
  00202	8d 4d a4	 lea	 ecx, DWORD PTR _Section$[ebp]
  00205	89 5d ec	 mov	 DWORD PTR $T199820[ebp], ebx
  00208	e8 00 00 00 00	 call	 ??A?$map@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@@std@@QAEAAVTokenizerRow@@ABK@Z ; std::map<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> > >::operator[]
  0020d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00210	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00213	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00217	75 1c		 jne	 SHORT $LN436@Load
  00219	8d a4 24 00 00
	00 00		 npad	 7
$LL437@Load:
  00220	83 79 0c 02	 cmp	 DWORD PTR [ecx+12], 2
  00224	73 05		 jae	 SHORT $LN435@Load
  00226	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00229	eb 04		 jmp	 SHORT $LN434@Load
$LN435@Load:
  0022b	8b d1		 mov	 edx, ecx
  0022d	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN434@Load:
  0022f	80 79 2d 00	 cmp	 BYTE PTR [ecx+45], 0
  00233	74 eb		 je	 SHORT $LL437@Load
$LN436@Load:
  00235	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00238	89 55 ec	 mov	 DWORD PTR __Where$202364[ebp], edx
  0023b	3b d0		 cmp	 edx, eax
  0023d	74 0b		 je	 SHORT $LN430@Load
  0023f	83 7a 0c 02	 cmp	 DWORD PTR [edx+12], 2
  00243	77 05		 ja	 SHORT $LN430@Load
  00245	8d 4d ec	 lea	 ecx, DWORD PTR __Where$202364[ebp]
  00248	eb 06		 jmp	 SHORT $LN431@Load
$LN430@Load:
  0024a	89 45 e4	 mov	 DWORD PTR $T202293[ebp], eax
  0024d	8d 4d e4	 lea	 ecx, DWORD PTR $T202293[ebp]
$LN431@Load:
  00250	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00252	3b c8		 cmp	 ecx, eax
  00254	75 05		 jne	 SHORT $LN425@Load
  00256	83 c8 ff	 or	 eax, -1
  00259	eb 13		 jmp	 SHORT $LN426@Load
$LN425@Load:
  0025b	39 71 24	 cmp	 DWORD PTR [ecx+36], esi
  0025e	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00261	72 02		 jb	 SHORT $LN536@Load
  00263	8b 00		 mov	 eax, DWORD PTR [eax]
$LN536@Load:
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 _atoi
  0026b	83 c4 04	 add	 esp, 4
$LN426@Load:
  0026e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00270	8d 4c 49 03	 lea	 ecx, DWORD PTR [ecx+ecx*2+3]
  00274	89 04 8f	 mov	 DWORD PTR [edi+ecx*4], eax

; 20   : 			// ---
; 21   : 			this->iCount++;

  00277	ff 07		 inc	 DWORD PTR [edi]
  00279	43		 inc	 ebx
  0027a	3b 5d b4	 cmp	 ebx, DWORD PTR _Section$[ebp+16]
  0027d	0f 8c 9d fe ff
	ff		 jl	 $LL3@Load
$LN1@Load:

; 22   : 		}
; 23   : 	}
; 24   : }

  00283	8b 45 a8	 mov	 eax, DWORD PTR _Section$[ebp+4]
  00286	8b 08		 mov	 ecx, DWORD PTR [eax]
  00288	50		 push	 eax
  00289	51		 push	 ecx
  0028a	8d 55 e0	 lea	 edx, DWORD PTR $T202636[ebp]
  0028d	52		 push	 edx
  0028e	8d 4d a4	 lea	 ecx, DWORD PTR _Section$[ebp]
  00291	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00295	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::erase
  0029a	8b 45 a8	 mov	 eax, DWORD PTR _Section$[ebp+4]
  0029d	50		 push	 eax
  0029e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002a3	83 c4 04	 add	 esp, 4
  002a6	8b 45 bc	 mov	 eax, DWORD PTR _Class$[ebp+4]
  002a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ab	50		 push	 eax
  002ac	51		 push	 ecx
  002ad	8d 4d e0	 lea	 ecx, DWORD PTR $T202897[ebp]
  002b0	51		 push	 ecx
  002b1	8d 4d b8	 lea	 ecx, DWORD PTR _Class$[ebp]
  002b4	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  002bb	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::erase
  002c0	8b 55 bc	 mov	 edx, DWORD PTR _Class$[ebp+4]
  002c3	52		 push	 edx
  002c4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002c9	83 c4 04	 add	 esp, 4
  002cc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002d6	59		 pop	 ecx
  002d7	5f		 pop	 edi
  002d8	5e		 pop	 esi
  002d9	5b		 pop	 ebx
  002da	8b e5		 mov	 esp, ebp
  002dc	5d		 pop	 ebp
  002dd	c3		 ret	 0

; 9    : 	TokenizerSection   Section;

$LN88@Load:
  002de	8d 45 e0	 lea	 eax, DWORD PTR $T200136[ebp]
  002e1	50		 push	 eax
  002e2	8d 4d d4	 lea	 ecx, DWORD PTR $T200331[ebp]
  002e5	89 5d e0	 mov	 DWORD PTR $T200136[ebp], ebx
  002e8	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  002ed	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  002f2	8d 4d d4	 lea	 ecx, DWORD PTR $T200331[ebp]
  002f5	51		 push	 ecx
  002f6	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T200331[ebp], OFFSET ??_7bad_alloc@std@@6B@
  002fd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN628@Load:

; 7    : 	Tokenizer          token;
; 8    : 	TokenizerGroup     Class;

$LN37@Load:
  00302	8d 55 e4	 lea	 edx, DWORD PTR $T199871[ebp]
  00305	52		 push	 edx
  00306	8d 4d c8	 lea	 ecx, DWORD PTR $T200065[ebp]
  00309	89 5d e4	 mov	 DWORD PTR $T199871[ebp], ebx
  0030c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00311	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00316	8d 45 c8	 lea	 eax, DWORD PTR $T200065[ebp]
  00319	50		 push	 eax
  0031a	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T200065[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00321	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN629@Load:
$LN627@Load:
  00326	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Load@CItemBlock@@QAEXXZ$0:
  00000	8d 4d b8	 lea	 ecx, DWORD PTR _Class$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TokenizerGroup@@QAE@XZ
__unwindfunclet$?Load@CItemBlock@@QAEXXZ$1:
  00008	8d 4d a4	 lea	 ecx, DWORD PTR _Section$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1TokenizerSection@@QAE@XZ
__unwindfunclet$?Load@CItemBlock@@QAEXXZ$11:
  00010	8d 4d a4	 lea	 ecx, DWORD PTR _Section$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerRow@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerRow@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerRow,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerRow> >,0> >
__unwindfunclet$?Load@CItemBlock@@QAEXXZ$14:
  00018	8d 4d b8	 lea	 ecx, DWORD PTR _Class$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@KVTokenizerSection@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKVTokenizerSection@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,TokenizerSection,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,TokenizerSection> >,0> >
__ehhandler$?Load@CItemBlock@@QAEXXZ:
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CItemBlock@@QAEXXZ
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CItemBlock@@QAEXXZ ENDP				; CItemBlock::Load
PUBLIC	?id@?$codecvt@DDH@std@@2V0locale@2@A		; std::codecvt<char,char,int>::id
;	COMDAT ?id@?$codecvt@DDH@std@@2V0locale@2@A
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
_BSS	SEGMENT
?id@?$codecvt@DDH@std@@2V0locale@2@A DD 01H DUP (?)	; std::codecvt<char,char,int>::id
_BSS	ENDS
END
