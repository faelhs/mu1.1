; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\MuLua.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	?DoFile@MULua@@QAE_NPBD@Z			; MULua::DoFile
EXTRN	_lua_pcallk:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	_lua_settop:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_lua_tolstring:PROC
EXTRN	_luaL_loadfilex:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
;	COMDAT ??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\mulua.cpp
CONST	SEGMENT
??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@ DB 'E'
	DB	'rror!!, : %s : State = %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@ DB 'Error!!, : %s', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DoFile@MULua@@QAE_NPBD@Z
_TEXT	SEGMENT
_szFileName$ = 8					; size = 4
?DoFile@MULua@@QAE_NPBD@Z PROC				; MULua::DoFile, COMDAT
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 17   : 	if (this->m_bUseSync == true)

  00007	b3 01		 mov	 bl, 1
  00009	38 5e 1c	 cmp	 BYTE PTR [esi+28], bl
  0000c	75 0a		 jne	 SHORT $LN6@DoFile

; 18   : 	{
; 19   : 		EnterCriticalSection(&this->m_luaCritical);

  0000e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
$LN6@DoFile:

; 20   : 	}
; 21   : 
; 22   : 	int iState = 0;
; 23   : 
; 24   : 	if ( luaL_loadfile(m_luaState, szFileName) )

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _szFileName$[ebp]
  0001b	8b 16		 mov	 edx, DWORD PTR [esi]
  0001d	6a 00		 push	 0
  0001f	51		 push	 ecx
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 _luaL_loadfilex
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25   : 	{		
; 26   : 		MsgBox("Error!!, : %s\n", lua_tolstring(m_luaState, -1, 0) );

  00029	6a 00		 push	 0
  0002b	85 c0		 test	 eax, eax
  0002d	74 39		 je	 SHORT $LN5@DoFile
  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	6a ff		 push	 -1
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _lua_tolstring
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@
  0003f	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 27   : 		lua_pop(m_luaState, 1);

  00044	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00046	6a fe		 push	 -2			; fffffffeH
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 _lua_settop
  0004e	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN9@DoFile:

; 28   : 
; 29   : 		if (this->m_bUseSync == true)

  00051	38 5e 1c	 cmp	 BYTE PTR [esi+28], bl
  00054	75 0a		 jne	 SHORT $LN4@DoFile

; 30   : 		{
; 31   : 			LeaveCriticalSection(&this->m_luaCritical);

  00056	83 c6 04	 add	 esi, 4
  00059	56		 push	 esi
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN4@DoFile:

; 32   : 		}
; 33   : 
; 34   : 		return false;

  00060	5e		 pop	 esi
  00061	32 c0		 xor	 al, al
  00063	5b		 pop	 ebx

; 58   : }

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN5@DoFile:

; 35   : 	}
; 36   : 
; 37   :     iState = lua_pcall(m_luaState, 0, -1, 0);

  00068	8b 16		 mov	 edx, DWORD PTR [esi]
  0006a	6a 00		 push	 0
  0006c	6a 00		 push	 0
  0006e	6a ff		 push	 -1
  00070	6a 00		 push	 0
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 _lua_pcallk
  00078	83 c4 18	 add	 esp, 24			; 00000018H

; 38   : 
; 39   : 	if ( iState )

  0007b	85 c0		 test	 eax, eax
  0007d	74 2a		 je	 SHORT $LN3@DoFile

; 40   : 	{
; 41   : 		MsgBox("Error!!, : %s : State = %d\n", lua_tolstring(m_luaState, -1, 0) , iState);

  0007f	50		 push	 eax
  00080	8b 06		 mov	 eax, DWORD PTR [esi]
  00082	6a 00		 push	 0
  00084	6a ff		 push	 -1
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _lua_tolstring
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	50		 push	 eax
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@
  00095	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 42   : 		lua_pop(m_luaState, 1);

  0009a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0009c	6a fe		 push	 -2			; fffffffeH
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 _lua_settop
  000a4	83 c4 14	 add	 esp, 20			; 00000014H

; 43   : 
; 44   : 		if (this->m_bUseSync == true)
; 45   : 		{
; 46   : 			LeaveCriticalSection(&this->m_luaCritical);
; 47   : 		}
; 48   : 
; 49   : 		return false;

  000a7	eb a8		 jmp	 SHORT $LN9@DoFile
$LN3@DoFile:

; 50   : 	}
; 51   : 
; 52   : 	if (this->m_bUseSync == true)

  000a9	38 5e 1c	 cmp	 BYTE PTR [esi+28], bl
  000ac	75 0a		 jne	 SHORT $LN1@DoFile

; 53   : 	{
; 54   : 		LeaveCriticalSection(&this->m_luaCritical);

  000ae	83 c6 04	 add	 esi, 4
  000b1	56		 push	 esi
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN1@DoFile:

; 55   : 	}
; 56   : 
; 57   : 	return true;	

  000b8	5e		 pop	 esi
  000b9	8a c3		 mov	 al, bl
  000bb	5b		 pop	 ebx

; 58   : }

  000bc	5d		 pop	 ebp
  000bd	c2 04 00	 ret	 4
?DoFile@MULua@@QAE_NPBD@Z ENDP				; MULua::DoFile
_TEXT	ENDS
PUBLIC	??_C@_0M@CELJGBOI@loadfilemem?$AA@		; `string'
PUBLIC	?DoFile@MULua@@QAE_NPADI@Z			; MULua::DoFile
EXTRN	_luaL_loadbufferx:PROC
;	COMDAT ??_C@_0M@CELJGBOI@loadfilemem?$AA@
CONST	SEGMENT
??_C@_0M@CELJGBOI@loadfilemem?$AA@ DB 'loadfilemem', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DoFile@MULua@@QAE_NPADI@Z
_TEXT	SEGMENT
_szBuff$ = 8						; size = 4
_size$ = 12						; size = 4
?DoFile@MULua@@QAE_NPADI@Z PROC				; MULua::DoFile, COMDAT
; _this$ = ecx

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 62   : 	if (this->m_bUseSync == true)

  00007	b3 01		 mov	 bl, 1
  00009	38 5e 1c	 cmp	 BYTE PTR [esi+28], bl
  0000c	75 0a		 jne	 SHORT $LN6@DoFile@2

; 63   : 	{
; 64   : 		EnterCriticalSection(&this->m_luaCritical);

  0000e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
$LN6@DoFile@2:

; 65   : 	}
; 66   : 
; 67   : 	if (luaL_loadbuffer(m_luaState, szBuff, size, "loadfilemem") != 0)

  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR _szBuff$[ebp]
  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
  00020	6a 00		 push	 0
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CELJGBOI@loadfilemem?$AA@
  00027	51		 push	 ecx
  00028	52		 push	 edx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _luaL_loadbufferx
  0002f	83 c4 14	 add	 esp, 20			; 00000014H

; 68   : 	{
; 69   : 		MsgBox("Error!!, : %s\n", lua_tolstring(m_luaState, -1, 0));

  00032	6a 00		 push	 0
  00034	85 c0		 test	 eax, eax
  00036	74 39		 je	 SHORT $LN5@DoFile@2
  00038	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003a	6a ff		 push	 -1
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _lua_tolstring
  00042	50		 push	 eax
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@
  00048	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 70   : 		lua_pop(m_luaState, 1);

  0004d	8b 16		 mov	 edx, DWORD PTR [esi]
  0004f	6a fe		 push	 -2			; fffffffeH
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 _lua_settop
  00057	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN9@DoFile@2:

; 71   : 
; 72   : 		if (this->m_bUseSync == true)

  0005a	38 5e 1c	 cmp	 BYTE PTR [esi+28], bl
  0005d	75 0a		 jne	 SHORT $LN4@DoFile@2

; 73   : 		{
; 74   : 			LeaveCriticalSection(&this->m_luaCritical);

  0005f	83 c6 04	 add	 esi, 4
  00062	56		 push	 esi
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN4@DoFile@2:

; 75   : 		}
; 76   : 
; 77   : 		return false;

  00069	5e		 pop	 esi
  0006a	32 c0		 xor	 al, al
  0006c	5b		 pop	 ebx

; 101  : }

  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
$LN5@DoFile@2:

; 78   : 	}
; 79   : 
; 80   : 	int iState = lua_pcall(m_luaState, 0, -1, 0);

  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	6a 00		 push	 0
  00075	6a 00		 push	 0
  00077	6a ff		 push	 -1
  00079	6a 00		 push	 0
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _lua_pcallk
  00081	83 c4 18	 add	 esp, 24			; 00000018H

; 81   : 
; 82   : 	if (iState)

  00084	85 c0		 test	 eax, eax
  00086	74 2a		 je	 SHORT $LN3@DoFile@2

; 83   : 	{
; 84   : 		MsgBox("Error!!, : %s : State = %d\n", lua_tolstring(m_luaState, -1, 0), iState);

  00088	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008a	50		 push	 eax
  0008b	6a 00		 push	 0
  0008d	6a ff		 push	 -1
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 _lua_tolstring
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH
  00098	50		 push	 eax
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@
  0009e	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 85   : 		lua_pop(m_luaState, 1);

  000a3	8b 16		 mov	 edx, DWORD PTR [esi]
  000a5	6a fe		 push	 -2			; fffffffeH
  000a7	52		 push	 edx
  000a8	e8 00 00 00 00	 call	 _lua_settop
  000ad	83 c4 14	 add	 esp, 20			; 00000014H

; 86   : 
; 87   : 		if (this->m_bUseSync == true)
; 88   : 		{
; 89   : 			LeaveCriticalSection(&this->m_luaCritical);
; 90   : 		}
; 91   : 
; 92   : 		return false;

  000b0	eb a8		 jmp	 SHORT $LN9@DoFile@2
$LN3@DoFile@2:

; 93   : 	}
; 94   : 
; 95   : 	if (this->m_bUseSync == true)

  000b2	38 5e 1c	 cmp	 BYTE PTR [esi+28], bl
  000b5	75 0a		 jne	 SHORT $LN1@DoFile@2

; 96   : 	{
; 97   : 		LeaveCriticalSection(&this->m_luaCritical);

  000b7	83 c6 04	 add	 esi, 4
  000ba	56		 push	 esi
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN1@DoFile@2:

; 98   : 	}
; 99   : 
; 100  : 	return true;

  000c1	5e		 pop	 esi
  000c2	8a c3		 mov	 al, bl
  000c4	5b		 pop	 ebx

; 101  : }

  000c5	5d		 pop	 ebp
  000c6	c2 08 00	 ret	 8
?DoFile@MULua@@QAE_NPADI@Z ENDP				; MULua::DoFile
_TEXT	ENDS
PUBLIC	?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z		; MULua::DoFile
; Function compile flags: /Ogtp
;	COMDAT ?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_szFileName$ = 12					; size = 4
?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z PROC		; MULua::DoFile, COMDAT
; _this$ = ecx

; 105  : 	return true;

  00000	b0 01		 mov	 al, 1

; 106  : }

  00002	c2 08 00	 ret	 8
?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z ENDP		; MULua::DoFile
_TEXT	ENDS
PUBLIC	?GetLua@MULua@@QAEPAUlua_State@@XZ		; MULua::GetLua
; Function compile flags: /Ogtp
;	COMDAT ?GetLua@MULua@@QAEPAUlua_State@@XZ
_TEXT	SEGMENT
?GetLua@MULua@@QAEPAUlua_State@@XZ PROC			; MULua::GetLua, COMDAT
; _this$ = ecx

; 115  : 	return m_luaState;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 116  : }

  00002	c3		 ret	 0
?GetLua@MULua@@QAEPAUlua_State@@XZ ENDP			; MULua::GetLua
_TEXT	ENDS
PUBLIC	?Create@MULua@@AAE_NXZ				; MULua::Create
EXTRN	?AddTable@LuaExport@@QAEXPAUlua_State@@@Z:PROC	; LuaExport::AddTable
EXTRN	?AddGlobal@LuaExport@@QAEXPAUlua_State@@@Z:PROC	; LuaExport::AddGlobal
EXTRN	?gLuaExport@@3VLuaExport@@A:DWORD		; gLuaExport
EXTRN	_lua_gc:PROC
EXTRN	_luaL_openlibs:PROC
EXTRN	_luaL_newstate:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Create@MULua@@AAE_NXZ
_TEXT	SEGMENT
?Create@MULua@@AAE_NXZ PROC				; MULua::Create, COMDAT
; _this$ = ecx

; 119  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 120  : 	if (this->m_bUseSync == true)

  00003	80 7e 1c 01	 cmp	 BYTE PTR [esi+28], 1
  00007	75 0a		 jne	 SHORT $LN1@Create

; 121  : 	{
; 122  : 		InitializeCriticalSection(&this->m_luaCritical);

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4
$LN1@Create:

; 123  : 	}
; 124  : 
; 125  : 	m_luaState = luaL_newstate();

  00013	e8 00 00 00 00	 call	 _luaL_newstate

; 126  : 
; 127  : 	luaL_openlibs(m_luaState);

  00018	50		 push	 eax
  00019	89 06		 mov	 DWORD PTR [esi], eax
  0001b	e8 00 00 00 00	 call	 _luaL_openlibs

; 128  : 	/*lua_pushcclosure(m_luaState, IncludeLuaQuest, 0);*/
; 129  : 	/*lua_setglobal(m_luaState, "QuestInclude");*/
; 130  : 	lua_gc(m_luaState, LUA_GCCOLLECT, 0);

  00020	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00022	6a 00		 push	 0
  00024	6a 02		 push	 2
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 _lua_gc

; 131  : 
; 132  : 	gLuaExport.AddGlobal(m_luaState);

  0002c	8b 16		 mov	 edx, DWORD PTR [esi]
  0002e	83 c4 10	 add	 esp, 16			; 00000010H
  00031	52		 push	 edx
  00032	b9 00 00 00 00	 mov	 ecx, OFFSET ?gLuaExport@@3VLuaExport@@A ; gLuaExport
  00037	e8 00 00 00 00	 call	 ?AddGlobal@LuaExport@@QAEXPAUlua_State@@@Z ; LuaExport::AddGlobal

; 133  : 	gLuaExport.AddTable(m_luaState);

  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	50		 push	 eax
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gLuaExport@@3VLuaExport@@A ; gLuaExport
  00044	e8 00 00 00 00	 call	 ?AddTable@LuaExport@@QAEXPAUlua_State@@@Z ; LuaExport::AddTable

; 134  : 
; 135  : 	return true;

  00049	b0 01		 mov	 al, 1
  0004b	5e		 pop	 esi

; 136  : }

  0004c	c3		 ret	 0
?Create@MULua@@AAE_NXZ ENDP				; MULua::Create
_TEXT	ENDS
PUBLIC	?Register@MULua@@QAEXPAX@Z			; MULua::Register
; Function compile flags: /Ogtp
;	COMDAT ?Register@MULua@@QAEXPAX@Z
_TEXT	SEGMENT
_pLua$ = 8						; size = 4
?Register@MULua@@QAEXPAX@Z PROC				; MULua::Register, COMDAT
; _this$ = ecx

; 140  : 	lua_State* pLuaState = (lua_State*)pLua;
; 141  : }

  00000	c2 04 00	 ret	 4
?Register@MULua@@QAEXPAX@Z ENDP				; MULua::Register
_TEXT	ENDS
PUBLIC	?RegisterData@MULua@@QAEXPBUluaL_Reg@@PAD1I@Z	; MULua::RegisterData
EXTRN	_lua_setglobal:PROC
EXTRN	_lua_setmetatable:PROC
EXTRN	_luaL_setfuncs:PROC
EXTRN	_luaL_newmetatable:PROC
EXTRN	_lua_newuserdata:PROC
; Function compile flags: /Ogtp
;	COMDAT ?RegisterData@MULua@@QAEXPBUluaL_Reg@@PAD1I@Z
_TEXT	SEGMENT
_Table$ = 8						; size = 4
_TableName$ = 12					; size = 4
_DataName$ = 16						; size = 4
_Size$ = 20						; size = 4
?RegisterData@MULua@@QAEXPBUluaL_Reg@@PAD1I@Z PROC	; MULua::RegisterData, COMDAT
; _this$ = ecx

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 145  : 	lua_newuserdata(this->m_luaState, Size);

  00003	8b 45 14	 mov	 eax, DWORD PTR _Size$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _lua_newuserdata

; 146  : 	luaL_newmetatable(this->m_luaState, TableName);

  00012	8b 55 0c	 mov	 edx, DWORD PTR _TableName$[ebp]
  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _luaL_newmetatable

; 147  : 	luaL_setfuncs(this->m_luaState, Table, 0); // for lua 5.2

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _Table$[ebp]
  00021	8b 16		 mov	 edx, DWORD PTR [esi]
  00023	6a 00		 push	 0
  00025	51		 push	 ecx
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 _luaL_setfuncs

; 148  : 	//luaL_register(this->m_luaState, DataName, Table); not work in Lua 5.2
; 149  : 	lua_setmetatable(this->m_luaState, -2);

  0002c	8b 06		 mov	 eax, DWORD PTR [esi]
  0002e	6a fe		 push	 -2			; fffffffeH
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _lua_setmetatable

; 150  : 	lua_setglobal(this->m_luaState, DataName);

  00036	8b 4d 10	 mov	 ecx, DWORD PTR _DataName$[ebp]
  00039	8b 16		 mov	 edx, DWORD PTR [esi]
  0003b	51		 push	 ecx
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _lua_setglobal
  00042	83 c4 2c	 add	 esp, 44			; 0000002cH
  00045	5e		 pop	 esi

; 151  : }

  00046	5d		 pop	 ebp
  00047	c2 10 00	 ret	 16			; 00000010H
?RegisterData@MULua@@QAEXPBUluaL_Reg@@PAD1I@Z ENDP	; MULua::RegisterData
_TEXT	ENDS
PUBLIC	??_C@_0CJ@EGCCEPHO@luacall_Generic_Call?5invalid?5opt@ ; `string'
PUBLIC	??_C@_0DH@JDMJKKHH@luacall_Generic_Call?5error?5runni@ ; `string'
PUBLIC	??_C@_0BD@IOJAAODF@too?5many?5arguments?$AA@	; `string'
PUBLIC	__real@41f0000000000000
PUBLIC	?Generic_Call@MULua@@QAA_NPBD0ZZ		; MULua::Generic_Call
EXTRN	_lua_isstring:PROC
EXTRN	_lua_tonumberx:PROC
EXTRN	_lua_isnumber:PROC
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
EXTRN	_luaL_checkstack:PROC
EXTRN	_lua_pushnumber:PROC
EXTRN	_lua_pushlstring:PROC
EXTRN	_lua_getglobal:PROC
EXTRN	__fltused:DWORD
EXTRN	__ftol2:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0CJ@EGCCEPHO@luacall_Generic_Call?5invalid?5opt@
CONST	SEGMENT
??_C@_0CJ@EGCCEPHO@luacall_Generic_Call?5invalid?5opt@ DB 'luacall_Generi'
	DB	'c_Call invalid option (%c)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@JDMJKKHH@luacall_Generic_Call?5error?5runni@
CONST	SEGMENT
??_C@_0DH@JDMJKKHH@luacall_Generic_Call?5error?5runni@ DB 'luacall_Generi'
	DB	'c_Call error running function ''%s'': ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOJAAODF@too?5many?5arguments?$AA@
CONST	SEGMENT
??_C@_0BD@IOJAAODF@too?5many?5arguments?$AA@ DB 'too many arguments', 00H ; `string'
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Generic_Call@MULua@@QAA_NPBD0ZZ
_TEXT	SEGMENT
tv449 = -20						; size = 8
tv392 = -20						; size = 8
tv459 = -12						; size = 4
_nRetValCnt$ = -12					; size = 4
tv452 = -8						; size = 8
tv394 = -4						; size = 4
_nArg$ = 8						; size = 4
_this$ = 8						; size = 4
tv397 = 10						; size = 2
_func$ = 12						; size = 4
_sig$ = 16						; size = 4
?Generic_Call@MULua@@QAA_NPBD0ZZ PROC			; MULua::Generic_Call, COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi

; 155  : 	if (this->m_luaState == NULL)

  00007	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0000a	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0000d	75 07		 jne	 SHORT $LN40@Generic_Ca

; 156  : 	{
; 157  : 		return false;

  0000f	32 c0		 xor	 al, al
  00011	5e		 pop	 esi

; 348  : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN40@Generic_Ca:

; 158  : 	}
; 159  : 
; 160  : 	if (this->m_bUseSync == true)

  00016	80 7e 1c 01	 cmp	 BYTE PTR [esi+28], 1
  0001a	75 0a		 jne	 SHORT $LN39@Generic_Ca

; 161  : 	{
; 162  : 		EnterCriticalSection(&this->m_luaCritical);

  0001c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
$LN39@Generic_Ca:

; 163  : 	}
; 164  : 
; 165  : 	va_list	VA_LIST;
; 166  : 	int nArg = 0;
; 167  : 
; 168  : 	va_start(VA_LIST, sig);
; 169  : 	lua_getglobal(this->m_luaState, func);

  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _func$[ebp]
  00029	8b 16		 mov	 edx, DWORD PTR [esi]
  0002b	53		 push	 ebx
  0002c	57		 push	 edi
  0002d	51		 push	 ecx
  0002e	52		 push	 edx
  0002f	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _nArg$[ebp], 0
  00036	8d 7d 14	 lea	 edi, DWORD PTR _sig$[ebp+4]
  00039	e8 00 00 00 00	 call	 _lua_getglobal

; 170  : 
; 171  : 	while (*sig)

  0003e	8b 45 10	 mov	 eax, DWORD PTR _sig$[ebp]
  00041	8a 00		 mov	 al, BYTE PTR [eax]
  00043	83 c4 08	 add	 esp, 8
  00046	84 c0		 test	 al, al
  00048	0f 84 d9 00 00
	00		 je	 $endwhile$153543
  0004e	8b ff		 npad	 2
$LL38@Generic_Ca:

; 172  : 	{
; 173  : 		switch (*sig++)

  00050	ff 45 10	 inc	 DWORD PTR _sig$[ebp]
  00053	0f be c0	 movsx	 eax, al
  00056	83 e8 3e	 sub	 eax, 62			; 0000003eH
  00059	83 f8 39	 cmp	 eax, 57			; 00000039H
  0005c	0f 87 2a 01 00
	00		 ja	 $LN27@Generic_Ca
  00062	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN52@Generic_Ca[eax]
  00069	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN64@Generic_Ca[ecx*4]
$LN34@Generic_Ca:

; 174  : 		{
; 175  : 		case 'd':
; 176  : 		{
; 177  : 			lua_pushnumber(this->m_luaState, va_arg(VA_LIST, double));

  00070	dd 07		 fld	 QWORD PTR [edi]
  00072	83 c7 08	 add	 edi, 8

; 178  : 		} break;

  00075	e9 7a 00 00 00	 jmp	 $LN61@Generic_Ca
$LN33@Generic_Ca:

; 179  : 
; 180  : 		case 'i':
; 181  : 		{
; 182  : 			lua_pushnumber(this->m_luaState, va_arg(VA_LIST, int));

  0007a	db 07		 fild	 DWORD PTR [edi]
  0007c	8b 06		 mov	 eax, DWORD PTR [esi]
  0007e	83 c7 04	 add	 edi, 4
  00081	83 ec 08	 sub	 esp, 8
  00084	dd 1c 24	 fstp	 QWORD PTR [esp]
  00087	50		 push	 eax

; 183  : 		} break;

  00088	eb 73		 jmp	 SHORT $LN62@Generic_Ca
$LN32@Generic_Ca:

; 184  : 
; 185  : 		case 's':
; 186  : 		{
; 187  : 			char *pszString = va_arg(VA_LIST, char *);

  0008a	8b 17		 mov	 edx, DWORD PTR [edi]
  0008c	83 c7 04	 add	 edi, 4

; 188  : 			lua_pushlstring(this->m_luaState, pszString, strlen(pszString));

  0008f	8b c2		 mov	 eax, edx
  00091	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
$LL53@Generic_Ca:
  00094	8a 08		 mov	 cl, BYTE PTR [eax]
  00096	40		 inc	 eax
  00097	84 c9		 test	 cl, cl
  00099	75 f9		 jne	 SHORT $LL53@Generic_Ca
  0009b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0009d	2b c3		 sub	 eax, ebx
  0009f	50		 push	 eax
  000a0	52		 push	 edx
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 _lua_pushlstring

; 189  : 		} break;

  000a7	eb 59		 jmp	 SHORT $LN63@Generic_Ca
$LN31@Generic_Ca:

; 190  : 
; 191  : 		case 'w':
; 192  : 		{
; 193  : 			lua_pushnumber(this->m_luaState, va_arg(VA_LIST, unsigned int));

  000a9	8b 17		 mov	 edx, DWORD PTR [edi]
  000ab	db 07		 fild	 DWORD PTR [edi]
  000ad	83 c7 04	 add	 edi, 4
  000b0	85 d2		 test	 edx, edx
  000b2	79 06		 jns	 SHORT $LN60@Generic_Ca
  000b4	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$LN60@Generic_Ca:
  000ba	8b 06		 mov	 eax, DWORD PTR [esi]
  000bc	83 ec 08	 sub	 esp, 8
  000bf	dd 1c 24	 fstp	 QWORD PTR [esp]
  000c2	50		 push	 eax

; 194  : 		} break;

  000c3	eb 38		 jmp	 SHORT $LN62@Generic_Ca
$LN30@Generic_Ca:

; 195  : 
; 196  : 		case 'l':
; 197  : 		{
; 198  : 			lua_pushnumber(this->m_luaState, va_arg(VA_LIST, unsigned long long));

  000c5	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c7	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000ca	83 c7 08	 add	 edi, 8
  000cd	89 4d f8	 mov	 DWORD PTR tv452[ebp], ecx
  000d0	8b c8		 mov	 ecx, eax
  000d2	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  000d7	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  000dd	89 45 fc	 mov	 DWORD PTR tv452[ebp+4], eax
  000e0	df 6d f8	 fild	 QWORD PTR tv452[ebp]
  000e3	89 4d f0	 mov	 DWORD PTR tv449[ebp+4], ecx
  000e6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv449[ebp], 0
  000ed	df 6d ec	 fild	 QWORD PTR tv449[ebp]
  000f0	d9 e0		 fchs
  000f2	de c1		 faddp	 ST(1), ST(0)
$LN61@Generic_Ca:
  000f4	8b 16		 mov	 edx, DWORD PTR [esi]
  000f6	83 ec 08	 sub	 esp, 8
  000f9	dd 1c 24	 fstp	 QWORD PTR [esp]
  000fc	52		 push	 edx
$LN62@Generic_Ca:
  000fd	e8 00 00 00 00	 call	 _lua_pushnumber
$LN63@Generic_Ca:

; 216  : 		}
; 217  : 		}
; 218  : 
; 219  : 		nArg++;
; 220  : 		luaL_checkstack(this->m_luaState, 1, "too many arguments");

  00102	8b 06		 mov	 eax, DWORD PTR [esi]
  00104	ff 45 08	 inc	 DWORD PTR _nArg$[ebp]
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@IOJAAODF@too?5many?5arguments?$AA@
  0010f	6a 01		 push	 1
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _luaL_checkstack
  00117	8b 4d 10	 mov	 ecx, DWORD PTR _sig$[ebp]
  0011a	8a 01		 mov	 al, BYTE PTR [ecx]
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011f	84 c0		 test	 al, al
  00121	0f 85 29 ff ff
	ff		 jne	 $LL38@Generic_Ca
$endwhile$153543:

; 221  : 
; 222  : 	} endwhile:
; 223  : 
; 224  : 	int nRes = strlen(sig);

  00127	8b 5d 10	 mov	 ebx, DWORD PTR _sig$[ebp]
  0012a	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0012d	8d 49 00	 npad	 3
$LL54@Generic_Ca:
  00130	8a 03		 mov	 al, BYTE PTR [ebx]
  00132	43		 inc	 ebx
  00133	84 c0		 test	 al, al
  00135	75 f9		 jne	 SHORT $LL54@Generic_Ca

; 225  : 
; 226  : 	if (lua_pcall(this->m_luaState, nArg, nRes, 0) != 0)

  00137	8b 16		 mov	 edx, DWORD PTR [esi]
  00139	6a 00		 push	 0
  0013b	6a 00		 push	 0
  0013d	2b d9		 sub	 ebx, ecx
  0013f	8b 4d 08	 mov	 ecx, DWORD PTR _nArg$[ebp]
  00142	6a 00		 push	 0
  00144	53		 push	 ebx
  00145	51		 push	 ecx
  00146	52		 push	 edx
  00147	e8 00 00 00 00	 call	 _lua_pcallk
  0014c	83 c4 18	 add	 esp, 24			; 00000018H
  0014f	85 c0		 test	 eax, eax
  00151	74 69		 je	 SHORT $LN25@Generic_Ca

; 227  : 	{
; 228  : 		LogAdd(LOG_RED, "luacall_Generic_Call error running function '%s': '%s'", func, lua_tolstring(this->m_luaState, -1, 0));

  00153	8b 06		 mov	 eax, DWORD PTR [esi]
  00155	6a 00		 push	 0
  00157	6a ff		 push	 -1
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 _lua_tolstring
  0015f	8b 4d 0c	 mov	 ecx, DWORD PTR _func$[ebp]
  00162	50		 push	 eax
  00163	51		 push	 ecx
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@JDMJKKHH@luacall_Generic_Call?5error?5runni@
  00169	6a 01		 push	 1
  0016b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00170	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN4@Generic_Ca:

; 229  : 
; 230  : 		if (this->m_bUseSync == true)

  00173	80 7e 1c 01	 cmp	 BYTE PTR [esi+28], 1
  00177	75 0a		 jne	 SHORT $LN3@Generic_Ca

; 231  : 		{
; 232  : 			LeaveCriticalSection(&this->m_luaCritical);

  00179	83 c6 04	 add	 esi, 4
  0017c	56		 push	 esi
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN3@Generic_Ca:

; 233  : 		}
; 234  : 
; 235  : 		return false;

  00183	5f		 pop	 edi
  00184	5b		 pop	 ebx
  00185	32 c0		 xor	 al, al
  00187	5e		 pop	 esi

; 348  : }

  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
$LN27@Generic_Ca:

; 199  : 		} break;
; 200  : 
; 201  : 		case '>':
; 202  : 		{
; 203  : 			goto endwhile;
; 204  : 		}
; 205  : 
; 206  : 		default:
; 207  : 		{
; 208  : 			LogAdd(LOG_RED, "luacall_Generic_Call invalid option (%c)", *(sig - 1));

  0018c	8b 55 10	 mov	 edx, DWORD PTR _sig$[ebp]
  0018f	0f be 42 ff	 movsx	 eax, BYTE PTR [edx-1]
  00193	50		 push	 eax
  00194	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@EGCCEPHO@luacall_Generic_Call?5invalid?5opt@
  00199	6a 01		 push	 1
  0019b	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  001a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 209  : 
; 210  : 			if (this->m_bUseSync == true)

  001a3	80 7e 1c 01	 cmp	 BYTE PTR [esi+28], 1
  001a7	75 da		 jne	 SHORT $LN3@Generic_Ca

; 211  : 			{
; 212  : 				LeaveCriticalSection(&this->m_luaCritical);

  001a9	83 c6 04	 add	 esi, 4
  001ac	56		 push	 esi
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  001b3	5f		 pop	 edi
  001b4	5b		 pop	 ebx

; 213  : 			}
; 214  : 
; 215  : 			return false;

  001b5	32 c0		 xor	 al, al
  001b7	5e		 pop	 esi

; 348  : }

  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c3		 ret	 0
$LN25@Generic_Ca:

; 239  : 	nRes = -nRes;
; 240  : 
; 241  : 	while (*sig)

  001bc	8b 55 10	 mov	 edx, DWORD PTR _sig$[ebp]
  001bf	8a 02		 mov	 al, BYTE PTR [edx]
  001c1	8b cb		 mov	 ecx, ebx
  001c3	f7 db		 neg	 ebx
  001c5	89 4d f4	 mov	 DWORD PTR _nRetValCnt$[ebp], ecx
  001c8	84 c0		 test	 al, al
  001ca	0f 84 33 01 00
	00		 je	 $LN22@Generic_Ca

; 236  : 	}
; 237  : 
; 238  : 	int nRetValCnt = nRes;

  001d0	83 c7 fc	 add	 edi, -4			; fffffffcH
$LL23@Generic_Ca:

; 242  : 	{
; 243  : 		switch (*sig++)

  001d3	ff 45 10	 inc	 DWORD PTR _sig$[ebp]
  001d6	0f be c0	 movsx	 eax, al
  001d9	83 e8 64	 sub	 eax, 100		; 00000064H
  001dc	83 f8 13	 cmp	 eax, 19			; 00000013H
  001df	77 92		 ja	 SHORT $LN4@Generic_Ca
  001e1	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN55@Generic_Ca[eax]
  001e8	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN65@Generic_Ca[eax*4]
$LN19@Generic_Ca:

; 244  : 		{
; 245  : 		case 'd':
; 246  : 		{
; 247  : 			if (!lua_isnumber(this->m_luaState, nRes))

  001ef	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001f1	53		 push	 ebx
  001f2	51		 push	 ecx
  001f3	e8 00 00 00 00	 call	 _lua_isnumber
  001f8	83 c4 08	 add	 esp, 8
  001fb	85 c0		 test	 eax, eax
  001fd	0f 84 70 ff ff
	ff		 je	 $LN4@Generic_Ca

; 248  : 			{
; 249  : 				if (this->m_bUseSync == true)
; 250  : 				{
; 251  : 					LeaveCriticalSection(&this->m_luaCritical);
; 252  : 				}
; 253  : 
; 254  : 				return false;
; 255  : 			}
; 256  : 			*va_arg(VA_LIST, double *) = lua_tonumber(this->m_luaState, nRes);

  00203	8b 16		 mov	 edx, DWORD PTR [esi]
  00205	6a 00		 push	 0
  00207	53		 push	 ebx
  00208	52		 push	 edx
  00209	83 c7 04	 add	 edi, 4
  0020c	e8 00 00 00 00	 call	 _lua_tonumberx
  00211	8b 07		 mov	 eax, DWORD PTR [edi]
  00213	dd 18		 fstp	 QWORD PTR [eax]
  00215	83 c4 0c	 add	 esp, 12			; 0000000cH

; 257  : 
; 258  : 		} break;

  00218	e9 d5 00 00 00	 jmp	 $LN20@Generic_Ca
$LN16@Generic_Ca:

; 259  : 
; 260  : 		case 'i':
; 261  : 		{
; 262  : 			if (!lua_isnumber(this->m_luaState, nRes))

  0021d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0021f	53		 push	 ebx
  00220	51		 push	 ecx
  00221	e8 00 00 00 00	 call	 _lua_isnumber
  00226	83 c4 08	 add	 esp, 8
  00229	85 c0		 test	 eax, eax
  0022b	0f 84 42 ff ff
	ff		 je	 $LN4@Generic_Ca

; 263  : 			{
; 264  : 				if (this->m_bUseSync == true)
; 265  : 				{
; 266  : 					LeaveCriticalSection(&this->m_luaCritical);
; 267  : 				}
; 268  : 
; 269  : 				return false;
; 270  : 			}
; 271  : 
; 272  : 			*va_arg(VA_LIST, int *) = (int)lua_tonumber(this->m_luaState, nRes);

  00231	8b 16		 mov	 edx, DWORD PTR [esi]
  00233	6a 00		 push	 0
  00235	53		 push	 ebx
  00236	52		 push	 edx
  00237	83 c7 04	 add	 edi, 4
  0023a	e8 00 00 00 00	 call	 _lua_tonumberx
  0023f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00242	e8 00 00 00 00	 call	 __ftol2_sse
  00247	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00249	89 01		 mov	 DWORD PTR [ecx], eax

; 273  : 		} break;

  0024b	e9 a2 00 00 00	 jmp	 $LN20@Generic_Ca
$LN13@Generic_Ca:

; 274  : 
; 275  : 		case 's':
; 276  : 		{
; 277  : 			if (!lua_isstring(this->m_luaState, nRes))

  00250	8b 16		 mov	 edx, DWORD PTR [esi]
  00252	53		 push	 ebx
  00253	52		 push	 edx
  00254	e8 00 00 00 00	 call	 _lua_isstring
  00259	83 c4 08	 add	 esp, 8
  0025c	85 c0		 test	 eax, eax
  0025e	0f 84 0f ff ff
	ff		 je	 $LN4@Generic_Ca

; 278  : 			{
; 279  : 				if (this->m_bUseSync == true)
; 280  : 				{
; 281  : 					LeaveCriticalSection(&this->m_luaCritical);
; 282  : 				}
; 283  : 
; 284  : 				return false;
; 285  : 			}
; 286  : 
; 287  : 			*va_arg(VA_LIST, const char **) = lua_tostring(this->m_luaState, nRes);

  00264	8b 06		 mov	 eax, DWORD PTR [esi]
  00266	6a 00		 push	 0
  00268	53		 push	 ebx
  00269	50		 push	 eax
  0026a	83 c7 04	 add	 edi, 4
  0026d	e8 00 00 00 00	 call	 _lua_tolstring
  00272	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00274	83 c4 0c	 add	 esp, 12			; 0000000cH
  00277	89 01		 mov	 DWORD PTR [ecx], eax

; 288  : 		} break;

  00279	eb 77		 jmp	 SHORT $LN20@Generic_Ca
$LN10@Generic_Ca:

; 289  : 
; 290  : 		case 'w':
; 291  : 		{
; 292  : 			if (!lua_isnumber(this->m_luaState, nRes))

  0027b	8b 16		 mov	 edx, DWORD PTR [esi]
  0027d	53		 push	 ebx
  0027e	52		 push	 edx
  0027f	e8 00 00 00 00	 call	 _lua_isnumber
  00284	83 c4 08	 add	 esp, 8
  00287	85 c0		 test	 eax, eax
  00289	0f 84 e4 fe ff
	ff		 je	 $LN4@Generic_Ca

; 293  : 			{
; 294  : 				if (this->m_bUseSync == true)
; 295  : 				{
; 296  : 					LeaveCriticalSection(&this->m_luaCritical);
; 297  : 				}
; 298  : 
; 299  : 				return false;
; 300  : 			}
; 301  : 
; 302  : 			*va_arg(VA_LIST, unsigned int*) = (unsigned int)lua_tonumber(this->m_luaState, nRes);

  0028f	8b 06		 mov	 eax, DWORD PTR [esi]
  00291	6a 00		 push	 0
  00293	53		 push	 ebx
  00294	50		 push	 eax
  00295	83 c7 04	 add	 edi, 4
  00298	e8 00 00 00 00	 call	 _lua_tonumberx
  0029d	d9 7d 0a	 fnstcw	 WORD PTR tv397[ebp]
  002a0	0f b7 45 0a	 movzx	 eax, WORD PTR tv397[ebp]
  002a4	8b 17		 mov	 edx, DWORD PTR [edi]
  002a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a9	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002ae	89 45 fc	 mov	 DWORD PTR tv394[ebp], eax
  002b1	d9 6d fc	 fldcw	 WORD PTR tv394[ebp]
  002b4	df 7d ec	 fistp	 QWORD PTR tv392[ebp]
  002b7	8b 4d ec	 mov	 ecx, DWORD PTR tv392[ebp]
  002ba	89 0a		 mov	 DWORD PTR [edx], ecx
  002bc	d9 6d 0a	 fldcw	 WORD PTR tv397[ebp]

; 303  : 		} break;

  002bf	eb 31		 jmp	 SHORT $LN20@Generic_Ca
$LN7@Generic_Ca:

; 304  : 
; 305  : 		case 'l':
; 306  : 		{
; 307  : 			if (!lua_isnumber(this->m_luaState, nRes))

  002c1	8b 06		 mov	 eax, DWORD PTR [esi]
  002c3	53		 push	 ebx
  002c4	50		 push	 eax
  002c5	e8 00 00 00 00	 call	 _lua_isnumber
  002ca	83 c4 08	 add	 esp, 8
  002cd	85 c0		 test	 eax, eax
  002cf	0f 84 9e fe ff
	ff		 je	 $LN4@Generic_Ca

; 308  : 			{
; 309  : 				if (this->m_bUseSync == true)
; 310  : 				{
; 311  : 					LeaveCriticalSection(&this->m_luaCritical);
; 312  : 				}
; 313  : 
; 314  : 				return false;
; 315  : 			}
; 316  : 
; 317  : 			*va_arg(VA_LIST, unsigned long long*) = (unsigned long long)lua_tonumber(this->m_luaState, nRes);

  002d5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002d7	6a 00		 push	 0
  002d9	53		 push	 ebx
  002da	51		 push	 ecx
  002db	83 c7 04	 add	 edi, 4
  002de	e8 00 00 00 00	 call	 _lua_tonumberx
  002e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e6	e8 00 00 00 00	 call	 __ftol2
  002eb	8b 0f		 mov	 ecx, DWORD PTR [edi]
  002ed	89 01		 mov	 DWORD PTR [ecx], eax
  002ef	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN20@Generic_Ca:

; 239  : 	nRes = -nRes;
; 240  : 
; 241  : 	while (*sig)

  002f2	8b 55 10	 mov	 edx, DWORD PTR _sig$[ebp]
  002f5	8a 02		 mov	 al, BYTE PTR [edx]

; 318  : 		} break;
; 319  : 
; 320  : 		default:
; 321  : 		{
; 322  : 			if (this->m_bUseSync == true)
; 323  : 			{
; 324  : 				LeaveCriticalSection(&this->m_luaCritical);
; 325  : 			}
; 326  : 
; 327  : 			return false;
; 328  : 		} break;
; 329  : 
; 330  : 		}
; 331  : 
; 332  : 		nRes++;

  002f7	43		 inc	 ebx
  002f8	84 c0		 test	 al, al
  002fa	0f 85 d3 fe ff
	ff		 jne	 $LL23@Generic_Ca

; 304  : 
; 305  : 		case 'l':
; 306  : 		{
; 307  : 			if (!lua_isnumber(this->m_luaState, nRes))

  00300	8b 4d f4	 mov	 ecx, DWORD PTR _nRetValCnt$[ebp]
$LN22@Generic_Ca:

; 333  : 	}
; 334  : 
; 335  : 	va_end(VA_LIST);
; 336  : 
; 337  : 	if (nRetValCnt)

  00303	85 c9		 test	 ecx, ecx
  00305	74 11		 je	 SHORT $LN2@Generic_Ca

; 338  : 	{
; 339  : 		lua_pop(this->m_luaState, nRetValCnt);

  00307	83 c8 ff	 or	 eax, -1
  0030a	2b c1		 sub	 eax, ecx
  0030c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0030e	50		 push	 eax
  0030f	51		 push	 ecx
  00310	e8 00 00 00 00	 call	 _lua_settop
  00315	83 c4 08	 add	 esp, 8
$LN2@Generic_Ca:

; 340  : 	}
; 341  : 
; 342  : 	if (this->m_bUseSync == true)

  00318	80 7e 1c 01	 cmp	 BYTE PTR [esi+28], 1
  0031c	75 0a		 jne	 SHORT $LN1@Generic_Ca

; 343  : 	{
; 344  : 		LeaveCriticalSection(&this->m_luaCritical);

  0031e	83 c6 04	 add	 esi, 4
  00321	56		 push	 esi
  00322	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN1@Generic_Ca:

; 345  : 	}
; 346  : 
; 347  : 	return true;

  00328	5f		 pop	 edi
  00329	5b		 pop	 ebx
  0032a	b0 01		 mov	 al, 1
  0032c	5e		 pop	 esi

; 348  : }

  0032d	8b e5		 mov	 esp, ebp
  0032f	5d		 pop	 ebp
  00330	c3		 ret	 0
  00331	8d 49 00	 npad	 3
$LN64@Generic_Ca:
  00334	00 00 00 00	 DD	 $endwhile$153543
  00338	00 00 00 00	 DD	 $LN34@Generic_Ca
  0033c	00 00 00 00	 DD	 $LN33@Generic_Ca
  00340	00 00 00 00	 DD	 $LN30@Generic_Ca
  00344	00 00 00 00	 DD	 $LN32@Generic_Ca
  00348	00 00 00 00	 DD	 $LN31@Generic_Ca
  0034c	00 00 00 00	 DD	 $LN27@Generic_Ca
$LN52@Generic_Ca:
  00350	00		 DB	 0
  00351	06		 DB	 6
  00352	06		 DB	 6
  00353	06		 DB	 6
  00354	06		 DB	 6
  00355	06		 DB	 6
  00356	06		 DB	 6
  00357	06		 DB	 6
  00358	06		 DB	 6
  00359	06		 DB	 6
  0035a	06		 DB	 6
  0035b	06		 DB	 6
  0035c	06		 DB	 6
  0035d	06		 DB	 6
  0035e	06		 DB	 6
  0035f	06		 DB	 6
  00360	06		 DB	 6
  00361	06		 DB	 6
  00362	06		 DB	 6
  00363	06		 DB	 6
  00364	06		 DB	 6
  00365	06		 DB	 6
  00366	06		 DB	 6
  00367	06		 DB	 6
  00368	06		 DB	 6
  00369	06		 DB	 6
  0036a	06		 DB	 6
  0036b	06		 DB	 6
  0036c	06		 DB	 6
  0036d	06		 DB	 6
  0036e	06		 DB	 6
  0036f	06		 DB	 6
  00370	06		 DB	 6
  00371	06		 DB	 6
  00372	06		 DB	 6
  00373	06		 DB	 6
  00374	06		 DB	 6
  00375	06		 DB	 6
  00376	01		 DB	 1
  00377	06		 DB	 6
  00378	06		 DB	 6
  00379	06		 DB	 6
  0037a	06		 DB	 6
  0037b	02		 DB	 2
  0037c	06		 DB	 6
  0037d	06		 DB	 6
  0037e	03		 DB	 3
  0037f	06		 DB	 6
  00380	06		 DB	 6
  00381	06		 DB	 6
  00382	06		 DB	 6
  00383	06		 DB	 6
  00384	06		 DB	 6
  00385	04		 DB	 4
  00386	06		 DB	 6
  00387	06		 DB	 6
  00388	06		 DB	 6
  00389	05		 DB	 5
  0038a	8b ff		 npad	 2
$LN65@Generic_Ca:
  0038c	00 00 00 00	 DD	 $LN19@Generic_Ca
  00390	00 00 00 00	 DD	 $LN16@Generic_Ca
  00394	00 00 00 00	 DD	 $LN7@Generic_Ca
  00398	00 00 00 00	 DD	 $LN13@Generic_Ca
  0039c	00 00 00 00	 DD	 $LN10@Generic_Ca
  003a0	00 00 00 00	 DD	 $LN4@Generic_Ca
$LN55@Generic_Ca:
  003a4	00		 DB	 0
  003a5	05		 DB	 5
  003a6	05		 DB	 5
  003a7	05		 DB	 5
  003a8	05		 DB	 5
  003a9	01		 DB	 1
  003aa	05		 DB	 5
  003ab	05		 DB	 5
  003ac	02		 DB	 2
  003ad	05		 DB	 5
  003ae	05		 DB	 5
  003af	05		 DB	 5
  003b0	05		 DB	 5
  003b1	05		 DB	 5
  003b2	05		 DB	 5
  003b3	03		 DB	 3
  003b4	05		 DB	 5
  003b5	05		 DB	 5
  003b6	05		 DB	 5
  003b7	04		 DB	 4
?Generic_Call@MULua@@QAA_NPBD0ZZ ENDP			; MULua::Generic_Call
_TEXT	ENDS
PUBLIC	?Release@MULua@@QAEXXZ				; MULua::Release
EXTRN	_lua_close:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Release@MULua@@QAEXXZ
_TEXT	SEGMENT
?Release@MULua@@QAEXXZ PROC				; MULua::Release, COMDAT
; _this$ = ecx

; 351  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 352  : 	if (this->m_bUseSync == true)

  00003	80 7e 1c 01	 cmp	 BYTE PTR [esi+28], 1
  00007	75 0a		 jne	 SHORT $LN2@Release

; 353  : 	{
; 354  : 		DeleteCriticalSection(&this->m_luaCritical);

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
$LN2@Release:

; 355  : 	}
; 356  : 
; 357  : 	if(m_luaState)

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	85 c0		 test	 eax, eax
  00017	74 13		 je	 SHORT $LN1@Release

; 358  : 	{
; 359  : 		lua_close(m_luaState);

  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _lua_close
  0001f	83 c4 04	 add	 esp, 4

; 360  : 		m_luaState = NULL;

  00022	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 361  : 		m_bUseSync = false;

  00028	c6 46 1c 00	 mov	 BYTE PTR [esi+28], 0
$LN1@Release:
  0002c	5e		 pop	 esi

; 362  : 	}
; 363  : }

  0002d	c3		 ret	 0
?Release@MULua@@QAEXXZ ENDP				; MULua::Release
_TEXT	ENDS
PUBLIC	?CreateWinConsole@MULua@@QAEXPAUHINSTANCE__@@@Z	; MULua::CreateWinConsole
; Function compile flags: /Ogtp
;	COMDAT ?CreateWinConsole@MULua@@QAEXPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
?CreateWinConsole@MULua@@QAEXPAUHINSTANCE__@@@Z PROC	; MULua::CreateWinConsole, COMDAT
; _this$ = ecx

; 368  : 	/*HWND hWnd = NULL;
; 369  : 
; 370  : 	hWnd = CWinConsole::StartConsole(hInstance, m_luaState);
; 371  : 
; 372  : 	if ( hWnd )
; 373  : 		ShowWindow(hWnd, SW_HIDE);*/
; 374  : 
; 375  : }

  00000	c2 04 00	 ret	 4
?CreateWinConsole@MULua@@QAEXPAUHINSTANCE__@@@Z ENDP	; MULua::CreateWinConsole
_TEXT	ENDS
PUBLIC	?DestroyWinConsole@MULua@@QAEXXZ		; MULua::DestroyWinConsole
; Function compile flags: /Ogtp
;	COMDAT ?DestroyWinConsole@MULua@@QAEXXZ
_TEXT	SEGMENT
?DestroyWinConsole@MULua@@QAEXXZ PROC			; MULua::DestroyWinConsole, COMDAT
; _this$ = ecx

; 380  : 	//CWinConsole::StopConsole();
; 381  : }

  00000	c3		 ret	 0
?DestroyWinConsole@MULua@@QAEXXZ ENDP			; MULua::DestroyWinConsole
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 496  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 498  : 		}

  00003	5d		 pop	 ebp

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00004	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 526  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 527  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  0000b	88 0a		 mov	 BYTE PTR [edx], cl

; 528  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2003 : 		{	// determine current pointer to buffer for mutable string

  00000	8b c1		 mov	 eax, ecx

; 2004 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2005 : 			: this->_Bx._Buf);

  00002	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00006	72 02		 jb	 SHORT $LN4@Myptr
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Myptr:

; 2006 : 		}

  0000a	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 459  : 		}

  00000	c3		 ret	 0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	??0MULua@@QAE@_N@Z				; MULua::MULua
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\mulua.cpp
;	COMDAT ??0MULua@@QAE@_N@Z
_TEXT	SEGMENT
_UseSync$ = 8						; size = 1
??0MULua@@QAE@_N@Z PROC					; MULua::MULua, COMDAT
; _this$ = ecx

; 4    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5    : 	this->m_bUseSync = UseSync;

  00003	8a 45 08	 mov	 al, BYTE PTR _UseSync$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000f	88 46 1c	 mov	 BYTE PTR [esi+28], al

; 6    : 	this->Create();

  00012	e8 00 00 00 00	 call	 ?Create@MULua@@AAE_NXZ	; MULua::Create

; 7    : }

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??0MULua@@QAE@_N@Z ENDP					; MULua::MULua
_TEXT	ENDS
PUBLIC	??1MULua@@QAE@XZ				; MULua::~MULua
; Function compile flags: /Ogtp
;	COMDAT ??1MULua@@QAE@XZ
_TEXT	SEGMENT
??1MULua@@QAE@XZ PROC					; MULua::~MULua, COMDAT
; _this$ = ecx

; 12   : 	this->Release();

  00000	e9 00 00 00 00	 jmp	 ?Release@MULua@@QAEXXZ	; MULua::Release
??1MULua@@QAE@XZ ENDP					; MULua::~MULua
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1953 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1954 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0000a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000d	72 02		 jb	 SHORT $LN5@Eos
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN5@Eos:
  00011	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1955 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1988 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1989 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 22		 je	 SHORT $LN9@Tidy

; 1990 : 			;
; 1991 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 1c		 jb	 SHORT $LN9@Tidy

; 1992 : 			{	// copy any leftovers to small buffer and deallocate
; 1993 : 			_Elem *_Ptr = this->_Bx._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 1994 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN7@Tidy

; 1995 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@Tidy:

; 1996 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

  00028	53		 push	 ebx
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4
  00031	5b		 pop	 ebx
$LN9@Tidy:

; 1997 : 			}
; 1998 : 		this->_Myres = this->_BUF_SIZE - 1;
; 1999 : 		_Eos(_Newsize);

  00032	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00035	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0003c	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 2000 : 		}

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 753  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 754  : 		_Tidy(true);

  00003	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00007	72 0b		 jb	 SHORT $LN11@basic_stri
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
$LN11@basic_stri:
  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00022	c6 06 00	 mov	 BYTE PTR [esi], 0
  00025	5e		 pop	 esi

; 755  : 		}

  00026	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; MULua::DoString
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\mulua.cpp
;	COMDAT ?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_kString$ = 8						; size = 28
?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; MULua::DoString, COMDAT
; _this$ = ecx

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 110  : 	return true;

  00003	83 7d 1c 10	 cmp	 DWORD PTR _kString$[ebp+20], 16 ; 00000010H
  00007	72 0c		 jb	 SHORT $LN26@DoString
  00009	8b 45 08	 mov	 eax, DWORD PTR _kString$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN26@DoString:
  00015	b0 01		 mov	 al, 1

; 111  : }

  00017	5d		 pop	 ebp
  00018	c2 1c 00	 ret	 28			; 0000001cH
?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; MULua::DoString
_TEXT	ENDS
END
