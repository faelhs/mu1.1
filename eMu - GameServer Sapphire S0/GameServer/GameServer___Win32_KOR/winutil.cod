; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\winutil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_bBuxCode DB	0fcH
	DB	0cfH
	DB	0abH
_DATA	ENDS
PUBLIC	?BuxConvert@@YAXPADH@Z				; BuxConvert
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\winutil.cpp
;	COMDAT ?BuxConvert@@YAXPADH@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
?BuxConvert@@YAXPADH@Z PROC				; BuxConvert, COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 17   : 	int n;
; 18   : 
; 19   : 	for (n=0;n<size;n++)

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _size$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	85 ff		 test	 edi, edi
  0000b	7e 23		 jle	 SHORT $LN1@BuxConvert
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _buf$[ebp]
$LL3@BuxConvert:

; 20   : 	{
; 21   : 		buf[n]^=bBuxCode[n%3] ;		// Nice trick from WebZen

  00011	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00016	f7 e1		 mul	 ecx
  00018	d1 ea		 shr	 edx, 1
  0001a	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  0001d	8b d1		 mov	 edx, ecx
  0001f	2b d0		 sub	 edx, eax
  00021	8a 82 00 00 00
	00		 mov	 al, BYTE PTR _bBuxCode[edx]
  00027	30 04 31	 xor	 BYTE PTR [ecx+esi], al
  0002a	41		 inc	 ecx
  0002b	3b cf		 cmp	 ecx, edi
  0002d	7c e2		 jl	 SHORT $LL3@BuxConvert
  0002f	5e		 pop	 esi
$LN1@BuxConvert:
  00030	5f		 pop	 edi

; 22   : 	}
; 23   : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?BuxConvert@@YAXPADH@Z ENDP				; BuxConvert
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?StrHangulCheck@@YAHPAD@Z			; StrHangulCheck
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?StrHangulCheck@@YAHPAD@Z
_TEXT	SEGMENT
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_str$ = 8						; size = 4
?StrHangulCheck@@YAHPAD@Z PROC				; StrHangulCheck, COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _str$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi

; 118  : 	BYTE code1;
; 119  : 	BYTE code2;
; 120  : 	BYTE code;
; 121  : 	int i = 0;
; 122  : 	int n = 0;
; 123  : 	char	szTemp[256] = "";

  00019	68 ff 00 00 00	 push	 255			; 000000ffH
  0001e	8d 85 fd fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp+1]
  00024	6a 00		 push	 0
  00026	50		 push	 eax
  00027	c6 85 fc fe ff
	ff 00		 mov	 BYTE PTR _szTemp$[ebp], 0
  0002e	e8 00 00 00 00	 call	 _memset
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 124  : 	int result = 1;
; 125  : 	int count = 0xFF;	// -1

  00036	bf ff 00 00 00	 mov	 edi, 255		; 000000ffH

; 129  : 	{
; 130  : 	
; 131  : 		code1=str[i];

  0003b	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]

; 143  : 				n++;

  00041	8b f3		 mov	 esi, ebx
$LL9@StrHangulC:

; 126  : 
; 127  : 
; 128  : 	while ((count--) != 0)

  00043	8a 0e		 mov	 cl, BYTE PTR [esi]
  00045	4f		 dec	 edi

; 132  : 		i++;

  00046	46		 inc	 esi

; 133  : 
; 134  : 		if (code1==0)

  00047	84 c9		 test	 cl, cl
  00049	74 21		 je	 SHORT $LN16@StrHangulC

; 135  : 		{
; 136  : 			break;
; 137  : 		}
; 138  : 		else
; 139  : 		{
; 140  : 			if (code1<128)

  0004b	80 f9 80	 cmp	 cl, 128			; 00000080H
  0004e	73 05		 jae	 SHORT $LN5@StrHangulC

; 141  : 			{
; 142  : 				szTemp[n]=code1;

  00050	88 08		 mov	 BYTE PTR [eax], cl

; 143  : 				n++;

  00052	40		 inc	 eax

; 144  : 				continue;

  00053	eb 13		 jmp	 SHORT $LN1@StrHangulC
$LN5@StrHangulC:

; 145  : 			}
; 146  : 			else
; 147  : 			{
; 148  : 				code2=str[i];

  00055	8a 16		 mov	 dl, BYTE PTR [esi]

; 149  : 				i++;

  00057	46		 inc	 esi

; 150  : 				code=code2 | (code1<<8);
; 151  : 
; 152  : 				if ((code)>0)

  00058	84 d2		 test	 dl, dl
  0005a	74 10		 je	 SHORT $LN16@StrHangulC

; 153  : 				{
; 154  : 					szTemp[n]=code1;

  0005c	88 08		 mov	 BYTE PTR [eax], cl

; 155  : 					n++;
; 156  : 					szTemp[n]=code2;

  0005e	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 157  : 					n++;

  00061	83 c0 02	 add	 eax, 2

; 158  : 				}
; 159  : 				else
; 160  : 				{
; 161  : 					result =0;
; 162  : 				}
; 163  : 				if(code2==0)

  00064	84 d2		 test	 dl, dl
  00066	74 04		 je	 SHORT $LN16@StrHangulC
$LN1@StrHangulC:

; 126  : 
; 127  : 
; 128  : 	while ((count--) != 0)

  00068	85 ff		 test	 edi, edi
  0006a	75 d7		 jne	 SHORT $LL9@StrHangulC
$LN16@StrHangulC:
  0006c	5f		 pop	 edi

; 164  : 				{
; 165  : 					break;
; 166  : 				}
; 167  : 			}
; 168  : 		}
; 169  : 	}
; 170  : 	
; 171  : 	
; 172  : 	strcpy(str, szTemp);

  0006d	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00073	8b d3		 mov	 edx, ebx
  00075	8b c8		 mov	 ecx, eax
  00077	5e		 pop	 esi
  00078	2b d1		 sub	 edx, ecx
  0007a	5b		 pop	 ebx
  0007b	eb 03 8d 49 00	 npad	 5
$LL12@StrHangulC:
  00080	8a 08		 mov	 cl, BYTE PTR [eax]
  00082	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00085	40		 inc	 eax
  00086	84 c9		 test	 cl, cl
  00088	75 f6		 jne	 SHORT $LL12@StrHangulC

; 173  : 	return TRUE;
; 174  : }

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008d	33 cd		 xor	 ecx, ebp
  0008f	b8 01 00 00 00	 mov	 eax, 1
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
?StrHangulCheck@@YAHPAD@Z ENDP				; StrHangulCheck
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_02CPIDLAI@at?$AA@				; `string'
PUBLIC	?FileSaveString@@YAXPAD0@Z			; FileSaveString
EXTRN	_fclose:PROC
EXTRN	_fprintf:PROC
EXTRN	_fopen:PROC
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CPIDLAI@at?$AA@
CONST	SEGMENT
??_C@_02CPIDLAI@at?$AA@ DB 'at', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?FileSaveString@@YAXPAD0@Z
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_string$ = 12						; size = 4
?FileSaveString@@YAXPAD0@Z PROC				; FileSaveString, COMDAT

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 179  : 	FILE* fp;
; 180  : 	
; 181  : 	fp=fopen(filename, "at");

  00003	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00006	56		 push	 esi
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_02CPIDLAI@at?$AA@
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _fopen
  00012	8b f0		 mov	 esi, eax
  00014	83 c4 08	 add	 esp, 8

; 182  : 
; 183  : 	if (fp==0)

  00017	85 f6		 test	 esi, esi
  00019	74 1e		 je	 SHORT $LN1@FileSaveSt

; 184  : 	{
; 185  : 		return;
; 186  : 	}
; 187  : 	else
; 188  : 	{
; 189  : 		fprintf(fp, string);

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _string$[ebp]
  0001e	51		 push	 ecx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _fprintf

; 190  : 		fprintf(fp, "\n");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 _fprintf

; 191  : 		fclose(fp);

  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 _fclose
  00036	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@FileSaveSt:
  00039	5e		 pop	 esi

; 192  : 	}
; 193  : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?FileSaveString@@YAXPAD0@Z ENDP				; FileSaveString
_TEXT	ENDS
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	?IsFile@@YAHPAD@Z				; IsFile
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?IsFile@@YAHPAD@Z
_TEXT	SEGMENT
_filename$ = 8						; size = 4
?IsFile@@YAHPAD@Z PROC					; IsFile, COMDAT

; 201  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : FILE *fp;
; 203  : 	
; 204  : 	fp=fopen(filename,"rb");

  00003	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _fopen
  00011	83 c4 08	 add	 esp, 8

; 205  : 	if (fp==0)

  00014	85 c0		 test	 eax, eax
  00016	75 02		 jne	 SHORT $LN2@IsFile

; 213  : 	}
; 214  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN2@IsFile:

; 206  : 	{
; 207  : 		return FALSE;
; 208  : 	}
; 209  : 	else
; 210  : 	{
; 211  : 		fclose(fp);

  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _fclose
  00020	83 c4 04	 add	 esp, 4

; 212  : 		return TRUE;

  00023	b8 01 00 00 00	 mov	 eax, 1

; 213  : 	}
; 214  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?IsFile@@YAHPAD@Z ENDP					; IsFile
_TEXT	ENDS
PUBLIC	?PHeadSetB@@YAXPAEEH@Z				; PHeadSetB
; Function compile flags: /Ogtp
;	COMDAT ?PHeadSetB@@YAXPAEEH@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 4
?PHeadSetB@@YAXPAEEH@Z PROC				; PHeadSetB, COMDAT

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 	lpBuf[0] =0xC1;		// Packets

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 235  : 	lpBuf[1] =size;

  00006	8a 4d 10	 mov	 cl, BYTE PTR _size$[ebp]

; 236  : 	lpBuf[2] =head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  0000f	88 48 01	 mov	 BYTE PTR [eax+1], cl
  00012	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 237  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?PHeadSetB@@YAXPAEEH@Z ENDP				; PHeadSetB
_TEXT	ENDS
PUBLIC	?PHeadSubSetB@@YAXPAEEEH@Z			; PHeadSubSetB
; Function compile flags: /Ogtp
;	COMDAT ?PHeadSubSetB@@YAXPAEEEH@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 4
?PHeadSubSetB@@YAXPAEEEH@Z PROC				; PHeadSubSetB, COMDAT

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 242  : 	lpBuf[0] =0xC1;	// Packets

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 243  : 	lpBuf[1] =size;

  00006	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]

; 244  : 	lpBuf[2] =head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 245  : 	lpBuf[3] =sub;

  0000f	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  00012	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  00015	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00018	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 246  : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?PHeadSubSetB@@YAXPAEEEH@Z ENDP				; PHeadSubSetB
_TEXT	ENDS
PUBLIC	?strchr@@YAPADPADH@Z				; strchr
EXTRN	_strchr:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\string.h
;	COMDAT ?strchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADPADH@Z PROC				; strchr, COMDAT

; 215  : 	{ return (char*)strchr((const char*)_Str, _Ch); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	e9 00 00 00 00	 jmp	 _strchr
?strchr@@YAPADPADH@Z ENDP				; strchr
_TEXT	ENDS
PUBLIC	?PHeadSetW@@YAXPAEEH@Z				; PHeadSetW
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\winutil.cpp
;	COMDAT ?PHeadSetW@@YAXPAEEH@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 4
?PHeadSetW@@YAXPAEEH@Z PROC				; PHeadSetW, COMDAT

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 250  : 	lpBuf[0] = 0xC2;	// Packets Header

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 251  : 	lpBuf[1]= SET_NUMBERH(size);

  00006	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  00009	8b d1		 mov	 edx, ecx

; 252  : 	lpBuf[2]= SET_NUMBERL(size);

  0000b	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 253  : 	lpBuf[3]= head;

  0000e	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00011	c1 ea 08	 shr	 edx, 8
  00014	c6 00 c2	 mov	 BYTE PTR [eax], 194	; 000000c2H
  00017	88 50 01	 mov	 BYTE PTR [eax+1], dl
  0001a	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 254  : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?PHeadSetW@@YAXPAEEH@Z ENDP				; PHeadSetW
_TEXT	ENDS
PUBLIC	?PHeadSubSetW@@YAXPAEEEH@Z			; PHeadSubSetW
; Function compile flags: /Ogtp
;	COMDAT ?PHeadSubSetW@@YAXPAEEEH@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 4
?PHeadSubSetW@@YAXPAEEEH@Z PROC				; PHeadSubSetW, COMDAT

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 258  : 	lpBuf[0]=0xC2;	// packet header
; 259  : 	lpBuf[1]=SET_NUMBERH(size);

  00003	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00009	8b d1		 mov	 edx, ecx
  0000b	c1 ea 08	 shr	 edx, 8
  0000e	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 260  : 	lpBuf[2]=SET_NUMBERL(size);
; 261  : 	lpBuf[3]=head;
; 262  : 	lpBuf[4]=sub;

  00011	8a 55 10	 mov	 dl, BYTE PTR _sub$[ebp]
  00014	88 48 02	 mov	 BYTE PTR [eax+2], cl
  00017	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  0001a	c6 00 c2	 mov	 BYTE PTR [eax], 194	; 000000c2H
  0001d	88 48 03	 mov	 BYTE PTR [eax+3], cl
  00020	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 263  : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?PHeadSubSetW@@YAXPAEEEH@Z ENDP				; PHeadSubSetW
_TEXT	ENDS
PUBLIC	?PHeadSetBE@@YAXPAEEH@Z				; PHeadSetBE
; Function compile flags: /Ogtp
;	COMDAT ?PHeadSetBE@@YAXPAEEH@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 4
?PHeadSetBE@@YAXPAEEH@Z PROC				; PHeadSetBE, COMDAT

; 267  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 268  : 	lpBuf[0] =0xC3;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 269  : 	lpBuf[1] =size;

  00006	8a 4d 10	 mov	 cl, BYTE PTR _size$[ebp]

; 270  : 	lpBuf[2] =head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	c6 00 c3	 mov	 BYTE PTR [eax], 195	; 000000c3H
  0000f	88 48 01	 mov	 BYTE PTR [eax+1], cl
  00012	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 271  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?PHeadSetBE@@YAXPAEEH@Z ENDP				; PHeadSetBE
_TEXT	ENDS
PUBLIC	?PHeadSubSetBE@@YAXPAEEEH@Z			; PHeadSubSetBE
; Function compile flags: /Ogtp
;	COMDAT ?PHeadSubSetBE@@YAXPAEEEH@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 4
?PHeadSubSetBE@@YAXPAEEEH@Z PROC			; PHeadSubSetBE, COMDAT

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 275  : 	lpBuf[0] =0xC3;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 276  : 	lpBuf[1] =size;

  00006	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]

; 277  : 	lpBuf[2] =head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 278  : 	lpBuf[3] =sub;

  0000f	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  00012	c6 00 c3	 mov	 BYTE PTR [eax], 195	; 000000c3H
  00015	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00018	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 279  : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?PHeadSubSetBE@@YAXPAEEEH@Z ENDP			; PHeadSubSetBE
_TEXT	ENDS
EXTRN	__localtime64:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _localtime
_TEXT	SEGMENT
_localtime PROC						; COMDAT
; __Time$ = eax

; 114  : #pragma warning( push )
; 115  : #pragma warning( disable : 4996 )
; 116  :     return _localtime64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __localtime64
  00006	83 c4 04	 add	 esp, 4

; 117  : #pragma warning( pop )
; 118  : }

  00009	c3		 ret	 0
_localtime ENDP
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	?SQLSyntexCheck@@YAHPAD@Z			; SQLSyntexCheck
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\winutil.cpp
;	COMDAT ?SQLSyntexCheck@@YAHPAD@Z
_TEXT	SEGMENT
_SQLString$ = 8						; size = 4
?SQLSyntexCheck@@YAHPAD@Z PROC				; SQLSyntexCheck, COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 28   : 	char* temp;
; 29   : 
; 30   : 	temp=strchr(SQLString, 39);

  00004	8b 75 08	 mov	 esi, DWORD PTR _SQLString$[ebp]
  00007	6a 27		 push	 39			; 00000027H
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 _strchr
  0000f	83 c4 08	 add	 esp, 8

; 31   : 	if (temp==0)

  00012	85 c0		 test	 eax, eax
  00014	75 13		 jne	 SHORT $LN4@SQLSyntexC

; 32   : 	{
; 33   : 		temp=strchr(SQLString, 32);

  00016	6a 20		 push	 32			; 00000020H
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _strchr
  0001e	83 c4 08	 add	 esp, 8

; 34   : 		if (temp==0)

  00021	f7 d8		 neg	 eax
  00023	1b c0		 sbb	 eax, eax
  00025	40		 inc	 eax
  00026	5e		 pop	 esi

; 46   : 	}
; 47   : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN4@SQLSyntexC:

; 35   : 		{
; 36   : 			return TRUE;
; 37   : 		}
; 38   : 		else
; 39   : 		{
; 40   : 			return FALSE;
; 41   : 		}
; 42   : 	}
; 43   : 	else
; 44   : 	{
; 45   : 		return FALSE;

  00029	33 c0		 xor	 eax, eax
  0002b	5e		 pop	 esi

; 46   : 	}
; 47   : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?SQLSyntexCheck@@YAHPAD@Z ENDP				; SQLSyntexCheck
_TEXT	ENDS
PUBLIC	??_C@_02OHHJMEON@?8?8?$AA@			; `string'
PUBLIC	_SQLString$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?SQLSyntexCheckConvert@@YAHPAD@Z		; SQLSyntexCheckConvert
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_02OHHJMEON@?8?8?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\string.h
CONST	SEGMENT
??_C@_02OHHJMEON@?8?8?$AA@ DB '''''', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\winutil.cpp
CONST	ENDS
;	COMDAT ?SQLSyntexCheckConvert@@YAHPAD@Z
_TEXT	SEGMENT
_SQLString$GSCopy$ = -264				; size = 4
_tempSQL$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_SQLString$ = 8						; size = 4
?SQLSyntexCheckConvert@@YAHPAD@Z PROC			; SQLSyntexCheckConvert, COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _SQLString$[ebp]

; 51   : 	char tempSQL[256];
; 52   : 	char* temp;
; 53   : 	char* temp2;
; 54   : 
; 55   : 	temp2 = SQLString;
; 56   : 	int lOfs=0;
; 57   : 	int tOfs=0;

  00019	33 db		 xor	 ebx, ebx

; 85   : 			
; 86   : 		}
; 87   : 		else
; 88   : 		{
; 89   : 			strcpy(&tempSQL[tOfs], temp2);

  0001b	89 bd f8 fe ff
	ff		 mov	 DWORD PTR _SQLString$GSCopy$[ebp], edi
  00021	8b f7		 mov	 esi, edi
  00023	85 ff		 test	 edi, edi
  00025	75 13		 jne	 SHORT $LN13@SQLSyntexC@2

; 58   : 	int sOfs=0;
; 59   : 
; 60   : 	
; 61   : 
; 62   : 	if (SQLString==0)
; 63   : 	{
; 64   : 		return FALSE;

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	33 c0		 xor	 eax, eax
  0002b	5b		 pop	 ebx

; 96   : 	return TRUE;
; 97   : }

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002f	33 cd		 xor	 ecx, ebp
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN13@SQLSyntexC@2:

; 65   : 	}
; 66   : 	while (true)
; 67   : 	{
; 68   : 		temp = strchr(temp2, 39);

  0003a	6a 27		 push	 39			; 00000027H
  0003c	57		 push	 edi
  0003d	e8 00 00 00 00	 call	 _strchr
  00042	83 c4 08	 add	 esp, 8

; 69   : 		if (temp != 0 )

  00045	85 c0		 test	 eax, eax
  00047	74 67		 je	 SHORT $LN3@SQLSyntexC@2
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL5@SQLSyntexC@2:

; 70   : 		{
; 71   : 			if (temp - temp2 != 0)

  00050	8b f8		 mov	 edi, eax
  00052	2b fe		 sub	 edi, esi
  00054	74 12		 je	 SHORT $LN2@SQLSyntexC@2

; 72   : 			{
; 73   : 				memcpy(&tempSQL[tOfs], temp2, temp-temp2);

  00056	57		 push	 edi
  00057	8d 84 1d fc fe
	ff ff		 lea	 eax, DWORD PTR _tempSQL$[ebp+ebx]
  0005e	56		 push	 esi
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _memcpy
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SQLSyntexC@2:

; 74   : 			}
; 75   : 			lOfs = temp - (temp2 + sOfs);
; 76   : 			tOfs += lOfs;

  00068	03 df		 add	 ebx, edi

; 77   : 			temp2 += lOfs;
; 78   : 
; 79   : 			tempSQL[tOfs]=0;

  0006a	c6 84 1d fc fe
	ff ff 00	 mov	 BYTE PTR _tempSQL$[ebp+ebx], 0

; 80   : 
; 81   : 			tOfs += 2;
; 82   : 			temp2++;
; 83   : 
; 84   : 			strcat(tempSQL, "''");

  00072	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _tempSQL$[ebp]
  00078	83 c3 02	 add	 ebx, 2
  0007b	8d 74 3e 01	 lea	 esi, DWORD PTR [esi+edi+1]
  0007f	48		 dec	 eax
$LL16@SQLSyntexC@2:
  00080	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00083	40		 inc	 eax
  00084	84 c9		 test	 cl, cl
  00086	75 f8		 jne	 SHORT $LL16@SQLSyntexC@2
  00088	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ??_C@_02OHHJMEON@?8?8?$AA@
  0008f	8a 15 02 00 00
	00		 mov	 dl, BYTE PTR ??_C@_02OHHJMEON@?8?8?$AA@+2
  00095	6a 27		 push	 39			; 00000027H
  00097	66 89 08	 mov	 WORD PTR [eax], cx
  0009a	56		 push	 esi
  0009b	88 50 02	 mov	 BYTE PTR [eax+2], dl
  0009e	e8 00 00 00 00	 call	 _strchr
  000a3	83 c4 08	 add	 esp, 8
  000a6	85 c0		 test	 eax, eax
  000a8	75 a6		 jne	 SHORT $LL5@SQLSyntexC@2

; 69   : 		if (temp != 0 )

  000aa	8b bd f8 fe ff
	ff		 mov	 edi, DWORD PTR _SQLString$GSCopy$[ebp]
$LN3@SQLSyntexC@2:

; 85   : 			
; 86   : 		}
; 87   : 		else
; 88   : 		{
; 89   : 			strcpy(&tempSQL[tOfs], temp2);

  000b0	8d 9c 1d fc fe
	ff ff		 lea	 ebx, DWORD PTR _tempSQL$[ebp+ebx]
  000b7	2b de		 sub	 ebx, esi
  000b9	8d a4 24 00 00
	00 00		 npad	 7
$LL9@SQLSyntexC@2:
  000c0	8a 06		 mov	 al, BYTE PTR [esi]
  000c2	88 04 33	 mov	 BYTE PTR [ebx+esi], al
  000c5	46		 inc	 esi
  000c6	84 c0		 test	 al, al
  000c8	75 f6		 jne	 SHORT $LL9@SQLSyntexC@2

; 90   : 			break;
; 91   : 		}
; 92   : 	}
; 93   : 
; 94   : 	
; 95   : 	strcpy(SQLString, tempSQL);		// Strange unseless jump here

  000ca	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _tempSQL$[ebp]
  000d0	8b d7		 mov	 edx, edi
  000d2	8b c8		 mov	 ecx, eax
  000d4	2b d1		 sub	 edx, ecx
$LL10@SQLSyntexC@2:
  000d6	8a 08		 mov	 cl, BYTE PTR [eax]
  000d8	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000db	40		 inc	 eax
  000dc	84 c9		 test	 cl, cl
  000de	75 f6		 jne	 SHORT $LL10@SQLSyntexC@2

; 96   : 	return TRUE;
; 97   : }

  000e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi
  000e5	33 cd		 xor	 ecx, ebp
  000e7	b8 01 00 00 00	 mov	 eax, 1
  000ec	5b		 pop	 ebx
  000ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c3		 ret	 0
?SQLSyntexCheckConvert@@YAHPAD@Z ENDP			; SQLSyntexCheckConvert
_TEXT	ENDS
PUBLIC	?SpaceSyntexCheck@@YAHPAD@Z			; SpaceSyntexCheck
; Function compile flags: /Ogtp
;	COMDAT ?SpaceSyntexCheck@@YAHPAD@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?SpaceSyntexCheck@@YAHPAD@Z PROC			; SpaceSyntexCheck, COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	char* temp;
; 103  : 	
; 104  : 	temp = strchr(string, 32);

  00003	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00006	6a 20		 push	 32			; 00000020H
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _strchr
  0000e	83 c4 08	 add	 esp, 8

; 105  : 	if (temp ==0 )

  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 106  : 	{
; 107  : 		return TRUE;
; 108  : 	}
; 109  : 	else
; 110  : 	{
; 111  : 		return FALSE;
; 112  : 	}
; 113  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?SpaceSyntexCheck@@YAHPAD@Z ENDP			; SpaceSyntexCheck
_TEXT	ENDS
PUBLIC	??_C@_0N@NMLPILGG@?$CF02d?$CF02d?$CF02d?$AA@	; `string'
PUBLIC	?GetTodayString@@YAXPAD@Z			; GetTodayString
EXTRN	__imp__wsprintfA:PROC
;	COMDAT ??_C@_0N@NMLPILGG@?$CF02d?$CF02d?$CF02d?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
CONST	SEGMENT
??_C@_0N@NMLPILGG@?$CF02d?$CF02d?$CF02d?$AA@ DB '%02d%02d%02d', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\winutil.cpp
CONST	ENDS
;	COMDAT ?GetTodayString@@YAXPAD@Z
_TEXT	SEGMENT
_ltime$ = -8						; size = 8
_szDate$ = 8						; size = 4
?GetTodayString@@YAXPAD@Z PROC				; GetTodayString, COMDAT

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 219  : 	tm* today;
; 220  : 	time_t ltime;
; 221  : 	
; 222  : 
; 223  : 	time(&ltime);

  00003	8d 45 f8	 lea	 eax, DWORD PTR _ltime$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __time64

; 224  : 	today=localtime(&ltime);

  0000f	8d 4d f8	 lea	 ecx, DWORD PTR _ltime$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 __localtime64

; 225  : 
; 226  : 	today->tm_year = today->tm_year +1900;

  00018	81 40 14 6c 07
	00 00		 add	 DWORD PTR [eax+20], 1900 ; 0000076cH
  0001f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]

; 227  : 
; 228  : 	wsprintf(szDate, "%02d%02d%02d", today->tm_year , today->tm_mon +1 , today->tm_mday );

  00022	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00025	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00028	52		 push	 edx
  00029	40		 inc	 eax
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _szDate$[ebp]
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NMLPILGG@?$CF02d?$CF02d?$CF02d?$AA@
  00034	51		 push	 ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0003b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 229  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?GetTodayString@@YAXPAD@Z ENDP				; GetTodayString
_TEXT	ENDS
END
